Project Path: arc_gmh5225_fibratus_8rfg7lyg

Source Tree:

```txt
arc_gmh5225_fibratus_8rfg7lyg
├── CONTRIBUTING.md
├── LICENSE.MD
├── README.md
├── build
│   └── msi
│       ├── LICENSE.rtf
│       ├── background.png
│       ├── banner.png
│       └── fibratus.wxs
├── cmd
│   └── fibratus
│       ├── app
│       │   ├── capture_windows.go
│       │   ├── config.go
│       │   ├── control_service_windows.go
│       │   ├── docs.go
│       │   ├── install_service_windows.go
│       │   ├── list.go
│       │   ├── remove_service_windows.go
│       │   ├── replay_windows.go
│       │   ├── root.go
│       │   ├── run_windows.go
│       │   ├── stats.go
│       │   └── version.go
│       ├── common
│       │   ├── init_windows.go
│       │   └── signals.go
│       ├── fibratus.exe.manifest
│       ├── fibratus.rc
│       ├── main_windows.go
│       └── version.h
├── configs
│   ├── fibratus.json
│   ├── fibratus.yml
│   └── rules
│       └── default
│           ├── default.yml
│           ├── stateful.yml
│           └── values.yml
├── docs
│   ├── CNAME
│   ├── README.md
│   ├── _coverpage.md
│   ├── _sidebar.md
│   ├── alerts
│   │   ├── filaments.md
│   │   ├── introduction.md
│   │   ├── senders
│   │   │   ├── mail.md
│   │   │   └── slack.md
│   │   └── senders.md
│   ├── captures
│   │   ├── capturing.md
│   │   ├── introduction.md
│   │   └── replaying.md
│   ├── favicon.ico
│   ├── filaments
│   │   ├── executing.md
│   │   ├── internals.md
│   │   ├── introduction.md
│   │   └── writing.md
│   ├── filters
│   │   ├── fields.md
│   │   ├── filtering.md
│   │   ├── functions.md
│   │   ├── introduction.md
│   │   ├── operators.md
│   │   ├── paths.md
│   │   ├── prefiltering.md
│   │   └── rules.md
│   ├── images
│   │   ├── fibratus-term.gif
│   │   └── fibratus-term.png
│   ├── index.html
│   ├── kevents
│   │   ├── anatomy.md
│   │   ├── file.md
│   │   ├── handle.md
│   │   ├── image.md
│   │   ├── network.md
│   │   ├── process.md
│   │   ├── registry.md
│   │   └── thread.md
│   ├── logo.png
│   ├── nav.md
│   ├── outputs
│   │   ├── console.md
│   │   ├── elasticsearch.md
│   │   ├── eventlog.md
│   │   ├── http.md
│   │   ├── images
│   │   │   ├── eventlog-details.png
│   │   │   └── eventlog-general.png
│   │   ├── introduction.md
│   │   ├── null.md
│   │   └── rabbitmq.md
│   ├── overview
│   │   └── what-is-fibratus.md
│   ├── pe
│   │   ├── introduction.md
│   │   ├── resources.md
│   │   ├── sections.md
│   │   └── symbols.md
│   ├── setup
│   │   ├── configuration.md
│   │   ├── images
│   │   │   └── fibratus-installer-msi.png
│   │   ├── installation.md
│   │   └── running.md
│   ├── themes
│   │   └── fibratus.css
│   ├── transformers
│   │   ├── introduction.md
│   │   ├── remove.md
│   │   ├── rename.md
│   │   ├── replace.md
│   │   ├── tags.md
│   │   └── trim.md
│   ├── troubleshooting
│   │   ├── logs.md
│   │   ├── pprof.md
│   │   └── stats.md
│   └── yara
│       ├── alerts.md
│       ├── introduction.md
│       └── scanning.md
├── filaments
│   ├── README.md
│   ├── fishy_netio.py
│   ├── registry_persistence.py
│   ├── teamviewer_remote_file_copy.py
│   ├── top_in_packets.py
│   ├── top_keys.py
│   ├── top_out_packets.py
│   ├── utils
│   │   └── dotdict.py
│   └── watch_files.py
├── go.mod
├── go.sum
├── logo.png
├── make.bat
├── pkg
│   ├── aggregator
│   │   ├── aggregator.go
│   │   ├── aggregator_test.go
│   │   ├── config.go
│   │   ├── submitter.go
│   │   ├── transformers
│   │   │   ├── config.go
│   │   │   ├── remove
│   │   │   │   ├── config.go
│   │   │   │   ├── remove.go
│   │   │   │   └── remove_test.go
│   │   │   ├── rename
│   │   │   │   ├── config.go
│   │   │   │   ├── rename.go
│   │   │   │   └── rename_test.go
│   │   │   ├── replace
│   │   │   │   ├── config.go
│   │   │   │   ├── replace.go
│   │   │   │   └── replace_test.go
│   │   │   ├── tags
│   │   │   │   ├── config.go
│   │   │   │   ├── tags.go
│   │   │   │   └── tags_test.go
│   │   │   ├── transformer.go
│   │   │   └── trim
│   │   │       ├── config.go
│   │   │       ├── trim.go
│   │   │       └── trim_test.go
│   │   ├── worker.go
│   │   └── worker_test.go
│   ├── alertsender
│   │   ├── alert.go
│   │   ├── config.go
│   │   ├── mail
│   │   │   ├── config.go
│   │   │   └── mail.go
│   │   ├── sender.go
│   │   └── slack
│   │       ├── config.go
│   │       └── slack.go
│   ├── api
│   │   ├── handler
│   │   │   └── config.go
│   │   ├── listener.go
│   │   ├── server.go
│   │   └── server_windows.go
│   ├── config
│   │   ├── _fixtures
│   │   │   ├── eventlog-output.yml
│   │   │   ├── fibratus.json
│   │   │   ├── fibratus.yml
│   │   │   ├── filters
│   │   │   │   ├── default-new-attributes.yml
│   │   │   │   ├── default.yml
│   │   │   │   ├── filter_action_in_exclude_group.yml
│   │   │   │   ├── invalid_filter_action.yml
│   │   │   │   ├── invalid_filter_action_values.yml
│   │   │   │   └── values
│   │   │   │       ├── default.yml
│   │   │   │       └── values.yml
│   │   │   ├── http-output.yml
│   │   │   ├── output.yml
│   │   │   └── transformers.yml
│   │   ├── alertsender.go
│   │   ├── api.go
│   │   ├── config_windows.go
│   │   ├── config_windows_test.go
│   │   ├── decoder.go
│   │   ├── filament.go
│   │   ├── filters.go
│   │   ├── filters_test.go
│   │   ├── kstream.go
│   │   ├── kstream_test.go
│   │   ├── output.go
│   │   ├── output_test.go
│   │   ├── print.go
│   │   ├── print_test.go
│   │   ├── schema_windows.go
│   │   ├── transformer.go
│   │   ├── transformer_test.go
│   │   ├── validation.go
│   │   └── validation_test.go
│   ├── errors
│   │   ├── errors.go
│   │   └── errors_windows.go
│   ├── filament
│   │   ├── _fixtures
│   │   │   ├── test_filter.py
│   │   │   ├── test_on_next_kevent.py
│   │   │   ├── top_hives_io.py
│   │   │   └── top_keys_io_table.py
│   │   ├── cpython
│   │   │   ├── _fixtures
│   │   │   │   └── top_hives_io.py
│   │   │   ├── api.c
│   │   │   ├── api.h
│   │   │   ├── dict.go
│   │   │   ├── dict_test.go
│   │   │   ├── errors.go
│   │   │   ├── gil.go
│   │   │   ├── gil_test.go
│   │   │   ├── interpreter.go
│   │   │   ├── interpreter_test.go
│   │   │   ├── ip.go
│   │   │   ├── module.go
│   │   │   ├── module_test.go
│   │   │   ├── object.go
│   │   │   ├── sequence.go
│   │   │   └── string.go
│   │   ├── filament.go
│   │   ├── filament_test.go
│   │   ├── filament_unsupported.go
│   │   ├── kdict.go
│   │   ├── kdict_test.go
│   │   ├── table.go
│   │   ├── table_test.go
│   │   └── types.go
│   ├── filter
│   │   ├── _fixtures
│   │   │   ├── default
│   │   │   │   ├── default.yml
│   │   │   │   └── values.yml
│   │   │   ├── exclude_policy_and.yml
│   │   │   ├── exclude_policy_and_no_include_groups.yml
│   │   │   ├── exclude_policy_or.yml
│   │   │   ├── exclude_policy_or_different_include_group.yml
│   │   │   ├── exclude_policy_or_no_include_groups.yml
│   │   │   ├── groups_type_selector.yml
│   │   │   ├── include_exclude_remote_threads.yml
│   │   │   ├── include_policy_and.yml
│   │   │   ├── include_policy_and_not_matches.yml
│   │   │   ├── include_policy_emit_alert.yml
│   │   │   ├── include_policy_or.yml
│   │   │   ├── merged_groups.yml
│   │   │   ├── sequence_policy_complex_pattern_bindings.yml
│   │   │   ├── sequence_policy_simple.yml
│   │   │   ├── sequence_policy_simple_max_span.yml
│   │   │   ├── sequence_policy_simple_pattern_bindings.yml
│   │   │   └── values.yml
│   │   ├── accessor.go
│   │   ├── accessor_windows.go
│   │   ├── accessor_windows_test.go
│   │   ├── fields
│   │   │   ├── fields.go
│   │   │   ├── fields_windows.go
│   │   │   └── fields_windows_test.go
│   │   ├── filter.go
│   │   ├── filter_test.go
│   │   ├── filter_windows.go
│   │   ├── funcmap
│   │   │   └── funcmap_windows.go
│   │   ├── ql
│   │   │   ├── ast.go
│   │   │   ├── error.go
│   │   │   ├── error_test.go
│   │   │   ├── expr.go
│   │   │   ├── function.go
│   │   │   ├── function_test.go
│   │   │   ├── functions
│   │   │   │   ├── cidr.go
│   │   │   │   ├── cidr_test.go
│   │   │   │   ├── concat.go
│   │   │   │   ├── concat_test.go
│   │   │   │   ├── entropy.go
│   │   │   │   ├── entropy_test.go
│   │   │   │   ├── indexof.go
│   │   │   │   ├── indexof_test.go
│   │   │   │   ├── length.go
│   │   │   │   ├── length_test.go
│   │   │   │   ├── lower.go
│   │   │   │   ├── lower_test.go
│   │   │   │   ├── ltrim.go
│   │   │   │   ├── ltrim_test.go
│   │   │   │   ├── md5.go
│   │   │   │   ├── md5_test.go
│   │   │   │   ├── regex.go
│   │   │   │   ├── regex_test.go
│   │   │   │   ├── replace.go
│   │   │   │   ├── replace_test.go
│   │   │   │   ├── rtrim.go
│   │   │   │   ├── rtrim_test.go
│   │   │   │   ├── split.go
│   │   │   │   ├── split_test.go
│   │   │   │   ├── substr.go
│   │   │   │   ├── substr_test.go
│   │   │   │   ├── types.go
│   │   │   │   ├── upper.go
│   │   │   │   └── upper_test.go
│   │   │   ├── lexer.go
│   │   │   ├── lexer_test.go
│   │   │   ├── literal.go
│   │   │   ├── parser.go
│   │   │   ├── parser_test.go
│   │   │   ├── token.go
│   │   │   └── visitor.go
│   │   ├── rules.go
│   │   └── rules_test.go
│   ├── fs
│   │   ├── _fixtures
│   │   ├── attrs.go
│   │   ├── dev.go
│   │   ├── dev_test.go
│   │   ├── file.go
│   │   ├── file_test.go
│   │   └── types.go
│   ├── handle
│   │   ├── _fixtures
│   │   ├── alpc.go
│   │   ├── key.go
│   │   ├── key_test.go
│   │   ├── mutant.go
│   │   ├── object.go
│   │   ├── object_test.go
│   │   ├── snapshotter.go
│   │   ├── snapshotter_mock.go
│   │   ├── snapshotter_test.go
│   │   ├── timeout.go
│   │   ├── timeout_test.go
│   │   ├── types
│   │   │   ├── marshaller.go
│   │   │   ├── marshaller_test.go
│   │   │   └── types.go
│   │   └── types.go
│   ├── kcap
│   │   ├── _fixtures
│   │   │   ├── cap.kcap
│   │   │   ├── cap1.kcap
│   │   │   └── test.kcap
│   │   ├── config.go
│   │   ├── header.go
│   │   ├── reader.go
│   │   ├── reader_unsupported.go
│   │   ├── reader_windows.go
│   │   ├── reader_windows_test.go
│   │   ├── section
│   │   │   ├── section.go
│   │   │   ├── section_windows.go
│   │   │   └── section_windows_test.go
│   │   ├── types_linux.go
│   │   ├── types_windows.go
│   │   ├── version
│   │   │   └── version_windows.go
│   │   ├── writer.go
│   │   ├── writer_unsupported.go
│   │   ├── writer_windows.go
│   │   └── writer_windows_test.go
│   ├── kevent
│   │   ├── README.md
│   │   ├── _fixtures
│   │   │   └── handles.json
│   │   ├── batch.go
│   │   ├── batch_test.go
│   │   ├── doc.go
│   │   ├── formatter.go
│   │   ├── formatter_test.go
│   │   ├── formatter_windows.go
│   │   ├── kevent.go
│   │   ├── kevent_windows.go
│   │   ├── kevent_windows_test.go
│   │   ├── kparam.go
│   │   ├── kparam_test.go
│   │   ├── kparam_windows.go
│   │   ├── kparams
│   │   │   ├── canonicalize.go
│   │   │   ├── canonicalize_test.go
│   │   │   ├── fields_windows.go
│   │   │   ├── readers.go
│   │   │   ├── readers_test.go
│   │   │   ├── size.go
│   │   │   ├── size_test.go
│   │   │   ├── types_windows.go
│   │   │   └── types_windows_test.go
│   │   ├── ktypes
│   │   │   ├── category.go
│   │   │   ├── ktypes_windows.go
│   │   │   ├── ktypes_windows_test.go
│   │   │   ├── metainfo_windows.go
│   │   │   └── metainfo_windows_test.go
│   │   ├── marshaller.go
│   │   ├── marshaller_test.go
│   │   ├── marshaller_windows.go
│   │   ├── sequencer_windows.go
│   │   └── sequencer_windows_test.go
│   ├── kstream
│   │   ├── README.md
│   │   ├── _fixtures
│   │   │   └── snapshots
│   │   │       ├── create-process-raw.gob
│   │   │       └── create-process.gob
│   │   ├── controller_windows.go
│   │   ├── controller_windows_test.go
│   │   ├── doc.go
│   │   ├── interceptors
│   │   │   ├── chain.go
│   │   │   ├── chain_windows.go
│   │   │   ├── fs_windows.go
│   │   │   ├── fs_windows_test.go
│   │   │   ├── handle_windows.go
│   │   │   ├── handle_windows_test.go
│   │   │   ├── image_windows.go
│   │   │   ├── image_windows_test.go
│   │   │   ├── interceptor.go
│   │   │   ├── net_windows.go
│   │   │   ├── net_windows_test.go
│   │   │   ├── ps_windows.go
│   │   │   ├── ps_windows_test.go
│   │   │   ├── registry_windows.go
│   │   │   ├── registry_windows_test.go
│   │   │   └── util.go
│   │   ├── kstreamc_linux.go
│   │   ├── kstreamc_windows.go
│   │   └── kstreamc_windows_test.go
│   ├── network
│   │   ├── address.go
│   │   ├── dns.go
│   │   ├── dns_test.go
│   │   └── types.go
│   ├── outputs
│   │   ├── amqp
│   │   │   ├── _fixtures
│   │   │   │   └── garagemq
│   │   │   │       ├── README.md
│   │   │   │       ├── amqp
│   │   │   │       │   ├── constants_generated.go
│   │   │   │       │   ├── extended_constants.go
│   │   │   │       │   ├── methods_generated.go
│   │   │   │       │   ├── readers_writers.go
│   │   │   │       │   └── types.go
│   │   │   │       ├── auth
│   │   │   │       │   └── auth.go
│   │   │   │       ├── binding
│   │   │   │       │   └── binding.go
│   │   │   │       ├── config
│   │   │   │       │   ├── config.go
│   │   │   │       │   └── default.go
│   │   │   │       ├── consumer
│   │   │   │       │   └── consumer.go
│   │   │   │       ├── exchange
│   │   │   │       │   └── exchange.go
│   │   │   │       ├── interfaces
│   │   │   │       │   └── interfaces.go
│   │   │   │       ├── pool
│   │   │   │       │   └── pool.go
│   │   │   │       ├── qos
│   │   │   │       │   └── qos.go
│   │   │   │       ├── queue
│   │   │   │       │   └── queue.go
│   │   │   │       ├── safequeue
│   │   │   │       │   └── safequeue.go
│   │   │   │       └── server
│   │   │   │           ├── basicMethods.go
│   │   │   │           ├── channel.go
│   │   │   │           ├── channelMethods.go
│   │   │   │           ├── confirmMethods.go
│   │   │   │           ├── connection.go
│   │   │   │           ├── connectionMethods.go
│   │   │   │           ├── exchangeMethods.go
│   │   │   │           ├── queueMethods.go
│   │   │   │           ├── server.go
│   │   │   │           └── vhost.go
│   │   │   ├── amqp.go
│   │   │   ├── amqp_test.go
│   │   │   ├── client.go
│   │   │   └── config.go
│   │   ├── client.go
│   │   ├── config.go
│   │   ├── console
│   │   │   ├── config.go
│   │   │   └── console.go
│   │   ├── elasticsearch
│   │   │   ├── config.go
│   │   │   ├── elasticsearch.go
│   │   │   ├── elasticsearch_test.go
│   │   │   ├── index.go
│   │   │   ├── index_test.go
│   │   │   └── template.go
│   │   ├── eventlog
│   │   │   ├── api.go
│   │   │   ├── config.go
│   │   │   ├── eventlog.go
│   │   │   ├── eventlog_test.go
│   │   │   ├── mc
│   │   │   │   └── fibratus.mc
│   │   │   └── template.go
│   │   ├── http
│   │   │   ├── client.go
│   │   │   ├── config.go
│   │   │   ├── http.go
│   │   │   └── http_test.go
│   │   ├── null
│   │   │   ├── config.go
│   │   │   └── null.go
│   │   ├── outputs.go
│   │   └── serializer.go
│   ├── pe
│   │   ├── config.go
│   │   ├── doc.go
│   │   ├── entropy.go
│   │   ├── marshaller.go
│   │   ├── marshaller_test.go
│   │   ├── reader.go
│   │   ├── reader_test.go
│   │   ├── resource
│   │   │   └── types.go
│   │   ├── resources.go
│   │   ├── resources_test.go
│   │   ├── section.go
│   │   ├── section_test.go
│   │   └── types.go
│   ├── ps
│   │   ├── doc.go
│   │   ├── peb.go
│   │   ├── peb_test.go
│   │   ├── snapshotter.go
│   │   ├── snapshotter_mock.go
│   │   ├── snapshotter_windows.go
│   │   ├── snapshotter_windows_test.go
│   │   └── types
│   │       ├── marshaller_windows.go
│   │       ├── marshaller_windows_test.go
│   │       ├── types.go
│   │       ├── types_windows.go
│   │       └── types_windows_test.go
│   ├── syscall
│   │   ├── doc.go
│   │   ├── etw
│   │   │   ├── etw.go
│   │   │   └── types.go
│   │   ├── file
│   │   │   ├── file.go
│   │   │   └── types.go
│   │   ├── handle
│   │   │   └── handle.go
│   │   ├── object
│   │   │   ├── alpc.go
│   │   │   ├── event.go
│   │   │   ├── mutant.go
│   │   │   ├── object.go
│   │   │   └── types.go
│   │   ├── process
│   │   │   ├── process.go
│   │   │   ├── process_test.go
│   │   │   └── types.go
│   │   ├── registry
│   │   │   └── key.go
│   │   ├── security
│   │   │   ├── privileges.go
│   │   │   └── sid.go
│   │   ├── sys
│   │   │   └── sys.go
│   │   ├── tdh
│   │   │   ├── tdh.go
│   │   │   └── types.go
│   │   ├── thread
│   │   │   ├── thread.go
│   │   │   └── thread_test.go
│   │   ├── utf16
│   │   │   └── string.go
│   │   └── winerrno
│   │       └── errors.go
│   ├── util
│   │   ├── atomic
│   │   │   └── atomic.go
│   │   ├── bytes
│   │   │   └── bytes.go
│   │   ├── fasttemplate
│   │   │   ├── doc.go
│   │   │   ├── template.go
│   │   │   └── unsafe.go
│   │   ├── filetime
│   │   │   └── filetime.go
│   │   ├── hostname
│   │   │   └── hostname_windows.go
│   │   ├── ip
│   │   │   ├── ip.go
│   │   │   └── ip_test.go
│   │   ├── log
│   │   │   ├── _fixtures
│   │   │   │   └── fibratus.log
│   │   │   ├── config.go
│   │   │   ├── logger.go
│   │   │   ├── logger_test.go
│   │   │   └── rotate
│   │   │       └── rotate.go
│   │   ├── multierror
│   │   │   └── multierror.go
│   │   ├── ports
│   │   │   └── iana_ports.go
│   │   ├── rest
│   │   │   ├── rest.go
│   │   │   └── rest_test.go
│   │   ├── spinner
│   │   │   └── spinner.go
│   │   ├── stringcase
│   │   │   ├── camel.go
│   │   │   └── camel_test.go
│   │   ├── term
│   │   │   ├── fb.go
│   │   │   └── term.go
│   │   ├── tls
│   │   │   └── tls.go
│   │   ├── typesize
│   │   │   └── typesize.go
│   │   ├── version
│   │   │   └── version.go
│   │   └── wildcard
│   │       ├── wildcard.go
│   │       └── wildcard_test.go
│   └── yara
│       ├── _fixtures
│       │   ├── rules
│       │   │   ├── dll.yar
│       │   │   └── notepad.yar
│       │   └── yara-test.dll
│       ├── config
│       │   └── config.go
│       ├── scanner.go
│       ├── scanner_test.go
│       ├── scanner_unsupported.go
│       ├── scanner_windows.go
│       ├── types
│       │   └── types.go
│       └── types.go
└── pkg-config
    └── python-37.pc

```

`CONTRIBUTING.md`:

```md
# Contributing

We greatly appreciate you have considered contributing to Fibratus! Please, read carefully through the contribution guidelines before you start the contribution process.

## Introduction

1. **You're familiar with [Github](https://github.com) and the pull request workflow.**
2. **Make sure you've read Fibratus [docs](https://www.fibratus.io).**
3. If you got an idea about some feature that's not currently in the backlog, please create the [feature request](https://github.com/rabbitstack/fibratus/issues/new) first.

## Development

1. Clone the Fibratus repository into the location of your choice.
2. [Download](https://golang.org/dl/) and install the Go compiler.
3. If you are intending to contribute to features that interop with the `C` code, such as [filaments](https://www.fibratus.io/#/filaments/introduction) or [YARA](https://www.fibratus.io/#/yara/introduction), [set up](https://www.fibratus.io/#/setup/installation?id=installing-dependencies) the required dependencies.

#### Directory Structure

- [`/build/package`](/build/package) - [NSIS](https://nsis.sourceforge.io/Main_Page) script for producing the Windows installer.
- [`/cmd/fibratus`](/cmd/fibratus) - Contains the entrypoint, CLI command implementations and the resource compiler manifest.
- [`/config`](/config) - Configuration files in `yml` and `json` format, included in releases. [Rules](https://www.fibratus.io/#/filters/rules) files are included in the `rules` subdirectory.
- [`/docs`](/docs) - Markdown files for generating the [documentation](https://www.fibratus.io/) site.
- [`/filaments`](/filaments) - The collection of [filaments](https://www.fibratus.io/#/filaments/introduction) that are included in releases.
- [`/pkg`](/pkg) - Fibratus main source.
- [`/pkg-config`](/pkg-config) - [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/) descriptors for externalizing the `cgo` flags.

#### Make

Fibratus includes a [`make.bat`](/make.bat) in the root of the repo. The `bat` script mimics the [Makefile](https://www.gnu.org/software/make/manual/html_node/Introduction.html) execution workflow.
Running `make` will produce the Fibratus binary and place it inside `cmd\fibratus` directory. Refer to the `make.bat` file for a list of available tasks.

#### Code Style

Fibratus uses `gofmt` to format the code. Run the `make fmt` from the root directory to emit indentation blocks that are in harmony with the Go code style.

Besides this, the `golint` ensures you adhere to best practices regarding identifier naming, code docs, and so on. You can invoke the linter with `make lint`.

```

`LICENSE.MD`:

```MD
Copyright 2019-2020 by Nedim Sabic Sabic
https://www.fibratus.io

All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

```

`README.md`:

```md
---

<p align="center" >
  <a href="https://www.fibratus.io" >
    <img src="logo.png" alt="Fibratus">
  </a>
</p>

<h2 align="center">Fibratus</h2>

<p align="center">
  A modern tool for Windows kernel exploration and observability with a focus on security
  <br>
  <a href="https://www.fibratus.io/#/setup/installation"><strong>Get Started »</strong></a>
  <br>
  <br>
  <strong>
    <a href="https://www.fibratus.io">Docs</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/tree/master/filaments">Filaments</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/releases">Download</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/discussions">Discussions</a>
  </strong>
</p>

### What is Fibratus?

Fibratus is a tool for exploration and tracing of the **Windows** kernel. It lets you trap system-wide [events](https://www.fibratus.io/#/kevents/anatomy) such as process life-cycle, file system I/O, registry modifications or network requests among many other observability signals. In a nutshell, Fibratus allows for gaining deep operational visibility into the Windows kernel but also processes running on top of it. It requires no drivers nor third-party software.

Events can be shipped to a wide array of [output sinks](https://www.fibratus.io/#/outputs/introduction) or dumped to [capture](https://www.fibratus.io/#/captures/introduction) files for local inspection and forensics analysis. The powerful [filtering](https://www.fibratus.io/#/filters/introduction) engine permits drilling into the event flux entrails and the [rules engine](https://www.fibratus.io/#/filters/rules) is capable of detecting stealthy adversary attacks and sophisticated threats.

You can use [filaments](https://www.fibratus.io/#/filaments/introduction) to extend Fibratus with your own arsenal of tools and so leverage the power of the Python ecosystem

### Quick start

- Observe Microsoft Outlook attachments creating on the file system

```
fibratus run file.operation = 'create' and file.name icontains '\\Content.Outlook\\'
```

- Hunt remote thread creations

```
fibratus run kevt.name = 'CreateThread' and kevt.pid != thread.pid
```

- Record network interactions to the capture file

```
fibratus capture kevt.category = 'net' -o conns.kcap
```

- Replay events from the capture

```
fibratus replay net.dport in (443, 80) -k conns.kcap
```

- Run the filament for watching file system changes

```
fibratus run -f watch_files
```

### Features

- :zap: blazing fast
- :satellite: collects a wide spectrum of kernel events - from process to network observability signals
- :mag: super powerful filtering and rule engine
- :snake: running Python scriptlets on top of kernel event flow
- :minidisc: capturing event flux to **kcap** files and replaying anywhere
- :rocket: transporting events to Elasticsearch, RabbitMQ or console sinks
- :scissors: transforming kernel events
- :dart: scanning malicious processes and files with Yara
- :file_folder: PE (Portable Executable) introspection

### [Documentation](https://www.fibratus.io)
---

### Setup

* [**Installation**](https://www.fibratus.io/#/setup/installation)
* [**Building from source**](https://www.fibratus.io/#/setup/installation?id=building-from-source)
* [**Running as standalone binary**](https://www.fibratus.io/#/setup/running?id=standalone-binary)
* [**Running as Windows Service**](https://www.fibratus.io/#/setup/running?id=windows-service)
* [**CLI**](https://www.fibratus.io/#/setup/running?id=cli)
* [**Configuration**](https://www.fibratus.io/#/setup/configuration)

### Events

* [**Anatomy of an event**](https://www.fibratus.io/#/kevents/anatomy)
* [**Process**](https://www.fibratus.io/#/kevents/process)
* [**Thread**](https://www.fibratus.io/#/kevents/thread)
* [**Image**](https://www.fibratus.io/#/kevents/image)
* [**File**](https://www.fibratus.io/#/kevents/file)
* [**Registry**](https://www.fibratus.io/#/kevents/registry)
* [**Network**](https://www.fibratus.io/#/kevents/network)
* [**Handle**](https://www.fibratus.io/#/kevents/handle)

### Filters and Rules

* [**Needle in the haystack**](https://www.fibratus.io/#/filters/introduction)
* [**Prefiltering**](https://www.fibratus.io/#/filters/prefiltering)
* [**Filtering**](https://www.fibratus.io/#/filters/filtering)
* [**Operators**](https://www.fibratus.io/#/filters/operators)
* [**Functions**](https://www.fibratus.io/#/filters/functions)
* [**Paths**](https://www.fibratus.io/#/filters/paths)
* [**Fields**](https://www.fibratus.io/#/filters/fields)
* [**Rules**](https://www.fibratus.io/#/filters/rules)

### Captures

* [**Immortalizing the event flux**](https://www.fibratus.io/#/captures/introduction)
* [**Capturing**](https://www.fibratus.io/#/captures/capturing)
* [**Replaying**](https://www.fibratus.io/#/captures/replaying)

### Filaments

* [**Python meets kernel events**](https://www.fibratus.io/#/filaments/introduction)
* [**Executing**](https://www.fibratus.io/#/filaments/executing)
* [**Internals**](https://www.fibratus.io/#/filaments/internals)
* [**Writing filaments**](https://www.fibratus.io/#/filaments/writing)

### Outputs

* [**Transporting kernel events**](https://www.fibratus.io/#/outputs/introduction)
* [**Console**](https://www.fibratus.io/#/outputs/console)
* [**Null**](https://www.fibratus.io/#/outputs/null)
* [**RabbitMQ**](https://www.fibratus.io/#/outputs/rabbitmq)
* [**Elasticsearch**](https://www.fibratus.io/#/outputs/elasticsearch)
* [**Eventlog**](https://www.fibratus.io/#/outputs/eventlog)
* [**HTTP**](https://www.fibratus.io/#/outputs/http)


### Transformers

* [**Parsing, enriching, transforming**](https://www.fibratus.io/#/transformers/introduction)
* [**Remove**](https://www.fibratus.io/#/transformers/remove)
* [**Rename**](https://www.fibratus.io/#/transformers/rename)
* [**Replace**](https://www.fibratus.io/#/transformers/replace)
* [**Tags**](https://www.fibratus.io/#/transformers/tags)
* [**Trim**](https://www.fibratus.io/#/transformers/trim)

### Alerts

* [**Watchdogging kernel events**](https://www.fibratus.io/#/alerts/introduction)
* [**Mail**](https://www.fibratus.io/#/alerts/senders/mail)
* [**Slack**](https://www.fibratus.io/#/alerts/senders/slack)
* [**Filament alerting**](https://www.fibratus.io/#/alerts/filaments)

### PE (Portable Executable)

* [**Portable Executable introspection**](https://www.fibratus.io/#/pe/introduction)
* [**Sections**](https://www.fibratus.io/#/pe/sections)
* [**Symbols**](https://www.fibratus.io/#/pe/symbols)
* [**Resources**](https://www.fibratus.io/#/pe/resources)

### YARA

* [**Pattern matching swiss knife**](https://www.fibratus.io/#/yara/introduction)
* [**Scanning processes**](https://www.fibratus.io/#/yara/scanning)
* [**Alerts**](https://www.fibratus.io/#/yara/alerts)

### Troubleshooting

* [**Logs**](https://www.fibratus.io/#/troubleshooting/logs)
* [**Stats**](https://www.fibratus.io/#/troubleshooting/stats)
* [**Profiling**](https://www.fibratus.io/#/troubleshooting/pprof)

---

<p align="center">
  Developed with ❤️ by <strong>Nedim Šabić Šabić</strong>
</p>
<p align="center">
  Logo designed with ❤️ by <strong><a name="logo" target="_blank" href="https://github.com/karinkasweet/">Karina Slizova</a></strong>
</p>

```

`build/msi/LICENSE.rtf`:

```rtf
{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Tahoma;}{\f1\fnil Lucida Console;}{\f2\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red255\green255\blue255;}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\box\brdrdash\brdrw0 \cbpat3\sa200\sl276\slmult1\cf1\f0\fs19\lang9 Copyright 2019-2020 by Nedim Sabic Sabic\line\line All Rights Reserved.\line\line Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. \line You may obtain a copy of the License at\line\line {\cf0{\field{\*\fldinst{HYPERLINK http://www.apache.org/licenses/LICENSE-2.0 }}{\fldrslt{http://www.apache.org/licenses/LICENSE-2.0\ul0\cf0}}}}\f0\fs19\line\line Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR \line CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\line\f1\par

\pard\sa200\sl276\slmult1\cf0\f2\fs22\par
}
 
```

`build/msi/fibratus.wxs`:

```wxs
<?xml version="1.0" encoding="utf-8"?>

<?define VERSION="!(bind.fileVersion.fibratus.exe)"?>

<Wix
  xmlns="http://schemas.microsoft.com/wix/2006/wi"
  xmlns:util="http://schemas.microsoft.com/wix/UtilExtension"
  >

  <Product
    Id="*"
    UpgradeCode="E81B8794-3277-47F9-BE58-2EF2D20930EC"
    Name="Fibratus"
    Version="$(var.VERSION)"
    Manufacturer="Nedim Sabic Sabic &lt;https://www.fibratus.io&gt;"
    Language="1033"
    >
    <Package
      Id="*"
      Description="Fibratus Installer"
      InstallerVersion="200"
      Compressed="yes"
      Languages="1033"
      Platform="x64"
      />
    <MajorUpgrade
        Schedule="afterInstallInitialize"
        DowngradeErrorMessage="A later version of [ProductName] is already installed"
        AllowSameVersionUpgrades="yes" />
    <UIRef
      Id="WixUI_InstallDir"
      />
    <Property
      Id="WIXUI_INSTALLDIR"
      Value="INSTALLDIR"
      />
    <WixVariable
      Id="WixUIDialogBmp"
      Value="background.png"
      />
    <WixVariable
      Id="WixUIBannerBmp"
      Value="banner.png"
      />
    <WixVariable
      Id="WixUILicenseRtf"
      Value="LICENSE.rtf"
      />
    <Media
      Id="1"
      Cabinet="fibratus.cab"
      EmbedCab="yes"
      />
    <Directory
      Id="TARGETDIR"
      Name="SourceDir"
      >
      <Directory
        Id="ProgramFiles64Folder"
        >
        <Directory
          Id="INSTALLDIR"
          Name="Fibratus"
          >
          <Component Win64='yes' Id="Path" KeyPath="yes" Guid="E81B8794-3277-47F9-BE58-2EF2D20930EC">
              <Environment Id="PATH" Name="PATH" Value="[INSTALLDIR]Bin" Permanent="no" Part="last" Action="set" System="yes" />
          </Component>
        </Directory>
      </Directory>
    </Directory>

    <Feature
      Id="Fibratus"
      Description="The complete installation."
      Level="1"
      Display="expand"
      ConfigurableDirectory="INSTALLDIR"
      >
      <ComponentGroupRef
              Id="Fibratus"
      />
      <ComponentRef
              Id="Path"
      />
    </Feature>
  </Product>
</Wix>

```

`cmd/fibratus/app/capture_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kcap"
	"github.com/rabbitstack/fibratus/pkg/kstream"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/util/spinner"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"time"
)

var captureCmd = &cobra.Command{
	Use:   "capture [filter]",
	Short: "Capture kernel event stream to the kcap file",
	RunE:  capture,
}

var (
	// capture command config
	captureConfig = config.NewWithOpts(config.WithCapture())
)

func init() {
	captureConfig.MustViperize(captureCmd)
}

func capture(cmd *cobra.Command, args []string) error {
	// initialize config and logger
	if err := common.Init(captureConfig, true); err != nil {
		return err
	}

	// set up the signals
	stopCh := common.Signals()

	spin := spinner.Show("Snapshotting processes and handles")
	// make sure to not wait more than a minute if system handle enumeration
	// got stuck or taking too much time to complete.
	wait := make(chan struct{}, 1)
	deadline := time.AfterFunc(time.Minute, func() {
		wait <- struct{}{}
	})
	cb := func(total uint64, withName uint64) {
		deadline.Stop()
		spin.Stop()
		wait <- struct{}{}
	}

	// the capture will start after all system handles have been enumerated. This gives us a
	// chance to build the handle state before writing the event flow
	hsnap := handle.NewSnapshotter(captureConfig, cb)
	psnap := ps.NewSnapshotter(hsnap, captureConfig)

	// we'll start writing to the kcap file once we receive on the wait channel
	<-wait

	// initiate the kernel trace and start consuming from the event stream
	ktracec := kstream.NewKtraceController(captureConfig.Kstream)
	err := ktracec.StartKtrace()
	if err != nil {
		return err
	}

	kstreamc := kstream.NewConsumer(ktracec, psnap, hsnap, captureConfig)
	kfilter, err := filter.NewFromCLI(args, captureConfig)
	if err != nil {
		return err
	}
	if kfilter != nil {
		kstreamc.SetFilter(kfilter)
	}

	err = kstreamc.OpenKstream(ktracec.Traces())
	if err != nil {
		return multierror.Wrap(err, ktracec.CloseKtrace())
	}
	defer func() {
		_ = ktracec.CloseKtrace()
		_ = kstreamc.CloseKstream()
	}()

	// bootstrap kcap writer with inbound event channel
	writer, err := kcap.NewWriter(captureConfig.KcapFile, psnap, hsnap)
	if err != nil {
		return err
	}
	errsc := writer.Write(kstreamc.Events(), kstreamc.Errors())

	go func() {
		for err := range errsc {
			log.Warnf("fail to write event to kcap: %v", err)
		}
	}()

	// start rendering the spinner
	spin = spinner.Show("Capturing")

	// start the HTTP server
	if err := api.StartServer(captureConfig); err != nil {
		return err
	}

	<-stopCh
	spin.Stop()

	if err := writer.Close(); err != nil {
		return err
	}
	if err := api.CloseServer(); err != nil {
		return err
	}

	return nil
}

```

`cmd/fibratus/app/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"fmt"
	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/util/rest"
	"github.com/spf13/cobra"
	"os"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Show runtime config",
	RunE:  printConfig,
}

var (
	// config command options
	c = config.NewWithOpts(config.WithStats())
)

func init() {
	c.MustViperize(configCmd)
}

func printConfig(cmd *cobra.Command, args []string) error {
	if err := common.Init(c, false); err != nil {
		return err
	}
	body, err := rest.Get(rest.WithTransport(c.API.Transport), rest.WithURI("config"))
	if err != nil {
		return kerrors.ErrHTTPServerUnavailable(c.API.Transport, err)
	}
	_, err = fmt.Fprintln(os.Stdout, string(body))
	if err != nil {
		return err
	}
	return nil
}

```

`cmd/fibratus/app/control_service_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"fmt"
	"time"

	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/aggregator"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kstream"
	"github.com/rabbitstack/fibratus/pkg/ps"
	ver "github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/svc"
	"golang.org/x/sys/windows/svc/debug"
	"golang.org/x/sys/windows/svc/eventlog"
	"golang.org/x/sys/windows/svc/mgr"
)

var startSvcCmd = &cobra.Command{
	Use:   "start-service",
	RunE:  startService,
	Short: "Start fibratus service",
}

var stopSvcCmd = &cobra.Command{
	Use:   "stop-service",
	RunE:  stopService,
	Short: "Stop fibratus service",
}

var restartSvcCmd = &cobra.Command{
	Use:   "restart-service",
	RunE:  restartService,
	Short: "Restart fibratus service",
}

var (
	// windows service command config
	svcConfig = config.NewWithOpts(config.WithRun())

	// windows event logger
	evtlog debug.Log

	ctrl     kstream.KtraceController
	consumer kstream.Consumer
	aggr     *aggregator.BufferedAggregator
)

func init() {
	// initialize service config
	svcConfig.MustViperize(startSvcCmd)
}

func startService(cmd *cobra.Command, args []string) error {
	h, err := windows.OpenSCManager(nil, nil, windows.SC_MANAGER_CONNECT)
	if err != nil {
		return fmt.Errorf("couldn't connect to Windows Service Manager: %v", err)
	}
	m := &mgr.Mgr{Handle: h}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := windows.OpenService(
		m.Handle,
		windows.StringToUTF16Ptr(svcName),
		windows.SERVICE_START|windows.SERVICE_STOP,
	)
	if err != nil {
		return fmt.Errorf("could not open fibratus service: %v", err)
	}
	scm := &mgr.Service{Name: svcName, Handle: s}
	defer func() {
		_ = scm.Close()
	}()
	err = scm.Start()
	if err != nil {
		return fmt.Errorf("could not start fibratus service: %v", err)
	}

	start := time.Now()
	var status svc.Status
	for time.Since(start) > 5*time.Second {
		status, err = scm.Query()
		if err != nil {
			return fmt.Errorf("failed to get fibratus service status: %v", err)
		}

		if status.State == svc.Running {
			return nil
		}
	}
	return nil
}

func stopService(cmd *cobra.Command, args []string) error {
	return stopSvc()
}

func restartService(cmd *cobra.Command, args []string) error {
	if err := stopSvc(); err != nil {
		return err
	}
	return startService(cmd, args)
}

func stopSvc() error {
	h, err := windows.OpenSCManager(nil, nil, windows.SC_MANAGER_CONNECT)
	if err != nil {
		return fmt.Errorf("couldn't connect to Windows Service Manager: %v", err)
	}
	m := &mgr.Mgr{Handle: h}
	defer func() {
		_ = m.Disconnect()
	}()

	s, err := windows.OpenService(
		m.Handle,
		windows.StringToUTF16Ptr(svcName),
		windows.SERVICE_START|windows.SERVICE_STOP|windows.SERVICE_QUERY_STATUS,
	)
	if err != nil {
		return fmt.Errorf("could not open fibratus service: %v", err)
	}
	scm := &mgr.Service{Name: svcName, Handle: s}
	defer func() {
		_ = scm.Close()
	}()

	status, err := scm.Control(svc.Stop)
	if err != nil {
		return fmt.Errorf("couldn't stop fibratus service: %v", err)
	}
	timeout := time.Now().Add(10 * time.Second)
	for status.State != svc.Stopped {
		if timeout.Before(time.Now()) {
			return fmt.Errorf("timeout waiting for service to go to state=%d", svc.Stopped)
		}
		time.Sleep(300 * time.Millisecond)
		status, err = scm.Query()
		if err != nil {
			return fmt.Errorf("could not retrieve service status: %v", err)
		}
	}
	return nil
}

type fsvc struct{}

func (s *fsvc) Execute(args []string, r <-chan svc.ChangeRequest, changes chan<- svc.Status) (bool, uint32) {
	const cmdsAccepted = svc.AcceptStop | svc.AcceptShutdown
	changes <- svc.Status{State: svc.StartPending}
	changes <- svc.Status{State: svc.Running, Accepts: cmdsAccepted}

	if err := s.run(); err != nil {
		_ = evtlog.Error(0xc000000B, err.Error())
		changes <- svc.Status{State: svc.Stopped}
		return false, 1
	}

loop:
	for {
		c := <-r
		switch c.Cmd {
		case svc.Interrogate:
			changes <- c.CurrentStatus
			time.Sleep(100 * time.Millisecond)
			changes <- c.CurrentStatus
		case svc.Stop:
			break loop
		case svc.Shutdown:
			break loop
		}
	}

	changes <- svc.Status{State: svc.StopPending}

	if ctrl != nil {
		_ = ctrl.CloseKtrace()
	}
	if consumer != nil {
		_ = consumer.CloseKstream()
	}
	if aggr != nil {
		_ = aggr.Stop()
	}
	_ = handle.CloseTimeout()
	_ = api.CloseServer()

	changes <- svc.Status{State: svc.Stopped}

	return true, 0
}

func (s *fsvc) run() error {
	// initialize config and logger
	if err := common.Init(svcConfig, true); err != nil {
		return err
	}
	ver.Set(version)
	ctrl = kstream.NewKtraceController(svcConfig.Kstream)
	err := ctrl.StartKtrace()
	if err != nil {
		return err
	}

	// initialize handle/process snapshotters and try to open the kernel event stream
	hsnap := handle.NewSnapshotter(svcConfig, nil)
	psnap := ps.NewSnapshotter(hsnap, svcConfig)
	consumer = kstream.NewConsumer(ctrl, psnap, hsnap, svcConfig)
	// open the kernel event stream, start processing events and forwarding to outputs
	err = consumer.OpenKstream(ctrl.Traces())
	if err != nil {
		return err
	}

	aggr, err = aggregator.NewBuffered(
		consumer.Events(),
		consumer.Errors(),
		svcConfig.Aggregator,
		svcConfig.Output,
		svcConfig.Transformers,
		svcConfig.Alertsenders,
	)
	if err != nil {
		return err
	}
	if err := api.StartServer(svcConfig); err != nil {
		return err
	}

	return nil
}

// RunService runs the service handler.
func RunService() {
	var err error
	evtlog, err = eventlog.Open(svcName)
	if err != nil {
		return
	}
	defer func() {
		_ = evtlog.Close()
	}()

	err = svc.Run(svcName, &fsvc{})
	if err != nil {
		_ = evtlog.Error(0xc0000008, err.Error())
		return
	}
}

```

`cmd/fibratus/app/docs.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"github.com/spf13/cobra"
	"os/exec"
)

var docsCmd = &cobra.Command{
	Use:   "docs",
	Short: "Open Fibratus docs in the web browser",
	RunE: func(cmd *cobra.Command, args []string) error {
		return exec.Command("rundll32", "url.dll,FileProtocolHandler", "https://www.fibratus.io").Start()
	},
}

```

`cmd/fibratus/app/install_service_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows/svc/eventlog"
	"golang.org/x/sys/windows/svc/mgr"
	"os"
)

const svcName = "fibratus"

var errServiceAlreadyInstalled = errors.New("fibratus service is already installed")

var installSvcCmd = &cobra.Command{
	Use:   "install-service",
	Short: "Install fibratus within the Windows service control manager",
	RunE:  installService,
}

func installService(cmd *cobra.Command, args []string) error {
	exe, err := os.Executable()
	if err != nil {
		return err
	}
	m, err := mgr.Connect()
	if err != nil {
		return err
	}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := m.OpenService(svcName)
	if err == nil {
		if err := s.Close(); err != nil {
			return err
		}
		return errServiceAlreadyInstalled
	}

	svccfg := mgr.Config{
		DisplayName: "Fibratus Service",
		Description: "Exploration and tracing of the Windows kernel",
	}
	s, err = m.CreateService(svcName, exe, svccfg)
	if err != nil {
		return err
	}
	defer func() {
		_ = s.Close()
	}()

	err = eventlog.InstallAsEventCreate(svcName, eventlog.Error|eventlog.Warning|eventlog.Info)
	if err != nil {
		if err := s.Delete(); err != nil {
			return err
		}
		return fmt.Errorf("couldn't create event log record: %v", err)
	}
	return nil
}

```

`cmd/fibratus/app/list.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"bufio"
	"fmt"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/spf13/cobra"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "Show info about filaments, filter fields or kernel event types",
}

var listFilamentsCmd = &cobra.Command{
	Use:   "filaments",
	Short: "List available filaments",
	RunE:  listFilaments,
}

var listFieldsCmd = &cobra.Command{
	Use:   "fields",
	Short: "List available filtering fields",
	Run:   listFields,
}

var listsKeventsCmd = &cobra.Command{
	Use:   "kevents",
	Short: "List supported kernel event types",
	Run:   listKevents,
}

var listConfig = config.NewWithOpts(config.WithList())

func init() {
	listConfig.MustViperize(listFilamentsCmd)

	listCmd.AddCommand(listFilamentsCmd)
	listCmd.AddCommand(listFieldsCmd)
	listCmd.AddCommand(listsKeventsCmd)

	RootCmd.AddCommand(listCmd)
}

// listFilaments renders a table with all available filaments.
func listFilaments(cmd *cobra.Command, args []string) error {
	if err := common.Init(listConfig, false); err != nil {
		return err
	}

	dir := listConfig.Filament.Path
	if _, err := os.Stat(dir); err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("%q directory does not exist", dir)
		}
		return err
	}

	filaments, err := ioutil.ReadDir(dir)
	if err != nil {
		return err
	}

	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Description"})
	t.SetStyle(table.StyleLight)

	for _, f := range filaments {
		if f.IsDir() {
			continue
		}
		py, err := os.Open(filepath.Join(dir, f.Name()))
		if err != nil {
			continue
		}
		if filepath.Ext(f.Name()) != ".py" {
			continue
		}

		sn := bufio.NewScanner(py)
		var docStart bool
		var doc string
		for sn.Scan() {
			ln := sn.Text()
			if docStart {
				doc = ln
				break
			}
			if ln == `"""` {
				docStart = true
			}
		}
		_ = py.Close()
		t.AppendRow(table.Row{strings.TrimSuffix(f.Name(), ".py"), doc})
	}
	t.Render()

	return nil
}

// listKevents renders a table with supported kernel event types showing the category to which their pertain and a short description.
func listKevents(cmd *cobra.Command, args []string) {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Category", "Description"})
	t.SetStyle(table.StyleLight)

	for _, ktyp := range ktypes.GetKtypesMeta() {
		t.AppendRow(table.Row{ktyp.Name, ktyp.Category, ktyp.Description})
	}

	t.Render()
}

// listFields renders a table with available filtering fields containing the name, description and the example filtering expression.
func listFields(cmd *cobra.Command, args []string) {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Description", "Example"})
	t.SetStyle(table.StyleLight)

	for _, field := range fields.Get() {
		t.AppendRow(table.Row{field.Field, field.Desc, strings.Join(field.Examples, ",")})
	}

	t.Render()
}

```

`cmd/fibratus/app/remove_service_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows/svc/eventlog"
	"golang.org/x/sys/windows/svc/mgr"
)

var removeSvcCmd = &cobra.Command{
	Use:   "remove-service",
	Short: "Remove fibratus from the Windows service control manager",
	RunE:  removeService,
}

var errServiceNotInstalled = errors.New("fibratus service is not installed")

func removeService(cmd *cobra.Command, args []string) error {
	m, err := mgr.Connect()
	if err != nil {
		return err
	}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := m.OpenService(svcName)
	if err != nil {
		return errServiceNotInstalled
	}
	defer func() {
		_ = s.Close()
	}()
	err = s.Delete()
	if err != nil {
		return err
	}
	err = eventlog.Remove(svcName)
	if err != nil {
		return fmt.Errorf("couldn't create eventlog remove record: %v", err)
	}
	return nil
}

```

`cmd/fibratus/app/replay_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"context"

	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/aggregator"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filament"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/kcap"
	ver "github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/spf13/cobra"
)

var replayCmd = &cobra.Command{
	Use:   "replay",
	Short: "Replay kernel event flow from the kcap file",
	RunE:  replay,
}

var (
	// replay command config
	replayConfig = config.NewWithOpts(config.WithReplay())
)

func init() {
	replayConfig.MustViperize(replayCmd)
}

func replay(cmd *cobra.Command, args []string) error {
	// initialize config and logger
	if err := common.Init(replayConfig, false); err != nil {
		return err
	}
	ver.Set(version)
	// set up the signals
	stopCh := common.Signals()

	kfilter, err := filter.NewFromCLIWithAllAccessors(args)
	if err != nil {
		return err
	}

	// initialize kcap reader and try to recover the snapshotters
	// from the captured state
	reader, err := kcap.NewReader(replayConfig.KcapFile, replayConfig)
	if err != nil {
		return err
	}
	hsnap, psnap, err := reader.RecoverSnapshotters()
	if err != nil {
		return err
	}

	ctx, cancel := context.WithCancel(context.Background())
	// stop kcap reader consumers
	defer cancel()

	filamentName := replayConfig.Filament.Name
	// we don't need the aggregator is user decided to replay the
	// kcap on the filament. Otherwise, we setup the full-fledged
	// buffered aggregator
	var agg *aggregator.BufferedAggregator

	if filamentName != "" {
		f, err := filament.New(filamentName, psnap, hsnap, replayConfig)
		if err != nil {
			return err
		}
		if f.Filter() != nil {
			kfilter = f.Filter()
		}
		reader.SetFilter(kfilter)

		// returns the channel where events are read from the kcap
		kevents, errs := reader.Read(ctx)

		go func() {
			defer f.Close()
			err = f.Run(kevents, errs)
			if err != nil {
				stopCh <- struct{}{}
			}
		}()
	} else {
		if kfilter != nil {
			reader.SetFilter(kfilter)
		}

		// use the channels where events are read from the kcap as aggregator source
		kevents, errs := reader.Read(ctx)

		var err error
		agg, err = aggregator.NewBuffered(
			kevents,
			errs,
			replayConfig.Aggregator,
			replayConfig.Output,
			replayConfig.Transformers,
			replayConfig.Alertsenders,
		)
		if err != nil {
			return err
		}
	}
	// start the HTTP server
	if err := api.StartServer(replayConfig); err != nil {
		return err
	}

	<-stopCh

	if agg != nil {
		if err := agg.Stop(); err != nil {
			return err
		}
	}
	if err := api.CloseServer(); err != nil {
		return err
	}

	return nil
}

```

`cmd/fibratus/app/root.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"errors"
	"github.com/spf13/cobra"
	"runtime"
)

// RootCmd is the entrance to Fibratus CLI
var RootCmd = &cobra.Command{
	Use:   "fibratus",
	Short: "Modern tool for the kernel observability and exploration",
	Long: `
	Fibratus is a tool for exploration and tracing of the Windows kernel. 
	It lets you trap system-wide events such as process life-cycle, file system I/O, 
	registry modifications or network requests among many other observability signals. 
	In a nutshell, Fibratus allows for gaining deep operational visibility into the Windows 
	kernel but also processes running on top of it.
	`,
	SilenceUsage: true,
	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
		if runtime.GOOS != "windows" {
			return errors.New("fibratus can only be run on Windows operating systems")
		}
		if runtime.GOARCH == "386" {
			return errors.New("fibratus can't be run on 32-bits Windows operating systems")
		}
		return nil
	},
}

func init() {
	RootCmd.AddCommand(runCmd)
	RootCmd.AddCommand(captureCmd)
	RootCmd.AddCommand(replayCmd)
	RootCmd.AddCommand(installSvcCmd)
	RootCmd.AddCommand(removeSvcCmd)
	RootCmd.AddCommand(startSvcCmd)
	RootCmd.AddCommand(stopSvcCmd)
	RootCmd.AddCommand(restartSvcCmd)
	RootCmd.AddCommand(statsCmd)
	RootCmd.AddCommand(configCmd)
	RootCmd.AddCommand(docsCmd)
	RootCmd.AddCommand(versionCmd)
}

```

`cmd/fibratus/app/run_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"os"

	ver "github.com/rabbitstack/fibratus/pkg/util/version"

	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/aggregator"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filament"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kstream"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

var runCmd = &cobra.Command{
	Use:     "run [filter]",
	Short:   "Bootstrap fibratus or a filament",
	Aliases: []string{"start"},
	RunE:    run,
	Example: `
	# Run without the filter
	fibratus run

	# Run with the filter that drops all but events produced by the svchost.exe process
	fibratus run ps.name = 'svchost.exe'

	# Run with the filter that traps all events that were generated by process that contains the 'svc' string and it was started by 'SYSTEM' or 'admin' users
	fibratus run ps.name contains 'svc' and ps.sid in ('NT AUTHORITY\\SYSTEM', 'ARCHRABBIT\\admin')

	# Run the top_keys filament
	fibratus run -f top_keys
	`,
}

var (
	// the run command config
	cfg = config.NewWithOpts(config.WithRun())
)

func init() {
	// initialize flags
	cfg.MustViperize(runCmd)
}

func run(cmd *cobra.Command, args []string) error {
	// initialize config and logger
	if err := common.Init(cfg, true); err != nil {
		return err
	}
	ver.Set(version)
	// set up the signals
	stopCh := common.Signals()

	// initialize kernel trace controller and try to start the trace
	ktracec := kstream.NewKtraceController(cfg.Kstream)
	err := ktracec.StartKtrace()
	if err != nil {
		return err
	}

	// bootstrap essential components, including handle, process snapshotters
	// and the kernel stream consumer that will actually collect all the events
	hsnap := handle.NewSnapshotter(cfg, nil)
	psnap := ps.NewSnapshotter(hsnap, cfg)
	kstreamc := kstream.NewConsumer(ktracec, psnap, hsnap, cfg)
	// build the filter from the CLI argument. If we got a valid expression the filter
	// is linked to the kernel stream consumer so it can drop any events that don't match
	// the filter criteria
	kfilter, err := filter.NewFromCLI(args, cfg)
	if err != nil {
		return err
	}
	if kfilter != nil {
		kstreamc.SetFilter(kfilter)
	}
	log.Infof("bootstrapping with pid %d", os.Getpid())

	// user can either instruct to bootstrap a filament or start a regular run. We'll setup
	// the corresponding components accordingly to what we got from the CLI options. If a filament
	// was given, we'll assign it the previous filter if it wasn't provided in the filament init function.
	// Finally, we open the kernel stream flow and run the filament i.e. Python main thread in a new goroutine.
	// In case of a regular run, we additionally setup the aggregator. The aggregator will grab the events
	// from the queue, assemble them into batches and hand over to output sinks.
	var f filament.Filament
	filamentName := cfg.Filament.Name
	if filamentName != "" {
		f, err = filament.New(filamentName, psnap, hsnap, cfg)
		if err != nil {
			return err
		}
		if f.Filter() != nil {
			kstreamc.SetFilter(f.Filter())
		}
		err = kstreamc.OpenKstream(ktracec.Traces())
		if err != nil {
			return multierror.Wrap(err, ktracec.CloseKtrace())
		}
		// load alert senders so emitting alerts is possible from filaments
		err = alertsender.LoadAll(cfg.Alertsenders)
		if err != nil {
			log.Warnf("couldn't load alertsenders: %v", err)
		}
		go func() {
			err = f.Run(kstreamc.Events(), kstreamc.Errors())
			if err != nil {
				log.Error(err)
				stopCh <- struct{}{}
			}
		}()
	} else {
		err = kstreamc.OpenKstream(ktracec.Traces())
		if err != nil {
			return multierror.Wrap(err, ktracec.CloseKtrace())
		}
		// setup the aggregator that forwards events to outputs
		agg, err := aggregator.NewBuffered(
			kstreamc.Events(),
			kstreamc.Errors(),
			cfg.Aggregator,
			cfg.Output,
			cfg.Transformers,
			cfg.Alertsenders,
		)
		if err != nil {
			return err
		}
		defer func() {
			if err := agg.Stop(); err != nil {
				log.Error(err)
			}
		}()
	}

	// start the HTTP server
	if err := api.StartServer(cfg); err != nil {
		return err
	}

	<-stopCh

	// shutdown everything gracefully
	_ = ktracec.CloseKtrace()
	_ = kstreamc.CloseKstream()

	if f != nil {
		if err := f.Close(); err != nil {
			return err
		}
	}
	if err := handle.CloseTimeout(); err != nil {
		return err
	}
	if err := api.CloseServer(); err != nil {
		return err
	}

	return nil
}

```

`cmd/fibratus/app/stats.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"encoding/json"
	"os"
	"reflect"

	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/cmd/fibratus/common"
	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/util/rest"
	"github.com/spf13/cobra"
)

var statsCmd = &cobra.Command{
	Use:   "stats",
	Short: "Show runtime stats",
	RunE:  stats,
}

var statsConfig = config.NewWithOpts(config.WithStats())

func init() {
	statsConfig.MustViperize(statsCmd)
}

// Stats stores runtime statistics that are retrieved from the expvar endpoint.
type Stats struct {
	AggregatorBatchEvents               int            `json:"aggregator.batch.events"`
	AggregatorFlushesCount              int            `json:"aggregator.flushes.count"`
	AggregatorKeventErrors              int            `json:"aggregator.kevent.errors"`
	AggregatorTransformerErrors         map[string]int `json:"aggregator.transformer.errors"`
	AggregatorWorkerClientPublishErrors int            `json:"aggregator.worker.client.publish.errors"`
	FilamentKdictErrors                 int            `json:"filament.kdict.errors"`
	FilamentKeventBatchFlushes          int            `json:"filament.kevent.batch.flushes"`
	FilamentKeventErrors                map[string]int `json:"filament.kevent.errors"`
	FilamentKeventProcessErrors         int            `json:"filament.kevent.process.errors"`
	FilterAccessorErrors                map[string]int `json:"filter.accessor.errors"`
	FsFileObjectHandleHits              int            `json:"fs.file.object.handle.hits"`
	FsFileObjectMisses                  int            `json:"fs.file.object.misses"`
	FsFileReleases                      int            `json:"fs.file.releases"`
	FsTotalRundownFiles                 int            `json:"fs.total.rundown.files"`
	HandleDeferredEvictions             int            `json:"handle.deferred.evictions"`
	HandleNameQueryFailures             map[string]int `json:"handle.name.query.failures"`
	HandleSnapshotCount                 int            `json:"handle.snapshot.count"`
	HandleSnapshotBytes                 int            `json:"handle.snapshot.bytes"`
	HandleTypesCount                    int            `json:"handle.types.count"`
	HandleTypeNameMisses                int            `json:"handle.type.name.misses"`
	HandleWaitTimeouts                  int            `json:"handle.wait.timeouts"`
	HostnameErrors                      map[string]int `json:"hostname.errors"`
	KcapFlusherErrors                   map[string]int `json:"kcap.flusher.errors"`
	KcapHandleWriteErrors               int            `json:"kcap.handle.write.errors"`
	KcapKeventUnmarshalErrors           int            `json:"kcap.kevent.unmarshal.errors"`
	KcapKeventWriteErrors               int            `json:"kcap.kevent.write.errors"`
	KcapKstreamConsumerErrors           int            `json:"kcap.kstream.consumer.errors"`
	KcapOverflowErrors                  int            `json:"kcap.overflow.errors"`
	KcapReadBytes                       int            `json:"kcap.read.bytes"`
	KcapReadKevents                     int            `json:"kcap.read.kevents"`
	KcapReaderDroppedByFilter           int            `json:"kcap.reader.dropped.by.filter"`
	KcapReaderHandleUnmarshalErrors     int            `json:"kcap.reader.handle.unmarshal.errors"`
	KeventInterceptorFailures           int            `json:"kevent.interceptor.failures"`
	KeventSeqInitErrors                 map[string]int `json:"kevent.seq.init.errors"`
	KeventSeqStoreErrors                int            `json:"kevent.seq.store.errors"`
	KeventTimestampUnmarshalErrors      int            `json:"kevent.timestamp.unmarshal.errors"`
	KstreamDroppedKevents               int            `json:"kstream.dropped.kevents"`
	KstreamDroppedProcs                 int            `json:"kstream.dropped.procs"`
	KstreamKbuffersRead                 int            `json:"kstream.kbuffers.read"`
	KstreamKeventParamFailures          int            `json:"kstream.kevent.param.failures"`
	KstreamKeventsEnqueued              int            `json:"kstream.kevents.enqueued"`
	KstreamKeventsDequeued              int            `json:"kstream.kevents.dequeued"`
	KstreamKeventsFailures              map[string]int `json:"kstream.kevents.failures"`
	KstreamKeventsMissingSchemaErrors   map[string]int `json:"kstream.kevents.missing.schema.errors"`
	KstreamUpstreamCancellations        int            `json:"kstream.upstream.cancellations"`
	LoggerErrors                        map[string]int `json:"logger.errors"`
	OutputAMQPChannelFailures           int            `json:"output.amqp.channel.failures"`
	OutputAMQPConnectionFailures        int            `json:"output.amqp.connection.failures"`
	OutputAMQPPublishErrors             int            `json:"output.amqp.publish.errors"`
	OutputConsoleErrors                 int            `json:"output.console.errors"`
	OutputNullBlackholeEvents           int            `json:"output.null.blackhole.events"`
	PeFailedResourceEntryReads          int            `json:"pe.failed.resource.entry.reads"`
	PeMaxResourceEntriesExceeded        int            `json:"pe.max.resource.entries.exceeded"`
	ProcessCount                        int            `json:"process.count"`
	ProcessModuleCount                  int            `json:"process.module.count"`
	ProcessLookupFailureCount           map[int]int    `json:"process.lookup.failure.count"`
	ProcessPebReadErrors                int            `json:"process.peb.read.errors"`
	ProcessReaped                       int            `json:"process.reaped"`
	ProcessThreadCount                  int            `json:"process.thread.count"`
	RegistryKcbCount                    int            `json:"registry.kcb.count"`
	RegistryKcbMisses                   int            `json:"registry.kcb.misses"`
	RegistryKeyHandleHits               int            `json:"registry.key.handle.hits"`
	RegistryUnknownKeysCount            int            `json:"registry.unknown.keys.count"`
	SidsCount                           int            `json:"sids.count"`
	YaraImageScans                      int            `json:"yara.image.scans"`
	YaraProcScans                       int            `json:"yara.proc.scans"`
	YaraRuleMatches                     int            `json:"yara.rule.matches"`
}

func stats(cmd *cobra.Command, args []string) error {
	if err := common.Init(statsConfig, false); err != nil {
		return err
	}

	c := statsConfig.API
	body, err := rest.Get(rest.WithTransport(c.Transport), rest.WithURI("debug/vars"))
	if err != nil {
		return kerrors.ErrHTTPServerUnavailable(c.Transport, err)
	}
	var stats Stats
	if err := json.Unmarshal(body, &stats); err != nil {
		return err
	}

	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Value"})
	t.SetStyle(table.StyleLight)

	typ := reflect.TypeOf(stats)
	val := reflect.ValueOf(stats)

	for i := 0; i < typ.NumField(); i++ {
		f := typ.Field(i)
		tag := f.Tag.Get("json")

		if tag == "" {
			continue
		}

		if !val.Field(i).CanInterface() {
			continue
		}

		t.AppendRow(table.Row{tag, val.Field(i).Interface()})
	}

	t.Render()

	return nil
}

```

`cmd/fibratus/app/version.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	v "github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/spf13/cobra"
)

var (
	version string // version string
	commit  string // commit hash
	date    string // build date
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Show version info",
	Run: func(cmd *cobra.Command, args []string) {
		v.New(version, commit, date).Render()
	},
}

```

`cmd/fibratus/common/init_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package common

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/syscall/security"
	"github.com/rabbitstack/fibratus/pkg/util/log"
)

// Init initializes and validates the configuration
// as given by the commands. This function will also set up
// the logger and adjust the process token with the debug
// privilege if required.
func Init(c *config.Config, debugPrivilege bool) error {
	if err := c.TryLoadFile(c.File()); err != nil {
		return err
	}
	// initialize and validate the config
	if err := c.Init(); err != nil {
		return err
	}
	if err := c.Validate(); err != nil {
		return err
	}
	// inject the debug privilege if enabled
	if c.DebugPrivilege && debugPrivilege {
		security.SetDebugPrivilege()
	}
	if err := log.InitFromConfig(c.Log); err != nil {
		return err
	}

	return nil
}

```

`cmd/fibratus/common/signals.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package common

import (
	log "github.com/sirupsen/logrus"
	"os"
	"os/signal"
	"syscall"
)

// Signals set ups the signal handler.
func Signals() chan struct{} {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)

	stopCh := make(chan struct{})

	go func() {
		sig := <-sigCh
		log.Infof("got signal %q, shutting down...", sig)
		stopCh <- struct{}{}
	}()

	return stopCh
}

```

`cmd/fibratus/fibratus.exe.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
```

`cmd/fibratus/fibratus.rc`:

```rc
#include "version.h"
#define RT_MANIFEST 24

#define VS_VERSION_INFO 1
VS_VERSION_INFO VERSIONINFO
 FILEVERSION RC_FILE_VERSION
 PRODUCTVERSION RC_FILE_VERSION
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Fibratus"
            VALUE "FileDescription", "Kernel tracing and exploration tool"
            VALUE "FileVersion", FILE_VERSION_STRING
            VALUE "InternalName", "fibratus"
            VALUE "LegalCopyright", "Copyright (C) 2019-2021"
            VALUE "OriginalFilename", "fibratus.exe"
            VALUE "ProductName", "Fibratus"
            VALUE "ProductVersion", FILE_VERSION_STRING
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

1 RT_MANIFEST "fibratus.exe.manifest"
```

`cmd/fibratus/main_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"fmt"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app"
	"golang.org/x/sys/windows/svc"
	"os"
)

func main() {
	// determine if we are running in an interactive session
	in, err := svc.IsAnInteractiveSession()
	if err != nil {
		fmt.Printf("interactive session check failed: %v\n", err)
		os.Exit(-1)
	}
	if !in {
		app.RunService()
		return
	}
	if err := app.RootCmd.Execute(); err != nil {
		os.Exit(-1)
	}
}

```

`cmd/fibratus/version.h`:

```h
#define RC_FILE_VERSION RC_VER,0

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

#define FILE_VERSION_STRING TO_STRING(VER)

```

`configs/fibratus.json`:

```json
{
  "aggregator": {
    "flush-period": "500ms",
    "flush-timeout": "4s"
  },

  "alertsenders": {
    "mail": {
      "enabled": false
    },

    "slack": {
      "enabled": false
    }
  },

  "api": {
    "transport": "localhost:8090",
    "timeout": "5s"
  },

  "debug-privilege": true,

  "filament": {
    "name": "",
    "flush-period": "200ms"
  },

  "handle": {
    "init-snapshot": true
  },

  "kevent": {

  },

  "kcap": {

  },

  "kstream": {},
  "logging": {},

  "output": {
    "console": {
      "enabled": true,
      "format": "pretty",
      "kv-delimiter": "->"
    }
  },

  "pe": {},
  "transformers": {},
  "yara": {}
}
```

`configs/fibratus.yml`:

```yml
###################### Fibratus Configuration File #####################################

# =============================== Aggregator ==========================================

# Aggregator is responsible for creating kernel event batches, applying transformers to each event
# present in the batch, and forwarding those batches to the output sinks.
aggregator:
  # Determines the flush period that triggers the flushing of the kernel event batches to output sinks
  flush-period: 500ms

  # Represents the max time to wait before announcing failed flushing of enqueued events when fibratus
  # is stopped
  flush-timeout: 4s

# =============================== Alert senders ========================================

# Alert senders deal with emitting alerts via different channels.
alertsenders:
  # Mail sender transports the alerts via SMTP protocol.
  mail:
    # Enables/disables mail alert sender
    enabled: false

    # Represents the host of the SMTP server
    #host:

    # Represents the port of the SMTP server
    #port: 25

    # Specifies the user name when authenticating to the SMTP server
    #user:

    # Specifies the password when authenticating to the SMTP server
    #password:

    # Specifies the sender's address
    #from:

    # Specifies all the recipients that'll receive the alert
    #to:
    #  - ""

  # Slack sender transports the alerts to the Slack workspace.
  slack:
    # Enables/disables Slack alert sender
    enabled: false

    # Represents the Webhook URL of the workspace where alerts will be dispatched
    #url:

    # Designates the Slack workspace where alerts will be routed
    #workspace:

    # Is the slack channel in which to post alerts
    #channel:

    # Represents the emoji icon surrounded in ':' characters for the Slack bot
    #emoji: ""

# =============================== API ==================================================

# Settings that influence the behaviour of the HTTP server that exposes a number of endpoints such as
# expvar metrics, internal state, and so on
api:
  # Specifies the underlying transport protocol for the API HTTP server. The transport can either be the
  # named pipe or TCP socket. Default is named pipe but you can override it to expose the API server on
  # TCP address, e.g. 192.168.1.32:8084.
  transport: localhost:8482

  # Represents the timeout interval for the HTTP server responses.
  timeout: 5s

# =============================== General ==============================================

# Indicates whether debug privilege is set in Fibratus process' token. Enabling this security policy allows
# Fibratus to obtain handles of protected processes for the purpose of querying the Process Environment Block
# regions.
debug-privilege: true


# =============================== Filament =============================================

# Filaments are lightweight Python scriplets that are executed on top of the kernel event stream. You can easily
# extend Fibratus with custom features that is encapsulated in filaments. This section controls the behaviour of
# the filament engine.
filament:
  # Specifies the name of the filament that is executed by the run command
  name: ""

  # The directory where all filaments are located. By default, filaments are stored in the ${PROGRAMFILES}/fibratus/filaments directory.
  #path: ${PROGRAMFILES}/fibratus/filaments

  # Determines how often event batches are propagated to the filament callback function
  #flush-period: 200ms

# =============================== Filters ===============================================

# Contains the definition of filter rules. Filter expressions are contained in filter group files.
# Rule definitions can reside in the local file system or also can be served over HTTP/S.
filters:
  rules:
    from-paths:
    # - C:\Program Files\Fibratus\Config\Rules\Default\default.yml
    #from-urls:
    #  - https://raw.githubusercontent.com/rabbitstack/fibratus/master/configs/rules/default/default.yml

# =============================== Handle ===============================================

# Indicates whether initial handle snapshot is built. The snapshot contains the state of system handles.
handle:
  init-snapshot: true

# =============================== Kevent ===============================================

# The following settings control the state of the kernel event.
kevent:
  # Indicates if threads are serialized as part of the process state
  serialize-threads: false

  # Indicates if modules such as Dynamic Linked Libraries are serialized as part of the process state
  serialize-images: false

  # Indicates if handles are serialized as part of the process state
  serialize-handles: false

  # Indicates if PE (Portable Executable) metadata are serialized as part of the process state
  serialize-pe: false

  # Indicates if environment variables are serialized as part of the process state
  serialize-envs: false

# =============================== Kcap =================================================

# Contains the settings that dictate the behaviour of the kernel event captures.

kcap:
  # Specifies the name of the output kcap file. If not empty, capture files are always stored
  # to this file by overwriting any existing capture file
  file: ""

# =============================== Kstream ==============================================

# Tweaks for controlling the behaviour of the kernel stream consumer.
kstream:
  # Determines the maximum number of buffers allocated for the event tracing session's buffer pool
  #max-buffers:

  # Determines the minimum number of buffers allocated for the event tracing session's buffer pool
  #min-buffers:

  # Specifies how often the trace buffers are forcibly flushed
  #flush-interval: 1s

  # Represents the amount of memory allocated for each event tracing session buffer, in kilobytes.
  # The buffer size affects the rate at which buffers fill and must be flushed (small buffer size requires
  # less memory but it increases the rate at which buffers must be flushed)
  #buffer-size:

  # Determines whether thread kernel events are collected by Kernel Logger provider
  #enable-thread: true

  # Determines whether registry kernel events are collected by Kernel Logger provider
  #enable-registry: true

  # Determines whether network kernel events are collected by Kernel Logger provider
  #enable-net: true

  # Determines whether file kernel events are collected by Kernel Logger provider
  #enable-fileio: true

  # Determines whether image kernel events are collected by Kernel Logger provider
  #enable-image: true

  # Determines whether object manager kernel events (handle creation/destruction) are
  # collected by Kernel Logger provider
  #enable-handle: false

  # Determines if raw event buffer parsing is used instead of TDH (Trace Data Helper) API
  # raw-event-parsing: true

  # Determines which events are dropped either by the event name or the process' image
  # name that triggered the event.
  blacklist:
    # Contains a list of kernel event names that are dropped from the event stream
    events:
      - CloseFile
      - CloseHandle
    # Contains a list of case-sensitive process image names including the extension.
    # Any event originated by the image specified in this list is dropped from the event stream
    images:
      - System

# =============================== Logging ================================================

# Contains the tweaks for fine-tuning the behaviour of the log files produced by Fibratus.
logging:
  # Specifies the minimum allowed log level. Anything logged below this log level will
  # not get dumped to a file or stdout stream
  level: info

  # Represents the maximum number of days to retain old log files based on the timestamp
  # encoded in their filename. By default, all log files are retained
  # max-age: 0

  # Specifies the maximum number of old log files to retain
  #max-backups: 15

  # Specifies the maximum size in megabytes of the log file before it gets rotated
  #max-size: 100

  # Represents the log file format. By default, Fibratus will dump the logs in JSON format
  #formatter: json

  # Represents the alternative paths for storing the logs. Logs are usually stored in the
  # same directory where Fibratus was installed
  #path:

  # Indicates whether log lines are written to standard output in addition to writing them to log files
  #log-stdout: false


# =============================== Output ================================================

# Outputs transport the event flowing through kernel event stream to its final destination. Only one output
# can be active at the time. The following section contains available outputs and their preferences.
output:
  # Console output writes the event to standard output stream.
  console:
    # Indicates whether the console output is active
    enabled: true

    # Specifies the console output format. The "pretty" format dictates that formatting is accomplished
    # by replacing the specifiers in the template. The "json" format outputs the event as a raw JSON string
    format: pretty

    # Template that's feed into event formatter. The default event formatter template is:
    #
    # {{ .Seq }} {{ .Timestamp }} - {{ .CPU }} {{ .Process }} ({{ .Pid }}) - {{ .Type }} ({{ .Kparams }})
    #
    #template:

    # Specifies the separator that's rendered between the event parameter's key and its value.
    #kv-delimiter:

  # Elasticsearch output indexes event bulks into Elasticsearch clusters.
  elasticsearch:
    # Indicates whether the Elasticsearch output is enabled
    enabled: false

    # Defines the URL endpoints of the Elasticsearch nodes
    #servers:
    #  - http://localhost:9200

    # Represents the initial HTTP connection timeout
    #timeout: 5s

    # Specifies when to flush the bulk at the end of the given interval
    #flush-period: 1s

    # Determines the number of workers that commit docs to Elasticsearch
    #bulk-workers: 1

    # Enables/disables nodes health checking
    #healthcheck: true

    # Specifies the interval for checking if the Elasticsearch nodes are available
    #healthcheck-interval: 10s

    # Specifies the timeout for periodic health checks
    #healthcheck-timeout: 5s

    # Identifies the user name for the basic HTTP authentication
    #username:

    # Identifies the password for the basic HTTP authentication
    #password:

    # Enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list
    # of available Elasticsearch nodes
    #sniff: false

    # Determines if the Elasticsearch trace log is enabled. Useful for troubleshooting
    #trace-log: false

    # Specifies if gzip compression is enabled
    #gzip-compression: false

    # Specifies the name of the index template
    #template-name: fibratus

    # Represents the target index for kernel events. It allows time specifiers to create indices per time frame.
    # For example, fibratus-%Y-%m generates the index name with current year and and month time specifiers
    #index-name: fibratus

    # Contains the full JSON body of the index template. For more information refer to
    # https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html
    #template-config:

    # Path to the public/private key file
    #tls-key:

    # Path to certificate file
    #tls-cert:

    # Represents the path of the certificate file that is associated with the Certification Authority (CA)
    #tls-ca:

    # Indicates if the chain and host verification stage is skipped
    #tls-insecure-skip-verify: false

  # Amqp output emits event batches to RabbitMQ brokers.
  amqp:
    # Indicates if the AMQP output is enabled
    enabled: false

    # Represents the AMQP connection string
    #url: amqp://localhost:5672

    # Specifies the AMQP connection timeout
    #timeout: 5s

    # Specifies target exchange name that receives inbound kernel events
    #exchange: fibratus

    # Represents  the AMQP exchange type. Available exchange type include common types are "direct", "fanout",
    # "topic", "header", and "x-consistent-hash"
    #exchange-type: topic

    # Represents the static routing key to link exchanges with queues.
    #routing-key: fibratus

    # Represents the virtual host name
    #vhost: /

    # Indicates if the exchange is marked as durable. Durable exchanges can survive server restarts
    #durable: false

    # Indicates if the server checks whether the exchange already exists and raises an error if it doesn't exist
    #passive: false

    # Determines if a published message is persistent or transient
    #delivery-mode: transient

    # The username for the plain authentication method
    #username:
    # The password for the plain authentication method
    #password:

    # Designates static headers that are added to each published message
    #headers:
    #  env: dev

    # Path to the public/private key file
    #tls-key:

    # Path to certificate file
    #tls-cert:

    # Represents the path of the certificate file that is associated with the Certification Authority (CA)
    #tls-ca:

    # Indicates if the chain and host verification stage is skipped
    #tls-insecure-skip-verify: false

  # HTTP output sends event batches to HTTP servers.
  http:
    # Indicates if the HTTP output is enabled
    enabled: false

    # List of endpoints to which the events are sent
    #endpoints:
    #  - http://localhost:8081

    # Represents the timeout for the HTTP requests
    #timeout: 5s

    # Specifies the HTTP proxy URL. It overrides the HTTP proxy URL as indicated by the environment variables
    #proxy-url: ""

    # The username for HTTP proxy authentication
    #proxy-username: ""

    # The password for HTTP proxy authentication
    #proxy-password: ""

    # Determines the HTTP verb to use in requests
    #method: POST

    # Specifies the event serializer type
    #serializer: json

    # Username for the basic HTTP authentication
    #username: ""

    # Password for the basic HTTP authentication
    #password: ""

    # If enabled, the HTTP body is compressed with gzip compression
    #enable-gzip: false

    # List of arbitrary headers to include in HTTP requests
    #headers:
    #  api-key: ""

    # Path to the public/private key file
    #tls-key:

    # Path to certificate file
    #tls-cert:

    # Represents the path of the certificate file that is associated with the Certification Authority (CA)
    #tls-ca:

    # Indicates if the chain and host verification stage is skipped
    #tls-insecure-skip-verify: false

  # Eventlog output publishes events to Windows Event Log.
  eventlog:
    # Indicates if the Eventlog output is enabled
    enabled: false

    # Specifies the eventlog level
    # level: info

    # Address of the remote eventlog intake
    # remote-host:

    # Go template for rendering the eventlog message
    # template:

# =============================== Portable Executable (PE) =============================

# Tweaks for controlling the fetching of the PE (Portable Executable) metadata from the process' binary image.
pe:
  # Designates whether inspecting PE metadata is allowed.
  enabled: false

  # Contains a list of image names that are excluded from PE parsing
  excluded-images:
    - svchost.exe

  # Determines if resources are read from the PE resource directory
  #read-resources: false

  # Indicates if symbols are read from the PE headers
  #read-symbols: false

  # Indicates if full section inspection is allowed. When se to true, section's individual bytes are
  # consulted for computing section hashes, calculating the entropy, and so on
  #read-sections: false

# =============================== Transformers =========================================

# Transformers are responsible for augmenting, parsing or enriching kernel events.
transformers:
  # Remove transformer deletes provided event parameters.
  remove:
    # Indicates if the remove transformer is enabled
    enabled: false

    # Represents the list of parameters that are removed from the event
    #kparams:
    #  - irp

  # Rename transformer renames parameter from old to new name.
  rename:
    # Indicates if the rename transformer is enabled
    enabled: false

    # Contains the list of old/new mappings. Old represents the original
    # parameter name, while new is the new parameter name
    #kparams:
    #  - old:
    #    new:

  # Replace transformer replaces all non-overlapping instances of old parameter's value with the new one.
  replace:
    # Indicates if the replace transformer is enabled
    enabled: false

    # Contains the list of parameter replacements. For each target event parameter, the old represent the substring
    # that gets replaced by the new string.
    #replacements:
    #  - kparam:
    #    old:
    #    new:

  # Tags transformer appends custom key/value pairs to event metadata.
  tags:
    # Indicates if the tags transformer is enabled
    enabled: false

    # Contains the list of tags that are appended to event metadata. Values can be fetched from environment
    # variables by enclosing them in % symbols
    #tags:
    #  - key:
    #    value:

  # Trim transformer removes prefixes/suffixes from event parameter values.
  trim:
    # # Indicates if the trim transformer is enabled
    enabled: false

    # Contains the list of parameters associated with the prefix that is trimmed from the parameter's value
    #prefixes:
    #  - kparam:
    #    trim:

    # Contains the list of parameters associated with the suffix that is trimmed from the parameter's value
    #suffixes:
    #  - kparam:
    #    trim:

# =============================== YARA =================================================

# Tweaks that influence the behaviour of the YARA scanner.
yara:
  # Indicates if the YARA scanner is enabled. When enabled, each newly created process is scanned for pattern matches.
  enabled: false

  # Contains rule paths and rule definition information
  rule:
    # Represents the paths within the file system along with the YARA namespace identifier
    paths:
      - path: ""
        namespace: ""

    # Represents the string with the rule definition along with the YARA namespace identifier
    strings:
      - string:
        namespace:

  # Indicates which sender is used to transport the alert generated by scanner
  #alert-via: mail

  # Specifies templates for the alert title and text in Go templating language (https://golang.org/pkg/text/template)
  #alert-template:
  #  title:
  #  text:

  # Determines when multiple matches of the same string can be avoided when not necessary
  #fastscan: true

  # Specifies the timeout for the scanner. If the timeout is reached, the scan operation is cancelled
  #scan-timeout: 20s

  # Indicates whether file scanning is disabled. This affects the scan triggered by the image loading events.
  #skip-files: true

  # Contains the list of file names that shouldn't be scanned
  #excluded-files:
  #  - kernel32.dll

  # Contains the list of the process' image names that shouldn't be scanned
  #excluded-procs:
  #  - System

```

`configs/rules/default/default.yml`:

```yml
# ====================================================================================================
#
# These filter rules try to mimic the subset of the sysmon config template
# created by SwiftOnSecurity (https://github.com/SwiftOnSecurity/sysmon-config).
#
# All credits for digging the rule definitions go to the above author/contributors.
#
# Obviously, some events can't be directly translated to Fibratus equivalent
# since Fibratus is not aware of them. In the same way,
# some filter fields are still missing in Fibratus, so those sysmon rules were
# omitted.
#
# ======================= Process creation ===========================================================
#
# All processes launched will be logged, except for what matches a rule below.
# It's best to be as specific as possible, to avoid user-mode executables imitating
# other process names to avoid logging, or if malware drops files in an existing directory.
#
- group: Windows userspace and common apps processes
  selector:
    type: CreateProcess
  enabled: true
  policy: exclude
  relation: or
  rules:
    - name: Windows error reporting/telemetry, WMI provider host
      condition: ps.comm istartswith
          (
            ' \"C:\\Windows\\system32\\wermgr.exe\\" \"-queuereporting_svc\" ',
            'C:\\Windows\\system32\\DllHost.exe /Processid',
            'C:\\Windows\\system32\\wbem\\wmiprvse.exe -Embedding',
            'C:\\Windows\\system32\\wbem\\wmiprvse.exe -secured -Embedding'
          )
    - name: Windows error reporting/telemetry, Search Indexer, Session Manager, Auto check utility
      condition: ps.comm iin
          (
            'C:\\Windows\\system32\\wermgr.exe -upload',
            'C:\\Windows\\system32\\SearchIndexer.exe /Embedding',
            'C:\\windows\\system32\\wermgr.exe -queuereporting',
            '\\??\\C:\\Windows\\system32\\autochk.exe *',
            '\\SystemRoot\\System32\\smss.exe',
            'C:\\Windows\\System32\\RuntimeBroker.exe -Embedding'
          )
    - name: Various Windows processes
      condition: ps.exe iin
          (
            'C:\\Program Files (x86)\\Common Files\\microsoft shared\\ink\\TabTip32.exe',
            'C:\\Windows\\System32\\TokenBrokerCookies.exe',
            'C:\\Windows\\System32\\plasrv.exe',
            'C:\\Windows\\System32\\wifitask.exe',
            'C:\\Windows\\system32\\CompatTelRunner.exe',
            'C:\\Windows\\system32\\PrintIsolationHost.exe',
            'C:\\Windows\\system32\\SppExtComObj.Exe',
            'C:\\Windows\\system32\\audiodg.exe',
            'C:\\Windows\\system32\\conhost.exe',
            'C:\\Windows\\system32\\mobsync.exe',
            'C:\\Windows\\system32\\musNotification.exe',
            'C:\\Windows\\system32\\musNotificationUx.exe',
            'C:\\Windows\\system32\\powercfg.exe',
            'C:\\Windows\\system32\\sndVol.exe',
            'C:\\Windows\\system32\\sppsvc.exe',
            'C:\\Windows\\system32\\wbem\\WmiApSrv.exe'
          )
            or
          ps.comm iin
          (
            'C:\\WINDOWS\\system32\\devicecensus.exe UserCxt',
            'C:\\Windows\\System32\\usocoreworker.exe -Embedding'
          )
    - name: svchost
      condition: ps.comm iin {{ .Values.processes.comm.svchost | stringify }}
    - name: Microsoft edge
      condition: ps.comm istartswith '\"C:\\Program Files (x86)\\Microsoft\\Edge Dev\\Application\\msedge.exe\" --type='
    - name: Microsoft dotNet
      condition: ps.comm istartswith
          (
            'C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\ngen.exe',
            'C:\\WINDOWS\\Microsoft.NET\\Framework64\\v4.0.30319\\Ngen.exe'
          )
            or
          ps.exe imatches
          (
            'C:\\Windows\\Microsoft.NET\\Framework64\\*\\mscorsvw.exe',
            'C:\\Windows\\Microsoft.NET\\Framework\\*\\mscorsvw.exe',
            'C:\\Windows\\Microsoft.Net\\Framework64\\*\\WPF\\PresentationFontCache.exe'
          )
    - name: Microsoft Office
      condition: ps.exe iin
          (
            'C:\\Program Files\\Microsoft Office\\Office16\\MSOSYNC.EXE',
            'C:\\Program Files (x86)\\Microsoft Office\\Office16\\MSOSYNC.EXE',
            'C:\\Program Files\\Common Files\\Microsoft Shared\\OfficeSoftwareProtectionPlatform\\OSPPSVC.EXE',
            'C:\\Program Files\\Microsoft Office\\Office16\\msoia.exe',
            'C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\officebackgroundtaskhandler.exe',
            'C:\\Program Files\\Common Files\\Microsoft Shared\\ClickToRun\\OfficeC2RClient.exe'
          )
    - name: Media Player
      condition: ps.exe = 'C:\\Program Files\\Windows Media Player\\wmpnscfg.exe'
    - name: Google
      condition: ps.comm istartswith
          (
            '\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\\\" --type=',
            '\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --type='
          )

# ======================= Process termination ========================================================
#
- group: Suspicious process terminations
  selector:
    type: TerminateProcess
  policy: include
  rules:
    - name: User binaries
      condition: ps.name istartswith ('C:\\Users', '\\')


# ======================= Remote thread creation =====================================================
#
# Monitor for processes injecting code into other processes. Often used by malware to cloak their actions.
# Also when Firefox loads Flash.
#
- group: Suspicious remote thread creations
  selector:
    type: CreateThread
  policy: include
  rules:
    - name: Fishy remote threads
      condition: kevt.pid != thread.pid
             and
           ps.exe not iin
           (
              'C:\\Windows\\system32\\wbem\\WmiPrvSE.exe',
              'C:\\Windows\\system32\\svchost.exe',
              'C:\\Windows\\system32\\wininit.exe',
              'C:\\Windows\\system32\\csrss.exe',
              'C:\\Windows\\system32\\services.exe',
              'C:\\Windows\\system32\\winlogon.exe',
              'C:\\Windows\\system32\\audiodg.exe',
              'C:\\Windows\\system32\\kernel32.dll',
              'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe'
           )
      action: >
        {{ emit
            (printf "Detected remote thread creation in %s" .Kevt.Kparams.exe)
            (printf "Possible code injection by %s" .Kevt.PS.Exe)
        }}

# ======================= Network connection initiated ===============================================
#
# By default this configuration takes a very conservative approach to network logging,
# limited to only extremely high-signal events.
#
- group: Suspicious network-connecting binaries
  selector:
    type: Connect
  policy: include
  rules:
    - name: Suspicious sources for network-connecting binaries
      condition: ps.exe istartswith
          (
            'C:\\Users',
            'C:\\Recycle',
            'C:\\ProgramData',
            'C:\\Windows\\Temp',
            '\\',
            'C:\\perflogs',
            'C:\\intel',
            'C:\\Windows\\fonts',
            'C:\\Windows\\system32\\config'
          )
    - name: Suspicious Windows tools network-connecting binaries
      condition: ps.name in
          (
            'at.exe',
            'certutil.exe',
            'cmd.exe',
            'cmstp.exe',
            'cscript.exe',
            'driverquery.exe',
            'dsquery.exe',
            'hh.exe',
            'infconditionaultInstall.exe',
            'java.exe',
            'javaw.exe',
            'javaws.exe',
            'mmc.exe',
            'msbuild.exe',
            'mshta.exe',
            'msiexec.exe',
            'nbtstat.exe',
            'net.exe',
            'net1.exe',
            'notepad.exe',
            'nslookup.exe',
            'powershell.exe',
            'qprocess.exe',
            'qwinsta.exe',
            'reg.exe',
            'regsvcs.exe',
            'regsvr32.exe',
            'rundll32.exe',
            'rwinsta.exe',
            'sc.exe',
            'schtasks.exe',
            'taskkill.exe',
            'tasklist.exe',
            'wmic.exe',
            'wscript.exe'
          )
    - name: Relevant 3rd Party Tools
      condition: ps.name in
          (
            'nc.exe',
            'ncat.exe',
            'psexec.exe',
            'psexesvc.exe',
            'tor.exe',
            'vnc.exe',
            'vncservice.exe',
            'vncviewer.exe',
            'winexesvc.exe',
            'nmap.exe',
            'psinfo.exe'
          )
    - name: Suspicious ports
      condition: net.dport in
          (
            22,
            23,
            25,
            143,
            3389,
            5800,
            5900,
            444,
            1080,
            3128,
            8080,
            1723,
            9001,
            9030
          )

- group: Microsoft binaries and known addresses
  selector:
    type: Connect
  policy: exclude
  rules:
    - name: Microsoft binaries
      condition: ps.exe istartswith 'C:\\ProgramData\\Microsoft\\Windows conditionender\\Platform\\'
              or
           ps.exe endswith 'AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe'
              or
           net.dip.names endswith
           (
              '.microsoft.com',
              'microsoft.com.akadns.net',
              'microsoft.com.nsatc.net'
           )
    - name: OCSP protocol known addresses
      condition: net.dip in (23.4.43.27, 72.21.91.29)
    - name: Loopback addresses
      condition: net.dip = 127.0.0.1 or net.dip startswith 'fe80:0:0:0'

# ======================= File created ===============================================================
#
- group: Suspicious file creation operations
  selector:
    type: CreateFile
  policy: include
  rules:
    - name: Startup links and shortcut modifications
      condition: file.operation = 'create'
              and
           file.name icontains
           (
              '\\Start Menu',
              '\\Startup\\'
           )
    - name: Microsoft Outlook attachments
      condition: file.operation = 'create' and file.name icontains '\\Content.Outlook\\'
    - name: Downloaded files
      condition: file.operation = 'create' and file.name icontains '\\Downloads\\'
    - name: Microsoft ClickOnce application
      condition: file.operation = 'create'
              and
           file.extension in
           (
              '.application',
              '.appref-ms'
           )
    - name: Batch scripting
      condition: file.operation = 'create'
              and
           file.extension in
           (
              '.bat',
              '.chm',
              '.cmd',
              '.cmdline'
           )
    - name: Fishy extensions
      condition: file.operation = 'create'
              and
           file.extension in
           (
              '.dll',
              '.exe',
              '.exe.log',
              '.jar',
              '.jnlp',
              '.jse',
              '.hta',
              '.job',
              '.pptm',
              '.ps1',
              '.sys',
              '.scr',
              '.vbe',
              '.vbs',
              '.xlsm',
              '.ocx',
              '.sln',
              '.xls'
           )
    - name: Powershell persistence
      condition: file.operation = 'create'
              and
           file.name imatches 'C:\\Windows\\*\\WindowsPowerShell'

# ======================= Registry modification ======================================================
#
- group: Suspicious registry key modifications
  selector:
    category: registry
  policy: include
  rules:
    - name: Core Windows keys
      condition: >
        kevt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
              and
           registry.key.name icontains
              (
                'CurrentVersion\\Run',
                'Policies\\Explorer\\Run',
                'Group Policy\\Scripts',
                'Windows\\System\\Scripts',
                'CurrentVersion\\Windows\\Load',
                'CurrentVersion\\Windows\\Run',
                'CurrentVersion\\Winlogon\\Shell',
                'CurrentVersion\\Winlogon\\System',
                'UserInitMprLogonScript'
              )
              or
           registry.key.name istartswith
              (
                'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
                'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
                'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
                'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
                'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
                'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
              )
              or
           registry.key.name iendswith
              (
                'user shell folders\\startup'
              )

    - name: Services
      condition: kevt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
              and
           registry.key.name iendswith
           (
              '\\ServiceDll',
              '\\ServiceManifest',
              '\\ImagePath',
              '\\Start',
              'CurrentVersion\\Run'
           )

```

`configs/rules/default/stateful.yml`:

```yml
- group: remote connection and command shell execution
  policy: sequence
  rules:
    - name: establish remote connection
      condition: >
        kevt.name = 'Connect'
          and
          not
        cidr_contains(
          net.dip,
          '10.0.0.0/8',
          '172.16.0.0/12',
          '172.17.0.0/16',
          '192.168.0.0/16')
    - name: spawn command shell
      max-span: 1m
      condition: >
        kevt.name = 'CreateProcess'
          and
        ps.pid = $1.ps.pid
          and
        ps.sibling.name in ('cmd.exe', 'powershell.exe')
  action: >
    {{ emit "Command shell spawned after remote connection"
      (printf "%s process spawned a command shell after connecting to %s" .Kevts.k2.PS.Exe .Kevts.k1.Kparams.dip)
    }}

```

`configs/rules/default/values.yml`:

```yml
# ========================= Values.yml ==================================================
#
# This file contains process image names, command line signatures, file names or registry
# keys that are utilized in filter group files to make them more readable and avoid cluttering
# with massive payloads.
#
processes:
  comm:
    svchost:
      - C:\\Windows\\system32\\svchost.exe -k appmodel -s StateRepository
      - C:\\Windows\\system32\\svchost.exe -k appmodel -p -s camsvc
      - C:\\Windows\\system32\\svchost.exe -k appmodel
      - C:\\Windows\\system32\\svchost.exe -k appmodel -p -s tiledatamodelsvc
      - C:\\Windows\\system32\\svchost.exe -k camera -s FrameServer
      - C:\\Windows\\system32\\svchost.exe -k dcomlaunch -s LSM
      - C:\\Windows\\system32\\svchost.exe -k dcomlaunch -s PlugPlay
      # Windows defragmentation
      - C:\\Windows\\system32\\svchost.exe -k defragsvc
      - C:\\Windows\\system32\\svchost.exe -k devicesflow -s DevicesFlowUserSvc
      # Microsoft: The Windows Image Acquisition Service
      - C:\\Windows\\system32\\svchost.exe -k imgsvc
      - C:\\Windows\\system32\\svchost.exe -k localService -s EventSystem
      - C:\\Windows\\system32\\svchost.exe -k localService -s bthserv
      - C:\\Windows\\system32\\svchost.exe -k LocalService -p -s BthAvctpSvc
      - C:\\Windows\\system32\\svchost.exe -k localService -s nsi
      - C:\\Windows\\system32\\svchost.exe -k localService -s w32Time
      # Windows: Network services
      - C:\\Windows\\system32\\svchost.exe -k localServiceAndNoImpersonation
      - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s Dhcp
      - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s EventLog
      - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s TimeBrokerSvc
      - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s WFDSConMgrSvc
      - C:\\Windows\\system32\\svchost.exe -k LocalServiceNetworkRestricted -s BTAGService
      # Win10:1903: Network Connection Broker
      - C:\\Windows\\System32\\svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService
      - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted
      - C:\\Windows\\system32\\svchost.exe -k localServiceAndNoImpersonation -s SensrSvc
      # Windows: SSDP [ https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol ]
      - C:\\Windows\\system32\\svchost.exe -k localServiceAndNoImpersonation -p -s SSDPSRV
      - C:\\Windows\\system32\\svchost.exe -k localServiceNoNetwork
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -p -s WPDBusEnum
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -p -s fhsvc
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s DeviceAssociationService
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s NcbService
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s SensorService
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s TabletInputService
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s UmRdpService
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s WPDBusEnum
      # Microsoft: Passport
      - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -p -s NgcSvc
      # Microsoft: Passport Container
      - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -p -s NgcCtnrSvc
```

`docs/CNAME`:

```
www.fibratus.io
```

`docs/README.md`:

```md
# Welcome to Fibratus Docs!

Fibratus documentation is built with [docsify](https://docsify.js.org/#/) site generator. docsify generates the documentation website on the fly by parsing the Markdown files. To preview the docs while you're editing, you can use the `docsify` CLI tool.

- download [Node.JS](https://nodejs.org/en/download/)
- `npm install -g docsify`
- go to the `docs` directory and run `docsify serve`
- browse the docs on `http://localhost:3000`

```

`docs/_coverpage.md`:

```md
<!-- _coverpage.md -->

<div>
  <img src='logo.png'></img>
</div>

# fibratus <small>1.6.0</small>

> A modern tool for Windows kernel exploration and observability with a focus on security

- <ion-icon class="fast-icon" name="flash"></ion-icon> Fast
- <ion-icon class="extensible-icon" name="cube"></ion-icon> Extensible
- <ion-icon class="comprehensive-icon" name="magnet"></ion-icon> Comprehensive


<a href="https://github.com/rabbitstack/fibratus/releases" target="_blank" rel="noopener"><ion-icon name="download"></ion-icon> Download</a>
<a href="#/setup/installation"><ion-icon name="rocket"></ion-icon> Get Started</a>

<div>
  <img src='images/fibratus-term.gif'></img>
</div>

```

`docs/_sidebar.md`:

```md
* <ion-icon name="infinite-outline"></ion-icon> Overview
  * [What is Fibratus?](overview/what-is-fibratus.md)
* <ion-icon name="rocket-outline"></ion-icon> Setup
  * [Installation](setup/installation.md)
  * [Running](setup/running.md)
  * [Configuration](setup/configuration.md)
* <ion-icon name="apps-outline"></ion-icon> Events
  * [Anatomy Of An Event](kevents/anatomy.md)
  * [Process](kevents/process.md)
  * [Thread](kevents/thread.md)
  * [Image](kevents/image.md)
  * [File](kevents/file.md)
  * [Registry](kevents/registry.md)
  * [Network](kevents/network.md)
  * [Handle](kevents/handle.md)
* <ion-icon name="filter-outline"></ion-icon> Filters and Rules
  * [Needle In The Haystack](filters/introduction.md)
  * [Prefiltering](filters/prefiltering.md)
  * [Filtering](filters/filtering.md)
  * [Operators](filters/operators.md)
  * [Paths](filters/paths.md)
  * [Functions](filters/functions.md)
  * [Fields](filters/fields.md)
  * [Rules](filters/rules.md)
* <ion-icon name="server-outline"></ion-icon> Captures
  * [Immortalizing The Event Flux](captures/introduction.md)
  * [Capturing](captures/capturing.md)
  * [Replaying](captures/replaying.md)
* <ion-icon name="flash-outline"></ion-icon> Filaments
  * [Python Meets Kernel Events](filaments/introduction.md)
  * [Executing](filaments/executing.md)
  * [Internals](filaments/internals.md)
  * [Writing Filaments](filaments/writing.md)
* <ion-icon name="send-outline"></ion-icon> Outputs
  * [Transporting Kernel Events](outputs/introduction.md)
  * [Console](outputs/console.md)
  * [Null](outputs/null.md)
  * [RabbitMQ](outputs/rabbitmq.md)
  * [Elasticsearch](outputs/elasticsearch.md)
  * [HTTP](outputs/http.md)
  * [Eventlog](outputs/eventlog.md)
* <ion-icon name="color-wand-outline"></ion-icon> Transformers
  * [Parsing, Enriching, Transforming](transformers/introduction.md)
  * <ion-icon name="remove-circle-outline"></ion-icon> [Remove](transformers/remove.md)
  * <ion-icon name="reload-circle-outline"></ion-icon> [Rename](transformers/rename.md)
  * <ion-icon name="sync-circle-outline"></ion-icon> [Replace](transformers/replace.md)
  * <ion-icon name="pricetags-outline"></ion-icon> [Tags](transformers/tags.md)
  * <ion-icon name="cut-outline"></ion-icon> [Trim](transformers/trim.md)
* <ion-icon name="locate-outline"></ion-icon> Alerts
  * [Watchdogging Kernel Events](alerts/introduction.md)
  * [Alert Senders](alerts/senders.md)
    * <ion-icon name="mail-unread-outline"></ion-icon> [Mail](alerts/senders/mail.md)
    * <ion-icon name="logo-slack"></ion-icon> [Slack](alerts/senders/slack.md)
  * [Filament Alerting](alerts/filaments.md)
* <ion-icon name="terminal-outline"></ion-icon> PE
  * [Portable Executable Introspection](/pe/introduction.md)
  * [Sections](/pe/sections.md)
  * [Symbols](/pe/symbols.md)
  * [Resources](/pe/resources.md)
* <ion-icon name="bug-outline"></ion-icon> Yara
  * [Pattern Matching Swiss Knife](/yara/introduction.md)
  * [Scanning Processes](/yara/scanning.md)
  * [Alerts](/yara/alerts.md)
* <ion-icon name="help-buoy-outline"></ion-icon> Troubleshooting
  * [Logs](troubleshooting/logs.md)
  * [Stats](troubleshooting/stats.md)
  * [Profiling](troubleshooting/pprof.md)

```

`docs/alerts/filaments.md`:

```md
# Filament Alerting

Filaments produce alerts by invoking the `emit_alert` function. The alert is propagated to all active alert senders.

The `emit_alert` function accepts two positional and two keyword arguments. Here is the signature of the function:

```python
emit_alert(title, text, severity='normal', tags=[])
```

An example of calling the `emit_alert` function to generate an alert from the filament that detects registry persistence attacks:

```python
emit_alert(
        f'Registry persistence gained via {kevent.kparams.key_name}',
        text(kevent),
        severity='medium',
        tags=['registry persistence']
)
```

```

`docs/alerts/introduction.md`:

```md
# Watchdogging Kernel Events

Fibratus has the ability to generate alerts when an unexpected flow is detected in the system. Some alerts are generated out of the box, for example, when the [YARA scanner](/yara/scanning) yields rule matches. Other alerts are emitted directly from [filaments](/alerts/filaments) when the conditions are met.

The alert has the following key components:

- **title** summarizes the purpose of the alert.
- **text** is the message that further explains what this alert is about as well as actors involved.
- **tags** contains a sequence of tags for categorizing the alerts.
- **severity** determines the severity of the alert. Possible values are `normal`, `medium`, `critical`.

To send alert notifications, use [alert senders](/alerts/senders).

```

`docs/alerts/senders.md`:

```md
# Alert Senders

You can send alert notifications to your team through email, Slack, or incident response platforms. The notification can be sent to multiple alert senders. Alert senders configuration resides in the `alertsenders` section of the `yml` file.

- [Mail](/alerts/senders/mail)
- [Slack](/alerts/senders/mail)

```

`docs/alerts/senders/mail.md`:

```md
# Mail

The mail alert sender emits alert notifications through the `SMTP` protocol.

### Configuration {docsify-ignore}

The `mail` alert sender configuration is located in the `alertsenders.mail` section.

#### enabled

Indicates if the alert sender is enabled.

**default**: `false`

#### host

Represents the host name of the SMTP server where the alert notification is sent.

#### port

Represents the port number of the SMTP server.

**default**: `25`

#### user

Specifies the user name when authenticating to the SMTP server.

#### password

Specifies the password when authenticating to the SMTP server.

#### from

Determines the sender's email address.

#### to

Specifies the list of the recipient email addresses.

```

`docs/alerts/senders/slack.md`:

```md
# Slack

The `slack` alert sender forwards alerts to Slack workspaces. You'll have to [activate](https://slack.com/intl/en-es/help/articles/115005265063-Incoming-webhooks-for-Slack) incoming webhooks and associate the webhook to your Slack workspace to be able to emit the alerts.

### Configuration {docsify-ignore}

The `slack` alert sender configuration is located in the `alertsenders.slack` section.

#### enabled

Indicates whether the `slack` alert sender is enabled.

**default**: `false`

#### url

Represents the Webhook URL of the workspace where alerts will be dispatched. The Webhook URL has the following format: `https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX`.

#### workspace

The name of the Slack workspace where alerts are routed.

#### channel

Is the slack channel in which to post alerts.

#### emoji

Represents the emoji icon surrounded in `:` characters for the Slack bot.

```

`docs/captures/capturing.md`:

```md
# Capturing

Under the hood, captures are written to disk in the form of the [zstd](https://en.wikipedia.org/wiki/Zstandard) compressed streams. zstd provides a compelling balance between the capture file size and the compression runtime overhead.

Each capture file consists of the header that represents the `kcap` magic, major/minor version, and some arbitrary flags. Next, the handle snapshot is stored with all allocated handles followed by kernel events. We can forgo persisting the process snapshot, because it can be reconstructed when replaying the capture and processing the `EnumProcess` events.

Capturing is initiated by running the `fibratus capture` command. The `o` flag, that stands for `output`, specifies the `kcap` file where events are dumped. The capture file is stored in the current working directory. **Any already existing file is overwritten**. To above command would produce a capture and store all events in `events.kcap` file.

```
$ fibratus capture -o events
```

To stop capturing events, hit the `Ctrl-C` key combination. A short summary is displayed indicating the number of captured events, processes, handles, the size of the `kcap` file and so on.

### Filtering {docsify-ignore}

As already explained in [filtering](/filters/filtering), for a fine-grained control over which events are stored in the capture, you can provide a filter expression.

```
$ fibratus capture kevt.category = 'file' -o fs-events
```

```

`docs/captures/introduction.md`:

```md
# Immortalizing The Event Flux

Captures or `kcap` files aim for the capture-once replay-anywhere workflow. Captures contain the full state of processes at the time capture was taken as well as the originated event flux. This makes them a great companion in post-mortem investigations - generate the capture in the honeypot machine, grab the `.kcap` file, and you're ready to dive into the attacker kill chain by replaying the capture file on your laptop.

With captures you "freeze" the shape of the event flux at a certain point in time. Do you need to troubleshoot an network issue and surface the root cause? Or maybe you need to determine what files were written by a malicious process? Replay the capture at any given time and drill down into the event flow to start investigating.

You can harness the power of the filtering engine when replaying captures or even execute a filament on top of captured events.

```

`docs/captures/replaying.md`:

```md
# Replaying

Replaying essentially recovers the handle/process state and consumes the captured event flux. It is important to point out that Fibratus increments the major `kcap` version under relevant changes in the format structure. Because of this, old capture files might not be able to replay due to mismatch of the `kcap` major version digit.

To replay the `kcap` file, you launch the following command.

```
$ fibratus replay -k events
```

### Filtering {docsify-ignore}

To drill down into capture by filtering out valuable events, you can provide a filter.

```
$ fibratus replay file.name contains 'Temp' -k fs-events
```

### Filaments {docsify-ignore}

Another compelling use case stems from running a filament on top of events living in the capture. To run a filament you supply the filament name via the `-f` or `--filament.name` option.

```
$ fibratus replay -f watch_files -k fs-events
```

```

`docs/filaments/executing.md`:

```md
# Executing Filaments

Filaments are bootstrapped via the `fibratus run` command by specifying the filament name. Use the `-f` or `--filament.name` flags to indicate the filament you'd like to run.

```
$ fibratus run -f watch_files
```

The filament will keep running until the keyboard interrupt signal is received. 

### Passing arguments to filaments {docsify-ignore}

Filaments may require additional arguments to execute some conditional logic or set up a filter. Arguments are passed to a filament by specifying a list of comma-separated values after filament name:

```
$ fibratus run -f "watch_files,powershell.exe"
```

This populates the [sys.argv](https://docs.python.org/3/library/sys.html#sys.argv) list with the provided arguments, where `sys.argv[0]` is the filament name.


### Listing filaments {docsify-ignore}

By default, filaments reside within the `%PROGRAMFILES%\Fibratus\Filaments` directory. It is possible to override this location by specifying an alternative directory via the `--filament.path` flag or by editing the config file.

To list available filaments, run the below command.

```
$ fibratus list filaments
```

### Filters {docsify-ignore}

Engaging filters in filaments can be accomplished in two ways:

- the command line argument when running the filament
- the `kfilter` function during filament initialization

If the filter expression is supplied in both the CLI argument and the `kfilter` function, the one set in the latter takes precedence.

```

`docs/filaments/internals.md`:

```md
# Internals

Filaments are scheduled as independent Python Virtual Machines and thus they have their own memory and other resources allocated. Fibratus takes as an input a Python module consisting of various functions and converts them into a running instance of the Python interpreter that knows how to process incoming kernel events. It also augments the Python module with numerous functions that permit a filament to interact with alerts and other state exposed by Fibratus.

### Event dispatching {docsify-ignore}

The backbone of a filament is the `on_next_kevent` function. It's executed whenever a new kernel event arrives. The parameter of this function is the Python dictionary that contains event data. Here is the structure of such a dictionary object:

```python
{
  'seq': 122344,
  'pid': 2034,
  'tid': 2453,
  'ppid': 45,
  'cwd': 'C:\Windows\system32',
  'exe': 'cmd.exe',
  'comm': 'cmd.exe rm /r',
  'sid': 'archrabbit\SYSTEM',
  'cpu': 2,
  'name': 'CreateFile',
  'category': 'file',
  'timestamp': '2013-08-23 16:15:13.4323',
  'host': 'archrabbit',
  'description': 'Creates or opens a file or I/O device',
  'kparams': {
    'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
    'file_object': 'ffffa88c7ea077d0',
    'irp': 'ffffa88c746b2a88',
    'operation': 'supersede',
    'share_mask': 'rw-',
    'type': 'directory'
  }
}
```

For a more convenient dictionary accesses, you can annotate the function with the `dotdictify` decorator.

```python
from utils.dotdict import dotdictify

@dotdictify
def on_next_kevent(kevent):
    print(f'{kevent.name} generated by {kevent.exe}')
```

### Initialization {docsify-ignore}

If the `on_init` function is declared in the filament, any logic wrapped inside this function is executed prior to event processing. This is a convenient place for configuring the table columns or establishing the `on_interval` function triggering intervals among other initialization tasks.

```python
def on_init():
    interval(1)
```

### Termination {docsify-ignore}

The `on_stop` function is called right before the Python interpreter is teared down. You can place any code you would like to get executed when the filament is stopped.

```python
def on_stop():
    f.close()
```

### Periodical actions {docsify-ignore}

Filament has built-in support for scheduling timers. The timer, associated with the `on_interval` function, is fired after the interval specified by the `interval` function elapses. The minimum interval granularity is one second.

```python
def on_interval():
    for ip, count in __connections__.copy().items():
      f.write(f'{ip.count}')
```

### Filtering {docsify-ignore}

The `kfilter` function defines a filter expression for the life span of a filament. Filaments give an appealing approach for constructing the filters dynamically. For example, this following code snippet defines a filter from the list:

```python
kfilter("ps.name in (%s)" % (', '.join([f'\'{ps}\'' for ps in __procs__])))
```

### Table rendering {docsify-ignore}

Filaments are able to render tabular data on the console in a flicker-free fashion by using the frame buffers. To render a table, you start by defining the columns with the `columns` function. It's possible to sort the data by specifying the column via `sort_by` function. Finally, the `add_row` function appends rows to the table. When you're ready to draw the table, invoke the `render_table` function.

```python
def on_init():
    columns(["Source", "Count"])
    sort_by('Count')
    interval(1)

def on_interval():
    for ip, count in __connections__.copy().items():
        add_row([ip, count])
    render_table()
```

### Python distribution and pip {docsify-ignore}

Fibratus bundles embedded Python 3.7 distribution. Installing additional packages can be achieved by running the `pip` command from the `%PROGRAM FILES%\Fibratus\Python\Scripts` directory.

```

`docs/filaments/introduction.md`:

```md
# Python Meets Kernel Events

**Python** is the lingua franca of pen testers and other **SecOps**-driven individuals. Many security tools are written in Python language.
Wouldn't it be awesome to exploit the arsenal of those tools in Fibratus or build your own tools atop them?

Fibratus incorporates a framework for painlessly extending the functionality and incorporating new features via Python scripts. These scripts are called **filaments**. You can also think of them as extension points with virtually endless possibilities. Whatever you are allowed to craft in Python, you can also implement in filaments.

Filaments are executed on top of kernel event flux and thus they have access to all event's parameters, process state and so on.
From technical perspective, a filament is a full-fledged instance of the Python interpreter. Fibratus interacts with the **CPython** API to bootstrap the interpreter, initialize the module from filament definition, declare functions and other related tasks.

```

`docs/filaments/writing.md`:

```md
# Writing Filaments

The best way to grasp filaments is by writing a new filament from scratch. The following is the walkthrough of building a filament that fetches the IP blacklist database and relies on it to detect outbound/inbound connections to botnets, C&C servers, and other fishy destinations.

Let's first define the function for fetching the database and converting it into a list. We also declare two regular expressions for accepting only valid IP addresses or IP addresses in CIDR notation. Note that we use the `requests` package for fetching the database.

```python
IP_RE      = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}(?!\d|(?:\.\d))")
IP_CIDR_RE = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}/\d{1,2}(?!\d|(?:\.\d))")

def fetch_db(url):
    with requests.get(url) as r:
      ips = [ipaddress.ip_network(l) if '/' in l else ipaddress.ip_address(l) \
          for l in r.text.splitlines() if IP_RE.match(l) or IP_CIDR_RE.match(l)]
    return ips
```

We call into the `fetch_db` function during filament initialization and store the result into the global `__fishy_ips__` list. Additionally, we'll schedule the syncing of the IP database every hour to get the latest definitions of spam nets and attacker IP addresses. Since we're only interested in network events, we'll set the filter accordingly.

```python
IP_DB_URL = 'http://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt'

def on_init():
    __fishy_ips__ = fetch_db(IP_DB_URL)
    interval(3600)
    kfilter("kevt.category = 'net'")
    columns(["Source", "Destination", "Process"])

def on_interval():
    __fishy_ips__ = fetch_db(IP_DB_URL)
```

Now, we'll implement the main logic for checking whether the network flow is involved in compromised communication such as C&C server requests. Here we simply add a new row and render a table with the source/destination IP address and the process that initiated the network request.

```python
@dotdictify
def on_next_kevent(kevent):
    sip = kevent.kparams.sip
    dip = kevent.kparams.dip
    if (sip in __fishy_ips__ or dip in __fishy_ips__) or \
        (sip or dip in net for net in __fishy_ips__ if isinstance(net, ipaddress.IPv4Network)):
        add_row([sip, dip, kevent.exe])
    render_table()
```

We could have generated an alert and send it via Slack or email. We'll touch on emitting the alerts in [filament alerting](/alerts/filaments).

The full source code of our filament would look similar to the snippet above.

```python
"""
Pinpoints network communications with botnets or C&C servers.
"""

import requests
import re
import ipaddress
from utils.dotdict import dotdictify

IP_RE      = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}(?!\d|(?:\.\d))")
IP_CIDR_RE = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}/\d{1,2}(?!\d|(?:\.\d))")
IP_DB_URL = 'http://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt'


def fetch_db(url):
    with requests.get(url) as r:
      ips = [ipaddress.ip_network(l) if '/' in l else ipaddress.ip_address(l) \
            for l in r.text.splitlines() if IP_RE.match(l) or IP_CIDR_RE.match(l)]
    return ips


def on_init():
    __fishy_ips__ = fetch_db(IP_DB_URL)
    interval(3600)
    kfilter("kevt.category = 'net'")
    columns(["Source", "Destination", "Process"])


@dotdictify
def on_next_kevent(kevent):
    sip = kevent.kparams.sip
    dip = kevent.kparams.dip
    if (sip in __fishy_ips__ or dip in __fishy_ips__) or \
        (sip or dip in net for net in __fishy_ips__ if isinstance(net, ipaddress.IPv4Network)):
        add_row([sip, dip, kevent.exe])
    render_table()


def on_interval():
    __fishy_ips__ = fetch_db(IP_DB_URL)
```

Save it to, let's say, `cc.py` file inside the `%PROGRAMFILES%\Fibratus\Filaments` directory and you're ready to go. Run the filament with the following command:

```
$ fibratus run -f cc
```

```

`docs/filters/fields.md`:

```md
# Fields

In Fibratus filter expression language the fields can evaluate to one of the following types:

- **string** values are enclosed in single quotes and escaped according to these [rules](filters/filtering?id=escaping-characters)
- **number** field types can be both integer and floating-point numbers. Floating point numbers use the dot notation (`6.54`).
- **IP address** field types represent IPv4 addresses (`172.14.4.4`)
- **bool** represents the `true` or `false` boolean values

## Filter fields {docsify-ignore}

The following tables summarize available field names that can be used in filter expressions.

### Event
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| kevt.seq      | Monotonic event sequence number       | `kevt.seq > 666`   |
| kevt.pid      | Process identifier generating the kernel event       | `kevt.pid = 6`   |
| kevt.tid      | Thread identifier generating the kernel event       | `kevt.tid = 1024`   |
| kevt.cpu      | Logical processor core where the event was generated       | `kevt.cpu = 2`   |
| kevt.name      | Symbolical kernel event name       | `kevt.name = 'CreateThread'`   |
| kevt.category      | Category to which the event pertains      | `kevt.category = 'registry'`   |
| kevt.desc      | Cursory event description      | `kevt.desc contains 'Creates'`   |
| kevt.host      | Hostname on which the event was produced     | `kevt.host contains 'dev'`   |
| kevt.nparams    | Number of event parameters     | `kevt.nparams > 2`   |
| kevt.time      | Event timestamp as a time string      | `kevt.time = '17:05:32'`   |
| kevt.time.h      | Hour within the day on which the event occurred      | `kevt.time.h = 23`   |
| kevt.time.m      | Minute offset within the hour on which the event occurred      | `kevt.time.m = 54`   |
| kevt.time.s      | Second offset within the minute on which the event occurred      | `kevt.time.s = 0`   |
| kevt.time.ns     | Nanoseconds specified by the event timestamp      | `kevt.time.ns > 1591191629102337000`   |
| kevt.date       | Event timestamp as a date string      | `kevt.date = '2018-03-03'`   |
| kevt.date.d     | Day of the month on which the event occurred      | `kevt.date.d = 12`   |
| kevt.date.m     | Month of the year on which the event occurred      | `kevt.date.m = 11`   |
| kevt.date.y     | Year on which the event occurred      | `kevt.date.y = 2020`   |
| kevt.date.tz    | Time zone associated with the event timestamp     | `kevt.date.tz = 'UTC'`   |
| kevt.date.week    | Week number within the year on which the event occurred     | `kevt.date.week = 2`   |
| kevt.date.weekday    | Week day on which the event occurred     | `kevt.date.weekday = 'Monday'`   |

### Process
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| ps.pid         | Process identifier generating the kernel event. Alias for `kevt.pid` | `ps.pid = 1024`   |
| ps.ppid         | Parent process identifier of the process generating the kernel event | `ps.ppid = 25`   |
| ps.name         | Process (image) path name that generates an event | `ps.name = 'cmd.exe'`   |
| ps.comm         | Process command line | `ps.comm contains '/E c:\\ads\\file.txt:regfile.reg'`   |
| ps.exe          | Full name of the process' executable | `ps.exe = 'C:\\Windows\\system32\\cmd.exe'`   |
| ps.args         | Process command line arguments | `ps.args in ('/cdir', '/-C')`   |
| ps.cwd          | Process current working directory | `ps.cwd = 'C:\\Users\\Default'`   |
| ps.sid          | Security identifier under which this process is run | `ps.sid contains 'SYSTEM'`   |
| ps.domain       | Process domain name  | `ps.domain = 'NT AUTHORITY'`   |
| ps.username     | Process user name  | `ps.username = 'SYSTEM'`   |
| ps.sessionid    | Unique identifier for the current session | `ps.sessionid = 1`   |
| ps.access.mask  | Process access rights | `ps.access.mask = '0x1000'`   |
| ps.access.mask.names  | Process access human-readable rights | `ps.access.mask.names in ('TERMINATE', 'QUERY_INFORMATION')`   |
| ps.access.status  | Process access status | `ps.access.status = 'success'`   |
| ps.envs         | Process environment variables | `ps.envs in ('MOZ_CRASHREPORTER_DATA_DIRECTORY')`  |
| ps.envs[]       | Accesses a specific environment variable. Prefix matches are supported | `ps.envs['MOZ_CRASHREPORTER'] = 'C:\\Program Files\\Firefox'`  |
| ps.dtb          | Process directory table base address | `ps.dtb = '7ffe0000'` |
| ps.handles      | Allocated process handles | `ps.handles in ('\\BaseNamedObjects\\__ComCatalogCache__')`   |
| ps.handle.types | Allocated process handle types | `ps.handle.types in ('Key', 'Mutant', 'Section')`   |
| ps.modules      | Modules loaded by the process | `ps.modules in ('crypt32.dll', 'xul.dll')`   |
| ps.modules[]    | Accesses a specific process module. Prefix matches are supported  | `ps.modules['crypt'].size > 1024`   |
| ps.parent.name    | Parent process name  | `ps.parent.name = 'powershell.exe'`   |
| ps.parent.pid    | Parent process identifier  | `ps.parent.pid = 2340`   |
| ps.parent.comm    | Parent process command line  | `ps.parent.comm contains 'attrib'`   |
| ps.parent.exe    | Full name of the parent process executable  | `ps.parent.exe = 'C:\\Windows\\system32\\cmd.exe'`   |
| ps.parent.cwd    | Parent process current working directory  | `ps.parent.cwd = 'C:\\Users\\Default'`   |
| ps.parent.sid    | Security identifier under which the parent process is run  | `ps.parent.sid contains 'SYSTEM'`   |
| ps.parent.domain    | Parent process domain name  | `ps.parent.domain = 'NT AUTHORITY'`   |
| ps.parent.username  | Parent process user name  | `ps.parent.username = 'SYSTEM'`   |
| ps.parent.sessionid    | Unique identifier for the current session of the parent process  | `ps.parent.session = 1`   |
| ps.parent.dtb    | Parent process directory table base address  | `ps.parent.dtb = 'powershell.exe'`   |
| ps.parent.envs    | Parent process environment variables   | `ps.parent.envs in ('PROCESSOR_LEVEL')'`   |
| ps.parent.handles    | Allocated parent process handles  | `ps.parent.handles in ('\\...\\Cor_SxSPublic_IPCBlock')`   |
| ps.parent.handle.types    | Allocated parent process handles types  | `ps.parent.handle.types in ('Key', 'Mutant', 'Section')`   |
| ps.ancestor[]    | Process ancestry traversing  | `ps.ancestor[2].name in ('winword.exe', 'powershell.exe')`   |
| ps.sibling.name    | Sibling process name  | `ps.sibling.name = 'cmd.exe'`   |
| ps.sibling.pid     | Sibling process identifier  | `ps.sibling.id = 6050`   |
| ps.sibling.comm    | Sibling process command line  | `ps.sibling.name contains '/k /v'`   |
| ps.sibling.exe     | Sibling process executable full path  | `ps.sibling.exe = 'C:\\Windows\\system32\\cmd.exe'`   |
| ps.sibling.sid     | Sibling process security identifier  | `ps.sibling.sid contains 'SYSTEM'`   |
| ps.sibling.sessionid   | Sibling process session identifier  | `ps.sibling.sessionid = 1`   |
| ps.sibling.domain    | Sibling process domain name  | `ps.sibling.domain = 'NT AUTHORITY'`   |
| ps.sibling.username  | Sibling process user name  | `ps.sibling.username = 'SYSTEM'`   |

### Thread
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| thread.prio     | Scheduler priority of the thread | `thread.prio = 5`   |
| thread.io.prio  | I/O priority hint for scheduling I/O operations | `thread.io.prio = 4`   |
| thread.page.prio | Memory page priority hint for memory pages accessed by the thread | `thread.page.prio = 12`   |
| thread.kstack.base | Base address of the thread's kernel space stack | `thread.kstack.base = 'a65d800000'`   |
| thread.kstack.limit | Limit of the thread's kernel space stack | `thread.kstack.limit = 'a85d800000'`   |
| thread.ustack.base | Base address of the thread's user space stack | `thread.ustack.base = '7ffe0000'`   |
| thread.ustack.limit | Limit of the thread's user space stack | `thread.ustack.limit = '8ffe0000'`   |
| thread.entrypoint | Starting address of the function to be executed by the thread | `thread.entrypoint = '7efe0000'`   |
| thread.access.mask | Thread access rights | `thread.access.mask = '0x1800'`   |
| thread.access.mask.names | Thread access human-readable rights | `thread.access.mask.names in ('QUERY_LIMITED_INFORMATION')`   |
| thread.access.status | Thread access status | `thread.access.status = 'success'`   |


### Image
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| image.name     | Full image path | `image.name = 'C:\\Windows\\System32\\advapi32.dll'`   |
| image.base.address  | Base address of the process in which the image is loaded | `image.base.address = 'a65d800000'`   |
| image.checksum  | Image checksum | `image.checksum = 746424`   |
| image.size  | Image size | `image.size > 1024`   |
| image.default.address  | Default image address | `image.default.address = '7efe0000'`   |

### File
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| file.object     | File object address in the kernel space | `file.object = 18446738026482168384`   |
| file.name       | Full file name | `file.name = 'C:\\Windows\\Sytem32\\regedit.exe'`   |
| file.operation  | Operation performed on the file or I/O device | `file.operation = 'open'`   |
| file.share.mask | File share mask | `file.share.mask = 'rw-'`   |
| file.io.size    | I/O read/write size | `file.io.size > 512`   |
| file.offset     | Read/write position in the file | `file.offset = 1024`   |
| file.type       | File type. Possible values are `file`, `directory`, `pipe`, `console`, `mailslot`, `other`, `unknown` | `file.type = 'directory'`   |
| file.extension  | File extension represents the file extension (e.g. .exe or .dll) | `file.extension = '.dll'`   |
| file.attributes | List of file attributes | `file.attributes in ('hidden', 'temporary')`   |
| file.status | System status message of the `CreateFile` operation | `file.status = 'success'`   |

### Registry
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| registry.key.name   | Fully qualified key name | `registry.key.name = 'HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services'`   |
| registry.key.handle | Registry key object address | `registry.key.handle = 'FFFFB905D60C2268'`   |
| registry.value      | Registry value content | `registry.value = '%SystemRoot%\\system32'`   |
| registry.value.type | Registry value type | `registry.value.type = 'REG_SZ'`   |
| registry.status     | Registry operation status | `registry.status != 'success'`   |

### Network
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| net.dip   | Destination IP address | `net.dip = 172.17.0.3`   |
| net.sip   | Source IP address | `net.sip = 127.0.0.1`   |
| net.dport   | Destination port | `net.dport in (80, 443, 8080)`   |
| net.sport   |Source port | `net.sport != 3306`   |
| net.dport.name   | Destination port name as per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service assignation | `net.dport.name = 'dns'`   |
| net.sport.name   | Source port name as per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service assignation | `net.sport.name = 'http'`   |
| net.l4.proto   | Layer 4 protocol name | `net.l4.proto = 'TCP'`   |
| net.size   | Network packet size | `net.size > 512`   |
| net.dip.names | List of destination IP address domain names | `net.dip.names in ('github.com.')` |
| net.sip.names | List of source IP address domain names | `net.sip.names in ('github.com.')` |

### Handle
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| handle.id   	| Handle identifier | `handle.id = 24`   |
| handle.object | Handle kernel object address | `handle.object = 'FFFFB905DBF61988'`   |
| handle.name   | Handle name | `handle.name = '\\Device\\NamedPipe\\chrome.12644.28.105826381'`   |
| handle.type   | Handle type | `handle.type = 'Mutant'`   |

### PE
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| pe.nsections   | Number of sections | `pe.nsections < 5`   |
| pe.nsymbols   | Number of entries in the symbol table | `pe.nsymbols > 230`   |
| pe.address.base   | Image base address | `pe.address.base = '140000000'`   |
| pe.address.entrypoint   | Address of the entrypoint function | `pe.address.entrypoint = '20110'`   |
| pe.sections[].entropy   | Specified section entropy | `pe.sections[.text].entropy > 6.2`   |
| pe.sections[].size   | Size in bytes of the specified section | `pe.sections[.text].size > 56000`   |
| pe.sections[].md5   | MD5 hash of the specified section | `pe.sections[.text].md5 = '0464997eb36c70083164c666d53c6af3'`   |
| pe.symbols   | Imported symbols | `pe.symbols in ('GetTextFaceW', 'GetProcessHeap')`   |
| pe.imports   | Imported dynamic linked libraries | `pe.imports in ('msvcrt.dll', 'GDI32.dll')`   |
| pe.resources  | Version and other PE resources | `pe.resources[FileDescription] = 'Notepad'`   |
| pe.company   | Internal company name of the file provided at compile-time | `pe.company = 'Microsoft Corporation'`  |
| pe.copyright | Copyright notice for the file emitted at compile-time | `pe.company = '© Microsoft Corporation'`  |
| pe.description   | Internal description of the file provided at compile-time | `pe.description = 'Notepad'`   |
| pe.file.name   | Original file name supplied at compile-time | `pe.file.name = 'NOTEPAD.EXE'`   |
| pe.file.version   | File version supplied at compile-time | `pe.file.version = '10.0.18362.693 (WinBuild.160101.0800)'`   |
| pe.product   | Internal product name of the file provided at compile-time | `pe.product = 'Microsoft® Windows® Operating System'`   |
| pe.product.name   | Internal product version of the file provided at compile-time | `pe.product.version = '10.0.18362.693'`   |


```

`docs/filters/filtering.md`:

```md
# Filtering

### Anatomy of a filter {docsify-ignore}

At its simplest form, a filter is composed of the LHS (Left Hand Side) and RHS (Right Hand Side) expressions connected with an [operator](/filters/operators) that can pertain to binary, logical, or string operators. The LHS expression is usually a [field](/filters/fields) [path](/filters/paths), even though the use of fields is possible in Right Hand Side expressions as well.

```
    LHS          operator         RHS
kevt.category       =            'net'
```

The RHS expressions can be strings, numbers, IP addresses, boolean values, and fields. In the above snippet, the RHS is a simple string literal, but we could have written filters with the following RHS expressions:

- IP addresses: `net.sip = 127.0.0.1`
- Booleans: `kevt.nparams != false`
- Numbers: `ps.pid = 4`
- Fields: `kevt.pid != ps.pid`

### Running filters {docsify-ignore}

As previously mentioned, filters can be engaged in various stages of event collection and processing. The filter expression is given  to `run`, `capture`, and `replay` commands in form of the command line argument.

The `run` command applies the filter expression to each inbound kernel event and prevents upstream propagation if the event doesn't match the filter. The above command filters events that occur on `Monday` and are produced by `cmd.exe` and `svchost.exe` processes.

```
$ fibratus run kevt.date.weekday = 'Monday' and ps.name in ('cmd.exe', 'svchost.exe')
```

!> If you're using PowerShell, it is necessary to enclose the entire filter expression in quotes. For example, `fibratus run "kevt.category = 'net'"`


In a similar fashion, the `capture` command only dumps events that match the provided filter. In this case, the capture would boil down to  `registry` kernel events.

```
$ fibratus capture kevt.category = 'registry' -o events
```

When replaying events from the kcap file, you can also specify a filter to narrow down the replay context, for example, to filter out events that mutate registry values.

```
$ fibratus replay kevt.name = 'RegSetValue' -k events
```

Lastly, filtering is possible during filament execution. If the filter is set in both, the `run` command and through the `kfilter` function, the latter takes precedence. Filtering in filaments is thoroughly explained in [filaments](/filaments/introduction).

### Escaping characters {docsify-ignore}

As you might have noticed, string values are enclosed in single quotes `''`. If the string contains characters that would result in an illegal identifier, you'll have to escape the offending characters accordingly. For example, path delimiters (backslashes) or quotes need to be escaped:

```
$ fibratus run file.name = 'C:\\Windows\\System32'
$ fibratus run file.name contains '\"hosts\"'
```

Filter expressions can accept escape sequences, such as newline characters (`\n`).

### Invalid filters {docsify-ignore}

If a syntax error is present in the filter, a hint is given indicating the erroneous position in the expression.  

```
kevt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
      and
   registry.key.name icontains
      (
        'CurrentVersion\\Run',
        'Windows\\System\\Scripts',
        'CurrentVersion\\Windows\\Load',
        'CurrentVersion\\Windows\\Run',
        'CurrentVersion\\Winlogon\\Shell',
        'CurrentVersion\\Winlogon\\System',
        'UserInitMprLogonScript'
      )
      or
   registry.key.name istartswith
      (
        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
        'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
        HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
╭──────────^
|        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
|      )
|      or
|   registry.key.name iendswith
|      (
|        'user shell folders\\startup'
|      )
|
|
╰─────────────────── expected field, string, number, bool, ip, function, pattern binding
```

```

`docs/filters/functions.md`:

```md
# Functions

Functions expand the scope of the filtering language by bringing a plethora of capabilities. The function can return a primitive value, including integers, strings, and booleans. Function calls can be nested where the result of one function is used as an input in another function. For example, `lower(ltrim(file.name, 'C:'))`, removes the `C` drive letter from the file path and converts it to a lower case string.

Additionally, some functions may return a collection of values. Function names are case insensitive.

### Network functions

#### cidr_contains

`cidr_contains` determines if the specified IP is contained within the block referenced by the given CIDR mask. The first argument represents the IP address and the subsequent   arguments are IP masks in CIDR notation.

- **Specification**
    ```
    cidr_contains(ip: <string>, cidrs: <string>...) :: <boolean>
    ```
    - `ip`: The IP address in v4/v6 notation
    - `cidrs`: The list of CIDR masks
    - `return` a boolean value indicating whether the IP pertains to the CIDR block

- **Examples**

    Assuming the `net.sip` field contains the `192.168.1.20` IP address, the following filter
    would match on this event.

    ```
    fibratus run kevt.category = 'net' and cidr_contains(net.sip, '192.168.1.1/24', '172.17.1.1/8')
    ```

### Hash functions

#### md5

`md5` computes the MD5 hash of the given value.

- **Specification**
    ```
    md5(data: <string|[]byte>) :: <string>
    ```
    - `data`: The string or the byte array for which to calculate the hash
    - `return` a string representing the md5 hash

- **Examples**

    Assuming the `registry.key.name` field contains `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`, the following would filter events for the matching md5 hash.

    ```
    fibratus run kevt.category = 'net' and md5(registry.key.name) = 'eab870b2a516206575d2ffa2b98d8af5'
    ```

### String functions

#### concat

`concat` concatenates string/integer input arguments.

- **Specification**
    ```
    concat(args: <string|int>...) :: <string>
    ```
    - `args`: Strings or integers to be concatenated. This function requires at least 2 input arguments
    - `return` a concatenated string of all input arguments

- **Examples**

    Assuming the `ps.domain` field contains `NT_AUTHORITY` and `ps.username` field contains `admin`, the following would filter events for the matching concatenated string.

    ```
    fibratus run concat(ps.domain, '-', ps.username) = 'NT_AUTHORITY-admin'
    ```

#### ltrim

`ltrim` trims the specified prefix from a string.

- **Specification**
    ```
    ltrim(string: <string>, prefix: <string>) :: <string>
    ```
    - `string`: Input string
    - `prefix`: Prefix that is removed from the original input string
    - `return` a string with the specified prefix removed

- **Examples**

    Assuming the `registry.key.name` field contains `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`, the following filter expression would match on all events where the resulting string is equal to `SYSTEM\Setup\Pid`

    ```
    fibratus run ltrim(registry.key.name, 'HKEY_LOCAL_MACHINE\\') = 'SYSTEM\\Setup\\Pid'
    ```

#### rtrim

`rtrim` trims the specified suffix from a string.

- **Specification**
    ```
    rtrim(string: <string>, suffix: <string>) :: <string>
    ```
    - `string`: Input string
    - `prefix`: Suffix that is removed from the original string
    - `return` a string with the specified suffix removed

- **Examples**

    Assuming the `registry.key.name` field contains `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`, the following filter expression would match on all events where the resulting string is equal to `HKEY_LOCAL_MACHINE\SYSTEM\Setup`

    ```
    fibratus run rtrim(registry.key.name, '\\Pid') = 'HKEY_LOCAL_MACHINE\\SYSTEM\\Setup'
    ```

#### lower

`lower` converts the string with all Unicode letters mapped to their lower case.

- **Specification**
    ```
    lower(string: <string>) :: <string>
    ```
    - `string`: Input string
    - `return` a string converted to lower case

- **Examples**

    Assuming the `registry.key.name` field contains `HKEY_LOCAL_MACHINE\SYSTEM\Setup`, the following filter expression would match on all events where the resulting string is equal to `hkey_local_machine\system\setup`

    ```
    fibratus run lower(registry.key.name) = 'hkey_local_machine\\system\\setup'
    ```

#### upper

`upper` converts the string with all Unicode letters mapped to their upper case.

- **Specification**
    ```
    upper(string: <string>) :: <string>
    ```
    - `string`: Input string
    - `return` a string converted to upper case

- **Examples**

    Assuming the `registry.key.name` field contains `HKEY_LOCAL_MACHINE\SYSTEM\Setup`, the following filter expression would match on all events where the resulting string is equal to `HKEY_LOCAL_MACHINE\SYSTEM\SETUP`

    ```
    fibratus run upper(registry.key.name) = 'HKEY_LOCAL_MACHINE\\SYSTEM\\SETUP'
    ```

#### replace

`replace` replaces all occurrences in the string as given by arbitrary old/new replacement pairs.

- **Specification**
    ```
    replace(string: <string>, old: <string>, new: <string>, ..., old-n: <string>, new-n: <string>) :: <string>
    ```
    - `string`: Input string
    - `old`: substring in the original string that is replaced with the `new` string
    - `new`: the replacement string
    - `return` a string with all occurrences replaced by old/new pairs

- **Examples**

    Assuming the `registry.key.name` field contains `HKEY_LOCAL_MACHINE\SYSTEM\Setup`, the following filter expression would match on all events where the resulting string is equal to `HKLM\SYS\Setup`

    ```
    fibratus run replace(registry.key.name, 'HKEY_LOCAL_MACHINE', 'HKLM', 'SYSTEM', 'SYS') = 'HKLM\\SYS\\Setup'
    ```

#### split

`split` produces a slice of substrings separated by the given delimiter.

- **Specification**
    ```
    split(string: <string>, sep: <string>) :: <[]string>
    ```
    - `string`: Input string
    - `prefix`: The separator that is used to split the string
    - `return` a slice of substrings

- **Examples**

    Assuming the `file.name` field contains `C:\Windows\System32\kernel32.dll`, the following filter expression would match on all events where the `kernel32.dll` or `System32` strings are present in the resulting slice.

    ```
    fibratus run split(file.name, '\\') in ('kernel32.dll', 'System32')
    ```

#### length

`length` returns the number of characters for string arguments and the size of the slice for slice arguments.

- **Specification**
    ```
    length(string: <string|slice>) :: <int>
    ```
    - `string`: Input string or slice
    - `return` the number of characters or array length

- **Examples**

    Assuming the `ps.domain` field contains `"こんにちは"`, the following would filter events with 5 symbols in the process domain.

    ```
    fibratus run length(ps.domain) = 5
    ```

#### indexof

`indexof` returns the index of the instance of substring in a given string depending on the provided search order.

- **Specification**
    ```
    indexof(string: <string>, substring: <string>, order: <string>) :: <int>
    ```
    - `string`: Input string
    - `prefix`: Substring for which the search is performed
    - `order`: Specifies the string index search order. It can be `first`, `any`, `last`, `lastany`. This is an optional argument.
    - `return` the index of the substring

- **Examples**

    Assuming the `ps.domain` field contains `NT_AUTHORITY`, the following would filter events for the matching substring index.

    ```
    fibratus run indexof(ps.domain, 'NT') = 0
    ```

#### substr

`substr` creates a substring of a given string.

- **Specification**
    ```
    substr(string: <string>, start: <int>, end: <int>) :: <string>
    ```
    - `string`: Input string
    - `start`: Substring start index
    - `end`: Substring end index
    - `return` a substring contained within start and end indices

- **Examples**

    Assuming the `file.name` field contains `\Device\HarddiskVolume2\Windows\system32\user32.dll`, the following filter expression would match on all events where the substring is equal to `\Device`

    ```
    fibratus run substr(file.name, indexof(file.name, '\\'), indexof(file.name, '\\Hard')) = '\\Device'
    ```

#### entropy

`entropy` measures the string entropy.

- **Specification**
    ```
    entropy(string: <string>, algo: <string>) :: <int>
    ```
    - `string`: Input string
    - `algo`: The algorithm used to calculate the string entropy. `shannon` is the default entropy type. This argument is optional
    - `return` the string entropy

- **Examples**

    Assuming the `file.name` field contains `\Device\HarddiskVolume2\Windows\system32\user32.dll`, the following filter expression would match on all events where file name entropy is greater than 255.

    ```
    fibratus run entropy(file.name) > 255
    ```

#### regex

`regex` applies single/multiple regular expressions on the provided string argument.

- **Specification**
    ```
    regex(string: <string>, patterns: <string>...) :: <bool>
    ```
    - `string`: Input string
    - `patterns`: Regular expression patterns
    - `return` `true` if at least one regular expression matches or `false` otherwise

- **Examples**

    Assuming the `ps.name` field contains `powershell.exe`, the following would filter events matching the regular expressions.

    ```
    fibratus run regex(ps.name, 'power.*(shell|hell).dll', '.*hell.exe')
    ```

```

`docs/filters/introduction.md`:

```md
# Needle In The Haystack

An overwhelming volume of kernel events makes it challenging to dig out valuable insights or to narrow down the scope of a particular investigation or postmortem scenario. To streamline day-to-day tasks and to propel your workflow, Fibratus delivers a powerful engine for building sophisticated filtering expressions. Let's assume you want to catch events originated from `cmd.exe`, `powershell.exe`, `winword.exe` processes, or processes that export the `WORKER=1` environment variable and whose current working directory contains the `Users\Public` path. We can write such a filter as:

```
ps.name in ('cmd.exe', 'powershell.exe', 'winword.exe')
        or ps.envs['WORKER'] = '1'
        and ps.cwd contains 'Users\\Public'
```

It may look intimidating at first glance, but once you get familiar with the syntax and the field names you'll be able to write even the most intricate filters.

Filters represent the foundation of the [rule engine](/filters/rules) that provides threat detection capabilities. For example, the following stanza detects the outbound communication followed by the execution of the command shell within one-minute time window. The action invokes the [alert sender](/alerts/senders) to emit the security alert via email or Slack. 

```yaml
- group: remote connection and command shell execution
  policy: sequence
  rules:
    - name: establish remote connection
      condition: >
        kevt.name = 'Connect'
          and
          not
        cidr_contains(
          net.dip,
          '10.0.0.0/8',
          '172.16.0.0/12')
    - name: spawn command shell
      max-span: 1m
      condition: >
        kevt.name = 'CreateProcess'
          and
        ps.pid = $1.ps.pid
          and
        ps.sibling.name in ('cmd.exe', 'powershell.exe')
  action: >
    {{ emit "Command shell spawned after remote connection"
      (printf "%s process spawned a command shell after connecting to %s" .Kevts.k2.PS.Exe .Kevts.k1.Kparams.dip)
    }}
```

```

`docs/filters/operators.md`:

```md
# Operators

The filter engine supports logical, arithmetic, and string operators. Operator names are case-insensitive.

## Binary operators

The filtering query language supports the following  comparison binary operators:

- `=` (equal)
- `!=` (not equal)
- `<` (less than)
- `>` (greater than)
- `>=` (greater or equal)
- `<=` (less or equal)

## Logical operators

Logical operators are applied on two or more binary expressions, except for `not` that acts as a unary operator.

### or

`or` (union) evalutes to true if either one of the LHS (Left Hand Side) or RHS (Right Hand Side) expressions are true. 

- **Example**

   Filter events where the originating process name is equal to `svchost.exe` or the process name contains the `svc` string

   ```
   fibratus run ps.name = 'svchost.exe' or ps.name contains ('svc')
   ```

### and

`and` (intersection) evalutes to true if both of the LHS (Left Hand Side) and RHS (Right Hand Side) expressions are true.

- **Example**

   Filter events only when the originating process name is equal to `System` and the process identifier is equal to `4`

   ```
   fibratus run ps.name = 'System' and ps.pid = 4
   ```

### not

`not` (negation) negates the result of the adjacent expression.

- **Example**

   Filter events only when the originating process name is equal to `svchost.exe` and none of the process' command line arguments is equal to `/-C` or `/cdir`

   ```
   fibratus run ps.name = 'svchost.exe' and ps.args not in ('/-C', '/cdir') 
   ```

## String operators

String operators are applied to string field types or string literals.

### in, iin

`in` operator validates the presence of a value in the string sequence. It can be applied to string literal sequences or dynamic string slices given by filter fields. `iin` is the case-insensitive variant of the `in` operator.

- **Examples**

   Tests if the process name producing the event is either `cmd.exe` or `powershell.exe`

   ```
   $ fibratus run ps.name in ('cmd.exe', 'powershell.exe')
   ```

   Checks if any of the process modules contains the `kernel32` dynamic linked object

   ```
   $ fibratus run ps.modules in ('kernel32.dll')
   ```

### contains, icontains

`contains` operator checks whether a string field contains a sequence of characters. This operator works on both simple string values and lists of strings. `icontains` is the case-insensitive variant of the `contains` operator.

- **Examples**

   Checks if the process' name contains the `cmd` or `power` substrings

   ```
   $ fibratus run ps.name contains ('cmd', 'power')
   ```

   Checks if the process' command line contains the `Windows Tasks` substring

   ```
   $ fibratus run ps.comm contains 'Windows Tasks'
   ```


### startswith, istartswith

`startswith` checks whether a string field starts with a specified prefix. This operator works on both simple string values and lists of strings. `istartswith` is the case-insensitive variant of the `startswith` operator.

- **Example**

   Filter events where the originating process name is equal to `svchost.exe`

   ```
   fibratus run ps.name startswith 'svchost'
   ```


### endswith, iendswith

`endswith` checks whether a string field ends with a specified suffix. This operator works on both simple string values and lists of strings. `iendswith` is the case-insensitive variant of the `endswith` operator.

- **Example**

   Filter events where the originating process name is equal to `svchost.exe`

   ```
   fibratus run ps.name endswith '.exe'

### matches, imatches

`matches` is the swiss army knife string matching operator. It allows string matching by using the wildcard characters similar to [globbing](https://en.wikipedia.org/wiki/Glob_(programming)). The `*` wildcard matches a sequence of characters, while the `?` wildcard matches a single character. `imatches` is the case-insensitive variant of the `matches` operator.

- **Examples**

   To match events with file paths equal to `C:\\Windows\\System32\\lsass2.dmp` or `C:\\ProgramData\\Directory\\tmp\\anubis.dll`

   ```
   fibratus run file.name matches ('C:\\*\\lsass?.dmp', 'C:\\ProgramData\\*.dll')
   ```

   For filtering registry events with key names such as `HKEY_USERS\\S-1-5-21-2271034452-2606270099-984871569-1001\\Environment\\windir`

   ```
   fibratus run registry.key.name matches 'HKEY_USERS\\*\\Environment\\windir'
   ```

### fuzzy, ifuzzy, fuzzynorm, ifuzzynorm

`fuzzy` operators allow for flexibly matching a string with partial input based on [fuzzy matching](https://en.wikipedia.org/wiki/Fuzzy_matching_(computer-assisted_translation)) techniques. `fuzzynorm` applies Unicode normalization before running the matching phase. `ifuzzy` and `ifuzzynorm` are the case-insensitive variants of the respective fuzzy operators.

- **Examples**

   To match events with file paths that contain `C:\\Windows\\System32\\user32.dll`, you could create an expression with the  partial path input

   ```
   fibratus run file.name fuzzy 'C:\\Windows\\Sys\\ser3ll'
   ```

   `fuzzynorm` operates on normalized Unicode codepoints

   ```
   fibratus run file.name fuzzynorm 'C:\\Windows\\Sys\\sér3ll'
   ```
```

`docs/filters/paths.md`:

```md
# Paths

As you may have already noticed, different entities can appear in filter fields. For example, `ps` is the root entity that designates the source of process-related values. To access the value from the entity, the __path__ expression is used as a sequence of period-delimited segments that yield the final value. Thus, the `ps.name` field path gives the process name. Paths can be nested, like `ps.parent.handles`, to collect all handle names of the parent process.

Paths can also be constructed in combination with array or map indexing.

### Process ancestry {docsify-ignore}

Walking the process tree is a useful feature when you want to capture events produced by the process that is a descendant of particular processes. For this purpose, various path segments with map indexing are available.

#### Depth indexing

Fetches the ancestor that is located at a specified depth starting from the current process. `ps.ancestor[1]` yields the immediate parent process and it is equivalent to using the `ps.parent` field. Imagine the following process tree:

```
├───wininit.exe
│   └───services.exe
│       └───svchost.exe
│           └───dllhost.exe
│               ├───cmd.exe
│               └───winword.exe
```

Assuming the `winword.exe` is the current process generating the event, we could write the following filter expression to check its ancestors:

```
$ fibratus run ps.ancestor[1].name = 'dllhost.exe' or ps.ancestor[3].name = 'services.exe'
```

#### Root indexing

To filter events where their ancestor process is the root of the process tree, you can employ the `root` key. Considering the same process tree as above, we can construct the following filter:

```
$ fibratus run ps.ancestor[root].name = 'wininit.exe'
```

#### Any indexing

If you want to match on multiple ancestors, use the `any` key. The following expression would filter all events where the process generating them has `svchost.exe` or `dllhost.exe` ancestors:

```
$ fibratus run ps.ancestor[any].name in ('svchost.exe', 'dllhost.exe')
```

Besides the process name, several other path segments are available for returning the ancestor data:

- `.pid` returns the process identifier
- `.args` gives process command line arguments as a list of strings
- `.comm` returns the process command line argument as a raw string
- `.cwd` fetches the process current working directory
- `.exe` returns the process image path
- `.sid` returns the process user/domain name
- `.sessionid` returns the process session identifier

!> `any` returns a list of values specified by the path segment, and thus requires operators that evaluate on lists instead of simple primitive values.

### Portable Executable {docsify-ignore}

[Portable Executable](/pe/introduction) introspection allows for utilizing the PE metadata in filters. See other [fields](filters/fields?id=pe) that can be used to narrow down events by PE data.

#### Section indexing

You can use the section name as an index to retrieve the data used for filter matching. For example, `ps.pe.sections[.debug$].size` would fetch the size of the `.debug$` section.

Available path segments:

- `.entropy` returns the section entropy
- `.md5` returns the section MD5 hash value

#### Resource indexing

PE [resources](/pe/resources) are accessed by the resource name. For example, the following filter would match all events where process PE resources contain the `github` company.

```
$ fibratus run pe.resources[CompanyName] contains 'github'
```

### Modules {docsify-ignore}

Process modules can be accessed by the module name. The file extension is omitted from the module name. For example:

```
$ fibratus run ps.modules['crypt'].size > 1024
```

Other paths segments you can use in modules indexing:

- `.base.address` returns the	base address of the process in which the module is loaded
- `.checksum`	returns the checksum of the module file
- `.size` gives the module size
- `.default.address` returns the default image address

### Environment variables {docsify-ignore}

You can access process environment variables by providing the name of the environment variable. Alternatively, you can provide the prefix.

```
$ fibratus run ps.envs['MOZ_CRASHREPORTER'] = 'C:\\Program Files\\Firefox'
```

Or, supplying the prefix

```
$ fibratus run ps.envs['MOZ_CRASH'] = 'C:\\Program Files\\Firefox'
```
```

`docs/filters/prefiltering.md`:

```md
# Prefiltering

Sometimes it is useful to drop certain events either by image (process) name or event type once the event is peeked from the tracing buffer. Besides this, the kernel stream consumer can be configured to ignore events at the `ETW` session level. This can drastically reduce the load if you're not interested in particular events that are producing an immense volume of data.

The above is the summary of configuration options that influence the collection of kernel events by the `Kernel Logger`. These options are placed in the `kstream` section of the configuration file.

- `enable-thread` enables/disables the collection of the thread-related kernel events
- `enable-registry` enables/disables the collection of registry kernel events
- `enable-net` enables/disables the collection of network kernel events
- `enable-fileio` enables/disables the collection of the file system events
- `enable-image` enables/disables the collection of image loading/unloading events
- `enable-handle` enables/disables the collection of handle events

### Blacklisting {docsify-ignore}

If you want to permanently exclude specific kernel events or processes that produce them from the event flow, you can achieve this by defining the blacklist in the `kstream.blacklist` configuration section:

- `events` contains a list of kernel event names that are dropped from the event stream.
- `images` contains a list of case-sensitive process image names including the extension. Any event originated by the image specified in this list is dropped from the event stream.

```

`docs/filters/rules.md`:

```md
# Rules

CLI filters offer a decent amount of flexibility when digging into the event flux, but they fall short to express complex filtering decisions which are paramount to runtime threat detection. This is where rules come to the rescue. Rules are a collection of grouped filters defined in `yaml` files. Specifically, the following attributes describe a group:

- **name** associates a meaningful name to the group such as `Suspicious network-connecting binaries`
- **selector** indicates the event type or event category that a certain filter group can capture. For example,`CreateProcess` or `registry`. The selector is only relevant for `include` and `exclude` policies.
- **enabled** specifies whether the group is active
- **policy** determines the action that's taken on behalf of the incoming event. There are different types of policies: `include`,  `exclude`, and `sequence.`. Include policy filters the event if one of the filters in the group matches, even though this behavior can be tweaked by setting the `relation` attribute. On the other hand, the exclude policy drops the event when a match occurs in the group.
Sequence policy deserves a [dedicated section](/filters/rules?id=stateful-event-tracking). In a nutshell, sequence policy permit stateful event tracking which is the foundation of detections that can assert an ordered sequence of events sharing certain properties.
- **relation** controls the group matching criteria. Possible values for the group relation are `and` and `or`. When the `and` relation type is specified, all filters in the group have to match for the event to get accepted. Conversely, the `or` relation type requires only one filter in the group to evaluate to true for accepting the event. Relation is only relevant for `include` and `exclude` policies.
- **rules** contains an array of rule expressions. Each expression is composed of a descriptive rule name, condition, and an optional action that is executed when the rule is triggered.

### Loading rules {docsify-ignore}

By default, rules reside inside `%PROGRAM FILES%\Fibratus\Config\Rules` directory. You can load any number of rule files from file system paths or URL locations.

Edit the main [configuration](/setup/configuration?id=files) file. Go to the `filters` section where the following `yaml` fragment is located:

```yaml
filters:
  rules:
    from-paths:
      - C:\Program Files\Fibratus\Config\Rules\Default\default.yml
    from-urls:
      - https://raw.githubusercontent.com/rabbitstack/fibratus/master/configs/rules/default/default.yml
```

- `from-paths` represents an array of file system paths pointing to the rule definition files
- `from-urls` is an array of URL resources that serve the rule definitions

### Defining rules {docsify-ignore}

As we mentioned previously, rules are bound to groups. Each group targets a specific event type or event category unless a sequence policy is used. Let's have a glimpse at an example of a group with two rules.

```yaml
- group: Suspicious file creation operations                               
  selector:
    type: CreateFile
  enabled: true
  policy: include
  relation: or
  rules:
    - name: Startup links and shortcut modifications
      condition: > 
           file.operation = 'create'
              and
           file.name icontains
           (
              '\\Start Menu',
              '\\Startup\\'
           )
    - name: Microsoft Outlook attachments
      condition: file.operation = 'create' and file.name icontains '\\Content.Outlook\\'
   tags:
    - persistence
    - lateral movement
```

1. The group needs a mandatory name. You can define as many groups as you like, even if they target the same event type or category. Later on, during the loading stage, they are merged into a single group. Sequence groups are evaluated independently.

2. Every group with include or exclude policy has a selector. The selector dictates which events are captured by the group. In our example, only `CreateFile` events would get routed to this group. An alternative option for `type` is the `category` attribute that can have one of the values described in the [category](kevents/anatomy?id=canonical-fields) canonical field. Setting the `category: file` attribute would result in all file events being captured by the group.

3. Sometimes it comes in handy to temporarily disable a specific group. This is the purpose of the `enabled` attribute. It can be omitted and by default it is equal to `true`.

4. Group policy specifies whether the event that matched a rule is propagated to upstream [output](/outputs/introduction) or is rejected. This behaviour is accomplished with `include` and `exclude` policies respectively. Exclude policies take precedence over include policies. Simply put, if we had another group with the `exclude` policy targeting the `CreateFile` event type or the `file` category, any match occurring in the exclude group would drop the event. If not specified, the group policy is equal to `include`. Finally, if none of include/exclude policy groups is fired, the sequence group policies are evaluated.

5. If we need all the rules in a group to produce a match in order to accept the event, we can tune up the `relation` attribute. By default, the `or` relation allows for the group match to get promoted if a single rule in a group is evaluated to be true. On the contrary, the `and` relation type would instruct the rule engine to pass the event only if all rules are matched.

6. The collection of rules is specified in the `rules` attribute. You may notice the `condition` element contains the well-known filter expression we used to employ in the CLI filters.

7. You can attach an arbitrary number of `tags` to each group.

#### Externalizing values

To avoid bloating rule files with long file paths, command-line signatures, registry keys, or other resources, it is possible to store them separately in so-called `values` files. [Here](https://github.com/rabbitstack/fibratus/blob/master/configs/rules/default/values.yml) is an example of such a file. Just make sure to place the `values.yml` file within the same directory where rule files are located.

To fetch any value from the `values.yml` file, use the Go [template](https://pkg.go.dev/text/template) syntax with the `.Values` field accessor. Assuming you have defined the following `values.yml` file. 

```yaml
processes:
  comm:
    svchost:
      - C:\\Windows\\system32\\svchost.exe -k appmodel -s StateRepository
      - C:\\Windows\\system32\\svchost.exe -k dcomlaunch -s LSM
      - C:\\Windows\\system32\\svchost.exe -k defragsvc
```

To to get a comma-separated list of string values enclosed inside parentheses, you would use the following snippet in the rule definition:

```yaml
- name: svchost
  condition: ps.comm iin {{ .Values.processes.comm.svchost | stringify }}
```

Note we start the field path with the `.Values` prefix and next specify the rest of the segments as declared in the `yml` file. The result is fed to the `stringify` function that simply quotes  each element in the array and encloses it inside parentheses.

This filter would get expanded to the following block.

```yaml
- name: svchost
  condition: > 
    ps.comm iin 
      (
        'C:\\Windows\\system32\\svchost.exe -k appmodel -s StateRepository', 
        'C:\\Windows\\system32\\svchost.exe -k dcomlaunch -s LSM', 
        'C:\\Windows\\system32\\svchost.exe -k defragsvc'
      )
```


#### Templating {docsify-ignore}

One of the compelling features of the rule files is the ability to use the Go [templating](https://pkg.go.dev/text/template) engine for assisting in filter expression building. This encompass loops, pipelines, functions, and many other facilities. Additionaly, Fibratus includes a set of [predefined](http://masterminds.github.io/sprig/) functions ranging from string to cryptographic and math functions.

#### Actions {docsify-ignore}

Apart from letting the event continue its journey when the rule matches, it is also possible to attach an `action` to execute when the rule is triggered. Currently, the following actuators are available in rule actions:

- `emit` sends an alert via alert [senders](/alerts/senders). The `emit` actuator requires a title and text, and optionally, you can specify the severity level and a list of tags.
- `kill` terminates a process with the specified pid.

Let's see the following example:

```yaml
- group: Suspicious remote thread creations
  selector:
    type: CreateThread
  rules:
    - name: Fishy remote threads
      condition: kevt.pid != thread.pid
      action: >
        {{ emit
            (printf "Detected remote thread creation in %s" .Kevt.Kparams.exe)
            (printf "Possible code injection by %s" .Kevt.PS.Exe)
        }}
```

Each time we detect a thread creation event happening in a remote process the `action` block is executed. When in the action scope, the template has access to various fields:

- `.Kevt` accesses the underlying kernel event. Refer to this [link](https://github.com/rabbitstack/fibratus/blob/83cd37820b208846809f82b19e857bff6f4eb415/pkg/kevent/kevent.go#L55) to inspect all possible subfields. For sequence group policies, a list of all matched events is given instead. Thus, accessing a matching event for the specific group is accomplished with the `.Kevts.k{rule-number}` expression. For example, to access the process name of the event in the first rule you would use an expression like `.Kevts.k1.PS.Name`.
- `.Filter` provides access to filter attributes. The following subfields are available:
    - `.Filter.Name` gets the filter/rule name
    - `.Filter.Def` gets the filter expression
- `.Group` provides access to group attributes. The following subfields are available:
    - `.Group.Name` gets the group name
    - `.Group.Selector` returns the selector
    - `.Group.Policy` returns the group policy
    - `.Group.Relation` returns the group relation
    - `.Group.Tags` fetches group tags

We have used the `cat` function to concatenate string literals with fields. Finally, we call into the `emit` actuator passing the title and text arguments.

#### Event rule metadata {docsify-ignore}

For include groups matches, the rule and group name are pushed into the event metadata stitching the rule with the event that triggered it. `rule.name` and `rule.group` tags identify the rule and the group name respectively. For example, you can configure the console output [template](outputs/console?id=templates) to print the metadata of the event. Similarly, other outputs will produce the corresponding JSON dictionary with the rule tags.

### Stateful event tracking {docsify-ignore}

Sequence policies piggyback on stateful event tracking. These policies are the most flexible and powerful for implementing runtime detections. Let's peer into the structure of the sequence group policy.

```yaml
- group: remote connection and command shell execution
  policy: sequence
  rules:
    - name: establish remote connection
      condition: >
        kevt.name = 'Connect'
          and
          not
        cidr_contains(
          net.dip,
          '10.0.0.0/8',
          '172.16.0.0/12')
    - name: spawn command shell
      max-span: 1m
      condition: >
        kevt.name = 'CreateProcess'
          and
        ps.pid = $1.ps.pid
          and
        ps.sibling.name in ('cmd.exe', 'powershell.exe')
  action: >
    {{ emit "Command shell spawned after remote connection"
      (printf "%s process spawned a command shell after connecting to %s" .Kevts.k2.PS.Exe .Kevts.k1.Kparams.dip)
    }}
```

1. As with regular group policies, the name is also mandatory in the sequence policies.
2. Since sequence groups track an ordered sequence of events of any type, the selector is not applicable to these groups.
3. Every sequence group requires at least two rule definitions. The rules can refer to partial events matched by upstream rules. This is achieved with **pattern bindings**. The syntax for a pattern binding is expressed with the `$` symbol followed by the scalar number that refers to the position where the rule is declared in the `rules` array. The rest of the path is a well-known filter field identifier. For example, in the above rule group, we require that the process spawning the command shell is equal to the process that established a network connection.
4. Sometimes we want to scope the occurrence of a specific event within a time frame. This is the purpose of the `max-span` attribute. Following the previous example, the group matches if the command shell execution happens within the one-minute time window. Otherwise, all partial matches are discarded and the evaluation phase starts over again.
5. Unlike `include` group policies, `sequence` policy has group-level actions. The action is executed when all rules in the group match. The action context contains a list of events that triggered each individual rule in the group.

```

`docs/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fibratus</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Fibratus is a tool for exploration and tracing of the Windows kernel. It lets you trap system-wide events such as process life-cycle, file system I/O, registry modifications or network requests among many other observability signals">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://indestructibletype.com/fonts/Jost.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="themes/fibratus.css">
  <link rel="stylesheet" href="https://unpkg.com/docsify-toc@1.0.0/dist/toc.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link media="all" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dmhendricks/bootstrap-grid-css@4.1.3/dist/css/bootstrap-grid.min.css" />
</head>
<body>
  <div id="app"></div>
  <script>
    window.$docsify = {
      onlyCover: true,
      auto2top: true,
      themeColor: "#6da9e2",
      coverpage: true,
      loadNavbar: 'nav.md',
      loadSidebar: true,
      subMaxLevel: 3,
      maxLevel: 4,
      homepage: 'home.md',
      executeScript: true,
      search: {
        maxAge: 86400000, // Expiration time, the default one day
        paths: 'auto',
        placeholder: 'Search',
        noData: 'No Results!',
        // Headline depth, 1 - 6
        depth: 6,
        hideOtherSidebarContent: false // whether or not to hide other sidebar content
      },
      pagination: {
        crossChapter: true,
        crossChapterText: true,
        headings: 'h1, h2, h3, h4, h5, h6'
      },
      toc: {
        scope: '.markdown-section',
        headings: 'h1, h2, h3, h4, h5, h6',
        title: 'CONTENTS',
      }
    }
  </script>
  <script src="//unpkg.com/docsify/lib/docsify.min.js"></script>
  <script src="//unpkg.com/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js"></script>
  <script src="//unpkg.com/docsify-pagination/dist/docsify-pagination.min.js"></script>
  <script src="//unpkg.com/docsify-toc@1.0.0/dist/toc.js"></script>
  <script src="//unpkg.com/ionicons@5.0.0/dist/ionicons.js"></script>
  <script src="//unpkg.com/docsify/lib/plugins/search.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs/components/prism-yaml.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"></script>
</body>
</html>

```

`docs/kevents/anatomy.md`:

```md
# Anatomy Of An Event

The **Event** or `kevent` as referred to in Fibratus internal lingo is the fundamental building block that encapsulates the state of the inbound kernel event. The [ETW](https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal) **Kernel Logger** provider produces the flow of kernel events in their raw format. This means that the vast majority of the event's parameters lack a meaningful context needed for an intuitive human interpretation. To clarify the previous statement, here are some concrete examples:

- registry keys containing partial paths are typically not very useful. Think of `Settings/Control Panel` key that actually represents the fully qualified `HKEY_CURRENT_USER/Settings/Control Panel` path. Fibratus makes sure to run a hook in the early stage of the kernel event stream to figure out the remaining key name. Aside from this, root keys are represented in the native object manager format, e.g. `REGISTRY\MACHINE` is the key name for the `HKEY_CURRENT_MACHINE` root level key. Fibratus normalizes native root keys to well-known names.
- missing file names in `ReadFile` or `WriteFile` events. These events only contain the address of the file object that obviously doesn't give any hints about the file involved in the I/O operation. Fibratus strives for a best-effort file name resolution. Similarly to native registry key names, the Kernel Logger emits files names in DOS device name format, e.g. `Device\HardDisk4\Windows\System32\kernel32.dll`. Fibratus maps DOS device names to drive letters.
- handle type names are given as integer values. Fibratus takes care of mapping type identifiers to human-readable handle type names such as `File`, `Mutant` or `Key`.

However, this is not the only heavy-lifting task Fibratus does to produce high-quality events. Additionally, events are enriched with various parameters that are not originally present in the ETW payloads.

### Canonical fields

Each kernel event contains a series of canonical fields that describe the nature of the event such as its name, the process identifier that generated the event and such. The following is the list of all canonical fields.

- **Sequence** is a monotonically increasing integer value that uniquely identifies an event. The sequence value is guaranteed to increment monotonically as long as the machine is not rebooted. After the restart, the sequence is restored to the zero value.
- **PID** represents the process identifier that triggered the kernel event.
- **TID** is the thread identifier connected to the kernel event.
- **CPU** designates the logical CPU core on which the event was originated.
- **Name** is the human-readable event name such as `CreateProcess` or `RegOpenKey`.
- **Timestamp** denotes the timestamp expressed in nanosecond precision as the instant the event occurred.
- **Category** designates the category to which the event pertains, e.g. `file` or `thread`. Each particular category is explained thoroughly in the next
 sections. Possible category types are: `registry`, `file`, `net`, `process`, `thread`, `image` and `handle`.
- **Description** is a short explanation about the purpose of the event. For example, `CreateFile` kernel event creates or opens a file, directory, I/O device, pipe, console buffer or other block/pseudo device.
- **Host** represents the host name where the event was produced.

### Parameters

Also called as `kparams` in Fibratus parlance, contain each of the event's parameters. Internally, they are modeled as a collection of key/value pairs where the key is mapped to the structure consisting of parameter name, parameter type and the value. An example of the parameter tuple could be the `dip` parameter
that denotes a destination IP address with value `172.17.0.2` and therefore `IPv4` type. Additionally, parameter types can be scalar values, strings, slices, enumerations, and timestamps among others.

### Process state

Each event stores the process state that represents an extended information about the process including its allocated resources such as handles, dynamically-linked libraries, exported environment variables and other attributes. The process state internals are thoroughly explained in the [Process](/kevents/process) events section.

### Metadata

Metadata are an arbitrary sequence of tags in form of key/value pairs that you can squash into the event on behalf of [transformers](/transformers/introduction). A tag can be virtually any string data that you find meaningful to either identify the event or apply filtering/grouping once event is persisted in the data store.

```

`docs/kevents/file.md`:

```md
# File events

File events encompass a variety of file system related activities such as creating or opening directories/files/devices, writing or reading data, altering file metadata and so on.

#### CreateFile

The `CreateFile` event is triggered when the kernel serves create/open requests for files or I/O devices. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. `CreateFile` events have the following parameters:

- `file_object` is the file object pointer as seen from the kernel perspective. You can use this parameter to correlate file events.
- `file_name` represents the file/directory or device name (e.g. `C:\ProgramData\AVG\Antivirus\psi.db-journal`)
- `irp` is the I/O request packet value that identifies the file system activity.
- `operation` identifies the file system operation performed on the file or device:
  - `supersede` replaces the file if it already exists, otherwise creates a new file
  - `open` opens the file if it exists
  - `create` creates a new file or fails if the file already exists
  - `openif` opens the file if it already exists, otherwise creates a new file
  - `overwrite` opens and overwrites the file if it already exists
  - `overwriteif` opens and overwrites the file if it already exists, otherwise creates a new file
- `share_mask` specifies the sharing mode of the file or device, which can be read, write, both, delete, all of these, or none. This flag determines the permission granularity which enables a process to share a file or device while another process has the file or device open.
- `type` defines the file type. Possible values are `file`, `directory`, `pipe`, `console`, `mailslot`, `other`, `unknown`.
- `attributes` denotes the file attributes. Possible values are `readonly`, `hidden`, `system`, `directory`, `compressed`, `encrypted`, `hidden`, `junction`, `sparse`,`temporary`, `device`, `normal`, `offline`, `unindexed`, `stream`, `virtual`, `noscrub`, `recallopen`, `recallaccess`, `pinned`, `unpinned`, `unknown`.
- `status` represents the system status message (e.g. `success`)

#### WriteFile and ReadFile

These events occur when a process writes data to a file or reads data from the file or I/O device. They contain the following parameters:

- `file_object` is the file object pointer as seen from the kernel perspective. You can use this parameter to correlate file events.
- `file_name` represents the file/directory or device name the data is written to or read from.
- `irp` is the I/O request packet value that identifies the file system activity.
- `io_size` specifies the number of bytes read or written.
- `offset` determines the offset in the file where the data is read or written.
- `type` defines the file type. Possible values are  `file`, `directory`, `pipe`, `console`, `mailslot`, `other`, `unknown`.


#### DeleteFile

Removes the file from the file system. This event contains the following parameters:

- `file_object` is the file object pointer as seen from the kernel perspective. You can use this parameter to correlate file events.
- `file_name` represents the file/directory that was removed
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are  `file`, `directory`, `pipe`, `mailslot`, `other`, `unknown`.

#### RenameFile

Renames the file or directory in the file system.

- `file_object` is the file object pointer as seen from the kernel perspective.
- `file_name` represents the file/directory that was renamed.
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are  `file`, `directory`, `other`, `unknown`.

#### CloseFile

Closes the handle to opened file. This event is excluded by default.

- `file_object` is the file object pointer as seen from the kernel perspective.
- `file_name` represents the file/directory that was closed.
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are  `file`, `directory`, `pipe`, `console`, `mailslot`, `other`, `unknown`.


#### SetFileInformation

Sets the file information for the file according to the file information class.

- `class` identifies the file information class. For example, the `Basic` information class means the process altered file timestamps or basic attributes. Refer to [this](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_file_information_class) link for a full list of the file information class enumerations.
- `file_object` is the file object pointer as seen from the kernel perspective.
- `file_name` represents the file whose information class was set.
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are `file`, `pipe`, `mailslot`, `other`, `unknown`.


#### EnumDirectory

The `EnumDirectory` event is triggered in response to directory enumeration requests.

- `dir` specifies the directory that was requested for enumeration.
- `file_name` is the pattern for directory enumeration.
- `class` identifies the requested directory enumeration class.
- `file_object` is the file object pointer as seen from the kernel perspective.
- `irp` is the I/O request packet value that identifies the file system activity.

```

`docs/kevents/handle.md`:

```md
# Handle events

The object manager produces handle events to provision or dispose Windows resources allocated to processes. Resources can be threads, registry keys, files, synchronization primitives and so on.

!> Handle events can be quite voluminous and they are disabled by default. To enable the collection of handle kernel events either run Fibratus with the `--kstream.enable-handle=true` flag or activate them permanently by editing the config file.

#### CreateHandle

Provisions a new handle in the address space of the calling process. The following parameters are associated with the `CreateHandle` event:

- `handle_id` represents the unique identifier of the handle.
- `handle_object` represents the address of the kernel object to which the handle is associated
- `handle_name` denotes the handle name. (e.g. `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`)
- `handle_type` designates the type of the handle. (e.g. `ALPC Port`, `File`, `Key`)

#### CloseHandle

The `CloseHandle` event is triggered when the handle is released by the process. It contains the same set of parameters found in the `CreateHandle` event.

### Handle state {docsify-ignore}

During bootstrap, Fibratus builds a snapshot of currently allocated handles. Similarly, when a new process is created Fibratus fetches its handles and attaches them to the process state. However, you can prevent the initial handle snapshotting by running Fibratus with the `--handle.init-snapshot=false` or changing the corresponding key in the configuration file.

The handle state contains:

- handle name
- handle type
- the address of the kernel object
- handle identifier
- additional metadata such as `ALPC` port information or mutant count

```

`docs/kevents/image.md`:

```md
# Image events

Image events occur when a process loads/unloads a dynamic linked library or executable into or out of its own address space or the address space of another process. These events are represented by `LoadImage` and `UnloadImage` types respectively. The following list describes all available parameters present in DLL events.

- `file_name` denotes the full path name of the image file. (e.g. `C:\Windows\system32\kernel32.dll`)
- `image_size` represents the image size in bytes.
- `checksum` represents the image checksum digest.
- `base_address` is the base address of the process in which the image is loaded/unloaded.
- `default_address` represents the image's base address.
- `pid` that specifies the process identifier where the image was loaded/unloaded.

```

`docs/kevents/network.md`:

```md
# Network events

Interprocess communication via TCP/UDP sockets produces all sorts of network events including, sending and receiving data, retransmitting TCP segments or connecting to sockets.

#### Connect

Establishes a connection to the stream-oriented socket. `Connect` events have the following parameters:

- `dip` represents the destination IPv4/IPv6 address of the communication endpoint.
- `sip` represents the source IPv4/IPv6 address of the local process.
- `dport` identifies the destination port.
- `sport` identifies the source port.
- `l4_proto` denotes the type of the Layer 4 protocol. Possible values are `tcp`, `udp`.
- `dport_name` represents the destination port name per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service mappings.
- `sport_name` represents the source port name per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service mappings.

The remaining network events share the same parameters as the `Connect` event.

#### Accept

Accepts the connection request from the socket queue.

#### Send

Sends data over the wire. The kernel generates `Send` events when a process transports data to local or remote endpoint.

#### Recv

Receives data from the socket. The kernel produces `Recv` events a process is ready to consume data sent by local or remote socket.

#### Disconnect

Terminates data reception on the socket.


#### Reconnect

Reconnects to the socket.

#### Retransmit

Retransmits unacknowledged TCP segments. The kernel networking stack generates retransmissions when packets are dropped due to network congestion, packets arriving out of order and other reasons. 

### DNS reverse lookups

Fibratus can perform reverse DNS lookups on IP addresses and return a list of domain names that correspond to a particular IP address. Domain names are represented as slice event parameters:

- `dip_names` contains the destination IP address domain names (e.g.`47.224.186.35.bc.googleusercontent.com.`)
- `sip_names` contains the source IP address domain names (e.g. `a-0001.a-msedge.net.`)

You can use domain names in [filters](filters/introduction) in conjunction with the `matches`, `contains` or `in` operators. For example, the following filter would match all events that have at least one domain ending with `.domain.`

```
net.sip.names matches ('*.domain.')
```
```

`docs/kevents/process.md`:

```md
# Process events

#### CreateProcess and TerminateProcess

Process events are fired up as a stimulus to the process' life-cycle changes. When the kernel puts into motion a process or terminates it, the `CreateProcess` and `TerminateProcess` events are emitted respectively. The following list summarizes all the distinct event parameters that are associated with process events.

- `pid` is the process' identifier. This value is valid from the time a process is created until it is terminated.
- `tid` is the thread identifier inside process address space that generated the event.
- `ppid` represents the parent identifier of the child process. Process identifier numbers are reused, so they only identify a process for the lifetime of that process. It is possible that the process identified by `ppid` is terminated, so `ppid` may not refer to a running process. It is also possible that `ppid` incorrectly refers to a process that reuses a process identifier.
- `name` is the process' image name including file extension (e.g. `cmd.exe`).
- `comm` is the full process' command line (e.g. `C:\Windows\system32\cmd.exe /cdir /-C /W`).
- `exe` is the full name of the process' executable (e.g. `C:\Windows\system32\cmd.exe`)
- `sid` is the security identifier under which this process is run.
- `kproc` represents the address of the process object in the kernel.
- `directory_table_base` represents the address of the directory table that holds process' memory page mappings.
- `session_id` is the unique identifier for the current session under which process was started or terminated.
- `status` is the exit status of the stopped process.
- `start_time` designates the instant when the process was started.

#### OpenProcess

`OpenProcess` event is triggered when a process tries to acquire an existing local process object. This event contains the following parameters:

- `desired_access` is the hexadecimal value that represents the desired access to the process object.
- `desired_access_names` is the list of human-readable desired access strings (e.g. `TERMINATE,QUERY_INFORMATION`). For a full list and detailed explanation of available access rights, head to the official [docs](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights).
- `name` is the name of the local process that was opened.
- `exe` is the full path of the local process object that was open.
- `pid` is the identifier of the local process that was opened.
- `status` contains the result of the process object open operation. (e.g. `success`)

### Process state  {docsify-ignore}

Fibratus keeps a snapshot of all running processes including their state such as basic process attributes, allocated file handles, dynamically-linked libraries, PE (Portable Executable) metadata and other resources. The snapshot is updated dynamically as processes get spawn or die. Each time a kernel event is triggered, its process' state is fetched from the snapshot and attached to the event. This state machine semantically enriches each individual event with the aim on providing a powerful context for [filtering](/filters/introduction.md) and [scripting](/filaments/introduction.md).

Process state comprises the following attributes and resources:

- process name
- process identifier as well as its parent process identifier
- process command line
- current working directory
- process SID
- session identifier
- environment variables
- threads
- modules
- handles
- PE metadata

```

`docs/kevents/registry.md`:

```md
# Registry events

Registry events are triggered when processes access or modify the registry structure.

#### RegCreateKey

Creates a new registry key or opens the key if it already exists. This event has the following parameters:

- `key_handle` represents the handle to the registry key. In reality, this value represents the address of the KCB (Key Control Block) structure in kernel space.
- `key_name` is the name of the registry key including the root key. (e.g. `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control`)
- `status` contains the result of the registry operation (e.g. `key not found`)

#### RegDeleteKey

Deletes a subkey and all its values. This event has the same group of parameters as the `RegCreateKey` event.

#### RegOpenKey

Opens a registry key. This event has the same group of parameters as the `RegCreateKey` event.

#### RegQueryKey

Enumerates the subkeys of the specified key. The first subkey is referenced by index number 0, the second key by 1, and so on.

- `key_handle` represents the handle to the registry key.
- `key_name` is the name of the registry key whose subkeys are enumerated.
- `status` contains the result of the registry operation (e.g. `key not found`)

#### RegQueryValue

Fetches the data associated with the value of a registry key. This event has the same group of parameters as the `RegCreateKey` event, except that the base name of the registry key path is the value name.

#### RegSetValue

Sets the data associated with the value of a registry key. This event contains the following parameters:

- `key_handle` represents the handle to the registry key.
- `key_name` represents the fully qualified name of the registry value whose data is modified
- `status` contains the result of the registry operation (e.g. `success`)
- `value` contains the payload of the value being set
- `type` represents the registry value type. Possible value are: `REG_DWORD`, `REG_QWORD`, `REG_SZ`, `REG_EXPAND_SZ`, `REG_MULTI_SZ`, `REG_BINARY`, `UNKNOWN`.

#### RegDeleteValue

Deletes the registry value. This event has the same parameters as the `RegCreateKey` event.

```

`docs/kevents/thread.md`:

```md
# Thread events

#### CreateThread and TerminateThread

Thread events notify the creation (`CreateThread`) or termination (`TerminateThread`) of threads within the process' address space. In situations where a process spawns a remote thread that runs in other process' address space, the `CreateThread` event is also triggered.
Thread events are comprised of the following parameters:

- `pid` identifies the process where the thread was created. If this value is not equal to the `pid` of the process generating the event, then the thread is created in remote process.
- `tid` represents the identifier of the freshly spawn thread.
- `base_prio` is the scheduler priority of the thread.
- `page_prio` is a memory page priority hint for memory pages accessed by the thread.
- `io_prio` represents an I/O priority hint for scheduling I/O operations generated by the thread.
- `ustack_base` is the base address of the thread's user space stack.
- `ustack_limit` is the limit of the thread's user space stack.
- `kstack_base` is the base address of the thread's kernel space stack.
- `kstack_limit` is the limit of the thread's kernel space stack.
- `entrypoint` is the starting address of the function to be executed by the thread.

#### OpenThread

`OpenProcess` event is triggered when a process opens an existing local thread object. This event contains the following parameters:

- `desired_access` is the hexadecimal value that represents the desired access to the thread object.
- `desired_access_names` is the list of human-readable desired access strings (e.g. `QUERY_LIMITED_INFORMATION`). For a full list and detailed explanation of available access rights, head to the official [docs](https://docs.microsoft.com/en-us/windows/win32/procthread/thread-security-and-access-rights).
- `name` is the name of the local process whose thread object was open.
- `exe` is the full path of the local process image whose thread object was open.
- `pid` is the identifier of the local process whose thread object was opened.
- `tid` is the identifier of the local thread that was opened.
- `status` contains the result of the thread object open operation. (e.g. `success`)


```

`docs/nav.md`:

```md
<div onclick="window.location='https://www.fibratus.io';" class="logo"><strong>f</strong>ibratus</div>

```

`docs/outputs/console.md`:

```md
# Console

Console is the default output. It renders the inbound event flow onto the console. The console output tends to reduce the number of I/O syscalls by buffering the incoming event lines.

### Configuration {docsify-ignore}

The console output configuration is located in the `outputs.console` section.

#### enabled

Indicates whether the console output is active.

**default**: `true`

#### format

Specifies the console output format. The `pretty` format dictates that formatting is accomplished by replacing the specifiers in the template. The `json` format outputs the event as a raw JSON string.

**default**: `pretty`

#### kv-delimiter

Specifies the separator that's rendered between the event parameter's key and its value.

**default**: `➜`

#### template

Defines the template that's used in the event formatter. For more details, see the next section.

**default**: `{{ .Seq }} {{ .Timestamp }} - {{ .CPU }} {{ .Process }} ({{ .Pid }}) - {{ .Type }} ({{ .Kparams }})`

### Templates {docsify-ignore}

The template consists of a collection of named placeholders that event formatter replaces with desired values. The syntax of the template resembles the Go [template](https://golang.org/pkg/text/template/) engine constructs, excepts the event formatter lacks advanced templating features such as loops , functions or `if` statements.

The following field modifiers are supported:

- `.Seq`
- `.Timestamp`
- `.Pid`
- `.Ppid`
- `.Pexe`
- `.Pcomm`
- `.Pname`
- `.Cwd`
- `.Exe`
- `.Comm`
- `.Tid`
- `.Sid`
- `.Process`
- `.Category`
- `.Description`
- `.CPU`
- `.Type`
- `.Kparams`
- `.Meta`
- `.Host`
- `.PE`
- `.Kparams.`

**Examples**

- `{{ .Type }} on file ({{ .Kparams.File_name }})`

  renders

  `CreateFile on file C:\ProgramData\AVG\Antivirus\psi.db-journal`

- `{{ .Seq }} {{ .Process }} ({{ .Cwd }}) {{ .Ppid }} ({{ .Sid }})`

  renders

  `1999 cmd.exe (C:/Windows/System32) 2324 (nedo/archrabbit)`

- `{{ .Seq }} {{.CPU}} -  ({{.Type}}) Pid: {{ .Kparams.Pid }} {{ .Meta }}`

  renders

  `1999 4 -  (CreateProcess) Pid: 1232 env: prod, az: east`

```

`docs/outputs/elasticsearch.md`:

```md
# Elasticsearch

The Elasticsearch output ships kernel events to the `_bulk` [API endpoint](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html). Events are batched and flushed when the interval specified by `flush-period` elapses.

### Configuration {docsify-ignore}

The Elasticsearch output configuration is located in the `outputs.elasticsearch` section.

#### enabled

Indicates whether the Elasticsearch output is enabled.

**default**: `false`

#### servers

Defines the URL endpoints of the Elasticsearch nodes.

**default**: `http://localhost:9200`

#### timeout

Represents the initial HTTP connection timeout when connecting to the Elasticsearch cluster.

**default**: `5s`

#### flush-period

Specifies when to flush the bulk at the end of the given interval.

**default**: `1s`

#### bulk-workers

Determines the number of workers that commit docs to Elasticsearch. Higher values maximize the throughout at the cost of increased CPU utilization.

**default**: `1`

#### healthcheck

Enables or disables nodes health checking.

**default**: `true`

#### healthcheck-interval

Specifies the interval for checking if the Elasticsearch nodes are available.

**default**: `10s`

#### healthcheck-timeout

Specifies the timeout for periodic node health checks.

**default**: `5s`

#### username

Identifies the user name for the basic HTTP authentication.

#### password

Identifies the password for the basic HTTP authentication.

#### sniff

Enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list of available Elasticsearch nodes.

**default**: `false`

#### trace-log

Determines if the Elasticsearch client trace log is enabled. Useful for troubleshooting.

**default**: `false`

#### gzip-compression

Determines if the `gzip` compression is enabled for Elasticsearch documents.

**default**: `false`

#### template-name

Specifies the name of the index template.

**default**: `fibratus`

#### template-config

Contains the full JSON body of the index template. For more information refer to [index templates](https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html).

**default**:

```
{
	"index_patterns": [ "{{ fibratus* }}" ],
	"settings": {
		"index": {
			"refresh_interval": "5s",
			"number_of_shards": 1,
			"number_of_replicas": 1
		}
	},
	"mappings": {
		"properties": {
			"seq": { "type": "long" },
			"pid": { "type": "long" },
			"tid": { "type": "long" },
			"cpu": { "type": "short" },

			"name": { "type": "keyword" },
			"category": { "type": "keyword" },
			"description": { "type": "text" },
			"host": { "type": "keyword" },

			"timestamp": { "type": "date" },

			"kparams": {
				"type": "nested",
			    "properties": {
					"dip": { "type": "ip" },
					"sip": { "type": "ip" }
				}
			},

			"ps": {
				"type": "nested",
			    "properties": {
					"pid": { "type": "long" },
					"ppid": { "type": "long" },
					"name": { "type": "keyword" },
					"comm": { "type": "text" },
					"exe": { "type": "text" },
					"cwd": { "type": "text" },
					"sid": { "type": "keyword" },
					"sessionid": { "type": "short" }
				}
			}
		}
	}
}
```

#### index-name

Represents the target index for kernel events. It allows time specifiers to create indices per time frame. For example, `fibratus-%Y-%m` generates the index name with current year and month. Supported time specifiers are:

- `%Y` current year in `YYYY` format (`2020`)
- `%y` current year in `YY` format (`20`)
- `%m` current month (`01`)
- `%d` current day (`02`)
- `%H` current hour (`15`)

**default**: `fibratus`

#### tls-key

Path to the public/private key file.

#### tls-cert

Path to the certificate file.

#### tls-ca

Represents the path of the certificate file that is associated with the Certification Authority (CA).

#### tls-insecure-skip-verify

Indicates if the chain and host verification stage is skipped.

**default**: `false`

```

`docs/outputs/eventlog.md`:

```md
# Eventlog

Exports events via [Windows Event Log](https://docs.microsoft.com/en-us/windows/win32/wes/windows-event-log) API that can be explored with the [Event Viewer](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc766042(v=ws.11)) management tool. The screenshots below illustrate event logs produced by Fibratus. The `General` tab reveals the event type that was generated. Each log event pertains to the specific `Task Category` that directly maps to the internal event category. Similar to [sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon), Fibratus classifies each event with a custom `Event ID`. 

<p align="center">
  <img src="outputs/images/eventlog-general.png"/>
</p>

The `Details` tab shows extended event data including event parameters, process, and thread information. It is possible to customize the rendering template to influence the constructed event data. This is achieved by changing the [`eventlog.template`](outputs/eventlog?id=template) configuration property.

<p align="center">
  <img src="outputs/images/eventlog-details.png"/>
</p>

### Configuration {docsify-ignore}

The Eventlog output configuration is located in the `outputs.eventlog` section.

#### enabled

Indicates whether the Eventlog output is enabled.

**default**: `false`


#### level

Specifies the eventlog level associated with the event logs produced by Fibratus. You can specify one of the following values:

- `info`, `INFO`
- `warn`, `warning`, `WARN`, `WARNING`
- `erro`, `ERRO`, `error`, `ERROR`

**default**: `info`

#### remote-host

Address of the remote eventlog intake.

#### template

Go [template](https://pkg.go.dev/text/template) for rendering the eventlog message.

**default**:

```
Name:  		    {{ .Kevt.Name }}
Sequence: 		{{ .Kevt.Seq }}
Process ID:		{{ .Kevt.PID }}
Thread ID: 		{{ .Kevt.Tid }}
Cpu: 			{{ .Kevt.CPU }}
Params:			{{ .Kevt.Kparams }}
Category: 		{{ .Kevt.Category }}

{{- if .Kevt.PS }}

Process:		{{ .Kevt.PS.Name }}
Exe:			{{ .Kevt.PS.Exe }}
Pid:  			{{ .Kevt.PS.PID }}
Ppid: 			{{ .Kevt.PS.Ppid }}
Cmdline:		{{ .Kevt.PS.Comm }}
Cwd:			{{ .Kevt.PS.Cwd }}
SID:			{{ .Kevt.PS.SID }}
Session ID:		{{ .Kevt.PS.SessionID }}
{{ if and (.SerializeEnvs) (.Kevt.PS.Envs) }}
Env:
			{{- with .Kevt.PS.Envs }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeThreads }}
Threads:
			{{- with .Kevt.PS.Threads }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeImages }}
Modules:
			{{- with .Kevt.PS.Modules }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if and (.SerializeHandles) (.Kevt.PS.Handles) }}
Handles:
			{{- with .Kevt.PS.Handles }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}

{{ if and (.SerializePE) (.Kevt.PS.PE) }}
Entrypoint:  		{{ .Kevt.PS.PE.EntryPoint }}
Image base: 		{{ .Kevt.PS.PE.ImageBase }}
Build date:  		{{ .Kevt.PS.PE.LinkTime }}

Number of symbols: 	{{ .Kevt.PS.PE.NumberOfSymbols }}
Number of sections: {{ .Kevt.PS.PE.NumberOfSections }}

Sections:
			{{- with .Kevt.PS.PE.Sections }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ if .Kevt.PS.PE.Symbols }}
Symbols:
			{{- with .Kevt.PS.PE.Symbols }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Kevt.PS.PE.Imports }}
Imports:
			{{- with .Kevt.PS.PE.Imports }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Kevt.PS.PE.VersionResources }}
Resources:
			{{- with .Kevt.PS.PE.VersionResources }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
			{{ end }}
{{ end }}
{{- end }}

```

```

`docs/outputs/http.md`:

```md
# HTTP

Sends events to local/remote endpoints via HTTP protocol. Requests are serialized to the data format specified by the `serializer` property, which by default encodes events as `JSON` payloads. HTTP requests are randomly load-balanced across endpoints defined in the `endpoints` config property.

### Configuration {docsify-ignore}

The HTTP output configuration is located in the `outputs.http` section.

#### enabled

Indicates whether the HTTP output is enabled.

**default**: `false`

#### endpoints

Specifies a list of endpoints to which the events are forwarded. Each of the endpoints must contain the HTTP protocol scheme, that can be `http` or `https`.

#### timeout

Represents the timeout for the HTTP requests.

**default**: `5s`

#### proxy-url

Specifies the HTTP proxy URL. It overrides the HTTP proxy URL as indicated by the environment variables.

#### proxy-username

The username for HTTP proxy authentication.

#### proxy-password

The password for HTTP proxy authentication.

#### method

Determines the HTTP verb to use in requests.

**default**: `POST`

#### serializer

Specifies the event serializer type.

**default**: `json`

#### username

Username for the basic HTTP authentication.
   
#### password

Password for the basic HTTP authentication.

#### enable-gzip

If enabled, the HTTP body is compressed with the `gzip` compression.

**default**: `false`

#### headers

Represents a list of arbitrary headers to include in HTTP requests.

#### tls-key

Path to the public/private key file.

#### tls-cert

Path to the certificate file.

#### tls-ca

Represents the path of the certificate file that is associated with the Certification Authority (CA).

#### tls-insecure-skip-verify

Indicates if the chain and host verification stage is skipped.

**default**: `false`

```

`docs/outputs/introduction.md`:

```md
# Transporting Kernel Events

Fibratus delivers a diverse array of output sinks to route the events. When captures are not enough, you may opt for forwarding the event stream to remote destinations such as RabbitMQ brokers or Elasticsearch clusters. Outputs expose a rich set of configuration knobs that enable to fine-tune the behaviour of the event flow transmission.

### Event serialization tweaking {docsify-ignore}

JSON is the default serialization format for events. Since the event state contains a vast of attributes, you can specify which fields are serialized through configuration properties located in the `kevent` section.

- `serialize-threads` indicates whether the threads metadata are serialized as part of the process, and consequently, the event state
- `serialize-images` decides whether modules such as Dynamic Linked Libraries are serialized as part of the process state
- `serialize-handles` determines whether allocated process handles are serialized as part of the process state
- `serialize-pe` indicates if PE (Portable Executable) metadata are serialized as part of the process state
- `serialize-envs` indicates if environment variables are serialized as part of the process state

```

`docs/outputs/null.md`:

```md
# Null

The null output devours kernel events the same way a black hole swallows the light. This output is useful in case you want to snooze the event stream.

```

`docs/outputs/rabbitmq.md`:

```md
# RabbitMQ

The RabbitMQ output sends events to the [RabbitMQ](https://www.rabbitmq.com/) message broker. Various events are buffered and sent as part of a single AMQP message.

### Configuration {docsify-ignore}

The RabbitMQ output configuration is located in the `outputs.amqp` section.

#### enabled

Specifies whether the RabbitMQ output sink is enabled.

**default**: `false`

#### url

Represents the AMQP connection string.

**default**: `amqp://localhost:5672`

#### timeout

Specifies the AMQP connection timeout.

**default**: `5s`

#### exchange

Specifies the target AMQP exchange name that receives inbound event message flow.

**default**: `fibratus`

#### exchange-type

Represents  the AMQP exchange type. Available exchange type include common types are `direct`, `fanout`,
`topic`, `header`, and `x-consistent-hash`. To learn more about exchange types, refer to the RabbitMQ [docs](https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges).

#### routing-key

Represents the static routing key to link exchanges with queues.

**default**: `fibratus`

#### vhost

Represents the AMQP virtual host name.

**default**: `/`

#### durable

Indicates if the exchange is marked as durable. Durable exchanges can survive broker restarts.

**default**: `false`

#### passive

Indicates if the server checks whether the exchange already exists and raises an error if it doesn't exist.

**default**: `false`

#### delivery-mode

Determines if a published message is persistent or transient.

**default**: `transient`

#### username

The username for the plain authentication method.

#### password

The password for the plain authentication method.

#### headers

Designates a collection of static headers that are added to each published message.

#### tls-key

Path to the public/private key file.

#### tls-cert

Path to the certificate file.

#### tls-ca

Represents the path of the certificate file that is associated with the Certification Authority (CA).

#### tls-insecure-skip-verify

Indicates if the chain and host verification stage is skipped.

**default**: `false`

```

`docs/overview/what-is-fibratus.md`:

```md
# What is Fibratus?

[Fibratus](https://github.com/rabbitstack/fibratus) is a tool for exploration and tracing of the **Windows** kernel. It lets you trap system-wide events such as process life-cycle, file system I/O, registry modifications or network requests among many other observability signals. Once collected, the events can be shipped to a number of [sinks](/outputs/introduction), sliced and diced with [filaments](/filaments/introduction) or dumped to specialized [capture](/captures/introduction) files for local inspection and analysis. You can use the powerful filtering engine to dig into the event stream. The built-in [rules engine](https://www.fibratus.io/#/filters/rules) enables threat detection capabilities.

Fibratus is mainly targeted to malware researchers, security analysts, reverse engineers or DFIR oriented folks, even though software developers and system administrators might also benefit from it. Even if you don't pertain to any of those aforementioned IT collectives, but you are curious to comprehend what Windows and applications are doing under the hood, Fibratus is the right tool.

```

`docs/pe/introduction.md`:

```md
# Portable Executable Introspection

[Portable Executable](https://en.wikipedia.org/wiki/Portable_Executable) (PE) is the Windows file format that describes the layout of the executable code. PE is frequently subject to weaponization ranging from reverse shell payload injections to several obfuscation techniques used by malware creators.

Fibratus natively supports the scanning of the PE format data that, for example, underpins the [PE filters](/filters/fields?id=pe). To enable the PE introspection, it is necessary to edit the `pe.enabled` key in the configuration file or provide the `--pe.enabled=true` command line flag.

### Excluding executables {docsify-ignore}

When the PE introspection is enabled, Fibratus will try to obtain the PE data for every running process in the system. This happens during Fibratus bootstrap stage, but also when a new process is spawn. To skip gathering the PE data for some process images, you can add the image name under the `excluded-images` key in the configuration file. Avoiding the parsing of the PE format data for some process images, alleviates the pressure on Fibratus and reduces resource usage.

```

`docs/pe/resources.md`:

```md
# Resources

Fibratus reads version resources from the PE resource directory. The resource contains information about the exeucutable as its version number, its intended operating system, and its original filename. An example of version resources read by Fibratus:

```
CompanyName: Microsoft Corporation
FileDescription: Notepad
FileVersion: 10.0.18362.693 (WinBuild.160101.0800)
InternalName: Notepad
LegalCopyright: © Microsoft Corporation. All rights reserved.
OriginalFilename: NOTEPAD.EXE
ProductName: Microsoft® Windows® Operating System
ProductVersion: 10.0.18362.693
```

You can use any of these resource entries in filter expressions. For example, the `pe.resources[FileDescription] = 'Notepad'` filter matches any event where the `FileDescription` resource is equal to `Notepad`.

To enable resource parsing, it is necessary to set the `read-resources` option to `true`.

```

`docs/pe/sections.md`:

```md
# Sections

Sections are the fundamental building block of the PE data. They contain the content of the file, including the executable code, data, resources and other executable artifacts.

Fibratus obtains the number of sections, and for each section encountered in the PE data, its name and size is fetched. For example, the code section is called `.text` and the data section is called `.data`. Sometimes the malware specimens tamper the PE structure and alter sections. You can hunt for a non-standard number of sections in the executable or detect extraneous sections by checking the data surfaced by Fibratus.

### Reading extended section data {docsify-ignore}

For a full-blown section parsing, you can enable the `read-sections` option. This instructs the PE parser to read the underlying section bytes for the purpose of computing the `md5` hash of each section. It is possible to write filter expressions that involve evaluating the section attributes.

For example, to match against specific `.text` section `md5` hash, you would write the `pe.sections[.text].md5 = '0464997eb36c70083164c666d53c6af3'` filter.

```

`docs/pe/symbols.md`:

```md
# Symbols

 Symbols or functions referred to by the binary that are expected to be satisfied by other libraries at dynamic load time are located in the Import Address Table (IAT). Fibratus parses this table and extracts all symbols names as well as the dynamic libraries referenced by the binary. Symbol names can be `URLDownloadToFileA` or `WriteFile`.

 To activate symbol parsing it is necessary to enable the `read-symbols` option.

 From the filtering perspective,  you can write `pe.symbols in ('GetTextFaceW', 'GetProcessHeap')` or `pe.imports in ('msvcrt.dll', 'GDI32.dll')` to filter events where the originating process contains the provided symbols or imports in its binary PE data.

```

`docs/setup/configuration.md`:

```md
# Configuration

You can parametrize Fibratus from various configuration sources including `yaml`/`json` files, environment variables and command line flags.
Properties that you specify via command line flags or environment variables take precedence over the configuration file.

### Files {docsify-ignore}

By default, configuration files are stored in `%PROGRAM FILES%\Fibratus\Config` directory. If you prefer to keep them in a different location, you can override the configuration file path via the `--config-file` command line flag when starting Fibratus. The template, `fibratus.yml` configuration file with all options documented is available in the `%PROGRAM FILES%\Fibratus\Config` directory.

### Flags {docsify-ignore}

Each CLI command accepts a set of config flags. For example, running the `fibratus run -h` command displays flag names, their default value (if any), and a short description. Command line flags take precedence over environment variables and configuration files.

!> Some configuration options are not exposed via command line flags and can only be tuned in the configuration file.


### Environment variables {docsify-ignore}

To set a certain configuration property via an environment variable, a simple rule of thumb needs to be followed: remove the leading `--` characters in the flag name, convert all `.` and `-` characters to `_` symbol, capitalize the environment variable name and you're ready to go.

Let's suppose we want to set the value of the `--kstream.buffer-size` flag via an environment variable. The resulting environment variable would get converted to `KSTREAM_BUFFER_SIZE`.

```

`docs/setup/installation.md`:

```md
# Installation

### Minimum requirements {docsify-ignore}

- 64-bits Windows operating system starting from Windows 7
- 40 MB of free disk space
- 1 (V)CPU
- 50 MB of available memory

### Deployment  {docsify-ignore}

The easiest way to get started with Fibratus is by downloading the Windows installer. Head over to the [releases](https://github.com/rabbitstack/fibratus/releases) and pick your download. Latest releases are recommended as they ship with new features, bug fixes and tend to improve the performance.
Windows installers are automatically built by the CI platform each time new Fibratus release is published.

<p align="center">
  <a href="https://github.com/rabbitstack/fibratus/releases"><img src="setup/images/fibratus-installer-msi.png"/></a>
</p>

There are two flavors of Windows MSI installers:

- __full installers__ ship with all features ([captures](captures/introduction), [filaments](filaments/introduction), [yara](yara/introduction)) and bundle the embedded Python distribution
- __slim installers__ support less features but are more portable and have lower disk space requirements

After the install completes, you can verify if Fibratus was correctly installed. Spin up a command line prompt. Alternatively, you can use [Windows Terminal](https://github.com/microsoft/terminal) or [Cmder](https://cmder.net/) consoles which is the recommended choice for better user experience. Run the following command:


```
$ fibratus -h

Usage:
  fibratus [command]

Available Commands:
  capture         Capture kernel event stream to the kcap file
  config          Show runtime config
  docs            Open Fibratus docs in the web browser
  help            Help about any command
  install-service Install fibratus within the Windows service control manager
  list            Show info about filaments, filter fields or kernel event types
  remove-service  Remove fibratus from the Windows service control manager
  replay          Replay kernel event flow from the kcap file
  restart-service Restart fibratus service
  run             Bootstrap fibratus or a filament
  start-service   Start fibratus service
  stats           Show runtime stats
  stop-service    Stop fibratus service
  version         Show version info
```

If you're able to see the output like in the snippet above, congratulations! You have successfully installed Fibratus. Jump to [running](/setup/running).

### Uninstall {docsify-ignore}

To remove Fibratus from your system, head to the Control Panel > Programs and Features and start the uninstall process. The uninstaller will make sure to get rid of all installation data.

## Building from source {docsify-ignore}

To build Fibratus directly from source code you have satisfy the following requirements:

- Go compiler 1.15
- C compiler (optional)
- Python headers (optional)
- [libyara](https://github.com/VirusTotal/yara/tree/master/libyara) (optional)

### Installing dependencies {docsify-ignore}

!> You can skip this step if you're not interested in building features that interop with the C code.

1. Download the `msys2` installer and follow the instructions [here](https://www.msys2.org/).
  - open the `msys2` shell (by default located in `C:\msys2\msys2.exe`). You can also access it from the `MSYS2 64-bit` Start Menu item.
  - install the `MinGW` compiler toolchain along with other dependencies:
    - `pacman -S base-devel mingw-w64-x86_64-openssl mingw-w64-x86_64-gcc mingw-w64-x86_64-pkg-config automake libtool autoconf`
2. [Download](https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe) and install the `Python 3.7`. Assuming the Python distribution was installed in `C:\Python37`, set the `PKG_CONFIG_PATH` environment variable to the location of the `pkg-config` directory within the `fibratus` directory.
  - `set PKG_CONFIG_PATH=<pkg-config absolute path>`
3. Build `libyara`
  - clone the `yara` repository into the path visible to the `msys2` environment. This is ideally done from the `MSYS2 64-bit` shell.
    - `pacman -S git`
    - `git clone https://github.com/VirusTotal/yara.git`
    - go to the `yara` repository you previously cloned. Run the following commands:
      - `autoreconf -fiv`
      - `./configure --host=x86_64-w64-mingw32`
      - `make install`

### Building the executable {docsify-ignore}

The **optional dependencies are only needed** if you'll be building features that interop with the C code. The Go compiler is instructed to ignore all features that trigger the [cgo](https://golang.org/cmd/cgo/), but you can control which features are built into Fibratus through the following build flags:

- `filament`: compiles Fibratus with filaments support
- `kcap`: compiles Fibratus with support for capturing/replaying kcap files
- `yara`: builds Fibratus with support for [Yara](https://virustotal.github.io/yara/) pattern matching

To build the Fibratus binary without filament, kcap nor yara features, run the following command from the `cmd` shell and within the`fibratus` directory:

```
$ make
```

To produce the Fibratus binary with the filaments support, you would run the following commands:

```
$ set TAGS=filament
$ make
```

In either case, the resulting binary is placed in the `cmd\fibratus` directory.

```

`docs/setup/running.md`:

```md
# Running

### Permission requirements {docsify-ignore}

Fibratus requires **administrator** privileges to start/stop ETW sessions. During execution, Fibratus performs the following operations on your system:

- takes a snapshot of allocated system handles. You can control this option through [configuration](/kevents/handle?id=handle-state) flags
- periodically writes the current event sequence into volatile registry value
- writes logs to disk. The default logs directory location is `%PROGRAMFILES%\Fibratus\Logs`
- grants the `SeDebugPrivilege` to its process token. However, you can disable granting this privilege by setting the `debug-privilege` option to `false`
- transports kernel events over the wire when non-console output is active
- inspects process image [PE](/pe/introduction.md) metadata. Again, you can disable this feature through [config](/pe/introduction) file
- executes [YARA](/yara/introduction.md) rules on freshly created process images or other image files when the [YARA scanner](/yara/introduction) is enabled
- spins up an embedded Python interpreter to run [filaments](/filaments/introduction)

### Resource overhead {docsify-ignore}

The resource utilization greatly depends on the type of workloads, the amount of data collected by Fibratus, and the output sink responsible for transporting events. Some benchmarks were performed with Fibratus and Elasticsearch running on the same machine along with other userspace processes. Since ingesting non-trivial amount of data puts a strain on the file system (writing and merging of the Lucene segments) and the network I/O, this was a perfect scenario for stressing out Fibratus. All kernel events, except handle events, were captured and shipped to Elasticsearch. The following resource utilization was recorded:

- 3-6% single CPU core
- ~170 MB memory usage

### Standalone binary {docsify-ignore}

To start collecting kernel events, you can run Fibratus from the command line:

```
$ fibratus run
```

The continuous stream of kernel events will start rendering on the console.

```
  ...
681951 2020-11-07 14:24:57.1839809 +0100 CET - 2 cmd.exe (6328) - CreateFile (file_name➜ C:\WINDOWS\system32\config\systemprofile\AppData\Local\Microsoft\WindowsApps\, file_object➜ ffffa88c7ea077d0, irp➜ ffffa88c746b2a88, operation➜ supersede, share_mask➜ rw-, type➜ directory)
681952 2020-11-07 14:24:57.1840451 +0100 CET - 2 cmd.exe (6328) - RegOpenKey (key_handle➜ 0, key_name➜ HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsStore, status➜ key not found)
681953 2020-11-07 14:24:57.1840626 +0100 CET - 2 cmd.exe (6328) - RegOpenKey (key_handle➜ 0, key_name➜ HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\StateSeparation\RedirectionMap\Keys, status➜ key not found)
681954 2020-11-07 14:24:57.1840751 +0100 CET - 2 cmd.exe (6328) - RegOpenKey (key_handle➜ 0, key_name➜ HKEY_LOCAL_MACHINE\Software\Microsoft\LanguageOverlay\OverlayPackages\en-US, status➜ key not found)
681955 2020-11-07 14:24:57.1841104 +0100 CET - 2 cmd.exe (6328) - CreateFile (file_name➜ C:\WINDOWS\system32\en-US\cmd.exe.mui, file_object➜ ffffa88c7ea077d0, irp➜ ffffa88c746b2a88, operation➜ open, share_mask➜ r-d, type➜ directory)
681956 2020-11-07 14:24:57.1848044 +0100 CET - 2 cmd.exe (6328) - TerminateThread (base_prio➜ 8, entrypoint➜ 7ff7762382b0, io_prio➜ 2, kstack➜ fffff10cf0785000, kstack_limit➜ fffff10cf077e000, page_prio➜ 5, pid➜ 6328, tid➜ 11716, ustack➜ d020700000, ustack_limit➜ d020604000)
681957 2020-11-07 14:24:57.1848713 +0100 CET - 2 cmd.exe (6328) - UnloadImage (base_address➜ 7ff776220000, default_address➜ 7ff776220000, file_name➜ C:\Windows\System32\cmd.exe, image_size➜ 413696, pid➜ 6328)
681958 2020-11-07 14:24:57.1848779 +0100 CET - 2 cmd.exe (6328) - UnloadImage (base_address➜ 7fffaaba0000, default_address➜ 7fffaaba0000, file_name➜ C:\Program Files\AVG\Antivirus\aswhook.dll, image_size➜ 73728, pid➜ 6328)
681959 2020-11-07 14:24:57.1848954 +0100 CET - 2 cmd.exe (6328) - UnloadImage (base_address➜ 7fffc97a0000, default_address➜ 7fffc97a0000, file_name➜ C:\Windows\System32\KernelBase.dll, image_size➜ 2764800, pid➜ 6328)
681967 2020-11-07 14:24:57.184997 +0100 CET - 2 erl.exe (5236) - TerminateProcess (comm➜ C:\WINDOWS\system32\cmd.exe /c handle.exe /accepteula -s -p 5236 2> nul, directory_table_base➜ 2300cb000, exe➜ C:\WINDOWS\system32\cmd.exe, exit_status➜ 1, kproc➜ ffffa88c70ee7080, name➜ cmd.exe, pid➜ 6328, ppid➜ 5236, session_id➜ 0, sid➜ NT AUTHORITY\SYSTEM)
681968 2020-11-07 14:24:57.1853111 +0100 CET - 2  (6328) - RegOpenKey (key_handle➜ ffffc980980b55f0, key_name➜ HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings\S-1-5-18, status➜ success)
681969 2020-11-07 14:24:57.1853224 +0100 CET - 2  (6328) - RegQueryValue (key_handle➜ ffffc980abd657d0, key_name➜ HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings\S-1-5-18\\Device\HarddiskVolume4\Windows\System32\cmd.exe, status➜ key not found)
681970 2020-11-07 14:24:57.1853581 +0100 CET - 5 aswidsagent.exe (7812) - CreateFile (file_name➜ C:\WINDOWS\SYSTEM32\CMD.EXE, file_object➜ ffffa88c7a8053e0, irp➜ ffffa88c7b711608, operation➜ open, share_mask➜ rw-, type➜ file)
681971 2020-11-07 14:24:57.185952 +0100 CET - 4 AVGSvc.exe (4000) - CreateFile (file_name➜ C:\ProgramData\AVG\Antivirus\psi.db-journal, file_object➜ ffffa88c7ea02500, irp➜ ffffa88c73ff8a88, operation➜ supersede, share_mask➜ rw-, type➜ directory)
681972 2020-11-07 14:24:57.1860706 +0100 CET - 4 AVGSvc.exe (4000) - ReadFile (file_name➜ C:\ProgramData\AVG\Antivirus\psi.db, file_object➜ ffffa88c72c7c260, io_size➜ 16, irp➜ ffffa88c73ff8a88, offset➜ 24, type➜ file)
  ...
```

Each line is comprised of the following fields:

- monotonic sequence value
- timestamp of event occurrence
- CPU where the event was captured
- the process name and the pid that produced the event
- event type
- event parameters

A different [rendering template](/outputs/console?id=templates) can be used to customize the line format or you can opt to change the output format to, for example, JSON.

The console output is the default kernel events sink, even though you can route the kernel event flow to [Elasticsearch](https://www.elastic.co/elasticsearch/) or [RabbitMQ](https://www.rabbitmq.com/) sinks, just to name a few. [Learn](/outputs/introduction) more about output sinks.

To stop Fibratus, hit the `Ctr-C` key combination.

### Windows service {docsify-ignore}

If you prefer long-running jobs, you might consider running Fibratus as Windows Service. Execute the following command to register the instance of the Fibratus service within the Service Control Manager:

```
$ fibratus install-service
```

Now, it's time to start the Fibratus service:

```
$ fibratus start-service
```

If any errors occur during service startup, they we'll be logged to Windows Events Log. To stop the Fibratus service use the `fibratus stop-service` command. Service removal is accomplished through `fibratus remove-service` command.

## CLI {docsify-ignore}

Invoking the `fibratus` binary without any parameters reveals available CLI commands. You can obtain help information for each available command by appending the `--help` or `-h` option after the command name. Let's briefly describe available commands.

### run

The main command for bootstrapping Fibratus or running a filament. It accepts an optional filter expression. Examples:

- collect all events
  ```
  $ fibratus run
  ```

- run the `watch_files` filament
  ```
  $ fibratus run -f watch_files
  ```

- collect fs events originated from the `cmd.exe` process
  ```
  $ fibratus run kevt.category = 'file' and ps.name = 'cmd.exe'
  ```

- collect fs events and enable PE introspection
  ```
  $ fibratus run kevt.category = 'file' --pe.enabled=true
  ```

### capture

Dumps the kernel event flow to specialized kcap (capture) file. It accepts an optional filter expression. Examples:

- capture all events to `events.kcap` capture file
  ```
  $ fibratus capture -o events
  ```

- capture network events from the specific destination IP address
  ```
  $ fibratus capture kevt.category = 'net' and net.dip = 172.17.2.3 -o events
  ```

### replay

Replays the kernel event flow from the kcap file. It accepts an optional filter expression. Examples:

- replay all events from the `events.kcap` capture file
  ```
  $ fibratus replay -k events
  ```

- replay events that contain a specific resource name in the PE resource directory
  ```
  $ fibratus replay pe.resources[Company] contains 'blackwater' -k events
  ```

### config

Prints the options loaded from configuration sources including files, command line flags or environment variables. Sensitive data, such as passwords are  masked out.

### install-service

Installs the Fibratus service within the Windows Service Control Manager. If this command is successful, the Fibratus service will appear in the Windows Services Manager console.

### start-service

Starts the Fibratus service that was previously registered within the Windows Service Control Manager.

### stop-service

Stops the Fibratus Windows service.

### restart-service

Restarts the Fibratus Windows service.

### remove-service

Removes the Fibratus service from the Windows Service Control Manager.

### docs

Launches the default web browser and opens the Fibratus documentation site.

### list

The `list` command consists of various subcommands:

  * `filaments`: displays available filaments. Filaments live in the `%PROGRAMFILES\Fibratus\Filaments` directory, but you can override this location with the `--filament.path` flag or the corresponding key in the `yaml` configuration file.
  * `fields`: shows all [field names](/filters/fields) that can be used in filter expressions.
  * `kevents`: shows available kernel event types.

### stats

Returns the runtime metrics that are exposed through the [expvar](https://golang.org/pkg/expvar/) HTTP endpoint. Useful for debugging.

### version

Displays the Fibratus version along with the commit hash and the Go compiler version.

```

`docs/themes/fibratus.css`:

```css
@import url("https://fonts.googleapis.com/css?family=Roboto+Mono|Source+Code+Pro|Oxygen+Mono|Nova+Mono|Source+Sans+Pro:300,400,600");
* {
	-webkit-font-smoothing: antialiased;
	-webkit-overflow-scrolling: touch;
	-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
	-webkit-text-size-adjust: none;
	-webkit-touch-callout: none;
	box-sizing: border-box
}

body:not(.ready) {
	overflow: hidden
}

body:not(.ready) .app-nav,
body:not(.ready)>nav,
body:not(.ready) [data-cloak] {
	display: none
}

div#app {
	font-size: 30px;
	font-weight: lighter;
	margin: 40vh auto;
	text-align: center
}

div#app:empty:before {
	content: "Loading Fibratus Docs..."
}

footer span {
		font-size: 10px;
}

footer {
	text-align: center;
}

.search input {
	background-color: #F7F7F7;
	border-radius:5px;
	text-indent: 23px;
	-moz-border-radius:5px;
	-webkit-border-radius:5px;
}

.search .input-wrap::before {
		font-family: "FontAwesome";
		content: "\f002";
    position: relative;
    left: 8px;
    top: -2px;
		color: #d6e0f0;
    height: 24px;
    width: 0;
    overflow: visible;
    display: inline-block;
    line-height: 24px;
    z-index: 1;
}

.fast-icon {
  color: #ffba00;
}

.extensible-icon {
	color: #5D99E5;
}

.comprehensive-icon {
	color: #738FD6;
}

.operator > p {
	background-color: rgba(0, 27, 61, 0.03);
	border-left: 4px solid #6da9e2 !important;
	border-radius: 5px;
	color: #001b3d;
	font-weight: 600;
	font-size: .95em;
	padding: 0.7em 0.6em;
}


p.center {
	text-align: center;
	font-size: 30px;
}

.inner-icon {
    border-top: 1px solid #ffba00;
    color: #ffba00;
    font-size: 1.5em;
    margin-bottom: -.5em;
    margin-top: 1em;
    text-align: center;
}

.emoji {
	height: 1.2rem;
	vertical-align: middle
}

.progress {
	background-color: var(--theme-color, #42b983);
	height: 2px;
	left: 0;
	position: fixed;
	right: 0;
	top: 0;
	transition: width .2s, opacity .4s;
	width: 0;
	z-index: 999999
}

.hero-icon-left {
	font-size: 100px;
	color: #b6d4f0;
	float: left;
	margin-left: -10px;
	margin-bottom: 2px;
	margin-top: -10px;
	margin-right: 15px;
	 --ionicon-stroke-width: 16px;
}

.search .search-keyword,
.search a:hover {
	color: var(--theme-color, #42b983)
}

.search .search-keyword {
	font-style: normal;
	font-weight: 700
}

.hydrated {
	top: 3px;
	position: relative;
}

body,
html {
	height: 100%
}

body {
	-moz-osx-font-smoothing: grayscale;
	-webkit-font-smoothing: antialiased;
	color: #34495e;
	font-family: Jost, Source Sans Pro, Helvetica Neue, Arial, sans-serif;
	font-size: 18px;
	letter-spacing: 0;
	margin: 0;
	overflow-x: hidden
}

img {
	max-width: 100%
}

a[disabled] {
	cursor: not-allowed;
	opacity: .6
}

kbd {
	border: 1px solid #ccc;
	border-radius: 3px;
	display: inline-block;
	font-size: 12px!important;
	line-height: 12px;
	margin-bottom: 3px;
	padding: 3px 5px;
	vertical-align: middle
}

li input[type=checkbox] {
	margin: 0 .2em .25em 0;
	vertical-align: middle
}

.app-nav {
	margin: 0;
	top: 0;
	position: fixed;
	right: 0;
	text-align: right;
	z-index: 10;
	background-color: #6da9e2;
	width: 100%;
	height: 0px;
	display: none;
}

.app-nav.no-badge {
	margin-right: 0px
}

.app-nav p {
	margin: 0
}

.app-nav>a {
	margin: 0 0rem;
	padding: 5px 0
}

.app-nav li,
.app-nav ul {
	display: inline-block;
	list-style: none;
	top: -12px;
	margin-right: 10px;
}

.app-nav a {
	border-radius: 1rem;
	border: 1px solid var(--theme-color, #42b983);
	box-sizing: border-box;
	color: var(--theme-color, #42b983);
	display: inline-block;
	font-size: 0.6rem;
	font-weight: 600;
	letter-spacing: .1rem;
	margin: .1rem .1rem;
	padding: .4em .4rem;
	text-decoration: none;
	transition: all .15s ease;
	background-color: #4787BE;
	color: #F7F7F7
}

.sidebar-margin-nocover {
	margin-top: 0px;
}

.app-nav a.active {
	color: #fff;
}
.app-nav a:hover {
	background-color: #5894ce;
	opacity: .8
}

.app-nav li {
	display: inline-block;
	margin: 0 0.2rem;
	padding: 0px 0;
	position: relative
}

.app-nav li ul {
	background-color: #fff;
	border: 1px solid;
	border-color: #ddd #ddd #ccc;
	border-radius: 4px;
	box-sizing: border-box;
	display: none;
	max-height: calc(100vh - 81px);
	overflow-y: auto;
	padding: 10px 0;
	position: absolute;
	right: -15px;
	text-align: left;
	top: 100%;
	white-space: nowrap
}

.app-nav li ul li {
	display: block;
	font-size: 14px;
	line-height: 1rem;
	margin: 8px 14px;
	white-space: nowrap
}

.app-nav li ul a {
	display: block;
	font-size: inherit;
	margin: 0;
	padding: 0;
}

.app-nav li ul a.active {
	border-bottom: 0;
}

.app-nav li:hover ul {
	display: block
}

.app-nav .logo {
	color: #F7F7F7;
	font-size: 1.7rem;
	font-weight: 400;
	margin-left: 25px;
	margin-top: 2px;
	position: absolute;
	text-align: right;
	display: none;
	cursor: pointer;
	letter-spacing: 2px;
}

.github-corner {
	border-bottom: 0;
	position: fixed;
	right: 0;
	text-decoration: none;
	top: 0;
	z-index: 1
}

.github-corner:hover .octo-arm {
	-webkit-animation: octocat-wave .56s ease-in-out;
	animation: octocat-wave .56s ease-in-out
}

.github-corner svg {
	color: #fff;
	fill: var(--theme-color, #42b983);
	height: 80px;
	width: 80px
}

main {
	display: block;
	position: relative;
	width: 100vw;
	height: 100%;
	z-index: 0
}

main.hidden {
	display: none
}

.anchor {
	display: inline-block;
	text-decoration: none;
	transition: all .3s
}

.anchor span {
	color: #34495e
}

.anchor span:h {
	color: #6da9e2
}

.anchor:hover {
	text-decoration: none;
}

.ml-auto {
	margin-left: auto;
}

.mr-auto {
	margin-right: auto;
}

.divider-custom {
    margin: 1.25rem 0 1.5rem;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

.divider-custom.divider-light .divider-custom-line {
    background-color: #2c3e50;
}

.divider-custom .divider-custom-line {
    width: 100%;
    max-width: 7rem;
    height: 0.25rem;
    background-color: #2c3e50;
    border-radius: 1rem;
    border-color: #2c3e50 !important;
}

.divider-custom .divider-custom-icon {
    color: #2c3e50 !important;
    font-size: 2rem;
}

.sidebar {
	border-right: 1px solid rgba(0, 0, 0, .07);
	overflow-y: auto;
	padding: 10px 10px 0;
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	transition: transform .25s ease-out;
	width: 300px;
	z-index: 20;
	background-color: #F7F7F7;
}

.sidebar>h1 {
	margin: 0 auto 1rem;
	font-size: 1.5rem;
	font-weight: 300;
	text-align: center
}

.sidebar>h1 a {
	color: inherit;
	text-decoration: none
}

.sidebar>h1 .app-nav {
	display: block;
	position: static
}

.sidebar .sidebar-nav {
	line-height: 1.7em;
	padding-bottom: 40px
}

.sidebar li.collapse .app-sub-sidebar {
	display: none
}

.sidebar ul {
	margin: 0 0 0 8px;
	padding: 0;
}

.sidebar li>p {
	font-weight: 700;
	margin: 0
}

.sidebar ul,
.sidebar ul li {
	list-style: none;
	line-height: 20px;
	margin-bottom: -4px;
}

.sidebar ul li:hover {
	cursor: pointer;
	color: #6da9e2;
}

.sidebar ul +ul {
  max-height:0;
  overflow:hidden;
  transition:0.5s linear;
}

.sidebar ul li {
	border-bottom: none;
	display: block;
  padding: 4px 8px;
	font-size: 19px;
	font-weight: 500;
}

.sidebar ul li ul {
	border-left: 1px solid rgba(0, 0, 0, .07);
}

.sidebar ul li ul {
	padding-left: 1px
}

.sidebar::-webkit-scrollbar {
	width: 4px
}

.sidebar::-webkit-scrollbar-thumb {
	background: transparent;
	border-radius: 4px
}

.sidebar:hover::-webkit-scrollbar-thumb {
	background: hsla(0, 0%, 53.3%, .4)
}

.sidebar:hover::-webkit-scrollbar-track {
	background: hsla(0, 0%, 53.3%, .1)
}

.sidebar-toggle {
	background-color: transparent;
	border: 0;
	outline: none;
	padding: 10px;
	position: absolute;
	bottom: 0;
	left: 0;
	text-align: center;
	transition: opacity .3s;
	width: 284px;
	z-index: 30
}

.sidebar-toggle .sidebar-toggle-button:hover {
	opacity: .4
}

.sidebar-toggle span {
	background-color: var(--theme-color, #42b983);
	display: block;
	margin-bottom: 4px;
	width: 16px;
	height: 2px
}

body.sticky .sidebar,
body.sticky .sidebar-toggle {
	margin-top: 0px;
	position: fixed;
}

body.sticky .page_toc {
	margin-top: 15px;
}

body.sticky .app-nav .logo {
	display: none;
}

.page_toc ul a:hover span {
	color: #6da9e2 !important;
}

.page_toc ul a {
	font-size: 17px !important;
}

.page_toc .active {
	border-left: 3px solid !important;
}

.page_toc {
		padding-left: 12px !important;
}

.content {
	padding-top: 30px;
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 300px;
	transition: left .25s ease;
	background-color: #F7F7F7;
}

.markdown-section {
	margin: 0 auto;
	max-width: 80%;
	padding: 30px 15px 40px;
	position: relative;
}

.markdown-section>* {
	box-sizing: border-box;
	font-size: inherit
}

.markdown-section>:first-child {
	margin-top: 0!important
}

.markdown-section hr {
	border: none;
	border-bottom: 1px solid #eee;
	margin: 2em 0
}

.markdown-section iframe {
	border: 1px solid #eee;
	width: 1px;
	min-width: 100%
}

.markdown-section table {
	border-collapse: collapse;
	border-spacing: 0;
	display: block;
	margin-bottom: 1rem;
	overflow: auto;
	width: 100%
}

.markdown-section th {
	font-weight: 700
}

.markdown-section td,
.markdown-section th {
	border: 1px solid #ddd;
	padding: 6px 13px
}

.markdown-section tr {
	border-top: 1px solid #ccc
}

.markdown-section p.tip,
.markdown-section tr:nth-child(2n) {
	background-color: rgba(0, 27, 61, 0.03);
}

.markdown-section p.tip {
	border-bottom-right-radius: 2px;
	border-left: 4px solid #f66;
	border-top-right-radius: 2px;
	margin: 2em 0;
	padding: 12px 24px 12px 30px;
	position: relative
}

.markdown-section p.tip:before {
	background-color: #f66;
	border-radius: 100%;
	color: #fff;
	content: "!";
	font-family: Dosis, Source Sans Pro, Helvetica Neue, Arial, sans-serif;
	font-size: 14px;
	font-weight: 700;
	left: -12px;
	line-height: 20px;
	position: absolute;
	height: 20px;
	width: 20px;
	text-align: center;
	top: 14px
}

.markdown-section p.tip code {
	background-color: #efefef
}

.markdown-section p.tip em {
	color: #34495e
}

.markdown-section p.warn {
	background: rgba(66, 185, 131, .1);
	border-radius: 2px;
	padding: 1rem
}

.markdown-section ul.task-list>li {
	list-style-type: none
}

body.close .sidebar {
	transform: translateX(-300px)
}

body.close .sidebar-toggle {
	width: auto
}

body.close .content {
	left: 0
}

@media print {
	.app-nav,
	.github-corner,
	.sidebar,
	.sidebar-toggle {
		display: none
	}
}


@media screen and (max-width: 1300px) {
	.page_toc {
		display: none;
	}
}

@media screen and (max-width: 768px) {
    .github-corner,
    .sidebar,
    .sidebar-toggle {
        position: fixed;
    }
    .app-nav {
        margin-top: 16px;
    }
    .app-nav li ul {
        top: 30px;
    }
    main {
        height: auto;
        overflow-x: hidden;
    }
    .sidebar {
        left: -300px;
        transition: transform 0.25s ease-out;
    }
    .content {
        left: 0;
        max-width: 100vw;
        position: static;
        padding-top: 20px;
        transition: transform 0.25s ease;
    }
    .app-nav,
    .github-corner {
        transition: transform 0.25s ease-out;
    }
    .sidebar-toggle {
        background-color: transparent;
        width: auto;
        padding: 30px 30px 10px 10px;
    }
    body.close .sidebar {
        transform: translateX(300px);
    }
    body.close .sidebar-toggle {
        background-color: hsla(0, 0%, 100%, 0.8);
        transition: background-color 1s;
        width: 284px;
        padding: 10px;
    }
    body.close .content {
        transform: translateX(300px);
    }
    body.close .app-nav,
    body.close .github-corner {
        display: none;
    }
    .github-corner:hover .octo-arm {
        -webkit-animation: none;
        animation: none;
    }
    .github-corner .octo-arm {
        -webkit-animation: octocat-wave 0.56s ease-in-out;
        animation: octocat-wave 0.56s ease-in-out;
    }
	.page_toc {
		display: none;
	}
}

@keyframes octocat-wave {
	0%,
	to {
		transform: rotate(0)
	}
	20%,
	60% {
		transform: rotate(-25deg)
	}
	40%,
	80% {
		transform: rotate(10deg)
	}
}

section.cover {
	align-items: center;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	height: 205vh;
	display: none;
}

section.cover.show {
	display: flex;
	background: linear-gradient(#6da9e2,#c7def4) !important;
}

section.cover.has-mask .mask {
	background-color: #fff;
	opacity: .8;
	position: absolute;
	top: 0;
	height: 100%;
	width: 100%
}

section.cover .cover-main {
	flex: 1;
	margin: -20px 16px 0px; 
	text-align: center;
	position: relative;
}

section.cover .cover-main img {
	margin-top: 45px;
}

section.cover a {
	color: inherit
}

section.cover a,
section.cover a:hover {
	text-decoration: none
}

section.cover p {
	line-height: 1.5rem;
	margin: 1em 0
}

section.cover h1 {
	color: #fff;
	font-size: 2.5rem;
	font-weight: 300;
	margin: .625rem 0 2.5rem;
	position: relative;
	text-align: center
}

section.cover h1 a {
	display: block
}

section.cover h1 small {
	bottom: -.4375rem;
	font-size: 1rem;
	position: absolute
}

section.cover blockquote {
	font-size: 1.5rem;
	text-align: center
}

section.cover ul {
	line-height: 1.8;
	list-style-type: none;
	margin: 1em auto;
	max-width: 500px;
	padding: 0
}

section.cover .cover-main>p:nth-last-child(2) a {
	background: linear-gradient(340.87deg,#777ce0 -5.97%,#60cefd 100.83%);
	box-shadow: 0px 20px 30px -3px rgba(112,153,234,.45);
	border-radius: 2rem;
	border: 1px solid var(--theme-color, #42b983);
	box-sizing: border-box;
	color: #34495e;
	display: inline-block;
	font-size: 1.05rem;
	letter-spacing: .1rem;
	margin: .5rem 1rem;
	padding: .75em 2rem;
	text-decoration: none;
	transition: .3s all ease-in-out;
}

section.cover .cover-main {
	position: relative;
	top: 0px;
}

section.cover .cover-main>p:nth-last-child(2) a:hover {
	color: inherit;
  opacity: .8;
}

section.cover .cover-main h1 {
	font-size: 3.5rem;
}

section.cover blockquote>p>a {
	border-bottom: 2px solid var(--theme-color, #42b983);
	transition: color .3s
}

section.cover blockquote>p>a:hover {
	color: var(--theme-color, #42b983)
}

section.cover .cover-main div {
	position: relative;
} 

.sidebar,
body {
	background-color: #F7F7F7;
}

.sidebar {
	color: #364149
}

.sidebar li {
	margin: 10px 0
}

.sidebar ul li a {
	color: #505d6b;
	font-size: 16px;
	font-weight: 500;
	overflow: hidden;
	text-decoration: none;
	text-overflow: ellipsis;
	white-space: nowrap;
}

.sidebar ul li a:hover {
	text-decoration: underline
}

.sidebar ul li ul {
	padding: -1;
	margin: 0
}

.sidebar ul li.active>a {
	color: var(--theme-color, #42b983);
	font-weight: 600
}

.app-sub-sidebar li:before {
	padding-right: 4px;
	float: left
}

.markdown-section h1,
.markdown-section h2,
.markdown-section h3,
.markdown-section h4,
.markdown-section strong {
	color: #2c3e50;
	font-weight: 600
}

.markdown-section h4 {
	 border-bottom: 1px solid rgba(0, 0, 0,.045);
}

.markdown-section h2.center {
	color: #2c3e50;
	font-weight: 600;
	text-align: center;
}

.markdown-section a {
	color: var(--theme-color, #42b983);
	font-weight: 600
}

.markdown-section h1 {
	font-size: 2rem;
	margin: 0 0 1rem;
	border-bottom: 1px solid rgba(0, 0, 0,.075);
}

.markdown-section h2 {
	font-size: 1.75rem;
	margin: 45px 0 .8rem
}

.markdown-section h3 {
	font-size: 1.5rem;
	margin: 40px 0 .6rem
}

.markdown-section h4 {
	font-size: 1.25rem
}

.markdown-section h5 {
	font-size: 1rem
}

.markdown-section h6 {
	color: #777;
	font-size: 1rem
}

.markdown-section figure,
.markdown-section p {
	margin: 1.2em 0
}

.markdown-section ol,
.markdown-section p,
.markdown-section ul {
	line-height: 1.6rem;
	word-spacing: .05rem
}

.markdown-section ol,
.markdown-section ul {
	padding-left: 1.5rem
}

.markdown-section blockquote {
	border-left: 4px solid var(--theme-color, #42b983);
	color: #858585;
	margin: 2em 0;
	padding-left: 20px
}

.markdown-section blockquote p {
	font-weight: 600;
	margin-left: 0
}

.markdown-section iframe {
	margin: 1em 0
}

.markdown-section em {
	color: #6da9e2
}

.pagination-item-title:hover {
	 color: #6da9e2
}

.markdown-section code {
	border-radius: 5px;
	color: #5894ce;
	font-size: .8rem;
	margin: 0 2px;
	padding: 3px 5px;
	white-space: pre-wrap;
	font-weight: 600;
}

.markdown-section code,
.markdown-section pre {
	background-color: rgba(0, 27, 61, 0.03);
	font-family: Nova Mono, Oxygen Mono, Source Code Pro, Roboto Mono, Monaco, courier, monospace
}

.markdown-section pre {
	font-family: Nova Mono, Source Code Pro, Roboto Mono, Monaco, courier, monospace;
	-moz-osx-font-smoothing: initial;
	-webkit-font-smoothing: initial;
	line-height: 1.5rem;
	margin: 1.2em 0;
	overflow: auto;
	padding: 0 1.4rem;
	position: relative;
	word-wrap: normal;
	border-radius: 5px;
}

.token.cdata,
.token.comment,
.token.doctype,
.token.prolog {
	color: #8e908c
}

.token.namespace {
	opacity: .7
}

.token.boolean,
.token.number {
	color: #c76b29
}

.token.punctuation {
	color: #525252
}

.token.property {
	color: #c08b30
}

.token.tag {
	color: #2973b7
}

.token.string {
	color: var(--theme-color, #42b983)
}

.token.selector {
	color: #6679cc
}

.token.attr-name {
	color: #2973b7
}

.language-css .token.string,
.style .token.string,
.token.entity,
.token.url {
	color: #22a2c9
}

.token.attr-value,
.token.control,
.token.directive,
.token.unit {
	color: var(--theme-color, #42b983)
}

.token.function,
.token.keyword {
	color: #e96900
}

.token.atrule,
.token.regex,
.token.statement {
	color: #22a2c9
}

.token.placeholder,
.token.variable {
	color: #3d8fd1
}

.token.deleted {
	text-decoration: line-through
}

.token.inserted {
	border-bottom: 1px dotted #202746;
	text-decoration: none
}

.token.italic {
	font-style: italic
}

.token.bold,
.token.important {
	font-weight: 700
}

.token.important {
	color: #c94922
}

.token.entity {
	cursor: help
}

.markdown-section pre>code {
	-moz-osx-font-smoothing: initial;
	-webkit-font-smoothing: initial;
	background-color: #f8f8f8a3;
	border-radius: 0px;
	color: #5994CE;
	display: block;
	font-family: Nova Mono, Oxygen Mono, Source Code Pro, Roboto Mono, Monaco, courier, monospace;
	font-size: .85rem;
	line-height: inherit;
	margin: 0 2px;
	max-width: inherit;
	overflow: inherit;
	padding: 1.2em 5px;
	white-space: inherit
}

.markdown-section code:after,
.markdown-section code:before {
	letter-spacing: .05rem
}

code .token {
	-moz-osx-font-smoothing: initial;
	-webkit-font-smoothing: initial;
	min-height: 1.5rem;
	position: relative;
	left: auto
}

pre:after {
	color: #ccc;
	content: attr(data-lang);
	font-size: .6rem;
	font-weight: 600;
	height: 15px;
	line-height: 15px;
	padding: 5px 10px 0;
	position: absolute;
	right: 0;
	text-align: right;
	top: 0
}

```

`docs/transformers/introduction.md`:

```md
# Parsing, Enriching, Transforming

Transformers are responsible for mutating, parsing, or enriching kernel events before they hit the output sink. They offer a fair amount of flexibility to shape the structure of the event parameters. Transformers are applied sequentially to every event routed to the output sink.

You can parameterize transformers via the `yml` configuration in the `transformers` section.

```

`docs/transformers/remove.md`:

```md
# Remove

The `remove` transform drops parameters from the event. Given the following event parameters:

```
{
  'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'file_object': 'ffffa88c7ea077d0',
  'irp': 'ffffa88c746b2a88',
  'operation': 'supersede',
  'share_mask': 'rw-',
  'type': 'directory'
}
```

And the `remove` transformer configuration:

```
transformers:
  remove:
    enabled: true
    kparams:
      - irp
      - share_mask
      - file_object
```

The event will contain the following parameters:

```
{
  'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'operation': 'supersede',
  'type': 'directory'
}
```

### Configuration {docsify-ignore}

The `remove` transformer configuration is located in the `transformers.remove` section.

#### enabled

Indicates if the `remove` transformer is enabled.

**default**: `false`

#### kparams

Represents the list of parameters that are removed from the event.

```

`docs/transformers/rename.md`:

```md
# Rename

The `rename` transform rename one or more parameters. Given the following event parameters:

```
{
  'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'file_object': 'ffffa88c7ea077d0',
  'irp': 'ffffa88c746b2a88',
  'operation': 'supersede',
  'share_mask': 'rw-',
  'type': 'directory'
}
```

And the `rename` transformer configuration:

```
transformers:
  rename:
    enabled: true
    kparams:
      - old: file_name
        new: file
      - old: file_object
        new: fobj
```

The event will contain the following parameters:

```
{
  'name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'fobj': 'ffffa88c7ea077d0',
  'irp': 'ffffa88c746b2a88',
  'operation': 'supersede',
  'share_mask': 'rw-',
  'type': 'directory'
}
```

### Configuration {docsify-ignore}

The `rename` transformer configuration is located in the `transformers.rename` section.

#### enabled

Indicates if the `rename` transformer is enabled.

**default**: `false`

#### kparams

Contains the list of old/new parameter name mappings. `old` key represents the original parameter name, while `new` is the new parameter name.

```

`docs/transformers/replace.md`:

```md
# Replace

The `replace` transformer replaces all non-overlapping instances of string parameters with the specified substring. Given the following event parameters:

```
{
  'key_handle': 0,
  'key_name': 'HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\StateSeparation\Keys',
  'status': 'key not found'
}
```

And the `replace` transformer configuration:

```
replace:
  enabled: true
  replacements:
    - kparam: key_name
      old: HKEY_LOCAL_MACHINE
      new: HKLM
```

The transformer produces the following parameters:

```
{
  'key_handle': 0,
  'key_name': 'HKLM\System\CurrentControlSet\Control\StateSeparation\Keys',
  'status': 'key not found'
}
```

### Configuration {docsify-ignore}

The `replace` transformer configuration is located in the `transformers.replace` section.

#### enabled

Indicates if the `replace` transformer is enabled.

**default**: `false`

#### replacements

Contains the list of parameter replacements. For each target event parameter identified by the `kparam` key, `old` represent the substring  that will be replaced by the `new` substring.

```

`docs/transformers/tags.md`:

```md
# Tags

The `tags` transformer appends custom tags to event's metadata field.

### Configuration {docsify-ignore}

The `tags` transformer configuration is located in the `transformers.tags` section.

#### enabled

Indicates if the `tags` transformer is enabled.

**default**: `false`

#### tags

Contains the list of tags that are appended to event metadata. Values can be fetched from environment variables by enclosing them in `%`. Example:

```
tags:
  enabled: true
  tags:
    - key: env
      value: prod
    - key: drive
      value: %HOMEDRIVE%
```

```

`docs/transformers/trim.md`:

```md
# Trim

The `trim` transformer cuts off specified prefixes/suffixes from the string event parameters. Given the following event parameters:

```
{
  'key_handle': 0,
  'key_name': 'HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\StateSeparation\Keys',
  'status': 'key not found'
}
```

And the `trim` transformer configuration:

```
replace:
  enabled: true
  prefixes:
    - kparam: key_name
      trim: HKEY_LOCAL_MACHINE
  suffixes:
    - kparam: key_name
      trim: Keys
```

The transformer produces the following parameters:

```
{
  'key_handle': 0,
  'key_name': '\System\CurrentControlSet\Control\StateSeparation\',
  'status': 'key not found'
}
```

### Configuration {docsify-ignore}

The `trim` transformer configuration is located in the `transformers.trim` section.

#### enabled

Indicates if the `trim` transformer is enabled.

**default**: `false`

#### prefixes

Contains the list of parameter names and prefixes that are trimmed from the parameter's value.

#### suffixes

Contains the list of parameter names and suffixes that are trimmed from the parameter's value.

```

`docs/troubleshooting/logs.md`:

```md
# Logs

Fibratus logs various diagnostics and error messages to log files residing in the `%PROGRAM FILES%\Fibratus\Logs` directory. Logs serve as an invaluable resource for debugging or chasing down issues in Fibratus.

### Configuration {docsify-ignore}

It's possible to influence the behavior of how log file are written. The configuration options are stored in the `logging` section of the `yml` file.

#### level

Specifies the minimum allowed log level. Anything logged below this log level will not get dumped to a file or stdout stream. Possible values are `debug`, `info`, `warn`, `error`, `panic`.

**default**: `info`

#### max-age

Represents the maximum number of days to retain old log files based on the timestamp encoded in their filename. By default, all log files are retained.

**default**: `0`

#### max-backup

Specifies the maximum number of old log files to retain.

**default**: `15`

#### max-size

Specifies the maximum size in megabytes of the log file before it gets rotated.

**default**: `100`

#### formatter

Represents the log file format. Possible values are `text` or `json`. By default, Fibratus will dump the logs in JSON format.

**default**: `json`

#### path

Represents the alternative paths for storing the logs.

#### log-stdout

Indicates whether log lines are written to standard output in addition to writing them to log files.

**default**: `false`

```

`docs/troubleshooting/pprof.md`:

```md
# Profiling

[pprof](https://golang.org/pkg/net/http/pprof/) is an extremely useful profiling facility that lets you collect CPU profiles, traces and heap allocation profiles among others. With `pprof` it is easy to spot top CPU consumers or find opportunities for code optimizations.

To get the profile, you can use the `go tool pprof` tool. The pprof HTTP handlers are exposed on `localhost:8482` by default. To override the TCP port or the transport protocol, modify the `api.transport` configuration option. For example, getting the CPU profile could be accomplished with the following command:

```
$ go tool pprof http://localhost:8482/debug/pprof/profile
```

```

`docs/troubleshooting/stats.md`:

```md
# Stats

Sometimes it is useful to dive into the internal Fibratus telemetry to get various metrics about its inner workings. Fibratus exposes its internal metrics through the [expvar](https://golang.org/pkg/expvar/) interface. To explore the metrics you can execute the `fibratus stats` command.

```

`docs/yara/alerts.md`:

```md
# Alerts

Alert notifications are automatically sent via the sender specified by the `alert-via` option. The alert will contain any tag that was defined in the YARA rule. The following is an example of a YARA alert.

```
Possible malicious process, notepad.exe (8424), detected at 12 Oct 2020 18:33:58 CEST.

Rule matches
  Rule: FakeNotepad
  Namespace: default
  Meta: map[author:Usurper]
  Tags: [notepad]

Process information

Name: notepad.exe
PID: 8424
PPID: 8424
Comm: "C:\WINDOWS\system32\notepad.exe"
Cwd: C:\Users\nedo\
SID: ARCHRABBIT\nedo
Session ID: 1

Env:
  ALLUSERSPROFILE: C:\ProgramData
  APPDATA: C:\Users\nedo\AppData\Roaming
  COMPUTERNAME: ARCHRABBIT
  ComSpec: C:\WINDOWS\system32\cmd.exe
  CommonProgramFiles: C:\Program Files\Common Files
  CommonProgramFiles(x86): C:\Program Files (x86)\Common Files
  CommonProgramW6432: C:\Program Files\Common Files
  DriverData: C:\Windows\System32\Drivers\DriverData
  ERLANG_HOME: C:\Program Files\erl-23.0
  FPS_BROWSER_APP_PROFILE_STRING: Internet Explorer
  FPS_BROWSER_USER_PROFILE_STRING:  
  SESSIONNAME: Console
  SystemDrive: C:

Threads:
  ID: 888 IO prio: 2, Base prio: 8, Page prio: 5, Ustack base: f96af50000, Ustack limit: f96af3f000, Kstack base: ffff9982c4f1c000, Kstack limit: f96af3f000, Entrypoint: 7ff96cad3d60
  ID: 7084 IO prio: 2, Base prio: 8, Page prio: 5, Ustack base: f96aed0000, Ustack limit: f96aebf000, Kstack base: ffff9982c45cd000, Kstack limit: f96aebf000, Entrypoint: 7ff7a0240110
  ID: 7492 IO prio: 2, Base prio: 8, Page prio: 5, Ustack base: f96b280000, Ustack limit: f96b26f000, Kstack base: ffff9982c4fc1000, Kstack limit: f96b26f000, Entrypoint: 7ff96cad3d60
  ID: 13496 IO prio: 2, Base prio: 8, Page prio: 5, Ustack base: f96afd0000, Ustack limit: f96afbf000, Kstack base: ffff9982c4518000, Kstack limit: f96afbf000, Entrypoint: 7ff96acdb0c0

Modules:
  Name: C:\Windows\System32\notepad.exe, Size: 204800, Checksum: 0, Base address: 7ff7a0220000, Default base address: 7ff7a0220000
  Name: C:\Windows\System32\ntdll.dll, Size: 2031616, Checksum: 0, Base address: 7ff96caa0000, Default base address: 7ff96caa0000
  Name: C:\Windows\System32\kernel32.dll, Size: 729088, Checksum: 0, Base address: 7ff96ab50000, Default base address: 7ff96ab50000
  Name: C:\Program Files\AVG\Antivirus\aswhook.dll, Size: 73728, Checksum: 0, Base address: 7ff94baa0000, Default base address: 7ff94baa0000 Name: C:\Windows\System32\KernelBase.dll, Size: 2764800, Checksum: 0, Base address: 7ff969d00000, Default base address: 7ff969d00000
  Name: C:\Windows\System32\gdi32.dll, Size: 155648, Checksum: 0, Base address: 7ff96c080000, Default base address: 7ff96c080000
  Name: C:\Windows\System32\win32u.dll, Size: 135168, Checksum: 0, Base address: 7ff96ab20000, Default base address: 7ff96ab20000
  Name: C:\Windows\System32\gdi32full.dll, Size: 1654784, Checksum: 0, Base address: 7ff96a880000, Default base address: 7ff96a880000
  Name: C:\Windows\System32\msvcp_win.dll, Size: 647168, Checksum: 0, Base address: 7ff96a060000, Default base address: 7ff96a060000
  Name: C:\Windows\System32\ucrtbase.dll, Size: 1024000, Checksum: 0, Base address: 7ff96aa20000, Default base address: 7ff96aa20000
  Name: C:\Windows\System32\user32.dll, Size: 1654784, Checksum: 0, Base address: 7ff96b8b0000, Default base address: 7ff96b8b0000
  Name: C:\Windows\System32\msvcrt.dll, Size: 647168, Checksum: 0, Base address: 7ff96c880000, Default base address: 7ff96c880000
  Name: C:\Windows\System32\combase.dll, Size: 3366912, Checksum: 0, Base address: 7ff96ac40000, Default base address: 7ff96ac40000
  Name: C:\Windows\System32\rpcrt4.dll, Size: 1179648, Checksum: 0, Base address: 7ff96bc60000, Default base address: 7ff96bc60000
  Name: C:\Windows\System32\bcryptprimitives.dll, Size: 524288, Checksum: 0, Base address: 7ff969a30000, Default base address: 7ff969a30000 Name: C:\Windows\System32\SHCore.dll, Size: 692224, Checksum: 0, Base address: 7ff96b6b0000, Default base address: 7ff96b6b0000
  Name: C:\Windows\System32\advapi32.dll, Size: 667648, Checksum: 0, Base address: 7ff96bbb0000, Default base address: 7ff96bbb0000
  Name: C:\Windows\System32\sechost.dll, Size: 618496, Checksum: 0, Base address: 7ff96b610000, Default base address: 7ff96b610000

Handles:
  Num: 4 Type: Event, Name: , Object: 0x0, PID: 8424 Num: 12 Type: Event, Name: , Object: 0x0, PID: 8424
  Num: 16 Type: WaitCompletionPacket, Name: , Object: 0x0, PID: 8424
  Num: 20 Type: IoCompletion, Name: , Object: 0x0, PID: 8424
  Num: 24 Type: TpWorkerFactory, Name: , Object: 0x0, PID: 8424
  Num: 28 Type: IRTimer, Name: , Object: 0x0, PID: 8424
  Num: 32 Type: WaitCompletionPacket, Name: , Object: 0x0, PID: 8424
  Num: 36 Type: IRTimer, Name: , Object: 0x0, PID: 8424
  Num: 40 Type: WaitCompletionPacket, Name: , Object: 0x0, PID: 8424
  Num: 56 Type: Directory, Name: \KnownDlls, Object: 0x0, PID: 8424
  Num: 60 Type: Event, Name: , Object: 0x0, PID: 8424 Num: 64 Type: Event, Name: , Object: 0x0, PID: 8424
  Num: 80 Type: ALPC Port, Name: , Object: 0x0, PID: 8424 Num: 96 Type: Key, Name: HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Nls\Sorting\Versions, Object: 0x0, PID: 8424
  Num: 108 Type: Key, Name: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options, Object: 0x0, PID: 8424
  Num: 112 Type: Mutant, Name: , Object: 0x0, PID: 8424
  Num: 116 Type: Event, Name: , Object: 0x0, PID: 8424
  Num: 120 Type: IoCompletion, Name: , Object: 0x0, PID: 8424
  Num: 124 Type: WindowStation, Name: \Sessions\1\Windows\WindowStations\WinSta0, Object: 0x0, PID: 8424
  Num: 128 Type: Desktop, Name: \Default, Object: 0x0, PID: 8424
  Num: 132 Type: WindowStation, Name: \Sessions\1\Windows\WindowStations\WinSta0, Object: 0x0, PID: 8424
  Num: 144 Type: Key, Name: HKEY_LOCAL_MACHINE, Object: 0x0, PID: 8424 Num: 152 Type: Event, Name: , Object: 0x0, PID: 8424 Num: 160 Type:

Entrypoint: 20110
Image base: 140000000
Build date: 2028-08-09 02:09:05 +0000 UTC
Number of symbols: 0
Number of sections: 7
Sections:
  Name: .text, Size: 132608, Entropy: 0.000000, Md5:
  Name: .rdata, Size: 35840, Entropy: 0.000000, Md5:
  Name: .data, Size: 3072, Entropy: 0.000000, Md5:
  Name: .pdata, Size: 4096, Entropy: 0.000000, Md5:
  Name: .didat, Size: 512, Entropy: 0.000000, Md5:
  Name: .rsrc, Size: 3072, Entropy: 0.000000, Md5:
  Name: .reloc, Size: 1024, Entropy: 0.000000, Md5:
Resources:
  CompanyName: Microsoft Corporation
  FileDescription: Notepad
  FileVersion: 10.0.18362.693 (WinBuild.160101.0800)
  InternalName: Notepad
  LegalCopyright: © Microsoft Corporation. All rights reserved. 
  OriginalFilename: NOTEPAD.EXE
  ProductName: Microsoft® Windows® Operating System
  ProductVersion: 10.0.18362.693
```

##  Event metadata {docsify-ignore}

When the event triggers a specific YARA rule, its metadata is automatically decorated with the rule matches. 
The `yara.matches` tag contains the JSON array payload where each object represents the YARA rule match. For example:

```json
[
  {
    "rule": "AnglerEKredirector ",
    "namespace": "EK",
    "tags": null,
    "metas": [
      {
        "identifier": "description",
        "value": "Angler Exploit Kit Redirector"
      }
    ],
    "strings": "..."
  },
  {
    "rule": "angler_flash_uncompressed ",
    "namespace": "EK",
    "tags": [
      "exploitkit"
    ],
    "metas": [
      {
        "identifier": "description",
        "value": "Angler Exploit Kit Detection"
      }
    ],
    "strings": "..."
  }
]
```


```

`docs/yara/introduction.md`:

```md
# Pattern Matching Swiss Knife

[YARA](https://virustotal.github.io/yara/) is a prominent tool for binary pattern matching that aims to streamline and accelerate the classification of malware specimens. Fibratus interacts with the `libyara` through C bindings. The `libyara` dependency is statically linked, so no further software needs to be installed.

Fibratus/YARA difecta seeks to automate the classification of malicious processes and loadable modules by proactively scanning and alerting whenever a malicious process is started.

The YARA scanner is not enabled by default, but you can do that by modifying the `yara.enabled` key in the configuration file.

```

`docs/yara/scanning.md`:

```md
# Scanning Processes

For the YARA scanner to operate correctly, the rules have to be compiled and loaded into the engine. This is accomplished by providing file system paths with YARA rule definitions in the `rule.paths` configuration keys. The directories are scanned recursively for any `.yar` file. Alternatively, it is possible to provide the rules as inline strings directly in the Fibratus configuration file.

In addition to process scanning, Fibratus also performs file scanning for modules mapped into the process address space. You can control whether file scanning is enabled by changing the `skip-files` option.

### Configuration {docsify-ignore}

YARA scanner related options are located in the `yara` section of the configuration file.

#### enabled

Indicates if the YARA scanner is enabled. When enabled, each newly created process is scanned for pattern matches.

**default**: `false`

#### rule

The `rule` key contains various nested keys. The `paths` key identifies directories that hold the YARA rule definitions. It is also possible to link each directory to YARA namespace. The `strings` key allows for defining inline YARA rules. Example:

```
rule:
  paths:
    - path: C:\\yara-rules
      namespace: default
    - path: C:\\pdf-rules
      namespace: pdf

  strings:
    - string: rule test : tag1 { meta: author = \"Hilko Bengen\" strings: $a = \"abc\" fullword condition: $a }
      namespace: notepad
```

#### alert-via

Indicates which sender is used to transport the alert generated by YARA scanner.

**default**: `mail`

#### alert-template:

Specifies templates for the alert title and text in Go [templating](https://golang.org/pkg/text/template) language. You can specify a distinct template for both the `title` and the `text`.

Default `title` template:

```
{{if .PS }}YARA alert on process {{ .PS.Name }}{{ else }}YARA alert on file {{ .Filename }}{{ end }}
```

Default `text` template:

```
{{ if .PS }}
	Possible malicious process, {{ .PS.Name }} ({{ .PS.PID }}), detected at {{ .Timestamp }}.

	Rule matches
	{{- with .Matches }}
	{{ range . }}
		Rule: {{ .Rule }}
		Namespace: {{ .Namespace }}
		Meta: {{ .Meta }}
		Tags: {{ .Tags }}
	{{ end }}
	{{- end }}

	Process information

	Name: 		{{ .PS.Name }}
	PID:  		{{ .PS.PID }}
	PPID: 		{{ .PS.Ppid }}
	Comm:		{{ .PS.Comm }}
	Cwd:		{{ .PS.Cwd }}
	SID:		{{ .PS.SID }}
	Session ID: {{ .PS.SessionID }}
	{{ if .PS.Envs }}
	Env:
			{{- with .PS.Envs }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
	{{ end }}
	Threads:
			{{- with .PS.Threads }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	Modules:
			{{- with .PS.Modules }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ if .PS.Handles }}
	Handles:    
			{{- with .PS.Handles }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ end }}

	{{ if .PS.PE }}
	Entrypoint:  		{{ .PS.PE.EntryPoint }}
	Image base: 		{{ .PS.PE.ImageBase }}
	Build date:  		{{ .PS.PE.LinkTime }}

	Number of symbols: 	{{ .PS.PE.NumberOfSymbols }}
	Number of sections: {{ .PS.PE.NumberOfSections }}

	Sections:
			{{- with .PS.PE.Sections }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ if .PS.PE.Symbols }}
	Symbols:
			{{- with .PS.PE.Symbols }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ end }}
	{{ if .PS.PE.Imports }}
	Imports:
			{{- with .PS.PE.Imports }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ end }}
	{{ if .PS.PE.VersionResources }}
	Resources:
			{{- with .PS.PE.VersionResources }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
	{{ end }}
	{{ end }}

	{{ else }}

	Possible malicious file, {{ .Filename }}, detected at {{ .Timestamp }}.

	Rule matches
	{{ with .Matches }}
	{{ range . }}
		Rule: {{ .Rule }}
		Namespace: {{ .Namespace }}
		Meta: {{ .Meta }}
		Tags: {{ .Tags }}
	{{ end }}
	{{ end }}

	{{ end }}
```

#### fastscan

Determines when multiple matches of the same string can be avoided when not necessary.

**default**: `true`

#### scan-timeout

Specifies the timeout for the scanner. If the timeout is reached, the scan operation is cancelled.

**default**: `20s`

#### skip-files

Indicates whether file scanning is enabled. This affects scans triggered by the image loading events.

**default**: `false`

#### excluded-files

Contains the list of file names that shouldn't be scanned.

#### excluded-procs

Contains the list of process image names that shouldn't be scanned.

```

`filaments/README.md`:

```md
Fibratus incorporates a framework for painlessly extending the functionality and incorporating new features via Python scripts. 
These scripts are called **filaments**. You can also think of them as extension points with virtually endless possibilities. 
Whatever you are allowed to craft in Python, you can also implement in filaments.

Visit the [documentation](https://www.fibratus.io/#/filaments/writing) for a walkthrough on writing a filament from scratch.

### Available filaments

- `fishy_netio` alerts when atypical processes produce network requests
- `registry_persistence` surfaces registry operations that would allow a process to execute on system startup
- `top_in_packets` shows the top TCP / UDP inbound packets by IP/port tuple
- `top_keys` shows the top registry keys by number of registry operations
- `top_out_packets` shows the top TCP / UDP outbound packets by IP/port tuple
- `watch_files` watches files and directories created in the file system
- `teamviewer_remote_file_copy` identifies an executable or script file remotely downloaded via a TeamViewer transfer session

```

`filaments/fishy_netio.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Anomalous process attempts to make a network request or it accepts an inbound connection
"""

from utils.dotdict import dotdictify

__pids__ = []
__procs__ = [
    'calc.exe',
    'notepad.exe',
    'mspaint.exe',
]


def on_init():
    kfilter("kevt.category = 'net' and ps.name in (%s)" % (', '.join([f'\'{ps}\'' for ps in __procs__])))


@dotdictify
def on_next_kevent(kevent):
    print(kevent)
    notify = True if kevent.pid in __pids__ else False
    if not notify:
        emit_alert(
            f'Anomalous network I/O detected to {kevent.kparams.dip}:{kevent.kparams.dport}',
            text(kevent),
            severity='critical',
            tags=['anomalous netio']
        )
        __pids__.append(kevent.pid)


def text(kevent):
    return """
        
        Source IP:        %s
        Source port:      %s
        Destination IP:   %s  
        Destination port: %s
        Protocol:         %s

        Process ==================================================================================

        Name: %s
        Comm: %s
        Cwd:  %s
        User: %s

        """ % (
        kevent.kparams.sip,
        kevent.kparams.sport,
        kevent.kparams.dip,
        kevent.kparams.dport,
        kevent.kparams.dport_name,
        kevent.exe,
        kevent.comm,
        kevent.cwd, kevent.sid)

```

`filaments/registry_persistence.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Surfaces registry operations that would allow a process to execute on system startup
"""

import os
from utils.dotdict import dotdictify

__keys__ = [
    r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run',
    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run',
    r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices',
    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices',

    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon',
    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce',

    r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Debug',
    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Debug',

    r'HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce',

    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx\0001',
    r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend'
]

WINLOGON_KEY = r'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon'


def on_init():
    kfilter("kevt.name = 'RegSetValue'")


@dotdictify
def on_next_kevent(kevent):
    key = os.path.dirname(kevent.kparams.key_name)

    # We check if the value being modified under the Winlogon key is Userinit.
    # The Userinit registry value defines which programs are run by Winlogon
    # when a user logs in to the system. Typically, Winlogon runs Userinit.exe,
    # which in turn runs logon scripts, reestablishes network connections,
    # and then starts explorer. Attackers can prepend the userinit.exe executable
    # with their own malicious binary/script.
    if key.lower() == WINLOGON_KEY.lower() and os.path.basename(kevent.kparams.key_name) != 'Userinit':
        return

    if any(k.lower() == key.lower() for k in __keys__):
        emit_alert(
                f'Registry persistence gained via {kevent.kparams.key_name}',
                text(kevent),
                severity='medium',
                tags=['registry persistence']
        )


def text(kevent):
    return """

        Key content: %s
        Key type:    %s
        
        Process ==================================================================================
        
        Name: %s
        Comm: %s
        Cwd:  %s
        User: %s
        
        """ % (
        kevent.kparams.value,
        kevent.kparams.type,
        kevent.exe,
        kevent.comm,
        kevent.cwd, kevent.sid)

```

`filaments/teamviewer_remote_file_copy.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Identifies an executable or script file remotely downloaded via a TeamViewer transfer session
"""

from utils.dotdict import dotdictify

__author__ = 'Nedim Sabic Sabic'
__tags__ = ['Command and Control', 'TeamViewer']
__references__ = ['https://blog.menasec.net/2019/11/hunting-for-suspicious-use-of.html']
__severity__ = 'medium'

__catalog__ = {
    'framework':        'MITRE ATT&CK',
    'technique_id':     'T1105',
    'technique_name':   'Ingress Tool Transfer',
    'technique_ref':    'https://attack.mitre.org/techniques/T1105/',
    'tactic_id':        'TA0011',
    'tactic_name':      'Command and Control',
    'tactic_ref':       'https://attack.mitre.org/tactics/TA0011/'
}


extensions = [
    '.exe',
    '.dll',
    '.scr',
    '.com',
    '.bar',
    '.ps1',
    '.vbs',
    '.vbe',
    '.js',
    '.wsh',
    '.hta'
]


def on_init():
    kfilter("kevt.name = 'CreateFile' and ps.name = 'TeamViewer.exe' and file.operation = 'create' "
            "and file.extension in (%s)"
            % (', '.join([f'\'{ext}\'' for ext in extensions])))


@dotdictify
def on_next_kevent(kevent):
    emit_alert(
        f'Remote File Copy via TeamViewer',
        f'TeamViewer downloaded an executable or script file {kevent.kparams.file_name} via transfer session',
        severity=__severity__,
        tags=[__tags__]
    )

```

`filaments/top_in_packets.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows the top TCP / UDP inbound packets by IP/port tuple
"""

import collections
from utils.dotdict import dotdictify

__connections__ = collections.Counter()


def on_init():
    kfilter("kevt.name = 'Recv'")
    columns(["Source", "Count"])
    sort_by('Count')
    interval(1)


@dotdictify
def on_next_kevent(kevent):
    src = ['%s:%d' % (kevent.kparams.sip, kevent.kparams.sport)]
    __connections__.update(src)


def on_interval():
    for ip, count in __connections__.copy().items():
        add_row([ip, count])
    render_table()
```

`filaments/top_keys.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.


"""
Shows top keys by number of registry operations
"""

import collections
from utils.dotdict import dotdictify

__keys__ = collections.Counter()


def on_init():
    kfilter("kevt.category = 'registry'")
    columns(["Key", "#Ops"])
    sort_by('#Ops')
    interval(1)


@dotdictify
def on_next_kevent(kevent):
    key = kevent.kparams.key_name
    if key:
        __keys__.update((key, ))


def on_interval():
    for key, count in __keys__.copy().items():
        add_row([key, count])
    render_table()
```

`filaments/top_out_packets.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows the top TCP / UDP outbound packets by IP/port tuple
"""

import collections
from utils.dotdict import dotdictify

__connections__ = collections.Counter()


def on_init():
    kfilter("kevt.name = 'Send'")
    columns(["Destination", "Count"])
    sort_by('Count')
    interval(1)


@dotdictify
def on_next_kevent(kevent):
    dst = ['%s:%d' % (kevent.kparams.dip, kevent.kparams.dport)]
    __connections__.update(dst)


def on_interval():
    for ip, count in __connections__.copy().items():
        add_row([ip, count])
    render_table()
```

`filaments/utils/dotdict.py`:

```py
# https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
class dotdict(dict):
    """dot.notation access to dictionary attributes"""
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


def dotdictify(fn):
    """
    The decorator for converting the dict parameter to dot notation access dictionary.
    """
    def __wrap(kevent):
        kevent = dotdict(kevent)
        kevent.kparams = dotdict(kevent.kparams)
        return fn(kevent)
    return __wrap

```

`filaments/watch_files.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Watches files and directories created in the file system
"""

from utils.dotdict import dotdictify

__files__ = []


def on_init():
    kfilter("kevt.name = 'CreateFile' and file.operation = 'create'")
    columns(["Process", "File"])


@dotdictify
def on_next_kevent(kevent):
    file_name = kevent.kparams.file_name
    if file_name:
        __files__.append((kevent.exe, file_name, ))
        for f in __files__:
            add_row([f[0], f[1]])
        render_table()
```

`go.mod`:

```mod
module github.com/rabbitstack/fibratus

require (
	github.com/Masterminds/sprig/v3 v3.2.2
	github.com/Microsoft/go-winio v0.4.14
	github.com/briandowns/spinner v1.12.0
	github.com/dustin/go-humanize v1.0.0
	github.com/hashicorp/go-version v1.2.1
	github.com/hillu/go-yara/v4 v4.0.6
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/jedib0t/go-pretty/v6 v6.2.1
	github.com/lithammer/fuzzysearch v1.1.2
	github.com/magiconair/properties v1.8.1
	github.com/mitchellh/mapstructure v1.4.1
	github.com/olivere/elastic/v7 v7.0.20
	github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2
	github.com/pkg/errors v0.9.1
	github.com/qmuntal/stateless v1.6.0 // indirect
	github.com/rifflock/lfshook v0.0.0-20180920164130-b9218ef580f5
	github.com/sirupsen/logrus v1.4.1
	github.com/spf13/cobra v0.0.3
	github.com/spf13/pflag v1.0.5
	github.com/spf13/viper v1.6.2
	github.com/streadway/amqp v1.0.0
	github.com/stretchr/objx v0.2.0 // indirect
	github.com/stretchr/testify v1.5.1
	github.com/valyala/bytebufferpool v1.0.0
	github.com/valyala/gozstd v1.11.0
	github.com/xeipuuv/gojsonschema v1.2.0
	golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b
	golang.org/x/text v0.3.5
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gopkg.in/natefinch/lumberjack.v2 v2.0.0
	gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b
)

go 1.16

```

`go.sum`:

```sum
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=
github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=
github.com/Masterminds/semver/v3 v3.1.1 h1:hLg3sBzpNErnxhQtUy/mmLR2I9foDujNK030IGemrRc=
github.com/Masterminds/semver/v3 v3.1.1/go.mod h1:VPu/7SZ7ePZ3QOrcuXROw5FAcLl4a0cBrbBpGY/8hQs=
github.com/Masterminds/sprig/v3 v3.2.2 h1:17jRggJu518dr3QaafizSXOjKYp94wKfABxUmyxvxX8=
github.com/Masterminds/sprig/v3 v3.2.2/go.mod h1:UoaO7Yp8KlPnJIYWTFkMaqPUYKTfGFPhxNuwnnxkKlk=
github.com/Microsoft/go-winio v0.4.14 h1:+hMXMk01us9KgxGb7ftKQt2Xpf5hH/yky+TDA+qxleU=
github.com/Microsoft/go-winio v0.4.14/go.mod h1:qXqCSQ3Xa7+6tgxaGTIe4Kpcdsi+P8jBhyzoq1bpyYA=
github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
github.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=
github.com/aws/aws-sdk-go v1.34.13/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=
github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=
github.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=
github.com/briandowns/spinner v1.12.0 h1:72O0PzqGJb6G3KgrcIOtL/JAGGZ5ptOMCn9cUHmqsmw=
github.com/briandowns/spinner v1.12.0/go.mod h1:QOuQk7x+EaDASo80FEXwlwiA+j/PPIcX3FScO+3/ZPQ=
github.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=
github.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=
github.com/dustin/go-humanize v1.0.0 h1:VSnTsYCnlFHaM2/igO1h6X3HA71jcobQuxemgkq4zYo=
github.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
github.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=
github.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/fortytw2/leaktest v1.3.0 h1:u8491cBMTQ8ft8aeV+adlcytMZylmA5nnwwkRZjI8vw=
github.com/fortytw2/leaktest v1.3.0/go.mod h1:jDsjWgpAGjm2CA7WthBh/CdZYEPF31XHquHwclZch5g=
github.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=
github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
github.com/fzipp/gocyclo v0.3.1/go.mod h1:DJHO6AUmbdqj2ET4Z9iArSuwWgYDRryYt2wASxc7x3E=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
github.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=
github.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=
github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
github.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
github.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.5.2 h1:X2ev0eStA3AbceY54o37/0PQ/UWqKEiiO2dKL5OPaFM=
github.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=
github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1 h1:EGx4pi6eqNxGaHF6qqu48+N2wcFQ5qg5FXgOdqsJ5d8=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
github.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
github.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
github.com/hashicorp/go-version v1.2.1 h1:zEfKbn2+PDgroKdiOzqiE8rsmLqU2uwi5PB5pBJ3TkI=
github.com/hashicorp/go-version v1.2.1/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
github.com/hillu/go-yara/v4 v4.0.6 h1:2fHGPatCXQL1RgWWvPJDdaCkXAzvMx8SpVtKpqVMHDo=
github.com/hillu/go-yara/v4 v4.0.6/go.mod h1:rkb/gSAoO8qcmj+pv6fDZN4tOa3N7R+qqGlEkzT4iys=
github.com/huandu/xstrings v1.3.1 h1:4jgBlKK6tLKFvO8u5pmYjG91cqytmDCDvGh7ECVFfFs=
github.com/huandu/xstrings v1.3.1/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
github.com/imdario/mergo v0.3.11 h1:3tnifQM4i+fbajXKBHXWEH+KvNHqojZ778UH75j3bGA=
github.com/imdario/mergo v0.3.11/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
github.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NHg9XEKhtSvM=
github.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=
github.com/jedib0t/go-pretty/v6 v6.2.1 h1:O/3XdNfyWSyVLLIt1EeDhfP8AhNMjtBSh0MuZ4frg6U=
github.com/jedib0t/go-pretty/v6 v6.2.1/go.mod h1:+nE9fyyHGil+PuISTCrp7avEdo6bqoMwqZnuiK2r2a0=
github.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=
github.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=
github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/konsorten/go-windows-terminal-sequences v1.0.1 h1:mweAR1A6xJ3oS2pRaGiHgQ4OO8tzTaLawm8vnODuwDk=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/lithammer/fuzzysearch v1.1.2 h1:ePUtm14xKxbpCxozcFbIDRtvANxnVnE+RKpJUqkr2gA=
github.com/lithammer/fuzzysearch v1.1.2/go.mod h1:v6tYW/9kpfV6LNcweXdSjQsfCku/1M/oObmSox1fzP8=
github.com/magiconair/properties v1.8.1 h1:ZC2Vc7/ZFkGmsVC9KvOjumD+G5lXy2RtTKyzRKO2BQ4=
github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
github.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=
github.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=
github.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
github.com/mattn/go-isatty v0.0.8 h1:HLtExJ+uU2HOZ+wI0Tt5DtUDrx8yhUqDcp7fYERX4CE=
github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=
github.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
github.com/mitchellh/copystructure v1.0.0 h1:Laisrj+bAB6b/yJwB5Bt3ITZhGJdqmxquMKeZ+mmkFQ=
github.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=
github.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
github.com/mitchellh/mapstructure v1.4.1 h1:CpVNEelQCZBooIPDn+AR3NpivK/TIKU8bDxdASFVQag=
github.com/mitchellh/mapstructure v1.4.1/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/mitchellh/reflectwalk v1.0.0 h1:9D+8oIskB4VJBN5SFlmc27fSlIBZaov1Wpk/IfikLNY=
github.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=
github.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
github.com/olivere/elastic/v7 v7.0.20 h1:5FFpGPVJlBSlWBOdict406Y3yNTIpVpAiUvdFZeSbAo=
github.com/olivere/elastic/v7 v7.0.20/go.mod h1:Kh7iIsXIBl5qRQOBFoylCsXVTtye3keQU2Y/YbR7HD8=
github.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=
github.com/pelletier/go-toml v1.2.0 h1:T5zMGML61Wp+FlcbWjRDT7yAxhJNAiPPLOFECq181zc=
github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=
github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2 h1:JhzVVoYvbOACxoUmOs6V/G4D5nPVUW73rKvXxP4XUJc=
github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2/go.mod h1:iIss55rKnNBTvrwdmkUpLnDpZoAHvWaiq5+iMmen4AE=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/profile v1.2.1/go.mod h1:hJw3o1OdXxsrSjjVksARp5W95eeEaEfptyVZyv6JUPA=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
github.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=
github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=
github.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=
github.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
github.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=
github.com/qmuntal/stateless v1.6.0 h1:gL34XLU4ZIGGEtlhbG1IBOty5Aoa8i+XY1YiRFtdLWk=
github.com/qmuntal/stateless v1.6.0/go.mod h1:cWTwXu9ey+FxI0fHvDi1nGCtpYa8N1X2aOmoRg2RUCI=
github.com/rifflock/lfshook v0.0.0-20180920164130-b9218ef580f5 h1:mZHayPoR0lNmnHyvtYjDeq0zlVHn9K/ZXoy17ylucdo=
github.com/rifflock/lfshook v0.0.0-20180920164130-b9218ef580f5/go.mod h1:GEXHk5HgEKCvEIIrSpFI3ozzG5xOKA2DVlEX/gGnewM=
github.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=
github.com/shopspring/decimal v1.2.0 h1:abSATXmQEYyShuxI4/vyW3tV1MrKAJzCZ/0zLUXYbsQ=
github.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
github.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=
github.com/sirupsen/logrus v1.4.1 h1:GL2rEmy6nsikmW0r8opw9JIRScdMF5hA8cOYLH7In1k=
github.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/assertions v1.1.1 h1:T/YLemO5Yp7KPzS+lVtu+WsHn8yoSwTfItdAd1r3cck=
github.com/smartystreets/assertions v1.1.1/go.mod h1:tcbTF8ujkAEcZ8TElKY+i30BzYlVhC/LOxJk7iOWnoo=
github.com/smartystreets/go-aws-auth v0.0.0-20180515143844-0c1422d1fdb9/go.mod h1:SnhjPscd9TpLiy1LpzGSKh3bXCfxxXuqd9xmQJy3slM=
github.com/smartystreets/goconvey v1.6.4 h1:fv0U8FUIMPNf1L9lnHLvLhgicrIVChEkdzIKYqbNC9s=
github.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/smartystreets/gunit v1.4.2/go.mod h1:ZjM1ozSIMJlAz/ay4SG8PeKF00ckUp+zMHZXV9/bvak=
github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
github.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
github.com/spf13/afero v1.1.2 h1:m8/z1t7/fwjysjQRYbP0RD+bUIF/8tJwPdEZsI83ACI=
github.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=
github.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cast v1.3.1 h1:nFm6S0SMdyzrzcmThSipiEubIDy8WEXKNZ0UOgiRpng=
github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cobra v0.0.3 h1:ZlrZ4XsMRm04Fr5pSFxBgfND2EBVa1nLpiy1stUsX/8=
github.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=
github.com/spf13/jwalterweatherman v1.0.0 h1:XHEdyB+EcvlqZamSM4ZOMGlc93t6AcsBEu9Gc1vn7yk=
github.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=
github.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.6.2 h1:7aKfF+e8/k68gda3LOjo5RxiUqddoFxVq4BKBPrxk5E=
github.com/spf13/viper v1.6.2/go.mod h1:t3iDnF5Jlj76alVNuyFBk5oUMCvsrkbvZK0WQdfDi5k=
github.com/streadway/amqp v1.0.0 h1:kuuDrUJFZL1QYL9hUNuCxNObNzB0bV/ZG5jV3RWAQgo=
github.com/streadway/amqp v1.0.0/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=
github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/subosito/gotenv v1.2.0 h1:Slr1R9HxAlEKefgq5jn9U+DnETlIUa6HfgEzj0g5d7s=
github.com/subosito/gotenv v1.2.0/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=
github.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
github.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/gozstd v1.11.0 h1:VV6qQFt+4sBBj9OJ7eKVvsFAMy59Urcs9Lgd+o5FOw0=
github.com/valyala/gozstd v1.11.0/go.mod h1:y5Ew47GLlP37EkTB+B4s7r6A5rdaeB7ftbl9zoYiIPQ=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f h1:J9EGpcZtP0E/raorCMxlFGSTBrsSlaDGf3jU/qvAE2c=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=
github.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=
github.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
github.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=
go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
go.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
go.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=
go.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=
golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20200414173820-0848c9571904 h1:bXoxMPcSLOq08zI3/c5dEBT6lE4eh+jOh886GHrn6V8=
golang.org/x/crypto v0.0.0-20200414173820-0848c9571904/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180816055513-1c9583448a9c/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b h1:ag/x1USPSsqHud38I9BAC88qdNLDHHtQ4mlgQIZPPNA=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.5 h1:i6eZZ+zk0SOf0xgBpEpPD18qWcJda6q1sxt3S0kzyUQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
google.golang.org/grpc v1.21.0/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df h1:n7WqCuqOuCbNr617RXOY0AWRXxgwEyPp2z+p0+hgMuE=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df/go.mod h1:LRQQ+SO6ZHR7tOkpBDuZnXENFzX8qRjMDMyPD6BRkCw=
gopkg.in/ini.v1 v1.51.0 h1:AQvPpx3LzTDM0AjnIRlVFwFFGC+npRopjZxLJj6gdno=
gopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/natefinch/lumberjack.v2 v2.0.0 h1:1Lc07Kr7qY4U2YPouBjpCLxpiyxIVoxqXgkXLknAOE8=
gopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=
gopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=
gopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=
gopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b h1:h8qDotaEPuJATrMmW04NCwg7v22aHH28wwpauUhK9Oo=
gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=

```

`make.bat`:

```bat
:: Copyright 2019-2020 by Nedim Sabic Sabic
:: https://www.fibratus.io
:: All Rights Reserved.
::
:: Licensed under the Apache License, Version 2.0 (the "License"); you may
:: not use this file except in compliance with the License. You may obtain
:: a copy of the License at
::
:: http://www.apache.org/licenses/LICENSE-2.0

@echo off
SetLocal EnableDelayedExpansion

set PYTHON_VER=3.7.9
set PYTHON_URL=https://www.python.org/ftp/python/%PYTHON_VER%/python-%PYTHON_VER%-embed-amd64.zip

set GOBIN=%USERPROFILE%\go\bin

set GOTEST=go test -timeout=10m -v -gcflags=all=-d=checkptr=0
set GOFMT=gofmt -e -s -l -w
set GOLINT=%GOBIN%\golangci-lint

FOR /F "tokens=* USEBACKQ" %%F IN (`powershell -Command get-date -format "{dd-MM-yyyy.HH:mm:ss}"`) DO (
    SET BUILD_DATE=%%F
)
set LDFLAGS="-s -w -X github.com/rabbitstack/fibratus/cmd/fibratus/app.version=%VERSION% -X github.com/rabbitstack/fibratus/cmd/fibratus/app.commit=%COMMIT% -X github.com/rabbitstack/fibratus/cmd/fibratus/app.date=%BUILD_DATE%"

:: In case you want to avoid CGO overhead or don't need a specific feature, try tweaking the following compilation tags:
::
:: kcap: enables capture support
:: filament: enables running filaments and thus interacting with the CPython interpreter
:: yara: activates Yara process scanning
if NOT DEFINED TAGS (
    set TAGS=""
)

set PKGS=
:: Get the list of packages that we'll use to run tests/linter
for /f %%p in ('go list .\...') do call set "PKGS=%%PKGS%% %%p"


if "%~1"=="build" goto build
if "%~1"=="test" goto test
if "%~1"=="lint" goto lint
if "%~1"=="fmt" goto fmt
if "%~1"=="clean" goto clean
if "%~1"=="pkg" goto pkg
if "%~1"=="pkg-slim" goto pkg-slim
if "%~1"=="deps" goto deps
if "%~1"=="rsrc" goto rsrc
if "%~1"=="mc" goto mc

:build
:: set PKG_CONFIG_PATH=pkg-config
go build -ldflags %LDFLAGS% -tags %TAGS% -o .\cmd\fibratus\fibratus.exe .\cmd\fibratus
if errorlevel 1 goto fail
goto :EOF

:test
%GOTEST% -tags %TAGS% %PKGS%
if errorlevel 1 goto fail
goto :EOF

:lint
%GOLINT% run
if errorlevel 1 goto fail
goto :EOF

:fmt
%GOFMT% pkg cmd
goto :EOF

:deps
go get -v -u github.com/golangci/golangci-lint/cmd/golangci-lint@v1.34.1
goto :EOF

:rsrc
set RC_VER=%VERSION:.=,%
windres --define RC_VER=%RC_VER% --define VER=%VERSION% -i cmd\fibratus\fibratus.rc -O coff -o cmd\fibratus\fibratus.syso
if errorlevel 1 goto fail
goto :EOF

:mc
windmc -r pkg/outputs/eventlog/mc pkg/outputs/eventlog/mc/fibratus.mc
windres -O coff -r -fo pkg/outputs/eventlog/mc/fibratus.res pkg/outputs/eventlog/mc/fibratus.rc
:: link the resulting resource object
gcc pkg/outputs/eventlog/mc/fibratus.res -o pkg/outputs/eventlog/mc/fibratus.dll -s -shared "-Wl,--subsystem,windows"
if errorlevel 1 goto fail
goto :EOF

:pkg
set RELEASE_DIR=.\build\msi\fibratus-%VERSION%

:: create the dir structure
mkdir "%~dp0\%RELEASE_DIR%"
mkdir "%~dp0\%RELEASE_DIR%\Bin"
mkdir "%~dp0\%RELEASE_DIR%\Config"
mkdir "%~dp0\%RELEASE_DIR%\Config\Rules"
mkdir "%~dp0\%RELEASE_DIR%\Python"
mkdir "%~dp0\%RELEASE_DIR%\Filaments"

echo "Copying artifacts..."
:: copy artifacts
copy /y ".\cmd\fibratus\fibratus.exe" "%RELEASE_DIR%\Bin"
copy /y ".\configs\fibratus.yml" "%RELEASE_DIR%\Config\fibratus.yml"
copy /y ".\pkg\outputs\eventlog\mc\fibratus.dll" "%RELEASE_DIR%\fibratus.dll"

robocopy ".\filaments" "%RELEASE_DIR%\Filaments" /E /S /XF *.md /XD __pycache__ .idea
robocopy ".\configs\rules" "%RELEASE_DIR%\Config\Rules" /E /S

:: download the embedded Python distribution
echo Downloading Python %PYTHON_VER%...
powershell -Command "Invoke-WebRequest %PYTHON_URL% -OutFile %RELEASE_DIR%\python.zip"

echo Extracting Python distribution...
powershell -Command "Expand-Archive %RELEASE_DIR%\python.zip -DestinationPath %RELEASE_DIR%\python"

:: Bring in the pip
:: https://stackoverflow.com/questions/42666121/pip-with-embedded-python
powershell -Command "(Get-Content -path %RELEASE_DIR%\python\python*._pth -Raw) -replace '#import','import' | Set-Content -Path %RELEASE_DIR%\python\python*._pth"
echo Downloading get-pip.py...
powershell -Command "Invoke-WebRequest https://bootstrap.pypa.io/get-pip.py -OutFile %RELEASE_DIR%\get-pip.py"
%RELEASE_DIR%\python\python.exe %RELEASE_DIR%\get-pip.py

rm %RELEASE_DIR%\get-pip.py
rm %RELEASE_DIR%\python.zip

:: Move Python DLLs and other dependencies to the same directory where the fibratus binary
:: is located to advise Windows on the DLL search path strategy.
move %RELEASE_DIR%\python\*.dll %RELEASE_DIR%\bin

:: Rename libcrypto-1_1.dll to libcrypto-1_1-x64.dll. Strangely, the latter
:: is the DLL name required by linker.
ren "%RELEASE_DIR%\bin\libcrypto-1_1.dll" "libcrypto-1_1-x64.dll"

echo "Building MSI package..."
heat dir %RELEASE_DIR%\ -cg Fibratus -dr INSTALLDIR -suid -gg -sfrag -srd -var var.FibratusDir -out build/msi/components.wxs || exit /b
:: To target win64 builds
powershell -Command "(Get-Content -path build/msi/components.wxs) -replace 'Component ','Component Win64=\"yes\" ' | Set-Content -Path build/msi/components.wxs" || exit /b
candle build/msi/components.wxs -dFibratusDir=%RELEASE_DIR% -out build/msi/components.wixobj || exit /b
candle build/msi/fibratus.wxs -ext WiXUtilExtension -dFibratusDir=%RELEASE_DIR% -out build/msi/fibratus.wixobj || exit /b
light build/msi/fibratus.wixobj build/msi/components.wixobj -out build/msi/fibratus-%VERSION%-amd64.msi -ext WixUIExtension -ext WiXUtilExtension

if errorlevel 1 goto fail

goto :EOF

:pkg-slim
set RELEASE_DIR=.\build\msi\fibratus-%VERSION%-slim

:: create the dir structure
mkdir "%~dp0\%RELEASE_DIR%"
mkdir "%~dp0\%RELEASE_DIR%\Bin"
mkdir "%~dp0\%RELEASE_DIR%\Config"
mkdir "%~dp0\%RELEASE_DIR%\Config\Rules"

echo "Copying artifacts..."
:: copy artifacts
copy /y ".\cmd\fibratus\fibratus.exe" "%RELEASE_DIR%\Bin"
copy /y ".\configs\fibratus.yml" "%RELEASE_DIR%\Config\fibratus.yml"
copy /y ".\pkg\outputs\eventlog\mc\fibratus.dll" "%RELEASE_DIR%\fibratus.dll"

robocopy ".\configs\rules" "%RELEASE_DIR%\Config\Rules" /E /S

echo "Building MSI package..."
heat dir %RELEASE_DIR%\ -cg Fibratus -dr INSTALLDIR -suid -gg -sfrag -srd -var var.FibratusDir -out build/msi/components.wxs || exit /b
:: To target win64 builds
powershell -Command "(Get-Content -path build/msi/components.wxs) -replace 'Component ','Component Win64=\"yes\" ' | Set-Content -Path build/msi/components.wxs" || exit /b
candle build/msi/components.wxs -dFibratusDir=%RELEASE_DIR% -out build/msi/components.wixobj || exit /b
candle build/msi/fibratus.wxs -ext WiXUtilExtension -dFibratusDir=%RELEASE_DIR% -out build/msi/fibratus.wixobj || exit /b
light build/msi/fibratus.wixobj build/msi/components.wixobj -out build/msi/fibratus-%VERSION%-slim-amd64.msi -ext WixUIExtension -ext WiXUtilExtension

if errorlevel 1 goto fail

goto :EOF

:clean
rm cmd\fibratus\fibratus.exe
goto :EOF

:fail
echo Failed with error #%errorlevel%.
exit /b %errorlevel%


```

`pkg-config/python-37.pc`:

```pc
prefix=C:/Python37
exec_prefix=${prefix}
libdir=${exec_prefix}/libs
includedir=${prefix}/include

Name: Python
Description: Python library
Requires:
Version: 3.7
Libs: -L${libdir} -lpython37
Cflags: -I${includedir} -DMS_WIN64
```

`pkg/aggregator/aggregator.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"errors"
	"expvar"
	"time"

	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	log "github.com/sirupsen/logrus"

	// initialize outputs
	_ "github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/console"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/elasticsearch"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/eventlog"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/http"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/null"

	// initialize alert senders
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/slack"

	// initialize transformers
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/remove"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/replace"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/tags"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/trim"
)

var (
	// keventsDequeued counts the number of dequeued events
	keventsDequeued = expvar.NewInt("kstream.kevents.dequeued")
	// flushesCount computes the total count of aggregator flushes
	flushesCount = expvar.NewInt("aggregator.flushes.count")
	// batchEvents represents the overall number of processed batches
	batchEvents = expvar.NewInt("aggregator.batch.events")
	// transformerErrors is the count of transformers errors occurred during event processing
	transformerErrors = expvar.NewMap("aggregator.transformer.errors")
	/// keventErrors is the number of kernel event errors
	keventErrors = expvar.NewInt("aggregator.kevent.errors")
)

// BufferedAggregator collects events from the inbound channel and produces batches on regular intervals. The batches
// are pushed to the work queue from which load-balanced configured workers consume the batches and publish to the outputs.
type BufferedAggregator struct {
	kevtsc  chan *kevent.Kevent
	errsc   chan error
	stop    chan struct{}
	flusher *time.Ticker
	// queue of inbound kernel events
	kevts []*kevent.Kevent
	// work queue that forwarder passes to outputs
	wq         queue
	submitter  *submitter
	transforms []transformers.Transformer
	c          Config
}

// NewBuffered creates a new instance of the event aggregator.
func NewBuffered(
	kevents chan *kevent.Kevent,
	errs chan error,
	config Config,
	outputConfig outputs.Config,
	transformerConfigs []transformers.Config,
	alertsenderConfigs []alertsender.Config,
) (*BufferedAggregator, error) {
	flushInterval := config.FlushPeriod
	if flushInterval < time.Millisecond*250 {
		flushInterval = time.Millisecond * 250
	}
	agg := &BufferedAggregator{
		kevtsc:  kevents,
		kevts:   make([]*kevent.Kevent, 0),
		errsc:   errs,
		stop:    make(chan struct{}, 1),
		flusher: time.NewTicker(flushInterval),
		wq:      make(chan *kevent.Batch),
		c:       config,
	}

	var err error
	agg.submitter, err = newSubmitter(agg.wq, outputConfig)
	if err != nil {
		return nil, err
	}
	agg.transforms, err = transformers.LoadAll(transformerConfigs)
	if err != nil {
		return nil, err
	}

	err = alertsender.LoadAll(alertsenderConfigs)
	if err != nil {
		return nil, err
	}

	go agg.run()

	return agg, nil
}

// Stop flushes pending event batches and instructs the aggregator to stop processing events.
func (agg *BufferedAggregator) Stop() error {
	agg.stop <- struct{}{}

	// flush enqueued events
	b := kevent.NewBatch(agg.kevts...)
	if b.Len() > 0 {
		done := make(chan struct{}, 1)
		go func() {
			agg.wq <- b
			done <- struct{}{}
		}()

		select {
		case <-done:
			close(agg.wq)
		case <-time.After(agg.c.FlushTimeout):
			return errors.New("fail to flush events after stop timed out")
		}
	}

	// sleep a bit before closing the clients
	time.Sleep(time.Millisecond * 150)

	err := agg.submitter.shutdown()
	if err != nil {
		return err
	}

	return nil
}

// run starts the aggregator loop. The aggregator receives kernel event stream from the upstream channel, buffers
// them to intermediate queue and dispatches batches to downstream worker queue.
func (agg *BufferedAggregator) run() {
	for {
		select {
		case <-agg.stop:
			agg.flusher.Stop()
			return
		case <-agg.flusher.C:
			if len(agg.kevts) == 0 {
				continue
			}
			b := kevent.NewBatch(agg.kevts...)
			l := b.Len()
			batchEvents.Add(l)
			// push the batch to the work queue
			if l > 0 {
				agg.wq <- b
			}
			flushesCount.Add(1)
			// clear the queue
			agg.kevts = nil
		case kevt := <-agg.kevtsc:
			for _, transformer := range agg.transforms {
				if transformer == nil {
					continue
				}
				err := transformer.Transform(kevt)
				if err != nil {
					log.Warnf("transformer error occurred: %v", err)
					transformerErrors.Add(err.Error(), 1)
				}
			}
			// push the event to the queue
			agg.kevts = append(agg.kevts, kevt)
			keventsDequeued.Add(1)
		case err := <-agg.errsc:
			keventErrors.Add(1)
			log.Errorf("aggregator dispatch failure: %v", err)
		}
	}
}

```

`pkg/aggregator/aggregator_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/outputs/console"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
	"time"
)

func TestNewBufferedAggregator(t *testing.T) {
	keventsc := make(chan *kevent.Kevent, 20)
	errsc := make(chan error, 1)
	agg, err := NewBuffered(
		keventsc,
		errsc,
		Config{FlushPeriod: time.Millisecond * 200},
		outputs.Config{Type: outputs.Console, Output: console.Config{Format: "pretty"}},
		nil,
		nil,
	)
	require.NoError(t, err)
	require.NotNil(t, agg)

	for i := 0; i < 4; i++ {
		kevt := &kevent.Kevent{
			Type: ktypes.SendTCPv4,
			Tid:  2484,
			PID:  859,
			Kparams: kevent.Kparams{
				kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
				kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
				kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
				kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
		}
		keventsc <- kevt
	}
	<-time.After(time.Millisecond * 275)
	assert.Equal(t, int64(4), batchEvents.Value())

	for i := 0; i < 2; i++ {
		kevt := &kevent.Kevent{
			Type: ktypes.SendTCPv4,
			Tid:  2484,
			PID:  859,
			Seq:  uint64(i),
			Kparams: kevent.Kparams{
				kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
				kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
				kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
				kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
		}
		keventsc <- kevt
	}
	<-time.After(time.Millisecond * 260)
	assert.Equal(t, int64(6), batchEvents.Value())
	assert.Equal(t, int64(2), flushesCount.Value())
}

```

`pkg/aggregator/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"time"
)

const (
	flushPeriod  = "aggregator.flush-period"
	flushTimeout = "aggregator.flush-timeout"
)

// Config contains aggregator-specific configuration tweaks.
type Config struct {
	// FlushPeriod determines the period for flushing batches to outputs.
	FlushPeriod time.Duration `json:"aggregator.flush-period" yaml:"aggregator.flush-period"`
	// FlushTimeout represents the max time to wait before announcing failed flushing of enqueued events
	FlushTimeout time.Duration `json:"aggregator.flush-timeout" yaml:"aggregator.flush-timeout"`
}

// AddFlags registers persistent aggregator flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Duration(flushPeriod, time.Millisecond*200, "Determines the period for flushing batches to outputs")
	flags.Duration(flushTimeout, time.Second*4, "Represents the max time to wait before announcing failed flushing of enqueued events on aggregator shutdown")
}

// InitFromViper initializes aggregator flags from viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.FlushPeriod = v.GetDuration(flushPeriod)
	c.FlushTimeout = v.GetDuration(flushTimeout)
}

```

`pkg/aggregator/submitter.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

// queue defines the type alias for the batch worker queue
type queue chan *kevent.Batch

// submitter initializes a group of load balanced output producers.
type submitter struct {
	wq      queue
	workers []*worker
}

func newSubmitter(wq queue, outputConfig outputs.Config) (*submitter, error) {
	output, err := outputs.Load(outputConfig.Type, outputConfig)
	if err != nil {
		return nil, err
	}
	clients := output.Clients
	workers := make([]*worker, len(clients))

	for i, client := range clients {
		workers[i] = initWorker(wq, client)
	}

	return &submitter{wq: wq, workers: workers}, nil
}

func (s *submitter) shutdown() error {
	for _, w := range s.workers {
		if err := w.close(); err != nil {
			return err
		}
	}
	return nil
}

```

`pkg/aggregator/transformers/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package transformers

import "fmt"

// ErrInvalidConfig signals an invalid configuration input
var ErrInvalidConfig = func(name Type) error { return fmt.Errorf("invalid config for %q transformer", name) }

// Config acts as a container for the transformer configuration structures.
type Config struct {
	Type        Type
	Transformer interface{}
}

```

`pkg/aggregator/transformers/remove/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package remove

import "github.com/spf13/pflag"

const (
	kpars   = "transformers.remove.kparams"
	enabled = "transformers.remove.enabled"
)

// Config stores the configuration for the remove transformer.
type Config struct {
	// Kparams is the list of parameters that are dropped from the event.
	Kparams []string `mapstructure:"kparams"`
	// Enabled indicates whether this transformer is enabled
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.StringSlice(kpars, []string{}, "A list of comma-separated parameters that will be removed from the event")
	flags.Bool(enabled, false, "Indicates if remove transformer is enabled")
}

```

`pkg/aggregator/transformers/remove/remove.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package remove

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

var removedCount = expvar.NewInt("transformers.removed.params")

//remove transformer deletes kparams that are given in the list.
type remove struct {
	c Config
}

func init() {
	transformers.Register(transformers.Remove, initRemoveTransformer)
}

func initRemoveTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Remove)
	}
	return &remove{c: cfg}, nil
}

func (r remove) Transform(kevt *kevent.Kevent) error {
	for _, kpar := range r.c.Kparams {
		delete(kevt.Kparams, kpar)
		removedCount.Add(1)
	}
	return nil
}

```

`pkg/aggregator/transformers/remove/remove_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package remove

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestTransform(t *testing.T) {
	kevt := &kevent.Kevent{
		Type: ktypes.SendTCPv4,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
	}
	assert.Len(t, kevt.Kparams, 4)

	transf, err := transformers.Load(transformers.Config{Type: transformers.Remove, Transformer: Config{Kparams: []string{"dip", "sport", "foo"}}})
	require.NoError(t, err)
	err = transf.Transform(kevt)

	require.NoError(t, err)

	assert.Len(t, kevt.Kparams, 2)
}

```

`pkg/aggregator/transformers/rename/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rename

import "github.com/spf13/pflag"

const (
	enabled = "transformers.rename.enabled"
)

// Rename describes the configuration for the old/new parameter name.
type Rename struct {
	Old string `mapstructure:"old"`
	New string `mapstructure:"new"`
}

// Config stores the configuration of the rename transformer.
type Config struct {
	// Kparams is the list of parameters that will be renamed.
	Kparams []Rename
	// Enabled indicates whether this transformer is enabled.
	Enabled bool
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the rename transformer is enabled")
}

```

`pkg/aggregator/transformers/rename/rename.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rename

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

// rename as it name implies, it renames a sequence of kparams to their new names.
type rename struct {
	c Config
}

func init() {
	transformers.Register(transformers.Rename, initRenameTransformer)
}

func initRenameTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Rename)
	}
	return &rename{c: cfg}, nil
}

func (r rename) Transform(kevt *kevent.Kevent) error {
	for _, par := range r.c.Kparams {
		kpar, ok := kevt.Kparams[par.Old]
		if !ok {
			continue
		}
		kevt.Kparams.Remove(par.Old)
		kpar.Name = par.New
		kevt.Kparams[par.New] = kpar
	}
	return nil
}

```

`pkg/aggregator/transformers/rename/rename_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rename

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestTransform(t *testing.T) {
	kevt := &kevent.Kevent{
		Type: ktypes.SendTCPv4,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[kevent.MetadataKey]string),
	}

	transf, err := transformers.Load(transformers.Config{Type: transformers.Rename, Transformer: Config{Kparams: []Rename{{Old: "dport", New: "dstport"}, {Old: "sip", New: "srcip"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(kevt))

	assert.True(t, kevt.Kparams.Contains("dstport"))
	assert.False(t, kevt.Kparams.Contains("dport"))
	assert.True(t, kevt.Kparams.Contains("srcip"))
	assert.False(t, kevt.Kparams.Contains("sip"))
}

```

`pkg/aggregator/transformers/replace/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replace

import "github.com/spf13/pflag"

const (
	enabled = "transformers.replace.enabled"
)

// Config stores the configuration for the replace transformer
type Config struct {
	// Replacements describes a list of replacements that are applied on the kparam.
	Replacements []Replacement `mapstructure:"replacements"`
	// Enabled indicates whether this transformer is enabled
	Enabled bool `mapstructure:"enabled"`
}

// Replacement defines the string replacement config for a specific kparam.
type Replacement struct {
	Kpar string `mapstructure:"kparam"`
	Old  string `mapstructure:"old"`
	New  string `mapstructure:"new"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the replace transformer is enabled")
}

```

`pkg/aggregator/transformers/replace/replace.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replace

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"strings"
)

var replaceCount = expvar.NewInt("transformers.replaced.params")

// replace applies string substitutions in kpar values.
type replace struct {
	c Config
}

func init() {
	transformers.Register(transformers.Replace, initReplaceTransformer)
}

func initReplaceTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Replace)
	}
	return &replace{c: cfg}, nil
}

func (r replace) Transform(kevt *kevent.Kevent) error {
	for _, repl := range r.c.Replacements {
		kpar := kevt.Kparams.Find(repl.Kpar)

		if kpar == nil {
			continue
		}
		if kpar.Type != kparams.AnsiString && kpar.Type != kparams.UnicodeString {
			continue
		}

		val, ok := kpar.Value.(string)
		if !ok {
			continue
		}
		kpar.Value = strings.ReplaceAll(val, repl.Old, repl.New)

		replaceCount.Add(1)
	}
	return nil
}

```

`pkg/aggregator/transformers/replace/replace_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replace

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTransform(t *testing.T) {
	kevt := &kevent.Kevent{
		Type: ktypes.RegCreateKey,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.RegKeyName:   {Name: kparams.RegKeyName, Type: kparams.UnicodeString, Value: `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`},
			kparams.RegKeyHandle: {Name: kparams.RegKeyHandle, Type: kparams.HexInt64, Value: kparams.NewHex(uint64(18446666033449935464))},
		},
	}

	transf, err := transformers.Load(transformers.Config{Type: transformers.Replace, Transformer: Config{Replacements: []Replacement{{Kpar: "key_name", Old: "HKEY_LOCAL_MACHINE", New: "HKLM"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(kevt))

	keyName, _ := kevt.Kparams.GetString(kparams.RegKeyName)

	assert.Equal(t, `HKLM\SYSTEM\Setup\Pid`, keyName)
}

```

`pkg/aggregator/transformers/tags/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tags

import (
	"github.com/spf13/pflag"
)

const (
	enabled = "transformers.tags.enabled"
)

// Tag represents a distinct tag with its key and value attached.
type Tag struct {
	Key   string `mapstructure:"key"`
	Value string `mapstructure:"value"`
}

// Config stores the configuration for the tags transformer
type Config struct {
	// Tags is the sequence of key/value pairs that are added to the event
	Tags []Tag `mapstructure:"tags"`
	// Enabled indicates whether this transformer is enabled
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the tags transformer is enabled")
}

```

`pkg/aggregator/transformers/tags/tags.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tags

import (
	"os"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

// tags transformer appends tags to the event's metadata. It is capable of adding literal values as well as
// tags that are stored in environment variables.
type tags struct {
	tags map[string]string
}

func init() {
	transformers.Register(transformers.Tags, initTagsTransformer)
}

func initTagsTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Tags)
	}

	ktags := make(map[string]string)

	for _, tag := range cfg.Tags {
		// if the value is enclosed within % symbols this means
		// we have to expand it from the environ variable
		key, val := tag.Key, tag.Value
		if len(val) == 0 {
			continue
		}
		if val[0] == '%' && val[len(val)-1] == '%' {
			ktags[key] = os.Getenv(strings.ReplaceAll(val, "%", ""))
			continue
		}
		ktags[key] = val
	}

	return &tags{tags: ktags}, nil
}

func (t tags) Transform(kevt *kevent.Kevent) error {
	for k, v := range t.tags {
		kevt.AddMeta(kevent.MetadataKey(k), v)
	}
	return nil
}

```

`pkg/aggregator/transformers/tags/tags_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tags

import (
	"net"
	"os"
	"testing"

	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTransform(t *testing.T) {
	kevt := &kevent.Kevent{
		Type: ktypes.SendTCPv4,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[kevent.MetadataKey]string),
	}
	require.NoError(t, os.Setenv("NODENAME", "archbunny"))
	transf, err := transformers.Load(transformers.Config{Type: transformers.Tags, Transformer: Config{Tags: []Tag{{Key: "env", Value: "staging"}, {Key: "zone", Value: "dmz"}, {Key: "node", Value: "%NODENAME%"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(kevt))

	require.Len(t, kevt.Metadata, 3)

	assert.Equal(t, "staging", kevt.Metadata["env"])
	assert.Equal(t, "dmz", kevt.Metadata["zone"])
	assert.Equal(t, "archbunny", kevt.Metadata["node"])
}

```

`pkg/aggregator/transformers/transformer.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package transformers

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

var transformers = map[Type]Factory{}

// Factory defines the function for transformer factories
type Factory func(config Config) (Transformer, error)

// Type defines the alias for the transformer types
type Type uint8

const (
	// Remove represents the remove transformer type. This transformer deletes the given list of parameters from the event.
	Remove Type = iota
	// Rename represents the rename transformer type. It renames a sequence of kparam from old to new names.
	Rename
	// Replace represents the replace tranformer type. It applies string replacements on specific kparams.
	Replace
	// Trim represents the trim transformer type that that removes suffix/prefix from string kparams.
	Trim
	// Tags represents the tags transformer type. This transformer appends tags to the event's metadata.
	Tags
)

// String returns the type human-readable name.
func (typ Type) String() string {
	switch typ {
	case Remove:
		return "remove"
	case Rename:
		return "rename"
	case Replace:
		return "replace"
	case Trim:
		return "trim"
	case Tags:
		return "tags"
	default:
		return "unknown"
	}
}

// Register registers a singleton instance of the provided transformer.
func Register(typ Type, factory Factory) {
	if _, ok := transformers[typ]; ok {
		panic(fmt.Sprintf("output %q is already registered", typ))
	}
	transformers[typ] = factory
}

// LoadAll loads all transformers from the configuration inputs.
func LoadAll(configs []Config) ([]Transformer, error) {
	transformers := make([]Transformer, len(configs))
	for i, config := range configs {
		transformer, err := Load(config)
		if err != nil {
			return nil, err
		}
		transformers[i] = transformer
	}
	return transformers, nil
}

// Load loads a single transformer from the configuration.
func Load(config Config) (Transformer, error) {
	typ := config.Type
	factory := transformers[typ]
	if factory == nil {
		return nil, fmt.Errorf("%q transformer not availaible in the factory", typ)
	}
	return factory(config)
}

// Transformer is the minimal interface all transformers have to satisfy.
type Transformer interface {
	Transform(*kevent.Kevent) error
}

```

`pkg/aggregator/transformers/trim/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package trim

import "github.com/spf13/pflag"

const (
	enabled = "transformers.trim.enabled"
)

// Trim defines the trim configuration for a single event parameter.
type Trim struct {
	Name string `mapstructure:"kparam"`
	Trim string `mapstructure:"trim"`
}

// Config stores the configuration for the trim transformer.
type Config struct {
	// Prefixes contains the mapping between distinct kparam names and the prefixes that will get trimmed from their values.
	Prefixes []Trim `mapstructure:"prefixes"`
	// Suffixes contains the mapping between distinct kparam names and the suffixes that will get trimmed from their values.
	Suffixes []Trim `mapstructure:"suffixes"`
	// Enabled determines whether trim transformer is enabled or disabled.
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the trim transformer is enabled")
}

```

`pkg/aggregator/transformers/trim/trim.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package trim

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"strings"
)

// trim transformer trims suffixes/prefixes from kpar values.
type trim struct {
	c Config
}

func init() {
	transformers.Register(transformers.Trim, initTrimTransformer)
}

func initTrimTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Trim)
	}
	return &trim{c: cfg}, nil
}

func (r trim) Transform(kevt *kevent.Kevent) error {
	for _, kpar := range kevt.Kparams {
		if kpar.Type != kparams.AnsiString && kpar.Type != kparams.UnicodeString {
			continue
		}
		// trim prefixes
		for _, par := range r.c.Prefixes {
			if kpar.Name != par.Name {
				continue
			}
			s, ok := kpar.Value.(string)
			if !ok {
				continue
			}
			kpar.Value = strings.TrimPrefix(s, par.Trim)
		}
		// trim suffixes
		for _, par := range r.c.Suffixes {
			if kpar.Name != par.Name {
				continue
			}
			s, ok := kpar.Value.(string)
			if !ok {
				continue
			}
			kpar.Value = strings.TrimSuffix(s, par.Trim)
		}
	}
	return nil
}

```

`pkg/aggregator/transformers/trim/trim_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package trim

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestTransform(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "overwriteif"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
			kparams.KstackLimit:   {Name: kparams.KstackLimit, Type: kparams.HexInt8, Value: kparams.Hex("ff")},
			kparams.StartTime:     {Name: kparams.StartTime, Type: kparams.Time, Value: time.Now()},
			kparams.ProcessID:     {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(1204)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barz"},
	}

	transf, err := transformers.Load(transformers.Config{Type: transformers.Trim, Transformer: Config{Prefixes: []Trim{{Name: "file_name", Trim: "\\Device"}}, Suffixes: []Trim{{Name: "operation", Trim: "if"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(kevt))
	filename, _ := kevt.Kparams.GetString(kparams.FileName)
	dispo, _ := kevt.Kparams.GetString(kparams.FileOperation)

	assert.Equal(t, "\\HarddiskVolume2\\Windows\\system32\\user32.dll", filename)
	assert.Equal(t, "overwrite", dispo)
}

```

`pkg/aggregator/worker.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	log "github.com/sirupsen/logrus"
	"time"
)

// maxBackoff determines the maximum exponential backoff wait time before reconnecting the client
const maxBackoff = time.Minute

var clientPublishErrors = expvar.NewInt("aggregator.worker.client.publish.errors")

type worker struct {
	qu      queue
	client  outputs.Client
	backoff time.Duration
}

func initWorker(q queue, client outputs.Client) *worker {
	w := &worker{qu: q, client: client, backoff: time.Second * 2}
	go w.run()
	return w
}

func (w *worker) run() {
	for {
		err := w.client.Connect()
		if err != nil {
			// schedule an exponential backoff reconnect strategy for the client
			w.backoff *= 2
			log.Warnf("fail to connect the client: %v. Reconnecting in %v...", err, w.backoff)
			if w.backoff > maxBackoff {
				w.backoff = maxBackoff
			}
			<-time.After(w.backoff)
			continue
		}
		break
	}
	for batch := range w.qu {
		if err := w.client.Publish(batch); err != nil {
			clientPublishErrors.Add(1)
			log.Warnf("couldn't publish batch to client: %v", err)
		}
	}
}

func (w *worker) close() error {
	return w.client.Close()
}

```

`pkg/aggregator/worker_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

type httpClient struct {
	url               string
	published         int
	expectedPublished int
	wait              chan struct{}
}

func (c *httpClient) Connect() error {
	//nolint:noctx
	res, err := http.Get(c.url + "/connect")
	if err != nil {
		return err
	}
	defer func() {
		_ = res.Body.Close()
	}()
	if res.StatusCode != http.StatusOK {
		return err
	}
	return nil
}

func (c *httpClient) Close() error { return nil }

func (c *httpClient) Publish(b *kevent.Batch) error {
	//nolint:noctx
	res, err := http.Post(c.url+"/publish", "application/json", nil)
	if err != nil {
		return err
	}
	defer func() {
		_ = res.Body.Close()
	}()
	c.published++
	if c.published == c.expectedPublished {
		c.wait <- struct{}{}
	}
	return nil
}

func TestRunWorker(t *testing.T) {
	q := make(chan *kevent.Batch, 2)
	q <- &kevent.Batch{}
	q <- &kevent.Batch{}

	mux := http.NewServeMux()
	mux.HandleFunc("/publish", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewServer(mux)
	defer srv.Close()

	client := &httpClient{url: srv.URL, wait: make(chan struct{}, 1), expectedPublished: 2}

	w := initWorker(q, client)
	defer w.close()

	<-client.wait

	assert.Equal(t, 2, client.published)
}

func TestConnectClientBackoff(t *testing.T) {
	q := make(chan *kevent.Batch, 2)
	q <- &kevent.Batch{}
	q <- &kevent.Batch{}

	fail := true

	mux := http.NewServeMux()
	mux.HandleFunc("/publish", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
	mux.HandleFunc("/connect", func(w http.ResponseWriter, r *http.Request) {
		if fail {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewServer(mux)
	defer srv.Close()

	client := &httpClient{url: srv.URL, wait: make(chan struct{}, 1), expectedPublished: 2}

	go time.AfterFunc(time.Second*3, func() {
		fail = false
	})

	w := initWorker(q, client)
	defer w.close()

	<-client.wait

	assert.Equal(t, 2, client.published)
}

```

`pkg/alertsender/alert.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

import "fmt"

// Severity is the type alias for alert's severity level.
type Severity uint8

const (
	// Normal designates alert's normal level
	Normal Severity = iota
	// Medium designates alert's medium level
	Medium
	// Critical designates alert's critical level
	Critical
)

// String returns severity human-friendly name.
func (s Severity) String() string {
	switch s {
	case Normal:
		return "normal"
	case Medium:
		return "medium"
	case Critical:
		return "critical"
	default:
		return "unknown"
	}
}

// ParseSeverityFromString parses the severity from the string representation.
func ParseSeverityFromString(sever string) Severity {
	switch sever {
	case "normal", "Normal":
		return Normal
	case "medium", "Medium":
		return Medium
	case "critical", "Critical":
		return Critical
	default:
		return Normal
	}
}

// Alert encapsulates the state of an alert.
type Alert struct {
	// Title is the short title that summarizes the purpose of the alert.
	Title string
	// Text is the longer textual content that further explains what this alert is about.
	Text string
	// Tags contains a sequence of tags for categorizing the alerts.
	Tags []string
	// Severity determines the severity of this alert.
	Severity Severity
}

// String returns the alert string representation.
func (a Alert) String() string {
	return fmt.Sprintf("Title: %s, Text: %s, Severity: %s, Tags: %v", a.Title, a.Text, a.Severity, a.Tags)
}

// NewAlert builds a new alert.
func NewAlert(title, text string, tags []string, severity Severity) Alert {
	return Alert{Title: title, Text: text, Tags: tags, Severity: severity}
}

```

`pkg/alertsender/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

// Config is the container for the alert sender configuration structure.
type Config struct {
	Type   Type
	Sender interface{}
}

```

`pkg/alertsender/mail/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

import "github.com/spf13/pflag"

const (
	host    = "alertsenders.mail.host"
	port    = "alertsenders.mail.port"
	user    = "alertsenders.mail.user"
	pass    = "alertsenders.mail.password"
	from    = "alertsenders.mail.from"
	to      = "alertsenders.mail.to"
	enabled = "alertsenders.mail.enabled"
)

// Config contains the configuration for the mail alert sender.
type Config struct {
	// Host is the host of the SMTP server.
	Host string `mapstructure:"host"`
	// Port is the port of the SMTP server.
	Port int `mapstructure:"port"`
	// User specifies the user name when authenticating to the SMTP server.
	User string `mapstructure:"user"`
	// Pass specifies the password when authenticating to the SMTP server.
	Pass string `mapstructure:"password"`
	// From specifies the sender address.
	From string `mapstructure:"from"`
	// To specifies recipients that receive the alert.
	To []string `mapstructure:"to"`
	// Enabled indicates whether mail alert sender is enabled
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(host, "", "Represents the host of the SMTP server")
	flags.Int(port, 25, "Represents the port of the SMTP server")
	flags.String(user, "", "Specifies the user name when authenticating to the SMTP server")
	flags.String(pass, "", "Specifies the password when authenticating to the SMTP server")
	flags.String(from, "", "Specifies the sender's address")
	flags.StringSlice(to, []string{}, "Specifies all the recipients that'll receive the alert")
	flags.Bool(enabled, false, "Indicates whether mail alert sender is enabled")
}

```

`pkg/alertsender/mail/mail.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

import (
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"gopkg.in/gomail.v2"
)

type mail struct {
	dialer *gomail.Dialer
	c      Config
}

func init() {
	alertsender.Register(alertsender.Mail, makeSender)
}

// makeSender constructs a new instance of the email alert sender.
func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	c, ok := config.Sender.(Config)
	if !ok {
		return nil, alertsender.ErrInvalidConfig(alertsender.Mail)
	}
	dialer := gomail.NewDialer(c.Host, c.Port, c.User, c.Pass)
	return &mail{dialer: dialer, c: c}, nil
}

func (s mail) Send(alert alertsender.Alert) error {
	sender, err := s.dialer.Dial()
	if err != nil {
		return err
	}
	defer sender.Close()
	return gomail.Send(sender, composeMessage(s.c.From, s.c.To, alert))
}

func composeMessage(from string, to []string, alert alertsender.Alert) *gomail.Message {
	msg := gomail.NewMessage()
	msg.SetHeader("From", from)
	msg.SetHeader("To", to...)
	msg.SetHeader("Subject", alert.Title)
	msg.SetBody("text/plain", alert.Text)
	return msg
}

```

`pkg/alertsender/sender.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

import "fmt"

// ErrInvalidConfig signals an invalid sender config
var ErrInvalidConfig = func(name Type) error { return fmt.Errorf("invalid config for %q sender", name) }

var factories = map[Type]Factory{}
var alertsenders = map[Type]Sender{}

// Factory defines the alias for the alert sender factory
type Factory func(config Config) (Sender, error)

// Type defines the alias for the alert sender type
type Type uint8

const (
	// Mail designates mail alert sender
	Mail Type = iota
	// Slack designates Slack alert sender
	Slack
	// Noop is a noop alert sender. Useful for testing.
	Noop
	// None is the type for unknown alert sender
	None
)

// String returns the string representation of the alert sender type.
func (s Type) String() string {
	switch s {
	case Mail:
		return "mail"
	case Slack:
		return "slack"
	case Noop:
		return "noop"
	default:
		return "none"
	}
}

// Sender is the minimal interface all alert senders have to implement.
type Sender interface {
	// Send emits an alert.
	Send(Alert) error
}

// ToType converts the string representation of the alert sender to its corresponding type.
func ToType(s string) Type {
	switch s {
	case "mail":
		return Mail
	case "slack":
		return Slack
	case "noop":
		return Noop
	default:
		return None
	}
}

// Register registers a new alert sender.
func Register(typ Type, factory Factory) {
	if _, ok := factories[typ]; ok {
		panic(fmt.Sprintf("%q alert sender is already registered", typ))
	}
	factories[typ] = factory
}

// Find locates the sender.
func Find(typ Type) Sender {
	return alertsenders[typ]
}

// FindAll returns all registered senders.
func FindAll() []Sender {
	senders := make([]Sender, 0, len(alertsenders))
	for _, s := range alertsenders {
		senders = append(senders, s)
	}
	return senders
}

// Load loads an alert sender from the registry.
func Load(config Config) (Sender, error) {
	typ := config.Type
	factory := factories[typ]
	if factory == nil {
		return nil, fmt.Errorf("%q alert sender not availaible in the factory", typ)
	}
	return factory(config)
}

// LoadAll loads all alert senders from the configuration inputs.
func LoadAll(configs []Config) error {
	for _, config := range configs {
		alertsender, err := Load(config)
		if err != nil {
			return fmt.Errorf("fail to load %q alertsender: %v", config.Type, err)
		}
		alertsenders[config.Type] = alertsender
	}
	return nil
}

```

`pkg/alertsender/slack/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package slack

import "github.com/spf13/pflag"

const (
	enabled   = "alertsenders.slack.enabled"
	url       = "alertsenders.slack.url"
	workspace = "alertsenders.slack.workspace"
	channel   = "alertsenders.slack.channel"
	botemoji  = "alertsenders.slack.emoji"
)

// Config stores the settings that dictate the behaviour of the Slack alert sender.
type Config struct {
	// URL represents the Webhook URL of the workspace where alerts will be dispatched.
	URL string `mapstructure:"url"`
	// Workspace designates the Slack workspace where alerts will be routed.
	Workspace string `mapstructure:"workspace"`
	// Channel is the slack channel in which to post alerts.
	Channel string `mapstructure:"channel"`
	// BotEmoji is the emoji icon for the Slack bot.
	BotEmoji string `mapstructure:"emoji"`
	// Enabled determines if Slack alert sender is enabled.
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Determines whether Slack alert sender is enabled")
	flags.String(url, "", "Represents the Webhook URL of the workspace where alerts will be dispatched")
	flags.String(workspace, "", "Designates the Slack workspace where alerts will be routed")
	flags.String(channel, "", "Represents the slack channel in which to post alerts")
	flags.String(botemoji, "", "Represents the emoji icon for the Slack bot")
}

```

`pkg/alertsender/slack/slack.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package slack

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"io/ioutil"
	"net"
	"net/http"
	"time"
)

const botName = "fibratus"

type slack struct {
	client *http.Client
	config Config
}

// attachment represents Slack attachment info
type attachment struct {
	Fallback string   `json:"fallback"`
	Color    string   `json:"color"`
	Text     string   `json:"text"`
	Mdin     []string `json:"mrkdwn_in"`
}

func init() {
	alertsender.Register(alertsender.Slack, makeSender)
}

// makeSender constructs a new instance of the Slack alert sender.
func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	c, ok := config.Sender.(Config)
	if !ok {
		return nil, alertsender.ErrInvalidConfig(alertsender.Slack)
	}
	client := &http.Client{
		Transport: &http.Transport{
			DialContext: (&net.Dialer{
				Timeout:   10 * time.Second,
				KeepAlive: 30 * time.Second,
			}).DialContext,
			IdleConnTimeout:     90 * time.Second,
			TLSHandshakeTimeout: 10 * time.Second,
		},
	}
	return &slack{config: c, client: client}, nil
}

func (s slack) Send(alert alertsender.Alert) error {
	var color string
	switch alert.Severity {
	case alertsender.Medium:
		color = "warning"
	case alertsender.Critical:
		color = "danger"
	default:
		color = "good"
	}

	attach := attachment{
		Fallback: alert.Text,
		Text:     alert.Text,
		Color:    color,
		Mdin:     []string{"text"},
	}

	params := make(map[string]interface{})
	params["as_user"] = false
	params["channel"] = s.config.Channel
	params["text"] = ""
	params["attachments"] = []attachment{attach}
	params["username"] = botName
	if s.config.BotEmoji != "" {
		params["icon_emoji"] = s.config.BotEmoji
	}

	var body bytes.Buffer
	enc := json.NewEncoder(&body)
	err := enc.Encode(params)
	if err != nil {
		return nil
	}
	//nolint:noctx
	resp, err := s.client.Post(s.config.URL, "application/json", &body)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		type response struct {
			Error string `json:"error"`
		}
		r := &response{Error: fmt.Sprintf("failed to send alert to Slack. code: %d content: %s", resp.StatusCode, string(body))}
		b := bytes.NewReader(body)
		dec := json.NewDecoder(b)
		if err := dec.Decode(r); err != nil {
			return err
		}
		return errors.New(r.Error)
	}
	return nil
}

```

`pkg/api/handler/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handler

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"net/http"
)

// Config is the handler the serves the current configuration state as pretty-formatted text.
func Config(c *config.Config) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte(c.Print())); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})
}

```

`pkg/api/listener.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"context"
	"fmt"
	"github.com/Microsoft/go-winio"
	"net"
	"strings"
)

// MakePipeListener produces a new listener for receiving requests over a named pipe.
func MakePipeListener(pipePath, descriptor string) (net.Listener, error) {
	npipe := transformPipePath(pipePath)
	l, err := winio.ListenPipe(npipe, &winio.PipeConfig{SecurityDescriptor: descriptor})
	if err != nil {
		return nil, fmt.Errorf("fail to listen on the %q pipe: %v", pipePath, err)
	}
	return l, nil
}

// makeTCPListener produces a new listener for receiving requests over TCP.
func makeTCPListener(addr string) (net.Listener, error) {
	return net.Listen("tcp", addr)
}

// DialPipe creates a dialer to be used with the http.Client to connect to a named pipe.
func DialPipe(pipePath string) func(context.Context, string, string) (net.Conn, error) {
	npipe := transformPipePath(pipePath)
	return func(ctx context.Context, _, _ string) (net.Conn, error) {
		return winio.DialPipeContext(ctx, npipe)
	}
}

// transformPipePath takes an input type name defined as a URI like `npipe:///hello` and transform it into
// `\\.\pipe\hello`. Borrowed from https://github.com/elastic/beats/blob/master/libbeat/api/npipe/listener_windows.go
func transformPipePath(name string) string {
	if strings.HasPrefix(name, "npipe:///") {
		path := strings.TrimPrefix(name, "npipe:///")
		return `\\.\pipe\` + path
	}

	if strings.HasPrefix(name, `\\.\pipe\`) {
		return name
	}

	return name
}

```

`pkg/api/server.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/api/handler"
	"github.com/rabbitstack/fibratus/pkg/config"
	log "github.com/sirupsen/logrus"
	"net"
	"net/http"
	"net/http/pprof"
	"runtime/debug"
	"strings"
)

func setupServer(lis net.Listener, c *config.Config) {
	mux := http.NewServeMux()
	mux.Handle("/config", handler.Config(c))
	mux.Handle("/debug/vars", expvar.Handler())

	mux.HandleFunc("/debug/pprof/", pprof.Index)
	mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
	mux.HandleFunc("/debug/freemem", func(writer http.ResponseWriter, request *http.Request) {
		debug.FreeOSMemory()
	})

	srv := &http.Server{
		Handler: mux,
	}

	go func() {
		if err := srv.Serve(lis); err != nil && err != http.ErrServerClosed {
			if strings.Contains(err.Error(), "use of closed network connection") {
				return
			}
			log.Errorf("unable to bind the API server: %v", err)
		}
	}()
}

```

`pkg/api/server_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"net"
	"os/user"
	"strings"
)

var listener net.Listener

// StartServer starts the HTTP server with the specified configuration.
func StartServer(c *config.Config) error {
	var err error
	apiConfig := c.API
	if strings.HasPrefix(apiConfig.Transport, `npipe:///`) {
		usr, err := user.Current()
		if err != nil {
			return fmt.Errorf("failed to retrieve the current user: %v", err)
		}
		// Named pipe security and access rights.
		// We create the pipe and the specific users should only be able to write to it.
		// See docs: https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipe-security-and-access-rights
		// String definition: https://docs.microsoft.com/en-us/windows/win32/secauthz/ace-strings
		// Give generic read/write access to the specified user.
		descriptor := "D:P(A;;GA;;;" + usr.Uid + ")"
		listener, err = MakePipeListener(apiConfig.Transport, descriptor)
		if err != nil {
			return err
		}
	} else {
		listener, err = makeTCPListener(apiConfig.Transport)
	}
	if err != nil {
		return err
	}

	setupServer(listener, c)

	return nil
}

// CloseServer shutdowns the server by stopping the listener.
func CloseServer() error {
	if listener != nil {
		return listener.Close()
	}
	return nil
}

```

`pkg/config/_fixtures/eventlog-output.yml`:

```yml
kstream:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output:
  console:
    enabled: false
    format: pretty
  elasticsearch:
  eventlog:
    enabled: true
    level: INFO

```

`pkg/config/_fixtures/fibratus.json`:

```json
{
  "aggregator": {
    "flush-period": "230ms",
    "flush-timeout": "8s"
  },

  "alertsenders": {
    "mail": {
      "enabled": false
    },

    "slack": {
      "enabled": false
    }
  },

  "api": {
    "transport": "localhost:8090",
    "timeout": "5s"
  },

  "debug-privilege": true,

  "filament": {
    "name": "",
    "flush-period": "200ms"
  },

  "handle": {
    "init-snapshot": true
  },

  "kevent": {

  },

  "kcap": {

  },

  "kstream": {},
  "logging": {},
  "output": {
    "console": {
      "enabled": true,
      "format": "pretty",
      "kv-delimiter": "->"
    }
  },
  "pe": {},
  "transformers": {},
  "yara": {}
}
```

`pkg/config/_fixtures/fibratus.yml`:

```yml
###################### Fibratus Configuration File #####################################

# =============================== Aggregator ==========================================

# Aggregator is responsible for creating kernel event batches, applying transformers to each event
# present in the batch, and forwarding those batches to the output sinks.
aggregator:
  # Determines the flush period that triggers the flushing of the kernel event batches to output sinks.
  flush-period: 230ms

  # Represents the max time to wait before announcing failed flushing of enqueued events when fibratus
  # is stopped.
  flush-timeout: 8s

# =============================== Alert senders ========================================

# Alert senders deal with emitting alerts via different channels.
alertsenders:
  # Mail sender transports the alerts via SMTP protocol.
  mail:
    # Enables/disables mail alert sender.
    enabled: true

    # Represents the host of the SMTP server.
    host: smtp.gmail.com

    # Represents the port of the SMTP server.
    port: 587

    # Specifies the user name when authenticating to the SMTP server.
    user: bunny

    # Specifies the password when authenticating to the SMTP server.
    password: changeit

    # Specifies the sender's address.
    from: bunny@gmail.com

    # Specifies all the recipients that'll receive the alert.
    to:
      - bunny@gmail.com
      - rabbit@gmail.com
      - cuniculus@gmail.com

  # Slack sender transports the alerts to the Slack workspace.
  slack:
    # Enables/disables Slack alert sender.
    enabled: true

    # Represents the Webhook URL of the workspace where alerts will be dispatched.
    url: https://fibratus/232sfghagjhfasr

    # Designates the Slack workspace where alerts will be routed.
    workspace: fibratus

    # Is the slack channel in which to post alerts.
    channel: fibratus

    # Represents the emoji icon surrounded in ':' characters for the Slack bot.
    #emoji: ""

# =============================== API ==================================================

# Settings that influence the behaviour of the HTTP server that exposes a number of endpoints such as
# expvar metrics, internal state, and so on.
api:
  # Specifies the underlying transport protocol for the API HTTP server. The transport can either be the
  # named pipe or TCP socket. Default is named pipe but you can override it to expose theAPI server on
  # TCP address, e.g. 192.168.1.32:8084.
  transport: npipe:///fibratus

  # Represents the timeout interval for the HTTP server responses.
  timeout: 5s

# =============================== General ==============================================

# Indicates whether debug privilege is set in Fibratus process' token. Enabling this security policy allows
# Fibratus to obtain handles of protected processes for the purpose of querying the Process Environment Block
# regions.
debug-privilege: true

# =============================== Filament =============================================

# Filaments are lightweight Python scriplets that are executed on top of the kernel event stream. You can easily
# extend Fibratus with custom features that is encapsulated in filaments. This section controls the behaviour of
# the filament engine.
filament:
  # Specifies the name of the filament that is executed with the run command.
  name: top_netio

  # The directory where all filaments are located. By default, they are stored within the fibratus program
  # files directory.
  path: $(PROGRAMFILES)/fibratus/filaments

  flush-period: 300ms

# =============================== Handle ===============================================

# Indicates whether initial handle snapshot is taken.
handle:
  init-snapshot: true

# =============================== Kcap =================================================

kcap:
  file: ""

# =============================== Kevent ===============================================

kevent:
  serialize-threads: false
  serialize-images: false
  serialize-handles: false
  serialize-pe: false

# =============================== Kstream ==============================================

kstream:
  max-buffers: 2
  min-buffers: 1
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread
      - CreateHandle
      - CloseHandle
    images:
      - System


# =============================== Logging ================================================

logging:
  level: info
  # max-age:
  # max-backups:
  # max-size:
  # formatter:
  # path:
  # log-stdout: false


# =============================== Output ================================================

output:
  console:
    enabled: false
    format: json
    template: ""


  elasticsearch:
    enabled: false
    servers:
      - http://localhost:9200
    timeout: 5s

  amqp:
    enabled: true
    url: amqp://localhost:5672
    timeout: 5s
    exchange-type: topic
    routing-key: fibratus
    vhost: /

  http:
    enabled: false
    endpoints:
      - http://localhost:8081
    timeout: 5s
    method: POST

# =============================== Portable Executable (PE) =============================

pe:
  enabled: false
  read-resources: true
  read-symbols: true
  read-sections: false

# =============================== Transformers =========================================

transformers:
  remove:
    enabled: true
    kparams:
      - disposition
  rename:
    enabled: true
    kparams:
      - old: "a"
        new: "b"
      - old: "c"
        new: "d"
  replace:
    enabled: false
    replacements:
      - kparam: key_name
        old: HKEY_CURRENT_USER
        new: HCU
  tags:
    enabled: false
    tags:
      - key: foo
        value: bar
  trim:
    enabled: false
    prefixes:
      - kparam: key_name
        trim: CurrentControlSet
    suffixes:
      - kparam: file_name
        trim: .exe

# =============================== YARA =================================================

yara:
  enabled: true
  rule:
    paths:
      - path: "C:\\yara-rules"
        namespace: default
    strings:
      - string: "rule test : tag1 { meta: author = \"Hilko Bengen\" strings: $a = \"abc\" fullword condition: $a }"
        namespace: default
  alert-via: slack
  alert-template:
    title: ""
    text: ""
  fastscan: true
  scan-timeout: 20s
  skip-files: true
  excluded-files:
    - kernel32.dll
  excluded-procs:
    - system
    - spotify.exe

```

`pkg/config/_fixtures/filters/default-new-attributes.yml`:

```yml
- group: internal network traffic
  enabled: false
  selector:
    type: Connect
  policy: exclude
  relation: and
  tags:
    - TE
  from-strings:
    - name: only network category
      def: kevt.category = 'net'

- group: rouge processes
  selector:
    category: net
  rules:
    - name: suspicious network {{ upper "activity" }}
      condition: kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')

```

`pkg/config/_fixtures/filters/default.yml`:

```yml
- group: internal network traffic
  enabled: true
  selector:
    type: Connect
  policy: exclude
  relation: and
  tags:
    - TE
  from-strings:
    - name: only network category
      def: kevt.category = 'net'

- group: rouge processes
  enabled: true
  selector:
    category: net
  from-strings:
    - name: suspicious network {{ upper "activity" }}
      def: kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')
```

`pkg/config/_fixtures/filters/filter_action_in_exclude_group.yml`:

```yml
- group: rouge processes
  enabled: true
  selector:
    category: net
  policy: exclude
  from-strings:
    - name: suspicious network activity
      def: kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')
      action: |
        {{ kill .Kevt.PID }}
```

`pkg/config/_fixtures/filters/invalid_filter_action.yml`:

```yml
- group: rouge processes
  enabled: true
  selector:
    category: net
  from-strings:
    - name: suspicious network activity
      def: kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')
      action: |
        {{ kil .Kevt.PID }}
```

`pkg/config/_fixtures/filters/invalid_filter_action_values.yml`:

```yml
- group: rouge processes
  enabled: true
  selector:
    category: net
  from-strings:
    - name: suspicious network activity
      def: kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')
      action: |
        {{ kill .Kevt.Pid }}
```

`pkg/config/_fixtures/filters/values/default.yml`:

```yml
- group: internal network traffic
  enabled: true
  selector:
    type: Connect
  policy: exclude
  relation: and
  tags:
    - TE
  from-strings:
    - name: only network category
      def: kevt.category = 'net'

- group: rouge processes
  enabled: true
  selector:
    category: net
  from-strings:
    - name: suspicious network {{ upper "activity" }}
      def: kevt.category = 'net' and ps.name in {{ .Values.procs | stringify }}
```

`pkg/config/_fixtures/filters/values/values.yml`:

```yml
procs:
  - at.exe
  - java.exe
  - nc.exe
```

`pkg/config/_fixtures/http-output.yml`:

```yml
kstream:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output:
  console:
    enabled: false
    format: pretty
  elasticsearch:
  http:
    enabled: true
    endpoints:
      - http://localhost:8081
      - http://localhost:8082
    timeout: 2s
    proxy-url: http://192.168.1.8:3123
    proxy-username: bunny
    proxy-password: bunny
    username: basic
    password: basic
    enable-gzip: true
    headers:
      api-Key: kkvvkk
      header2: value2

```

`pkg/config/_fixtures/output.yml`:

```yml
kstream:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output:
  console:
    enabled: false
    format: pretty
  elasticsearch:
  amqp:
    enabled: true
    url: amqp://localhost:5672
    timeout: 5s
    exchange: fibratus
    exchange-type: topic
    routing-key: fibratus


```

`pkg/config/_fixtures/transformers.yml`:

```yml
kstream:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output.console:
  format: pretty

transformers.tags:
  enabled: true
  tags:
    - key: 1
      value: k

transformers.remove:
  enabled: true
  kparams:
    - key_handle

transformers.rename:
  enabled: true
  kparams:
    - old: key_handle
      new: KeyHandle
```

`pkg/config/alertsender.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	"github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	"reflect"
)

var errNoAlertsendersSection = errors.New("no alertsenders section in config")

var errAlertsenderConfig = func(sender string, err error) error {
	return fmt.Errorf("%s alert sender invalid config: %v", sender, err)
}

func (c *Config) tryLoadAlertSenders() error {
	configs := make([]alertsender.Config, 0)
	alertsenders := c.viper.AllSettings()["alertsenders"]
	if alertsenders == nil {
		return errNoAlertsendersSection
	}

	mapping, ok := alertsenders.(map[string]interface{})
	if !ok {
		return fmt.Errorf("expected map[string]interface{} type for alertsenders but found %s", reflect.TypeOf(alertsenders))
	}

	for typ, config := range mapping {
		switch typ {
		case "mail":
			var mailConfig mail.Config
			if err := decode(config, &mailConfig); err != nil {
				return errAlertsenderConfig(typ, err)
			}
			if !mailConfig.Enabled {
				continue
			}
			config := alertsender.Config{
				Type:   alertsender.Mail,
				Sender: mailConfig,
			}
			configs = append(configs, config)

		case "slack":
			var slackConfig slack.Config
			if err := decode(config, &slackConfig); err != nil {
				return errAlertsenderConfig(typ, err)
			}
			if !slackConfig.Enabled {
				continue
			}
			config := alertsender.Config{
				Type:   alertsender.Slack,
				Sender: slackConfig,
			}
			configs = append(configs, config)
		}
	}

	c.Alertsenders = configs

	return nil
}

```

`pkg/config/api.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/spf13/viper"
	"time"
)

const (
	transport = "api.transport"
	timeout   = "api.timeout"
)

// APIConfig contains API specific config options.
type APIConfig struct {
	// Transport specifies the underlying transport protocol for the API HTTP server.
	Transport string `json:"api.transport" yaml:"api.transport"`
	// Timeout determines the timeout for the API server responses
	Timeout time.Duration `json:"api.timeout" yaml:"api.timeout"`
}

// initFromViper initializes API configuration from Viper.
func (c *APIConfig) initFromViper(v *viper.Viper) {
	c.Transport = v.GetString(transport)
	c.Timeout = v.GetDuration(timeout)
}

```

`pkg/config/config_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"time"

	"github.com/rabbitstack/fibratus/pkg/outputs/eventlog"

	"github.com/rabbitstack/fibratus/pkg/outputs/http"

	"github.com/rabbitstack/fibratus/pkg/aggregator"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	removet "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/remove"
	replacet "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/replace"
	tagst "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/tags"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/elasticsearch"
	"github.com/rabbitstack/fibratus/pkg/util/log"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	yara "github.com/rabbitstack/fibratus/pkg/yara/config"
	"gopkg.in/yaml.v3"

	renamet "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	trimt "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/trim"

	"os"
	"path/filepath"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	mailsender "github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	slacksender "github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/outputs/console"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	kcapFile           = "kcap.file"
	configFile         = "config-file"
	debugPrivilege     = "debug-privilege"
	initHandleSnapshot = "handle.init-snapshot"

	serializeThreads = "kevent.serialize-threads"
	serializeImages  = "kevent.serialize-images"
	serializeHandles = "kevent.serialize-handles"
	serializePE      = "kevent.serialize-pe"
	serializeEnvs    = "kevent.serialize-envs"
)

// Config stores configuration options for fine tuning the behaviour of Fibratus.
type Config struct {
	// Kstream stores different configuration options for fine tuning kstream consumer/controller settings.
	Kstream KstreamConfig `json:"kstream" yaml:"kstream"`
	// Filament contains filament settings
	Filament FilamentConfig `json:"filament" yaml:"filament"`
	// PE contains the settings that influences the behaviour of the PE (Portable Executable) reader.
	PE pe.Config `json:"pe" yaml:"pe"`
	// Output stores the currently active output config
	Output outputs.Config
	// InitHandleSnapshot indicates whether initial handle snapshot is built
	InitHandleSnapshot bool `json:"init-handle-snapshot" yaml:"init-handle-snapshot"`
	DebugPrivilege     bool `json:"debug-privilege" yaml:"debug-privilege"`
	KcapFile           string

	// API stores global HTTP API preferences
	API APIConfig `json:"api" yaml:"api"`
	// Yara contains configuration that influences the behaviour of the Yara engine
	Yara yara.Config `json:"yara" yaml:"yara"`
	// Aggregator stores event aggregator configuration
	Aggregator aggregator.Config `json:"aggregator" yaml:"aggregator"`
	// Log contains log-specific configuration options
	Log log.Config `json:"logging" yaml:"logging"`

	// Transformers stores transformer configurations
	Transformers []transformers.Config
	// Alertsenders stores alert sender configurations
	Alertsenders []alertsender.Config

	// Filters contains filter group definitions
	Filters *Filters `json:"filters" yaml:"filters"`

	flags *pflag.FlagSet
	viper *viper.Viper
	opts  *Options
}

// Options determines which config flags are toggled depending on the command type.
type Options struct {
	capture bool
	replay  bool
	run     bool
	list    bool
	stats   bool
}

// Option is the type alias for the config option.
type Option func(*Options)

// WithCapture determines the capture command is executed.
func WithCapture() Option {
	return func(o *Options) {
		o.capture = true
	}
}

// WithReplay determines the replay command is executed.
func WithReplay() Option {
	return func(o *Options) {
		o.replay = true
	}
}

// WithRun determines the main command is executed.
func WithRun() Option {
	return func(o *Options) {
		o.run = true
	}
}

// WithList determines the list command is executed.
func WithList() Option {
	return func(o *Options) {
		o.list = true
	}
}

// WithStats determines the stats command is executed.
func WithStats() Option {
	return func(o *Options) {
		o.stats = true
	}
}

// NewWithOpts builds a new configuration store from a variety of sources such as configuration files,
// environment variables or command line flags.
func NewWithOpts(options ...Option) *Config {
	opts := &Options{}

	for _, opt := range options {
		opt(opts)
	}

	v := viper.New()
	v.AutomaticEnv()
	v.SetEnvKeyReplacer(strings.NewReplacer("-", "_", ".", "_"))

	flagSet := new(pflag.FlagSet)

	c := &Config{
		Kstream:    KstreamConfig{},
		Filament:   FilamentConfig{},
		API:        APIConfig{},
		PE:         pe.Config{},
		Log:        log.Config{},
		Aggregator: aggregator.Config{},
		Filters:    &Filters{},
		viper:      v,
		flags:      flagSet,
		opts:       opts,
	}

	if opts.run || opts.replay {
		aggregator.AddFlags(flagSet)
		console.AddFlags(flagSet)
		amqp.AddFlags(flagSet)
		elasticsearch.AddFlags(flagSet)
		http.AddFlags(flagSet)
		eventlog.AddFlags(flagSet)
		removet.AddFlags(flagSet)
		replacet.AddFlags(flagSet)
		renamet.AddFlags(flagSet)
		trimt.AddFlags(flagSet)
		tagst.AddFlags(flagSet)
		mailsender.AddFlags(flagSet)
		slacksender.AddFlags(flagSet)
		yara.AddFlags(flagSet)
	}

	if opts.run || opts.capture {
		pe.AddFlags(flagSet)
	}

	c.addFlags()

	return c
}

// GetConfigFile gets the path of the configuration file from Viper value.
func (c Config) GetConfigFile() string {
	return c.viper.GetString(configFile)
}

// MustViperize adds the flag set to the Cobra command and binds them within the Viper flags.
func (c *Config) MustViperize(cmd *cobra.Command) {
	cmd.PersistentFlags().AddFlagSet(c.flags)
	if err := c.viper.BindPFlags(cmd.PersistentFlags()); err != nil {
		panic(err)
	}
	if c.opts.capture || c.opts.replay {
		if err := cmd.MarkPersistentFlagRequired(kcapFile); err != nil {
			panic(err)
		}
	}
}

// Init setups the configuration state from Viper.
func (c *Config) Init() error {
	c.Kstream.initFromViper(c.viper)
	c.Filament.initFromViper(c.viper)
	c.API.initFromViper(c.viper)
	c.PE.InitFromViper(c.viper)
	c.Aggregator.InitFromViper(c.viper)
	c.Log.InitFromViper(c.viper)
	c.Yara.InitFromViper(c.viper)
	c.Filters.initFromViper(c.viper)

	c.InitHandleSnapshot = c.viper.GetBool(initHandleSnapshot)
	c.DebugPrivilege = c.viper.GetBool(debugPrivilege)
	c.KcapFile = c.viper.GetString(kcapFile)

	kevent.SerializeThreads = c.viper.GetBool(serializeThreads)
	kevent.SerializeImages = c.viper.GetBool(serializeImages)
	kevent.SerializeHandles = c.viper.GetBool(serializeHandles)
	kevent.SerializePE = c.viper.GetBool(serializePE)
	kevent.SerializeEnvs = c.viper.GetBool(serializeEnvs)

	if c.opts.run || c.opts.replay {
		if err := c.tryLoadOutput(); err != nil {
			return err
		}
		if err := c.tryLoadTransformers(); err != nil {
			return err
		}
		if err := c.tryLoadAlertSenders(); err != nil {
			return err
		}
	}
	return nil
}

// TryLoadFile attempts to load the configuration file from specified path on the file system.
func (c *Config) TryLoadFile(file string) error {
	c.viper.SetConfigFile(file)
	return c.viper.ReadInConfig()
}

// Validate ensures that all configuration options provided by user have the expected values. It returns
// a list of validation errors prefixed with the offending configuration property/flag.
func (c *Config) Validate() error {
	// we'll first validate the structure and values of the config file
	file := c.viper.GetString(configFile)
	var out interface{}
	b, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	switch filepath.Ext(file) {
	case ".yaml", ".yml":
		err = yaml.Unmarshal(b, &out)
	case ".json":
		err = json.Unmarshal(b, &out)
	default:
		return fmt.Errorf("%s is not a supported config file extension", filepath.Ext(file))
	}
	if err != nil {
		return fmt.Errorf("couldn't read the config file: %v", err)
	}
	// validate config file content
	valid, errs := validate(interpolateSchema(), out)
	if !valid || len(errs) > 0 {
		return fmt.Errorf("invalid config: %v", multierror.Wrap(errs...))
	}
	// now validate the Viper config flags
	valid, errs = validate(interpolateSchema(), c.viper.AllSettings())
	if !valid || len(errs) > 0 {
		return fmt.Errorf("invalid config: %v", multierror.Wrap(errs...))
	}
	return nil
}

// File returns the config file path.
func (c *Config) File() string { return c.viper.GetString(configFile) }

func (c *Config) addFlags() {
	c.flags.String(configFile, filepath.Join(os.Getenv("PROGRAMFILES"), "fibratus", "config", "fibratus.yml"), "Indicates the location of the configuration file")
	if c.opts.run || c.opts.replay {
		c.flags.StringP(filamentName, "f", "", "Specifies the filament to execute")
		c.flags.StringSlice(rulesFromPaths, []string{}, "Comma-separated list of rules files")
		c.flags.StringSlice(rulesFromURLs, []string{}, "Comma-separated list of rules URL resources")
	}
	if c.opts.capture {
		c.flags.StringP(kcapFile, "o", "", "The path of the output kcap file")
	}
	if c.opts.replay {
		c.flags.StringP(kcapFile, "k", "", "The path of the input kcap file")
	}
	if c.opts.run || c.opts.replay || c.opts.list {
		c.flags.String(filamentPath, filepath.Join(os.Getenv("PROGRAMFILES"), "fibratus", "filaments"), "Denotes the directory where filaments are located")
	}
	if c.opts.run || c.opts.replay || c.opts.capture || c.opts.stats {
		c.flags.String(transport, `localhost:8080`, "Specifies the underlying transport protocol for the API HTTP server")
		c.flags.Duration(timeout, time.Second*15, "Determines the timeout for the API server responses")
	}
	if c.opts.run || c.opts.capture {
		c.flags.Bool(initHandleSnapshot, true, "Indicates whether initial handle snapshot is built. This implies scanning the system handles table and producing an entry for each handle object")

		c.flags.Bool(enableThreadKevents, true, "Determines whether thread kernel events are collected by Kernel Logger provider")
		c.flags.Bool(enableRegistryKevents, true, "Determines whether registry kernel events are collected by Kernel Logger provider")
		c.flags.Bool(enableNetKevents, true, "Determines whether network (TCP/UDP) kernel events are collected by Kernel Logger provider")
		c.flags.Bool(enableFileIOKevents, true, "Determines whether disk I/O kernel events are collected by Kernel Logger provider")
		c.flags.Bool(enableImageKevents, true, "Determines whether file I/O kernel events are collected by Kernel Logger provider")
		c.flags.Bool(enableHandleKevents, false, "Determines whether object manager kernel events (handle creation/destruction) are collected by Kernel Logger provider")
		c.flags.Int(bufferSize, int(maxBufferSize), "Represents the amount of memory allocated for each event tracing session buffer, in kilobytes. The buffer size affects the rate at which buffers fill and must be flushed (small buffer size requires less memory but it increases the rate at which buffers must be flushed)")
		c.flags.Int(minBuffers, int(defaultMinBuffers), "Determines the minimum number of buffers allocated for the event tracing session's buffer pool")
		c.flags.Int(maxBuffers, int(defaultMaxBuffers), "Determines the maximum number of buffers allocated for the event tracing session's buffer pool")
		c.flags.Duration(flushInterval, defaultFlushInterval, "Specifies how often the trace buffers are forcibly flushed")
		c.flags.StringSlice(excludedEvents, []string{}, "A list of symbolical kernel event names that will be dropped from the kernel event stream. By default all events are accepted")
		c.flags.StringSlice(excludedImages, []string{"System"}, "A list of image names that will be dropped from the kernel event stream. Image names are case insensitive")
		c.flags.Bool(rawEventParsing, true, "Determines if raw event buffer parsing is used instead of TDH (Trace Data Helper) API")

		c.flags.Bool(serializeThreads, false, "Indicates if threads are serialized as part of the process state")
		c.flags.Bool(serializeImages, false, "Indicates if images are serialized as part of the process state")
		c.flags.Bool(serializeHandles, false, "Indicates if handles are serialized as part of the process state")
		c.flags.Bool(serializePE, false, "Indicates if the PE metadata are serialized as part of the process state")
		c.flags.Bool(serializeEnvs, true, "Indicates if environment variables are serialized as part of the process state")
	}
	c.Log.AddFlags(c.flags)
}

```

`pkg/config/config_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	"github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestNewFromYamlFile(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/fibratus.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	errs := c.Validate()

	require.Empty(t, errs)

	assert.Equal(t, time.Millisecond*230, c.Aggregator.FlushPeriod)
	assert.Equal(t, time.Second*8, c.Aggregator.FlushTimeout)

	assert.Len(t, c.Alertsenders, 2)

	for _, c := range c.Alertsenders {
		switch c.Type {
		case alertsender.Slack:
			assert.IsType(t, slack.Config{}, c.Sender)
		case alertsender.Mail:
			assert.IsType(t, mail.Config{}, c.Sender)
			mailConfig := c.Sender.(mail.Config)
			assert.Equal(t, "smtp.gmail.com", mailConfig.Host)
			assert.Equal(t, 587, mailConfig.Port)
			assert.Equal(t, "bunny", mailConfig.User)
			assert.Equal(t, "changeit", mailConfig.Pass)
			assert.Equal(t, "bunny@gmail.com", mailConfig.From)
			assert.Equal(t, []string{"bunny@gmail.com", "rabbit@gmail.com", "cuniculus@gmail.com"}, mailConfig.To)
		}
	}

	assert.Equal(t, "npipe:///fibratus", c.API.Transport)
	assert.Equal(t, time.Second*5, c.API.Timeout)
	assert.True(t, c.DebugPrivilege)

	assert.Equal(t, "top_netio", c.Filament.Name)

	require.Len(t, c.Transformers, 2)

	for _, tr := range c.Transformers {
		switch tr.Type {
		case transformers.Rename:
			rconfig := tr.Transformer.(rename.Config)
			assert.Len(t, rconfig.Kparams, 2)
			r1 := rconfig.Kparams[0]
			assert.Equal(t, "b", r1.New)
		}
	}

	assert.True(t, c.Yara.Enabled)

	require.Len(t, c.Yara.Rule.Paths, 1)
	assert.Len(t, c.Yara.Rule.Strings, 1)

	assert.Equal(t, "C:\\yara-rules", c.Yara.Rule.Paths[0].Path)
	assert.Equal(t, "default", c.Yara.Rule.Paths[0].Namespace)
}

func TestNewFromJsonFile(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/fibratus.json"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	errs := c.Validate()

	require.Empty(t, errs)

	assert.Equal(t, time.Millisecond*230, c.Aggregator.FlushPeriod)
	assert.Equal(t, time.Second*8, c.Aggregator.FlushTimeout)
}

```

`pkg/config/decoder.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import "github.com/mitchellh/mapstructure"

func decode(input, output interface{}) error {
	var decoderConfig = &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
		),
	}
	decoder, err := mapstructure.NewDecoder(decoderConfig)
	if err != nil {
		return err
	}
	return decoder.Decode(input)
}

```

`pkg/config/filament.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/spf13/viper"
	"time"
)

const (
	filamentName = "filament.name"
	filamentPath = "filament.path"
)

// FilamentConfig stores config parameters for tweaking the behaviour of the filament engine.
type FilamentConfig struct {
	Name        string
	Path        string
	FlushPeriod time.Duration
}

func (f *FilamentConfig) initFromViper(v *viper.Viper) {
	f.Name = v.GetString(filamentName)
	f.Path = v.GetString(filamentPath)
}

```

`pkg/config/filters.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/filter/funcmap"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"gopkg.in/yaml.v3"
	"hash/fnv"
	"io"
	"io/ioutil"
	"net/http"
	u "net/url"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// FilterGroupPolicy is the type alias for the filter group policy
type FilterGroupPolicy uint8

// FilterGroupRelation is the type alias for the filter group relation
type FilterGroupRelation uint8

const (
	// IncludePolicy determines the policy type that allows for
	// filtering the matching events.
	IncludePolicy FilterGroupPolicy = iota
	// ExcludePolicy determines the policy that allows for filtering
	// out the matching events, that is, discarding them from the event
	// flow.
	ExcludePolicy
	// SequencePolicy determines the policy that allows matching a
	// sequence of temporal events based on pattern binding restrictions
	SequencePolicy
	// UnknownPolicy determines the unknown group policy type.
	UnknownPolicy
)

const (
	// OrRelation is the group relation type that requires at
	// least one matching filter to evaluate successfully.
	OrRelation FilterGroupRelation = iota
	// AndRelation is the group relation type that requires that
	// all the filters to match in order to evaluate successfully.
	AndRelation
	// UnknownRelation determines the unknown group relation type.
	UnknownRelation
)

// String yields human readable group policy.
func (p FilterGroupPolicy) String() string {
	switch p {
	case IncludePolicy:
		return "include"
	case ExcludePolicy:
		return "exclude"
	case SequencePolicy:
		return "sequence"
	default:
		return ""
	}
}

// String yields human readable group relation.
func (r FilterGroupRelation) String() string {
	switch r {
	case OrRelation:
		return "or"
	case AndRelation:
		return "and"
	default:
		return ""
	}
}

// UnmarshalYAML converts the policy string to enum type.
func (p *FilterGroupPolicy) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var policy string
	err := unmarshal(&policy)
	if err != nil {
		return err
	}
	*p = filterGroupPolicyFromString(policy)
	return nil
}

// UnmarshalYAML converts the relation string to enum type.
func (r *FilterGroupRelation) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var relation string
	err := unmarshal(&relation)
	if err != nil {
		return err
	}
	*r = filterGroupRelationFromString(relation)
	return nil
}

func filterGroupPolicyFromString(s string) FilterGroupPolicy {
	switch s {
	case "include", "INCLUDE":
		return IncludePolicy
	case "exclude", "EXCLUDE":
		return ExcludePolicy
	case "sequence", "SEQUENCE":
		return SequencePolicy
	default:
		return UnknownPolicy
	}
}

func filterGroupRelationFromString(s string) FilterGroupRelation {
	switch s {
	case "or", "OR":
		return OrRelation
	case "and", "AND":
		return AndRelation
	default:
		return UnknownRelation
	}
}

// FilterConfig is the descriptor of a single filter.
type FilterConfig struct {
	Name      string        `json:"name" yaml:"name"`
	Def       string        `json:"def" yaml:"def"` // deprecated in favor of `Condition`
	Condition string        `json:"condition" yaml:"condition"`
	Action    string        `json:"action" yaml:"action"`
	MaxSpan   time.Duration `json:"max-span" yaml:"max-span"`
}

// parseTmpl ensures the correctness of the filter
// action template by trying to parse the template
// string from the base64 payload.
func (f FilterConfig) parseTmpl(resource string) error {
	if f.Action == "" {
		return nil
	}
	decoded, err := base64.StdEncoding.DecodeString(f.Action)
	if err != nil {
		return err
	}
	tmpl, err := template.New(f.Name).Funcs(funcmap.New()).Parse(string(decoded))
	if err != nil {
		return cleanupParseError(resource, err)
	}
	var bb bytes.Buffer
	return cleanupParseError(resource, tmpl.Execute(&bb, tmplData()))
}

// FilterGroup represents the container for filters.
type FilterGroup struct {
	Name        string              `json:"group" yaml:"group"`
	Enabled     *bool               `json:"enabled" yaml:"enabled"`
	Selector    FilterGroupSelector `json:"selector" yaml:"selector"`
	Policy      FilterGroupPolicy   `json:"policy" yaml:"policy"`
	Relation    FilterGroupRelation `json:"relation" yaml:"relation"`
	Rules       []*FilterConfig     `json:"rules" yaml:"rules"`
	FromStrings []*FilterConfig     `json:"from-strings" yaml:"from-strings"` // deprecated in favor or `Rules`
	Tags        []string            `json:"tags" yaml:"tags"`
	Action      string              `json:"action" yaml:"action"` // only valid in sequence policies
}

// IsDisabled determines if this group is disabled.
func (g FilterGroup) IsDisabled() bool { return g.Enabled != nil && !*g.Enabled }

func (g FilterGroup) validate(resource string) error {
	filters := append(g.FromStrings, g.Rules...)
	for _, filter := range filters {
		if filter.Action != "" && g.Policy == ExcludePolicy {
			return fmt.Errorf("%q rule found in %q group with exclude policy. "+
				"Only groups with include policies can have rule actions", filter.Name, g.Name)
		}
		if filter.MaxSpan != 0 && g.Policy != SequencePolicy {
			return fmt.Errorf("%q rule found has max span, but it is not in sequence policy " +
				filter.Name)
		}
		if err := filter.parseTmpl(resource); err != nil {
			return fmt.Errorf("invalid %q rule action: %v", filter.Name, err)
		}
	}
	return nil
}

// Hash calculates the filter group hash.
func (g FilterGroup) Hash() uint32 {
	h := fnv.New32()
	_, err := h.Write([]byte(g.Policy.String() + g.Name))
	if err != nil {
		return 0
	}
	return h.Sum32()
}

// FilterGroupSelector permits specifying the events
// that will be captured by particular filter group.
// Only one of type or category selectors can be active
// at the same time.
type FilterGroupSelector struct {
	Type     ktypes.Ktype    `json:"type" yaml:"type"`
	Category ktypes.Category `json:"category" yaml:"category"`
}

// Hash computes the filter group selector hash.
func (s FilterGroupSelector) Hash() uint32 {
	hash := s.Type.Hash()
	if hash != 0 {
		return hash
	}
	return s.Category.Hash()
}

// Filters contains references to filter group definitions.
// Each filter group can contain multiple filter expressions.
// Filter expressions can reside in the filter group file or
// live in a separate file.
type Filters struct {
	Rules Rules `json:"rules" yaml:"rules"`
}

// Rules contains attributes that describe the location of
// rule resources.
type Rules struct {
	FromPaths []string `json:"from-paths" yaml:"from-paths"`
	FromURLs  []string `json:"from-urls" yaml:"from-urls"`
}

const rulesFromPaths = "filters.rules.from-paths"
const rulesFromURLs = "filters.rules.from-urls"

func (f *Filters) initFromViper(v *viper.Viper) {
	f.Rules.FromPaths = v.GetStringSlice(rulesFromPaths)
	f.Rules.FromURLs = v.GetStringSlice(rulesFromURLs)
}

// LoadGroups for each filter group file it decodes the
// groups and ensures the correctness of the yaml file.
func (f Filters) LoadGroups() ([]FilterGroup, error) {
	allGroups := make([]FilterGroup, 0)
	for _, path := range f.Rules.FromPaths {
		log.Infof("loading rules from file %s", path)
		file, err := os.Stat(path)
		if err != nil {
			return nil, fmt.Errorf("couldn't open rule file %s: %v", path, err)
		}
		if file.IsDir() {
			return nil, fmt.Errorf("expected yml file but got directory %s", path)
		}
		// read the file group yaml file and produce
		// the corresponding filter groups from it
		rawConfig, err := ioutil.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("couldn't load rule file: %v", err)
		}
		groups, err := decodeFilterGroups(path, rawConfig)
		if err != nil {
			return nil, err
		}
		allGroups = append(allGroups, groups...)
	}
	for _, url := range f.Rules.FromURLs {
		log.Infof("loading rules from URL %s", url)
		if _, err := u.Parse(url); err != nil {
			return nil, fmt.Errorf("%q is an invalid URL", url)
		}
		//nolint:noctx
		resp, err := http.Get(url)
		if err != nil {
			return nil, fmt.Errorf("cannot fetch rule file from %q: %v", url, err)
		}
		if resp.StatusCode != http.StatusOK {
			_ = resp.Body.Close()
			return nil, fmt.Errorf("got non-ok status code for %q: %s", url,
				http.StatusText(resp.StatusCode))
		}

		var rawConfig bytes.Buffer
		_, err = io.Copy(&rawConfig, resp.Body)
		_ = resp.Body.Close()
		if err != nil {
			return nil, fmt.Errorf("cannot copy rule file from %q: %v", url, err)
		}
		groups, err := decodeFilterGroups(url, rawConfig.Bytes())
		if err != nil {
			return nil, err
		}
		allGroups = append(allGroups, groups...)
	}
	return allGroups, nil
}

func decodeFilterGroups(resource string, b []byte) ([]FilterGroup, error) {
	var out interface{}
	err := yaml.Unmarshal(b, &out)
	if err != nil {
		return nil, fmt.Errorf("%q is invalid yaml file: %v", resource, err)
	}

	rawGroups, ok := out.([]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid rule group "+
			"file %s: expected array(s) of groups", resource)
	}
	// apply validation to each group
	// declared in the yml config file
	for _, group := range rawGroups {
		valid, errs := validate(filterGroupSchema, group)
		if !valid || len(errs) > 0 {
			rawGroup := group
			b, err := yaml.Marshal(&rawGroup)
			if err == nil {
				rawGroup = string(b)
			}
			return nil, fmt.Errorf("invalid rule group: \n\n"+
				"%v in %s: %v", rawGroup, resource, multierror.Wrap(errs...))
		}
	}
	// convert filter action template to
	// base64 before executing the global
	// template. The rendered template yields
	// a yaml payload with template directives
	// expanded
	b, err = encodeFilterActions(b)
	if err != nil {
		return nil, err
	}
	b, err = renderTmpl(resource, b)
	if err != nil {
		return nil, err
	}

	// now unmarshal into typed group slice
	var groups []FilterGroup
	if err := yaml.Unmarshal(b, &groups); err != nil {
		return nil, err
	}
	// try to validate filter action template
	for _, group := range groups {
		err := group.validate(resource)
		if err != nil {
			return nil, err
		}
	}
	return groups, nil
}

// renderTmpl executes templating directives in the
// file group yaml file. It returns the byte slice
// with yaml content after template expansion.
func renderTmpl(filename string, b []byte) ([]byte, error) {
	rawValues, err := unmarshalValues(filename)
	if err != nil {
		return nil, err
	}
	tmpl, err := template.New(filename).Funcs(funcmap.New()).Parse(string(b))
	if err != nil {
		return nil, cleanupParseError(filename, err)
	}
	var w bytes.Buffer
	// force strict keys presence
	tmpl.Option("missingkey=error")
	err = tmpl.Execute(&w, map[string]interface{}{"Values": rawValues})
	if err != nil {
		return nil, cleanupParseError(filename, err)
	}
	return w.Bytes(), nil
}

// unmarshalValues reads the values defined in
// the values.yml file is the file is present
// in the same directory as the filter group yaml file.
func unmarshalValues(filename string) (interface{}, error) {
	path := filepath.Join(filepath.Dir(filename), "values.yml")
	f, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, nil
	}
	var rawValues interface{}
	err = yaml.Unmarshal(f, &rawValues)
	if err != nil {
		return nil, fmt.Errorf("unable to unmarshal yaml: %v", err)
	}
	return rawValues, nil
}

func cleanupParseError(filename string, err error) error {
	if err == nil {
		return nil
	}
	tokens := strings.Split(err.Error(), ": ")
	if len(tokens) < 2 {
		// This might happen if a non-templating error occurs
		return fmt.Errorf("syntax error in (%s): %s", filename, err)
	}
	// The first token is "template"
	// The second token is either "filename:lineno" or "filename:lineNo:columnNo"
	location := tokens[1]
	key := tokens[2]
	i := strings.Index(key, "at")
	if i > 0 {
		key = key[i+3:]
	}
	var errMsg string
	if len(tokens) > 4 {
		errMsg = strings.Join(tokens[3:], ": ")
	} else {
		errMsg = tokens[len(tokens)-1]
	}
	return fmt.Errorf("syntax error in (%s) at %s: %s", location, key, errMsg)
}

// TmplData is the template data object. Some
// fields of this structure represent empty
// values, since we have to satisfy the presence
// of certain keys when executing the template.
type TmplData struct {
	Filter *FilterConfig
	Group  *FilterGroup
	Kevt   *kevent.Kevent
}

func tmplData() TmplData {
	return TmplData{
		Filter: &FilterConfig{},
		Group:  &FilterGroup{},
		Kevt:   kevent.Empty(),
	}
}

const (
	actionNode      = "action"
	defNode         = "def"
	fromStringsNode = "from-strings"
	rulesNode       = "rules"
)

// encodeFilterActions convert the filter action template
// to base64 payload. Because we only want to execute
// the action template when a filter matches in runtime,
// encoding the template to base64 prevents the Go templating
// engine from expanding the template in parse time, when we
// first load all the filter groups.
func encodeFilterActions(buf []byte) ([]byte, error) {
	var yn yaml.Node
	if err := yaml.Unmarshal(buf, &yn); err != nil {
		return nil, err
	}

	// for each group
	for _, n := range yn.Content[0].Content {
		// for each group node
		for i, gn := range n.Content {
			// sequence groups action
			if gn.Value == actionNode && n.Content[i+1].Value != "" {
				n.Content[i+1].Value =
					base64.StdEncoding.EncodeToString([]byte(n.Content[i+1].Value))
			}
			if gn.Value == fromStringsNode {
				log.Warnf("`from-strings` attribute is deprecated and will be " +
					"removed in future versions. Please consider switching to `rules` attribute")
			}
			if gn.Value == fromStringsNode || gn.Value == rulesNode {
				content := n.Content[i+1]
				// for each node in from-strings
				for _, s := range content.Content {
					for j, e := range s.Content {
						if e.Value == defNode {
							log.Warnf("`def` attribute is deprecated and will be " +
								"removed in future versions. Please consider switching to `condition` attribute")
						}
						if e.Value == actionNode && s.Content[j+1].Value != "" {
							s.Content[j+1].Value =
								base64.StdEncoding.EncodeToString([]byte(s.Content[j+1].Value))
						}
					}
				}
			}
		}
	}

	b, err := yaml.Marshal(&yn)
	if err != nil {
		return nil, err
	}
	return b, nil
}

```

`pkg/config/filters_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/httptest"
	"testing"
)

func newFilters(paths ...string) Filters {
	return Filters{
		Rules{
			FromPaths: paths,
		},
	}
}

func TestLoadGroupsFromPaths(t *testing.T) {
	filters := Filters{
		Rules{
			FromPaths: []string{
				"_fixtures/filters/default.yml",
			},
		},
	}
	groups, err := filters.LoadGroups()
	require.NoError(t, err)
	require.Len(t, groups, 2)

	g1 := groups[0]
	assert.Equal(t, "internal network traffic", g1.Name)
	assert.True(t, *g1.Enabled)
	assert.Equal(t, ktypes.Connect, g1.Selector.Type)
	assert.Equal(t, ExcludePolicy, g1.Policy)
	assert.Equal(t, AndRelation, g1.Relation)
	assert.Contains(t, g1.Tags, "TE")
	assert.Len(t, g1.FromStrings, 1)
	assert.Equal(t, "only network category", g1.FromStrings[0].Name)
	assert.Equal(t, "kevt.category = 'net'", g1.FromStrings[0].Def)

	g2 := groups[1]
	assert.Equal(t, "rouge processes", g2.Name)
	assert.True(t, *g2.Enabled)
	assert.Equal(t, ktypes.Net, g2.Selector.Category)
	assert.Equal(t, IncludePolicy, g2.Policy)
	assert.Equal(t, OrRelation, g2.Relation)
	assert.Len(t, g2.FromStrings, 1)
	assert.Equal(t, "suspicious network ACTIVITY", g2.FromStrings[0].Name)
	assert.Equal(t, "kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')", g2.FromStrings[0].Def)
}

func TestLoadGroupsFromPathsNewAttributes(t *testing.T) {
	filters := Filters{
		Rules{
			FromPaths: []string{
				"_fixtures/filters/default-new-attributes.yml",
			},
		},
	}
	groups, err := filters.LoadGroups()
	require.NoError(t, err)
	require.Len(t, groups, 2)

	g1 := groups[0]
	assert.Equal(t, "internal network traffic", g1.Name)
	assert.False(t, *g1.Enabled)
	assert.Equal(t, ktypes.Connect, g1.Selector.Type)
	assert.Equal(t, ExcludePolicy, g1.Policy)
	assert.Equal(t, AndRelation, g1.Relation)
	assert.Contains(t, g1.Tags, "TE")
	assert.Len(t, g1.FromStrings, 1)
	assert.Equal(t, "only network category", g1.FromStrings[0].Name)
	assert.Equal(t, "kevt.category = 'net'", g1.FromStrings[0].Def)

	g2 := groups[1]
	assert.Equal(t, "rouge processes", g2.Name)
	assert.Nil(t, g2.Enabled)
	assert.False(t, g2.IsDisabled())
	assert.Equal(t, ktypes.Net, g2.Selector.Category)
	assert.Equal(t, IncludePolicy, g2.Policy)
	assert.Equal(t, OrRelation, g2.Relation)
	assert.Len(t, g2.Rules, 1)
	assert.Equal(t, "suspicious network ACTIVITY", g2.Rules[0].Name)
	assert.Equal(t, "kevt.category = 'net' and ps.name in ('at.exe', 'java.exe')", g2.Rules[0].Condition)
}

func TestLoadGroupsFromURLs(t *testing.T) {
	mux := http.NewServeMux()
	mux.HandleFunc("/default.yml", func(w http.ResponseWriter, r *http.Request) {
		b, err := ioutil.ReadFile("_fixtures/filters/default.yml")
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		_, _ = w.Write(b)
	})

	l, err := net.Listen("tcp", "127.0.0.1:3231")
	if err != nil {
		t.Fatal(err)
	}
	srv := httptest.NewUnstartedServer(mux)
	srv.Listener = l
	srv.Start()
	defer srv.Close()

	filters := Filters{
		Rules{
			FromURLs: []string{
				"http://localhost:3231/default.yml",
			},
		},
	}
	groups, err := filters.LoadGroups()
	require.NoError(t, err)
	require.Len(t, groups, 2)

	g1 := groups[0]
	assert.Equal(t, "internal network traffic", g1.Name)
	assert.True(t, *g1.Enabled)
	assert.Equal(t, ktypes.Connect, g1.Selector.Type)
}

func TestLoadGroupsInvalidTemplates(t *testing.T) {
	var tests = []struct {
		filters Filters
		errMsg  string
	}{
		{newFilters("_fixtures/filters/invalid_filter_action.yml"), `invalid "suspicious network activity" rule action: syntax error in (suspicious network activity:1) at function "kil" not defined: function "kil" not defined`},
		{newFilters("_fixtures/filters/invalid_filter_action_values.yml"), `invalid "suspicious network activity" rule action: syntax error in (suspicious network activity:1:13) at <.Kevt.Pid>: can't evaluate field Pid in type *kevent.Kevent`},
		{newFilters("_fixtures/filters/filter_action_in_exclude_group.yml"), `"suspicious network activity" rule found in "rouge processes" group with exclude policy. Only groups with include policies can have rule actions`},
	}
	for i, tt := range tests {
		_, err := tt.filters.LoadGroups()
		if err.Error() != tt.errMsg {
			t.Errorf("%d. filter group error mismatch: exp=%s got=%v", i, tt.errMsg, err)
		}
	}
}

func TestLoadGroupsWithValues(t *testing.T) {
	filters := Filters{
		Rules{
			FromPaths: []string{
				"_fixtures/filters/values/default.yml",
			},
		},
	}
	groups, err := filters.LoadGroups()
	require.NoError(t, err)
	require.Len(t, groups, 2)

	g2 := groups[1]
	assert.Equal(t, "kevt.category = 'net' and ps.name in ('at.exe', 'java.exe', 'nc.exe')", g2.FromStrings[0].Def)
}

```

`pkg/config/kstream.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"runtime"
	"strings"
	"time"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/spf13/viper"
)

const (
	enableThreadKevents   = "kstream.enable-thread"
	enableRegistryKevents = "kstream.enable-registry"
	enableNetKevents      = "kstream.enable-net"
	enableFileIOKevents   = "kstream.enable-fileio"
	enableImageKevents    = "kstream.enable-image"
	enableHandleKevents   = "kstream.enable-handle"
	bufferSize            = "kstream.buffer-size"
	minBuffers            = "kstream.min-buffers"
	maxBuffers            = "kstream.max-buffers"
	flushInterval         = "kstream.flush-interval"
	rawEventParsing       = "kstream.raw-event-parsing"

	excludedEvents = "kstream.blacklist.events"
	excludedImages = "kstream.blacklist.images"

	maxBufferSize = uint32(1024)
)

var (
	defaultMinBuffers    = uint32(runtime.NumCPU() * 2)
	defaultMaxBuffers    = defaultMinBuffers + 20
	defaultFlushInterval = time.Second
)

// KstreamConfig stores different configuration options for fine tuning kstream consumer/controller settings.
type KstreamConfig struct {
	// EnableThreadKevents indicates if thread kernel events are collected by the ETW provider.
	EnableThreadKevents bool `json:"enable-thread" yaml:"enable-thread"`
	// EnableRegistryKevents indicates if registry kernel events are collected by the ETW provider.
	EnableRegistryKevents bool `json:"enable-registry" yaml:"enable-registry"`
	// EnableNetKevents determines whether network (TCP/UDP) events are collected by the ETW provider.
	EnableNetKevents bool `json:"enable-net" yaml:"enable-net"`
	// EnableFileIOKevents indicates if file I/O kernel events are collected by the ETW provider.
	EnableFileIOKevents bool `json:"enable-fileio" yaml:"enable-fileio"`
	// EnableImageKevents indicates if image kernel events are collected by the ETW provider.
	EnableImageKevents bool `json:"enable-image" yaml:"enable-image"`
	// EnableHandleKevents indicates whether handle creation/disposal events are enabled.
	EnableHandleKevents bool `json:"enable-handle" yaml:"enable-handle"`
	// BufferSize represents the amount of memory allocated for each event tracing session buffer, in kilobytes.
	// The buffer size affects the rate at which buffers fill and must be flushed (small buffer size requires
	// less memory but it increases the rate at which buffers must be flushed).
	BufferSize uint32 `json:"buffer-size" yaml:"buffer-size"`
	// MinBuffers determines the minimum number of buffers allocated for the event tracing session's buffer pool.
	MinBuffers uint32 `json:"min-buffers" yaml:"min-buffers"`
	// MaxBuffers is the maximum number of buffers allocated for the event tracing session's buffer pool.
	MaxBuffers uint32 `json:"max-buffers" yaml:"max-buffers"`
	// FlushTimer specifies how often the trace buffers are forcibly flushed.
	FlushTimer time.Duration `json:"flush-interval" yaml:"flush-interval"`
	// ExcludedKevents are kernel event names that will be dropped from the kernel event stream.
	ExcludedKevents []string `json:"blacklist.events" yaml:"blacklist.events"`
	// ExcludedImages are process image names that will be rejected if they generate a kernel event.
	ExcludedImages []string `json:"blacklist.images" yaml:"blacklist.images"`

	// RawEventParsing indicates if raw event buffer parsing is enabled
	RawEventParsing bool `json:"raw-param-parsing" yaml:"raw-event-parsing"`

	excludedKtypes map[ktypes.Ktype]bool
	excludedImages map[string]bool
}

func (c *KstreamConfig) initFromViper(v *viper.Viper) {
	c.EnableThreadKevents = v.GetBool(enableThreadKevents)
	c.EnableRegistryKevents = v.GetBool(enableRegistryKevents)
	c.EnableNetKevents = v.GetBool(enableNetKevents)
	c.EnableFileIOKevents = v.GetBool(enableFileIOKevents)
	c.EnableImageKevents = v.GetBool(enableImageKevents)
	c.EnableHandleKevents = v.GetBool(enableHandleKevents)
	c.BufferSize = uint32(v.GetInt(bufferSize))
	c.MinBuffers = uint32(v.GetInt(minBuffers))
	c.MaxBuffers = uint32(v.GetInt(maxBuffers))
	c.FlushTimer = v.GetDuration(flushInterval)
	c.ExcludedKevents = v.GetStringSlice(excludedEvents)
	c.ExcludedImages = v.GetStringSlice(excludedImages)
	c.RawEventParsing = v.GetBool(rawEventParsing)

	c.excludedKtypes = make(map[ktypes.Ktype]bool)
	c.excludedImages = make(map[string]bool)

	for _, name := range c.ExcludedKevents {
		if ktype := ktypes.KeventNameToKtype(name); ktype != ktypes.UnknownKtype {
			c.excludedKtypes[ktype] = true
		}
	}
	for _, name := range c.ExcludedImages {
		c.excludedImages[strings.ToLower(name)] = true
	}
}

// Init is an exported method to allow initializing exclusion maps from external modules.
func (c *KstreamConfig) Init() {
	c.excludedKtypes = make(map[ktypes.Ktype]bool)
	c.excludedImages = make(map[string]bool)

	for _, name := range c.ExcludedKevents {
		if ktype := ktypes.KeventNameToKtype(name); ktype != ktypes.UnknownKtype {
			c.excludedKtypes[ktype] = true
		}
	}
	for _, name := range c.ExcludedImages {
		c.excludedImages[name] = true
	}
}

// ExcludeKevent determines whether the supplied event is present in the list of
// excluded event types.
func (c *KstreamConfig) ExcludeKevent(kevt *kevent.Kevent) bool {
	return c.excludedKtypes[kevt.Type]
}

// ExcludeImage determines whether the process generating event is present in the
// list of excluded images. If the hit occurs, the event associated with the process
// is dropped.
func (c *KstreamConfig) ExcludeImage(ps *pstypes.PS) bool {
	if len(c.excludedImages) == 0 {
		return false
	}
	if ps == nil {
		return false
	}
	return c.excludedImages[ps.Name]
}

```

`pkg/config/kstream_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"testing"

	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestKstreamConfig(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{
		"--kstream.enable-thread=false",
		"--kstream.enable-registry=false",
		"--kstream.enable-fileio=false",
		"--kstream.enable-net=false",
		"--kstream.enable-image=false",
		"--kstream.blacklist.events=CloseFile,CloseHandle",
		"--kstream.blacklist.images=System,svchost.exe",
	})
	require.NoError(t, err)
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)

	require.NoError(t, c.Init())

	assert.False(t, c.Kstream.EnableThreadKevents)
	assert.False(t, c.Kstream.EnableNetKevents)
	assert.False(t, c.Kstream.EnableRegistryKevents)
	assert.False(t, c.Kstream.EnableImageKevents)
	assert.False(t, c.Kstream.EnableFileIOKevents)

	assert.True(t, c.Kstream.ExcludeKevent(&kevent.Kevent{Type: ktypes.CloseHandle}))
	assert.False(t, c.Kstream.ExcludeKevent(&kevent.Kevent{Type: ktypes.CreateProcess}))

	assert.True(t, c.Kstream.ExcludeImage(&pstypes.PS{Name: "svchost.exe"}))
	assert.False(t, c.Kstream.ExcludeImage(&pstypes.PS{Name: "explorer.exe"}))
}

```

`pkg/config/output.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"errors"
	"fmt"
	"reflect"
	"strconv"

	"github.com/rabbitstack/fibratus/pkg/outputs/eventlog"

	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/console"
	"github.com/rabbitstack/fibratus/pkg/outputs/elasticsearch"
	"github.com/rabbitstack/fibratus/pkg/outputs/http"
	"github.com/rabbitstack/fibratus/pkg/outputs/null"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows/svc"
)

var errNoOutputSection = errors.New("no output section in config")

var errOutputConfig = func(output string, err error) error { return fmt.Errorf("%s output invalid config: %v", output, err) }

func (c *Config) tryLoadOutput() error {
	output := c.viper.AllSettings()["output"]
	if output == nil {
		return errNoOutputSection
	}
	mapping, ok := output.(map[string]interface{})
	if !ok {
		return fmt.Errorf("expected map[string]interface{} type for output but found %s", reflect.TypeOf(output))
	}

	humNum := func(n int) string {
		switch n {
		case 2:
			return "two"
		case 3:
			return "three"
		case 4:
			return "four"
		case 5:
			return "five"
		case 6:
			return "six"
		case 7:
			return "seven"
		default:
			return strconv.Itoa(n)
		}
	}
	// don't permit if there are various outputs enabled at a time
	activeOutputs := findActiveOutputs(mapping)
	if len(activeOutputs) > 1 {
		return fmt.Errorf("expected one but found %s active outputs: %s", humNum(len(activeOutputs)), activeOutputs)
	}

	for typ, config := range mapping {
		switch outputs.TypeFromString(typ) {
		case outputs.Console:
			var consoleConfig console.Config
			if err := decode(config, &consoleConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !consoleConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.Console, consoleConfig

		case outputs.AMQP:
			var amqpConfig amqp.Config
			if err := decode(config, &amqpConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !amqpConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.AMQP, amqpConfig

		case outputs.Elasticsearch:
			var esConfig elasticsearch.Config
			if err := decode(config, &esConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !esConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.Elasticsearch, esConfig

		case outputs.HTTP:
			var httpConfig http.Config
			if err := decode(config, &httpConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !httpConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.HTTP, httpConfig

		case outputs.Eventlog:
			var eventlogConfig eventlog.Config
			if err := decode(config, &eventlogConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !eventlogConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.Eventlog, eventlogConfig
		}
	}

	// if it is not an interactive session but the console output is enabled
	// we default to null output and warn about that
	if isWindowsService() && c.Output.Output != nil {
		if c.Output.Type == outputs.Console {
			log.Warn("running in non-interactive session with console output. " +
				"Please configure a different output type. Defaulting to null output")
			c.Output.Type, c.Output.Output = outputs.Null, &null.Config{}
			return nil
		}
	}

	// default to null output
	if c.Output.Output == nil {
		log.Warn("all outputs disabled. Defaulting to null output")
		c.Output.Type, c.Output.Output = outputs.Null, &null.Config{}
	}

	return nil
}

func findActiveOutputs(outputs map[string]interface{}) []string {
	outputTypes := make([]string, 0)
	for typ, rawConfig := range outputs {
		enabled, ok := rawConfig.(map[string]interface{})["enabled"].(bool)
		if ok && enabled {
			outputTypes = append(outputTypes, typ)
		}
	}
	return outputTypes
}

// isWindowsService returns true if the process is running inside Windows Service.
func isWindowsService() bool {
	interactive, err := svc.IsAnInteractiveSession()
	if err != nil {
		return false
	}
	return !interactive
}

```

`pkg/config/output_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/outputs/eventlog"

	"github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/http"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestAMQPOutput(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/output.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.NotNil(t, c.Output)
	require.IsType(t, amqp.Config{}, c.Output.Output)

	amqpConfig := c.Output.Output.(amqp.Config)
	assert.Equal(t, "amqp://localhost:5672", amqpConfig.URL)
	assert.Equal(t, time.Second*5, amqpConfig.Timeout)
	assert.Equal(t, "fibratus", amqpConfig.Exchange)
	assert.Equal(t, "topic", amqpConfig.ExchangeType)
	assert.Equal(t, "fibratus", amqpConfig.RoutingKey)
	assert.Equal(t, "/", amqpConfig.Vhost)
}

func TestHTTPOutput(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/http-output.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.NotNil(t, c.Output)
	require.IsType(t, http.Config{}, c.Output.Output)

	httpConfig := c.Output.Output.(http.Config)
	assert.True(t, httpConfig.Enabled)
	assert.Len(t, httpConfig.Endpoints, 2)
	assert.Contains(t, httpConfig.Endpoints, "http://localhost:8081")
	assert.Equal(t, time.Second*2, httpConfig.Timeout)
	assert.Equal(t, "http://192.168.1.8:3123", httpConfig.ProxyURL)
	assert.Equal(t, "bunny", httpConfig.ProxyUsername)
	assert.Equal(t, "bunny", httpConfig.ProxyPassword)
	assert.True(t, httpConfig.EnableGzip)
	assert.Equal(t, "basic", httpConfig.Username)
	assert.Equal(t, "basic", httpConfig.Password)
	assert.Len(t, httpConfig.Headers, 2)
	assert.Equal(t, "kkvvkk", httpConfig.Headers["api-key"])
}

func TestEventlogOutput(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/eventlog-output.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.NotNil(t, c.Output)
	require.IsType(t, eventlog.Config{}, c.Output.Output)

	eventlogConfig := c.Output.Output.(eventlog.Config)
	assert.True(t, eventlogConfig.Enabled)
	assert.Equal(t, "INFO", eventlogConfig.Level)
}

```

`pkg/config/print.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"bytes"
	"fmt"
	"reflect"
	"sort"
	"strings"
)

func (c *Config) printArray(arr []interface{}) string {
	var buffer bytes.Buffer
	for v := range arr {
		buffer.WriteString(fmt.Sprintf("%v;", v))
	}
	return buffer.String()
}

func (c *Config) printMap(m map[string]interface{}) string {
	var buffer bytes.Buffer
	buffer.WriteString("[")
	for k, v := range m {
		val := c.print(v)
		if len(val) > 0 {
			buffer.WriteString(" ")
			buffer.WriteString(k)
			buffer.WriteString("=>")
			if strings.Contains(k, "password") {
				buffer.WriteString("********")
			} else {
				buffer.WriteString(val)
			}
		}
	}
	buffer.WriteString("]")
	return buffer.String()
}

func (c *Config) print(value interface{}) string {
	t := reflect.TypeOf(value)
	switch t.Kind() {
	case reflect.Array:
		return c.printArray(value.([]interface{}))
	case reflect.Map:
		return c.printMap(value.(map[string]interface{}))
	default:
		return fmt.Sprintf("%v", value)
	}
}

func (c *Config) printLine(buffer *bytes.Buffer, maxLength int, key string, value string) {
	if value != "" {
		buffer.WriteString("\n\t")
		buffer.WriteString(key)
		buffer.WriteString(" ")
		buffer.WriteString(strings.Repeat(".", maxLength-len(key)+5))
		buffer.WriteString(" ")
		buffer.WriteString(value)
	}
}

// Print returns the string with all the config options pretty-printed.
func (c *Config) Print() string {
	opts := c.viper.AllSettings()

	var buffer bytes.Buffer
	var maxKeyLen = 20

	type kv struct {
		k string
		v interface{}
	}

	sorted := make([]kv, 0, len(opts))
	// for printing we need to find the max key length
	for key, v := range opts {
		if len(key) > maxKeyLen {
			maxKeyLen = len(key)
		}
		sorted = append(sorted, kv{k: key, v: v})
	}
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].k < sorted[j].k })

	// print the options
	for _, kv := range sorted {
		c.printLine(&buffer, maxKeyLen, kv.k, c.print(kv.v))
	}

	return buffer.String()
}

```

`pkg/config/print_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestConfigPrint(t *testing.T) {
	c := NewWithOpts(WithRun())
	err := c.flags.Parse([]string{"--kstream.enable-thread=false", "--config-file=_fixtures/fibratus.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))
	opts := c.Print()
	require.NotEmpty(t, opts)
}

```

`pkg/config/schema_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"bytes"
	"text/template"
)

var schema = `
{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"definitions": {"yara": {"$id": "#yara", "type": "object", "properties": {"enabled": {"type": "boolean"}}}},

	"type": "object",
	"properties": {
		"aggregator": {
			"type": "object",
			"properties": {
				"flush-period":		{"type": "string", "minLength": 2, "pattern": "[0-9]+ms|s"},
				"flush-timeout":	{"type": "string", "minLength": 2, "pattern": "[0-9]+s"}
			},
			"additionalProperties": false
		},
		"alertsenders": {
			"type": "object",
			"anyOf": [{
					"properties": {
						"mail": {
							"type": "object",
							"properties": {
								"enabled": 		{"type": "boolean"},
								"host": 		{"type": "string"},
								"port": 		{"type": "number"},
								"user": 		{"type": "string"},
								"password": 	{"type": "string"},
								"from": 		{"type": "string"},
								"to": 			{"type": "array", "items": {"type": "string", "format": "email"}}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {
									"from": {"type": "string", "format": "email"},
									"to": 	{"type": "array", "minItems": 1, "items": {"type": "string", "format": "email"}}
								}
							},
							"additionalProperties": false
						},
						"slack": {
							"type": "object",
							"properties": {
								"enabled": 		{"type": "boolean"},
								"url": 			{"type": "string"},
								"workspace": 	{"type": "string"},
								"channel": 		{"type": "string"},
								"emoji": 		{"type": "string"}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {"url": {"type": "string", "format": "uri", "minLength": 1, "pattern": "^(https?|http?)://"}}
							},
							"additionalProperties": false
						}
					},
					"additionalProperties": false
				}
			]
		},
		"api": {
			"type": "object",
			"properties": {
				"transport": 		{"type": "string", "minLength": 3},
				"timeout":			{"type": "string", "minLength": 2, "pattern": "[0-9]+s"}
			},
			"additionalProperties": false
		},
		"config-file": 		{"type": "string"},
		"debug-privilege":  {"type": "boolean"},
		"handle": {
			"type": "object",
			"properties": {
				"init-snapshot": 		{"type": "boolean"}
			},
			"additionalProperties": false
		},
		"kcap": {
			"type": "object",
			"properties": {
				"file":				{"type": "string"}
			},
			"additionalProperties": false
		},
		"filament": {
			"type": "object",
			"properties": {
				"name":				{"type": "string"},
				"path":				{"type": "string"},
				"flush-period":		{"type": "string",  "minLength": 2, "pattern": "[0-9]+ms|s"}
			},
			"additionalProperties": false
		},
		"filters": {
			"type": "object",
			"properties": {
				"rules": {
					"type": "object",
					"properties": {
						"from-paths": 	{"type": ["array", "null"], "items": [{"type": "string", "minLength": 4}]},
						"from-urls":	{"type": ["array", "null"], "items": [{"type": "string", "minLength": 8}]}
					},
					"additionalProperties": false
				}
			},
			"additionalProperties": false
		},
		"kevent": {
			"type": "object",
			"properties": {
				"serialize-threads":	{"type": "boolean"},
				"serialize-images":		{"type": "boolean"},
				"serialize-handles":	{"type": "boolean"},
				"serialize-pe":			{"type": "boolean"},
				"serialize-envs":		{"type": "boolean"}
			},
			"additionalProperties": false
		},
		"kstream": {
			"type": "object",
			"properties": {
				"enable-thread": 	{"type": "boolean"},
				"enable-image": 	{"type": "boolean"},
				"enable-registry": 	{"type": "boolean"},
				"enable-fileio": 	{"type": "boolean"},
				"enable-handle": 	{"type": "boolean"},
				"enable-net": 		{"type": "boolean"},
				"raw-event-parsing":{"type": "boolean"},
				"min-buffers": 		{"type": "integer", "minimum": 1, "maximum": {{ .MinBuffers }}},
				"max-buffers": 		{"type": "integer", "minimum": 2, "maximum": {{ .MaxBuffers }}},
				"buffer-size":		{"type": "integer", "maximum": {{ .MaxBufferSize }}},
                "flush-interval":	{"type": "string", "minLength": 2, "pattern": "[0-9]+s"},
				"blacklist":		{
					"type": "object",
					"properties":	{
						"events":	{"type": "array", "items": [{"type": "string", "enum": ["CreateProcess", "CreateThread", "TerminateProcess", "TerminateThread", "OpenProcess", "OpenThread", "LoadImage", "UnloadImage", "CreateFile", "CloseFile", "ReadFile", "WriteFile", "DeleteFile", "RenameFile", "SetFileInformation", "EnumDirectory", "RegCreateKey", "RegOpenKey", "RegSetValue", "RegQueryValue", "RegQueryKey", "RegDeleteKey", "RegDeleteValue", "Accept", "Send", "Recv", "Connect", "Disconnect", "Reconnect", "Retransmit", "CreateHandle", "CloseHandle"]}]},
						"images":	{"type": "array", "items": [{"type": "string", "minLength": 1}]}
					},
					"additionalProperties": false
				}
			},
			"additionalProperties": false
		},
		"logging": {
			"type": "object",
			"properties": {
				"level": 			{"type": "string"},
				"max-age":			{"type": "integer"},
				"max-backups":		{"type": "integer", "minimum": 1},
				"max-size":			{"type": "integer", "minimum": 1},
				"formatter":		{"type": "string", "enum": ["json", "text"]},
				"path":				{"type": "string"},
				"log-stdout":		{"type": "boolean"}
			},
			"additionalProperties": false
		},
		"output": {
			"type": "object",
			"anyOf": [{
					"properties": {
						"console": {
							"type": "object",
							"properties": {
								"enabled":		{"type": "boolean"},
								"format": 		{"type": "string", "enum": ["json", "pretty"]},
								"template": 	{"type": "string"},
								"kv-delimiter": {"type": "string"}
							},
							"additionalProperties": false
						},
						"elasticsearch": {
							"type": "object",
							"properties": {
								"enabled":					{"type": "boolean"},
								"servers": 					{"type": "array", "items": [{"type": "string", "minItems": 1, "format": "uri", "minLength": 1, "maxLength": 255, "pattern": "^(https?|http?)://"}]},
								"timeout": 					{"type": "string"},
								"index-name":				{"type": "string", "minLength": 1},
								"template-config":			{"type": "string"},
								"template-name":			{"type": "string", "minLength": 1},
								"healthcheck": 				{"type": "boolean"},
								"bulk-workers":				{"type": "integer", "minimum": 1},
								"sniff": 					{"type": "boolean"},
								"trace-log": 				{"type": "boolean"},
								"gzip-compression": 		{"type": "boolean"},
								"healthcheck-interval":		{"type": "string", "minLength": 2, "pattern": "[0-9]+s|m}"},
								"healthcheck-timeout":		{"type": "string", "minLength": 2, "pattern": "[0-9]+s|m}"},
								"flush-period":				{"type": "string", "minLength": 2, "pattern": "[0-9]+s|m}"},
								"username": 				{"type": "string"},
								"password": 				{"type": "string"},
								"tls-key": 					{"type": "string"},
								"tls-cert": 				{"type": "string"},
								"tls-ca": 					{"type": "string"},
								"tls-insecure-skip-verify": {"type": "boolean"}
							},
							"additionalProperties": false
						},
						"amqp": {
							"type": "object",
							"properties": {
								"enabled":					{"type": "boolean"},
								"url": 						{"type": "string", "format": "uri", "minLength": 1, "maxLength": 255, "pattern": "^(amqps?|amqp?)://"},
								"timeout": 					{"type": "string", "minLength": 2, "pattern": "[0-9]+s|m}"},
								"exchange": 				{"type": "string", "minLength": 1},
								"exchange-type": 			{"type": "string", "enum": ["direct", "topic", "fanout", "header", "x-consistent-hash"]},
								"routing-key": 				{"type": "string", "minLength": 1},
								"delivery-mode": 			{"type": "string", "enum": ["transient", "persistent"]},
								"vhost": 					{"type": "string", "minLength": 1},
								"passive": 					{"type": "boolean"},
								"durable": 					{"type": "boolean"},
								"username": 				{"type": "string"},
								"password": 				{"type": "string"},
								"tls-key": 					{"type": "string"},
								"tls-cert": 				{"type": "string"},
								"tls-ca": 					{"type": "string"},
								"tls-insecure-skip-verify": {"type": "boolean"},
								"headers":					{"type": "object", "additionalProperties": true}
							},
							"additionalProperties": false
						},
						"http": {
							"type": "object",
							"properties": {
								"enabled":					{"type": "boolean"},
								"endpoints": 				{"type": "array", "items": [{"type": "string", "minItems": 1, "format": "uri", "minLength": 1, "maxLength": 255, "pattern": "^(https?|http?)://"}]},
								"timeout": 					{"type": "string", "minLength": 2, "pattern": "[0-9]+s|m}"},
								"method": 					{"type": "string", "enum": ["POST", "PUT"]},
								"serializer": 				{"type": "string", "enum": ["json"]},
								"enable-gzip": 				{"type": "boolean"},
								"proxy-url": 				{"type": "string"},
								"proxy-username": 			{"type": "string"},
								"proxy-password": 			{"type": "string"},
								"username": 				{"type": "string"},
								"password": 				{"type": "string"},
								"tls-key": 					{"type": "string"},
								"tls-cert": 				{"type": "string"},
								"tls-ca": 					{"type": "string"},
								"tls-insecure-skip-verify": {"type": "boolean"},
								"headers":					{"type": "object", "additionalProperties": true}
							},
							"additionalProperties": false
						},
						"eventlog": {
							"type": "object",
							"properties": {
								"enabled":					{"type": "boolean"},
								"level": 					{"type": "string", "enum": ["INFO", "info", "warn", "warning", "WARN", "WARNING", "error", "erro", "ERROR", "ERRO"]},
								"remote-host": 				{"type": "string"},
								"template": 				{"type": "string"}
							},
							"additionalProperties": false
						}
					},
					"additionalProperties": false
				}
			]
		},
		"pe": {
			"type": "object",
			"properties": {
				"enabled":			{"type": "boolean"},
				"read-resources":	{"type": "boolean"},
				"read-symbols":		{"type": "boolean"},
				"read-sections":	{"type": "boolean"},
				"excluded-images":  {"type": "array", "items": [{"type": "string"}]}
			},
			"additionalProperties": false
		},
		"transformers": {
			"type": "object",
			"anyOf": [{
					"properties": {
						"remove": {
							"type": "object",
							"properties": {
								"enabled":  {"type": "boolean"},
								"kparams": 	{"type": "array", "items": [{"type": "string"}]}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {"kparams": 	{"type": "array", "minItems": 1, "items": [{"type": "string"}]}}
							},
							"additionalProperties": false
						},
						"rename": {
							"type": "object",
							"properties": {
								"enabled":  {"type": "boolean"},
								"kparams": 	{"type": "array", "items": [
														{
															"type": "object",
															"properties": {
																"old": {"type": "string", "minLength": 1},
																"new": {"type": "string", "minLength": 1}
															},
															"additionalProperties": false
														}
								]}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {"kparams": {"minItems": 1}}
							},
							"additionalProperties": false
						},
						"replace": {
							"type": "object",
							"properties": {
								"enabled":  		{"type": "boolean"},
								"replacements": 	{"type": "array", "items": [
														{
															"type": "object",
															"properties": {
																"kparam": 	{"type": "string", "minLength": 1},
																"old": 		{"type": "string", "minLength": 1},
																"new": 		{"type": "string"}
															},
															"additionalProperties": false
														}
								]}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {"replacements": 	{"minItems": 1}}
							},
							"additionalProperties": false
						},
						"tags": {
							"type": "object",
							"properties": {
								"enabled":  {"type": "boolean"},
								"tags": 	{"type": "array", "items": [
														{
															"type": "object",
															"properties": {
																"key": 	 {"type": "string", "minLength": 1},
																"value": {"type": "string", "minLength": 1}
															},
															"additionalProperties": false
														}
								]}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {"tags": 	{"minItems": 1}}
							},
							"additionalProperties": false
						},
						"trim": {
							"type": "object",
							"properties": {
								"enabled":  		{"type": "boolean"},
								"prefixes": 		{"type": "array", "items": [
														{
															"type": "object",
															"properties": {
																"kparam": 	{"type": "string", "minLength": 1},
																"trim": 	{"type": "string", "minLength": 1}
															},
															"additionalProperties": false
														}
								]},
								"suffixes": 		{"type": "array", "items": [
														{
															"type": "object",
															"properties": {
																"kparam": 	{"type": "string", "minLength": 1},
																"trim": 	{"type": "string", "minLength": 1}
															},
															"additionalProperties": false
														}
								]}
							},
							"if": {
								"properties": {"enabled": { "const": true }}
							},
							"then": {
								"properties": {"suffixes": 	{"minItems": 1}, "prefixes": {"minItems": 1}}
							},
							"additionalProperties": false
						}
					},
					"additionalProperties": false
				}
			]
		},
		"yara": {
			"type": "object",
			"properties": {
				"enabled":			{"type": "boolean"},
				"rule":				{
					"type": "object",
					"anyOf": [{
						"properties": {
							"paths":  {"type": "array", "items": [
											{
												"type": "object",
												"properties": {
													"path": 		{"type": "string"},
													"namespace": 	{"type": "string"}
												},
												"if": {
													"properties": {"enabled": {"$ref": "#yara", "const": true }}
												},
												"then": {
													"properties": {"path": 	{"minLength": 0}}
												},
												"additionalProperties": false
											}]
                	                     },
							"strings": 	{"type": "array"}
						},
						"additionalProperties": false
					}]
				},
				"alert-via":		{"type": "string", "enum": ["slack", "mail"]},
				"alert-template":   {
						"type": 		"object",
						"properties": {
							"text":	 	{"type": "string"},
							"title": 	{"type": "string"}
						},
						"additionalProperties": false
				},
				"fastscan":			{"type": "boolean"},
				"skip-files":		{"type": "boolean"},
				"scan-timeout":		{"type": "string", "minLength": 2, "pattern": "[0-9]+s"},
				"excluded-files":	{"type": "array", "items": [{"type": "string", "minLength": 1}]},
				"excluded-procs":	{"type": "array", "items": [{"type": "string", "minLength": 1}]}
			},
			"additionalProperties": false
		}
	},
	"additionalProperties": false
}
`

var filterGroupSchema = `
{
	"$schema": "http://json-schema.org/draft-07/schema#",
    "definitions": {"rules": {"$id": "#rules", "type": "object", "type": "array",
			"items":
				{
					"type": "object",
					"properties": {
						"name": 		{"type": "string", "minLength": 3},
						"def": 			{"type": "string", "minLength": 3},
						"condition": 	{"type": "string", "minLength": 3},
						"action": 		{"type": "string"},
						"max-span": 	{"type": "string", "minLength": 2, "pattern": "[0-9]+ms|s|m|h|d"}
					},
					"oneOf": [
						{"required": ["def"]},
						{"required": ["condition"]}
					],
					"required": ["name"],
					"minItems": 1,
					"additionalProperties": false
				}}},


	"type": "object",
	"properties": {
		"group": {"type": "string", "minLength": 1},
		"selector": {
			"type": "object",
			"properties": {
				"type":		{"type": "string", "enum": ["CreateProcess", "CreateThread", "TerminateProcess", "TerminateThread", "OpenProcess", "OpenThread", "LoadImage", "UnloadImage", "CreateFile", "CloseFile", "ReadFile", "WriteFile", "DeleteFile", "RenameFile", "SetFileInformation", "EnumDirectory", "RegCreateKey", "RegOpenKey", "RegSetValue", "RegQueryValue", "RegQueryKey", "RegDeleteKey", "RegDeleteValue", "Accept", "Send", "Recv", "Connect", "Disconnect", "Reconnect", "Retransmit", "CreateHandle", "CloseHandle"]},
				"category": {"type": "string", "enum": ["registry", "file", "net", "process", "thread", "image", "handle"]}
			},
			"additionalProperties": false,
			"oneOf": [
				{"required": ["type"]},
				{"required": ["category"]}
			]
		},
		"enabled":  	{"type": "boolean"},
		"policy":   	{"type": "string", "enum": ["include", "exclude", "sequence", "INCLUDE", "EXCLUDE", "SEQUENCE"]},
		"relation": 	{"type": "string", "enum": ["or", "and", "OR", "AND"]},
		"tags":			{"type": "array", "items": [{"type": "string", "minLength": 1}]},
		"action":       {"type": "string"},
		"from-strings": {"$ref": "#rules"},
		"rules": 		{"$ref": "#rules"}
	},
	"if": {
		"properties": {"policy": {"const": "sequence" }}
	},
	"then": {
		"required": ["group"],
		"oneOf": [
			{"required": ["from-strings"]},
			{"required": ["rules"]}
		]
	},
	"else": {
		"required": ["group", "selector"],
		"oneOf": [
			{"required": ["from-strings"]},
			{"required": ["rules"]}
		]
	},
	"additionalProperties": false
}
`

type schemaConfig struct {
	MaxBuffers    uint32
	MinBuffers    uint32
	MaxBufferSize uint32
}

func interpolateSchema() string {
	tmpl := template.Must(template.New("schema").Parse(schema))

	var b bytes.Buffer
	err := tmpl.Execute(&b, &schemaConfig{
		MaxBuffers:    defaultMaxBuffers,
		MinBuffers:    defaultMinBuffers,
		MaxBufferSize: maxBufferSize,
	})
	if err != nil {
		return ""
	}

	return b.String()
}

```

`pkg/config/transformer.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/remove"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/replace"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/tags"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/trim"
	"reflect"
)

var errTransformerConfig = func(t string, err error) error { return fmt.Errorf("%s transformer invalid config: %v", t, err) }

func (c *Config) tryLoadTransformers() error {
	transforms := c.viper.AllSettings()["transformers"]
	if transforms == nil {
		return nil
	}
	mapping, ok := transforms.(map[string]interface{})
	if !ok {
		return fmt.Errorf("expected map[string]interface{} type for transformers but found %s", reflect.TypeOf(transforms))
	}

	configs := make([]transformers.Config, 0)

	for typ, config := range mapping {
		switch typ {
		case "remove":
			var removeConfig remove.Config
			if err := decode(config, &removeConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !removeConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Remove,
				Transformer: removeConfig,
			}
			configs = append(configs, config)

		case "rename":
			var renameConfig rename.Config
			if err := decode(config, &renameConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !renameConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Rename,
				Transformer: renameConfig,
			}
			configs = append(configs, config)

		case "replace":
			var replaceConfig replace.Config
			if err := decode(config, &replaceConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !replaceConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Replace,
				Transformer: replaceConfig,
			}
			configs = append(configs, config)

		case "trim":
			var trimConfig trim.Config
			if err := decode(config, &trimConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !trimConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Trim,
				Transformer: trimConfig,
			}
			configs = append(configs, config)

		case "tags":
			var tagsConfig tags.Config
			if err := decode(config, &tagsConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !tagsConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Tags,
				Transformer: tagsConfig,
			}
			configs = append(configs, config)
		}
	}

	c.Transformers = configs

	return nil
}

```

`pkg/config/transformer_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTransformers(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/transformers.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.Len(t, c.Transformers, 3)
}

```

`pkg/config/validation.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"fmt"
	"github.com/pkg/errors"
	"github.com/xeipuuv/gojsonschema"
)

func validate(s string, m interface{}) (bool, []error) {
	converted, err := convertToStringKeysRecursive(m, "")
	if err != nil {
		return false, []error{fmt.Errorf("fail to convert keys to string: %v", err)}
	}
	loader := gojsonschema.NewGoLoader(converted)
	sc := gojsonschema.NewStringLoader(s)
	r, err := gojsonschema.Validate(sc, loader)
	if err != nil {
		return false, []error{fmt.Errorf("fail to validate file through schema: %v", err)}
	}
	errs := make([]error, len(r.Errors()))
	for i, err := range r.Errors() {
		errs[i] = errors.New(err.String())
	}
	return r.Valid(), errs
}

// convertToStringKeysRecursive ensures keys are converted to strings for jsonschema.
func convertToStringKeysRecursive(value interface{}, keyPrefix string) (interface{}, error) {
	if mapping, ok := value.(map[string]interface{}); ok {
		dict := make(map[string]interface{})
		for str, entry := range mapping {
			var newKeyPrefix string
			if keyPrefix == "" {
				newKeyPrefix = str
			} else {
				newKeyPrefix = fmt.Sprintf("%s.%s", keyPrefix, str)
			}
			convertedEntry, err := convertToStringKeysRecursive(entry, newKeyPrefix)
			if err != nil {
				return nil, err
			}
			dict[str] = convertedEntry
		}
		return dict, nil
	}
	if mapping, ok := value.(map[interface{}]interface{}); ok {
		dict := make(map[string]interface{})
		for key, entry := range mapping {
			str, ok := key.(string)
			if !ok {
				return nil, formatInvalidKeyError(keyPrefix, key)
			}
			var newKeyPrefix string
			if keyPrefix == "" {
				newKeyPrefix = str
			} else {
				newKeyPrefix = fmt.Sprintf("%s.%s", keyPrefix, str)
			}
			convertedEntry, err := convertToStringKeysRecursive(entry, newKeyPrefix)
			if err != nil {
				return nil, err
			}
			dict[str] = convertedEntry
		}
		return dict, nil
	}
	if list, ok := value.([]interface{}); ok {
		var convertedList []interface{}
		for index, entry := range list {
			newKeyPrefix := fmt.Sprintf("%s[%d]", keyPrefix, index)
			convertedEntry, err := convertToStringKeysRecursive(entry, newKeyPrefix)
			if err != nil {
				return nil, err
			}
			convertedList = append(convertedList, convertedEntry)
		}
		return convertedList, nil
	}
	return value, nil
}

func formatInvalidKeyError(keyPrefix string, key interface{}) error {
	var location string
	if keyPrefix == "" {
		location = "at top level"
	} else {
		location = fmt.Sprintf("in %s", keyPrefix)
	}
	return errors.Errorf("non-string key %s: %#v", location, key)
}

```

`pkg/config/validation_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"gopkg.in/yaml.v3"
	"testing"
)

func TestValidate(t *testing.T) {
	var tests = []struct {
		text  string
		valid bool
		errs  int
	}{
		{text: `aggregator:
                 flush-period: 20ms
                 flush-timeout: 1s`, valid: true},
		{text: `aggregator:
                 flush-period: 20
                 flush-timeout: 1s`, valid: false, errs: 1},
		{text: `aggregator:
                 flush-perio: 20ms
                 flush-timeout: 1`, valid: false, errs: 2},

		{text: `alertsenders:
                 mail: 
                  enabled: true
                  host: smtp.gmail.com
                  port: 465
                  user: user
                  password: pas$
                  from: from@mail.com
                  to:
                   - to@mail.com
                 slack:
                  enabled: true
                  url: https://slack.url
                  workspace: fibratus
                  channel: fibratus
                  emoji: ""`, valid: true},
		{text: `alertsenders:
                 mail: 
                  enabled: true
                  host: smtp.gmail.com
                  port: 
                  user: user
                  pass: pas$
                  from: from@mail.com
                  to:
                   - invalidmail@
                 slack:
                  enabled: true
                  url: https://slack.url
                  workspace: fibratus
                  channel: fibratus
                  emoji: ""`, valid: false, errs: 6},
		{text: `api:
                 transport: "" 
                 timeout: 1s`, valid: false, errs: 1},
	}

	for i, tt := range tests {
		var m interface{}
		err := yaml.Unmarshal([]byte(tt.text), &m)
		if err != nil {
			t.Fatal(err)
		}
		valid, errs := validate(interpolateSchema(), m)
		if valid != tt.valid {
			t.Errorf("%d. valid mismatch: text=%q exp=%#v got=%#v errs=%#v", i, tt.text, tt.valid, valid, errs)
		} else if len(errs) != tt.errs {
			t.Errorf("%d. error count mismatch: text=%q exp=%#v got=%#v errs=%#v", i, tt.text, tt.errs, len(errs), errs)
		}
	}
}

```

`pkg/errors/errors.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package errors

import (
	"errors"
	"fmt"
)

var (
	// ErrCancelUpstreamKevent represents the error that is returned to denote that event is not going to be passed to upstream components such as aggregator or outputs
	ErrCancelUpstreamKevent = errors.New("cancel bubbling up the kernel event to upstream components")

	// ErrFeatureUnsupported is thrown when a certain feature was not triggered via the build flag
	ErrFeatureUnsupported = func(s string) error {
		return fmt.Errorf("fibratus was compiled without %s support. Please compile with the '%s' build flag", s, s)
	}

	// ErrHTTPServerUnavailable signals that the HTTP server is not running on the specified transport
	ErrHTTPServerUnavailable = func(transport string, err error) error {
		return fmt.Errorf("fibratus API server up and running on %s? %v", transport, err)
	}
)

// ErrKparamNotFound is the error is thrown when a parameter is not present in the list of parameters
type ErrKparamNotFound struct {
	Name string
}

// Error returns the error message.
func (e ErrKparamNotFound) Error() string {
	return "couldn't find '" + e.Name + "' in event parameters"
}

// IsCancelUpstreamKevent determines if the error being passed if of `ErrCancelUpstreamKevent` type.
func IsCancelUpstreamKevent(err error) bool { return err == ErrCancelUpstreamKevent }

// IsKparamNotFound returns true if the error is KparamNotFound.
func IsKparamNotFound(err error) bool {
	switch err.(type) {
	case *ErrKparamNotFound:
		return true
	default:
		return false
	}
}

```

`pkg/errors/errors_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package errors

import (
	"errors"
)

var (
	// ErrTraceAccessDenied is returned when user doesn't have enough privileges to start kernel trace
	ErrTraceAccessDenied = errors.New("not enough privileges to start the kernel trace. Only users with administrative privileges or users in the Performance Log Users group can start kernel traces")
	// ErrTraceInvalidParameter signals invalid values for trace session
	ErrTraceInvalidParameter = errors.New("trace has invalid values")
	// ErrTraceBadLength signals an incorrect size for internal structure buffer
	ErrTraceBadLength = errors.New("incorrect size of internal structure buffer")
	// ErrCannotUpdateTrace signals that the session with the same GUID was running and couldn't be updated
	ErrCannotUpdateTrace = errors.New("couldn't update the running trace")
	// ErrTraceNoSysResources signals that the maximum number of logging sessions has been reached
	ErrTraceNoSysResources = errors.New("maximum number of logging sessions has been reached")
	// ErrTraceDiskFull signals that there is not enough space on disk for the log file. Should never happen for real-time loggers
	ErrTraceDiskFull = errors.New("not enough disk space for writing to log file")
	// ErrInvalidTrace signals invalid trace handle
	ErrInvalidTrace = errors.New("invalid kernel trace handle")
	// ErrStopTrace is bubbled when controller is not able to stop kernel trace session
	ErrStopTrace = errors.New("an error occurred while stopping kernel trace")
	// ErrRestartTrace signals an error that is thrown when currently running kernel trace cannot be restarted
	ErrRestartTrace = errors.New("couldn't restart an already running kernel trace")
	// ErrTraceAlreadyRunning identifies kernel trace already running errors
	ErrTraceAlreadyRunning = errors.New("kernel trace is already running")
	// ErrEventCallbackException signals that an exception has occurred in the event processing function
	ErrEventCallbackException = errors.New("an exception occurred in the event callback function")
	// ErrKsessionNotRunning is thrown when kernel session from which consumer is trying to collect events is not running
	ErrKsessionNotRunning = errors.New("kernel session from which you are trying to consume events in real time is not running")
	// ErrTraceCancelled is thrown when in-progress kernel event trace is cancelled
	ErrTraceCancelled = errors.New("kernel event trace has been cancelled")
	// ErrInsufficentBuffer raises when the buffer size for allocating event metadata is higher then regular buffer size
	ErrInsufficentBuffer = errors.New("insufficient buffer size to allocate event metadata")
	// ErrEventSchemaNotFound signals missing event schema
	ErrEventSchemaNotFound = errors.New("event schema not found")
	// ErrNeedsReallocateBuffer is signaled when an API function requires bigger buffer size
	ErrNeedsReallocateBuffer = errors.New("buffer size is too small")
)

```

`pkg/filament/_fixtures/test_filter.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Tests the filter expression.
"""

kevents = []

def on_init():
    kfilter('ps.name in (%s)' % ','.join(["'svchost.exe'", "'cmd.exe'", "'mimikatz.exe'"]))

def on_next_kevent(kevent):
    pass
```

`pkg/filament/_fixtures/test_on_next_kevent.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Tests the on_next_kevent function.
"""

kevents = []

def on_init():
    interval(1)
    columns(['Key', '#Seq'])
    sort_by('#Seq')

def on_next_kevent(kevent):
    kevents.append({'key_name': kevent['kparams']['key_name'], 'seq': kevent['seq'], 'dip': kevent['kparams']['dip']})

def on_interval():
    for key in kevents:
        add_row([key['key_name'], key['seq']])
    render_table()
```

`pkg/filament/_fixtures/top_hives_io.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows top registry hives by I/O activity.
"""

import collections

hives = collections.Counter()


def on_init():
    interval(4)
    columns(['Hive', "1", ["d"]])
    sort_by("1")


def on_next_kevent(kevent):
    pass


```

`pkg/filament/_fixtures/top_keys_io_table.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows top registry keys by I/O activity.
"""

import collections

keys = collections.Counter()


def on_init():
    interval(1)
    columns(['Key', '#Ops'])
    sort_by('#Ops')


def on_next_kevent(kevent):
    pass


def on_interval():
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9",))
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9",))
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9",))
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Control\\Nls\\Sorting\\Ids",))
    for key, count in keys.items():
        add_row([key, count])
    render_table()
```

`pkg/filament/cpython/_fixtures/top_hives_io.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows top registry hives by I/O activity.
"""

import collections

hives = collections.Counter()


def on_init():
    set_interval(2)
    print("on_init")
    #set_filter('RegOpenKey or proc.name=java')
    #columns(["Hive", "#Ops"])
    #sort_by('#Ops')
    #set_interval(1)


def on_next_kevent(kevent):
    print("KEVENT\n", kevent["kparams"])
    #raise Exception('eggs', 'eggs')

def on_interval():
    for hive, count in hives.items():
        add_row([hive, count])
    render_tabular()

def sum(v):
    return 1 + 1
```

`pkg/filament/cpython/api.c`:

```c
/*
 *	Copyright 2019-2020 by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

#include "api.h"

int PyArg_ParseInt(PyObject *args, int n) {
    int i;
    int res;
    switch (n) {
    case 1:
        res = PyArg_ParseTuple(args, "i", &i);
        break;
    case 2:
        res = PyArg_ParseTuple(args, "Oi", &i, &i);
        break;
    case 3:
        res = PyArg_ParseTuple(args, "OOi", &i, &i, &i);
        break;
    default:
        return i;
    }
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "argument must be an integer");
        return 0;
    }
    return i;
}

PyObject* PyArg_ParseList(PyObject *args, int n) {
    PyObject *ob;
    int res;
    switch (n) {
    case 1:
        res = PyArg_ParseTuple(args, "O!", &PyList_Type, &ob);
        break;
    case 2:
        res = PyArg_ParseTuple(args, "OO!", &ob, &PyList_Type, &ob);
        break;
    case 3:
        res = PyArg_ParseTuple(args, "OOO!", &ob, &ob, &PyList_Type, &ob);
        break;
    default:
        return NULL;
    }
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "argument must be a list");
        return NULL;
    }
    return ob;
}

PyObject* PyArg_ParseString(PyObject *args, int n) {
    PyObject *ob;
    int res;
    switch (n) {
    case 1:
        res = PyArg_ParseTuple(args, "U", &ob);
        break;
    case 2:
        res = PyArg_ParseTuple(args, "OU", &ob, &ob);
        break;
    case 3:
        res = PyArg_ParseTuple(args, "OOU", &ob, &ob, &ob);
        break;
    default:
        return NULL;
    }
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "argument must be a string");
        return NULL;
    }
    return ob;
}

void PyArg_ParseKeywords(PyObject *args, PyObject *kwargs, char *kwlist[], PyObject **ob1,  PyObject **ob2,  PyObject **ob3,  PyObject **ob4) {
    int res;

    res = PyArg_ParseTupleAndKeywords(args,
                                      kwargs,
                                      "OO|$OO", kwlist,
                                      ob1, ob2, ob3, ob4);
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "parse keywords failed");
    }
}

PyObject* PyTime_FromDateTime(int year, int month, int day, int hour, int minute, int second, int usecond) {
    return PyDateTime_FromDateAndTime(year, month, day, hour, minute, second, usecond);
}

PyObject* PyChar_FromChar(char v) {
    return Py_BuildValue("b", v);
}

PyObject* PyChar_FromUnsignedChar(unsigned char v) {
    return Py_BuildValue("B", v);
}

PyObject* PyShort_FromShort(short v) {
    return Py_BuildValue("h", v);
}

PyObject* PyShort_FromUnsignedShort(unsigned short v) {
    return Py_BuildValue("H", v);
}

bool Py_IsUnicode(PyObject *ob) {
    if (ob == NULL)
      return false;
    return PyUnicode_CheckExact(ob);
}

bool Py_IsInteger(PyObject *ob) {
    if (ob == NULL)
       return false;
    return PyLong_CheckExact(ob);
}

void Py_DateTimeImport() {
    PyDateTime_IMPORT;
}


bool Py_IsDateTime(PyObject *ob) {
    if (ob == NULL)
       return false;
    return PyDateTime_CheckExact(ob);
}

const char* Py_Type(PyObject *ob) {
    return Py_TYPE(ob)->tp_name;
}

int PyDate_GetYear(PyObject *ob) {
    return PyDateTime_GET_YEAR(ob);
}
int PyDate_GetMonth(PyObject *ob) {
    return PyDateTime_GET_MONTH(ob);
}
int PyDate_GetDay(PyObject *ob) {
    return PyDateTime_GET_DAY(ob);
}
int PyDate_GetHour(PyObject *ob) {
    return PyDateTime_DATE_GET_HOUR(ob);
}
int PyDate_GetMinute(PyObject *ob) {
    return PyDateTime_DATE_GET_MINUTE(ob);
}
int PyDate_GetSecond(PyObject *ob) {
    return PyDateTime_DATE_GET_SECOND(ob);
}
int PyDate_GetMicroSecond(PyObject *ob) {
    return PyDateTime_DATE_GET_MICROSECOND(ob);
}
```

`pkg/filament/cpython/api.h`:

```h
/*
 *	Copyright 2019-2020 by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

#include <Python.h>
#include <string.h>
#include <stdbool.h>
#include "datetime.h"

typedef char i8;
typedef unsigned char u8;
typedef short i16;
typedef unsigned short u16;
typedef long i32;
typedef long long i64;
typedef unsigned long long u64;
typedef unsigned long u32;

/*
Cgo doesn't know how to deal with C macros/variadic functions. This is the main reason we need the wrapper for
some CPython API functions in pure C.
*/

int PyArg_ParseInt(PyObject *args, int n);
PyObject* PyArg_ParseString(PyObject *args, int n);
PyObject* PyArg_ParseList(PyObject *args, int n);

void PyArg_ParseKeywords(PyObject *args, PyObject *kwargs, char *kwlist[], PyObject **ob1,  PyObject **ob2,  PyObject **ob3,  PyObject **ob4);

PyObject* PyTime_FromDateTime(int year, int month, int day, int hour, int minute, int second, int usecond);
PyObject* PyChar_FromChar(char v);
PyObject* PyChar_FromUnsignedChar(unsigned char v);
PyObject* PyShort_FromShort(short v);
PyObject* PyShort_FromUnsignedShort(unsigned short v);

bool Py_IsUnicode(PyObject *ob);
bool Py_IsInteger(PyObject *ob);
bool Py_IsDateTime(PyObject *ob);

void Py_DateTimeImport();

int PyDate_GetYear(PyObject *ob);
int PyDate_GetMonth(PyObject *ob);
int PyDate_GetDay(PyObject *ob);
int PyDate_GetHour(PyObject *ob);
int PyDate_GetMinute(PyObject *ob);
int PyDate_GetSecond(PyObject *ob);
int PyDate_GetMicroSecond(PyObject *ob);

const char* Py_Type(PyObject *ob);
```

`pkg/filament/cpython/dict.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"

// Dict represents the abstraction over the Python dictionary object.
type Dict struct {
	*PyObject
}

// NewDict constructs a new empty dictionary object.
func NewDict() *Dict {
	return &Dict{PyObject: &PyObject{rawptr: C.PyDict_New()}}
}

// NewDictFromObject constructs a new dictionary object from the existing dictionary.
func NewDictFromObject(o *PyObject) *Dict {
	return &Dict{PyObject: o}
}

// Insert inserts a value into the dictionary indexed with a key. Key must be hashable, otherwise TypeError is raised.
func (d *Dict) Insert(k, v *PyObject) {
	C.PyDict_SetItem(d.rawptr, k.rawptr, v.rawptr)
}

// Get returns the object from dictionary with the provided key. Returns a null object if the key key is not present,
// but without setting an exception.
func (d *Dict) Get(k *PyObject) *PyObject {
	return &PyObject{rawptr: C.PyDict_GetItem(d.rawptr, k.rawptr)}
}

// Object returns the underlying Python object reference.
func (d *Dict) Object() *PyObject {
	return d.PyObject
}

```

`pkg/filament/cpython/dict_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"github.com/magiconair/properties/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestDict(t *testing.T) {
	t.SkipNow()
	dict := NewDict()
	require.False(t, dict.IsNull())

	dict.Insert(PyUnicodeFromString("filename"), PyUnicodeFromString("C:\\Windows\\System32\\kernel32.dll"))
	v := dict.Get(PyUnicodeFromString("filename"))
	require.NotNil(t, v)

	assert.Equal(t, `C:\Windows\System32\kernel32.dll`, v.String())
}

```

`pkg/filament/cpython/errors.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"
import (
	"errors"
	"sync"
)

var once sync.Once
var formatException *PyObject

// FetchErr retrieves the error indicator into three variables whose addresses are passed. If the error indicator is not
// set, set all three variables to NULL. If it is set, it will be cleared and you own a reference to each object retrieved.
// The value and traceback object may be NULL even when the type object is not.
func FetchErr() error {
	if C.PyErr_Occurred() == nil {
		// error indicator not set, nothing to do
		return nil
	}

	exc := &PyObject{}
	val := &PyObject{}
	traceback := &PyObject{}
	defer exc.DecRef()
	defer val.DecRef()
	defer traceback.DecRef()

	C.PyErr_Fetch(&exc.rawptr, &val.rawptr, &traceback.rawptr)
	//  normalize exception values as per python C API
	C.PyErr_NormalizeException(&exc.rawptr, &val.rawptr, &traceback.rawptr)

	if !traceback.IsNull() {
		once.Do(func() {
			tb, _ := NewModule("traceback")
			if tb != nil {
				formatException, _ = tb.GetAttrString("format_exception")
			}
		})
		if !formatException.IsNull() {
			ob := formatException.Call(exc, val, traceback)
			if !ob.IsNull() {
				defer ob.DecRef()
				return errors.New(ob.String())
			}
		}
		return errors.New("can't format traceback exception")
	}
	if !val.IsNull() {
		return errors.New(val.String())
	}
	if !exc.IsNull() {
		return errors.New(exc.String())
	}
	return nil
}

// ClearError clears the error indicator.
func ClearError() {
	C.PyErr_Clear()
}

// CheckSignals checks the signal queue.
func CheckSignals() bool {
	return C.PyErr_CheckSignals() == -1
}

```

`pkg/filament/cpython/gil.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"
import (
	"runtime"
	"sync/atomic"
)

// PyGILState is the type alias for the native Python GIL state
type PyGILState C.PyGILState_STATE

// GIL is responsible for interacting with the Python GIL. Goroutines are executed on
// multiple threads and the scheduler might decide to pause the goroutine on one thread
// and resume it later in a different thread. This would cause catastrophic effects if
// the Python interpreter finds out the GIL was acquired in one thread but released in a
// different one. We have to provide extra safety to avoid runtime crashes at the cost of
// sacrificing some performance since we'll always stick the goroutine to be scheduled on
// the same thread.
type GIL struct {
	locked uint32
	state  PyGILState
	tstate *C.PyThreadState
}

// NewGIL creates a new instance of the GIL manager.
func NewGIL() *GIL {
	return &GIL{}
}

// SaveThread releases the global interpreter lock (if it has been created and thread
// support is enabled) and reset the thread state to NULL, returning the
// previous thread state (which is not NULL).
func (g *GIL) SaveThread() {
	g.tstate = C.PyEval_SaveThread()
}

// RestoreThread acquire the global interpreter lock (if it has been created and thread
// support is enabled) and set the thread state to tstate, which must not be
// NULL. If the lock has been created, the current thread must not have
// acquired it, otherwise deadlock ensues.
func (g *GIL) RestoreThread() {
	C.PyEval_RestoreThread(g.tstate)
}

// Lock acquires the GIL lock by ensuring the current thread is ready to call Python C API.
func (g *GIL) Lock() {
	runtime.LockOSThread()
	atomic.StoreUint32(&g.locked, 1)
	g.state = PyGILState(C.PyGILState_Ensure())
}

// Unlock releases the lock on the GIL.
func (g *GIL) Unlock() {
	atomic.StoreUint32(&g.locked, 0)
	C.PyGILState_Release(C.PyGILState_STATE(g.state))
	runtime.UnlockOSThread()
}

// Locked indicates if the lock on the GIL was acquired.
func (g *GIL) Locked() bool {
	return atomic.LoadUint32(&g.locked) > 0
}

```

`pkg/filament/cpython/gil_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestGILLock(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	gil := NewGIL()
	gil.Lock()
	require.True(t, gil.Locked())
}

func TestGILUnlock(t *testing.T) {
	// failing non-deterministically in CI
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	gil := NewGIL()
	gil.Lock()
	require.True(t, gil.Locked())
	gil.Unlock()
	require.False(t, gil.Locked())
}

```

`pkg/filament/cpython/interpreter.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#cgo pkg-config: python-37

#include "api.h"

*/
import "C"
import (
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"syscall"
	"unsafe"
)

// ErrPyInit signals that an error ocurred while initializing the Python interpreter
var ErrPyInit = errors.New("couldn't initialize the Python interpreter")

// ErrGILInit indicates that the global interpreter lock failed to initialize
var ErrGILInit = errors.New("unable to initialize the GIL")

// Initialize initializes the Python interpreter and its global interpreter lock (GIL).
func Initialize() error {
	if C.Py_IsInitialized() == 0 {
		// initialize the interpreter without signal handlers
		C.Py_InitializeEx(0)
	}
	if C.Py_IsInitialized() == 0 {
		return ErrPyInit
	}
	if C.PyEval_ThreadsInitialized() == 0 {
		C.PyEval_InitThreads()
	}
	if C.PyEval_ThreadsInitialized() == 0 {
		return ErrGILInit
	}
	// this calls into PyDateTime_IMPORT macro to initialize the PyDateTimeAPI
	C.Py_DateTimeImport()

	if err := initializeIPFnAndClasses(); err != nil {
		log.Warn(err)
	}

	return nil
}

// Finalize undos all initializations made by Initialize() and subsequent use of Python/C API functions,
// and destroys all sub-interpreters that were created and not yet destroyed since the last call to Initialize().
// Ideally, this frees all memory allocated by the Python interpreter.
func Finalize() {
	C.Py_Finalize()
}

// AddPythonPath adds a new path to the PYTHONPATH environment variable.
func AddPythonPath(path string) {
	syspath := C.CString("path")
	defer C.free(unsafe.Pointer(syspath))
	newPath := PyUnicodeFromString(path)
	defer newPath.DecRef()
	C.PyList_Append(C.PySys_GetObject(syspath), newPath.rawptr)
}

// SetPath sets the default module search path. If this function is called before Py_Initialize(), then Py_GetPath()
// won’t attempt to compute a default search path but uses the one provided instead. This is useful if Python is
// embedded by an application that has full knowledge of the location of all modules.
func SetPath(path string) {
	w, err := syscall.UTF16FromString(path)
	if err != nil {
		return
	}
	C.Py_SetPath((*C.wchar_t)(&w[0]))
}

// SetSysArgv sets sys.argv based on argc and argv. These parameters are similar to those passed to
// the program’s main() function with the difference that the first entry should refer to the script
// file to be executed rather than the executable hosting the Python interpreter. If there isn’t a
// script that will be run, the first entry in argv can be an empty string. If this function fails
// to initialize sys.argv, a fatal condition is signalled using Py_FatalError().
func SetSysArgv(args []string) {
	argc := C.int(len(args))
	argv := make([]*C.wchar_t, argc)
	for i, arg := range args {
		argv[i] = newWarg(arg)
	}
	C.PySys_SetArgvEx(argc, (**C.wchar_t)(unsafe.Pointer(&argv[0])), 0)
}

func newWarg(arg string) *C.wchar_t {
	carg := C.CString(arg)
	defer C.free(unsafe.Pointer(carg))

	warg := C.Py_DecodeLocale(carg, nil)
	if warg == nil {
		return nil
	}
	// Py_DecodeLocale requires a call to PyMem_RawFree to free the memory
	defer C.PyMem_RawFree(unsafe.Pointer(warg))
	return warg
}

```

`pkg/filament/cpython/interpreter_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestInitialize(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	Finalize()
}

```

`pkg/filament/cpython/ip.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import "errors"

var ipv4Class *PyObject
var ipv6Class *PyObject
var ipaddressFn *PyObject

func initializeIPFnAndClasses() error {
	mod, err := NewModule("ipaddress")
	if err != nil {
		return err
	}
	if mod.IsNull() {
		return errors.New("ipaddress module was not initialized")
	}

	ipaddressFn, err = mod.GetAttrString("ip_address")
	if err != nil {
		return err
	}
	ipv4Class, err = mod.GetAttrString("IPv4Address")
	if err != nil {
		return err
	}
	ipv6Class, err = mod.GetAttrString("IPv6Address")
	if err != nil {
		return err
	}

	return nil
}

```

`pkg/filament/cpython/module.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include <string.h>
#include "api.h"
*/
import "C"
import (
	"fmt"
	"syscall"
	"unsafe"
)

// Module encapsulates the Python module.
type Module struct {
	*PyObject
	name string
}

// NewModule imports a module leaving the globals and locals arguments set to NULL and level set to 0. When the name argument contains
// a dot (when it specifies a submodule of a package), the fromlist argument is set to the list ['*'] so that the return
// value is the named module rather than the top-level package containing it as would otherwise be the case.
// (Unfortunately, this has an additional side effect when name in fact specifies a subpackage instead of a submodule:
// the submodules specified in the package’s __all__ variable are loaded.) Return a new reference to the imported module,
// or NULL with an exception set on failure. A failing import of a module doesn't leave the module in sys.modules.
func NewModule(name string) (*Module, error) {
	n := C.CString(name)
	defer C.free(unsafe.Pointer(n))
	mod := C.PyImport_ImportModule(n)
	if mod == nil {
		return nil, fmt.Errorf("couldn't import %q module", name)
	}
	return &Module{
		PyObject: &PyObject{rawptr: mod},
		name:     name,
	}, nil
}

// MethFlags is the type alias for the method flags
type MethFlags int

const (
	// MethVarArgs indicates that the method or function accepts positional arguments
	MethVarArgs MethFlags = C.METH_VARARGS
	// MethKeyWords indicates that the method or function accepts keyword arguments
	MethKeyWords MethFlags = C.METH_KEYWORDS
	// MethNoArgs indicates that the method or function accepts no arguments
	MethNoArgs MethFlags = C.METH_NOARGS
)

// DefaultMethFlags represents the default method flags
var DefaultMethFlags = MethVarArgs | MethKeyWords

// declared globally to guard PyMethodDef structures from the garbage collector
var defs = map[string]*C.PyMethodDef{}

// RegisterFn anchors the function to this module. The callable Python object is built from the method definition
// that specifies the function name, the args expected by the function and the pointer to the Go callback.
func (m *Module) RegisterFn(name string, fn interface{}, flags MethFlags) error {
	n := C.CString(name)
	defer C.free(unsafe.Pointer(n))
	defs[name] = &C.PyMethodDef{
		ml_name:  n,
		ml_meth:  (C.PyCFunction)(unsafe.Pointer(syscall.NewCallback(fn))),
		ml_flags: C.int(flags),
	}
	mod := C.CString(m.name)
	defer C.free(unsafe.Pointer(mod))
	f := C.PyCFunction_NewEx((*C.PyMethodDef)(unsafe.Pointer(defs[name])), m.rawptr, C.PyUnicode_FromString(mod))
	if f == nil {
		return fmt.Errorf("unable to attach the %s function to the %s module", name, m.name)
	}
	return m.SetAttrString(name, f)
}

```

`pkg/filament/cpython/module_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestNewModule(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	AddPythonPath("_fixtures/")
	mod, err := NewModule("top_hives_io")
	require.NoError(t, err)
	require.NotNil(t, mod)
}

func TestModuleRegisterFn(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	AddPythonPath("_fixtures/")
	mod, err := NewModule("top_hives_io")
	require.NoError(t, err)
	require.NotNil(t, mod)

	f := func() uintptr { return 0 }

	err = mod.RegisterFn("set_interval", f, MethVarArgs)
	require.NoError(t, err)

	fn, err := mod.GetAttrString("set_interval")
	require.NoError(t, err)
	require.False(t, fn.IsNull())
	require.True(t, fn.IsCallable())
	fn.Call()

	fn, err = mod.GetAttrString("sum")
	require.NoError(t, err)
	require.False(t, fn.IsNull())
	require.True(t, fn.IsCallable())
	r := fn.Call(PyUnicodeFromString("test"))
	require.False(t, r.IsNull())
}

```

`pkg/filament/cpython/object.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"
import (
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"net"
	"syscall"
	"time"
	"unsafe"
)

var errTypeNotList = errors.New("couldn't parse the argument. It is probably not a list")

// PyRawObject is the type alias for the raw Python object pointer.
type PyRawObject *C.PyObject

// PyArgs represents the alias for the Python positional arguments.
type PyArgs uintptr

// PyKwargs represents the alias for the Python keyword arguments.
type PyKwargs uintptr

// GetInt returns the nth positional argument as an integer.
func (args PyArgs) GetInt(n uint8) int {
	return int(C.PyArg_ParseInt((*C.PyObject)(unsafe.Pointer(args)), C.int(n)))
}

// GetString returns the nth positional argument as a string.
func (args PyArgs) GetString(n uint8) string {
	return fromRawOb(C.PyArg_ParseString((*C.PyObject)(unsafe.Pointer(args)), C.int(n))).String()
}

// GetStringSlice returns the nth argument as a slice of string values.
func (args PyArgs) GetStringSlice(n uint8) ([]string, error) {
	ob := C.PyArg_ParseList((*C.PyObject)(unsafe.Pointer(args)), C.int(n))
	if ob == nil {
		return nil, errTypeNotList
	}
	l := int(C.PyList_Size(ob))
	s := make([]string, l)
	for i := 0; i < l; i++ {
		item := C.PyList_GetItem(ob, C.longlong(i))
		if item == nil {
			continue
		}
		isUnicode := bool(C.Py_IsUnicode(item))
		if !isUnicode {
			continue
		}
		s[i] = fromRawOb(item).String()
	}
	return s, nil
}

// GetSlice returns the nth argument as a slice of generic values.
func (args PyArgs) GetSlice(n uint8) ([]interface{}, error) {
	ob := C.PyArg_ParseList((*C.PyObject)(unsafe.Pointer(args)), C.int(n))
	if ob == nil {
		return nil, errTypeNotList
	}
	l := int(C.PyList_Size(ob))
	if l < 0 {
		return nil, nil
	}
	s := make([]interface{}, l)
	for i := 0; i < l; i++ {
		item := C.PyList_GetItem(ob, C.longlong(i))
		if item == nil {
			continue
		}
		switch {
		case bool(C.Py_IsUnicode(item)):
			s[i] = fromRawOb(item).String()
		case bool(C.Py_IsInteger(item)):
			s[i] = fromRawOb(item).Int()
		case bool(C.Py_IsDateTime(item)):
			s[i] = fromRawOb(item).Time()
		default:
			if ipv4Class != nil {
				if !ipv4Class.IsNull() && C.PyObject_IsInstance(item, ipv4Class.rawptr) > 0 {
					s[i] = net.ParseIP(fromRawOb(item).String())
				}
			}
			if ipv6Class != nil {
				if !ipv6Class.IsNull() && C.PyObject_IsInstance(item, ipv6Class.rawptr) > 0 {
					s[i] = net.ParseIP(fromRawOb(item).String())
				}
			}
		}
	}
	return s, nil
}

// PyArgsParseKeywords parses tuple and keywords arguments.
func PyArgsParseKeywords(args PyArgs, kwargs PyKwargs, kwlist []string) (string, string, string, []string) {
	var (
		ob1 *C.PyObject
		ob2 *C.PyObject
		ob3 *C.PyObject
		ob4 *C.PyObject
	)

	klist := make([]*C.char, len(kwlist)+1)

	for i, k := range kwlist {
		klist[i] = C.CString(k)
		defer C.free(unsafe.Pointer(klist[i]))
	}

	C.PyArg_ParseKeywords(
		(*C.PyObject)(unsafe.Pointer(args)),
		(*C.PyObject)(unsafe.Pointer(kwargs)),
		&klist[0],
		(**C.PyObject)(unsafe.Pointer(&ob1)),
		(**C.PyObject)(unsafe.Pointer(&ob2)),
		(**C.PyObject)(unsafe.Pointer(&ob3)),
		(**C.PyObject)(unsafe.Pointer(&ob4)),
	)

	return fromRawOb(ob1).String(), fromRawOb(ob2).String(), fromRawOb(ob3).String(), fromRawOb(ob4).StringSlice()
}

// PyObject is the main abstraction for manipulating the native CPython objects.
type PyObject struct {
	rawptr *C.PyObject
}

//nolint:golint // NewPyNone creates a new none Python object.
func NewPyNone() *C.PyObject {
	return C.Py_None
}

//nolint:golint // NewPyLong creates a new 64-bit signed integer Python object.
func NewPyLong(v int64) *C.PyObject {
	return C.PyLong_FromLongLong(C.i64(v))
}

// NewPyObjectFromValue builds a new Python object based on the underlying interface type.
func NewPyObjectFromValue(value interface{}) *PyObject {
	var ob *C.PyObject
	switch v := value.(type) {
	case int8:
		ob = C.PyChar_FromChar(C.i8(v))
	case uint8:
		ob = C.PyChar_FromUnsignedChar(C.u8(v))
	case int16:
		ob = C.PyShort_FromShort(C.i16(v))
	case uint16:
		ob = C.PyShort_FromUnsignedShort(C.u16(v))
	case int32:
		ob = C.PyLong_FromLong(C.i32(v))
	case uint32:
		ob = C.PyLong_FromUnsignedLong(C.u32(v))
	case int64:
		ob = C.PyLong_FromLongLong(C.i64(v))
	case uint64:
		ob = C.PyLong_FromUnsignedLongLong(C.u64(v))
	case string:
		ob = PyUnicodeFromString(v).asRaw()
	case fs.FileDisposition:
		ob = PyUnicodeFromString(v.String()).asRaw()
	case time.Time:
		ob = C.PyTime_FromDateTime(C.int(v.Year()), C.int(v.Month()), C.int(v.Day()), C.int(v.Hour()), C.int(v.Minute()), C.int(v.Second()), C.int(v.Nanosecond()/1000))
	case net.IP:
		if !ipaddressFn.IsNull() {
			ob = ipaddressFn.Call(PyUnicodeFromString(v.String())).asRaw()
		} else {
			ob = PyUnicodeFromString(v.String()).asRaw()
		}
	case func(arg1, arg2 PyArgs) PyRawObject:
		n := C.CString("func")
		defer C.free(unsafe.Pointer(n))
		mdef := &C.PyMethodDef{
			ml_name:  n,
			ml_meth:  (C.PyCFunction)(unsafe.Pointer(syscall.NewCallback(v))),
			ml_flags: C.int(DefaultMethFlags),
		}
		ob = C.PyCFunction_NewEx((*C.PyMethodDef)(unsafe.Pointer(mdef)), nil, C.PyUnicode_FromString(n))
	}
	return &PyObject{rawptr: ob}
}

// fromRawOb builds a new Python object from the raw pointer.
func fromRawOb(ob *C.PyObject) *PyObject { return &PyObject{rawptr: ob} }

// DecRef decrements the reference count for object o. If the object is NULL, nothing happens. If the reference count
// reaches zero, the object’s type’s deallocation function (which must not be NULL) is invoked.
func (ob *PyObject) DecRef() {
	if ob != nil || ob.rawptr == nil {
		return
	}
	C.Py_DecRef(ob.rawptr)
}

// IncRef increment the reference count for object o. The object may be NULL, in which case this method has no effect.
func (ob *PyObject) IncRef() {
	if ob != nil && ob.rawptr == nil {
		return
	}
	C.Py_IncRef(ob.rawptr)
}

// IsNull determines whether this object's instance is null.
func (ob *PyObject) IsNull() bool {
	if ob == nil {
		return true
	}
	return ob.rawptr == nil
}

func (ob *PyObject) asRaw() *C.PyObject {
	return ob.rawptr
}

// SetAttrString set the value of the attribute provided for this object to the specified value.
func (ob *PyObject) SetAttrString(name string, value *C.PyObject) error {
	attr := C.CString(name)
	defer C.free(unsafe.Pointer(attr))
	err := int(C.PyObject_SetAttrString(ob.rawptr, attr, value))
	if err == -1 {
		return fmt.Errorf("couldn't set the value of the %q attribute", name)
	}
	return nil
}

// GetAttrString retrieves an attribute named from object the object. Returns an error if the attribute can't be fetched.
func (ob *PyObject) GetAttrString(name string) (*PyObject, error) {
	attr := C.CString(name)
	defer C.free(unsafe.Pointer(attr))
	v := C.PyObject_GetAttrString(ob.rawptr, attr)
	if v == nil {
		return nil, fmt.Errorf("couldn't get the %q attribute", name)
	}
	return &PyObject{rawptr: v}, nil
}

// HasAttr determines if the Python object has the specified attribute.
func (ob *PyObject) HasAttr(name string) bool {
	attr := C.CString(name)
	defer C.free(unsafe.Pointer(attr))
	return C.PyObject_HasAttrString(ob.rawptr, attr) > 0
}

var encoding = C.CString("utf-8")
var codecErrors = C.CString("strict")

// String encodes an Unicode object and returns the result as a Python bytes object converted to the Go string.
func (ob *PyObject) String() string {
	if ob.rawptr == nil {
		return ""
	}
	repr := C.PyObject_Str(ob.rawptr)
	if repr == nil {
		return ""
	}
	defer C.Py_DecRef(repr)
	s := C.PyUnicode_AsEncodedString(repr, encoding, codecErrors)
	if s == nil {
		return "invalid Unicode string"
	}
	defer C.Py_DecRef(s)
	return C.GoString(C.PyBytes_AsString(s))
}

// StringSlice returns this object as a string slice.
func (ob *PyObject) StringSlice() []string {
	if ob.rawptr == nil {
		return []string{}
	}
	l := int(C.PyList_Size(ob.asRaw()))
	if l < 0 {
		return nil
	}
	s := make([]string, l)
	for i := 0; i < l; i++ {
		item := C.PyList_GetItem(ob.asRaw(), C.longlong(i))
		if item == nil {
			continue
		}
		isUnicode := bool(C.Py_IsUnicode(item))
		if !isUnicode {
			continue
		}
		s[i] = fromRawOb(item).String()
	}
	return s
}

// Uint32 returns an uint32 integer from the raw Python object.
func (ob *PyObject) Uint32() uint32 {
	return uint32(C.PyLong_AsUnsignedLong(ob.rawptr))
}

// Uint64 returns an uint64 integer from the raw Python object.
func (ob *PyObject) Uint64() uint64 {
	return uint64(C.PyLong_AsUnsignedLongLong(ob.rawptr))
}

// Int returns an integer from the raw Python object.
func (ob *PyObject) Int() int {
	return int(C.PyLong_AsUnsignedLongLong(ob.rawptr))
}

// Time returns the time from the raw Python object.
func (ob *PyObject) Time() time.Time {
	year := int(C.PyDate_GetYear((*C.PyObject)(unsafe.Pointer(ob))))
	month := int(C.PyDate_GetMonth((*C.PyObject)(unsafe.Pointer(ob))))
	day := int(C.PyDate_GetDay((*C.PyObject)(unsafe.Pointer(ob))))
	hour := int(C.PyDate_GetHour((*C.PyObject)(unsafe.Pointer(ob))))
	minute := int(C.PyDate_GetMinute((*C.PyObject)(unsafe.Pointer(ob))))
	second := int(C.PyDate_GetSecond((*C.PyObject)(unsafe.Pointer(ob))))
	microsecond := int(C.PyDate_GetMicroSecond((*C.PyObject)(unsafe.Pointer(ob))))
	return time.Date(year, time.Month(month), day, hour, minute, second, microsecond*1000, time.Local)
}

// Type returns the Python type representation.
func (ob *PyObject) Type() string {
	return C.GoString(C.Py_Type(ob.rawptr))
}

// IsCallable determines if the object is callable.
func (ob *PyObject) IsCallable() bool {
	return C.PyCallable_Check(ob.rawptr) > 0
}

// CallableArgCount returns the number of arguments declared in the callable Python object.
func (ob *PyObject) CallableArgCount() uint32 {
	fnCode, err := ob.GetAttrString("__code__")
	if err != nil || fnCode.IsNull() {
		return 0
	}
	defer fnCode.DecRef()
	count, err := fnCode.GetAttrString("co_argcount")
	if err != nil {
		return 0
	}
	defer count.DecRef()
	return count.Uint32()
}

// Call calls a callable Python object with arguments given by the tuple args. If no arguments are needed, then args
// may be NULL. Returns the result of the call on success, or a null reference on failure.
func (ob *PyObject) Call(args ...*PyObject) *PyObject {
	if ob.rawptr == nil {
		return nil
	}
	if len(args) == 0 {
		return &PyObject{rawptr: C.PyObject_CallObject(ob.rawptr, nil)}
	}
	tuple := NewTuple(len(args))
	for pos, arg := range args {
		tuple.Set(pos, arg)
	}
	defer tuple.DecRef()
	r := C.PyObject_CallObject(ob.rawptr, tuple.rawptr)
	return &PyObject{rawptr: r}
}

```

`pkg/filament/cpython/sequence.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"

// Tuple represents the Python tuple sequence object.
type Tuple struct {
	*PyObject
}

// NewTuple constructs a new tuple object of the provided size.
func NewTuple(size int) *Tuple {
	return &Tuple{PyObject: &PyObject{rawptr: C.PyTuple_New(C.Py_ssize_t(size))}}
}

// Set inserts a reference to object at specified position of the tuple.
func (t *Tuple) Set(pos int, ob *PyObject) {
	C.PyTuple_SetItem(t.rawptr, C.Py_ssize_t(pos), ob.rawptr)
}

```

`pkg/filament/cpython/string.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
 #include "api.h"
*/
import "C"
import "unsafe"

// PyUnicodeFromString creates the Python Unicode object from the Go string.
func PyUnicodeFromString(s string) *PyObject {
	u := C.CString(s)
	defer C.free(unsafe.Pointer(u))
	return &PyObject{rawptr: C.PyUnicode_FromString(u)}
}

```

`pkg/filament/filament.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filament/cpython"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/util/term"
	log "github.com/sirupsen/logrus"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
	// initialize alert senders
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/slack"
)

// pyver designates the current Python version
const pyver = "37"

// useEmbeddedPython instructs the filament engine to use the embedded Python distribution.
var useEmbeddedPython = true

const (
	intervalFn      = "interval"
	columnsFn       = "columns"
	sortbyFn        = "sort_by"
	kfilterFn       = "kfilter"
	addRowFn        = "add_row"
	maxRowsFn       = "max_rows"
	titleFn         = "title"
	renderTableFn   = "render_table"
	findHandleFn    = "find_handle"
	findHandlesFn   = "find_handles"
	findProcessFn   = "find_process"
	findProcessesFn = "find_processes"
	emitAlertFn     = "emit_alert"

	onInitFn       = "on_init"
	onStopFn       = "on_stop"
	onNextKeventFn = "on_next_kevent"
	onIntervalFn   = "on_interval"
	doc            = "__doc__"
)

var (
	keventErrors        = expvar.NewMap("filament.kevent.errors")
	keventProcessErrors = expvar.NewInt("filament.kevent.process.errors")
	kdictErrors         = expvar.NewInt("filament.kdict.errors")
	batchFlushes        = expvar.NewInt("filament.kevent.batch.flushes")

	errFilamentsDir = func(path string) error { return fmt.Errorf("%s does not exist or is not a directory", path) }

	errNoDoc                    = errors.New("filament description is required")
	errNoOnNextKevent           = errors.New("required on_next_kevent function is not defined")
	errOnNextKeventNotCallable  = errors.New("on_next_kevent is not callable")
	errOnNextKeventMismatchArgs = func(c uint32) error { return fmt.Errorf("expected 1 argument for on_next_kevent but found %d args", c) }
	errEmptyName                = errors.New("filament name is empty")

	tableOutput io.Writer
)

type kbatch []*kevent.Kevent

func (k *kbatch) append(kevt *kevent.Kevent) {
	if *k == nil {
		*k = make([]*kevent.Kevent, 0)
	}
	*k = append(*k, kevt)
}

func (k *kbatch) reset()  { *k = nil }
func (k kbatch) len() int { return len(k) }

type filament struct {
	name     string
	sortBy   string
	interval time.Duration
	columns  []string
	fexpr    string
	fnerrs   chan error
	close    chan struct{}
	gil      *cpython.GIL

	tick *time.Ticker
	mod  *cpython.Module

	config *config.Config

	psnap  ps.Snapshotter
	hsnap  handle.Snapshotter
	filter filter.Filter

	initErrors []error

	onNextKevent *cpython.PyObject
	onStop       *cpython.PyObject

	table tab
}

// New creates a new instance of the filament by starting an embedded Python interpreter. It imports the filament
// module and anchors required functions for controlling the filament options as well as providing the access to
// the kernel event flow.
func New(
	name string,
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
) (Filament, error) {
	if useEmbeddedPython {
		exe, err := os.Executable()
		if err != nil {
			return nil, err
		}
		pylib := filepath.Join(filepath.Dir(exe), "..", "Python", fmt.Sprintf("python%s.zip", pyver))
		if _, err := os.Stat(pylib); err != nil {
			return nil, fmt.Errorf("python lib not found: %v", err)
		}
		// set the default module search path so it points to our embedded Python distribution
		cpython.SetPath(pylib)
	}

	if name == "" {
		return nil, errEmptyName
	}

	// split filament args. The first argument
	// is the filament name followed by comma
	// separated list of arguments
	args := strings.Split(name, ",")
	if len(args) == 0 {
		return nil, errEmptyName
	}
	filamentName := args[0]

	// initialize the Python interpreter
	if err := cpython.Initialize(); err != nil {
		return nil, err
	}
	// set sys.argv
	cpython.SetSysArgv(args)

	// set the PYTHON_PATH to the filaments directory so the interpreter
	// is aware of our filament module prior to its loading
	path := config.Filament.Path
	fstat, err := os.Stat(path)
	if err != nil || !fstat.IsDir() {
		return nil, errFilamentsDir(path)
	}
	filaments, err := ioutil.ReadDir(path)
	if err != nil {
		return nil, err
	}
	// check if the filament is present in the directory
	var exists bool
	for _, f := range filaments {
		if strings.TrimSuffix(f.Name(), filepath.Ext(f.Name())) == filamentName {
			exists = true
		}
	}

	if !exists {
		return nil, fmt.Errorf("%q filament does not exist. Run 'fibratus list filaments' to view available filaments", name)
	}

	cpython.AddPythonPath(path)
	mod, err := cpython.NewModule(filamentName)
	if err != nil {
		if err = cpython.FetchErr(); err != nil {
			return nil, err
		}
		return nil, err
	}

	// ensure required attributes are present before proceeding with
	// further initialization. For instance, if the documentation
	// string is not provided, on_next_kevent function is missing
	// or has a wrong signature we won't run the filament
	doc, err := mod.GetAttrString(doc)
	if err != nil || doc.IsNull() {
		return nil, errNoDoc
	}
	defer doc.DecRef()
	if !mod.HasAttr(onNextKeventFn) {
		return nil, errNoOnNextKevent
	}
	onNextKevent, err := mod.GetAttrString(onNextKeventFn)
	if err != nil || onNextKevent.IsNull() {
		return nil, errNoOnNextKevent
	}
	if !onNextKevent.IsCallable() {
		return nil, errOnNextKeventNotCallable
	}
	argCount := onNextKevent.CallableArgCount()
	if argCount != 1 {
		return nil, errOnNextKeventMismatchArgs(argCount)
	}

	f := &filament{
		name:         name,
		mod:          mod,
		config:       config,
		psnap:        psnap,
		hsnap:        hsnap,
		close:        make(chan struct{}, 1),
		fnerrs:       make(chan error, 100),
		gil:          cpython.NewGIL(),
		columns:      make([]string, 0),
		onNextKevent: onNextKevent,
		interval:     time.Second,
		initErrors:   make([]error, 0),
		table:        newTable(),
	}

	if mod.HasAttr(onStopFn) {
		f.onStop, _ = mod.GetAttrString(onStopFn)
	}
	// register all the functions for interacting with filament
	// within the Python module
	err = f.mod.RegisterFn(addRowFn, f.addRowFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(renderTableFn, f.renderTableFn, cpython.MethNoArgs)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(titleFn, f.titleFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(sortbyFn, f.sortByFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(maxRowsFn, f.maxRowsFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(columnsFn, f.columnsFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(kfilterFn, f.kfilterFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(intervalFn, f.intervalFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(emitAlertFn, f.emitAlertFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findHandleFn, f.findHandleFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findHandlesFn, f.findHandlesFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findProcessFn, f.findProcessFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findProcessesFn, f.findProcessesFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	// invoke the on_init function if it has been declared in the filament
	if mod.HasAttr(onInitFn) {
		onInit, _ := mod.GetAttrString(onInitFn)
		if !onInit.IsNull() {
			onInit.Call()
			if err := cpython.FetchErr(); err != nil {
				return nil, fmt.Errorf("filament init error: %v", err)
			}
			if len(f.initErrors) > 0 {
				return nil, multierror.Wrap(f.initErrors...)
			}
		}
	}

	// initialize the console frame buffer
	var fb io.Writer
	if len(f.columns) > 0 {
		fb, err = term.NewFrameBuffer()
		if err != nil {
			return nil, fmt.Errorf("couldn't create console frame buffer: %v", err)
		}
	}
	if fb != nil {
		f.table.setWriter(fb)
		f.table.setColumnConfigs(f.columns, term.GetColumns()/2+15)
	} else if tableOutput != nil {
		f.table.setWriter(tableOutput)
	} else {
		f.table.setWriter(os.Stdout)
	}
	if len(f.columns) > 0 && f.sortBy != "" {
		var sortBy bool
		for _, col := range f.columns {
			if col == f.sortBy {
				sortBy = true
				break
			}
		}
		if !sortBy {
			return nil, fmt.Errorf("%s column can't be sorted since it is not defined", f.sortBy)
		}
	}

	// compile filter from the expression
	if f.fexpr != "" {
		f.filter = filter.New(f.fexpr, config)
		if err := f.filter.Compile(); err != nil {
			return nil, err
		}
	}
	// if on_interval function has been declared in the module, we'll
	// schedule the ticker to the interval value set during filament
	// bootstrap in on_init function or otherwise we'll use the default interval
	if mod.HasAttr(onIntervalFn) {
		onInterval, err := mod.GetAttrString(onIntervalFn)
		if err == nil && !onInterval.IsNull() {
			f.tick = time.NewTicker(f.interval)
			go f.onInterval(onInterval)
		}
	}
	// we acquired the GIL as a side effect of threading initialization (the call to cpython.Initialize())
	// but now we have to reset the current thread state and release the GIL. It is the responsibility of
	// the caller to acquire the GIL before executing any Python code from now on
	f.gil.SaveThread()

	return f, nil
}

func (f *filament) Run(kevents chan *kevent.Kevent, errs chan error) error {
	var batch kbatch
	var flusher = time.NewTicker(time.Second)
	for {
		select {
		case <-f.close:
			flusher.Stop()
			return nil
		default:
		}

		select {
		case kevt := <-kevents:
			batch.append(kevt)
		case err := <-errs:
			keventErrors.Add(err.Error(), 1)
		case <-flusher.C:
			batchFlushes.Add(1)
			if batch.len() > 0 {
				err := f.pushKevents(batch)
				if err != nil {
					log.Warnf("on_next_kevent failed: %v", err)
					keventProcessErrors.Add(1)
				}
				batch.reset()
			}
		case err := <-f.fnerrs:
			return err
		case <-f.close:
			flusher.Stop()
			return nil
		}
	}
}

func (f *filament) pushKevents(b kbatch) error {
	f.gil.Lock()
	defer f.gil.Unlock()
	for _, kevt := range b {
		kdict, err := newKDict(kevt)
		kevt.Release()
		if err != nil {
			kdict.DecRef()
			kdictErrors.Add(1)
			continue
		}
		r := f.onNextKevent.Call(kdict.Object())
		if r != nil {
			r.DecRef()
		}
		kdict.DecRef()
		if err := cpython.FetchErr(); err != nil {
			return err
		}
	}
	return nil
}

func (f *filament) Close() error {
	if f.onStop != nil && !f.onStop.IsNull() {
		f.gil.Lock()
		f.onStop.Call()
		f.gil.Unlock()
	}
	f.close <- struct{}{}
	if f.tick != nil {
		f.close <- struct{}{}
	}
	if f.tick != nil {
		f.tick.Stop()
	}
	return nil
}

func (f *filament) Filter() filter.Filter { return f.filter }

func (f *filament) intervalFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.interval = time.Second * time.Duration(args.GetInt(1))
	if f.interval == 0 {
		f.initErrors = append(f.initErrors, errors.New("invalid interval value specified"))
	}
	return cpython.NewPyNone()
}

func (f *filament) sortByFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.sortBy = args.GetString(1)
	f.table.sortBy(f.sortBy)
	return cpython.NewPyNone()
}

func (f *filament) maxRowsFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.table.maxRows(args.GetInt(1))
	return cpython.NewPyNone()
}

func (f *filament) columnsFn(_, args cpython.PyArgs) cpython.PyRawObject {
	var err error
	f.columns, err = args.GetStringSlice(1)
	if err != nil {
		f.initErrors = append(f.initErrors, err)
	}
	f.table.appendHeader(f.columns)
	return cpython.NewPyNone()
}

func (f *filament) kfilterFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.fexpr = args.GetString(1)
	return cpython.NewPyNone()
}

func (f *filament) addRowFn(_, args cpython.PyArgs) cpython.PyRawObject {
	s, err := args.GetSlice(1)
	if err != nil {
		f.fnerrs <- err
		return cpython.NewPyNone()
	}
	if len(s) != len(f.columns) {
		f.fnerrs <- fmt.Errorf("add_row has %d row(s) but expected %d rows(s)", len(s), len(f.columns))
		return cpython.NewPyNone()
	}
	f.table.appendRow(s)
	return cpython.NewPyLong(int64(len(s)))
}

func (f *filament) renderTableFn(_ cpython.PyArgs, args cpython.PyArgs) cpython.PyRawObject {
	f.table.render()
	f.table.reset()
	return cpython.NewPyNone()
}

func (f *filament) titleFn(_ cpython.PyArgs, args cpython.PyArgs) cpython.PyRawObject {
	f.table.title(args.GetString(1))
	return cpython.NewPyNone()
}

var keywords = []string{"", "", "severity", "tags"}

func (f *filament) emitAlertFn(_, args cpython.PyArgs, kwargs cpython.PyKwargs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	senders := alertsender.FindAll()
	if len(senders) == 0 {
		log.Warn("no alertsenders registered. Alert won't be sent")
		return cpython.NewPyNone()
	}

	title, text, sever, tags := cpython.PyArgsParseKeywords(args, kwargs, keywords)

	for _, s := range senders {
		alert := alertsender.NewAlert(
			title,
			text,
			tags,
			alertsender.ParseSeverityFromString(sever),
		)
		if err := s.Send(alert); err != nil {
			log.Warnf("unable to emit alert from filament: %v", err)
		}
	}

	return cpython.NewPyNone()
}

func (f *filament) findProcessFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) findHandleFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) findProcessesFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) findHandlesFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) onInterval(fn *cpython.PyObject) {
	for {
		select {
		case <-f.tick.C:
			f.gil.Lock()
			r := fn.Call()
			if r != nil {
				r.DecRef()
			}
			if err := cpython.FetchErr(); err != nil {
				f.fnerrs <- err
			}
			f.gil.Unlock()
		case <-f.close:
		}
	}
}

```

`pkg/filament/filament_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"bufio"
	"bytes"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"strings"
	"testing"
	"time"
)

func init() {
	useEmbeddedPython = false
}

func TestNewFilament(t *testing.T) {
	t.SkipNow()
	filament, err := New("top_hives_io", nil, nil, &config.Config{Filament: config.FilamentConfig{Path: "_fixtures"}})
	require.NoError(t, err)
	require.NotNil(t, filament)
	defer filament.Close()
}

var buf bytes.Buffer

func init() {
	tableOutput = &buf
}

func TestOnNextKevent(t *testing.T) {
	// this test crashes in the CI. Reenable once
	// we investigate why this happens
	t.SkipNow()
	filament, err := New("test_on_next_kevent", nil, nil, &config.Config{Filament: config.FilamentConfig{FlushPeriod: time.Millisecond * 250, Path: "_fixtures"}})
	require.NoError(t, err)
	require.NotNil(t, filament)
	time.AfterFunc(time.Millisecond*1050, func() {
		filament.Close()
	})

	kevents := make(chan *kevent.Kevent, 100)
	errs := make(chan error, 10)
	for i := 1; i <= 100; i++ {
		kevt := &kevent.Kevent{
			Type:      ktypes.RegCreateKey,
			Tid:       2484,
			PID:       859,
			Name:      "RegCreateKey",
			Host:      "archrabbit",
			CPU:       uint8(i / 2),
			Category:  ktypes.Registry,
			Seq:       uint64(i),
			Timestamp: time.Now(),
			Kparams: kevent.Kparams{
				kparams.RegKeyName:   {Name: kparams.RegKeyName, Type: kparams.UnicodeString, Value: `HKEY_LOCAL_MACHINE\SYSTEM\Setup`},
				kparams.RegKeyHandle: {Name: kparams.RegKeyHandle, Type: kparams.HexInt64, Value: kparams.NewHex(uint64(18446666033449935464))},
				kparams.NetDIP:       {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
		}
		kevents <- kevt
	}
	err = filament.Run(kevents, errs)
	require.Nil(t, err)
	sn := bufio.NewScanner(strings.NewReader(buf.String()))
	const headerOffset = 4
	rows := 0
	for sn.Scan() {
		rows++
	}
	assert.Equal(t, 100, rows-headerOffset)
}

func TestFilamentFilter(t *testing.T) {
	// skipped for the same reason as previous test
	t.SkipNow()
	filament, err := New("test_filter", nil, nil, &config.Config{Filament: config.FilamentConfig{Path: "_fixtures"}})
	require.NoError(t, err)
	require.NotNil(t, filament)
	defer filament.Close()
	require.NotNil(t, filament.Filter())
	kpars := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
		kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.AnsiString, Value: "svchost.exe"},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(1234)},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.Uint32, Value: uint32(345)},
	}

	kevt := &kevent.Kevent{
		Type:    ktypes.CreateProcess,
		Kparams: kpars,
		Name:    "CreateProcess",
	}

	require.True(t, filament.Filter().Run(kevt))
}

```

`pkg/filament/filament_unsupported.go`:

```go
//go:build !filament
// +build !filament

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

// New returns unsupported filament error.
func New(
	name string,
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
) (Filament, error) {
	return nil, kerrors.ErrFeatureUnsupported("filament")
}

```

`pkg/filament/kdict.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/filament/cpython"
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

var (
	seq      = cpython.PyUnicodeFromString("seq")
	pid      = cpython.PyUnicodeFromString("pid")
	ppid     = cpython.PyUnicodeFromString("ppid")
	cwd      = cpython.PyUnicodeFromString("cwd")
	exec     = cpython.PyUnicodeFromString("exe")
	comm     = cpython.PyUnicodeFromString("comm")
	sid      = cpython.PyUnicodeFromString("sid")
	tid      = cpython.PyUnicodeFromString("tid")
	cpu      = cpython.PyUnicodeFromString("cpu")
	name     = cpython.PyUnicodeFromString("name")
	cat      = cpython.PyUnicodeFromString("category")
	desc     = cpython.PyUnicodeFromString("description")
	host     = cpython.PyUnicodeFromString("host")
	ts       = cpython.PyUnicodeFromString("timestamp")
	kparamsk = cpython.PyUnicodeFromString("kparams")

	errDictAllocate = errors.New("couldn't allocate a new dict")
)

// newKDict constructs a Python dictionary object from the kernel event structure. This dictionary object is
// passed to the event dispatching function in the filament.
func newKDict(kevt *kevent.Kevent) (*cpython.Dict, error) {
	kdict := cpython.NewDict()
	if kdict.IsNull() {
		return nil, errDictAllocate
	}

	// insert canonical kevent fields
	kdict.Insert(seq, cpython.NewPyObjectFromValue(kevt.Seq))
	kdict.Insert(pid, cpython.NewPyObjectFromValue(kevt.PID))
	kdict.Insert(tid, cpython.NewPyObjectFromValue(kevt.Tid))
	kdict.Insert(cpu, cpython.NewPyObjectFromValue(kevt.CPU))
	kdict.Insert(name, cpython.NewPyObjectFromValue(kevt.Name))
	kdict.Insert(cat, cpython.NewPyObjectFromValue(string(kevt.Category)))
	kdict.Insert(desc, cpython.NewPyObjectFromValue(kevt.Description))
	kdict.Insert(host, cpython.NewPyObjectFromValue(kevt.Host))
	kdict.Insert(ts, cpython.NewPyObjectFromValue(kevt.Timestamp))

	// insert process state fields
	ps := kevt.PS
	if ps != nil {
		kdict.Insert(ppid, cpython.NewPyObjectFromValue(ps.Ppid))
		kdict.Insert(cwd, cpython.NewPyObjectFromValue(ps.Cwd))
		kdict.Insert(exec, cpython.NewPyObjectFromValue(ps.Name))
		kdict.Insert(comm, cpython.NewPyObjectFromValue(ps.Comm))
		kdict.Insert(sid, cpython.NewPyObjectFromValue(ps.SID))
	}

	// insert kevent parameters
	kpars := cpython.NewDict()
	for _, kpar := range kevt.Kparams {
		kparam := cpython.NewPyObjectFromValue(kpar.Value)
		if kparam.IsNull() {
			continue
		}
		kpars.Insert(cpython.PyUnicodeFromString(kpar.Name), kparam)
	}

	kdict.Insert(kparamsk, kpars.Object())

	return kdict, nil
}

```

`pkg/filament/kdict_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/rabbitstack/fibratus/pkg/filament/cpython"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
	"time"
)

func TestProduceKdict(t *testing.T) {
	// this test crashes in the CI. Reenable once
	// we investigate why this happens
	t.SkipNow()
	err := cpython.Initialize()
	require.NoError(t, err)
	defer cpython.Finalize()
	now := time.Now()
	kevt := &kevent.Kevent{
		Seq:         uint64(12456738026482168384),
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Name:        "CreateFile",
		Timestamp:   now,
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
	}
	dict, err := newKDict(kevt)
	require.NoError(t, err)
	require.NotNil(t, dict)

	assert.Equal(t, uint64(12456738026482168384), dict.Get(seq).Uint64())
	assert.Equal(t, uint32(859), dict.Get(pid).Uint32())
	assert.Equal(t, uint32(2484), dict.Get(tid).Uint32())
	assert.Equal(t, uint8(1), uint8(dict.Get(cpu).Uint32()))
	assert.Equal(t, "CreateFile", dict.Get(name).String())
	assert.Equal(t, "file", dict.Get(cat).String())
	assert.Equal(t, "archrabbit", dict.Get(host).String())
	assert.Equal(t, "Creates or opens a new file, directory, I/O device, pipe, console", dict.Get(desc).String())

	timestamp, err := time.Parse("2006-01-02 15:04:05.000000", dict.Get(ts).String())
	require.NoError(t, err)
	assert.Equal(t, timestamp.Year(), now.Year())
	assert.Equal(t, timestamp.Hour(), now.Hour())
	assert.Equal(t, timestamp.Second(), now.Second())
}

func TestProduceKdictWithIPAddresses(t *testing.T) {
	// this test crashes in the CI. Reenable once
	// we investigate why this happens
	t.SkipNow()
	err := cpython.Initialize()
	require.NoError(t, err)
	defer cpython.Finalize()

	kevt := &kevent.Kevent{
		Name: "Send",
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv6, Value: net.ParseIP("2001:0db8:85a3:0000:0000:8a2e:0370:7334")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
	}

	dict, err := newKDict(kevt)
	require.NoError(t, err)
	require.NotNil(t, dict)

	kpars := dict.Get(cpython.PyUnicodeFromString("kparams"))
	kparamsDict := cpython.NewDictFromObject(kpars)

	assert.Equal(t, "216.58.201.174", kparamsDict.Get(cpython.PyUnicodeFromString("dip")).String())
	assert.Equal(t, "2001:db8:85a3::8a2e:370:7334", kparamsDict.Get(cpython.PyUnicodeFromString("sip")).String())
}

func BenchmarkTestProduceKdict(b *testing.B) {
	// this crashes in the CI. Reenable once
	// we investigate why this happens
	b.SkipNow()
	b.ReportAllocs()
	err := cpython.Initialize()
	require.NoError(b, err)
	defer cpython.Finalize()

	kevt := &kevent.Kevent{
		Seq:         uint64(12456738026482168384),
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
	}

	for i := 0; i < b.N; i++ {
		dict, err := newKDict(kevt)
		if err != nil || dict.IsNull() {
			b.Fatal("invalid dict produced")
		}
	}
}

```

`pkg/filament/table.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/jedib0t/go-pretty/v6/table"
	"io"
)

type tab struct {
	writer table.Writer
}

func newTable() tab {
	writer := table.NewWriter()
	writer.SetStyle(table.StyleLight)
	return tab{writer: writer}
}

func (t tab) setWriter(output io.Writer) {
	t.writer.SetOutputMirror(output)
}

func (t tab) setColumnConfigs(cols []string, maxWidth int) {
	configs := make([]table.ColumnConfig, len(cols))
	for i, col := range cols {
		configs[i] = table.ColumnConfig{Name: col, WidthMax: maxWidth}
	}
	t.writer.SetColumnConfigs(configs)
}

func (t tab) appendHeader(cols []string) {
	r := make(table.Row, len(cols))
	for i, col := range cols {
		r[i] = col
	}
	t.writer.AppendHeader(r)
}

func (t tab) appendRow(row []interface{}) {
	t.writer.AppendRow(row)
}

func (t tab) sortBy(column string) {
	t.writer.SortBy([]table.SortBy{{Name: column, Mode: table.DscNumeric}})
}

func (t tab) maxRows(size int) {
	t.writer.SetPageSize(size)
}

func (t tab) render() {
	t.writer.Render()
}

func (t tab) reset() {
	t.writer.ResetRows()
}

func (t tab) title(title string) {
	t.writer.SetTitle(title)
}

```

`pkg/filament/table_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"os"
	"testing"
)

func TestTable(t *testing.T) {
	table := newTable()
	table.setWriter(os.Stdout)
	table.appendHeader([]string{"Hive", "#Ops"})
	table.appendRow([]interface{}{"HKLM/CurrentUser", 2000})
	table.render()

	table.reset()
	table.appendRow([]interface{}{"HKLM/CurrentUser", 2000})
	table.render()
}

```

`pkg/filament/types.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

// Filament defines the set of operations all filaments have to satisfy. Filament represents a full-fledged
// Python interpreter that runs the modules given by users.
type Filament interface {
	// Run consumes all events from the kernel event stream and dispatches them to the filament.
	Run(chan *kevent.Kevent, chan error) error
	// Close shutdowns the filament by releasing all allocated resources.
	Close() error
	// Filter returns the filter compiled from filament.
	Filter() filter.Filter
}

// Info stores metadata about the filament.
type Info struct {
	Name        string
	Description string
}

```

`pkg/filter/_fixtures/default/default.yml`:

```yml
# ========================== Filter rules ================================
# This filter group rules try to mimic the subset of the sysmon config template
# created by SwiftOnSecurity (https://github.com/SwiftOnSecurity/sysmon-config).
#
# All credits for digging the rule definitions go to the above author/contributors.
#
# Obviously, some events can't be directly translated from the corresponding
# sysmon expressions, since Fibratus doesn't support them yet. In the same way,
# some filter fields are still missing in Fibratus, so that sysmon rules were
# omitted.
#
# ======================= Process creation ================================
#
# All processes launched will be logged, except for what matches a rule below.
# It's best to be as specific as possible, to avoid user-mode executables imitating
# other process names to avoid logging, or if malware drops files in an existing directory.
#
- group: Windows userspace and common apps processes
  selector:
    type: CreateProcess
  enabled: true
  policy: exclude
  relation: or
  from-strings:
    - name: Windows error reporting/telemetry, WMI provider host
      def: ps.comm startswith
          (
            ' \"C:\\Windows\\system32\\wermgr.exe\\" \"-queuereporting_svc\" ',
            'C:\\Windows\\system32\\DllHost.exe /Processid',
            'C:\\Windows\\system32\\wbem\\wmiprvse.exe -Embedding',
            'C:\\Windows\\system32\\wbem\\wmiprvse.exe -secured -Embedding'
          )
    - name: Windows error reporting/telemetry, Search Indexer, Session Manager, Auto check utility
      def: ps.comm in
          (
            'C:\\Windows\\system32\\wermgr.exe -upload',
            'C:\\Windows\\system32\\SearchIndexer.exe /Embedding',
            'C:\\windows\\system32\\wermgr.exe -queuereporting',
            '\\??\\C:\\Windows\\system32\\autochk.exe *',
            '\\SystemRoot\\System32\\smss.exe',
            'C:\\Windows\\System32\\RuntimeBroker.exe -Embedding'
          )
    - name: Various Windows processes
      def: ps.exe in
          (
            'C:\\Program Files (x86)\\Common Files\\microsoft shared\\ink\\TabTip32.exe',
            'C:\\Windows\\System32\\TokenBrokerCookies.exe',
            'C:\\Windows\\System32\\plasrv.exe',
            'C:\\Windows\\System32\\wifitask.exe',
            'C:\\Windows\\system32\\CompatTelRunner.exe',
            'C:\\Windows\\system32\\PrintIsolationHost.exe',
            'C:\\Windows\\system32\\SppExtComObj.Exe',
            'C:\\Windows\\system32\\audiodg.exe',
            'C:\\Windows\\system32\\conhost.exe',
            'C:\\Windows\\system32\\mobsync.exe',
            'C:\\Windows\\system32\\musNotification.exe',
            'C:\\Windows\\system32\\musNotificationUx.exe',
            'C:\\Windows\\system32\\powercfg.exe',
            'C:\\Windows\\system32\\sndVol.exe',
            'C:\\Windows\\system32\\sppsvc.exe',
            'C:\\Windows\\system32\\wbem\\WmiApSrv.exe'
          )
            or
          ps.comm in
          (
            'C:\\WINDOWS\\system32\\devicecensus.exe UserCxt',
            'C:\\Windows\\System32\\usocoreworker.exe -Embedding'
          )
    - name: svchost
      def: ps.comm in {{ .Values.processes.comm.svchost | stringify }}
    - name: Microsoft edge
      def: ps.comm startswith '\"C:\\Program Files (x86)\\Microsoft\\Edge Dev\\Application\\msedge.exe\" --type='
    - name: Microsoft dotNet
      def: ps.comm startswith
          (
            'C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\ngen.exe',
            'C:\\WINDOWS\\Microsoft.NET\\Framework64\\v4.0.30319\\Ngen.exe'
          )
            or
          ps.exe in
          (
            'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\mscorsvw.exe',
            'C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\mscorsvw.exe',
            'C:\\Windows\\Microsoft.Net\\Framework64\\v3.0\\WPF\\PresentationFontCache.exe'
          )
    - name: Microsoft Office
      def: ps.exe in
          (
            'C:\\Program Files\\Microsoft Office\\Office16\\MSOSYNC.EXE',
            'C:\\Program Files (x86)\\Microsoft Office\\Office16\\MSOSYNC.EXE',
            'C:\\Program Files\\Common Files\\Microsoft Shared\\OfficeSoftwareProtectionPlatform\\OSPPSVC.EXE',
            'C:\\Program Files\\Microsoft Office\\Office16\\msoia.exe',
            'C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\officebackgroundtaskhandler.exe',
            'C:\\Program Files\\Common Files\\Microsoft Shared\\ClickToRun\\OfficeC2RClient.exe'
          )
    - name: Media Player
      def: ps.exe = 'C:\\Program Files\\Windows Media Player\\wmpnscfg.exe'
    - name: Google
      def: ps.comm in
          (
            '\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\\\" --type='
          )


# ======================= Network connection initiated ================================
#
# By default this configuration takes a very conservative approach to network logging,
# limited to only extremely high-signal events.
#
- group: Suspicious network-connecting binaries
  selector:
    type: Connect
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: Suspicious sources for network-connecting binaries
      def: ps.exe startswith
          (
            'C:\\Users',
            'C:\\Recycle',
            'C:\\ProgramData',
            'C:\\Windows\\Temp',
            '\\',
            'C:\\perflogs',
            'C:\\intel',
            'C:\\Windows\\fonts',
            'C:\\Windows\\system32\\config'
          )
    - name: Suspicious Windows tools network-connecting binaries
      def: ps.name in
          (
            'at.exe',
            'certutil.exe',
            'cmd.exe',
            'cmstp.exe',
            'cscript.exe',
            'driverquery.exe',
            'dsquery.exe',
            'hh.exe',
            'infDefaultInstall.exe',
            'java.exe',
            'javaw.exe',
            'javaws.exe',
            'mmc.exe',
            'msbuild.exe',
            'mshta.exe',
            'msiexec.exe',
            'nbtstat.exe',
            'net.exe',
            'net1.exe',
            'notepad.exe',
            'nslookup.exe',
            'powershell.exe',
            'qprocess.exe',
            'qwinsta.exe',
            'reg.exe',
            'regsvcs.exe',
            'regsvr32.exe',
            'rundll32.exe',
            'rwinsta.exe',
            'sc.exe',
            'schtasks.exe',
            'taskkill.exe',
            'tasklist.exe',
            'wmic.exe',
            'wscript.exe'
          )
    - name: Relevant 3rd Party Tools
      def: ps.name in
          (
            'nc.exe',
            'ncat.exe',
            'psexec.exe',
            'psexesvc.exe',
            'tor.exe',
            'vnc.exe',
            'vncservice.exe',
            'vncviewer.exe',
            'winexesvc.exe',
            'nmap.exe',
            'psinfo.exe'
          )
    - name: Suspicious ports
      def: net.dport in
          (
            22,
            23,
            25,
            143,
            3389,
            5800,
            5900,
            444,
            1080,
            3128,
            8080,
            1723,
            9001,
            9030
          )

- group: Suspicious network-connecting binaries
  selector:
    type: Connect
  enabled: true
  policy: exclude
  relation: or
  from-strings:
    - name: Microsoft binaries
      def: ps.exe startswith 'C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\'
              or
           ps.exe endswith 'AppData\\Local\\Microsoft\\Teams\\current\\Teams.exe'
              or
           net.dip.names endswith
           (
              '.microsoft.com',
              'microsoft.com.akadns.net',
              'microsoft.com.nsatc.net'
           )
    - name: OCSP protocol known addresses
      def: net.dip in (23.4.43.27, 72.21.91.29)
    - name: Loopback addresses
      def: net.dip = 127.0.0.1 or net.dip startswith 'fe80:0:0:0'
```

`pkg/filter/_fixtures/default/values.yml`:

```yml
processes:
  comm:
    svchost:
     - C:\\Windows\\system32\\svchost.exe -k appmodel -s StateRepository
     - C:\\Windows\\system32\\svchost.exe -k appmodel -p -s camsvc
     - C:\\Windows\\system32\\svchost.exe -k appmodel
     - C:\\Windows\\system32\\svchost.exe -k appmodel -p -s tiledatamodelsvc
     - C:\\Windows\\system32\\svchost.exe -k camera -s FrameServer
     - C:\\Windows\\system32\\svchost.exe -k dcomlaunch -s LSM
     - C:\\Windows\\system32\\svchost.exe -k dcomlaunch -s PlugPlay
     # Windows defragmentation
     - C:\\Windows\\system32\\svchost.exe -k defragsvc
     - C:\\Windows\\system32\\svchost.exe -k devicesflow -s DevicesFlowUserSvc
     # Microsoft: The Windows Image Acquisition Service
     - C:\\Windows\\system32\\svchost.exe -k imgsvc
     - C:\\Windows\\system32\\svchost.exe -k localService -s EventSystem
     - C:\\Windows\\system32\\svchost.exe -k localService -s bthserv
     - C:\\Windows\\system32\\svchost.exe -k LocalService -p -s BthAvctpSvc
     - C:\\Windows\\system32\\svchost.exe -k localService -s nsi
     - C:\\Windows\\system32\\svchost.exe -k localService -s w32Time
     # Windows: Network services
     - C:\\Windows\\system32\\svchost.exe -k localServiceAndNoImpersonation
     - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s Dhcp
     - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s EventLog
     - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s TimeBrokerSvc
     - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -s WFDSConMgrSvc
     - C:\\Windows\\system32\\svchost.exe -k LocalServiceNetworkRestricted -s BTAGService
     # Win10:1903: Network Connection Broker
     - C:\\Windows\\System32\\svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService
     - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted
     - C:\\Windows\\system32\\svchost.exe -k localServiceAndNoImpersonation -s SensrSvc
     # Windows: SSDP [ https://en.wikipedia.org/wiki/Simple_Service_Discovery_Protocol ]
     - C:\\Windows\\system32\\svchost.exe -k localServiceAndNoImpersonation -p -s SSDPSRV
     - C:\\Windows\\system32\\svchost.exe -k localServiceNoNetwork
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -p -s WPDBusEnum
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -p -s fhsvc
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s DeviceAssociationService
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s NcbService
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s SensorService
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s TabletInputService
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s UmRdpService
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -s WPDBusEnum
     # Microsoft: Passport
     - C:\\Windows\\system32\\svchost.exe -k localSystemNetworkRestricted -p -s NgcSvc
     # Microsoft: Passport Container
     - C:\\Windows\\system32\\svchost.exe -k localServiceNetworkRestricted -p -s NgcCtnrSvc
```

`pkg/filter/_fixtures/exclude_policy_and.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: exclude
  relation: and
  from-strings:
    - name: ignore https connections
      def: net.dport = 443
    - name: ignore events port 44123
      def: net.sport = 44123
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match http connections
      def: net.dport = 80
```

`pkg/filter/_fixtures/exclude_policy_and_no_include_groups.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: exclude
  relation: and
  from-strings:
    - name: ignore https connections
      def: net.dport = 80
    - name: ignore events where source port != 44123
      def: net.sport != 44123

```

`pkg/filter/_fixtures/exclude_policy_or.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: exclude
  relation: or
  from-strings:
    - name: ignore https connections
      def: net.dport = 443
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match http connections
      def: net.dport = '{{ .Values.process.windows }}'
```

`pkg/filter/_fixtures/exclude_policy_or_different_include_group.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: exclude
  relation: or
  from-strings:
    - name: ignore non https connections
      def: net.dport != 443
- group: network events
  selector:
    type: CreateFile
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match files in C:/Users
      def: file.name matches 'C:/Users/*'
```

`pkg/filter/_fixtures/exclude_policy_or_no_include_groups.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: exclude
  relation: or
  from-strings:
    - name: ignore http connections
      def: net.dport = 80

```

`pkg/filter/_fixtures/groups_type_selector.yml`:

```yml
- group: network events 1
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match https connections
      def: net.dport = 443

- group: network events 2
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match http connections
      def: net.dport = 80

- group: network events 3
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match ssh connections
      def: net.dport = 22
```

`pkg/filter/_fixtures/include_exclude_remote_threads.yml`:

```yml
- group: Safe remote thread creation sources
  selector:
    type: CreateThread
  enabled: true
  policy: exclude
  relation: or
  from-strings:
    - name: System processes and common binaries
      def: kevt.pid != thread.pid
        and
        ps.exe iin
        (
        'C:\\Windows\\system32\\wbem\\WmiPrvSE.exe',
        'C:\\Windows\\system32\\svchost.exe',
        'C:\\Windows\\system32\\wininit.exe',
        'C:\\Windows\\system32\\csrss.exe',
        'C:\\Windows\\system32\\services.exe',
        'C:\\Windows\\system32\\winlogon.exe',
        'C:\\Windows\\system32\\audiodg.exe',
        'C:\\Windows\\system32\\kernel32.dll',
        'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe'
        )

- group: Suspicious remote thread creations
  selector:
    type: CreateThread
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: Fishy remote threads
      def: kevt.pid != thread.pid
```

`pkg/filter/_fixtures/include_policy_and.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: and
  from-strings:
    - name: match https connections
      def: net.dport = 443
    - name: accept events where source port = 43123
      def: net.sport = 43123
```

`pkg/filter/_fixtures/include_policy_and_not_matches.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: and
  from-strings:
    - name: match https connections
      def: net.dport = 443
    - name: accept events where source port = 44123
      def: net.sport = 44123
    - name: src ip address is not a loopback address
      def: net.sip != 127.0.0.1
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: and
  from-strings:
    - name: src ip address is
      def: net.sip = 172.0.0.1
```

`pkg/filter/_fixtures/include_policy_emit_alert.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match https connections
      def: net.dport = 443
      action: |
        {{ $text := cat .Kevt.PS.Name "process received data on port" .Kevt.Kparams.dport }}
        {{ emit "Test alert" $text "critical" "tag1" "tag2" }}
    - name: Windows error reporting/telemetry, WMI provider host
      def: ps.comm startswith
        (
          ' \"C:\\Windows\\system32\\wermgr.exe\\" \"-queuereporting_svc\" ',
          'C:\\Windows\\system32\\DllHost.exe /Processid'
        )
```

`pkg/filter/_fixtures/include_policy_or.yml`:

```yml
- group: network events
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match https connections
      def: net.dport = 443
```

`pkg/filter/_fixtures/merged_groups.yml`:

```yml
- group: network events 1
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match https connections
      def: net.dport = 443

- group: network events 2
  selector:
    category: net
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match http connections
      def: net.dport = 80

- group: network events 3
  selector:
    type: Recv
  enabled: true
  policy: include
  relation: or
  from-strings:
    - name: match ssh connections
      def: net.dport = 22
```

`pkg/filter/_fixtures/sequence_policy_complex_pattern_bindings.yml`:

```yml
- group: phishing dropper outbound communication
  policy: sequence
  enabled: true
  from-strings:
    - name: spawn browser client
      condition: >
        kevt.name = 'CreateProcess' and ps.sibling.name
          in
        ('firefox.exe', 'chrome.exe', 'edge.exe')
    - name: downloaded executable file
      condition: >
        kevt.name = 'CreateFile' and file.operation = 'create'
          and
        file.extension = '.exe'
          and
        ps.pid = $1.ps.sibling.pid
      max-span: 1h
    - name: spawn dropper process
      condition: >
        kevt.name = 'CreateProcess' and ps.sibling.exe = $2.file.name
    - name: outbound communication
      condition: >
        kevt.name in ('Send', 'Connect') and ps.pid = $3.ps.sibling.pid
  action: >
      {{ emit "Phishing dropper outbound communication"
        (printf "%s process initiated outbound communication to %s" .Kevts.k3.Kparams.name .Kevts.k4.Kparams.dip)
      }}

```

`pkg/filter/_fixtures/sequence_policy_simple.yml`:

```yml
- group: command shell execution and temp files
  policy: sequence
  enabled: true
  from-strings:
    - name: spawn command shell
      condition: kevt.name = 'CreateProcess' and ps.name = 'cmd.exe'
    - name: created temp file by command shell
      condition: >
        kevt.name = 'CreateFile' and ps.name = 'cmd.exe' and file.name icontains 'temp'

```

`pkg/filter/_fixtures/sequence_policy_simple_max_span.yml`:

```yml
- group: command shell execution and temp files
  policy: sequence
  enabled: true
  from-strings:
    - name: spawn command shell
      condition: kevt.name = 'CreateProcess' and ps.name = 'cmd.exe'
    - name: created temp file by command shell
      condition: >
        kevt.name = 'CreateFile' and ps.name = 'cmd.exe' and file.name icontains 'temp'
      max-span: 200ms

```

`pkg/filter/_fixtures/sequence_policy_simple_pattern_bindings.yml`:

```yml
- group: command shell execution and temp files
  policy: sequence
  rules:
    - name: spawn command shell
      condition: kevt.name = 'CreateProcess' and ps.name = 'cmd.exe'
    - name: created temp file by command shell
      condition: >
        kevt.name = 'CreateFile'
          and
        ps.pid = $1.ps.pid
          and
        file.name icontains 'temp'
      max-span: 100ms

```

`pkg/filter/_fixtures/values.yml`:

```yml
process:
  windows: svchost.exe
```

`pkg/filter/accessor.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"errors"

	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
)

var (
	// ErrPsNil indicates the process state associated with the event is not initialized
	ErrPsNil = errors.New("process state is nil")
)

// kevtAccessor extracts kernel event specific values.
type kevtAccessor struct{}

func newKevtAccessor() accessor {
	return &kevtAccessor{}
}

const timeFmt = "15:04:05"
const dateFmt = "2006-01-02"

func (k *kevtAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.KevtSeq:
		return kevt.Seq, nil
	case fields.KevtPID:
		return kevt.PID, nil
	case fields.KevtTID:
		return kevt.Tid, nil
	case fields.KevtCPU:
		return kevt.CPU, nil
	case fields.KevtName:
		return kevt.Name, nil
	case fields.KevtCategory:
		return string(kevt.Category), nil
	case fields.KevtDesc:
		return kevt.Description, nil
	case fields.KevtHost:
		return kevt.Host, nil
	case fields.KevtTime:
		return kevt.Timestamp.Format(timeFmt), nil
	case fields.KevtTimeHour:
		return uint8(kevt.Timestamp.Hour()), nil
	case fields.KevtTimeMin:
		return uint8(kevt.Timestamp.Minute()), nil
	case fields.KevtTimeSec:
		return uint8(kevt.Timestamp.Second()), nil
	case fields.KevtTimeNs:
		return kevt.Timestamp.UnixNano(), nil
	case fields.KevtDate:
		return kevt.Timestamp.Format(dateFmt), nil
	case fields.KevtDateDay:
		return uint8(kevt.Timestamp.Day()), nil
	case fields.KevtDateMonth:
		return uint8(kevt.Timestamp.Month()), nil
	case fields.KevtDateTz:
		tz, _ := kevt.Timestamp.Zone()
		return tz, nil
	case fields.KevtDateYear:
		return uint32(kevt.Timestamp.Year()), nil
	case fields.KevtDateWeek:
		_, week := kevt.Timestamp.ISOWeek()
		return uint8(week), nil
	case fields.KevtDateWeekday:
		return kevt.Timestamp.Weekday().String(), nil
	case fields.KevtNparams:
		return uint64(kevt.Kparams.Len()), nil
	default:
		return nil, nil
	}
}

```

`pkg/filter/accessor_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"errors"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"

	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/network"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
)

// accessor dictates the behaviour of the field accessors. One of the main responsibilities of the accessor is
// to extract the underlying parameter for the field given in the filter expression. It can also produce a value
// from the non-params constructs such as process' state or PE metadata.
type accessor interface {
	// get fetches the parameter value for the specified filter field.
	get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error)
}

// getAccessors initializes and returns all available accessors.
func getAccessors() []accessor {
	return []accessor{
		newPSAccessor(),
		newPEAccessor(),
		newFileAccessor(),
		newKevtAccessor(),
		newImageAccessor(),
		newThreadAccessor(),
		newHandleAccessor(),
		newNetworkAccessor(),
		newRegistryAccessor(),
	}
}

func getParentPs(kevt *kevent.Kevent) *pstypes.PS {
	if kevt.PS == nil {
		return nil
	}
	return kevt.PS.Parent
}

// psAccessor extracts process's state or kevent specific values.
type psAccessor struct{}

func newPSAccessor() accessor { return &psAccessor{} }

func (ps *psAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.PsPid:
		// the process id that is generating the event
		return kevt.PID, nil
	case fields.PsSiblingPid:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		// the id of a freshly created process. `kevt.PID` references the parent process
		return kevt.Kparams.GetPid()
	case fields.PsPpid:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Ppid, nil
	case fields.PsName:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Name, nil
	case fields.PsSiblingName:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.ProcessName)
	case fields.PsComm:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Comm, nil
	case fields.PsSiblingComm:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.Comm)
	case fields.PsExe:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Exe, nil
	case fields.PsSiblingExe:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.Exe)
	case fields.PsArgs:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Args, nil
	case fields.PsCwd:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Cwd, nil
	case fields.PsSID:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.SID, nil
	case fields.PsSiblingSID:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.UserSID)
	case fields.PsSiblingDomain:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		sid, err := kevt.Kparams.GetString(kparams.UserSID)
		if err != nil {
			return nil, err
		}
		return domainFromSID(sid)
	case fields.PsSiblingUsername:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		sid, err := kevt.Kparams.GetString(kparams.UserSID)
		if err != nil {
			return nil, err
		}
		return usernameFromSID(sid)
	case fields.PsDomain:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return domainFromSID(ps.SID)
	case fields.PsUsername:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return usernameFromSID(ps.SID)
	case fields.PsSessionID:
		ps := kevt.PS
		if ps == nil {
			return nil, nil
		}
		return ps.SessionID, nil
	case fields.PsAccessMask:
		if kevt.Type != ktypes.OpenProcess {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.DesiredAccess)
	case fields.PsAccessMaskNames:
		if kevt.Type != ktypes.OpenProcess {
			return nil, nil
		}
		return kevt.Kparams.GetSlice(kparams.DesiredAccessNames)
	case fields.PsAccessStatus:
		if kevt.Type != ktypes.OpenProcess {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.NTStatus)
	case fields.PsSiblingSessionID:
		if kevt.Category != ktypes.Process {
			return nil, nil
		}
		return kevt.Kparams.GetUint32(kparams.SessionID)
	case fields.PsEnvs:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		envs := make([]string, 0, len(ps.Envs))
		for env := range ps.Envs {
			envs = append(envs, env)
		}
		return envs, nil
	case fields.PsModules:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		mods := make([]string, 0, len(ps.Modules))
		for _, m := range ps.Modules {
			mods = append(mods, filepath.Base(m.Name))
		}
		return mods, nil
	case fields.PsHandles:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		handles := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			handles[i] = handle.Name
		}
		return handles, nil
	case fields.PsHandleTypes:
		ps := kevt.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		types := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			if types[i] == handle.Type {
				continue
			}
			types[i] = handle.Type
		}
		return types, nil
	case fields.PsParentPid:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.PID, nil
	case fields.PsParentName:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Name, nil
	case fields.PsParentComm:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Comm, nil
	case fields.PsParentExe:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Exe, nil
	case fields.PsParentArgs:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Args, nil
	case fields.PsParentCwd:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Cwd, nil
	case fields.PsParentSID:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.SID, nil
	case fields.PsParentDomain:
		ps := getParentPs(kevt)
		if ps == nil {
			return nil, ErrPsNil
		}
		return domainFromSID(ps.SID)
	case fields.PsParentUsername:
		ps := getParentPs(kevt)
		if ps == nil {
			return nil, ErrPsNil
		}
		return usernameFromSID(ps.SID)
	case fields.PsParentSessionID:
		parent := getParentPs(kevt)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.SessionID, nil
	case fields.PsParentEnvs:
		ps := getParentPs(kevt)
		if ps == nil {
			return nil, ErrPsNil
		}
		envs := make([]string, 0, len(ps.Envs))
		for env := range ps.Envs {
			envs = append(envs, env)
		}
		return envs, nil
	case fields.PsParentHandles:
		ps := getParentPs(kevt)
		if ps == nil {
			return nil, ErrPsNil
		}
		handles := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			handles[i] = handle.Name
		}
		return handles, nil
	case fields.PsParentHandleTypes:
		ps := getParentPs(kevt)
		if ps == nil {
			return nil, ErrPsNil
		}
		types := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			if types[i] == handle.Type {
				continue
			}
			types[i] = handle.Type
		}
		return types, nil
	default:
		switch {
		case f.IsEnvsSequence():
			// access the specific environment variable
			env, _ := captureInBrackets(f.String())
			ps := kevt.PS
			if ps == nil {
				return nil, ErrPsNil
			}
			v, ok := ps.Envs[env]
			if ok {
				return v, nil
			}
			// match on prefix
			for k, v := range ps.Envs {
				if strings.HasPrefix(k, env) {
					return v, nil
				}
			}
		case f.IsModsSequence():
			name, segment := captureInBrackets(f.String())
			ps := kevt.PS
			if ps == nil {
				return nil, ErrPsNil
			}
			mod := ps.FindModule(name)
			if mod == nil {
				return nil, nil
			}

			switch segment {
			case fields.ModuleSize:
				return mod.Size, nil
			case fields.ModuleChecksum:
				return mod.Checksum, nil
			case fields.ModuleBaseAddress:
				return mod.BaseAddress.String(), nil
			case fields.ModuleDefaultAddress:
				return mod.DefaultBaseAddress.String(), nil
			case fields.ModuleLocation:
				return filepath.Dir(mod.Name), nil
			}
		case f.IsAncestorSequence():
			return ancestorFields(f.String(), kevt)
		}

		return nil, nil
	}
}

func domainFromSID(sid string) (string, error) {
	s := strings.Split(sid, "\\")
	if len(s) != 2 {
		return "", fmt.Errorf("illegal split for the domain field. Expected 2 but got %d substrings", len(s))
	}
	return s[0], nil
}

func usernameFromSID(sid string) (string, error) {
	s := strings.Split(sid, "\\")
	if len(s) != 2 {
		return "", fmt.Errorf("illegal split for the username field. Expected 2 but got %d substrings", len(s))
	}
	return s[1], nil
}

// ancestorFields recursively walks the process ancestors and extracts
// the required field values. If we get the `root` key, the root ancestor
// fields are inspected, while `any` accumulates values of all ancestors.
// Alternatively, the key may represent the depth that only returns the
// ancestor located at the given depth, starting with 1 which is the immediate
// process parent.
func ancestorFields(field string, kevt *kevent.Kevent) (kparams.Value, error) {
	key, segment := captureInBrackets(field)
	if key == "" || segment == "" {
		return nil, nil
	}

	var ps *pstypes.PS

	switch key {
	case "root":
		walk := func(proc *pstypes.PS) {
			ps = proc
		}
		pstypes.Walk(walk, kevt.PS)
	case "any":
		values := make([]string, 0)
		walk := func(proc *pstypes.PS) {
			switch segment {
			case fields.ProcessName:
				values = append(values, proc.Name)
			case fields.ProcessID:
				values = append(values, strconv.Itoa(int(proc.PID)))
			case fields.ProcessSID:
				values = append(values, proc.SID)
			case fields.ProcessSessionID:
				values = append(values, strconv.Itoa(int(proc.SessionID)))
			case fields.ProcessCwd:
				values = append(values, proc.Cwd)
			case fields.ProcessComm:
				values = append(values, proc.Comm)
			case fields.ProcessArgs:
				values = append(values, proc.Args...)
			case fields.ProcessExe:
				values = append(values, proc.Exe)
			}
		}
		pstypes.Walk(walk, kevt.PS)
		return values, nil
	default:
		depth, err := strconv.Atoi(key)
		if err != nil {
			return nil, err
		}
		var i int
		walk := func(proc *pstypes.PS) {
			i++
			if i == depth {
				ps = proc
			}
		}
		pstypes.Walk(walk, kevt.PS)
	}

	if ps == nil {
		return nil, nil
	}

	switch segment {
	case fields.ProcessName:
		return ps.Name, nil
	case fields.ProcessID:
		return ps.PID, nil
	case fields.ProcessSID:
		return ps.SID, nil
	case fields.ProcessSessionID:
		return ps.SessionID, nil
	case fields.ProcessCwd:
		return ps.Cwd, nil
	case fields.ProcessComm:
		return ps.Comm, nil
	case fields.ProcessArgs:
		return ps.Args, nil
	case fields.ProcessExe:
		return ps.Exe, nil
	}

	return nil, nil
}

// threadAccessor fetches thread parameters from thread kernel events.
type threadAccessor struct{}

func newThreadAccessor() accessor {
	return &threadAccessor{}
}

func (t *threadAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.ThreadBasePrio:
		return kevt.Kparams.GetUint8(kparams.BasePrio)
	case fields.ThreadIOPrio:
		return kevt.Kparams.GetUint8(kparams.IOPrio)
	case fields.ThreadPagePrio:
		return kevt.Kparams.GetUint8(kparams.PagePrio)
	case fields.ThreadKstackBase:
		v, err := kevt.Kparams.GetHex(kparams.KstackBase)
		if err != nil {
			return nil, err
		}
		return v.String(), nil
	case fields.ThreadKstackLimit:
		v, err := kevt.Kparams.GetHex(kparams.KstackLimit)
		if err != nil {
			return nil, err
		}
		return v.String(), nil
	case fields.ThreadUstackBase:
		v, err := kevt.Kparams.GetHex(kparams.UstackBase)
		if err != nil {
			return nil, err
		}
		return v.String(), nil
	case fields.ThreadUstackLimit:
		v, err := kevt.Kparams.GetHex(kparams.UstackLimit)
		if err != nil {
			return nil, err
		}
		return v.String(), nil
	case fields.ThreadEntrypoint:
		v, err := kevt.Kparams.GetHex(kparams.ThreadEntrypoint)
		if err != nil {
			return nil, err
		}
		return v.String(), nil
	case fields.ThreadPID:
		return kevt.Kparams.GetUint32(kparams.ProcessID)
	case fields.ThreadAccessMask:
		if kevt.Type != ktypes.OpenThread {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.DesiredAccess)
	case fields.ThreadAccessMaskNames:
		if kevt.Type != ktypes.OpenThread {
			return nil, nil
		}
		return kevt.Kparams.GetSlice(kparams.DesiredAccessNames)
	case fields.ThreadAccessStatus:
		if kevt.Type != ktypes.OpenThread {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.NTStatus)
	}
	return nil, nil
}

// fileAccessor extracts file specific values.
type fileAccessor struct{}

func newFileAccessor() accessor {
	return &fileAccessor{}
}

func (l *fileAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.FileName:
		return kevt.Kparams.GetString(kparams.FileName)
	case fields.FileOffset:
		return kevt.Kparams.GetUint64(kparams.FileOffset)
	case fields.FileIOSize:
		return kevt.Kparams.GetUint32(kparams.FileIoSize)
	case fields.FileShareMask:
		m, err := kevt.Kparams.Get(kparams.FileShareMask)
		if err != nil {
			return nil, err
		}
		mode, ok := m.(fs.FileShareMode)
		if !ok {
			return nil, errors.New("couldn't type assert to file share mode enum")
		}
		return mode.String(), nil
	case fields.FileOperation:
		op, err := kevt.Kparams.Get(kparams.FileOperation)
		if err != nil {
			return nil, err
		}
		fop, ok := op.(fs.FileDisposition)
		if !ok {
			return nil, errors.New("couldn't type assert to file operation enum")
		}
		return fop.String(), nil
	case fields.FileObject:
		return kevt.Kparams.GetUint64(kparams.FileObject)
	case fields.FileType:
		return kevt.Kparams.GetString(kparams.FileType)
	case fields.FileExtension:
		file, err := kevt.Kparams.GetString(kparams.FileName)
		if err != nil {
			return nil, err
		}
		return filepath.Ext(file), nil
	case fields.FileAttributes:
		val, err := kevt.Kparams.GetSlice(kparams.FileAttributes)
		if err != nil {
			return nil, err
		}
		slice, ok := val.([]fs.FileAttr)
		if !ok {
			return nil, nil
		}
		// convert from []fs.FileAttr to string slice
		attrs := make([]string, 0, len(slice))
		for _, attr := range slice {
			attrs = append(attrs, attr.String())
		}
		return attrs, nil
	case fields.FileStatus:
		if kevt.Type != ktypes.CreateFile {
			return nil, nil
		}
		return kevt.Kparams.GetString(kparams.NTStatus)
	}
	return nil, nil
}

// imageAccessor extracts image (DLL) kevent values.
type imageAccessor struct{}

func newImageAccessor() accessor {
	return &imageAccessor{}
}

func (i *imageAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.ImageName:
		return kevt.Kparams.GetString(kparams.ImageFilename)
	case fields.ImageDefaultAddress:
		address, err := kevt.Kparams.GetHex(kparams.ImageDefaultBase)
		if err != nil {
			return nil, err
		}
		return address.String(), nil
	case fields.ImageBase:
		address, err := kevt.Kparams.GetHex(kparams.ImageBase)
		if err != nil {
			return nil, err
		}
		return address.String(), nil
	case fields.ImageSize:
		return kevt.Kparams.GetUint32(kparams.ImageSize)
	case fields.ImageChecksum:
		return kevt.Kparams.GetUint32(kparams.ImageCheckSum)
	case fields.ImagePID:
		return kevt.Kparams.GetPid()
	}
	return nil, nil
}

// registryAccessor extracts registry specific parameters.
type registryAccessor struct{}

func newRegistryAccessor() accessor {
	return &registryAccessor{}
}

func (r *registryAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.RegistryKeyName:
		return kevt.Kparams.GetString(kparams.RegKeyName)
	case fields.RegistryKeyHandle:
		keyHandle, err := kevt.Kparams.GetHex(kparams.RegKeyHandle)
		if err != nil {
			return nil, err
		}
		return keyHandle.String(), nil
	case fields.RegistryValue:
		return kevt.Kparams.Get(kparams.RegValue)
	case fields.RegistryValueType:
		return kevt.Kparams.GetString(kparams.RegValueType)
	case fields.RegistryStatus:
		return kevt.Kparams.GetString(kparams.NTStatus)
	}
	return nil, nil
}

// networkAccessor deals with extracting the network specific kernel event parameters.
type networkAccessor struct{}

func newNetworkAccessor() accessor { return &networkAccessor{} }

func (n *networkAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.NetDIP:
		return kevt.Kparams.GetIP(kparams.NetDIP)
	case fields.NetSIP:
		return kevt.Kparams.GetIP(kparams.NetSIP)
	case fields.NetDport:
		return kevt.Kparams.GetUint16(kparams.NetDport)
	case fields.NetSport:
		return kevt.Kparams.GetUint16(kparams.NetSport)
	case fields.NetDportName:
		return kevt.Kparams.GetString(kparams.NetDportName)
	case fields.NetSportName:
		return kevt.Kparams.GetString(kparams.NetSportName)
	case fields.NetL4Proto:
		v, err := kevt.Kparams.Get(kparams.NetL4Proto)
		if err != nil {
			return nil, err
		}
		l4proto, ok := v.(network.L4Proto)
		if !ok {
			return nil, errors.New("couldn't type assert to L4 proto enum")
		}
		return l4proto.String(), nil
	case fields.NetPacketSize:
		return kevt.Kparams.GetUint32(kparams.NetSize)
	case fields.NetSIPNames:
		return kevt.Kparams.GetStringSlice(kparams.NetSIPNames)
	case fields.NetDIPNames:
		return kevt.Kparams.GetStringSlice(kparams.NetDIPNames)
	}
	return nil, nil
}

// handleAccessor extracts handle event values.
type handleAccessor struct{}

func newHandleAccessor() accessor { return &handleAccessor{} }

func (h *handleAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	switch f {
	case fields.HandleID:
		return kevt.Kparams.GetHexAsUint32(kparams.HandleID)
	case fields.HandleType:
		return kevt.Kparams.GetString(kparams.HandleObjectTypeName)
	case fields.HandleName:
		return kevt.Kparams.GetString(kparams.HandleObjectName)
	case fields.HandleObject:
		handleObject, err := kevt.Kparams.GetHex(kparams.HandleObject)
		if err != nil {
			return nil, err
		}
		return handleObject.String(), nil
	}
	return nil, nil
}

// peAccessor extracts PE specific values.
type peAccessor struct{}

func newPEAccessor() accessor {
	return &peAccessor{}
}

func (*peAccessor) get(f fields.Field, kevt *kevent.Kevent) (kparams.Value, error) {
	var p *pe.PE
	if kevt.PS != nil && kevt.PS.PE != nil {
		p = kevt.PS.PE
	}
	if p == nil {
		return nil, nil
	}

	switch f {
	case fields.PeEntrypoint:
		return p.EntryPoint, nil
	case fields.PeBaseAddress:
		return p.ImageBase, nil
	case fields.PeNumSections:
		return p.NumberOfSections, nil
	case fields.PeNumSymbols:
		return p.NumberOfSymbols, nil
	case fields.PeSymbols:
		return p.Symbols, nil
	case fields.PeImports:
		return p.Imports, nil
	case fields.PeCompany:
		return p.VersionResources[pe.Company], nil
	case fields.PeCopyright:
		return p.VersionResources[pe.LegalCopyright], nil
	case fields.PeDescription:
		return p.VersionResources[pe.FileDescription], nil
	case fields.PeFileName:
		return p.VersionResources[pe.OriginalFilename], nil
	case fields.PeFileVersion:
		return p.VersionResources[pe.FileVersion], nil
	case fields.PeProduct:
		return p.VersionResources[pe.ProductName], nil
	case fields.PeProductVersion:
		return p.VersionResources[pe.ProductVersion], nil
	default:
		switch {
		case f.IsPeSectionsSequence():
			// get the section name
			sname, segment := captureInBrackets(f.String())
			sec := p.Section(sname)
			if sec == nil {
				return nil, nil
			}
			switch segment {
			case fields.SectionEntropy:
				return sec.Entropy, nil
			case fields.SectionMD5Hash:
				return sec.Md5, nil
			case fields.SectionSize:
				return sec.Size, nil
			}
		case f.IsPeResourcesSequence():
			// consult the resource name
			key, _ := captureInBrackets(f.String())
			v, ok := p.VersionResources[key]
			if ok {
				return v, nil
			}
			// match on prefix (e.g. pe.resources[Org] = Blackwater)
			for k, v := range p.VersionResources {
				if strings.HasPrefix(k, key) {
					return v, nil
				}
			}
		}
	}

	return nil, nil
}

func captureInBrackets(s string) (string, fields.Segment) {
	lbracket := strings.Index(s, "[")
	if lbracket == -1 {
		return "", ""
	}
	rbracket := strings.Index(s, "]")
	if rbracket == -1 {
		return "", ""
	}
	if lbracket+1 > len(s) {
		return "", ""
	}
	if rbracket+2 < len(s) {
		return s[lbracket+1 : rbracket], fields.Segment(s[rbracket+2:])
	}
	return s[lbracket+1 : rbracket], ""
}

```

`pkg/filter/accessor_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/pe"
	ptypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestPSAccessor(t *testing.T) {
	ps := newPSAccessor()
	kevt := &kevent.Kevent{
		PS: &ptypes.PS{
			Envs: map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
		},
	}

	env, err := ps.get(fields.Field("ps.envs[ALLUSERSPROFILE]"), kevt)
	require.NoError(t, err)
	assert.Equal(t, "C:\\ProgramData", env)

	env, err = ps.get(fields.Field("ps.envs[ALLUSER]"), kevt)
	require.NoError(t, err)
	assert.Equal(t, "C:\\ProgramData", env)

	env, err = ps.get(fields.Field("ps.envs[ProgramFiles]"), kevt)
	require.NoError(t, err)
	assert.Equal(t, "C:\\Program Files (x86)", env)
}

func TestPEAccessor(t *testing.T) {
	pea := newPEAccessor()
	kevt := &kevent.Kevent{
		PS: &ptypes.PS{
			PE: &pe.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pe.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	entropy, err := pea.get(fields.Field("pe.sections[.text].entropy"), kevt)
	require.NoError(t, err)
	assert.Equal(t, 6.368381, entropy)

	v, err := pea.get(fields.Field("pe.sections[.text].md6"), kevt)
	require.NoError(t, err)
	require.Nil(t, v)

	md5, err := pea.get(fields.Field("pe.sections[.rdata].md5"), kevt)
	require.NoError(t, err)
	require.Nil(t, v)
	assert.Equal(t, "ffa5c960b421ca9887e54966588e97e8", md5)

	company, err := pea.get(fields.Field("pe.resources[CompanyName]"), kevt)
	require.NoError(t, err)
	assert.Equal(t, "Microsoft Corporation", company)
}

func TestCaptureInBrackets(t *testing.T) {
	v, subfield := captureInBrackets("ps.envs[ALLUSERSPROFILE]")
	assert.Equal(t, "ALLUSERSPROFILE", v)
	assert.Empty(t, subfield)

	v, subfield = captureInBrackets("ps.pe.sections[.debug$S].entropy")
	assert.Equal(t, ".debug$S", v)
	assert.Equal(t, fields.SectionEntropy, subfield)
}

```

`pkg/filter/fields/fields.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fields

import (
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"sort"
)

// FieldInfo is the field metadata descriptor.
type FieldInfo struct {
	Field    Field
	Desc     string
	Type     kparams.Type
	Examples []string
}

// Get returns a slice of field information.
func Get() []FieldInfo {
	fi := make([]FieldInfo, 0, len(fields))
	for _, field := range fields {
		fi = append(fi, field)
	}
	sort.Slice(fi, func(i, j int) bool { return fi[i].Field < fi[j].Field })
	return fi
}

```

`pkg/filter/fields/fields_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fields

import (
	"regexp"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
)

// pathRegexp splits the provided path into different components. The first capture
// contains the indexed field name. Next is the indexed key and, finally the segment.
var pathRegexp = regexp.MustCompile(`(pe.sections|pe.resources|ps.envs|ps.modules|ps.ancestor)\[(.+\s*)].?(.*)`)

// Field represents the type alias for the field
type Field string

const (
	// PsPid represents the process id field
	PsPid Field = "ps.pid"
	// PsPpid represents the parent process id field
	PsPpid Field = "ps.ppid"
	// PsName represents the process name field
	PsName Field = "ps.name"
	// PsComm represents the process command line field
	PsComm Field = "ps.comm"
	// PsExe represents the process image path field
	PsExe Field = "ps.exe"
	// PsArgs represents the process command line arguments
	PsArgs Field = "ps.args"
	// PsCwd represents the process current working directory
	PsCwd Field = "ps.cwd"
	// PsSID represents the process security identifier
	PsSID Field = "ps.sid"
	// PsDomain represents the process domain field
	PsDomain Field = "ps.domain"
	// PsUsername represents the process username field
	PsUsername Field = "ps.username"
	// PsSessionID represents the session id bound to the process
	PsSessionID Field = "ps.sessionid"
	// PsEnvs represents the process environment variables
	PsEnvs Field = "ps.envs"
	// PsHandles represents the process handles
	PsHandles Field = "ps.handles"
	// PsHandleTypes represents the process handle types
	PsHandleTypes Field = "ps.handle.types"
	// PsDTB represents the process directory table base address
	PsDTB Field = "ps.dtb"
	// PsModules represents the process modules
	PsModules Field = "ps.modules"
	// PsParentPid represents the parent process identifier field
	PsParentPid Field = "ps.parent.pid"
	// PsParentName represents the parent process name field
	PsParentName Field = "ps.parent.name"
	// PsParentComm represents the parent process command line field
	PsParentComm Field = "ps.parent.comm"
	// PsParentExe represents the parent process image path field
	PsParentExe Field = "ps.parent.exe"
	// PsParentArgs represents the parent process command line arguments field
	PsParentArgs Field = "ps.parent.args"
	// PsParentCwd represents the parent process current working directory field
	PsParentCwd Field = "ps.parent.cwd"
	// PsParentSID represents the parent process security identifier field
	PsParentSID Field = "ps.parent.sid"
	// PsParentUsername represents the parent process username field
	PsParentUsername Field = "ps.parent.username"
	// PsParentDomain represents the parent process domain field
	PsParentDomain Field = "ps.parent.domain"
	// PsParentSessionID represents the session id field bound to the parent process
	PsParentSessionID Field = "ps.parent.sessionid"
	// PsParentEnvs represents the parent process environment variables field
	PsParentEnvs Field = "ps.parent.envs"
	// PsParentHandles represents the parent process handles field
	PsParentHandles Field = "ps.parent.handles"
	// PsParentHandleTypes represents the parent process handle types field
	PsParentHandleTypes Field = "ps.parent.handle.types"
	// PsParentDTB represents the parent process directory table base address field
	PsParentDTB Field = "ps.parent.dtb"
	// PsAncestor represents the process ancestor sequence field
	PsAncestor Field = "ps.ancestor"
	// PsAccessMask represents the process access rights field
	PsAccessMask Field = "ps.access.mask"
	// PsAccessMaskNames represents the process access rights list field
	PsAccessMaskNames Field = "ps.access.mask.names"
	// PsAccessStatus represents the process access status field
	PsAccessStatus Field = "ps.access.status"

	// PsSiblingPid represents the sibling process identifier field
	PsSiblingPid Field = "ps.sibling.pid"
	// PsSiblingName represents the sibling process name field
	PsSiblingName Field = "ps.sibling.name"
	// PsSiblingComm represents the sibling process command line field
	PsSiblingComm Field = "ps.sibling.comm"
	// PsSiblingExe represents the sibling process complete executable path field
	PsSiblingExe Field = "ps.sibling.exe"
	// PsSiblingSID represents the sibling processes security identifier field
	PsSiblingSID Field = "ps.sibling.sid"
	// PsSiblingSessionID represents the sibling process session id field
	PsSiblingSessionID Field = "ps.sibling.sessionid"
	// PsSiblingDomain represents the sibling process domain field
	PsSiblingDomain Field = "ps.sibling.domain"
	// PsSiblingUsername represents the sibling process username field
	PsSiblingUsername Field = "ps.sibling.username"

	// ThreadBasePrio is the base thread priority
	ThreadBasePrio Field = "thread.prio"
	// ThreadIOPrio is the thread I/O priority
	ThreadIOPrio Field = "thread.io.prio"
	// ThreadPagePrio is the thread page priority
	ThreadPagePrio Field = "thread.page.prio"
	// ThreadKstackBase is the thread kernel stack start address
	ThreadKstackBase Field = "thread.kstack.base"
	// ThreadKstackLimit is the thread kernel stack end address
	ThreadKstackLimit Field = "thread.kstack.limit"
	// ThreadUstackBase is the thread user stack start address
	ThreadUstackBase Field = "thread.ustack.base"
	// ThreadUstackLimit is the thead user stack end address
	ThreadUstackLimit Field = "thread.ustack.limit"
	// ThreadEntrypoint is the thread entrypoint address
	ThreadEntrypoint Field = "thread.entrypoint"
	// ThreadPID is the process identifier where the thread is created
	ThreadPID Field = "thread.pid"
	// ThreadAccessMask represents the thread access rights field
	ThreadAccessMask Field = "thread.access.mask"
	// ThreadAccessMaskNames represents the thread access rights list field
	ThreadAccessMaskNames Field = "thread.access.mask.names"
	// ThreadAccessStatus represents the thread access status field
	ThreadAccessStatus Field = "thread.access.status"

	// PeNumSections represents the number of sections
	PeNumSections Field = "pe.nsections"
	// PeSections represents distinct section inside PE
	PeSections Field = "pe.sections"
	// PeNumSymbols represents the number of exported symbols
	PeNumSymbols Field = "pe.nsymbols"
	// PeSymbols represents imported symbols
	PeSymbols Field = "pe.symbols"
	// PeImports represents imported libraries (e.g. kernel32.dll)
	PeImports Field = "pe.imports"
	// PeTimestamp is the PE build timestamp
	PeTimestamp Field = "pe.timestamp"
	// PeBaseAddress represents the base address when the binary is loaded
	PeBaseAddress Field = "pe.address.base"
	// PeEntrypoint is the address of the entrypoint function
	PeEntrypoint Field = "pe.address.entrypoint"
	// PeResources represents PE resources
	PeResources Field = "pe.resources"
	// PeCompany represents the company name resource
	PeCompany Field = "pe.company"
	// PeDescription represents the internal description of the file
	PeDescription Field = "pe.description"
	// PeFileVersion represents the internal file version
	PeFileVersion Field = "pe.file.version"
	// PeFileName represents the original file name provided at compile-time.
	PeFileName Field = "pe.file.name"
	// PeCopyright represents the copyright notice emitted at compile-time
	PeCopyright Field = "pe.copyright"
	// PeProduct represents the product name provided at compile-time
	PeProduct Field = "pe.product"
	// PeProductVersion represents the internal product version provided at compile-time
	PeProductVersion Field = "pe.product.version"

	// KevtSeq is the event sequence number
	KevtSeq Field = "kevt.seq"
	// KevtPID is the process identifier that generated the event
	KevtPID Field = "kevt.pid"
	// KevtTID is the thread identifier that generated the event
	KevtTID Field = "kevt.tid"
	// KevtCPU is the CPU core where the event was generated
	KevtCPU Field = "kevt.cpu"
	// KevtDesc represents the event description
	KevtDesc Field = "kevt.desc"
	// KevtHost represents the host where the event was produced
	KevtHost Field = "kevt.host"
	// KevtTime is the event time
	KevtTime Field = "kevt.time"
	// KevtTimeHour is the hour part of the event time
	KevtTimeHour Field = "kevt.time.h"
	// KevtTimeMin is the minute part of the event time
	KevtTimeMin Field = "kevt.time.m"
	// KevtTimeSec is the second part of the event time
	KevtTimeSec Field = "kevt.time.s"
	// KevtTimeNs is the nanosecond part of the event time
	KevtTimeNs Field = "kevt.time.ns"
	// KevtDate is the event date
	KevtDate Field = "kevt.date"
	// KevtDateDay is the day of event date
	KevtDateDay Field = "kevt.date.d"
	// KevtDateMonth is the month of event date
	KevtDateMonth Field = "kevt.date.m"
	// KevtDateYear is the year of event date
	KevtDateYear Field = "kevt.date.y"
	// KevtDateTz is the time zone of event timestamp
	KevtDateTz Field = "kevt.date.tz"
	// KevtDateWeek is the event week number
	KevtDateWeek Field = "kevt.date.week"
	// KevtDateWeekday is the event week day
	KevtDateWeekday Field = "kevt.date.weekday"
	// KevtName is the event name
	KevtName Field = "kevt.name"
	// KevtCategory is the event category
	KevtCategory Field = "kevt.category"
	// KevtMeta is the event metadata
	KevtMeta Field = "kevt.meta"
	// KevtNparams is the number of event parameters
	KevtNparams Field = "kevt.nparams"

	// HandleID represents the handle identifier within the process address space
	HandleID Field = "handle.id"
	// HandleObject represents the handle object address
	HandleObject Field = "handle.object"
	// HandleName represents the handle name
	HandleName Field = "handle.name"
	// HandleType represents the handle type (e.g. file)
	HandleType Field = "handle.type"

	// NetDIP represents network destination IP address
	NetDIP Field = "net.dip"
	// NetSIP represents the source IP address
	NetSIP Field = "net.sip"
	// NetDport represents the destination port
	NetDport Field = "net.dport"
	// NetSport represents the source port
	NetSport Field = "net.sport"
	// NetDportName represents the destination port IANA name
	NetDportName Field = "net.dport.name"
	// NetSportName represents the source port IANA name
	NetSportName Field = "net.sport.name"
	// NetL4Proto represents the Layer4 protocol name (e.g. TCP)
	NetL4Proto Field = "net.l4.proto"
	// NetPacketSize represents the packet size
	NetPacketSize Field = "net.size"
	// NetSIPNames represents the source IP names
	NetSIPNames Field = "net.sip.names"
	// NetDIPNames represents the destination IP names
	NetDIPNames Field = "net.dip.names"

	// FileObject represents the address of the file object
	FileObject Field = "file.object"
	// FileName represents the fie name
	FileName Field = "file.name"
	// FileExtension represents the file extension (e.g. .exe or .dll)
	FileExtension Field = "file.extension"
	// FileOperation represents the file operation (e.g. create)
	FileOperation Field = "file.operation"
	// FileShareMask represents the file share mask
	FileShareMask Field = "file.share.mask"
	// FileIOSize represents the number of read/written bytes
	FileIOSize Field = "file.io.size"
	// FileOffset represents the read/write offset
	FileOffset Field = "file.offset"
	// FileType represents the file type
	FileType Field = "file.type"
	// FileAttributes represents a slice of file attributes
	FileAttributes Field = "file.attributes"
	// FileStatus represents the status message of the file operation
	FileStatus Field = "file.status"

	// RegistryKeyName represents the registry key name
	RegistryKeyName Field = "registry.key.name"
	// RegistryKeyHandle represents the registry KCB address
	RegistryKeyHandle Field = "registry.key.handle"
	// RegistryValue represents the registry value
	RegistryValue Field = "registry.value"
	// RegistryValueType represents the registry value type
	RegistryValueType Field = "registry.value.type"
	// RegistryStatus represent the registry operation status
	RegistryStatus Field = "registry.status"

	// ImageBase is the module base address
	ImageBase Field = "image.base.address"
	// ImageSize is the module size
	ImageSize Field = "image.size"
	// ImageChecksum represents the module checksum hash
	ImageChecksum Field = "image.checksum"
	// ImageDefaultAddress represents the module address
	ImageDefaultAddress Field = "image.default.address"
	// ImageName is the module full name
	ImageName Field = "image.name"
	// ImagePID is the pid of the process where the image was loaded
	ImagePID Field = "image.pid"

	// None represents the unknown field
	None Field = ""
)

// String casts the field type to string.
func (f Field) String() string { return string(f) }

// Segment represents the type alias for the segment. Segment
// denotes the location of the value within an indexed field.
type Segment string

const (
	// SectionEntropy is the entropy value of the specific PE section
	SectionEntropy Segment = "entropy"
	// SectionMD5Hash refers to the section md5 sum
	SectionMD5Hash Segment = "md5"
	// SectionSize is the section size
	SectionSize Segment = "size"

	// ModuleSize is the module size
	ModuleSize Segment = "size"
	// ModuleChecksum is the module checksum
	ModuleChecksum Segment = "checksum"
	// ModuleLocation is the module location
	ModuleLocation Segment = "location"
	// ModuleBaseAddress is the module base address
	ModuleBaseAddress Segment = "address.base"
	// ModuleDefaultAddress is the module address
	ModuleDefaultAddress Segment = "address.default"

	// ProcessID represents the process id
	ProcessID Segment = "pid"
	// ProcessName represents the process name
	ProcessName Segment = "name"
	// ProcessComm represents the process command line
	ProcessComm Segment = "comm"
	// ProcessExe represents the process image path
	ProcessExe Segment = "exe"
	// ProcessArgs represents the process command line arguments
	ProcessArgs Segment = "args"
	// ProcessCwd represents the process current working directory
	ProcessCwd Segment = "cwd"
	// ProcessSID represents the process security identifier
	ProcessSID Segment = "sid"
	// ProcessSessionID represents the session id bound to the process
	ProcessSessionID Segment = "sessionid"
)

func (f Field) IsEnvsSequence() bool        { return strings.HasPrefix(f.String(), "ps.envs[") }
func (f Field) IsModsSequence() bool        { return strings.HasPrefix(f.String(), "ps.modules[") }
func (f Field) IsAncestorSequence() bool    { return strings.HasPrefix(f.String(), "ps.ancestor[") }
func (f Field) IsPeSectionsSequence() bool  { return strings.HasPrefix(f.String(), "pe.sections[") }
func (f Field) IsPeResourcesSequence() bool { return strings.HasPrefix(f.String(), "pe.resources[") }

var fields = map[Field]FieldInfo{
	KevtSeq:         {KevtSeq, "event sequence number", kparams.Uint64, []string{"kevt.seq > 666"}},
	KevtPID:         {KevtPID, "process identifier generating the kernel event", kparams.Uint32, []string{"kevt.pid = 6"}},
	KevtTID:         {KevtTID, "thread identifier generating the kernel event", kparams.Uint32, []string{"kevt.tid = 1024"}},
	KevtCPU:         {KevtCPU, "logical processor core where the event was generated", kparams.Uint8, []string{"kevt.cpu = 2"}},
	KevtName:        {KevtName, "symbolical kernel event name", kparams.AnsiString, []string{"kevt.name = 'CreateThread'"}},
	KevtCategory:    {KevtCategory, "event category", kparams.AnsiString, []string{"kevt.category = 'registry'"}},
	KevtDesc:        {KevtDesc, "event description", kparams.AnsiString, []string{"kevt.desc contains 'Creates a new process'"}},
	KevtHost:        {KevtHost, "host name on which the event was produced", kparams.UnicodeString, []string{"kevt.host contains 'kitty'"}},
	KevtTime:        {KevtTime, "event timestamp as a time string", kparams.Time, []string{"kevt.time = '17:05:32'"}},
	KevtTimeHour:    {KevtTimeHour, "hour within the day on which the event occurred", kparams.Time, []string{"kevt.time.h = 23"}},
	KevtTimeMin:     {KevtTimeMin, "minute offset within the hour on which the event occurred", kparams.Time, []string{"kevt.time.m = 54"}},
	KevtTimeSec:     {KevtTimeSec, "second offset within the minute  on which the event occurred", kparams.Time, []string{"kevt.time.s = 0"}},
	KevtTimeNs:      {KevtTimeNs, "nanoseconds specified by event timestamp", kparams.Int64, []string{"kevt.time.ns > 1591191629102337000"}},
	KevtDate:        {KevtDate, "event timestamp as a date string", kparams.Time, []string{"kevt.date = '2018-03-03'"}},
	KevtDateDay:     {KevtDateDay, "day of the month on which the event occurred", kparams.Time, []string{"kevt.date.d = 12"}},
	KevtDateMonth:   {KevtDateMonth, "month of the year on which the event occurred", kparams.Time, []string{"kevt.date.m = 11"}},
	KevtDateYear:    {KevtDateYear, "year on which the event occurred", kparams.Uint32, []string{"kevt.date.y = 2020"}},
	KevtDateTz:      {KevtDateTz, "time zone associated with the event timestamp", kparams.AnsiString, []string{"kevt.date.tz = 'UTC'"}},
	KevtDateWeek:    {KevtDateWeek, "week number within the year on which the event occurred", kparams.Uint8, []string{"kevt.date.week = 2"}},
	KevtDateWeekday: {KevtDateWeekday, "week day on which the event occurred", kparams.AnsiString, []string{"kevt.date.weekday = 'Monday'"}},
	KevtNparams:     {KevtNparams, "number of parameters", kparams.Int8, []string{"kevt.nparams > 2"}},

	PsPid:               {PsPid, "process identifier", kparams.PID, []string{"ps.pid = 1024"}},
	PsPpid:              {PsPpid, "parent process identifier", kparams.PID, []string{"ps.ppid = 45"}},
	PsName:              {PsName, "process image name including the file extension", kparams.UnicodeString, []string{"ps.name contains 'firefox'"}},
	PsComm:              {PsComm, "process command line", kparams.UnicodeString, []string{"ps.comm contains 'java'"}},
	PsExe:               {PsExe, "full name of the process' executable", kparams.UnicodeString, []string{"ps.exe = 'C:\\Windows\\system32\\cmd.exe'"}},
	PsArgs:              {PsArgs, "process command line arguments", kparams.Slice, []string{"ps.args in ('/cdir', '/-C')"}},
	PsCwd:               {PsCwd, "process current working directory", kparams.UnicodeString, []string{"ps.cwd = 'C:\\Users\\Default'"}},
	PsSID:               {PsSID, "security identifier under which this process is run", kparams.UnicodeString, []string{"ps.sid contains 'SYSTEM'"}},
	PsSessionID:         {PsSessionID, "unique identifier for the current session", kparams.Int16, []string{"ps.sessionid = 1"}},
	PsDomain:            {PsDomain, "process domain", kparams.UnicodeString, []string{"ps.domain contains 'SERVICE'"}},
	PsUsername:          {PsUsername, "process username", kparams.UnicodeString, []string{"ps.username contains 'system'"}},
	PsEnvs:              {PsEnvs, "process environment variables", kparams.Slice, []string{"ps.envs in ('MOZ_CRASHREPORTER_DATA_DIRECTORY')"}},
	PsHandles:           {PsHandles, "allocated process handle names", kparams.Slice, []string{"ps.handles in ('\\BaseNamedObjects\\__ComCatalogCache__')"}},
	PsHandleTypes:       {PsHandleTypes, "allocated process handle types", kparams.Slice, []string{"ps.handle.types in ('Key', 'Mutant', 'Section')"}},
	PsDTB:               {PsDTB, "process directory table base address", kparams.HexInt64, []string{"ps.dtb = '7ffe0000'"}},
	PsModules:           {PsModules, "modules loaded by the process", kparams.Slice, []string{"ps.modules in ('crypt32.dll', 'xul.dll')"}},
	PsParentName:        {PsParentName, "parent process image name including the file extension", kparams.UnicodeString, []string{"ps.parent.name contains 'cmd.exe'"}},
	PsParentPid:         {PsParentPid, "parent process id", kparams.Uint32, []string{"ps.parent.pid = 4"}},
	PsParentComm:        {PsParentComm, "parent process command line", kparams.UnicodeString, []string{"parent.ps.comm contains 'java'"}},
	PsParentExe:         {PsParentExe, "full name of the parent process' executable", kparams.UnicodeString, []string{"ps.parent.exe = 'C:\\Windows\\system32\\explorer.exe'"}},
	PsParentArgs:        {PsParentArgs, "parent process command line arguments", kparams.Slice, []string{"ps.parent.args in ('/cdir', '/-C')"}},
	PsParentCwd:         {PsParentCwd, "parent process current working directory", kparams.UnicodeString, []string{"ps.parent.cwd = 'C:\\Temp'"}},
	PsParentSID:         {PsParentSID, "security identifier under which the parent process is run", kparams.UnicodeString, []string{"ps.parent.sid contains 'SYSTEM'"}},
	PsParentDomain:      {PsParentDomain, "parent process domain", kparams.UnicodeString, []string{"ps.parent.domain contains 'SERVICE'"}},
	PsParentUsername:    {PsParentUsername, "parent process username", kparams.UnicodeString, []string{"ps.parent.username contains 'system'"}},
	PsParentSessionID:   {PsParentSessionID, "unique identifier for the current session of parent process", kparams.Int16, []string{"ps.parent.sessionid = 1"}},
	PsParentEnvs:        {PsParentEnvs, "parent process environment variables", kparams.Slice, []string{"ps.parent.envs in ('MOZ_CRASHREPORTER_DATA_DIRECTORY')"}},
	PsParentHandles:     {PsParentHandles, "allocated parent process handle names", kparams.Slice, []string{"ps.parent.handles in ('\\BaseNamedObjects\\__ComCatalogCache__')"}},
	PsParentHandleTypes: {PsParentHandleTypes, "allocated parent process handle types", kparams.Slice, []string{"ps.parent.handle.types in ('File', 'SymbolicLink')"}},
	PsParentDTB:         {PsParentDTB, "parent process directory table base address", kparams.HexInt64, []string{"ps.parent.dtb = '7ffe0000'"}},
	PsAccessMask:        {PsAccessMask, "process desired access rights", kparams.AnsiString, []string{"ps.access.mask = '0x1400'"}},
	PsAccessMaskNames:   {PsAccessMaskNames, "process desired access rights as a string list", kparams.Slice, []string{"ps.access.mask.names in ('SUSPEND_RESUME')"}},
	PsAccessStatus:      {PsAccessStatus, "process access status", kparams.UnicodeString, []string{"ps.access.status = 'access is denied.'"}},
	PsSiblingPid:        {PsSiblingPid, "created, terminated, or opened process id", kparams.PID, []string{"ps.sibling.pid = 320"}},
	PsSiblingName:       {PsSiblingName, "created, terminated, or opened process name", kparams.UnicodeString, []string{"ps.sibling.name = 'notepad.exe'"}},
	PsSiblingComm:       {PsSiblingComm, "created or terminated process command line", kparams.UnicodeString, []string{"ps.sibling.comm contains '\\k \\v'"}},
	PsSiblingExe:        {PsSiblingExe, "created, terminated, or opened process id", kparams.UnicodeString, []string{"ps.sibling.exe contains '\\Windows\\cmd.exe'"}},
	PsSiblingSID:        {PsSiblingSID, "created or terminated process security identifier", kparams.UnicodeString, []string{"ps.sibling.sid contains 'SERVICE'"}},
	PsSiblingSessionID:  {PsSiblingSessionID, "created or terminated process session identifier", kparams.Int16, []string{"ps.sibling.sessionid == 1"}},
	PsSiblingDomain:     {PsSiblingDomain, "created or terminated process domain", kparams.UnicodeString, []string{"ps.sibling.domain contains 'SERVICE'"}},
	PsSiblingUsername:   {PsSiblingUsername, "created or terminated process username", kparams.UnicodeString, []string{"ps.sibling.username contains 'system'"}},

	ThreadBasePrio:        {ThreadBasePrio, "scheduler priority of the thread", kparams.Int8, []string{"thread.prio = 5"}},
	ThreadIOPrio:          {ThreadIOPrio, "I/O priority hint for scheduling I/O operations", kparams.Int8, []string{"thread.io.prio = 4"}},
	ThreadPagePrio:        {ThreadPagePrio, "memory page priority hint for memory pages accessed by the thread", kparams.Int8, []string{"thread.page.prio = 12"}},
	ThreadKstackBase:      {ThreadKstackBase, "base address of the thread's kernel space stack", kparams.HexInt64, []string{"thread.kstack.base = 'a65d800000'"}},
	ThreadKstackLimit:     {ThreadKstackLimit, "limit of the thread's kernel space stack", kparams.HexInt64, []string{"thread.kstack.limit = 'a85d800000'"}},
	ThreadUstackBase:      {ThreadUstackBase, "base address of the thread's user space stack", kparams.HexInt64, []string{"thread.ustack.base = '7ffe0000'"}},
	ThreadUstackLimit:     {ThreadUstackLimit, "limit of the thread's user space stack", kparams.HexInt64, []string{"thread.ustack.limit = '8ffe0000'"}},
	ThreadEntrypoint:      {ThreadEntrypoint, "starting address of the function to be executed by the thread", kparams.HexInt64, []string{"thread.entrypoint = '7efe0000'"}},
	ThreadPID:             {ThreadPID, "the process identifier where the thread is created", kparams.Uint32, []string{"kevt.pid != thread.pid"}},
	ThreadAccessMask:      {ThreadAccessMask, "thread desired access rights", kparams.AnsiString, []string{"thread.access.mask = '0x1fffff'"}},
	ThreadAccessMaskNames: {ThreadAccessMaskNames, "thread desired access rights as a string list", kparams.Slice, []string{"thread.access.mask.names in ('IMPERSONATE')"}},
	ThreadAccessStatus:    {ThreadAccessStatus, "thread access status", kparams.UnicodeString, []string{"thread.access.status = 'success'"}},

	ImageName:           {ImageName, "full image name", kparams.UnicodeString, []string{"image.name contains 'advapi32.dll'"}},
	ImageBase:           {ImageBase, "the base address of process in which the image is loaded", kparams.HexInt64, []string{"image.base.address = 'a65d800000'"}},
	ImageChecksum:       {ImageChecksum, "image checksum", kparams.Uint32, []string{"image.checksum = 746424"}},
	ImageSize:           {ImageSize, "image size", kparams.Uint32, []string{"image.size > 1024"}},
	ImageDefaultAddress: {ImageDefaultAddress, "default image address", kparams.HexInt64, []string{"image.default.address = '7efe0000'"}},
	ImagePID:            {ImagePID, "target process identifier", kparams.Uint32, []string{"image.pid = 80"}},

	FileObject:     {FileObject, "file object address", kparams.Uint64, []string{"file.object = 18446738026482168384"}},
	FileName:       {FileName, "full file name", kparams.UnicodeString, []string{"file.name contains 'mimikatz'"}},
	FileOperation:  {FileOperation, "file operation", kparams.AnsiString, []string{"file.operation = 'open'"}},
	FileShareMask:  {FileShareMask, "file share mask", kparams.AnsiString, []string{"file.share.mask = 'rw-'"}},
	FileIOSize:     {FileIOSize, "file I/O size", kparams.Uint32, []string{"file.io.size > 512"}},
	FileOffset:     {FileOffset, "file offset", kparams.Uint64, []string{"file.offset = 1024"}},
	FileType:       {FileType, "file type", kparams.AnsiString, []string{"file.type = 'directory'"}},
	FileExtension:  {FileExtension, "file extension", kparams.AnsiString, []string{"file.extension = '.dll'"}},
	FileAttributes: {FileAttributes, "file attributes", kparams.Slice, []string{"file.attributes in ('archive', 'hidden')"}},
	FileStatus:     {FileStatus, "file operation status message", kparams.UnicodeString, []string{"file.status != 'success'"}},

	RegistryKeyName:   {RegistryKeyName, "fully qualified key name", kparams.UnicodeString, []string{"registry.key.name contains 'HKEY_LOCAL_MACHINE'"}},
	RegistryKeyHandle: {RegistryKeyHandle, "registry key object address", kparams.HexInt64, []string{"registry.key.handle = 'FFFFB905D60C2268'"}},
	RegistryValue:     {RegistryValue, "registry value content", kparams.UnicodeString, []string{"registry.value = '%SystemRoot%\\system32'"}},
	RegistryValueType: {RegistryValueType, "type of registry value", kparams.UnicodeString, []string{"registry.value.type = 'REG_SZ'"}},
	RegistryStatus:    {RegistryStatus, "status of registry operation", kparams.UnicodeString, []string{"registry.status != 'success'"}},

	NetDIP:        {NetDIP, "destination IP address", kparams.IP, []string{"net.dip = 172.17.0.3"}},
	NetSIP:        {NetSIP, "source IP address", kparams.IP, []string{"net.sip = 127.0.0.1"}},
	NetDport:      {NetDport, "destination port", kparams.Uint16, []string{"net.dport in (80, 443, 8080)"}},
	NetSport:      {NetSport, "source port", kparams.Uint16, []string{"net.sport != 3306"}},
	NetDportName:  {NetDportName, "destination port name", kparams.AnsiString, []string{"net.dport.name = 'dns'"}},
	NetSportName:  {NetSportName, "source port name", kparams.AnsiString, []string{"net.sport.name = 'http'"}},
	NetL4Proto:    {NetL4Proto, "layer 4 protocol name", kparams.AnsiString, []string{"net.l4.proto = 'TCP"}},
	NetPacketSize: {NetPacketSize, "packet size", kparams.Uint32, []string{"net.size > 512"}},
	NetSIPNames:   {NetSIPNames, "source IP names", kparams.Slice, []string{"net.sip.names in ('github.com.')"}},
	NetDIPNames:   {NetDIPNames, "destination IP names", kparams.Slice, []string{"net.dip.names in ('github.com.')"}},

	HandleID:     {HandleID, "handle identifier", kparams.Uint16, []string{"handle.id = 24"}},
	HandleObject: {HandleObject, "handle object address", kparams.HexInt64, []string{"handle.object = 'FFFFB905DBF61988'"}},
	HandleName:   {HandleName, "handle name", kparams.UnicodeString, []string{"handle.name = '\\Device\\NamedPipe\\chrome.12644.28.105826381'"}},
	HandleType:   {HandleType, "handle type", kparams.AnsiString, []string{"handle.type = 'Mutant'"}},

	PeNumSections:    {PeNumSections, "number of sections", kparams.Uint16, []string{"pe.nsections < 5"}},
	PeNumSymbols:     {PeNumSymbols, "number of entries in the symbol table", kparams.Uint32, []string{"pe.nsymbols > 230"}},
	PeBaseAddress:    {PeBaseAddress, "image base address", kparams.HexInt64, []string{"pe.address.base = '140000000'"}},
	PeEntrypoint:     {PeEntrypoint, "address of the entrypoint function", kparams.HexInt64, []string{"pe.address.entrypoint = '20110'"}},
	PeSections:       {PeSections, "PE sections", kparams.Object, []string{"pe.sections[.text].entropy > 6.2"}},
	PeSymbols:        {PeSymbols, "imported symbols", kparams.Slice, []string{"pe.symbols in ('GetTextFaceW', 'GetProcessHeap')"}},
	PeImports:        {PeImports, "imported dynamic linked libraries", kparams.Slice, []string{"pe.imports in ('msvcrt.dll', 'GDI32.dll'"}},
	PeResources:      {PeResources, "version and other resources", kparams.Map, []string{"pe.resources[FileDescription] = 'Notepad'"}},
	PeCompany:        {PeCompany, "internal company name of the file provided at compile-time", kparams.UnicodeString, []string{"pe.company = 'Microsoft Corporation'"}},
	PeCopyright:      {PeCopyright, "copyright notice for the file emitted at compile-time", kparams.UnicodeString, []string{"pe.copyright = '© Microsoft Corporation'"}},
	PeDescription:    {PeDescription, "internal description of the file provided at compile-time", kparams.UnicodeString, []string{"pe.description = 'Notepad'"}},
	PeFileName:       {PeFileName, "original file name supplied at compile-time", kparams.UnicodeString, []string{"pe.file.name = 'NOTEPAD.EXE'"}},
	PeFileVersion:    {PeFileVersion, "file version supplied at compile-time", kparams.UnicodeString, []string{"pe.file.version = '10.0.18362.693 (WinBuild.160101.0800)'"}},
	PeProduct:        {PeProduct, "internal product name of the file provided at compile-time", kparams.UnicodeString, []string{"pe.product = 'Microsoft® Windows® Operating System'"}},
	PeProductVersion: {PeProductVersion, "internal product version of the file provided at compile-time", kparams.UnicodeString, []string{"pe.product.version = '10.0.18362.693'"}},
}

// Lookup finds the field literal in the map. For the nested fields, it checks the pattern matches
// the expected one and compares the paths. If all checks pass, the full segment field literal
// is returned.
func Lookup(name string) Field {
	if _, ok := fields[Field(name)]; ok {
		return Field(name)
	}
	groups := pathRegexp.FindStringSubmatch(name)
	if len(groups) != 4 {
		return None
	}

	field := groups[1]
	key := groups[2]
	segment := groups[3]

	switch Field(field) {
	case PeSections:
		if segment == "" {
			return None
		}
		switch Segment(segment) {
		case SectionEntropy:
			return Field(name)
		case SectionMD5Hash:
			return Field(name)
		case SectionSize:
			return Field(name)
		}
	case PsModules:
		if segment == "" {
			return None
		}
		switch Segment(segment) {
		case ModuleSize:
			return Field(name)
		case ModuleChecksum:
			return Field(name)
		case ModuleDefaultAddress:
			return Field(name)
		case ModuleBaseAddress:
			return Field(name)
		case ModuleLocation:
			return Field(name)
		}
	case PsAncestor:
		if segment == "" {
			return None
		}
		// the key is either the number
		// that represents the depth of
		// the ancestor process node or the
		// `root` keyword to designate the
		// root ancestor process node. Additionally,
		// we can also get the `any` keyword
		// that collects the fields of all
		// ancestor processes
		var keyRegexp = regexp.MustCompile(`[1-9]+|root|any`)
		if !keyRegexp.MatchString(key) {
			return None
		}
		switch Segment(segment) {
		case ProcessName:
			return Field(name)
		case ProcessID:
			return Field(name)
		case ProcessArgs:
			return Field(name)
		case ProcessComm:
			return Field(name)
		case ProcessCwd:
			return Field(name)
		case ProcessExe:
			return Field(name)
		case ProcessSID:
			return Field(name)
		case ProcessSessionID:
			return Field(name)
		}
	case PeResources:
		if segment == "" {
			return Field(name)
		}
	case PsEnvs:
		if segment == "" {
			return Field(name)
		}
	}
	return None
}

```

`pkg/filter/fields/fields_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fields

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestLookup(t *testing.T) {
	assert.Equal(t, PsPid, Lookup("ps.pid"))
	assert.Equal(t, Field("ps.envs[ALLUSERSPROFILE]"), Lookup("ps.envs[ALLUSERSPROFILE]"))
	assert.Empty(t, Lookup("ps.envs[ALLUSERSPROFILE].env"))
	assert.Empty(t, Lookup("ps.envs[ALLUSERSPROFILE"))
	assert.Empty(t, Lookup("ps.envs["))
	assert.Empty(t, Lookup("ps.envs[]"))
	assert.Equal(t, PsEnvs, Lookup("ps.envs"))
	assert.Equal(t, Field("ps.pe.sections[.debug$S].entropy"), Lookup("ps.pe.sections[.debug$S].entropy"))
	assert.Empty(t, Lookup("ps.pe.sections[.debug$S"))
	assert.Empty(t, Lookup("ps.pe.sections[.debug$S]"))
	assert.Empty(t, Lookup("ps.pe.sections[.debug$S]."))
	assert.Empty(t, Lookup("ps.pe.sections[.debug$S].e"))
	assert.Equal(t, Field("ps.ancestor[1].name"), Lookup("ps.ancestor[1].name"))
	assert.Equal(t, Field("ps.ancestor[root].name"), Lookup("ps.ancestor[root].name"))
	assert.Equal(t, Field("ps.ancestor[any].pid"), Lookup("ps.ancestor[any].pid"))
	assert.Equal(t, Field("ps.ancestor[2].sid"), Lookup("ps.ancestor[2].sid"))
	assert.Empty(t, Lookup("ps.ancestor[ro].name"))
}

```

`pkg/filter/filter.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"errors"
	"expvar"
	"fmt"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/filter/ql"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"strings"
)

var (
	accessorErrors = expvar.NewMap("filter.accessor.errors")
	errNoFields    = errors.New("expected at least one field or operator but zero found")
)

// Filter is the main interface for the filter engine implementors.
type Filter interface {
	// Compile compiles the filter by parsing the filtering expression.
	Compile() error
	// Run runs a filter on the inbound kernel event and decides whether the event
	// should be dropped or propagated to the downstream channel.
	Run(kevt *kevent.Kevent) bool
	// RunPartials runs a filter with stateful event tracking. Partials store all
	// intermediate events that are the result of previous filter matches.
	RunPartials(kevt *kevent.Kevent, partials map[uint16][]*kevent.Kevent) (bool, uint16, *kevent.Kevent)
	// BindingIndex returns the binding index to which the filter is bound
	// or a zero value if there are no pattern bindings defined.
	BindingIndex() (uint16, bool)
}

type filter struct {
	expr      ql.Expr
	parser    *ql.Parser
	accessors []accessor
	fields    []fields.Field
	bindings  map[uint16][]*ql.PatternBindingLiteral
	// useFuncValuer determines whether we should supply the function valuer
	useFuncValuer bool
}

// Compile parsers the filter expression and builds a binary expression tree
// where leaf nodes represent constants/variables while internal nodes are
// operators. Operators can be binary (=) or unary (not). Fields in filter
// expressions are replaced with respective event parameters via map valuer.
// For functions call we grab all the arguments that are evaluated as field
// literals.
// Matching the filter involves descending the binary expression tree recursively
// until all nodes are visited.
func (f *filter) Compile() error {
	var err error
	f.expr, err = f.parser.ParseExpr()
	if err != nil {
		return err
	}

	walk := func(n ql.Node) {
		if expr, ok := n.(*ql.BinaryExpr); ok {
			if lhs, ok := expr.LHS.(*ql.FieldLiteral); ok {
				f.fields = append(f.fields, fields.Field(lhs.Value))
			}
			if rhs, ok := expr.RHS.(*ql.FieldLiteral); ok {
				f.fields = append(f.fields, fields.Field(rhs.Value))
			}
			if rhs, ok := expr.RHS.(*ql.PatternBindingLiteral); ok {
				f.bindings[rhs.Index()] = append(f.bindings[rhs.Index()], rhs)
			}
		}
		if expr, ok := n.(*ql.Function); ok {
			f.useFuncValuer = true
			for _, arg := range expr.Args {
				if fld, ok := arg.(*ql.FieldLiteral); ok {
					f.fields = append(f.fields, fields.Field(fld.Value))
				}
			}
		}
	}
	ql.WalkFunc(f.expr, walk)

	if len(f.fields) == 0 {
		return errNoFields
	}

	if len(f.bindings) > 1 {
		bindings := make([]string, 0)
		for _, b := range f.bindings {
			for _, binding := range b {
				bindings = append(bindings, binding.Value)
			}
		}
		return fmt.Errorf("multiple pattern bindings found referencing "+
			"distinct sequence events: %s", strings.Join(bindings, ","))
	}
	return nil
}

func (f *filter) Run(kevt *kevent.Kevent) bool {
	if f.expr == nil {
		return false
	}
	return ql.Eval(f.expr, f.mapValuer(kevt), nil, f.useFuncValuer)
}

func (f *filter) RunPartials(kevt *kevent.Kevent, partials map[uint16][]*kevent.Kevent) (bool, uint16, *kevent.Kevent) {
	if f.expr == nil {
		return false, 0, nil
	}
	mapValuer := f.mapValuer(kevt)
	i, ok := f.BindingIndex()
	if !ok {
		return false, 0, nil
	}
	kevts := partials[i]
	for _, e := range kevts {
		valuer := f.bindingValuer(e, i)
		ok := ql.Eval(f.expr, mapValuer, valuer, f.useFuncValuer)
		if ok {
			return true, i, e
		}
	}
	return false, 0, nil
}

func (f *filter) BindingIndex() (uint16, bool) {
	if len(f.bindings) == 0 {
		return 0, false
	}
	for i := range f.bindings {
		return i, true
	}
	return 0, false
}

// mapValuer for each field present in the AST, we run the
// accessors and extract the field vales that are
// supplied to the valuer. The valuer feeds the
// expression with correct values.
func (f *filter) mapValuer(kevt *kevent.Kevent) map[string]interface{} {
	valuer := make(map[string]interface{})
	for _, field := range f.fields {
		for _, accessor := range f.accessors {
			v, err := accessor.get(field, kevt)
			if err != nil && !kerrors.IsKparamNotFound(err) {
				accessorErrors.Add(err.Error(), 1)
				continue
			}
			if v == nil {
				continue
			}
			valuer[field.String()] = v
		}
	}
	return valuer
}

// bindingValuer for each pattern binding node, resolves its value from
// the event that pertains to the same pattern binding index.
func (f *filter) bindingValuer(kevt *kevent.Kevent, idx uint16) map[string]interface{} {
	valuer := make(map[string]interface{})
	for _, binding := range f.bindings[idx] {
		for _, accessor := range f.accessors {
			v, err := accessor.get(binding.Field(), kevt)
			if err != nil && !kerrors.IsKparamNotFound(err) {
				accessorErrors.Add(err.Error(), 1)
				continue
			}
			if v == nil {
				continue
			}
			valuer[binding.Value] = v
		}
	}
	return valuer
}

```

`pkg/filter/filter_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"net"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/require"
)

var cfg = &config.Config{
	Kstream: config.KstreamConfig{
		EnableHandleKevents:   true,
		EnableNetKevents:      true,
		EnableRegistryKevents: true,
		EnableFileIOKevents:   true,
		EnableImageKevents:    true,
		EnableThreadKevents:   true,
	},
	PE: pe.Config{Enabled: true},
}

func TestFilterCompile(t *testing.T) {
	f := New(`ps.name = 'cmd.exe'`, cfg)
	require.NoError(t, f.Compile())
	f = New(`'cmd.exe'`, cfg)
	require.EqualError(t, f.Compile(), "expected at least one field or operator but zero found")
	f = New(`ps.name`, cfg)
	require.EqualError(t, f.Compile(), "expected at least one field or operator but zero found")
	f = New(`ps.name =`, cfg)
	require.EqualError(t, f.Compile(), "ps.name =\n╭─────────^\n|\n|\n╰─────────────────── expected field, string, number, bool, ip, function, pattern binding")
}

func TestFilterRunProcessKevent(t *testing.T) {
	kpars := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "C:\\Windows\\system32\\svchost-fake.exe -k RPCSS"},
		kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.AnsiString, Value: "svchost-fake.exe"},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(1234)},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(345)},
		kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: "TITAN\\loki"},
	}

	kpars1 := kevent.Kparams{
		kparams.DesiredAccessNames: {Name: kparams.DesiredAccessNames, Type: kparams.Slice, Value: []string{"QUERY_INFORMATION", "QUERY_LIMITED_INFORMATION"}},
	}

	ps1 := &pstypes.PS{
		Name: "wininit.exe",
		SID:  "NT AUTHORITY\\SYSTEM",
		PID:  5042,
		Parent: &pstypes.PS{
			Name: "services.exe",
			SID:  "NT AUTHORITY\\SYSTEM",
			PID:  2034,
			Parent: &pstypes.PS{
				Name: "System",
			},
		},
	}

	kevt := &kevent.Kevent{
		Type:     ktypes.CreateProcess,
		Category: ktypes.Process,
		Kparams:  kpars,
		Name:     "CreateProcess",
		PID:      1023,
		PS: &pstypes.PS{
			Name:   "svchost.exe",
			Parent: ps1,
			Ppid:   345,
			SID:    "LOCAL\\tor",
			Envs:   map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
			Modules: []pstypes.Module{
				{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: kparams.Hex("fff23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
				{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: kparams.Hex("fef23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
			},
		},
	}
	kevt.Timestamp, _ = time.Parse(time.RFC3339, "2011-05-03T15:04:05.323Z")

	kevt1 := &kevent.Kevent{
		Type:     ktypes.OpenProcess,
		Category: ktypes.Process,
		Kparams:  kpars1,
		Name:     "OpenProcess",
		PID:      1023,
		PS: &pstypes.PS{
			Name:   "svchost.exe",
			Parent: ps1,
			Ppid:   345,
			Envs:   map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
			Modules: []pstypes.Module{
				{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: kparams.Hex("fff23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
				{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: kparams.Hex("fef23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
			},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`ps.name = 'svchost.exe'`, true},
		{`ps.name = 'svchot.exe'`, false},
		{`ps.name = 'mimikatz.exe' or ps.name contains 'svc'`, true},
		{`ps.username = 'tor'`, true},
		{`ps.domain = 'LOCAL'`, true},
		{`ps.pid = 1023`, true},
		{`ps.sibling.pid = 1234`, true},
		{`ps.parent.pid = 5042`, true},
		{`ps.sibling.name = 'svchost-fake.exe'`, true},
		{`ps.sibling.username = 'loki'`, true},
		{`ps.sibling.domain = 'TITAN'`, true},
		{`ps.parent.username = 'SYSTEM'`, true},
		{`ps.parent.domain = 'NT AUTHORITY'`, true},
		{`ps.envs in ('ALLUSERSPROFILE')`, true},
		{`kevt.name='CreateProcess' and ps.name contains 'svchost'`, true},

		{`ps.modules IN ('kernel32.dll')`, true},
		{`ps.modules[kernel32.dll].size = 12354`, true},
		{`ps.modules[kernel32.dll].checksum = 23123343`, true},
		{`ps.modules[kernel32.dll].address.default = 'fff124fd'`, true},
		{`ps.modules[kernel32.dll].address.base = 'fff23fff'`, true},
		{`ps.modules[kernel32.dll].location = 'C:\\Windows\\System32'`, true},
		{`ps.modules[xul.dll].size = 12354`, false},
		{`kevt.name = 'CreateProcess' and kevt.pid != ps.ppid`, true},
		{`ps.parent.name = 'wininit.exe'`, true},
		{`ps.ancestor[1].name = 'wininit.exe'`, true},
		{`ps.ancestor[2].name = 'services.exe'`, true},
		{`ps.ancestor[2].sid = 'NT AUTHORITY\\SYSTEM'`, true},
		{`ps.ancestor[root].name = 'System'`, true},
		{`ps.ancestor[any].name in ('services.exe', 'System')`, true},
		{`ps.ancestor[any].name not in ('svchost.exe')`, true},
		{`ps.ancestor[any].name endswith ('ices.exe')`, true},
		{`ps.ancestor[any].name iendswith ('TeM')`, true},
		{`ps.ancestor[any].name startswith ('serv')`, true},
		{`ps.ancestor[any].name istartswith ('Serv')`, true},
		{`ps.ancestor[any].name contains ('Sys')`, true},
		{`ps.ancestor[any].name icontains ('sys')`, true},
		{`ps.ancestor[any].pid in (2034, 343)`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q ps filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	var tests1 = []struct {
		filter  string
		matches bool
	}{

		{`ps.access.mask.names in ('QUERY_INFORMATION')`, true},
	}

	for i, tt := range tests1 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt1)
		if matches != tt.matches {
			t.Errorf("%d. %q ps filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFilterRunThreadKevent(t *testing.T) {
	kpars := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
		kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.AnsiString, Value: "svchost.exe"},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(1234)},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.Uint32, Value: uint32(345)},
	}

	kevt := &kevent.Kevent{
		Type:    ktypes.CreateThread,
		Kparams: kpars,
		Name:    "CreateThread",
		PS: &pstypes.PS{
			Name: "svchost.exe",
			Envs: map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`ps.name = 'svchost.exe'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q thread filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFilterRunFileKevent(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`file.name = 'C:\\Windows\\system32\\user32.dll'`, true},
		{`file.extension  = '.dll'`, true},
		{`file.extension not contains '.exe'`, true},
		{`file.extension not contains '.exe' and file.extension contains '.dll'`, true},
		{`file.extension not contains '.exe' and file.extension not contains '.com'`, true},
		{`file.extension not contains '.exe' and file.extension not contains '.com' and file.extension not in ('.vba', '.exe')`, true},
		{`file.extension not in ('.exe', '.com')`, true},
		{`file.extension not in ('.exe', '.dll')`, false},
		{`file.name matches 'C:\\*\\user32.dll'`, true},
		{`file.name not matches 'C:\\*.exe'`, true},
		{`file.name imatches 'C:\\*\\USER32.dll'`, true},
		{`file.name matches ('C:\\*\\user3?.dll', 'C:\\*\\user32.*')`, true},
		{`file.name contains ('C:\\Windows\\system32\\kernel32.dll', 'C:\\Windows\\system32\\user32.dll')`, true},
		{`file.name not matches ('C:\\*.exe', 'C:\\Windows\\*.com')`, true},
		{`file.name endswith ('.exe', 'kernel32.dll', 'user32.dll')`, true},
		{`file.name iendswith ('.EXE', 'KERNEL32.dll', 'user32.dll')`, true},
		{`file.name istartswith ('C:\\WINDOWS', 'KERNEL32.dll', 'user32.dll')`, true},
		{`file.name iin ('C:\\WINDOWS\\system32\\user32.dll')`, true},
		{`file.name fuzzy 'C:\\Windows\\system32\\ser3ll'`, true},
		{`file.name ifuzzy 'C:\\WINDOWS\\sYS\\ser3ll'`, true},
		{`file.name ifuzzy 'C:\\WINDOWS\\sYS\\32dll'`, true},
		{`file.name fuzzy ('C:\\Windows\\system32\\kernel', 'C:\\Windows\\system32\\ser3ll')`, true},
		{`file.name ifuzzynorm 'C:\\WINDOWS\\sÝS\\32dll'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q file filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFilterRunKevent(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barz"},
	}

	kevt.Timestamp, _ = time.Parse(time.RFC3339, "2011-05-03T15:04:05.323Z")

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`kevt.seq = 2`, true},
		{`kevt.pid = 859`, true},
		{`kevt.tid = 2484`, true},
		{`kevt.cpu = 1`, true},
		{`kevt.name = 'CreateFile'`, true},
		{`kevt.category = 'file'`, true},
		{`kevt.host = 'archrabbit'`, true},
		{`kevt.nparams = 4`, true},

		{`kevt.desc contains 'Creates or opens a new file'`, true},

		{`kevt.date.d = 3 AND kevt.date.m = 5 AND kevt.time.s = 5 AND kevt.time.m = 4 and kevt.time.h = 15`, true},
		{`kevt.time = '15:04:05'`, true},
		{`concat(kevt.name, kevt.host, kevt.nparams) = 'CreateFilearchrabbit4'`, true},
		{`ltrim(kevt.host, 'arch') = 'rabbit'`, true},
		{`concat(ltrim(kevt.name, 'Create'), kevt.host) = 'Filearchrabbit'`, true},
		{`lower(rtrim(kevt.name, 'File')) = 'create'`, true},
		{`upper(rtrim(kevt.name, 'File')) = 'CREATE'`, true},
		{`replace(kevt.host, 'rabbit', '_bunny') = 'arch_bunny'`, true},
		{`replace(kevt.host, 'rabbit', '_bunny', '_bunny', 'bunny') = 'archbunny'`, true},
		{`split(file.name, '\\') IN ('windows', 'system32')`, true},
		{`length(file.name) = 51`, true},
		{`indexof(file.name, '\\') = 0`, true},
		{`indexof(file.name, '\\', 'last') = 40`, true},
		{`indexof(file.name, 'h2', 'any') = 22`, true},
		{`substr(file.name, indexof(file.name, '\\'), indexof(file.name, '\\Hard')) = '\\Device'`, true},
		{`substr(kevt.desc, indexof(kevt.desc, '\\'), indexof(kevt.desc, 'NOT')) = 'Creates or opens a new file, directory, I/O device, pipe, console'`, true},
		{`entropy(file.name) > 120`, true},
		{`regex(file.name, '\\\\Device\\\\HarddiskVolume[2-9]+\\\\.*')`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q kevt filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFilterRunNetKevent(t *testing.T) {
	kevt := &kevent.Kevent{
		Type: ktypes.SendTCPv4,
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
		},
		Kparams: kevent.Kparams{
			kparams.NetDport:    {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport:    {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:      {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:      {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
			kparams.NetDIPNames: {Name: kparams.NetDIPNames, Type: kparams.Slice, Value: []string{"dns.google.", "github.com."}},
			kparams.NetSIPNames: {Name: kparams.NetSIPNames, Type: kparams.Slice, Value: []string{"local.domain."}},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`net.dip = 216.58.201.174`, true},
		{`net.dip != 216.58.201.174`, false},
		{`net.dip != 116.58.201.174`, true},
		{`net.dip startswith '216.58'`, true},
		{`net.dip endswith '.174'`, true},
		{`net.dport = 443`, true},
		{`net.dport in (123, 443)`, true},
		{`net.dip.names in ('dns.google.')`, true},
		{`net.sip.names matches ('*.domain.')`, true},
		{`net.dip != 116.58.201.174`, true},
		{`net.dip not in ('116.58.201.172', '16.58.201.176')`, true},
		{`net.dip not in (116.58.201.172, 16.58.201.176)`, true},
		{`ps.name = 'cmd.exe' and not cidr_contains(net.sip, '227.0.0.1/12', '8.2.3.0/4')`, true},
		{`ps.name = 'cmd.exe' and not ((net.sip in (222.1.1.1)) or (net.sip in (12.3.4.5)))`, true},
		{`cidr_contains(net.dip, '216.58.201.1/24') = true`, true},
		{`cidr_contains(net.dip, '226.58.201.1/24') = false`, true},
		{`cidr_contains(net.dip, '216.58.201.1/24', '216.58.201.10/24') = true and kevt.pid = 859`, true},
		{`kevt.name not in ('CreateProcess', 'Connect') and cidr_contains(net.dip, '216.58.201.1/24') = true`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q net filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFilterRunRegistryKevent(t *testing.T) {
	kevt := &kevent.Kevent{
		Type: ktypes.RegSetValue,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.RegKeyName:   {Name: kparams.RegKeyName, Type: kparams.UnicodeString, Value: `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`},
			kparams.RegValue:     {Name: kparams.RegValue, Type: kparams.Uint32, Value: 10234},
			kparams.RegValueType: {Name: kparams.RegValueType, Type: kparams.AnsiString, Value: "DWORD"},
			kparams.NTStatus:     {Name: kparams.NTStatus, Type: kparams.AnsiString, Value: "success"},
			kparams.RegKeyHandle: {Name: kparams.RegKeyHandle, Type: kparams.HexInt64, Value: kparams.NewHex(uint64(18446666033449935464))},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`registry.status startswith ('key not', 'succ')`, true},
		{`registry.key.name icontains ('hkey_local_machine', 'HKEY_LOCAL')`, true},
		{`registry.value = 10234`, true},
		{`registry.value.type in ('DWORD', 'QWORD')`, true},
		{`MD5(registry.key.name) = 'eab870b2a516206575d2ffa2b98d8af5'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q registry filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFilterRunPE(t *testing.T) {
	kevt := &kevent.Kevent{
		PS: &pstypes.PS{
			PE: &pe.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "20110",
				ImageBase:        "140000000",
				LinkTime:         time.Now(),
				Sections: []pe.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`pe.sections[.text].entropy = 6.368381`, true},
		{`pe.sections[.text].entropy > 4.45`, true},
		{`pe.sections[.text].size = 132608`, true},
		{`pe.symbols IN ('GetTextFaceW', 'GetProcessHeap')`, true},
		{`pe.resources[FileDesc] = 'Notepad'`, true},
		{`pe.nsymbols = 10 AND pe.nsections = 2`, true},
		{`pe.nsections > 1`, true},
		{`pe.address.base = '140000000' AND pe.address.entrypoint = '20110'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(kevt)
		if matches != tt.matches {
			t.Errorf("%d. %q pe filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func BenchmarkFilterRun(b *testing.B) {
	b.ReportAllocs()
	f := New(`ps.name = 'mimikatz.exe' or ps.name contains 'svc'`, cfg)
	require.NoError(b, f.Compile())

	kpars := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
		kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.AnsiString, Value: "svchost.exe"},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(1234)},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.Uint32, Value: uint32(345)},
	}

	kevt := &kevent.Kevent{
		Type:    ktypes.CreateProcess,
		Kparams: kpars,
		Name:    "CreateProcess",
	}

	for i := 0; i < b.N; i++ {
		f.Run(kevt)
	}
}

```

`pkg/filter/filter_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/filter/ql"
	"strings"
)

// New creates a new filter with the specified filter expression. The consumers must ensure
// the expression is correctly parsed before executing the filter. This is achieved by calling the
// Compile` method after constructing the filter.
func New(expr string, config *config.Config) Filter {
	accessors := []accessor{
		// general event parameters
		newKevtAccessor(),
		// process state and parameters
		newPSAccessor(),
	}
	kconfig := config.Kstream

	if kconfig.EnableThreadKevents {
		accessors = append(accessors, newThreadAccessor())
	}
	if kconfig.EnableImageKevents {
		accessors = append(accessors, newImageAccessor())
	}
	if kconfig.EnableFileIOKevents {
		accessors = append(accessors, newFileAccessor())
	}
	if kconfig.EnableRegistryKevents {
		accessors = append(accessors, newRegistryAccessor())
	}
	if kconfig.EnableNetKevents {
		accessors = append(accessors, newNetworkAccessor())
	}
	if kconfig.EnableHandleKevents {
		accessors = append(accessors, newHandleAccessor())
	}
	if config.PE.Enabled {
		accessors = append(accessors, newPEAccessor())
	}

	return &filter{
		parser:    ql.NewParser(expr),
		accessors: accessors,
		fields:    make([]fields.Field, 0),
		bindings:  make(map[uint16][]*ql.PatternBindingLiteral),
	}
}

// NewFromCLI builds and compiles a filter by joining all the command line arguments into the filter expression.
func NewFromCLI(args []string, config *config.Config) (Filter, error) {
	expr := strings.Join(args, " ")
	if expr == "" {
		return nil, nil
	}
	filter := New(expr, config)
	if err := filter.Compile(); err != nil {
		return nil, fmt.Errorf("bad filter:\n %v", err)
	}
	return filter, nil
}

// NewFromCLIWithAllAccessors builds and compiles a filter with all field accessors enabled.
func NewFromCLIWithAllAccessors(args []string) (Filter, error) {
	expr := strings.Join(args, " ")
	if expr == "" {
		return nil, nil
	}
	filter := &filter{
		parser:    ql.NewParser(expr),
		accessors: getAccessors(),
		fields:    make([]fields.Field, 0),
		bindings:  make(map[uint16][]*ql.PatternBindingLiteral),
	}
	if err := filter.Compile(); err != nil {
		return nil, fmt.Errorf("bad filter:\n %v", err)
	}
	return filter, nil
}

```

`pkg/filter/funcmap/funcmap_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package funcmap

import (
	"fmt"
	"github.com/Masterminds/sprig/v3"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	log "github.com/sirupsen/logrus"
	"strings"
	"syscall"
	"text/template"
)

// New returns the template func map
// populated with some useful template functions
// that can be used in filter actions. Some functions
// are late-bound, so we merely provide a declaration.
// The real function is attached when the filter action
// is triggered.
func New() template.FuncMap {
	f := sprig.TxtFuncMap()

	extra := template.FuncMap{
		// This is a placeholder for the functions that might be
		// late-bound to a template. By declaring them here, we
		// can still execute the template associated with the
		// filter action to ensure template syntax is correct
		"emit": func(title string, text string, args ...string) string { return "" },
		"kill": func(pid uint32) string { return "" },
		"stringify": func(in []interface{}) string {
			values := make([]string, 0)
			for _, e := range in {
				s, ok := e.(string)
				if !ok {
					continue
				}
				values = append(values, fmt.Sprintf("'%s'", s))
			}
			return fmt.Sprintf("(%s)", strings.Join(values, ", "))
		},
	}

	for k, v := range extra {
		f[k] = v
	}

	return f
}

// InitFuncs assigns late-bound functions to the func map.
func InitFuncs(funcMap template.FuncMap) {
	funcMap["emit"] = emit
	funcMap["kill"] = kill
}

// emit sends an alert via all configured alert senders.
func emit(title string, text string, args ...string) string {
	log.Debugf("sending alert: %s. Text: %s", title, text)

	senders := alertsender.FindAll()
	if len(senders) == 0 {
		return "no alertsenders registered. Alert won't be sent"
	}

	severity := "normal"
	tags := make([]string, 0)
	if len(args) > 0 {
		severity = args[0]
	}
	if len(args) > 1 {
		tags = args[1:]
	}

	for _, s := range senders {
		alert := alertsender.NewAlert(
			title,
			text,
			tags,
			alertsender.ParseSeverityFromString(severity),
		)
		if err := s.Send(alert); err != nil {
			log.Warnf("unable to emit alert from rule: %v", err)
		}
	}
	return ""
}

// kill terminates a process with specified pid.
func kill(pid uint32) string {
	h, err := syscall.OpenProcess(syscall.PROCESS_TERMINATE, false, pid)
	if err != nil {
		return fmt.Sprintf("couldn't open pid %d for terminating: %v", pid, err)
	}
	defer func() {
		_ = syscall.CloseHandle(h)
	}()
	err = syscall.TerminateProcess(h, uint32(1))
	if err != nil {
		return fmt.Sprintf("fail to kill pid %d: %v", pid, err)
	}
	return ""
}

```

`pkg/filter/ql/ast.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  Copyright (c) 2013-2016 Errplane Inc.
 */

package ql

import (
	fuzzysearch "github.com/lithammer/fuzzysearch/fuzzy"
	"github.com/rabbitstack/fibratus/pkg/util/wildcard"
	"net"
	"strconv"
	"strings"
)

// Eval evaluates expr against a map that contains the field values.
func Eval(expr Expr, m map[string]interface{}, b map[string]interface{}, useFuncValuer bool) bool {
	var eval ValuerEval
	switch {
	case useFuncValuer && len(b) > 0:
		eval = ValuerEval{Valuer: MultiValuer(MapValuer(m), PatternBindingValuer(b), FunctionValuer{m})}
	case useFuncValuer:
		eval = ValuerEval{Valuer: MultiValuer(MapValuer(m), FunctionValuer{m})}
	case len(b) > 0:
		eval = ValuerEval{Valuer: MultiValuer(MapValuer(m), PatternBindingValuer(b))}
	default:
		eval = ValuerEval{Valuer: MapValuer(m)}
	}
	v, ok := eval.Eval(expr).(bool)
	if !ok {
		return false
	}
	return v
}

// MapValuer is a valuer that substitutes values for the mapped interface.
type MapValuer map[string]interface{}

// Value returns the value for a key in the MapValuer.
func (m MapValuer) Value(key string) (interface{}, bool) {
	v, ok := m[key]
	return v, ok
}

// Valuer is the interface that wraps the Value() method.
type Valuer interface {
	// Value returns the value and existence flag for a given key.
	Value(key string) (interface{}, bool)
}

// CallValuer implements the Call method for evaluating function calls.
type CallValuer interface {
	Valuer

	// Call is invoked to evaluate a function call (if possible).
	Call(name string, args []interface{}) (interface{}, bool)
}

// PatternBindingValuer fetches values from pattern bindings
type PatternBindingValuer map[string]interface{}

// Value returns the value for a key in the PatternBindingValuer.
func (b PatternBindingValuer) Value(key string) (interface{}, bool) {
	v, ok := b[key]
	return v, ok
}

// MultiValuer returns a Valuer that iterates over multiple Valuer instances
// to find a match.
func MultiValuer(valuers ...Valuer) Valuer {
	return multiValuer(valuers)
}

type multiValuer []Valuer

func (valuers multiValuer) Value(key string) (interface{}, bool) {
	for _, valuer := range valuers {
		if v, ok := valuer.Value(key); ok {
			return v, true
		}
	}
	return nil, false
}

func (valuers multiValuer) Call(name string, args []interface{}) (interface{}, bool) {
	for _, valuer := range valuers {
		if valuer, ok := valuer.(CallValuer); ok {
			if v, ok := valuer.Call(name, args); ok {
				return v, true
			}
		}
	}
	return nil, false
}

// ValuerEval will evaluate an expression using the Valuer.
type ValuerEval struct {
	Valuer Valuer

	// IntegerFloatDivision will set the eval system to treat
	// a division between two integers as a floating point division.
	IntegerFloatDivision bool
}

// Eval evaluates an expression and returns a value.
func (v *ValuerEval) Eval(expr Expr) interface{} {
	if expr == nil {
		return nil
	}

	switch expr := expr.(type) {
	case *BinaryExpr:
		return v.evalBinaryExpr(expr)
	case *NotExpr:
		switch expr1 := expr.Expr.(type) {
		case *BinaryExpr:
			v := v.evalBinaryExpr(expr1)
			if v == nil {
				return nil
			}
			if val, ok := v.(bool); ok {
				return !val
			}
			return nil
		case *Function:
			if valuer, ok := v.Valuer.(CallValuer); ok {
				var args []interface{}
				if len(expr1.Args) > 0 {
					args = make([]interface{}, len(expr1.Args))
					for i := range expr1.Args {
						args[i] = v.Eval(expr1.Args[i])
					}
				}
				v, _ := valuer.Call(expr1.Name, args)
				if val, ok := v.(bool); ok {
					return !val
				}
				return nil
			}
			return nil
		case *ParenExpr:
			v := v.Eval(expr1.Expr)
			if v == nil {
				return nil
			}
			if val, ok := v.(bool); ok {
				return !val
			}
			return nil
		default:
			return nil
		}
	case *IntegerLiteral:
		return expr.Value
	case *UnsignedLiteral:
		return expr.Value
	case *DecimalLiteral:
		return expr.Value
	case *ParenExpr:
		return v.Eval(expr.Expr)
	case *StringLiteral:
		return expr.Value
	case *ListLiteral:
		return expr.Values
	case *BoolLiteral:
		return expr.Value
	case *FieldLiteral:
		val, ok := v.Valuer.Value(expr.Value)
		if !ok {
			return nil
		}
		return val
	case *PatternBindingLiteral:
		val, ok := v.Valuer.Value(expr.Value)
		if !ok {
			return nil
		}
		return val
	case *IPLiteral:
		return expr.Value
	case *Function:
		if valuer, ok := v.Valuer.(CallValuer); ok {
			var args []interface{}
			if len(expr.Args) > 0 {
				args = make([]interface{}, len(expr.Args))
				for i := range expr.Args {
					args[i] = v.Eval(expr.Args[i])
				}
			}
			val, _ := valuer.Call(expr.Name, args)
			return val
		}
		return nil
	default:
		return nil
	}
}

func (v *ValuerEval) evalBinaryExpr(expr *BinaryExpr) interface{} {
	lhs := v.Eval(expr.LHS)
	rhs := v.Eval(expr.RHS)
	if lhs == nil && rhs != nil {
		// when the LHS is nil and the RHS is a boolean, implicitly cast the
		// nil to false.
		if _, ok := rhs.(bool); ok {
			lhs = false
		}
	} else if lhs != nil && rhs == nil {
		// implicit cast of the RHS nil to false when the LHS is a boolean.
		if _, ok := lhs.(bool); ok {
			rhs = false
		}
	}
	// evaluate if both sides are simple types.
	switch lhs := lhs.(type) {
	case bool:
		rhs, ok := rhs.(bool)
		switch expr.Op {
		case and:
			return ok && (lhs && rhs)
		case or:
			return ok && (lhs || rhs)
		case eq:
			return ok && (lhs == rhs)
		case neq:
			return ok && (lhs != rhs)
		}
	case int:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case eq:
				return int64(lhs) == rhs
			case neq:
				return int64(lhs) != rhs
			case lt:
				return int64(lhs) < rhs
			case lte:
				return int64(lhs) <= rhs
			case gt:
				return int64(lhs) > rhs
			case gte:
				return int64(lhs) >= rhs
			}
		case uint64:
			switch expr.Op {
			case eq:
				return uint64(lhs) == rhs
			case neq:
				return uint64(lhs) != rhs
			case lt:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) < rhs
			case lte:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) <= rhs
			case gt:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) > rhs
			case gte:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) >= rhs
			}
		case []uint16:
			switch expr.Op {
			case in:
				for _, i := range rhs {
					if int(i) == lhs {
						return true
					}
				}
				return false
			}
		}
	case uint8:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case eq:
				return int64(lhs) == rhs
			case neq:
				return int64(lhs) != rhs
			case lt:
				return int64(lhs) < rhs
			case lte:
				return int64(lhs) <= rhs
			case gt:
				return int64(lhs) > rhs
			case gte:
				return int64(lhs) >= rhs
			}
		case uint64:
			switch expr.Op {
			case eq:
				return uint64(lhs) == rhs
			case neq:
				return uint64(lhs) != rhs
			case lt:
				return uint64(lhs) < rhs
			case lte:
				return uint64(lhs) <= rhs
			case gt:
				return uint64(lhs) > rhs
			case gte:
				return uint64(lhs) >= rhs
			}
		}
	case float64:
		// try the rhs as a float64, int64, or uint64
		rhsf, ok := rhs.(float64)
		if !ok {
			switch val := rhs.(type) {
			case int64:
				rhsf, ok = float64(val), true
			case uint64:
				rhsf, ok = float64(val), true
			}
		}

		rhs := rhsf
		switch expr.Op {
		case eq:
			return ok && (lhs == rhs)
		case neq:
			return ok && (lhs != rhs)
		case lt:
			return ok && (lhs < rhs)
		case lte:
			return ok && (lhs <= rhs)
		case gt:
			return ok && (lhs > rhs)
		case gte:
			return ok && (lhs >= rhs)
		}
	case int64:
		// try as a float64 to see if a float cast is required.
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case uint64:
			switch expr.Op {
			case eq:
				return uint64(lhs) == rhs
			case neq:
				return uint64(lhs) != rhs
			case lt:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) < rhs
			case lte:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) <= rhs
			case gt:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) > rhs
			case gte:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) >= rhs
			}
		}
	case uint64:
		// try as a float64 to see if a float cast is required.
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case eq:
				return lhs == uint64(rhs)
			case neq:
				return lhs != uint64(rhs)
			case lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint64(rhs)
			case lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint64(rhs)
			case gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint64(rhs)
			case gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint64(rhs)
			}
		case uint64:
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		}
	case uint32:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case int32:
			switch expr.Op {
			case eq:
				return lhs == uint32(rhs)
			case neq:
				return lhs != uint32(rhs)
			case lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint32(rhs)
			case lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint32(rhs)
			case gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint32(rhs)
			case gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint32(rhs)
			}
		case int64:
			switch expr.Op {
			case eq:
				return lhs == uint32(rhs)
			case neq:
				return lhs != uint32(rhs)
			case lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint32(rhs)
			case lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint32(rhs)
			case gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint32(rhs)
			case gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint32(rhs)
			}
		case uint32:
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		}
	case uint16:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case int32:
			switch expr.Op {
			case eq:
				return lhs == uint16(rhs)
			case neq:
				return lhs != uint16(rhs)
			case lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint16(rhs)
			case lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint16(rhs)
			case gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint16(rhs)
			case gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint16(rhs)
			}
		case int64:
			switch expr.Op {
			case eq:
				return lhs == uint16(rhs)
			case neq:
				return lhs != uint16(rhs)
			case lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint16(rhs)
			case lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint16(rhs)
			case gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint16(rhs)
			case gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint16(rhs)
			}
		case uint16:
			switch expr.Op {
			case eq:
				return lhs == rhs
			case neq:
				return lhs != rhs
			case lt:
				return lhs < rhs
			case lte:
				return lhs <= rhs
			case gt:
				return lhs > rhs
			case gte:
				return lhs >= rhs
			}
		case []string:
			switch expr.Op {
			case in:
				for _, s := range rhs {
					n, err := strconv.Atoi(s)
					if err != nil {
						continue
					}
					if uint16(n) == lhs {
						return true
					}
				}
				return false
			}
		}
	case string:
		switch expr.Op {
		case eq:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return lhs == rhs
		case neq:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return lhs != rhs
		case contains:
			switch rhs := rhs.(type) {
			case string:
				return strings.Contains(lhs, rhs)
			case []string:
				for _, s := range rhs {
					if strings.Contains(lhs, s) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case icontains:
			switch rhs := rhs.(type) {
			case string:
				return strings.Contains(strings.ToLower(lhs), strings.ToLower(rhs))
			case []string:
				for _, s := range rhs {
					if strings.Contains(strings.ToLower(lhs), strings.ToLower(s)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case in:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, i := range rhs {
				if i == lhs {
					return true
				}
			}
			return false
		case iin:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, i := range rhs {
				if strings.EqualFold(i, lhs) {
					return true
				}
			}
			return false
		case startswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasPrefix(lhs, rhs)
			case []string:
				for _, s := range rhs {
					if strings.HasPrefix(lhs, s) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case istartswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasPrefix(strings.ToLower(lhs), strings.ToLower(rhs))
			case []string:
				for _, s := range rhs {
					if strings.HasPrefix(strings.ToLower(lhs), strings.ToLower(s)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case endswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasSuffix(lhs, rhs)
			case []string:
				for _, s := range rhs {
					if strings.HasSuffix(lhs, s) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case iendswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasSuffix(strings.ToLower(lhs), strings.ToLower(rhs))
			case []string:
				for _, s := range rhs {
					if strings.HasSuffix(strings.ToLower(lhs), strings.ToLower(s)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case matches:
			switch rhs := rhs.(type) {
			case string:
				return wildcard.Match(rhs, lhs)
			case []string:
				for _, pat := range rhs {
					if wildcard.Match(pat, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case imatches:
			switch rhs := rhs.(type) {
			case string:
				return wildcard.Match(strings.ToLower(rhs), strings.ToLower(lhs))
			case []string:
				for _, pat := range rhs {
					if wildcard.Match(strings.ToLower(pat), strings.ToLower(lhs)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case fuzzy:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.Match(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.Match(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case ifuzzy:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.MatchFold(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.MatchFold(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case fuzzynorm:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.MatchNormalized(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.MatchNormalized(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case ifuzzynorm:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.MatchNormalizedFold(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.MatchNormalizedFold(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		}
	case net.IP:
		switch expr.Op {
		case eq:
			rhs, ok := rhs.(net.IP)
			if !ok {
				return false
			}
			return lhs.Equal(rhs)
		case neq:
			rhs, ok := rhs.(net.IP)
			if !ok {
				return false
			}
			return !lhs.Equal(rhs)
		case in:
			ips, ok := rhs.([]net.IP)
			if !ok {
				// keep backward compatibility with string lists
				ips1, ok := rhs.([]string)
				if !ok {
					return false
				}
				for _, ip := range ips1 {
					if net.ParseIP(ip).Equal(lhs) {
						return true
					}
				}
				return false
			}
			for _, ip := range ips {
				if ip.Equal(lhs) {
					return true
				}
			}
			return false
		case startswith:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return strings.HasPrefix(lhs.String(), rhs)
		case endswith:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return strings.HasSuffix(lhs.String(), rhs)
		}
	case []string:
		switch expr.Op {
		case contains:
			s, ok := rhs.(string)
			if !ok {
				rhs, ok := rhs.([]string)
				if !ok {
					return false
				}
				for _, s1 := range rhs {
					for _, s2 := range lhs {
						if strings.Contains(s2, s1) {
							return true
						}
					}
				}
				return false
			}
			for _, val := range lhs {
				if strings.Contains(val, s) {
					return true
				}
			}
			return false
		case icontains:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range lhs {
				for _, s2 := range rhs {
					if strings.Contains(strings.ToLower(s1), strings.ToLower(s2)) {
						return true
					}
				}
			}
			return false
		case in:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, i := range lhs {
				for _, j := range rhs {
					if i == j {
						return true
					}
				}
			}
			return false
		case startswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasPrefix(s2, s1) {
						return true
					}
				}
			}
			return false
		case istartswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasPrefix(strings.ToLower(s2), strings.ToLower(s1)) {
						return true
					}
				}
			}
			return false
		case endswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasSuffix(s2, s1) {
						return true
					}
				}
			}
			return false
		case iendswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasSuffix(strings.ToLower(s2), strings.ToLower(s1)) {
						return true
					}
				}
			}
			return false
		case matches:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, pat := range rhs {
				for _, val := range lhs {
					if wildcard.Match(pat, val) {
						return true
					}
				}
			}
			return false
		case imatches:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, pat := range rhs {
				for _, val := range lhs {
					if wildcard.Match(strings.ToLower(pat), strings.ToLower(val)) {
						return true
					}
				}
			}
			return false
		}
	}

	// the types were not comparable. If our operation was an equality operation,
	// return false instead of true.
	switch expr.Op {
	case eq, neq, lt, lte, gt, gte:
		return false
	}
	return nil
}

```

`pkg/filter/ql/error.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"fmt"
	"strings"
)

// ParseError represents an error that occurred during parsing.
type ParseError struct {
	Expr     string
	Message  string
	Found    string
	Expected []string
	Pos      int
}

// newParseError returns a new instance of ParseError.
func newParseError(found string, expected []string, pos int, expr string) *ParseError {
	return &ParseError{Found: found, Expected: expected, Pos: pos, Expr: expr}
}

// findPosInLine returns the parser position and the line number
// where the syntax error occurred when the expression is split
// over multiple lines.
func findPosInLine(expr string, pos int) (int, int) {
	ln := 1
	for i, c := range []rune(expr) {
		if c == '\n' {
			ln++
		}
		if i == pos {
			switch {
			case ln > 1:
				// multiline expression. Calculate
				// the position relative to the line
				// number by looking back for the
				// previous newline terminator
				j := pos
				for expr[j] != '\n' {
					j--
					// no newline found
					if j == -1 {
						break
					}
				}
				return pos - j + 2, ln
			default:
				// single line expression
				return pos + 1, 1
			}
		}
	}
	return pos + 1, 1
}

type renderer struct {
	strings.Builder
}

func (r *renderer) renderTopGutter()                 { r.WriteString("\n╭") }
func (r *renderer) renderCaret()                     { r.WriteString("^\n|") }
func (r *renderer) renderLeftBorder()                { r.WriteString("|\n") }
func (r *renderer) renderLineWithBorder(line string) { r.WriteString("|" + line) }
func (r *renderer) renderLine(line string)           { r.WriteString(line) }
func (r *renderer) renderNewLine()                   { r.WriteString("\n") }
func (r *renderer) renderLabel(width int, msg string) {
	r.WriteString("╰")
	for i := 0; i <= width; i++ {
		r.WriteString("─")
	}
	r.WriteString(" expected " + msg)
}

func (r *renderer) renderTopBorder(width int) {
	for i := 0; i < width; i++ {
		r.WriteString("─")
	}
}

func render(e *ParseError) string {
	pos, ln := findPosInLine(e.Expr, e.Pos)
	r := renderer{}

	lines := strings.Split(e.Expr, "\n")

	for n, line := range lines {
		if n >= ln {
			r.renderLineWithBorder(line)
		} else {
			r.renderLine(line)
		}
		// insert a new line and start drawing
		// the snippet lines, gutters and borders
		if n == ln-1 {
			r.renderTopGutter()
			r.renderTopBorder(pos - 1)
			r.renderCaret()
		}
		r.renderNewLine()
	}

	r.renderLeftBorder()
	r.renderLabel(18, strings.Join(e.Expected, ", "))

	return r.String()
}

// Error returns the string representation of the error.
func (e *ParseError) Error() string {
	if e.Message != "" {
		return fmt.Sprintf("%s at line %d, char %d", e.Message, e.Pos+1, e.Pos+1)
	}
	return render(e)
}

```

`pkg/filter/ql/error_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestParseError(t *testing.T) {
	expr := `kevt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
	        and
	     registry.key.name icontains
			(
	          CurrentVersion\\Run',
	          'Policies\\Explorer\\Run',
	          'Group Policy\\Scripts',
	          'Windows\\System\\Scripts',
	          'CurrentVersion\\Windows\\Load',
	          'CurrentVersion\\Windows\\Run',
	          'CurrentVersion\\Winlogon\\Shell',
	          'CurrentVersion\\Winlogon\\System',
	          'UserInitMprLogonScript'
	        )
	        or
	     registry.key.name istartswith
	        (
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
	          'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
	          'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
	        )
	        or
	     registry.key.name iendswith
	        (
	          'user shell folders\\startup'
	        )`
	expected := `kevt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
	        and
	     registry.key.name icontains
			(
	          CurrentVersion\\Run',
╭─────────────^
|
|	          'Policies\\Explorer\\Run',
|	          'Group Policy\\Scripts',
|	          'Windows\\System\\Scripts',
|	          'CurrentVersion\\Windows\\Load',
|	          'CurrentVersion\\Windows\\Run',
|	          'CurrentVersion\\Winlogon\\Shell',
|	          'CurrentVersion\\Winlogon\\System',
|	          'UserInitMprLogonScript'
|	        )
|	        or
|	     registry.key.name istartswith
|	        (
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
|	          'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
|	          'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
|	        )
|	        or
|	     registry.key.name iendswith
|	        (
|	          'user shell folders\\startup'
|	        )
|
╰─────────────────── expected field, string, number, bool, ip, function, pattern binding`

	e := newParseError("[", []string{"field, string, number, bool, ip, function, pattern binding"}, 142, expr)
	require.Equal(t, expected, e.Error())

	expr = `ps.name = 'cmd.exe' aand ps.cmdline contains 'ss'`
	e = newParseError("[", []string{"operator"}, 20, expr)

	expected1 := `ps.name = 'cmd.exe' aand ps.cmdline contains 'ss'
╭────────────────────^
|
|
╰─────────────────── expected operator`

	require.Equal(t, expected1, e.Error())
}

```

`pkg/filter/ql/expr.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import "fmt"

// Node represents a node in the abstract syntax tree.
type Node interface {
	String() string
}

// Expr represents an expression that can be evaluated to a value.
type Expr interface {
	Node
}

// ParenExpr represents a parenthesized expression.
type ParenExpr struct {
	Expr Expr
}

// String returns a string representation of the parenthesized expression.
func (e *ParenExpr) String() string { return fmt.Sprintf("(%s)", e.Expr.String()) }

// BinaryExpr represents an operation between two expressions.
type BinaryExpr struct {
	Op  token
	LHS Expr
	RHS Expr
}

// String returns a string representation of the binary expression.
func (e *BinaryExpr) String() string {
	return fmt.Sprintf("%s %s %s", e.LHS.String(), e.Op.String(), e.RHS.String())
}

// NotExpr represents an unary not expression.
type NotExpr struct {
	Expr Expr
}

// String returns a string representation of the not expression.
func (e *NotExpr) String() string { return fmt.Sprintf("(%s)", e.Expr.String()) }

```

`pkg/filter/ql/function.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"fmt"
	"sort"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/filter/ql/functions"
)

var (
	// ErrArgumentTypeMismatch signals an invalid argument type
	ErrArgumentTypeMismatch = func(i int, keyword string, fn functions.Fn, types []functions.ArgType) error {
		argTypes := make([]string, len(types))
		for i, typ := range types {
			argTypes[i] = typ.String()
		}
		return fmt.Errorf("argument #%d (%s) in function %s should be one of: %v", i+1, keyword, fn, strings.Join(argTypes, "|"))
	}
	// ErrUndefinedFunction is thrown when an unknown function is supplied
	ErrUndefinedFunction = func(name string) error {
		return fmt.Errorf("%s function is undefined. Did you mean one of %s%s", name, strings.Join(functionNames(), "|"), "?")
	}
	// ErrFunctionSignature is thrown when the function signature is not satisfied
	ErrFunctionSignature = func(desc functions.FunctionDesc, givenArguments int) error {
		return fmt.Errorf("%s function requires %d argument(s) but %d argument(s) given", desc.Name, desc.RequiredArgs(), givenArguments)
	}
)

var funcs = map[string]FunctionDef{
	functions.CIDRContainsFn.String(): &functions.CIDRContains{},
	functions.MD5Fn.String():          &functions.MD5{},
	functions.ConcatFn.String():       &functions.Concat{},
	functions.LtrimFn.String():        &functions.Ltrim{},
	functions.RtrimFn.String():        &functions.Rtrim{},
	functions.LowerFn.String():        &functions.Lower{},
	functions.UpperFn.String():        &functions.Upper{},
	functions.ReplaceFn.String():      &functions.Replace{},
	functions.SplitFn.String():        &functions.Split{},
	functions.LengthFn.String():       &functions.Length{},
	functions.IndexOfFn.String():      &functions.IndexOf{},
	functions.SubstrFn.String():       &functions.Substr{},
	functions.EntropyFn.String():      &functions.Entropy{},
	functions.RegexFn.String():        functions.NewRegex(),
}

// FunctionDef is the interface that all function definitions have to satisfy.
type FunctionDef interface {
	// Call is the main function method that contains the implementation logic.
	Call(args []interface{}) (interface{}, bool)
	// Desc returns the function descriptor.
	Desc() functions.FunctionDesc
	// Name returns the function name.
	Name() functions.Fn
}

// FunctionValuer implements the CallValuer interface and delegates
// the evaluation of function calls to the corresponding functions.
type FunctionValuer struct {
	m map[string]interface{}
}

func (f FunctionValuer) Value(key string) (interface{}, bool) {
	v, ok := f.m[key]
	return v, ok
}

func (FunctionValuer) Call(name string, args []interface{}) (interface{}, bool) {
	fn, ok := funcs[strings.ToUpper(name)]
	if !ok {
		return nil, false
	}
	return fn.Call(args)
}

func functionNames() []string {
	names := make([]string, 0, len(funcs))
	for _, f := range funcs {
		names = append(names, f.Name().String())
	}
	sort.Slice(names, func(i, j int) bool { return names[i] < names[j] })
	return names
}

```

`pkg/filter/ql/function_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"errors"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestParseFunction(t *testing.T) {
	var tests = []struct {
		expr string
		err  error
	}{
		{expr: "cidr_contains(net.dip)", err: errors.New("CIDR_CONTAINS function requires 2 argument(s) but 1 argument(s) given")},
		{expr: "cidr_contains(net.dip, 12)", err: errors.New("argument #2 (cidr) in function CIDR_CONTAINS should be one of: string")},
		{expr: "cidr_contains(net.dip, '172.17.12.4/24')"},
		{expr: "md('172.17.12.4')", err: errors.New("md function is undefined")},
		{expr: "concat('hello ', 'world')"},
		{expr: "concat('hello')", err: errors.New("CONCAT function requires 2 argument(s) but 1 argument(s) given")},
		{expr: "ltrim('hello world', 'hello ')"},
		{expr: "replace('hello world', 'hello', 'hell', 'world')", err: errors.New("old/new replacements mismatch")},
		{expr: "replace('hello world', 'hello', 'hell', 'world', 'war', 'hello')", err: errors.New("old/new replacements mismatch")},
		{expr: "replace('hello world', 'hello', 'hell', 'world', 'war', 'hello', 'warld', 'old', 'new', 'one')", err: errors.New("old/new replacements mismatch")},
		{expr: "indexof('hello', 'h', 'frst')", err: errors.New("frst is not a valid index search order")},
	}

	for i, tt := range tests {
		p := NewParser(tt.expr)
		_, err := p.ParseExpr()
		if err == nil && tt.err != nil {
			t.Errorf("%d. exp=%s expected error=%v", i, tt.expr, tt.err)
		} else if err != nil {
			assert.True(t, strings.Contains(err.Error(), tt.err.Error()))
		} else if err != nil && tt.err == nil {
			t.Errorf("%d. exp=%s got error=%v", i, tt.expr, err)
		}
	}
}

```

`pkg/filter/ql/functions/cidr.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"net"
)

// CIDRContains determines if the specified IP is contained within
// the block referenced by the given CIDR mask. The first argument
// in the slice represents the IP address and the rest of the args
// represent IP addresses in CIDR notation.
type CIDRContains struct{}

func (f CIDRContains) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}

	var ip net.IP
	switch addr := args[0].(type) {
	case net.IP:
		ip = addr
	case string:
		ip = net.ParseIP(addr)
	}

	// get CIDR ranges
	cidrs := make([]string, len(args)-1)
	for i, arg := range args[1:] {
		cidr, ok := arg.(string)
		if !ok {
			continue
		}
		cidrs[i] = cidr
	}

	// check each CIDR range
	for _, cidr := range cidrs {
		_, ipnet, err := net.ParseCIDR(cidr)
		if err != nil {
			continue
		}
		if ipnet.Contains(ip) {
			return true, true
		}
	}

	return false, true
}

func (f CIDRContains) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: CIDRContainsFn,
		Args: []FunctionArgDesc{
			{Keyword: "ip", Types: []ArgType{IP, Field}, Required: true},
			{Keyword: "cidr", Types: []ArgType{String}, Required: true},
		},
	}
	offset := len(desc.Args)
	// add optional CIDR arguments
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: "cidr", Types: []ArgType{String, Func}})
	}
	return desc
}

func (f CIDRContains) Name() Fn { return CIDRContainsFn }

```

`pkg/filter/ql/functions/cidr_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestCIDRContainsCall(t *testing.T) {
	call := CIDRContains{}

	res, _ := call.Call([]interface{}{net.ParseIP("192.168.1.5"), "192.168.1.0/24"})
	require.True(t, res.(bool))

	res, _ = call.Call([]interface{}{net.ParseIP("216.58.201.174"), "216.58.201.1/24"})
	require.True(t, res.(bool))

	res, _ = call.Call([]interface{}{"192.168.1.5", "192.168.1.0/24"})
	require.True(t, res.(bool))

	res, _ = call.Call([]interface{}{net.ParseIP("192.168.1.5"), "172.168.1.0/24"})
	require.False(t, res.(bool))

	res, _ = call.Call([]interface{}{net.ParseIP("192.168.1.5"), "172.168.1.0/24", "192.168.1.0/24"})
	require.True(t, res.(bool))

	res, _ = call.Call([]interface{}{net.ParseIP("192.168.1.5"), "192.168.1.0"})
	require.False(t, res.(bool))

	res, _ = call.Call([]interface{}{net.ParseIP("192.168.1.5")})
	require.False(t, res.(bool))
}

func TestCIDRContainsDesc(t *testing.T) {
	call := CIDRContains{}

	desc := call.Desc()

	assert.Equal(t, desc.RequiredArgs(), 2)
	assert.Len(t, desc.Args, maxArgs)
}

```

`pkg/filter/ql/functions/concat.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"strconv"
	"strings"
)

// Concat returns a concatenated string of all input arguments.
type Concat struct{}

func (f Concat) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	var sb strings.Builder
	for _, arg := range args {
		switch s := arg.(type) {
		case string:
			sb.WriteString(s)
		case int:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int8:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint8:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int16:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint16:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int32:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint32:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int64:
			sb.WriteString(strconv.FormatInt(s, 10))
		case uint64:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		}
	}
	return sb.String(), true
}

func (f Concat) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: ConcatFn,
		Args: []FunctionArgDesc{
			{Keyword: "string1", Types: []ArgType{String, Number, Field, Func}, Required: true},
			{Keyword: "string2", Types: []ArgType{String, Number, Field, Func}, Required: true},
		},
	}
	offset := len(desc.Args)
	// add optional arguments
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: fmt.Sprintf("string%d", i+1), Types: []ArgType{String, Number, Field, Func}})
	}
	return desc
}

func (f Concat) Name() Fn { return ConcatFn }

```

`pkg/filter/ql/functions/concat_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestConcat(t *testing.T) {
	call := Concat{}
	res, _ := call.Call([]interface{}{"hello ", "world", " ", int32(7), 7})
	assert.Equal(t, "hello world 77", res)
}

```

`pkg/filter/ql/functions/entropy.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"math"
)

const (
	shannonAlgo = "shannon"
)

// Entropy measures the string entropy
type Entropy struct{}

func (f Entropy) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	s := parseString(0, args)
	if len(args) == 1 {
		return shannon(s), true
	}
	algo := parseString(1, args)
	switch algo {
	case shannonAlgo:
		return shannon(s), true
	default:
		return false, false
	}
}

func (f Entropy) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LengthFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Field, Func}, Required: true},
			{Keyword: "algo", Types: []ArgType{String}},
		},
		ArgsValidationFunc: func(args []string) error {
			if len(args) == 1 {
				return nil
			}
			if len(args) > 1 && args[1] != shannonAlgo {
				return fmt.Errorf("unsupported entropy algorithm: %s. Availiable algorithms: shannon", args[1])
			}
			return nil
		},
	}
	return desc
}

func (f Entropy) Name() Fn { return EntropyFn }

// shannon measures the Shannon entropy of a string.
func shannon(value string) int {
	frq := make(map[rune]float64)

	//get frequency of characters
	for _, i := range value {
		frq[i]++
	}

	var sum float64

	for _, v := range frq {
		f := v / float64(len(value))
		sum += f * math.Log2(f)
	}

	return int(math.Ceil(sum*-1)) * len(value)
}

```

`pkg/filter/ql/functions/entropy_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestEntropy(t *testing.T) {
	call := Entropy{}
	res, _ := call.Call([]interface{}{"\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"})
	assert.Equal(t, 255, res)
}

```

`pkg/filter/ql/functions/indexof.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"strings"
)

// index is the type alias for the string position search order
type index uint8

const (
	unknown index = iota
	first         // Index
	any           // IndexAny
	last          // LastIndex
	lastany       // LastIndexAny
)

var indexMappings = map[string]index{
	"first":   first,
	"any":     any,
	"last":    last,
	"lastany": lastany,
}

func indexFromString(s string) index { return indexMappings[s] }

// IndexOf returns the index of the instance of substring in a given string
// depending on the provided search order.
type IndexOf struct{}

func (f IndexOf) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	str := parseString(0, args)
	substr := parseString(1, args)
	if len(args) == 2 {
		return strings.Index(str, substr), true
	}
	// index search order
	switch indexFromString(parseString(2, args)) {
	case first:
		return strings.Index(str, substr), true
	case any:
		return strings.IndexAny(str, substr), true
	case last:
		return strings.LastIndex(str, substr), true
	case lastany:
		return strings.LastIndexAny(str, substr), true
	default:
		return false, false
	}
}

func (f IndexOf) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: IndexOfFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Field, Func}, Required: true},
			{Keyword: "substr", Types: []ArgType{String, Func}, Required: true},
			{Keyword: "index", Types: []ArgType{String}},
		},
		ArgsValidationFunc: func(args []string) error {
			if len(args) == 2 {
				return nil
			}
			if len(args) == 3 && indexFromString(args[2]) == unknown {
				return fmt.Errorf("%s is not a valid index search order. Available options are: first,any,last,lastany", args[2])
			}
			return nil
		},
	}
	return desc
}

func (f IndexOf) Name() Fn { return IndexOfFn }

```

`pkg/filter/ql/functions/indexof_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestIndexOf(t *testing.T) {
	call := IndexOf{}
	res, _ := call.Call([]interface{}{"hello world", "world"})
	assert.Equal(t, 6, res)

	res1, _ := call.Call([]interface{}{"hello world", "brave"})
	assert.Equal(t, -1, res1)

	res2, _ := call.Call([]interface{}{"hello world brave world", "world", "last"})
	assert.Equal(t, 18, res2)
}

```

`pkg/filter/ql/functions/length.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

// Length returns the number of characters (runes) for string arguments and
// the size of the slice for slice arguments.
type Length struct{}

func (f Length) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	switch s := args[0].(type) {
	case string:
		return len([]rune(s)), true
	case []string:
		return len(s), true
	}
	return -1, false
}

func (f Length) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LengthFn,
		Args: []FunctionArgDesc{
			{Keyword: "string/slice", Types: []ArgType{Field, Slice, Func}, Required: true},
		},
	}
	return desc
}

func (f Length) Name() Fn { return LengthFn }

```

`pkg/filter/ql/functions/length_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLength(t *testing.T) {
	call := Length{}
	res, _ := call.Call([]interface{}{"hello"})
	assert.Equal(t, 5, res)

	res1, _ := call.Call([]interface{}{"こんにちは"})
	assert.Equal(t, 5, res1)

	res2, _ := call.Call([]interface{}{[]string{"hello", "world"}})
	assert.Equal(t, 2, res2)
}

```

`pkg/filter/ql/functions/lower.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Lower converts the string with all Unicode letters mapped to their lower case.
type Lower struct{}

func (f Lower) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	s := parseString(0, args)
	return strings.ToLower(s), true
}

func (f Lower) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LowerFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, Func}, Required: true},
		},
	}
	return desc
}

func (f Lower) Name() Fn { return LowerFn }

```

`pkg/filter/ql/functions/lower_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLower(t *testing.T) {
	call := Lower{}
	res, _ := call.Call([]interface{}{"HellO World"})
	assert.Equal(t, "hello world", res)
}

```

`pkg/filter/ql/functions/ltrim.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Ltrim trims the specified prefix from a string.
type Ltrim struct{}

func (f Ltrim) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)
	prefix := parseString(1, args)
	return strings.TrimPrefix(s, prefix), true
}

func (f Ltrim) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LtrimFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, Func}, Required: true},
			{Keyword: "prefix", Types: []ArgType{String, Func}, Required: true},
		},
	}
	return desc
}

func (f Ltrim) Name() Fn { return LtrimFn }

```

`pkg/filter/ql/functions/ltrim_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLtrim(t *testing.T) {
	call := Ltrim{}
	res, _ := call.Call([]interface{}{"hello world", "hello "})
	assert.Equal(t, "world", res)
}

```

`pkg/filter/ql/functions/md5.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"crypto/md5"
	"encoding/hex"
)

// MD5 computes the MD5 hash of the given value.
type MD5 struct{}

func (f MD5) Call(args []interface{}) (interface{}, bool) {
	if len(args) != 1 {
		return false, false
	}

	var data []byte
	switch v := args[0].(type) {
	case []byte:
		data = v
	case string:
		data = []byte(v)
	}

	if data == nil {
		return false, false
	}

	hash := md5.Sum(data)
	return hex.EncodeToString(hash[:]), true
}

func (f MD5) Desc() FunctionDesc {
	return FunctionDesc{
		Name: MD5Fn,
		Args: []FunctionArgDesc{
			{Keyword: "data", Types: []ArgType{Field, String, Func}, Required: true},
		},
	}
}

func (f MD5) Name() Fn { return MD5Fn }

```

`pkg/filter/ql/functions/md5_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestMD5Call(t *testing.T) {
	call := MD5{}

	res, _ := call.Call([]interface{}{`HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`})
	assert.Equal(t, "eab870b2a516206575d2ffa2b98d8af5", res)
}

func TestMD5Desc(t *testing.T) {
	call := MD5{}
	desc := call.Desc()

	assert.Equal(t, desc.RequiredArgs(), 1)
	assert.Len(t, desc.Args, 1)
}

```

`pkg/filter/ql/functions/regex.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"regexp"

	log "github.com/sirupsen/logrus"
)

// Regex applies single/multiple regular expressions on the provided string arguments.
type Regex struct {
	rxs map[string]*regexp.Regexp
}

// NewRegex creates a new regex function.
func NewRegex() *Regex {
	return &Regex{rxs: make(map[string]*regexp.Regexp)}
}

func (f Regex) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)

	for _, arg := range args[1:] {
		expr, ok := arg.(string)
		if !ok {
			continue
		}
		rx, compiled := f.rxs[expr]
		if compiled && rx == nil {
			continue
		}
		if !compiled {
			var err error
			rx, err = regexp.Compile(expr)
			if err != nil {
				log.Warnf("invalid regular expression pattern: %v", err)
				// to avoid compiling the regex ad infinitum
				f.rxs[expr] = nil
				continue
			}
			f.rxs[expr] = rx
		}
		if rx.MatchString(s) {
			return true, true
		}
	}

	return false, false
}

func (f Regex) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: RegexFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Field, String, Func}, Required: true},
			{Keyword: "regexp", Types: []ArgType{String}, Required: true},
		},
	}
	offset := len(desc.Args)
	// add optional regular expression patterns
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: "regexp", Types: []ArgType{String}})
	}
	return desc
}

func (f Regex) Name() Fn { return RegexFn }

```

`pkg/filter/ql/functions/regex_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestRegex(t *testing.T) {
	call := NewRegex()

	res, _ := call.Call([]interface{}{`powershell.exe`, `power.*(shell|hell).exe`})
	assert.True(t, res.(bool))

	res1, _ := call.Call([]interface{}{`powershell.exe`, `power.*(shell|hell).dll`, `.*hell.exe`})
	assert.True(t, res1.(bool))

	for i := 0; i < 10; i++ {
		res, _ := call.Call([]interface{}{`powershell.exe`, `power.*(shell|hell).dll`, `.*hell.exe`})
		assert.True(t, res.(bool))
	}
}

```

`pkg/filter/ql/functions/replace.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"errors"
	"fmt"
	"strings"
)

// Replace replaces occurrences in the string as given by arbitrary old/new replacement pairs.
type Replace struct{}

func (f Replace) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 3 {
		return false, false
	}
	s := parseString(0, args)
	// happy path
	if len(args) == 3 {
		o := parseString(1, args)
		n := parseString(2, args)
		return strings.Replace(s, o, n, -1), true
	}
	// apply multiple replacements
	repl := s
	for i := 1; i < len(args)-1; i += 2 {
		o, ok := args[i].(string)
		if !ok {
			break
		}
		n, ok := args[i+1].(string)
		if !ok {
			break
		}
		repl = strings.Replace(repl, o, n, -1)
	}
	return repl, true
}

func (f Replace) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: ReplaceFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, Func}, Required: true},
			{Keyword: "old", Types: []ArgType{String, Field, Func}, Required: true},
			{Keyword: "new", Types: []ArgType{String, Field, Func}, Required: true},
		},
		ArgsValidationFunc: func(args []string) error {
			if len(args) == 3 {
				return nil
			}
			if (len(args)-1)%2 != 0 {
				return errors.New("old/new replacements mismatch")
			}
			return nil
		},
	}
	offset := len(desc.Args)
	// add optional old/new pair arguments
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: fmt.Sprintf("old%d", i+1), Types: []ArgType{String, Field, Func}})
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: fmt.Sprintf("new%d", i+1), Types: []ArgType{String, Field, Func}})
	}
	return desc
}

func (f Replace) Name() Fn { return ReplaceFn }

```

`pkg/filter/ql/functions/replace_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestReplace(t *testing.T) {
	call := Replace{}
	_, ok := call.Call([]interface{}{"hello world", "hello "})
	assert.False(t, ok)

	res, ok := call.Call([]interface{}{"hello world", "hello", "hell"})
	assert.Equal(t, "hell world", res)
	assert.True(t, ok)

	res1, ok := call.Call([]interface{}{"hello world", "hello", "hell", "NO", "REPL"})
	assert.Equal(t, "hell world", res1)
	assert.True(t, ok)

	res2, ok := call.Call([]interface{}{"hello world", "hello", "hell", "hell", "heaven", "world", "brave"})
	assert.Equal(t, "heaven brave", res2)
	assert.True(t, ok)

	key, ok := call.Call([]interface{}{"HKEY_LOCAL_MACHINE\\SAM", "HKEY_LOCAL_MACHINE", "HKLM", "HKEY_CURRENT_USER\\Console", "HKCU"})
	assert.Equal(t, "HKLM\\SAM", key)
	assert.True(t, ok)

	key1, ok := call.Call([]interface{}{"HKEY_CURRENT_USER\\Console", "HKEY_LOCAL_MACHINE", "HKLM", "HKEY_CURRENT_USER", "HKCU"})
	assert.Equal(t, "HKCU\\Console", key1)
	assert.True(t, ok)
}

```

`pkg/filter/ql/functions/rtrim.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Rtrim trims the specified suffix from a string.
type Rtrim struct{}

func (f Rtrim) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)
	suffix := parseString(1, args)
	return strings.TrimSuffix(s, suffix), true
}

func (f Rtrim) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LtrimFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, Func}, Required: true},
			{Keyword: "suffix", Types: []ArgType{String, Func}, Required: true},
		},
	}
	return desc
}

func (f Rtrim) Name() Fn { return RtrimFn }

```

`pkg/filter/ql/functions/rtrim_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestRtrim(t *testing.T) {
	call := Rtrim{}
	res, _ := call.Call([]interface{}{"hello world", " world"})
	assert.Equal(t, "hello", res)
}

```

`pkg/filter/ql/functions/split.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"strings"
)

// Split produces a slice of substrings separated by the given delimiter.
type Split struct{}

func (f Split) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)
	sep := parseString(1, args)
	return strings.Split(s, sep), true
}

func (f Split) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: SplitFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, Func}, Required: true},
			{Keyword: "sep", Types: []ArgType{String}, Required: true},
		},
	}
	return desc
}

func (f Split) Name() Fn { return SplitFn }

```

`pkg/filter/ql/functions/split_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSplit(t *testing.T) {
	call := Split{}
	res, _ := call.Call([]interface{}{"Hello World", " "})
	assert.IsType(t, []string{}, res)
	s := res.([]string)
	assert.Contains(t, s, "World")
}

```

`pkg/filter/ql/functions/substr.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

// Substr creates a substring of a given string.
type Substr struct{}

func (f Substr) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 3 {
		return false, false
	}
	s := parseString(0, args)
	start, ok := args[1].(int)
	if !ok {
		return false, false
	}
	end, ok := args[2].(int)
	if !ok {
		return false, false
	}
	if start >= 0 && (end >= start && end < len(s)) {
		return s[start:end], true
	}
	return s, true
}

func (f Substr) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: SubstrFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Func, Field}, Required: true},
			{Keyword: "start", Types: []ArgType{Func, Number}, Required: true},
			{Keyword: "end", Types: []ArgType{Func, Number}, Required: true},
		},
	}
	return desc
}

func (f Substr) Name() Fn { return SubstrFn }

```

`pkg/filter/ql/functions/substr_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSubstr(t *testing.T) {
	call := Substr{}
	res, _ := call.Call([]interface{}{"Hello", 0, 4})
	assert.Equal(t, "Hell", res)

	res1, _ := call.Call([]interface{}{"Hello World!", 0, 50})
	assert.Equal(t, "Hello World!", res1)

	res2, _ := call.Call([]interface{}{"Hello World!", 4, -1})
	assert.Equal(t, "Hello World!", res2)

	res3, _ := call.Call([]interface{}{"Hello World!", -1, 10})
	assert.Equal(t, "Hello World!", res3)

	res4, _ := call.Call([]interface{}{"Hello World!", 6, 7})
	assert.Equal(t, "W", res4)
}

```

`pkg/filter/ql/functions/types.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

const maxArgs = 1 << 5

// Fn is the type alias for function definitions.
type Fn uint16

const (
	// CIDRContainsFn identifies the CIDR_CONTAINS function
	CIDRContainsFn Fn = iota + 1
	// MD5Fn represents the MD5 function
	MD5Fn
	// ConcatFn represents the CONCAT function
	ConcatFn
	// LtrimFn represents the LTRIM function
	LtrimFn
	// RtrimFn represents the RTRIM function
	RtrimFn
	// LowerFn represents the LOWER function
	LowerFn
	// UpperFn represents the UPPER function
	UpperFn
	// ReplaceFn represents the REPLACE function
	ReplaceFn
	// SplitFn represents the SPLIT function
	SplitFn
	// LengthFn represents the LENGTH function
	LengthFn
	// IndexOfFn represents the INDEXOF function
	IndexOfFn
	// SubstrFn represents the SUBSTR function
	SubstrFn
	// EntropyFn represents the ENTROPY function
	EntropyFn
	// RegexFn represents the REGEX function
	RegexFn
)

// ArgType is the type alias for the argument value type.
type ArgType uint8

// ArgsValidation is a function for the custom argument validation logic.
type ArgsValidation func(args []string) error

const (
	// String represents the string argument type.
	String ArgType = iota
	// Number represents the scalar argument type.
	Number
	// IP represents the IP argument type.
	IP
	// Field represents the argument type that is derived
	// from the field literal. Field literal values can
	// be simple primitive types.
	Field
	// Func represents the argument type that is derived
	// from the function return value.
	Func
	// Slice represents the string slice argument type.
	Slice
	// Unknown is the unknown argument type.
	Unknown
)

// String returns the argument type as a string value.
func (typ ArgType) String() string {
	switch typ {
	case String:
		return "string"
	case Number:
		return "number"
	case IP:
		return "ip"
	case Field:
		return "field"
	case Func:
		return "func"
	case Slice:
		return "slice"
	}
	return "unknown"
}

// FunctionDesc contains the function signature that
// particular filter function has to satisfy.
type FunctionDesc struct {
	Name               Fn
	Args               []FunctionArgDesc
	ArgsValidationFunc ArgsValidation
}

// RequiredArgs returns the number of the required function args.
func (f FunctionDesc) RequiredArgs() int {
	var nargs int
	for _, arg := range f.Args {
		if arg.Required {
			nargs++
		}
	}
	return nargs
}

// FunctionArgDesc described each function argument.
type FunctionArgDesc struct {
	Keyword  string
	Required bool
	Types    []ArgType
}

// ContainsType returns true if the argument satisfies the given argument type.
func (arg FunctionArgDesc) ContainsType(typ ArgType) bool {
	for _, t := range arg.Types {
		if t == typ {
			return true
		}
	}
	return false
}

// String returns the function name in upper case.
func (f Fn) String() string {
	switch f {
	case CIDRContainsFn:
		return "CIDR_CONTAINS"
	case MD5Fn:
		return "MD5"
	case ConcatFn:
		return "CONCAT"
	case LtrimFn:
		return "LTRIM"
	case RtrimFn:
		return "RTRIM"
	case LowerFn:
		return "LOWER"
	case UpperFn:
		return "UPPER"
	case ReplaceFn:
		return "REPLACE"
	case SplitFn:
		return "SPLIT"
	case LengthFn:
		return "LENGTH"
	case IndexOfFn:
		return "INDEXOF"
	case SubstrFn:
		return "SUBSTR"
	case EntropyFn:
		return "ENTROPY"
	case RegexFn:
		return "REGEX"
	default:
		return "UNDEFINED"
	}
}

// parseString yields a string value from the specific position in the args slice.
func parseString(index int, args []interface{}) string {
	if index > len(args) {
		return ""
	}
	s, ok := args[index].(string)
	if !ok {
		return ""
	}
	return s
}

```

`pkg/filter/ql/functions/upper.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Upper converts the string with all Unicode letters mapped to their upper case.
type Upper struct{}

func (f Upper) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	s := parseString(0, args)
	return strings.ToUpper(s), true
}

func (f Upper) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: UpperFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, Func}, Required: true},
		},
	}
	return desc
}

func (f Upper) Name() Fn { return UpperFn }

```

`pkg/filter/ql/functions/upper_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestUpper(t *testing.T) {
	call := Upper{}
	res, _ := call.Call([]interface{}{"HellO World"})
	assert.Equal(t, "HELLO WORLD", res)
}

```

`pkg/filter/ql/lexer.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  Copyright (c) 2013-2016 Errplane Inc.
 */

package ql

import (
	"bufio"
	"bytes"
	"errors"
	"io"
	"strconv"
	"strings"
)

// scanner is responsible for splitting up the filter expression into individual tokens. This code is mostly borrowed
// from the influxql repository (https://github.com/influxdata/influxql) with some changes to support the lexing
// of additional tokens such as IP addresses.
type scanner struct {
	r *reader
}

func newScanner(r io.Reader) *scanner {
	return &scanner{r: &reader{r: bufio.NewReader(r)}}
}

// scan returns the next token and position from the underlying reader.
// Also returns the literal text read for strings, numbers, and duration tokens
// since these token types can have different literal representations.
func (s *scanner) scan() (tok token, pos int, lit string) {
	// Read next code point.
	ch0, pos := s.r.read()

	// if we see whitespace then consume all contiguous whitespace.
	// if we see a letter, or certain acceptable special characters, then consume
	// as an ident or reserved word.
	if isWhitespace(ch0) {
		return s.scanWhitespace()
	} else if isLetter(ch0) || ch0 == '_' || ch0 == '$' {
		s.r.unread()
		return s.scanIdent()
	} else if isDigit(ch0) {
		return s.scanNumber()
	}

	// Otherwise, parse individual characters.
	switch ch0 {
	case reof:
		return eof, pos, ""
	case '"':
		s.r.unread()
		return s.scanIdent()
	case '\'':
		return s.scanString()
	case '.':
		ch1, _ := s.r.read()
		s.r.unread()
		if isDigit(ch1) {
			return s.scanNumber()
		}
		return dot, pos, ""
	case '=':
		return eq, pos, ""
	case '!':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return neq, pos, ""
		}
		s.r.unread()
	case '>':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return gte, pos, ""
		}
		s.r.unread()
		return gt, pos, ""
	case '<':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return lte, pos, ""
		} else if ch1 == '>' {
			return neq, pos, ""
		}
		s.r.unread()
		return lt, pos, ""
	case '(':
		return lparen, pos, ""
	case ')':
		return rparen, pos, ""
	case ',':
		return comma, pos, ""
	}
	return illegal, pos, string(ch0)
}

// scanWhitespace consumes the current rune and all contiguous whitespace.
func (s *scanner) scanWhitespace() (tok token, pos int, lit string) {
	// Create a buffer and read the current character into it.
	var buf bytes.Buffer
	ch, pos := s.r.curr()
	_, _ = buf.WriteRune(ch)

	// Read every subsequent whitespace character into the buffer.
	// Non-whitespace characters and EOF will cause the loop to exit.
	for {
		ch, _ = s.r.read()
		if ch == reof {
			break
		} else if !isWhitespace(ch) {
			s.r.unread()
			break
		} else {
			_, _ = buf.WriteRune(ch)
		}
	}

	return ws, pos, buf.String()
}

func (s *scanner) scanIdent() (tok token, pos int, lit string) {
	// Save the starting position of the identifier.
	_, pos = s.r.read()
	s.r.unread()

	var buf bytes.Buffer
	for {
		if ch, _ := s.r.read(); ch == reof {
			break
		} else if ch == '"' {
			tok0, pos0, lit0 := s.scanString()
			if tok0 == badstr || tok0 == badesc {
				return tok0, pos0, lit0
			}
			return ident, pos, lit0
		} else if isIdentChar(ch) {
			s.r.unread()
			buf.WriteString(scanBareIdent(s.r))
		} else {
			s.r.unread()
			break
		}
	}
	lit = buf.String()

	if tok, lit = lookup(lit); tok != ident {
		return tok, pos, lit
	}

	return ident, pos, lit
}

// scanNumber consumes anything that looks like the start of a number.
func (s *scanner) scanNumber() (tok token, pos int, lit string) {
	var buf bytes.Buffer

	// Check if the initial rune is a ".".
	ch, pos := s.r.curr()
	if ch == '.' {
		// Peek and see if the next rune is a digit.
		ch1, _ := s.r.read()
		s.r.unread()
		if !isDigit(ch1) {
			return illegal, pos, "."
		}
		// Unread the full stop so we can read it later.
		s.r.unread()
	} else {
		s.r.unread()
	}

	// Read as many digits as possible.
	_, _ = buf.WriteString(s.scanDigits())

	// If next code points are a full stop and digit then consume them.
	isDecimal := false
	if ch0, _ := s.r.read(); ch0 == '.' {
		isDecimal = true
		if ch1, _ := s.r.read(); isDigit(ch1) {
			_, _ = buf.WriteRune(ch0)
			_, _ = buf.WriteRune(ch1)
			_, _ = buf.WriteString(s.scanDigits())
		} else {
			s.r.unread()
		}
	} else {
		s.r.unread()
	}

	// Check if next token is a "." and has at least 2 more subsequent "." runes
	// to confirm we have an IP address string
	ch, _ = s.r.read()
	if ch == '.' {
		buf.WriteRune(ch)
		nbDots := 2
		for {
			buf.WriteString(s.scanDigits())
			ch, _ := s.r.read()
			if ch != '.' {
				s.r.unread()
				break
			}
			nbDots++
			_, _ = buf.WriteRune(ch)
		}
		if nbDots != 3 {
			s.r.unread()
			return badip, pos, buf.String()
		}
		octets := strings.Split(buf.String(), ".")
		if len(octets) != 4 {
			return badip, pos, buf.String()
		}
		// check the range of each octet
		for _, oct := range octets {
			n, err := strconv.Atoi(oct)
			if err != nil {
				return badip, pos, buf.String()
			}
			if n < 0 || n > 255 {
				return badip, pos, buf.String()
			}
		}
		return ip, pos, buf.String()
	}
	// unread the previously read char
	s.r.unread()

	// Read as a duration or integer if it doesn't have a fractional part.
	if !isDecimal {
		// If the next rune is a letter then this is a duration token.
		if ch0, _ := s.r.read(); isLetter(ch0) || ch0 == 'µ' {
			_, _ = buf.WriteRune(ch0)
			for {
				ch1, _ := s.r.read()
				if !isLetter(ch1) && ch1 != 'µ' {
					s.r.unread()
					break
				}
				_, _ = buf.WriteRune(ch1)
			}

			// Continue reading digits and letters as part of this token.
			for {
				if ch0, _ := s.r.read(); isLetter(ch0) || ch0 == 'µ' || isDigit(ch0) {
					_, _ = buf.WriteRune(ch0)
				} else {
					s.r.unread()
					break
				}
			}
			return duration, pos, buf.String()
		}
		s.r.unread()
		return integer, pos, buf.String()
	}

	return dec, pos, buf.String()
}

// scanDigits consumes a contiguous series of digits.
func (s *scanner) scanDigits() string {
	var buf bytes.Buffer
	for {
		ch, _ := s.r.read()
		if !isDigit(ch) {
			s.r.unread()
			break
		}
		_, _ = buf.WriteRune(ch)
	}
	return buf.String()
}

// scanBareIdent reads bare identifier from a rune reader.
func scanBareIdent(r io.RuneScanner) string {
	// Read every ident character into the buffer.
	// Non-ident characters and EOF will cause the loop to exit.
	var buf bytes.Buffer
	for {
		ch, _, err := r.ReadRune()
		if err != nil {
			break
		} else if !isIdentChar(ch) {
			_ = r.UnreadRune()
			break
		} else {
			_, _ = buf.WriteRune(ch)
		}
	}
	return buf.String()
}

// scanString consumes a contiguous string of non-quote characters.
// Quote characters can be consumed if they're first escaped with a backslash.
func (s *scanner) scanString() (tok token, pos int, lit string) {
	s.r.unread()
	_, pos = s.r.curr()

	var err error
	lit, err = ScanString(s.r)
	if err == errBadString {
		return badstr, pos, lit
	} else if err == errBadEscape {
		_, pos = s.r.curr()
		return badstr, pos, lit
	}
	return str, pos, lit
}

var errBadString = errors.New("bad string")
var errBadEscape = errors.New("bad escape")

// ScanString reads a quoted string from a rune reader.
func ScanString(r io.RuneScanner) (string, error) {
	ending, _, err := r.ReadRune()
	if err != nil {
		return "", errBadString
	}

	var buf bytes.Buffer
	for {
		ch0, _, err := r.ReadRune()
		if ch0 == ending {
			return buf.String(), nil
		} else if err != nil || ch0 == '\n' {
			return buf.String(), errBadString
		} else if ch0 == '\\' {
			// If the next character is an escape then write the escaped char.
			// If it's not a valid escape then return an error.
			ch1, _, _ := r.ReadRune()
			if ch1 == 'n' {
				_, _ = buf.WriteRune('\n')
			} else if ch1 == '\\' {
				_, _ = buf.WriteRune('\\')
			} else if ch1 == '"' {
				_, _ = buf.WriteRune('"')
			} else if ch1 == '\'' {
				_, _ = buf.WriteRune('\'')
			} else {
				return string(ch0) + string(ch1), errBadEscape
			}
		} else {
			_, _ = buf.WriteRune(ch0)
		}
	}
}

// bufScanner represents a wrapper for scanner to add a buffer.
// It provides a fixed-length circular buffer that can be unread.
type bufScanner struct {
	s   *scanner
	i   int // buffer index
	n   int // buffer size
	buf [3]struct {
		tok token
		pos int
		lit string
	}
}

// newBufScanner returns a new buffered scanner for a reader.
func newBufScanner(r io.Reader) *bufScanner {
	return &bufScanner{s: newScanner(r)}
}

// scan reads the next token from the scanner.
func (s *bufScanner) scan() (tok token, pos int, lit string) {
	return s.scanFunc(s.s.scan)
}

// scanFunc uses the provided function to scan the next token.
func (s *bufScanner) scanFunc(scan func() (token, int, string)) (tok token, pos int, lit string) {
	// If we have unread tokens then read them off the buffer first.
	if s.n > 0 {
		s.n--
		return s.curr()
	}

	// Move buffer position forward and save the token.
	s.i = (s.i + 1) % len(s.buf)
	buf := &s.buf[s.i]
	buf.tok, buf.pos, buf.lit = scan()

	return s.curr()
}

// unscan pushes the previously token back onto the buffer.
func (s *bufScanner) unscan() { s.n++ }

// curr returns the last read token.
func (s *bufScanner) curr() (tok token, pos int, lit string) {
	buf := &s.buf[(s.i-s.n+len(s.buf))%len(s.buf)]
	return buf.tok, buf.pos, buf.lit
}

type reader struct {
	r   io.RuneScanner
	i   int
	n   int // buffer char count
	pos int // last read rune position
	buf [3]struct {
		ch  rune
		pos int
	}
	eof bool
}

// ReadRune reads the next rune from the reader.
// This is a wrapper function to implement the io.RuneReader interface.
// Note that this function does not return size.
func (r *reader) ReadRune() (ch rune, size int, err error) {
	ch, _ = r.read()
	if ch == reof {
		err = io.EOF
	}
	return
}

// UnreadRune pushes the previously read rune back onto the buffer.
// This is a wrapper function to implement the io.RuneScanner interface.
func (r *reader) UnreadRune() error {
	r.unread()
	return nil
}

var reof = rune(0)

// read reads the next rune from the reader.
func (r *reader) read() (ch rune, pos int) {
	// if we have unread characters then read them off the buffer first.
	if r.n > 0 {
		r.n--
		return r.curr()
	}

	// Read next rune from underlying reader.
	// Any error (including io.EOF) should return as EOF.
	ch, _, err := r.r.ReadRune()
	if err != nil {
		ch = reof
	} else if ch == '\r' {
		if ch, _, err := r.r.ReadRune(); err != nil {
			// nop
		} else if ch != '\n' {
			_ = r.r.UnreadRune()
		}
		ch = '\n'
	}

	// Save character and position to the buffer.
	r.i = (r.i + 1) % len(r.buf)
	buf := &r.buf[r.i]
	buf.ch, buf.pos = ch, r.pos

	// Update position.
	if !r.eof {
		r.pos++
	}

	// Mark the reader as EOF.
	// This is used so we don't double count EOF characters.
	if ch == reof {
		r.eof = true
	}

	return r.curr()
}

// unread pushes the previously read rune back onto the buffer.
func (r *reader) unread() { r.n++ }

// curr returns the last read character and position.
func (r *reader) curr() (ch rune, pos int) {
	i := (r.i - r.n + len(r.buf)) % len(r.buf)
	buf := &r.buf[i]
	return buf.ch, buf.pos
}

// isWhitespace returns true if the rune is a space, tab, or newline.
func isWhitespace(ch rune) bool { return ch == ' ' || ch == '\t' || ch == '\n' }

// isLetter returns true if the rune is a letter.
func isLetter(ch rune) bool {
	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')
}

// isDigit returns true if the rune is a digit.
func isDigit(ch rune) bool { return ch >= '0' && ch <= '9' }

// isIdentChar returns true if the rune can be used in an unquoted identifier. $ rune is for special PE section names (e.g. .debug$ | .tls$)
func isIdentChar(ch rune) bool {
	return isLetter(ch) || isDigit(ch) || ch == '_' || ch == '.' || ch == '[' || ch == ']' || ch == '$'
}

```

`pkg/filter/ql/lexer_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"strings"
	"testing"
)

func TestScanner(t *testing.T) {
	var tests = []struct {
		s   string
		tok token
		lit string
		pos int
	}{
		// special tokens
		{s: ``, tok: eof},
		{s: `#`, tok: illegal, lit: `#`},
		{s: ` `, tok: ws, lit: " "},
		{s: "\t", tok: ws, lit: "\t"},

		// logical operators
		{s: `AND`, tok: and},
		{s: `and`, tok: and},
		{s: `OR`, tok: or},
		{s: `or`, tok: or},

		{s: `=`, tok: eq},
		{s: `<>`, tok: neq},
		{s: `! `, tok: illegal, lit: "!"},
		{s: `<`, tok: lt},
		{s: `<=`, tok: lte},
		{s: `>`, tok: gt},
		{s: `>=`, tok: gte},
		{s: `IN`, tok: in},
		{s: `in`, tok: in},

		// misc tokens
		{s: `(`, tok: lparen},
		{s: `)`, tok: rparen},
		{s: `,`, tok: comma},

		// fields
		{s: `ps.name`, tok: field, lit: "ps.name"},
		{s: `ps.pe.sections[.debug$S].entropy`, tok: field, lit: "ps.pe.sections[.debug$S].entropy"},
		{s: `ps.envs[CommonProgramFiles86]`, tok: field, lit: "ps.envs[CommonProgramFiles86]"},

		// pattern bindings
		{s: `$1.ps.name`, tok: patternBinding, lit: "$1.ps.name"},
		{s: `$4.kevt.name`, tok: patternBinding, lit: "$4.kevt.name"},
		{s: `$4.ps.ancestor[1].name`, tok: patternBinding, lit: "$4.ps.ancestor[1].name"},

		// identifiers
		{s: `foo`, tok: ident, lit: `foo`},
		{s: `_foo`, tok: ident, lit: `_foo`},
		{s: `Zx12_3U_-`, tok: ident, lit: `Zx12_3U_`},
		{s: `"foo\"bar\""`, tok: ident, lit: `foo"bar"`},

		// IP address
		{s: "172.17.0.1", tok: ip, lit: "172.17.0.1"},
		{s: "172.17.1", tok: badip, lit: "172.17.1"},
		{s: "172.317.1.2", tok: badip, lit: "172.317.1.2"},
		{s: "172.2.266.2", tok: badip, lit: "172.2.266.2"},

		// strings
		{s: `'testing 123!'`, tok: str, lit: `testing 123!`},
		{s: `'foo\nbar'`, tok: str, lit: "foo\nbar"},
		{s: `'foo\\bar'`, tok: str, lit: "foo\\bar"},

		// numbers
		{s: "6.2323", tok: dec, lit: "6.2323"},
	}

	for i, tt := range tests {
		s := newScanner(strings.NewReader(tt.s))
		tok, pos, lit := s.scan()
		if tt.tok != tok {
			t.Errorf("%d. %q token mismatch: exp=%q got=%q <%q>", i, tt.s, tt.tok, tok, lit)
		} else if tt.pos != pos {
			t.Errorf("%d. %q pos mismatch: exp=%#v got=%#v", i, tt.s, tt.pos, pos)
		} else if tt.lit != lit {
			t.Errorf("%d. %q literal mismatch: exp=%q got=%q", i, tt.s, tt.lit, lit)
		}
	}
}

```

`pkg/filter/ql/literal.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"net"
	"reflect"
	"strconv"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/filter/ql/functions"
)

// StringLiteral represents a string literal.
type StringLiteral struct {
	Value string
}

// FieldLiteral represents a field literal.
type FieldLiteral struct {
	Value string
}

// IntegerLiteral represents a signed number literal.
type IntegerLiteral struct {
	Value int64
}

// UnsignedLiteral represents an unsigned number literal.
type UnsignedLiteral struct {
	Value uint64
}

// DecimalLiteral represents an floating point number literal.
type DecimalLiteral struct {
	Value float64
}

// BoolLiteral represents the logical true/false literal.
type BoolLiteral struct {
	Value bool
}

// IPLiteral represents an IP literal.
type IPLiteral struct {
	Value net.IP
}

// PatternBindingLiteral represents a pattern binding literal.
type PatternBindingLiteral struct {
	Value string
}

// Index returns the index pattern binding index number. E.g.
// Say the pattern binding is $1.ps.name, this method returns
// 1
func (b PatternBindingLiteral) Index() uint16 {
	i, err := strconv.Atoi(b.Value[1:2])
	if err != nil {
		return 0
	}
	return uint16(i)
}

// Field returns the string name from the pattern binding.
func (b PatternBindingLiteral) Field() fields.Field {
	return fields.Field(b.Value[3:])
}

func (i IPLiteral) String() string {
	return i.Value.String()
}

func (i IntegerLiteral) String() string {
	return strconv.Itoa(int(i.Value))
}

func (s StringLiteral) String() string {
	return s.Value
}

func (f FieldLiteral) String() string {
	return f.Value
}

func (u UnsignedLiteral) String() string {
	return strconv.Itoa(int(u.Value))
}

func (d DecimalLiteral) String() string {
	return strconv.FormatFloat(d.Value, 'e', -1, 64)
}

func (b BoolLiteral) String() string {
	return strconv.FormatBool(b.Value)
}

func (b PatternBindingLiteral) String() string {
	return b.Value
}

// ListLiteral represents a list of tag key literals.
type ListLiteral struct {
	Values []string
}

// String returns a string representation of the literal.
func (s *ListLiteral) String() string {
	var buf bytes.Buffer
	_, _ = buf.WriteString("(")
	for idx, tagKey := range s.Values {
		if idx != 0 {
			_, _ = buf.WriteString(", ")
		}
		_, _ = buf.WriteString(tagKey)
	}
	_, _ = buf.WriteString(")")
	return buf.String()
}

// Function represents a function call.
type Function struct {
	Name string
	Args []Expr
}

// ArgsSlice returns arguments as a slice of strings.
func (f *Function) ArgsSlice() []string {
	args := make([]string, 0, len(f.Args))
	for _, arg := range f.Args {
		args = append(args, arg.String())
	}
	return args
}

// String returns a string representation of the call.
func (f *Function) String() string {
	// join arguments.
	var str []string
	for _, arg := range f.Args {
		str = append(str, arg.String())
	}

	// Write function name and args.
	return fmt.Sprintf("%s(%s)", f.Name, strings.Join(str, ", "))
}

// validate ensures that the function name obtained
// from the parser exists within the internal functions
// catalog. It also validates the function signature to
// make sure required arguments are supplied. Finally, it
// checks the type of each argument with the expected one.
func (f Function) validate() error {
	fn, ok := funcs[strings.ToUpper(f.Name)]
	if !ok {
		return ErrUndefinedFunction(f.Name)
	}

	if len(f.Args) < fn.Desc().RequiredArgs() ||
		len(f.Args) > len(fn.Desc().Args) {
		return ErrFunctionSignature(fn.Desc(), len(f.Args))
	}

	validationFunc := fn.Desc().ArgsValidationFunc
	if validationFunc != nil {
		if err := validationFunc(f.ArgsSlice()); err != nil {
			return err
		}
	}

	for i, expr := range f.Args {
		arg := fn.Desc().Args[i]
		typ := functions.Unknown

		switch reflect.TypeOf(expr) {
		case reflect.TypeOf(&FieldLiteral{}):
			typ = functions.Field
		case reflect.TypeOf(&IPLiteral{}):
			typ = functions.IP
		case reflect.TypeOf(&StringLiteral{}):
			typ = functions.String
		case reflect.TypeOf(&IntegerLiteral{}):
			typ = functions.Number
		case reflect.TypeOf(&Function{}):
			typ = functions.Func
		case reflect.TypeOf(&ListLiteral{}):
			typ = functions.Slice
		}

		if !arg.ContainsType(typ) {
			return ErrArgumentTypeMismatch(i, arg.Keyword, fn.Name(), arg.Types)
		}
	}
	return nil
}

```

`pkg/filter/ql/parser.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  Copyright (c) 2013-2016 Errplane Inc.
 */

package ql

import (
	"net"
	"strconv"
	"strings"
)

// Parser builds the binary expression tree from the filter string.
type Parser struct {
	s    *bufScanner
	expr string
}

// NewParser builds a new parser instance from the expression string.
func NewParser(expr string) *Parser {
	return &Parser{s: newBufScanner(strings.NewReader(expr)), expr: expr}
}

// ParseExpr parses an expression by building the binary expression tree.
func (p *Parser) ParseExpr() (Expr, error) {
	var err error
	root := &BinaryExpr{}

	// parse a non-binary expression type to start. This variable will always be
	// the root of the expression tree.
	root.RHS, err = p.parseUnaryExpr()
	if err != nil {
		return nil, err
	}

	// loop over operations and unary exprs and build a tree based on precedence.
	for {
		// if the next token is NOT an operator then return the expression.
		op, pos, lit := p.scanIgnoreWhitespace()
		if !op.isOperator() {
			p.unscan()
			if op != eof && op != rparen && op != comma {
				return nil, newParseError(tokstr(op, lit), []string{"operator", "')'", "','"}, pos, p.expr)
			}
			return root.RHS, nil
		}

		if op == in || op == iin {
			// expect LPAREN after in
			tok, pos, lit := p.scanIgnoreWhitespace()
			p.unscan()
			if tok != lparen {
				return nil, newParseError(tokstr(op, lit), []string{"'('"}, pos, p.expr)
			}
		}

		var rhs Expr
		switch op {
		case not:
			// the first variant of the negation operator.
			// The operator that is negated appears immediately
			// after the `not` operator, e.g. ps.name not in ('cmd.exe')
			op1, pos, lit := p.scanIgnoreWhitespace()
			if !op1.isOperator() {
				return nil, newParseError(tokstr(op, lit), []string{"operator"}, pos, p.expr)
			}
			// parse the next expression after operator
			rhs1, err := p.parseUnaryExpr()
			if err != nil {
				return nil, err
			}
			rhs = &BinaryExpr{RHS: rhs1, Op: op1}
		default:
			op1, _, _ := p.scanIgnoreWhitespace()
			// if the negation appears after the operator
			// try to parse an entire binary expr and wrap
			// it inside the `not` expression. This is the
			// second variant of the negating expressions, e.g.
			// ps.name = 'cmd.exe' and not (ps.name in ('powershell.exe'))
			if op1 == not {
				binaryExpr, err := p.ParseExpr()
				if err != nil {
					return nil, err
				}
				rhs = &NotExpr{binaryExpr}
			} else {
				p.unscan()
				// otherwise, parse the next expression
				rhs, err = p.parseUnaryExpr()
				if err != nil {
					return nil, err
				}
			}
		}

		// find the right spot in the tree to add the new expression by
		// descending the RHS of the expression tree until we reach the last
		// BinaryExpr or a BinaryExpr whose RHS has an operator with
		// precedence >= the operator being added.
		for node := root; ; {
			r, ok := node.RHS.(*BinaryExpr)
			if !ok || r.Op.precedence() >= op.precedence() {
				if op == not {
					r := rhs.(*BinaryExpr)
					r.LHS = node.RHS
					node.RHS = &NotExpr{Expr: r}
					break
				}
				// Add the new expression here and break.
				node.RHS = &BinaryExpr{LHS: node.RHS, RHS: rhs, Op: op}
				break
			}
			node = r
		}
	}
}

// parseUnaryExpr parses an non-binary expression.
func (p *Parser) parseUnaryExpr() (Expr, error) {
	// If the first token is a LPAREN then parse it as its own grouped expression.
	if tok, _, _ := p.scanIgnoreWhitespace(); tok == lparen {
		// parse a comma-separated list if this looks like a list
		tagKeys, err := p.parseList()
		if err != nil {
			p.unscan()
			// if it fails, try to parse the grouped expression
			expr, err := p.ParseExpr()
			if err != nil {
				return nil, err
			}
			// Expect an RPAREN at the end.
			if tok, pos, lit := p.scanIgnoreWhitespace(); tok != rparen {
				return nil, newParseError(tokstr(tok, lit), []string{"')'"}, pos, p.expr)
			}
			return &ParenExpr{Expr: expr}, nil
		}

		// Expect an RPAREN at the end of list
		if tok, pos, lit := p.scanIgnoreWhitespace(); tok != rparen {
			return nil, newParseError(tokstr(tok, lit), []string{"')'"}, pos, p.expr)
		}

		return &ListLiteral{Values: tagKeys}, nil
	}

	p.unscan()

	tok, pos, lit := p.scanIgnoreWhitespace()
	switch tok {
	case ident:
		if tok0, _, _ := p.scan(); tok0 == lparen {
			return p.parseFunction(lit)
		}
		// unscan lparen and ident tokens
		p.unscan()
		p.unscan()
	case ip:
		return &IPLiteral{Value: net.ParseIP(lit)}, nil
	case str:
		return &StringLiteral{Value: lit}, nil
	case field:
		return &FieldLiteral{Value: lit}, nil
	case patternBinding:
		return &PatternBindingLiteral{Value: lit}, nil
	case truet, falset:
		return &BoolLiteral{Value: tok == truet}, nil
	case integer:
		v, err := strconv.ParseInt(lit, 10, 64)
		if err != nil {
			// The literal may be too large to fit into an int64. If it is, use an unsigned integer.
			// The check for negative numbers is handled somewhere else so this should always be a positive number.
			if v, err := strconv.ParseUint(lit, 10, 64); err == nil {
				return &UnsignedLiteral{Value: v}, nil
			}
			return nil, &ParseError{Message: "unable to parse integer", Pos: pos}
		}
		return &IntegerLiteral{Value: v}, nil
	case dec:
		v, err := strconv.ParseFloat(lit, 64)
		if err != nil {
			return nil, &ParseError{Message: "unable to parse decimal", Pos: pos}
		}
		return &DecimalLiteral{Value: v}, nil
	}

	expectations := []string{"field", "string", "number", "bool", "ip", "function", "pattern binding"}
	if tok == badip {
		expectations = []string{"a valid IP address"}
	}
	if tok == badesc || tok == badstr {
		expectations = []string{"a valid string but bad string or escape found"}
	}

	return nil, newParseError(tokstr(tok, lit), expectations, pos, p.expr)
}

func (p *Parser) parseList() ([]string, error) {
	tok, pos, lit := p.scanIgnoreWhitespace()
	if tok != str && tok != ip && tok != integer {
		return []string{}, newParseError(tokstr(tok, lit), []string{"identifier"}, pos, p.expr)
	}
	idents := []string{lit}

	// parse remaining identifiers
	for {
		if tok, _, _ := p.scanIgnoreWhitespace(); tok != comma {
			p.unscan()
			return idents, nil
		}

		tok, pos, lit := p.scanIgnoreWhitespace()
		if tok != str && tok != ip && tok != integer {
			return []string{}, newParseError(tokstr(tok, lit), []string{"identifier"}, pos, p.expr)
		}

		idents = append(idents, lit)
	}
}

// parseFunction parses a function call. This function assumes
// the function name and LPAREN have been consumed.
func (p *Parser) parseFunction(name string) (*Function, error) {
	name = strings.ToLower(name)
	args := make([]Expr, 0)

	// If there's a right paren then just return immediately.
	// This is the case for functions without arguments
	if tok, _, _ := p.scan(); tok == rparen {
		fn := &Function{Name: name}
		if err := fn.validate(); err != nil {
			return nil, err
		}
		return fn, nil
	}
	p.unscan()

	arg, err := p.ParseExpr()
	if err != nil {
		return nil, err
	}
	args = append(args, arg)

	// Parse additional function arguments if there is a comma.
	for {
		// If there's not a comma, stop parsing arguments.
		if tok, _, _ := p.scanIgnoreWhitespace(); tok != comma {
			p.unscan()
			break
		}

		// Parse an expression argument.
		arg, err := p.ParseExpr()
		if err != nil {
			return nil, err
		}
		args = append(args, arg)
	}

	// There should be a right parentheses at the end.
	if tok, pos, lit := p.scan(); tok != rparen {
		return nil, newParseError(tokstr(tok, lit), []string{")"}, pos, p.expr)
	}

	fn := &Function{Name: name, Args: args}

	if err := fn.validate(); err != nil {
		return nil, err
	}

	return fn, nil
}

// scan returns the next token from the underlying scanner.
func (p *Parser) scan() (tok token, pos int, lit string) { return p.s.scan() }

// scanIgnoreWhitespace scans the next non-whitespace.
func (p *Parser) scanIgnoreWhitespace() (tok token, pos int, lit string) {
	for {
		tok, pos, lit = p.scan()
		if tok == ws {
			continue
		}
		return
	}
}

// unscan pushes the previously read token back onto the buffer.
func (p *Parser) unscan() { p.s.unscan() }

```

`pkg/filter/ql/parser_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"errors"
	"testing"
)

func TestParser(t *testing.T) {
	var tests = []struct {
		expr string
		err  error
	}{
		{expr: "ps.name = 'cmd.exe'"},
		{expr: "ps.name != 'cmd.exe'"},
		{expr: "ps.name <> 'cmd.exe'"},
		{expr: "ps.name <> 'cmd.exe", err: errors.New("ps.name <> 'cmd.exe\n" +
			"           ^ expected field, string, number, bool, ip")},
		{expr: "ps.name = 123"},
		{expr: "net.dip = 172.17.0.9"},
		{expr: "net.dip = 172.17.0.9 and net.dip in ('172.15.9.2')"},
		{expr: "net.dip = 172.17.0.9 and (net.dip not in ('172.15.9.2'))"},

		{expr: "net.dip = 172.17.0", err: errors.New("net.dip = 172.17.0\n" +
			"           ^ expected a valid IP address")},

		{expr: "ps.name = 'cmd.exe' OR ps.name contains 'svc'"},
		{expr: "ps.name = 'cmd.exe' AND (ps.name contains 'svc' OR ps.name != 'lsass')"},
		{expr: "ps.name = 'cmd.exe' AND (ps.name contains 'svc' OR ps.name != 'lsass'", err: errors.New("ps.name = 'cmd.exe' AND (ps.name contains 'svc' OR ps.name != 'lsass'" +
			"^ expected")},

		{expr: "ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass') AND ps.ppid != 1)"},

		{expr: "ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass' AND ps.ppid != 1)", err: errors.New("ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass' AND ps.ppid != 1)" +
			"	^ expected )")},

		{expr: "ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass') AND ps.ppid != 1", err: errors.New("ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass') AND ps.ppid != 1" +
			"	^ expected )")},

		{expr: "ps.none = 'cmd.exe'", err: errors.New("ps.none = 'cmd.exe'" +
			"	^ expected field, string, number, bool, ip")},

		{expr: "ps.name = 'cmd.exe' AND ps.name IN ('exe') ps.name", err: errors.New("ps.name = 'cmd.exe' AND ps.name IN ('exe') ps.name" +
			"	^ expected operator")},
		{expr: "ip_cidr(net.dip) = '24'", err: errors.New("ip_cidr function is undefined. Did you mean one of CIDR_CONTAINS|MD5?")},

		{expr: "ps.name = 'cmd.exe' and not cidr_contains(net.sip, '172.14.0.0')"},
	}

	for i, tt := range tests {
		p := NewParser(tt.expr)
		_, err := p.ParseExpr()
		if err == nil && tt.err != nil {
			t.Errorf("%d. exp=%s expected error=%v", i, tt.expr, tt.err)
		} else if err != nil && tt.err == nil {
			t.Errorf("%d. exp=%s got error=%v", i, tt.expr, err)
		}
	}
}

```

`pkg/filter/ql/token.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"regexp"
	"strings"
)

// token represents the lexical token of the filter expression
type token int

const (
	illegal token = iota
	ws
	eof

	field          // ps.name
	str            // 'cmd.exe'
	patternBinding // $1.ps.name
	badstr
	badesc
	ident
	dec      // 123.3
	integer  // 123
	duration // 13h
	ip       // 192.168.1.23
	badip    // 192.156.300.12
	truet    // true
	falset   // false

	opBeg
	and         // and
	or          // or
	in          // in
	iin         // iin
	not         // not
	contains    // contains
	icontains   // icontains
	istartswith // istartswith
	startswith  // startswith
	endswith    // endswith
	iendswith   // iendswith
	matches     // matches
	imatches    // imatches
	fuzzy       // fuzzy
	ifuzzy      // ifuzzy
	fuzzynorm   // fuzzynorm
	ifuzzynorm  // ifuzzynorm
	eq          // =
	neq         // !=
	lt          // <
	lte         // <=
	gt          // >
	gte         // >=
	opEnd

	lparen // (
	rparen // )
	comma  // ,
	dot    // .
)

var keywords map[string]token

func init() {
	keywords = make(map[string]token)
	for _, tok := range []token{and, or, contains, icontains, in,
		iin, not, startswith, istartswith, endswith, iendswith,
		matches, imatches, fuzzy, ifuzzy, fuzzynorm, ifuzzynorm} {
		keywords[strings.ToLower(tokens[tok])] = tok
	}
	keywords["true"] = truet
	keywords["false"] = falset
}

var tokens = [...]string{
	illegal: "ILLEGAL",
	eof:     "EOF",
	ws:      "WS",

	ident:          "IDENT",
	field:          "FIELD",
	patternBinding: "PATTERNBINDING",
	integer:        "INTEGER",
	dec:            "DECIMAL",
	duration:       "DURATION",
	str:            "STRING",
	badstr:         "BADSTRING",
	badesc:         "BADESCAPE",
	ip:             "IPADDRESS",
	badip:          "BADIPADDRESS",
	truet:          "TRUE",
	falset:         "FALSE",

	and:         "AND",
	or:          "OR",
	contains:    "CONTAINS",
	icontains:   "ICONTAINS",
	in:          "IN",
	iin:         "IIN",
	not:         "NOT",
	startswith:  "STARTSWITH",
	istartswith: "ISTARTSWITH",
	endswith:    "ENDSWITH",
	iendswith:   "IENDSWITH",
	matches:     "MATCHES",
	imatches:    "IMATCHES",
	fuzzy:       "FUZZY",
	ifuzzy:      "IFUZZY",
	fuzzynorm:   "FUZZYNORM",
	ifuzzynorm:  "IFUZZYNORM",

	eq:  "=",
	neq: "!=",
	lt:  "<",
	lte: "<=",
	gt:  ">",
	gte: ">=",

	lparen: "(",
	rparen: ")",
	comma:  ",",
	dot:    ".",
}

// isOperator determines whether the current token is an operator.
func (tok token) isOperator() bool { return tok > opBeg && tok < opEnd }

// String returns the string representation of the token.
func (tok token) String() string {
	if tok >= 0 && tok < token(len(tokens)) {
		return tokens[tok]
	}
	return ""
}

// precedence returns the operator precedence of the binary operator token.
func (tok token) precedence() int {
	switch tok {
	case or:
		return 1
	case and:
		return 2
	case not:
		return 3
	case eq, neq, lt, lte, gt, gte:
		return 4
	case in, iin, contains, icontains, startswith, istartswith, endswith, iendswith,
		matches, imatches, fuzzy, ifuzzy, fuzzynorm, ifuzzynorm:
		return 5
	}
	return 0
}

func tokstr(tok token, lit string) string {
	if lit != "" {
		return lit
	}
	return tok.String()
}

// parsePatternBinding parses the pattern binding token and
// returns true if the provided id is a pattern binding. Returns
// false otherwise.
func parsePatternBinding(id string) (string, bool) {
	//nolint:gosimple
	matches := regexp.MustCompile("\\$[1-9]\\.([a-z0-9A-Z\\[\\].]+)").FindStringSubmatch(id)
	if len(matches) > 0 {
		return matches[1], true
	}
	return "", false
}

// lookup returns the token associated with a given string.
func lookup(id string) (token, string) {
	if tok, ok := keywords[strings.ToLower(id)]; ok {
		return tok, ""
	}
	pb, ok := parsePatternBinding(id)
	if ok {
		if tok := fields.Lookup(pb); tok != "" {
			return patternBinding, id
		}
	}
	if tok := fields.Lookup(id); tok != "" {
		return field, id
	}
	return ident, id
}

```

`pkg/filter/ql/visitor.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

// Visitor can be called by Walk to traverse an AST hierarchy.
// The Visit() function is called once per node.
type Visitor interface {
	Visit(Node) Visitor
}

// Walk traverses a node hierarchy in depth-first order.
func Walk(v Visitor, node Node) {
	if node == nil {
		return
	}
	if v = v.Visit(node); v == nil {
		return
	}
	switch n := node.(type) {
	case *BinaryExpr:
		Walk(v, n.LHS)
		Walk(v, n.RHS)
	case *NotExpr:
		Walk(v, n.Expr)
	case *Function:
		for _, expr := range n.Args {
			Walk(v, expr)
		}
	case *ParenExpr:
		Walk(v, n.Expr)
	}
}

// WalkFunc traverses a node hierarchy in depth-first order.
func WalkFunc(node Node, fn func(Node)) {
	Walk(walkFuncVisitor(fn), node)
}

type walkFuncVisitor func(Node)

func (fn walkFuncVisitor) Visit(n Node) Visitor { fn(n); return fn }

```

`pkg/filter/rules.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"bytes"
	"context"
	"encoding/base64"
	"errors"
	"expvar"
	"fmt"
	fsm "github.com/qmuntal/stateless"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/util/atomic"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter/funcmap"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	log "github.com/sirupsen/logrus"
)

// maxOutstandingPartials determines the maximum number of partials per sequence index
const maxOutstandingPartials = 1000

var (
	excludeOrFilterMatches    = expvar.NewMap("filter.exclude.or.matches")
	excludeAndFilterMatches   = expvar.NewMap("filter.exclude.and.matches")
	includeOrFilterMatches    = expvar.NewMap("filter.include.or.matches")
	includeAndFilterMatches   = expvar.NewMap("filter.include.and.matches")
	filterGroupsCount         = expvar.NewInt("filter.groups.count")
	filterGroupsCountByPolicy = expvar.NewMap("filter.groups.count.policy")
	filtersCount              = expvar.NewInt("filter.filters.count")

	matchTransitionErrors = expvar.NewInt("sequence.match.transition.errors")
	partialsPerSequence   = expvar.NewMap("sequence.partials.count")
	partialExpirations    = expvar.NewMap("sequence.partial.expirations")

	ErrInvalidFilter = func(rule, group string, err error) error {
		return fmt.Errorf("invalid filter %q in %q group: \n%v", rule, group, err)
	}
	ErrInvalidPatternBinding = func(rule string) error {
		return fmt.Errorf("%q is the initial sequence rule and can't contain pattern bindings", rule)
	}
)

var (
	// sequenceTerminalState represents the final state in the FSM.
	// This state is transitioned when the last rule in the group
	// produces a match
	sequenceTerminalState = fsm.State("terminal")
	// sequenceDeadlineState represents the state to which other
	// states transition if the rule's max span is reached
	sequenceDeadlineState = fsm.State("deadline")
	// sequenceExpiredState designates the state to which other
	// states transition when the sequence is expired
	sequenceExpiredState = fsm.State("expired")

	// transitions for match, cancel, reset, and expire triggers
	matchTransition  = fsm.Trigger("match")
	cancelTransition = fsm.Trigger("cancel")
	resetTransition  = fsm.Trigger("reset")
	expireTransition = fsm.Trigger("expire")
)

// Rules stores the compiled filter groups
// and for each incoming event, it applies
// the corresponding filtering policies to
// the event, dropping the event or passing
// it accordingly. If the filter rule has
// an action, the former is executed when the
// rule fires.
type Rules struct {
	filterGroups   map[uint32]filterGroups
	sequences      map[string]*sequenceState
	sequenceGroups []*filterGroup
	config         *config.Config
}

type filterGroup struct {
	group   config.FilterGroup
	filters []compiledFilter
}

type compiledFilter struct {
	filter Filter
	config *config.FilterConfig
}

// sequenceState represents the state of the
// ordered sequence of multiple events that
// may have time-frame constraints. A deterministic
// finite state machine tracks the matching status of
// each rule (state) in the machine.
type sequenceState struct {
	name string

	// partials keeps the state of all matched events per rule index
	partials map[uint16][]*kevent.Kevent
	// matches stores only the event that matched
	// the upstream partials. These events will be propagated
	// in the rule action context
	matches map[uint16]*kevent.Kevent
	// bindingIndexes keeps a mapping of binding indexes per rule index
	bindingIndexes map[uint16]uint16

	fsm *fsm.StateMachine

	// rule to rule index mapping
	idxs          map[fsm.State]uint16
	maxSpans      map[fsm.State]time.Duration
	spanDeadlines map[fsm.State]*time.Timer
	inDeadline    atomic.Bool
	inExpired     bool
	initialState  fsm.State

	// matchedRules keeps the mapping between rule indexes and
	// their matches.
	matchedRules map[uint16]bool
}

func newSequenceState(name, initialState string) *sequenceState {
	ss := &sequenceState{
		name:           name,
		partials:       make(map[uint16][]*kevent.Kevent),
		matchedRules:   make(map[uint16]bool),
		matches:        make(map[uint16]*kevent.Kevent),
		idxs:           make(map[fsm.State]uint16),
		bindingIndexes: make(map[uint16]uint16),
		maxSpans:       make(map[fsm.State]time.Duration),
		spanDeadlines:  make(map[fsm.State]*time.Timer),
		initialState:   fsm.State(initialState),
		inDeadline:     atomic.MakeBool(false),
	}

	ss.initFSM(initialState)

	return ss
}

func (s *sequenceState) initFSM(initialState string) {
	s.fsm = fsm.NewStateMachine(initialState)
	s.fsm.OnTransitioned(func(ctx context.Context, transition fsm.Transition) {
		// schedule span deadline for the current state
		if dur, ok := s.maxSpans[s.currentState()]; ok {
			log.Debugf("scheduling max span deadline of %v for rule %s", dur, s.currentState())
			s.scheduleMaxSpanDeadline(s.currentState(), dur)
		}
		// if the sequence was deadlined/expired, we can disable the deadline
		// status when the first rule in the sequence is reevaluated
		if transition.Source == s.initialState && s.inDeadline.Load() {
			s.inDeadline.Store(false)
		}
		if transition.Source == s.initialState && s.inExpired {
			s.inExpired = false
		}
		// clear state in case of expire/deadline transitions
		if transition.Trigger == cancelTransition ||
			transition.Trigger == expireTransition {
			s.clear()
		}
		if transition.Trigger == matchTransition {
			log.Debugf("state trigger from rule [%s]", transition.Source)
			// a match occurred from current to next state.
			// Stop deadline execution for the old current state
			if span, ok := s.spanDeadlines[transition.Source]; ok {
				log.Debugf("stopped max span deadline for rule %s", transition.Source)
				span.Stop()
				delete(s.spanDeadlines, transition.Source)
			}
			// save rule match
			s.matchedRules[s.idxs[transition.Source]] = true
		}
	})
}

func (s *sequenceState) matchTransition(rule string, kevt *kevent.Kevent) error {
	shouldFire := !s.matchedRules[s.idxs[rule]]
	if shouldFire {
		return s.fsm.Fire(matchTransition, kevt)
	}
	return nil
}

func (s *sequenceState) cancelTransition(rule fsm.State) error {
	return s.fsm.Fire(cancelTransition, rule)
}

func (s *sequenceState) expireTransition() error {
	return s.fsm.Fire(expireTransition)
}

func (s *sequenceState) isTerminalState() bool {
	isFinal := s.currentState() == sequenceTerminalState
	if isFinal {
		err := s.fsm.Fire(resetTransition)
		if err != nil {
			log.Warnf("unable to transition to initial state: %v", err)
		}
	}
	return isFinal
}

func (s *sequenceState) isInitialState() bool {
	return s.currentState() == s.initialState
}

func (s *sequenceState) currentState() fsm.State {
	return s.fsm.MustState()
}

func (s *sequenceState) addPartial(rule string, kevt *kevent.Kevent) {
	if len(s.partials[s.idxs[rule]]) > maxOutstandingPartials {
		log.Warnf("max partials encountered in sequence %s index %d. "+
			"Dropping incoming partial", s.name, s.idxs[rule])
		return
	}
	if len(s.bindingIndexes) > 0 {
		log.Debugf("adding partial to slot [%d] for rule %q: %s", s.idxs[rule], rule, kevt)
		partialsPerSequence.Add(s.name, 1)
		s.partials[s.idxs[rule]] = append(s.partials[s.idxs[rule]], kevt)
	}
}

func (s *sequenceState) addMatch(idx uint16, kevt *kevent.Kevent) {
	s.matches[idx] = kevt
}

func (s *sequenceState) getPartials(rule string) map[uint16][]*kevent.Kevent {
	i := s.idxs[rule] - 1
	// is this is the first rule in the sequence
	// return no partials
	if i == 0 {
		return nil
	}
	// next rules in the sequence contain partials
	// of their upstream rule. For example, if there
	// are two rules in the sequence, the partials map
	// will contain an index from rule 1 to all of its
	// partials
	if len(s.partials[i]) > 0 {
		partials := make(map[uint16][]*kevent.Kevent)
		partials[i] = s.partials[i]
		return partials
	}
	return nil
}

func (s *sequenceState) clear() {
	s.partials = make(map[uint16][]*kevent.Kevent)
	s.matches = make(map[uint16]*kevent.Kevent)
	s.matchedRules = make(map[uint16]bool)
	s.spanDeadlines = make(map[fsm.State]*time.Timer)
	partialsPerSequence.Delete(s.name)
}

// next determines whether the next rule in the
// sequence should be evaluated. The rule is evaluated
// if its upstream sequence rule produced a match and
// the sequence is not stuck in deadline or expired state.
func (s *sequenceState) next(i int) bool {
	// always evaluate the first rule in the sequence
	if i == 0 {
		return true
	}
	return s.matchedRules[uint16(i)] && !s.inDeadline.Load() && !s.inExpired
}

func (s *sequenceState) scheduleMaxSpanDeadline(rule fsm.State, maxSpan time.Duration) {
	t := time.AfterFunc(maxSpan, func() {
		inState, _ := s.fsm.IsInState(rule)
		if inState {
			log.Infof("max span of %v exceded for rule %s", maxSpan, rule)
			s.inDeadline.Store(true)
			// transitions to deadline state
			err := s.cancelTransition(rule)
			if err != nil {
				s.inDeadline.Store(false)
				log.Warnf("deadline transition failed: %v", err)
			}
			// transitions from deadline state to initial state
			err = s.fsm.Fire(resetTransition)
			if err != nil {
				log.Warnf("unable to transition to initial state: %v", err)
			}
		}
	})
	s.spanDeadlines[rule] = t
}

func (s *sequenceState) expire(e *kevent.Kevent) bool {
	if e.Type != ktypes.TerminateProcess {
		return false
	}
	canExpire := func(lhs, rhs *kevent.Kevent) bool {
		if lhs.Type == ktypes.CreateProcess {
			p1, _ := lhs.Kparams.GetPid()
			p2, _ := rhs.Kparams.GetPid()
			return p1 == p2
		}
		return lhs.PID == rhs.PID
	}
	for _, idx := range s.idxs {
		currentPartials := s.partials[idx]
		for i, e1 := range currentPartials {
			if !canExpire(e1, e) {
				continue
			}
			// if downstream rule didn't match, and it contains
			// a binding index to the previous rule in the sequence
			// whose condition is referencing a CreateProcess event
			// for which we just got the termination event, it is
			// safe to expire all pending partials and dispose
			// the state
			matched := s.matchedRules[idx+1]
			bindingIndex := s.bindingIndexes[idx+1]
			if !matched && bindingIndex == idx {
				log.Debugf("removing process %s (%d) "+
					"from partials pertaining to sequence [%s]",
					e.Kparams.MustGetString(kparams.ProcessName),
					e.Kparams.MustGetPid(),
					s.name)
				s.partials[idx] = append(
					s.partials[idx][:i],
					s.partials[idx][i+1:]...)
				partialsPerSequence.Add(s.name, -1)

				if len(s.partials[idx]) == 0 {
					log.Infof("%q sequence expired. All partials terminated", s.name)
					partialExpirations.Add(s.name, 1)
					s.inExpired = true
					err := s.expireTransition()
					if err != nil {
						s.inExpired = false
						log.Warnf("expire transition failed: %v", err)
					}
					// transitions from expired state to initial state
					err = s.fsm.Fire(resetTransition)
					if err != nil {
						log.Warnf("unable to transition to initial state: %v", err)
					}
					return true
				}
			}
		}
	}
	return false
}

func newFilterGroup(g config.FilterGroup, filters []compiledFilter) *filterGroup {
	return &filterGroup{group: g, filters: filters}
}

func newCompiledFilter(f Filter, filterConfig *config.FilterConfig) compiledFilter {
	return compiledFilter{config: filterConfig, filter: f}
}

// run execute the filter and returns the matching partial index along with
// the partial event that produced a match.
func (f compiledFilter) run(kevt *kevent.Kevent, i uint16, partials map[uint16][]*kevent.Kevent) (bool, uint16, *kevent.Kevent) {
	if len(partials) > 0 {
		return f.filter.RunPartials(kevt, partials)
	}
	return f.filter.Run(kevt), i, kevt
}

type filterGroups []*filterGroup

func (groups filterGroups) hasIncludePolicy(kevt *kevent.Kevent) bool {
	for _, g := range groups {
		if g.group.Selector.Type == kevt.Type ||
			g.group.Selector.Category == kevt.Category {
			if g.group.Policy == config.IncludePolicy {
				return true
			}
		}
	}
	return false
}

func (r *Rules) hasSequencePolicy() bool { return len(r.sequenceGroups) > 0 }

// NewRules produces a fresh rules instance.
func NewRules(c *config.Config) Rules {
	rules := Rules{
		filterGroups:   make(map[uint32]filterGroups),
		sequences:      make(map[string]*sequenceState),
		sequenceGroups: make([]*filterGroup, 0),
		config:         c,
	}
	return rules
}

func expr(c *config.FilterConfig) string {
	if c.Condition != "" {
		return c.Condition
	}
	return c.Def
}

// Compile loads the filter groups from all files
// and creates the filters for each filter group.
func (r *Rules) Compile() error {
	groups, err := r.config.Filters.LoadGroups()
	if err != nil {
		return err
	}
	for _, group := range groups {
		if group.IsDisabled() {
			log.Warnf("rule group [%s] disabled", group.Name)
			continue
		}
		log.Infof("loading rule group [%s]", group.Name)
		rules := append(group.Rules, group.FromStrings...)
		if group.Policy != config.SequencePolicy &&
			group.Action != "" {
			return fmt.Errorf("%s: only sequence policies can have top level actions", group.Name)
		}
		if group.Policy == config.SequencePolicy &&
			len(rules) <= 1 {
			return fmt.Errorf("%s: policy requires at least two rules", group.Name)
		}

		filterGroupsCount.Add(1)
		filterGroupsCountByPolicy.Add(group.Policy.String(), 1)

		// compile filters and populate the groups. Additionally, for
		// sequence policies we have to configure the FSM states and
		// transitions.
		if len(rules) == 0 {
			panic("got empty rules")
		}
		initialState := rules[0].Name
		seqState := newSequenceState(group.Name, initialState)
		filters := make([]compiledFilter, 0, len(rules))

		for i, filterConfig := range rules {
			rule := filterConfig.Name
			f := New(expr(filterConfig), r.config)
			if err := f.Compile(); err != nil {
				return ErrInvalidFilter(rule, group.Name, err)
			}
			// setup finite state machine states. The last rule
			// in the sequence transitions to the terminal state
			// if all rules match
			if group.Policy == config.SequencePolicy {
				seqState.idxs[rule] = uint16(i + 1)
				bindingID, ok := f.BindingIndex()
				if ok {
					if i == 0 {
						return ErrInvalidPatternBinding(rule)
					}
					seqState.bindingIndexes[uint16(i+1)] = bindingID
				}
				// set maximum span deadline
				if filterConfig.MaxSpan != 0 {
					seqState.maxSpans[rule] = filterConfig.MaxSpan
				}
				if i >= len(rules)-1 {
					seqState.fsm.Configure(rule).
						Permit(matchTransition, sequenceTerminalState).
						Permit(cancelTransition, sequenceDeadlineState).
						Permit(expireTransition, sequenceExpiredState)
				} else {
					seqState.fsm.Configure(rule).
						Permit(matchTransition, rules[i+1].Name).
						Permit(cancelTransition, sequenceDeadlineState).
						Permit(expireTransition, sequenceExpiredState)
				}
			}
			filters = append(filters, newCompiledFilter(f, filterConfig))
			filtersCount.Add(1)
		}

		// initialize filter groups
		fg := newFilterGroup(group, filters)

		switch group.Policy {
		case config.ExcludePolicy, config.IncludePolicy:
			// compute the hash depending on whether the type or category
			// is given in the group selector. For sequence group policies
			// we don't really care about the selector because these groups
			// must attract all event types. In this case the hash is the
			// filter group hash.
			hash := group.Selector.Hash()
			r.filterGroups[hash] = append(r.filterGroups[hash], fg)
		case config.SequencePolicy:
			// configure reset transitions that are triggered
			// when the final state is reached of when a deadline
			// or sequence expiration happens
			seqState.fsm.Configure(sequenceTerminalState).Permit(resetTransition, initialState)
			seqState.fsm.Configure(sequenceDeadlineState).Permit(resetTransition, initialState)
			seqState.fsm.Configure(sequenceExpiredState).Permit(resetTransition, initialState)

			r.sequences[group.Name] = seqState
			r.sequenceGroups = append(r.sequenceGroups, fg)
		}
	}
	return nil
}

func (r *Rules) findFilterGroups(kevt *kevent.Kevent) filterGroups {
	groups1 := r.filterGroups[kevt.Type.Hash()]
	groups2 := r.filterGroups[kevt.Category.Hash()]
	if groups1 == nil && groups2 == nil {
		return r.sequenceGroups
	}
	if len(r.sequenceGroups) > 0 {
		return append(groups1, append(groups2, r.sequenceGroups...)...)
	}
	return append(groups1, groups2...)
}

func (r *Rules) Fire(kevt *kevent.Kevent) bool {
	// if there are no filter groups we assume no group files were
	// defined or specified in the config, so, the default behaviour
	// in such cases is to pass the event and hand over it to the CLI
	// filter
	if len(r.filterGroups) == 0 && len(r.sequenceGroups) == 0 {
		return true
	}
	// find filter groups for a particular event type, category or
	// sequence groups. Events are dropped by default if no groups
	// are found
	groups := r.findFilterGroups(kevt)
	if len(groups) == 0 {
		return false
	}
	// exclude policies take precedence over
	// groups with include policies, so we first
	// evaluate those. If no filter matches occur,
	// we let pass the event but only if there are
	// no groups with include/sequence policies
	ok := r.runRules(groups, config.ExcludePolicy, kevt)
	if ok {
		return false
	}

	if !groups.hasIncludePolicy(kevt) && !r.hasSequencePolicy() {
		return true
	}

	// apply include policies. At this point none of
	// the groups with exclude policies got matched
	ok = r.runRules(groups, config.IncludePolicy, kevt)
	if ok {
		return true
	}

	// finally, evaluate sequence policies
	return r.runRules(groups, config.SequencePolicy, kevt)
}

func (r *Rules) runRules(groups filterGroups, policy config.FilterGroupPolicy, kevt *kevent.Kevent) bool {
nextGroup:
	for _, g := range groups {
		if g.group.Policy != policy {
			continue
		}
		// sequence policies leverage stateful event tracking.
		// All rules in the sequence have to match in order to
		// promote the group.
		if g.group.Policy == config.SequencePolicy {
			seqState := r.sequences[g.group.Name]
			if seqState == nil {
				continue
			}
			// if the sequence expired we'll not keep evaluating
			if seqState.expire(kevt) {
				return false
			}
			for i, f := range g.filters {
				if !seqState.next(i) {
					continue
				}
				rule := f.config.Name
				ok, idx, e := f.run(kevt, uint16(i+1), seqState.getPartials(rule))
				if ok {
					seqState.addPartial(rule, kevt)
					err := seqState.matchTransition(rule, kevt)
					if err != nil {
						matchTransitionErrors.Add(1)
						log.Warnf("match transition: %v", err)
					}
					seqState.addMatch(uint16(i+1), kevt)
					seqState.addMatch(idx, e)
				}
			}
			done := seqState.isTerminalState()
			if done {
				log.Debugf("rule group [%s] matched", g.group.Name)
				// this is the event that triggered the group match
				kevt.AddMeta(kevent.RuleGroupKey, g.group.Name)
				err := runFilterAction(nil, seqState.matches, g.group, nil)
				if err != nil {
					log.Warnf("unable to execute %q sequence action: %v", g.group.Name, err)
				}
				seqState.clear()
			}
			return done
		}
		var andMatched bool
		// process include/exclude filter groups. Each of them
		// may have `or` or `and` relation types to promote the
		// group upon first match or either all rules in the group
		// need to match
		for i, f := range g.filters {
			ok, _, _ := f.run(kevt, uint16(i+1), nil)

			switch g.group.Policy {
			case config.ExcludePolicy:
				switch g.group.Relation {
				case config.OrRelation:
					if ok {
						excludeOrFilterMatches.Add(f.config.Name, 1)
						return true
					}
				case config.AndRelation:
					if !ok {
						// jump to the next exclude group
						continue nextGroup
					}
					andMatched = true
				}
			case config.IncludePolicy:
				switch g.group.Relation {
				case config.OrRelation:
					if ok {
						includeOrFilterMatches.Add(f.config.Name, 1)
						log.Debugf("rule [%s] in group [%s] matched", f.config.Name, g.group.Name)
						err := runFilterAction(kevt, nil, g.group, f.config)
						if err != nil {
							log.Warnf("unable to execute %q rule action: %v", f.config.Name, err)
						}
						// attach rule and group meta
						kevt.AddMeta(kevent.RuleNameKey, f.config.Name)
						kevt.AddMeta(kevent.RuleGroupKey, g.group.Name)
						return true
					}
				case config.AndRelation:
					if !ok {
						// jump to the next include group
						continue nextGroup
					}
					andMatched = true
				}
			}
		}
		// got a match on the `and` relation group
		if andMatched {
			switch g.group.Policy {
			case config.ExcludePolicy:
				for _, f := range g.filters {
					excludeAndFilterMatches.Add(f.config.Name, 1)
				}
			case config.IncludePolicy:
				for _, f := range g.filters {
					includeAndFilterMatches.Add(f.config.Name, 1)
					log.Debugf("rule [%s] in group [%s] matched", f.config.Name, g.group.Name)
					err := runFilterAction(kevt, nil, g.group, f.config)
					if err != nil {
						log.Warnf("unable to execute %q rule action: %v", f.config.Name, err)
					}
				}
			}
			return true
		}
	}

	return false
}

// ActionContext is the convenient structure
// for grouping the event that resulted in
// matched filter along with filter group
// information.
type ActionContext struct {
	Kevt   *kevent.Kevent
	Kevts  map[string]*kevent.Kevent
	Filter *config.FilterConfig
	Group  config.FilterGroup
}

// runFilterAction executes the template associated with the filter
// that has produced a match in one of the include groups.
func runFilterAction(
	kevt *kevent.Kevent,
	kevts map[uint16]*kevent.Kevent,
	group config.FilterGroup,
	filter *config.FilterConfig,
) error {
	if (filter != nil && filter.Action == "") && group.Action == "" {
		return nil
	}
	var action []byte
	var err error
	if group.Policy == config.SequencePolicy {
		action, err = base64.StdEncoding.DecodeString(group.Action)
	} else {
		if filter == nil {
			panic("filter shouldn't be nil")
		}
		action, err = base64.StdEncoding.DecodeString(filter.Action)
	}
	if err != nil {
		return fmt.Errorf("corrupted filter/group action: %v", err)
	}

	fmap := funcmap.New()
	funcmap.InitFuncs(fmap)
	tmpl, err := template.New(group.Name).Funcs(fmap).Parse(string(action))
	if err != nil {
		return err
	}

	matches := make(map[string]*kevent.Kevent, len(kevts))
	for k, v := range kevts {
		matches["k"+strconv.Itoa(int(k))] = v
	}

	ctx := &ActionContext{
		Kevt:   kevt,
		Kevts:  matches,
		Filter: filter,
		Group:  group,
	}

	var bb bytes.Buffer
	if err := tmpl.Execute(&bb, ctx); err != nil {
		return err
	}
	if strings.TrimSpace(bb.String()) != "" {
		return errors.New(bb.String())
	}
	return nil
}

```

`pkg/filter/rules_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"github.com/rabbitstack/fibratus/pkg/fs"
	log "github.com/sirupsen/logrus"
	"net"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type mockSender struct{}

var emitAlert *alertsender.Alert

func (s *mockSender) Send(a alertsender.Alert) error {
	emitAlert = &a
	return nil
}

func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	return &mockSender{}, nil
}

func init() {
	alertsender.Register(alertsender.Noop, makeSender)
}

func fireRules(t *testing.T, c *config.Config) bool {
	rules := NewRules(c)

	kevt := &kevent.Kevent{
		Type: ktypes.Recv,
		Name: "Recv",
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[kevent.MetadataKey]string),
	}

	require.NoError(t, rules.Compile())
	return rules.Fire(kevt)
}

func newConfig(fromFiles ...string) *config.Config {
	var kstreamConfig = config.KstreamConfig{
		EnableHandleKevents:   true,
		EnableNetKevents:      true,
		EnableRegistryKevents: true,
		EnableFileIOKevents:   true,
		EnableImageKevents:    true,
		EnableThreadKevents:   true,
	}
	c := &config.Config{
		Kstream: kstreamConfig,
		Filters: &config.Filters{
			Rules: config.Rules{
				FromPaths: fromFiles,
			},
		},
	}
	return c
}

func TestChainCompileMergeGroups(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/merged_groups.yml"))
	require.NoError(t, rules.Compile())

	assert.Len(t, rules.filterGroups, 2)
	assert.Len(t, rules.filterGroups[ktypes.Recv.Hash()], 2)
	assert.Len(t, rules.filterGroups[ktypes.Net.Hash()], 1)

	groups := rules.findFilterGroups(&kevent.Kevent{Type: ktypes.Recv, Category: ktypes.Net})
	assert.Len(t, groups, 3)
}

func TestChainCompileGroupsOnlyTypeSelector(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/groups_type_selector.yml"))
	require.NoError(t, rules.Compile())

	assert.Len(t, rules.filterGroups, 1)
	assert.Len(t, rules.filterGroups[ktypes.Recv.Hash()], 3)

	groups := rules.findFilterGroups(&kevent.Kevent{Type: ktypes.Recv})
	assert.Len(t, groups, 3)
}

func TestFireRules(t *testing.T) {
	var tests = []struct {
		config  *config.Config
		matches bool
	}{
		{newConfig("_fixtures/exclude_policy_or.yml"), false},
		{newConfig("_fixtures/exclude_policy_and.yml"), false},
		{newConfig("_fixtures/exclude_policy_or_no_include_groups.yml"), true},
		{newConfig("_fixtures/exclude_policy_and_no_include_groups.yml"), true},
		{newConfig("_fixtures/exclude_policy_or_different_include_group.yml"), true},
		{newConfig("_fixtures/include_policy_or.yml"), true},
		{newConfig("_fixtures/include_policy_and.yml"), true},
		{newConfig("_fixtures/include_policy_and_not_matches.yml"), false},
	}

	for i, tt := range tests {
		matches := fireRules(t, tt.config)
		if matches != tt.matches {
			t.Errorf("%d. %v filter chain mismatch: exp=%t got=%t", i, tt.config.Filters, tt.matches, matches)
		}
	}
}

func TestIncludeExcludeRemoteThreads(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/include_exclude_remote_threads.yml"))
	require.NoError(t, rules.Compile())

	kevt := &kevent.Kevent{
		Type: ktypes.CreateThread,
		Name: "CreateThread",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Exe: "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(4143)},
		},
	}

	require.False(t, rules.Fire(kevt))
}

func TestSequenceState(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/sequence_policy_simple_pattern_bindings.yml"))
	require.NoError(t, rules.Compile())
	log.SetLevel(log.DebugLevel)

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID:   {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(4143)},
			kparams.ProcessName: {Name: kparams.ProcessName, Type: kparams.AnsiString, Value: "powershell.exe"},
		},
	}
	kevt2 := &kevent.Kevent{
		Type: ktypes.CreateFile,
		Name: "CreateFile",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.FileName: {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
	}

	sequences := rules.sequences
	assert.Len(t, sequences, 1)
	ss := sequences["command shell execution and temp files"]

	require.NotNil(t, ss)

	assert.Equal(t, "spawn command shell", ss.currentState())
	assert.True(t, ss.isInitialState())
	assert.Equal(t, "spawn command shell", ss.initialState)

	ss.addPartial("spawn command shell", kevt1)
	require.NoError(t, ss.matchTransition("spawn command shell", kevt1))
	assert.False(t, ss.isInitialState())
	assert.Equal(t, "created temp file by command shell", ss.currentState())

	ss.addPartial("created temp file by command shell", kevt2)
	require.NoError(t, ss.matchTransition("created temp file by command shell", kevt2))

	assert.Len(t, ss.getPartials("spawn command shell"), 0)
	assert.Len(t, ss.getPartials("created temp file by command shell"), 1)

	assert.Equal(t, sequenceTerminalState, ss.currentState())
	assert.True(t, ss.isTerminalState())

	ss.clear()

	// reset transition leads back to initial state
	assert.Equal(t, "spawn command shell", ss.currentState())
	// deadline exceeded
	require.NoError(t, ss.matchTransition("spawn command shell", kevt1))
	assert.Equal(t, "created temp file by command shell", ss.currentState())
	time.Sleep(time.Millisecond * 120)
	assert.True(t, ss.isInitialState())

	require.True(t, ss.inDeadline.Load())
	require.False(t, ss.next(1))
	if ss.next(1) {
		// this shouldn't happen
		require.NoError(t, ss.matchTransition("created temp file by command shell", kevt2))
	}

	ss.clear()
	assert.True(t, ss.isInitialState())
	require.NoError(t, ss.matchTransition("spawn command shell", kevt1))
	ss.addPartial("spawn command shell", kevt1)
	require.False(t, ss.inDeadline.Load())

	// test expiration
	terminateProcess := &kevent.Kevent{
		Type: ktypes.TerminateProcess,
		Name: "TerminateProcess",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID:   {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(4143)},
			kparams.ProcessName: {Name: kparams.ProcessName, Type: kparams.AnsiString, Value: "powershell.exe"},
		},
	}

	require.True(t, ss.expire(terminateProcess))
	require.True(t, ss.inExpired)

	require.NoError(t, ss.matchTransition("spawn command shell", kevt1))
	require.False(t, ss.inExpired)

	assert.Equal(t, "created temp file by command shell", ss.currentState())
}

func TestSimpleSequencePolicy(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/sequence_policy_simple.yml"))
	require.NoError(t, rules.Compile())

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(4143)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}

	kevt2 := &kevent.Kevent{
		Type: ktypes.CreateFile,
		Name: "CreateFile",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.FileName: {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, rules.Fire(kevt1))
	require.True(t, rules.Fire(kevt2))
}

func TestSimpleSequencePolicyWithMaxSpanReached(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/sequence_policy_simple_max_span.yml"))
	require.NoError(t, rules.Compile())

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(4143)},
		},
	}

	kevt2 := &kevent.Kevent{
		Type: ktypes.CreateFile,
		Name: "CreateFile",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.FileName: {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, rules.Fire(kevt1))
	time.Sleep(time.Millisecond * 250)
	require.False(t, rules.Fire(kevt2))

	// now the state machine has transitioned
	// to the initial state, which means we should
	// be able to match the sequence if we reinsert
	// the events
	require.False(t, rules.Fire(kevt1))
	require.True(t, rules.Fire(kevt2))
}

func TestSimpleSequencePolicyWithMaxSpanNotReached(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/sequence_policy_simple_max_span.yml"))
	require.NoError(t, rules.Compile())

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(4143)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}

	kevt2 := &kevent.Kevent{
		Type: ktypes.CreateFile,
		Name: "CreateFile",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.FileName: {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, rules.Fire(kevt1))
	time.Sleep(time.Millisecond * 110)
	require.True(t, rules.Fire(kevt2))
}

func TestSimpleSequencePolicyPatternBindings(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/sequence_policy_simple_pattern_bindings.yml"))
	require.NoError(t, rules.Compile())

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.Uint32, Value: uint32(4143)},
		},
	}

	kevt2 := &kevent.Kevent{
		Type: ktypes.CreateFile,
		Name: "CreateFile",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Kparams: kevent.Kparams{
			kparams.FileName: {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, rules.Fire(kevt1))
	require.True(t, rules.Fire(kevt2))
}

func TestSequenceComplexPatternBindings(t *testing.T) {
	rules := NewRules(newConfig("_fixtures/sequence_policy_complex_pattern_bindings.yml"))
	require.NoError(t, rules.Compile())

	kevt1 := &kevent.Kevent{
		Seq:      1,
		Type:     ktypes.CreateProcess,
		Category: ktypes.Process,
		Name:     "CreateProcess",
		Tid:      2484,
		PID:      859,
		PS: &types.PS{
			Name: "explorer.exe",
			Exe:  "C:\\Windows\\system32\\explorer.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID:   {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(2243)},
			kparams.ProcessName: {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "firefox.exe"},
		},
	}

	kevt2 := &kevent.Kevent{
		Seq:  2,
		Type: ktypes.CreateFile,
		Name: "CreateFile",
		Tid:  2484,
		PID:  2243,
		PS: &types.PS{
			Name: "firefox.exe",
			Exe:  "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			Comm: "C:\\Program Files\\Mozilla Firefox\\firefox.exe\" -contentproc --channel=\"10464.7.539748228\\1366525930\" -childID 6 -isF",
		},
		Kparams: kevent.Kparams{
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.Enum, Value: fs.FileDisposition(2)},
		},
	}

	kevt3 := &kevent.Kevent{
		Seq:      3,
		Type:     ktypes.CreateProcess,
		Name:     "CreateProcess",
		Category: ktypes.Process,
		Tid:      244,
		PID:      1234,
		PS: &types.PS{
			Name: "explorer.exe",
			Exe:  "C:\\Windows\\system32\\explorer.exe",
		},
		Kparams: kevent.Kparams{
			kparams.ProcessID:   {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(4143)},
			kparams.ProcessName: {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "dropper.exe"},
			kparams.Exe:         {Name: kparams.Exe, Type: kparams.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
		},
	}

	kevt4 := &kevent.Kevent{
		Seq:      4,
		Type:     ktypes.Connect,
		Category: ktypes.Net,
		Name:     "Connect",
		Tid:      244,
		PID:      4143,
		PS: &types.PS{
			Name: "dropper.exe",
			Exe:  "C:\\Temp\\dropper.exe",
		},
		Kparams: kevent.Kparams{
			kparams.NetDIP: {Name: kparams.NetDIP, Type: kparams.IP, Value: net.ParseIP("10.0.2.3")},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}

	require.False(t, rules.Fire(kevt1))
	require.False(t, rules.Fire(kevt2))
	time.Sleep(time.Millisecond * 30)
	require.False(t, rules.Fire(kevt3))

	// at this point we should have
	// accumulated multiple matches
	matches := rules.sequences["phishing dropper outbound communication"].matches

	require.Len(t, matches, 3)
	assert.Equal(t, uint64(1), matches[1].Seq)
	assert.Equal(t, uint64(2), matches[2].Seq)
	assert.Equal(t, uint64(3), matches[3].Seq)

	time.Sleep(time.Millisecond * 22)

	// register alert sender
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.Noop}}))

	require.True(t, rules.Fire(kevt4))

	// check the format of the generated alert
	require.NotNil(t, emitAlert)
	assert.Equal(t, "Phishing dropper outbound communication", emitAlert.Title)
	assert.Equal(t, "dropper.exe process initiated outbound communication to 10.0.2.3", emitAlert.Text)
	emitAlert = nil

	matches = rules.sequences["phishing dropper outbound communication"].matches
	require.Len(t, matches, 0)

	// FSM should transition from terminal to initial state
	require.False(t, rules.Fire(kevt1))
	require.False(t, rules.Fire(kevt2))
	time.Sleep(time.Millisecond * 15)
	require.False(t, rules.Fire(kevt3))
	require.True(t, rules.Fire(kevt4))
}

func TestFilterActionEmitAlert(t *testing.T) {
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.Noop}}))
	rules := NewRules(newConfig("_fixtures/include_policy_emit_alert.yml"))
	require.NoError(t, rules.Compile())

	kevt := &kevent.Kevent{
		Type: ktypes.Recv,
		Name: "Recv",
		Tid:  2484,
		PID:  859,
		PS: &types.PS{
			Name: "cmd.exe",
		},
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[kevent.MetadataKey]string),
	}

	require.True(t, rules.Fire(kevt))

	require.NotNil(t, emitAlert)
	assert.Equal(t, "Test alert", emitAlert.Title)
	assert.Equal(t, "cmd.exe process received data on port 443", emitAlert.Text)
	assert.Equal(t, alertsender.Critical, emitAlert.Severity)
	assert.Equal(t, []string{"tag1", "tag2"}, emitAlert.Tags)
	emitAlert = nil
}

func BenchmarkChainRun(b *testing.B) {
	b.ReportAllocs()

	rules := NewRules(newConfig("_fixtures/default/default.yml"))
	require.NoError(b, rules.Compile())

	kevts := []*kevent.Kevent{
		{
			Type: ktypes.Connect,
			Name: "Recv",
			Tid:  2484,
			PID:  859,
			PS: &types.PS{
				Name: "cmd.exe",
			},
			Kparams: kevent.Kparams{
				kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
				kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
				kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
				kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
			Metadata: make(map[kevent.MetadataKey]string),
		},
		{
			Type: ktypes.CreateProcess,
			Name: "CreateProcess",
			Tid:  2484,
			PID:  859,
			PS: &types.PS{
				Name: "powershell.exe",
			},
			Kparams: kevent.Kparams{
				kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: 2323},
				kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
				kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
				kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
				kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
				kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
			},
			Metadata: make(map[kevent.MetadataKey]string),
		},
	}

	for i := 0; i < b.N; i++ {
		for _, kevt := range kevts {
			rules.Fire(kevt)
		}
	}
}

```

`pkg/fs/attrs.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

// FileAttr represents a type alias for the file attribute enumeration.
type FileAttr uint32

const (
	// FileReadOnly reprsents file that is read-only. Processes can read the file, but cannot write to it or delete it.
	// This attribute is not honored on directories.
	FileReadOnly FileAttr = 0x00000001
	// FileHidden designates a file or directory that is hidden, i.e. it is not included in an ordinary directory listing.
	FileHidden FileAttr = 0x00000002
	// FileSystem is a file or directory that the operating system uses a part of, or uses exclusively.
	FileSystem FileAttr = 0x00000004
	// FileOldDosVolID is unused
	FileOldDosVolID FileAttr = 0x00000008
	// FileDirectory indicates that the file is a directory.
	FileDirectory FileAttr = 0x00000010
	// FileArchive denotes a file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.
	FileArchive FileAttr = 0x00000020
	// FileDevice attribute is reserved for system use.
	FileDevice FileAttr = 0x00000040
	// FileNormal is a file that does not have other attributes set. This attribute is valid only when used alone.
	FileNormal FileAttr = 0x00000080
	// FileTemporary denotes files that are used for temporary storage.
	FileTemporary = 0x00000100
	// FileSparse denotes a sparse file. Spare files can optimize disk usage as the system does not allocate disk space for the file regions with sparse data.
	FileSparse = 0x00000200
	// FileReparsePoint represents a file or directory that has an associated reparse point, or a file that is a symbolic link.
	FileReparsePoint FileAttr = 0x00000400
	// FileCompressed represents a file or a directory that is compressed.
	FileCompressed FileAttr = 0x00000800
	// FileOffline represents data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage.
	FileOffline FileAttr = 0x00001000
	// FileNotContentIndexed is a file or directory is not to be indexed by the content indexing service.
	FileNotContentIndexed = 0x00002000
	// FileEncrypted represents a file or a directory that is encrypted
	FileEncrypted FileAttr = 0x00004000
	// FileIntegrityStream is the directory or user data stream is configured with integrity (only supported on ReFS volumes).
	// It is not included in an ordinary directory listing.
	FileIntegrityStream FileAttr = 0x00008000
	// FileVirtual is reserved for system use.
	FileVirtual FileAttr = 0x00010000
	// FileNoScrubData represents user data stream not to be read by the background data integrity scanner (AKA scrubber).
	// When set on a directory it only provides inheritance. This flag is only supported on Storage Spaces and ReFS volumes
	FileNoScrubData FileAttr = 0x00020000
	// FileRecallOpen attribute only appears in directory enumeration classes (FILE_DIRECTORY_INFORMATION,
	// FILE_BOTH_DIR_INFORMATION, etc.). When this attribute is set, it means that the file or directory has no physical
	// representation on the local system; the item is virtual
	FileRecallOpen FileAttr = 0x00040000
	// FileRecallAccess means that the file or directory is not fully present locally.
	// For a file that means that not all of its data is on local storage (e.g. it may be sparse with some data still in
	// remote storage). For a directory it means that some of the directory contents are being virtualized from another
	// location.
	FileRecallAccess FileAttr = 0x400000
	// FilePinned indicates user intent that the file or directory should be kept fully present locally
	// even when not being actively accessed. This attribute is for use with hierarchical storage management software.
	FilePinned FileAttr = 0x80000
	// FileUnpinned indicates that the file or directory should not be kept fully present locally except
	// when being actively accessed. This attribute is for use with hierarchical storage management software.
	FileUnpinned FileAttr = 0x100000
)

// FileAttr returns human-readable file attribute name.
func (fa FileAttr) String() string {
	switch fa {
	case FileReadOnly:
		return "readonly"
	case FileHidden:
		return "hidden"
	case FileSystem:
		return "system"
	case FileDirectory:
		return "directory"
	case FileArchive:
		return "archive"
	case FileCompressed:
		return "compressed"
	case FileEncrypted:
		return "encrypted"
	case FileReparsePoint:
		return "junction"
	case FileSparse:
		return "sparse"
	case FileTemporary:
		return "temporary"
	case FileDevice:
		return "device"
	case FileNormal:
		return "normal"
	case FileOffline:
		return "offline"
	case FileNotContentIndexed:
		return "unindexed"
	case FileIntegrityStream:
		return "stream"
	case FileVirtual:
		return "virtual"
	case FileNoScrubData:
		return "noscrub"
	case FileRecallOpen:
		return "recallopen"
	case FileRecallAccess:
		return "recallaccess"
	case FilePinned:
		return "pinned"
	case FileUnpinned:
		return "unpinned"
	default:
		return "unknown"
	}
}

// FileAttributes returns all the attributes present in the bitmask.
func FileAttributes(b uint32) []FileAttr {
	fa := make([]FileAttr, 0)
	a := FileAttr(b)
	if a&FileReadOnly != 0 {
		fa = append(fa, FileReadOnly)
	}
	if a&FileHidden != 0 {
		fa = append(fa, FileHidden)
	}
	if a&FileSystem != 0 {
		fa = append(fa, FileSystem)
	}
	if a&FileOldDosVolID != 0 {
		fa = append(fa, FileOldDosVolID)
	}
	if a&FileDirectory != 0 {
		fa = append(fa, FileDirectory)
	}
	if a&FileArchive != 0 {
		fa = append(fa, FileArchive)
	}
	if a&FileCompressed != 0 {
		fa = append(fa, FileCompressed)
	}
	if a&FileEncrypted != 0 {
		fa = append(fa, FileEncrypted)
	}
	if a&FileReparsePoint != 0 {
		fa = append(fa, FileReparsePoint)
	}
	if a&FileSparse != 0 {
		fa = append(fa, FileSparse)
	}
	if a&FileTemporary != 0 {
		fa = append(fa, FileTemporary)
	}
	if a&FileDevice != 0 {
		fa = append(fa, FileDevice)
	}
	if a&FileNormal != 0 {
		fa = append(fa, FileNormal)
	}
	if a&FileOffline != 0 {
		fa = append(fa, FileOffline)
	}
	if a&FileNotContentIndexed != 0 {
		fa = append(fa, FileNotContentIndexed)
	}
	if a&FileIntegrityStream != 0 {
		fa = append(fa, FileIntegrityStream)
	}
	if a&FileVirtual != 0 {
		fa = append(fa, FileVirtual)
	}
	if a&FileNoScrubData != 0 {
		fa = append(fa, FileNoScrubData)
	}
	if a&FileRecallOpen != 0 {
		fa = append(fa, FileRecallOpen)
	}
	if a&FileRecallAccess != 0 {
		fa = append(fa, FileRecallAccess)
	}
	if a&FilePinned != 0 {
		fa = append(fa, FilePinned)
	}
	if a&FileUnpinned != 0 {
		fa = append(fa, FileUnpinned)
	}
	return fa
}

```

`pkg/fs/dev.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/file"
	"strings"
)

const deviceOffset = 8

// DevMapper is the minimal interface for the device converters.
type DevMapper interface {
	// Convert receives the fully qualified file path and replaces the DOS device name with a drive letter.
	Convert(filename string) string
}

type mapper struct {
	cache map[string]string
}

// NewDevMapper creates a new instance of the DOS device replacer.
func NewDevMapper() DevMapper {
	m := &mapper{
		cache: make(map[string]string),
	}
	// loop through logical drives and query the DOS device name
	for _, drive := range file.GetLogicalDrives() {
		device, err := file.QueryDosDevice(drive)
		if err != nil {
			continue
		}
		m.cache[device] = drive
	}
	return m
}

func (m *mapper) Convert(filename string) string {
	if filename == "" || len(filename) < deviceOffset {
		return filename
	}
	i := strings.Index(filename[deviceOffset:], "\\")
	if i < 0 {
		return m.cache[filename]
	}
	dev := filename[:i+deviceOffset]
	if drive, ok := m.cache[dev]; ok {
		return strings.Replace(filename, dev, drive, 1)
	}
	return filename
}

```

`pkg/fs/dev_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"strings"
	"testing"
)

var drives = []string{
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z"}

func TestConvertDosDevice(t *testing.T) {
	mapper := NewDevMapper()
	files := make([]string, 0, len(drives))
	for _, drive := range drives {
		files = append(files, fmt.Sprintf("%s:\\Windows\\system32\\kernel32.dll", drive))
	}
	var filename string
	for i := 0; i < len(drives); i++ {
		filename = mapper.Convert(fmt.Sprintf("\\Device\\HarddiskVolume%d\\Windows\\system32\\kernel32.dll", i))
		if !strings.HasPrefix(filename, "\\Device") {
			break
		}
	}
	assert.Contains(t, files, filename)
}

```

`pkg/fs/file.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/syscall/file"
	"os"
	"path/filepath"
	"strings"
)

const (
	directoryFile = 0x00000001 // file being created or opened is a directory file

	deviceCDROM      = 0x00000002
	deviceCDROMFs    = 0x00000003
	deviceController = 0x00000004
	deviceDatalink   = 0x00000005
	deviceDFS        = 0x00000006
	deviceDisk       = 0x00000007
	deviceDiskFs     = 0x00000008

	devMailslot  = 0x0000000c
	devNamedPipe = 0x00000011

	devConsole = 0x00000050
)

// queryVolumeCalls represents the number of times the query volume function was called
var queryVolumeCalls = expvar.NewInt("file.query.volume.info.calls")

// GetFileType returns the underlying file type. The opts parameter corresponds to the NtCreateFile CreateOptions argument
// that specifies the options to be applied when creating or opening the file.
func GetFileType(filename string, opts uint32) FileType {
	if filename == "" {
		return Other
	}
	// if the CreateOptions argument of the NtCreateFile syscall has been invoked
	// with the FILE_DIRECTORY_FILE flag, it is likely that the target file object
	// is a directory. We ensure that by calling the API function for checking whether
	// the path name is truly a directory
	if (opts&directoryFile) != 0 && file.IsPathDirectory(filename) {
		return Directory
	}
	// FILE_DIRECTORY_FILE flag only gives us a hint on the CreateFile op outcome. If this flag is
	// not present in the argument but the file is a directory, we can apply some simple heuristics
	// like checking the extension/suffix, even though they are not bullet proof
	if filename[:len(filename)-1] == "\\" || filepath.Ext(filename) == "" {
		return Directory
	}
	// non directory file can be a regular file, logical, virtual or physical device or a volume.
	// If the filename doesn't start with a drive letter it's probably not a regular
	// file since we already have mapped the DOS name to drive letter
	if !strings.HasPrefix(filename, "\\Device") {
		return Regular
	}
	// if the filename contains the HardiskVolume string then we assume it is a file. This
	// could happen if we fail to resolve the DOS name
	if strings.HasPrefix(filename, "\\Device\\HarddiskVolume") {
		return Regular
	}
	// logical, virtual, physical device or a volume
	// obtain the device type that is linked to this file object
	return getFileTypeFromVolumeInfo(filename)
}

func getFileTypeFromVolumeInfo(filename string) FileType {
	f, err := os.Open(filename)
	if err != nil {
		return Other
	}
	defer f.Close()

	queryVolumeCalls.Add(1)

	dev, err := file.QueryVolumeInfo(f.Fd())
	if err != nil {
		return Other
	}
	switch dev.Type {
	case deviceCDROM, deviceCDROMFs, deviceController,
		deviceDatalink, deviceDFS, deviceDisk, deviceDiskFs:
		if file.IsPathDirectory(filename) {
			return Directory
		}
		return Regular
	case devConsole:
		return Console
	case devMailslot:
		return Mailslot
	case devNamedPipe:
		return Pipe
	default:
		return Other
	}
}

```

`pkg/fs/file_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestGetFileType(t *testing.T) {
	typ := GetFileType(`_fixtures`, 16777249)
	assert.Equal(t, Directory, typ)

	typ = GetFileType(`_fixtures`, 25165857)
	assert.Equal(t, Directory, typ)

	typ = GetFileType(`C:\Users\bunny\AppData\Local\Mozilla\Firefox\Profiles\profile1.tmp`, 18874368)
	assert.Equal(t, Regular, typ)
}

```

`pkg/fs/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

// FileDisposition is the alias for the file disposition modes
type FileDisposition uint8

const (
	// Supersede dictates that if the file already exists, it is replaced with the given file. Otherwise the file with given name is created.
	Supersede FileDisposition = iota
	// Open opens the file if it already exists instead of creating a new file.
	Open
	// Create fails if the file already exists.
	Create
	// OpenIf opens the file if it already exists or creates a new file otherwise.
	OpenIf
	// Overwrite opens and overwrites the file if it already exists. Otherwise it fails.
	Overwrite
	// OverwriteIf opens and overwrites the file is it already exists. Otherwise it creates a new file.
	OverwriteIf
)

// String returns the textual representation of the file disposition.
func (fd FileDisposition) String() string {
	switch fd {
	case Supersede:
		return "supersede"
	case Open:
		return "open"
	case Create:
		return "create"
	case OpenIf:
		return "openif"
	case Overwrite:
		return "overwrite"
	case OverwriteIf:
		return "overwriteif"
	default:
		return "<na>"
	}
}

// FileType is the the type alias for the file type
type FileType uint8

const (
	// Regular represents the file, volume or hard disk device
	Regular FileType = iota
	// Directory represents the directory
	Directory
	// Pipe represent the pipe
	Pipe
	// Console denotes the standard output stream
	Console
	// Mailslot denotes a mail slot file
	Mailslot
	// Other is the file type different from listed above
	Other
	// Unknown is the unknown file type
	Unknown
)

// String returns the textual representation of the file type.
func (typ FileType) String() string {
	switch typ {
	case Regular:
		return "file"
	case Directory:
		return "directory"
	case Pipe:
		return "pipe"
	case Console:
		return "console"
	case Mailslot:
		return "mailslot"
	case Other:
		return "other"
	default:
		return "unknown"
	}
}

// FileShareMode designates a type alias for file share mode values
type FileShareMode uint8

const (
	// FileShareRead allows threads to gain read access to the file
	FileShareRead FileShareMode = 1
	// FileShareWrite allows threads to gain write access to the file
	FileShareWrite FileShareMode = 1 << 1
	// FileShareDelete grants threads the possibility to delete files
	FileShareDelete FileShareMode = 1 << 2
)

// String returns user-friendly representation of the file share mask.
func (shareMode FileShareMode) String() string {
	if shareMode == FileShareRead {
		return "r--"
	} else if shareMode == FileShareWrite {
		return "-w-"
	} else if shareMode == FileShareDelete {
		return "--d"
	} else if shareMode&FileShareRead == FileShareRead && shareMode&FileShareWrite == FileShareWrite {
		return "rw-"
	} else if shareMode&FileShareRead == FileShareRead && shareMode&FileShareDelete == FileShareDelete {
		return "r-d"
	} else if shareMode&FileShareWrite == FileShareWrite && shareMode&FileShareDelete == FileShareDelete {
		return "-wd"
	} else if shareMode&FileShareRead == FileShareRead && shareMode&FileShareWrite == FileShareWrite && shareMode&FileShareDelete == FileShareDelete {
		return "rwd"
	}
	return "---"
}

```

`pkg/handle/alpc.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/object"
	"unsafe"
)

// GetAlpcPort get ALPC port information for the specified ALPC handle and process id.
func GetAlpcPort(h handle.Handle) (*htypes.AlpcPortInfo, error) {
	buf := make([]byte, 16)
	if err := object.GetAlpcInformation(h, object.AlpcBasicPortInfo, buf); err != nil {
		return nil, err
	}
	return (*htypes.AlpcPortInfo)(unsafe.Pointer(&buf[0])), nil
}

```

`pkg/handle/key.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"expvar"
	"strings"
	"sync"

	"github.com/rabbitstack/fibratus/pkg/syscall/registry"
	"github.com/rabbitstack/fibratus/pkg/syscall/security"
)

const (
	hklmPrefixUppercase   = "\\REGISTRY\\MACHINE"
	hklmPrefixCapitalized = "\\Registry\\Machine"
	hkcrPrefixUppercase   = "\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"
	hkcrPrefixCapitalized = "\\Registry\\Machine\\Software\\Classes"
	hkuPrefixUppercase    = "\\REGISTRY\\USER"
	hkuPrefixCapitalized  = "\\Registry\\User"
	// hive represents an application hive. Application hives are loaded by user-mode processes via RegLoadAppKey to store application-specific state data.
	hive = "\\REGISTRY\\A"
)

var (
	keys = make([]string, 0)
	mux  sync.Mutex
	once sync.Once
	// sidsCount reflects the total count of the resolved SIDs
	sidsCount  = expvar.NewInt("sids.count")
	lookupSids = security.LookupAllSids
)

// FormatKey produces a root,key tuple from registry native key name.
func FormatKey(key string) (registry.Key, string) {
	if strings.HasPrefix(key, hklmPrefixUppercase) || strings.HasPrefix(key, hklmPrefixCapitalized) {
		return registry.LocalMachine, subkey(key, hklmPrefixUppercase)
	}

	if strings.HasPrefix(key, hkcrPrefixUppercase) || strings.HasPrefix(key, hkcrPrefixCapitalized) {
		return registry.ClassesRoot, subkey(key, hkcrPrefixUppercase)
	}

	once.Do(func() { initKeys() })

	if root, k := findSIDKey(key); root != registry.InvalidKey {
		return root, k
	}

	if strings.HasPrefix(key, hkuPrefixUppercase) || strings.HasPrefix(key, hkuPrefixCapitalized) {
		return registry.Users, subkey(key, hkuPrefixUppercase)
	}

	if strings.HasPrefix(key, hive) {
		return registry.Hive, key
	}

	return registry.InvalidKey, key
}

// initKeys retrieves all security identifiers on the local machine and builds a slice of
// prefixes targeting \\Registry\\User\\<sid> and \\Registry\\User\\<sid>\\_Classes keys.
func initKeys() {
	sids, err := lookupSids()
	if err != nil {
		return
	}
	sidsCount.Add(int64(len(sids)))
	mux.Lock()
	defer mux.Unlock()
	for _, sid := range sids {
		user := hkuPrefixUppercase + "\\" + sid
		keys = append(keys, user, user+"\\_Classes")
	}
}

func findSIDKey(key string) (registry.Key, string) {
	mux.Lock()
	defer mux.Unlock()
	for _, k := range keys {
		if strings.HasPrefix(key, k) {
			if strings.Contains(key, "_Classes") {
				return registry.CurrentUser, strings.Replace(subkey(key, k), "_Classes", "Software\\Classes", -1)
			}
			return registry.CurrentUser, subkey(key, k)
		}
	}
	return registry.InvalidKey, key
}

func subkey(key string, prefix string) string {
	if len(key) > len(prefix) {
		return key[len(prefix)+1:]
	}
	return ""
}

```

`pkg/handle/key_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/registry"
	"github.com/stretchr/testify/assert"
	"testing"
)

func init() {
	lookupSids = func() ([]string, error) {
		return []string{"S-1-5-21-2271034452-2606270099-984871569-500", "S-1-5-21-2271034452-2606270099-984871569-501"}, nil
	}
}

func TestFormatKey(t *testing.T) {
	root, key := FormatKey(`\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`)
	assert.Equal(t, registry.LocalMachine, root)
	assert.Equal(t, `SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`, key)

	root, key = FormatKey(`\Registry\Machine\SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`)
	assert.Equal(t, registry.LocalMachine, root)
	assert.Equal(t, `SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`, key)

	root, key = FormatKey(`\REGISTRY\MACHINE`)
	assert.Equal(t, registry.LocalMachine, root)
	assert.Empty(t, key)

	root, key = FormatKey(`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500\Console`)
	assert.Equal(t, registry.CurrentUser, root)
	assert.Equal(t, `Console`, key)

	root, key = FormatKey(`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500\_Classes`)
	assert.Equal(t, registry.CurrentUser, root)
	assert.Equal(t, `Software\Classes`, key)

	root, key = FormatKey(`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500\_Classes\.all`)
	assert.Equal(t, registry.CurrentUser, root)
	assert.Equal(t, `Software\Classes\.all`, key)
}

```

`pkg/handle/mutant.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/object"
	"unsafe"
)

type mutant struct {
	count     int32
	_         bool
	abandoned bool
}

// GetMutant gets the information about specified mutant handle.
func GetMutant(h handle.Handle) (*htypes.MutantInfo, error) {
	buf := make([]byte, 8)
	if err := object.QueryMutant(h, object.MutantBasicInfo, buf); err != nil {
		return nil, err
	}
	basicInfo := (*mutant)(unsafe.Pointer(&buf[0]))
	return &htypes.MutantInfo{Count: basicInfo.count, IsAbandoned: basicInfo.abandoned}, nil
}

```

`pkg/handle/object.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"errors"
	"expvar"
	"fmt"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/fs"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/syscall/file"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/object"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/rabbitstack/fibratus/pkg/syscall/registry"
	"github.com/rabbitstack/fibratus/pkg/util/typesize"
	"os"
	"sort"
	"unsafe"
)

var (
	// typeBufSize specifies the size of the object type name buffer
	typeBufSize = 512
	// nameBufSize specifies the size of the object name buffer
	nameBufSize = 1024
	// typesCount counts the number of resolved object type names
	typesCount = expvar.NewInt("handle.types.count")
	typeMisses = expvar.NewInt("handle.types.name.misses")
)

var devMapper = fs.NewDevMapper()

// ObjectTypeStore holds all object type names as exposed by the Object Manager. The store represents a efficient
// way of resolving object type indices to human-friendly names.
type ObjectTypeStore interface {
	FindByID(id uint8) string
	RegisterType(id uint8, typ string)
	TypeNames() []string
}

type otstore struct {
	types map[uint8]string
}

// NewObjectTypeStore creates a new object store instance.
func NewObjectTypeStore() ObjectTypeStore {
	s := &otstore{
		types: make(map[uint8]string),
	}
	s.queryTypes()
	return s
}

func (s *otstore) FindByID(id uint8) string {
	if typ, ok := s.types[id]; ok {
		return typ
	}
	typeMisses.Add(1)
	return ""
}

func (s *otstore) RegisterType(id uint8, typ string) {
	s.types[id] = typ
}

func (s *otstore) TypeNames() []string {
	types := make([]string, 0, len(s.types))
	for _, v := range s.types {
		types = append(types, v)
	}
	sort.Slice(types, func(i, j int) bool { return types[i] < types[j] })
	return types
}

func (s *otstore) queryTypes() {
	bufSize := 8824
	buf := make([]byte, bufSize)
	size, err := object.Query(0, object.TypesInformationClass, buf)
	if err == errs.ErrNeedsReallocateBuffer {
		buf = make([]byte, size)
		if _, err = object.Query(0, object.TypesInformationClass, buf); err != nil {
			return
		}
	}

	if err != nil {
		return
	}

	types := (*object.TypesInformation)(unsafe.Pointer(&buf[0]))
	typesCount.Add(int64(types.NumberOfTypes))

	// heavily influenced by ProcessHacker pointer arithmetic hackery to
	// dereference the first and all subsequent file object type instances
	// starting from the address of the TypesInformation structure
	objectTypeInfo := (*object.TypeInformation)(s.first(buf))
	for i := 0; i < int(types.NumberOfTypes); i++ {
		objectTypeInfo = (*object.TypeInformation)(s.next(objectTypeInfo))
		s.types[objectTypeInfo.TypeIndex] = objectTypeInfo.TypeName.String()
	}
}

func (s *otstore) first(b []byte) unsafe.Pointer {
	return unsafe.Pointer(uintptr(unsafe.Pointer(&b[0])) + (unsafe.Sizeof(object.TypesInformation{})+typesize.Pointer()-1)&^(typesize.Pointer()-1))
}

func (s *otstore) next(typ *object.TypeInformation) unsafe.Pointer {
	align := (uintptr(typ.TypeName.MaxLength) + typesize.Pointer() - 1) &^ (typesize.Pointer() - 1)
	offset := uintptr(unsafe.Pointer(typ)) + unsafe.Sizeof(object.TypeInformation{})
	return unsafe.Pointer(offset + align)
}

// Duplicate duplicates the handle in the caller process's address space.
func Duplicate(h handle.Handle, pid uint32, access handle.DuplicateAccess) (handle.Handle, error) {
	targetPs, err := process.Open(process.DupHandle, false, pid)
	if err != nil {
		return ^handle.Handle(0), err
	}
	defer targetPs.Close()
	currentPs, err := process.Open(process.DupHandle, false, uint32(os.Getpid()))
	if err != nil {
		return ^handle.Handle(0), err
	}
	defer currentPs.Close()
	// duplicate the remote handle in the current process's address space.
	// Note that for certain handle types this operation might fail
	// as they don't permit duplicate operations
	dup, err := h.Duplicate(targetPs, currentPs, access)
	if err != nil {
		return ^handle.Handle(0), fmt.Errorf("couldn't duplicate handle: %v", err)
	}
	return dup, nil
}

// QueryType returns the type of the specified handle.
func QueryType(handle handle.Handle) (string, error) {
	buffer := make([]byte, typeBufSize)
	size, err := object.Query(handle, object.TypeInformationClass, buffer)
	if err == errs.ErrNeedsReallocateBuffer {
		buffer = make([]byte, size)
		if _, err = object.Query(handle, object.TypeInformationClass, buffer); err != nil {
			return "", fmt.Errorf("couldn't query handle type after buffer reallocation: %v", err)
		}
	}
	if err != nil {
		return "", fmt.Errorf("couldn't query handle type: %v", err)
	}
	// transform buffer into type information structure and get
	// the underlying UNICODE string that identifies handle's type name
	typeInfo := (*object.TypeInformation)(unsafe.Pointer(&buffer[0]))
	length := typeInfo.TypeName.Length
	if length > 0 {
		return typeInfo.TypeName.String(), nil
	}
	return "", errors.New("zero length handle type name encountered")
}

// QueryName gets the name of the underlying handle reference and extra metadata if it is available.
func QueryName(handle handle.Handle, typ string, withTimeout bool) (string, htypes.Meta, error) {
	switch typ {
	case File:
		if !withTimeout {
			return "", nil, nil
		}
		// delegate the name resolution to the deadlock aware handle timeout
		name, err := GetHandleWithTimeout(handle, 500)
		if err != nil {
			return "", nil, err
		}
		name = devMapper.Convert(name)
		fileInfo := &htypes.FileInfo{IsDirectory: file.IsPathDirectory(name)}
		return name, fileInfo, nil
	case ALPCPort:
		port, err := GetAlpcPort(handle)
		if err != nil {
			return "", nil, nil
		}
		return "", port, nil
	case Process:
		name, err := process.QueryFullImageName(handle)
		if err != nil {
			return "", nil, nil
		}
		return name, nil, nil
	case Mutant:
		mutant, err := GetMutant(handle)
		if err != nil {
			return "", nil, nil
		}
		return "", mutant, nil
	default:
		name, err := queryObjectName(handle)
		if err != nil {
			return "", nil, err
		}
		switch typ {
		case Key:
			key, subkey := FormatKey(name)
			rootKey := key.String()
			if key == registry.InvalidKey {
				return name, nil, nil
			}
			if subkey != "" {
				return rootKey + "\\" + subkey, nil, nil
			}
			return key.String(), nil, nil
		default:
			return name, nil, nil
		}
	}
}

func queryObjectName(handle handle.Handle) (string, error) {
	buffer := make([]byte, nameBufSize)
	size, err := object.Query(handle, object.NameInformationClass, buffer)
	if err == errs.ErrNeedsReallocateBuffer {
		buffer = make([]byte, size)
		if _, err = object.Query(handle, object.NameInformationClass, buffer); err != nil {
			return "", fmt.Errorf("couldn't query handle name after buffer reallocation: %v", err)
		}
	}
	if err != nil {
		return "", fmt.Errorf("couldn't query handle name: %v", err)
	}
	nameInfo := (*object.NameInformation)(unsafe.Pointer(&buffer[0]))
	length := nameInfo.ObjectName.Length
	if length > 0 {
		return nameInfo.ObjectName.String(), nil
	}
	return "", nil
}

```

`pkg/handle/object_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"syscall"
	"testing"
	"unsafe"
)

var (
	modkernel32 = syscall.NewLazyDLL("kernel32.dll")

	procCreateNamedPipeW = modkernel32.NewProc("CreateNamedPipeW")
)

func createNamedPipe(name *uint16, openMode uint32, pipeMode uint32, maxInstances uint32, outBufSize uint32, inBufSize uint32, defaultTimeout uint32, sa *syscall.SecurityAttributes) (handle syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall9(procCreateNamedPipeW.Addr(), 8, uintptr(unsafe.Pointer(name)), uintptr(openMode), uintptr(pipeMode), uintptr(maxInstances), uintptr(outBufSize), uintptr(inBufSize), uintptr(defaultTimeout), uintptr(unsafe.Pointer(sa)), 0)
	handle = syscall.Handle(r0)
	if handle == syscall.InvalidHandle {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// createPipe is mainly borrowed from: https://github.com/natefinch/npipe for testing purposes.
func createPipe(address string, first bool) (syscall.Handle, error) {
	n, err := syscall.UTF16PtrFromString(address)
	if err != nil {
		return 0, err
	}
	mode := uint32(0x3 | syscall.FILE_FLAG_OVERLAPPED)
	if first {
		mode |= 0x00080000
	}
	return createNamedPipe(n,
		mode,
		0x0,
		255,
		512, 512, 0, nil)
}

func TestQueryAllObjectTypes(t *testing.T) {
	otstore := NewObjectTypeStore()
	require.Contains(t, otstore.TypeNames(), "Directory")
	require.Contains(t, otstore.TypeNames(), "Key")
}

func TestQueryType(t *testing.T) {
	h, err := process.Open(process.QueryInformation, false, uint32(os.Getpid()))
	require.NoError(t, err)
	defer h.Close()
	typeName, err := QueryType(h)
	require.NoError(t, err)
	assert.Equal(t, Process, typeName)
}

func TestQueryTypeSmallBuffer(t *testing.T) {
	typeBufSize = 25
	h, err := process.Open(process.QueryInformation, false, uint32(os.Getpid()))
	require.NoError(t, err)
	typeName, err := QueryType(h)
	require.NoError(t, err)
	assert.Equal(t, Process, typeName)
}

func TestQueryNameFileHandle(t *testing.T) {
	f, err := syscall.Open("_fixtures/.fibratus", syscall.O_RDONLY, syscall.S_ISUID)
	require.NoError(t, err)
	defer syscall.Close(f)
	handleName, _, err := QueryName(handle.Handle(f), File, true)
	require.NoError(t, err)
	assert.Equal(t, ".fibratus", filepath.Base(handleName))
}

func TestQueryNamedPipe(t *testing.T) {
	h, err := createPipe(`\\.\pipe\fibratus`, true)
	require.NoError(t, err)
	defer syscall.Close(h)
	handleName, _, err := QueryName(handle.Handle(h), File, true)
	require.NoError(t, err)
	assert.Equal(t, `\Device\NamedPipe\fibratus`, handleName)
}

```

`pkg/handle/snapshotter.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"expvar"
	"fmt"
	"os"
	"strconv"
	"sync"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/config"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/object"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/rabbitstack/fibratus/pkg/syscall/sys"
	log "github.com/sirupsen/logrus"
)

var (
	globalBufferSize = 4096
	bufferSize       = 1024

	handleNameQueryFailures = expvar.NewMap("handle.name.query.failures")
	handleSnapshotCount     = expvar.NewInt("handle.snapshot.count")
	handleSnapshotBytes     = expvar.NewInt("handle.snapshot.bytes")

	currentPid = uint32(os.Getpid())
)

// CreateCallback defines the function that is triggered when new handle is conceived
type CreateCallback func(pid uint32, handle htypes.Handle)

// DestroyCallback defines the function signature that is fired upon handle's destruction
type DestroyCallback func(pid uint32, num handle.Handle)

// SnapshotBuildCompleted is the function type for snapshot completed signal
type SnapshotBuildCompleted func(total uint64, withName uint64)

// Snapshotter keeps the system-wide snapshot of allocated handles always when handle kernel events are enabled or
// supported on the target system. It also provides facilities for obtaining a list of handles pertaining to the specific
// process.
type Snapshotter interface {
	// Write updates the snapshotter state by storing a new entry for the inbound create handle event. It also notifies
	// the registered callback that a new handle has been created.
	Write(kevt *kevent.Kevent) error
	// Remove destroys the handle state for the specified handle object. The removal callback is triggered when an item
	// is deleted from the store.
	Remove(kevt *kevent.Kevent) error
	// FindHandles returns a list of all known handles for the specified process identifier.
	FindHandles(pid uint32) ([]htypes.Handle, error)
	// FindByObject returns the handle for the given handle object reference.
	FindByObject(object uint64) (htypes.Handle, bool)
	// RegisterCreateCallback registers a function that's triggered when new handle is created.
	RegisterCreateCallback(fn CreateCallback)
	// RegisterDestroyCallback registers a function that's called when existing handle is disposed.
	RegisterDestroyCallback(fn DestroyCallback)
	// GetSnapshot returns all the handles present in the snapshotter state.
	GetSnapshot() []htypes.Handle
}

type snapshotter struct {
	sync.Mutex
	handlesByObject        map[uint64]htypes.Handle
	hc                     chan htypes.Handle
	hdone                  chan struct{}
	config                 *config.Config
	snapshotBuildCompleted SnapshotBuildCompleted
	createCallback         CreateCallback
	destroyCallback        DestroyCallback
	store                  ObjectTypeStore
	housekeepTick          *time.Ticker
	initSnap               bool
	capture                bool
}

// NewSnapshotter constructs a new instance of the handle snapshotter. If `SnapshotBuildCompleted` function is provided
// it will receive the total number of discovered handles as well as the count of the non-nameless handles.
func NewSnapshotter(config *config.Config, fn SnapshotBuildCompleted) Snapshotter {
	s := &snapshotter{
		hc:                     make(chan htypes.Handle),
		hdone:                  make(chan struct{}, 1),
		handlesByObject:        make(map[uint64]htypes.Handle),
		snapshotBuildCompleted: fn,
		config:                 config,
		store:                  NewObjectTypeStore(),
		housekeepTick:          time.NewTicker(time.Minute),
		initSnap:               config.InitHandleSnapshot,
	}

	if s.initSnap {
		go s.consumeHandles()
		go s.initSnapshot()
		go s.housekeeping()
	} else {
		if fn != nil {
			fn(0, 0)
		}
	}

	return s
}

// NewFromKcap builds the handle snapshotter from kcap state.
func NewFromKcap(handles []htypes.Handle) Snapshotter {
	handlesByObject := make(map[uint64]htypes.Handle)
	for _, h := range handles {
		handlesByObject[h.Object] = h
	}
	return &snapshotter{
		handlesByObject: handlesByObject,
		capture:         true,
	}
}

func (s *snapshotter) FindByObject(object uint64) (htypes.Handle, bool) {
	s.Lock()
	defer s.Unlock()
	if h, ok := s.handlesByObject[object]; ok {
		return h, ok
	}
	return htypes.Handle{}, false
}

func (s *snapshotter) FindHandles(pid uint32) ([]htypes.Handle, error) {
	if pid == currentPid || pid == 0 { // ignore current and idle processes
		return []htypes.Handle{}, nil
	}
	if s.capture {
		handles := make([]htypes.Handle, 0)
		s.Lock()
		defer s.Unlock()
		for _, h := range s.handlesByObject {
			if h.Pid == pid {
				handles = append(handles, h)
			}
		}
		return handles, nil
	}
	ps, err := process.Open(process.QueryInformation, false, pid)
	if err != nil {
		// trying to obtain the handle with `QueryInformation` access on a protected
		// process will always fail, so our best effort is to collect handles for those
		// processes in the snapshot's state
		handles := make([]htypes.Handle, 0)
		s.Lock()
		defer s.Unlock()
		for _, h := range s.handlesByObject {
			if h.Pid == pid && h.Type != "" {
				handles = append(handles, h)
			}
		}
		return handles, nil
	}
	defer ps.Close()
	buf := make([]byte, bufferSize)
	n, err := process.QueryInfo(ps, process.HandleInformationClass, buf)
	if err == errs.ErrNeedsReallocateBuffer {
		buf = make([]byte, n)
		_, err = process.QueryInfo(ps, process.HandleInformationClass, buf)
	}
	if err != nil {
		return nil, fmt.Errorf("unable to query handles for process id %d: %v", pid, err)
	}

	snapshot := (*object.ProcessHandleSnapshotInformation)(unsafe.Pointer(&buf[0]))

	// enumerate process's handles and try to resolve
	// the type and the name of each allocated handle
	handles := make([]htypes.Handle, 0)
	count := snapshot.NumberOfHandles
	sysHandles := (*[1 << 30]object.ProcessHandleTableEntryInfo)(unsafe.Pointer(&snapshot.Handles[0]))[:count:count]

	for _, sh := range sysHandles {
		h, err := s.getHandle(sh.Handle, 0, uint8(sh.ObjectTypeIndex), pid, false)
		if err != nil {
			continue
		}
		// ignore file handles since we can't get the file name...
		if h.Type == File && h.Name == "" {
			continue
		}
		handles = append(handles, h)
	}

	return handles, nil
}

// initSnapshot builds the initial snapshot state by enumerating system-wide handles.
func (s *snapshotter) initSnapshot() {
	size := globalBufferSize
	buf := make([]byte, size)
	for {
		_, err := sys.QuerySystemInformation(object.SystemExtendedHandleInformation, buf)
		if err == errs.ErrNeedsReallocateBuffer {
			size *= 2
			buf = make([]byte, size)
		} else if err == nil {
			sysHandleInfo := (*object.SystemHandleInformationEx)(unsafe.Pointer(&buf[0]))
			count := int(sysHandleInfo.NumberOfHandles)
			sysHandles := (*[1 << 30]object.SystemHandleTableEntryInfoEx)(unsafe.Pointer(&sysHandleInfo.Handles[0]))[:count:count]

			// iterate through available handles to get extended info
			// and send handle structure instances to the channel
			for _, sysHandle := range sysHandles {
				pid := sysHandle.ProcessID
				if pid == uintptr(currentPid) {
					continue
				}
				h, err := s.getHandle(sysHandle.Handle, sysHandle.Object, sysHandle.ObjectTypeIndex, uint32(pid), true)
				if err != nil || h.Type == "" {
					continue
				}
				s.hc <- h
			}
			s.hdone <- struct{}{}
			break
		} else {
			log.Warnf("couldn't enumerate system-wide handles: %v", err)
			break
		}
	}
}

func (s *snapshotter) getHandle(rawHandle handle.Handle, obj uint64, typeIndex uint8, pid uint32, withTimeout bool) (htypes.Handle, error) {
	typ := s.store.FindByID(typeIndex)
	if typ == "" {
		dup, err := Duplicate(rawHandle, pid, handle.AllAccess)
		if err != nil {
			return htypes.Handle{Num: rawHandle, Object: obj}, nil
		}
		defer dup.Close()
		typ, err = QueryType(dup)
		if err != nil {
			return htypes.Handle{Num: rawHandle, Object: obj}, nil
		}
	}
	h := htypes.Handle{
		Num:    rawHandle,
		Object: obj,
		Type:   typ,
		Pid:    pid,
	}
	// use the required duplicate access to query handle name
	var dupAccess handle.DuplicateAccess
	switch typ {
	case ALPCPort:
		dupAccess = handle.ReadControlAccess
	case Process:
		dupAccess = handle.ProcessQueryAccess
	case Mutant:
		dupAccess = handle.SemaQueryAccess
	default:
		dupAccess = handle.AllAccess
	}
	dup, err := Duplicate(rawHandle, pid, dupAccess)
	if err != nil {
		return h, err
	}
	defer dup.Close()
	h.Name, h.MD, err = QueryName(dup, typ, withTimeout)
	if err != nil {
		// even though we weren't able to query handle name we still
		// return handle info with handle type and other metadata
		handleNameQueryFailures.Add(strconv.Itoa(int(pid)), 1)
		return h, nil
	}
	return h, nil
}

func (s *snapshotter) consumeHandles() {
	for {
		select {
		case h := <-s.hc:
			s.Lock()
			handleSnapshotCount.Add(1)
			handleSnapshotBytes.Add(int64(h.Len()))
			s.handlesByObject[h.Object] = h
			s.Unlock()
		case <-s.hdone:
			log.Debug("initial handle enumeration has finalized")
			s.Lock()
			var withName uint64
			for _, h := range s.handlesByObject {
				if h.Name != "" {
					withName++
				}
				if s.createCallback != nil && h.Type == File {
					// for safety reasons related to deadlocks we are skipping file handles
					// for Enum/Create process events, we'll send these handles after initial
					// system-wide scan has completed
					if h.Name != "" {
						s.createCallback(h.Pid, h)
					}
				}
			}
			s.Unlock()
			if s.snapshotBuildCompleted != nil {
				s.snapshotBuildCompleted(uint64(len(s.handlesByObject)), withName)
			}
			return
		}
	}
}

func (s *snapshotter) housekeeping() {
	for {
		<-s.housekeepTick.C

		size := globalBufferSize
		buf := make([]byte, size)
	loop:
		for {
			_, err := sys.QuerySystemInformation(object.SystemExtendedHandleInformation, buf)
			if err == errs.ErrNeedsReallocateBuffer {
				size *= 2
				buf = make([]byte, size)
			} else if err == nil {
				sysHandleInfo := (*object.SystemHandleInformationEx)(unsafe.Pointer(&buf[0]))
				count := int(sysHandleInfo.NumberOfHandles)
				sysHandles := (*[1 << 30]object.SystemHandleTableEntryInfoEx)(unsafe.Pointer(&sysHandleInfo.Handles[0]))[:count:count]

				s.Lock()
				for _, sysHandle := range sysHandles {
					if h, ok := s.handlesByObject[sysHandle.Object]; !ok {
						handleSnapshotCount.Add(-1)
						handleSnapshotBytes.Add(-int64(h.Len()))
						delete(s.handlesByObject, sysHandle.Object)
					}
				}
				s.Unlock()

				break loop
			} else {
				log.Warnf("couldn't get system-wide handles in housekeeping timer: %v", err)
				break loop
			}
		}
	}
}

func (s *snapshotter) RegisterCreateCallback(fn CreateCallback) {
	s.createCallback = fn
}

func (s *snapshotter) RegisterDestroyCallback(fn DestroyCallback) {
	s.destroyCallback = fn
}

func (s *snapshotter) GetSnapshot() []htypes.Handle {
	handles := make([]htypes.Handle, 0, len(s.handlesByObject))
	for _, h := range s.handlesByObject {
		handles = append(handles, h)
	}
	return handles
}

func (s *snapshotter) Write(kevt *kevent.Kevent) error {
	if kevt.Type != ktypes.CreateHandle {
		return fmt.Errorf("expected CreateHandle kernel event but got %s", kevt.Type)
	}
	h := unwrapHandle(kevt)
	obj, err := kevt.Kparams.TryGetHexAsUint64(kparams.HandleObject)
	if err != nil {
		return err
	}
	s.Lock()
	s.handlesByObject[obj] = h
	s.Unlock()
	return nil
}

func (s *snapshotter) Remove(kevt *kevent.Kevent) error {
	if kevt.Type != ktypes.CloseHandle {
		return fmt.Errorf("expected CloseHandle kernel event but got %s", kevt.Type)
	}
	obj, err := kevt.Kparams.TryGetHexAsUint64(kparams.HandleObject)
	if err != nil {
		return err
	}
	s.Lock()
	delete(s.handlesByObject, obj)
	s.Unlock()
	return nil
}

func unwrapHandle(kevt *kevent.Kevent) htypes.Handle {
	h := htypes.Handle{}
	h.Type, _ = kevt.Kparams.GetString(kparams.HandleObjectTypeName)
	h.Object, _ = kevt.Kparams.GetHexAsUint64(kparams.HandleObject)
	h.Name, _ = kevt.Kparams.GetString(kparams.HandleObjectName)
	return h
}

```

`pkg/handle/snapshotter_mock.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/stretchr/testify/mock"
)

// SnapshotterMock is the mock handle snapshotter used in tests.
type SnapshotterMock struct {
	mock.Mock
}

// Write method
func (s *SnapshotterMock) Write(kevt *kevent.Kevent) error { return nil }

// Remove method
func (s *SnapshotterMock) Remove(kevt *kevent.Kevent) error { return nil }

// FindHandles method
func (s *SnapshotterMock) FindHandles(pid uint32) ([]htypes.Handle, error) { return nil, nil }

// FindByObject method
func (s *SnapshotterMock) FindByObject(object uint64) (htypes.Handle, bool) {
	return htypes.Handle{}, false
}

// RegisterCreateCallback method
func (s *SnapshotterMock) RegisterCreateCallback(fn CreateCallback) {}

// RegisterDestroyCallback method
func (s *SnapshotterMock) RegisterDestroyCallback(fn DestroyCallback) {}

// GetSnapshot method
func (s *SnapshotterMock) GetSnapshot() []htypes.Handle {
	handles := s.Called()
	return handles.Get(0).([]htypes.Handle)
}

```

`pkg/handle/snapshotter_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
	"time"
)

func TestInitSnapshot(t *testing.T) {
	ch := make(chan bool)
	time.AfterFunc(time.Second*40, func() {
		ch <- true
		t.Fatal("snapshot callback was not triggered")
	})
	snap := NewSnapshotter(&config.Config{InitHandleSnapshot: true}, func(total, known uint64) {
		ch <- true
	})
	require.NotNil(t, snap)
	<-ch
}

func TestFindHandles(t *testing.T) {
	snap := NewSnapshotter(&config.Config{InitHandleSnapshot: true}, nil)
	handles, err := snap.FindHandles(uint32(os.Getppid()))
	require.NoError(t, err)
	require.NotEmpty(t, handles)

	var hasProcessHandle bool
	for _, h := range handles {
		if h.Type == "Process" {
			hasProcessHandle = true
		}
	}

	require.True(t, hasProcessHandle)
}

```

`pkg/handle/timeout.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/object"
	"github.com/rabbitstack/fibratus/pkg/syscall/thread"
	"sync/atomic"
	"syscall"
)

var (
	threadHandle handle.Handle
	rawHandle    atomic.Value
	ini          object.Event
	done         object.Event
	name         string

	waitTimeoutCounts = expvar.NewInt("handle.wait.timeouts")
)

func init() {
	ini, _ = object.NewEvent(false, false)
	done, _ = object.NewEvent(false, false)
}

// GetHandleWithTimeout is in charge of resolving handle names on handle instances that are under the risk
// of producing a deadlock, and thus hanging the caller thread. To prevent this kind of unwanted scenarios,
// deadlock aware timeout calls into `NtQueryObject` in a separate native thread. The thread is reused across
// invocations as it is blocked waiting to be signaled by an event, but the query thread also signals back the main
// thread after completion of the `NtQueryObject` call. If the query thread doesn't notify the main thread after a prudent
// timeout, then the query thread is killed. Subsequent calls for handle name resolution will recreate the thread in case
// of it not being alive.
func GetHandleWithTimeout(handle handle.Handle, timeout uint32) (string, error) {
	if threadHandle == 0 {
		if err := ini.Reset(); err != nil {
			return "", fmt.Errorf("couldn't reset init event: %v", err)
		}
		if err := done.Reset(); err != nil {
			return "", fmt.Errorf("couldn't reset done event: %v", err)
		}
		h, _, err := thread.Create(nil, syscall.NewCallback(cb))
		if err != nil {
			return "", fmt.Errorf("cannot create handle query thread: %v", err)
		}
		threadHandle = h
	}

	rawHandle.Store(handle)

	if err := ini.Set(); err != nil {
		return "", err
	}

	switch s, _ := syscall.WaitForSingleObject(syscall.Handle(done), timeout); s {
	case syscall.WAIT_OBJECT_0:
		return name, nil
	case syscall.WAIT_TIMEOUT:
		waitTimeoutCounts.Add(1)
		// kill the thread and wait for its termination to orderly cleanup resources
		if err := thread.Terminate(threadHandle, 0); err != nil {
			return "", fmt.Errorf("unable to terminate timeout thread: %v", err)
		}
		if _, err := syscall.WaitForSingleObject(syscall.Handle(threadHandle), timeout); err != nil {
			return "", fmt.Errorf("failed awaiting timeout thread termination: %v", err)
		}
		threadHandle = 0
		threadHandle.Close()

		return "", errors.New("couldn't resolve handle name due to timeout")
	}
	return "", nil
}

// CloseTimeout releases handle timeut resources.
func CloseTimeout() error {
	if err := ini.Close(); err != nil {
		return done.Close()
	}
	threadHandle.Close()
	return done.Close()
}

func cb(ctx uintptr) uintptr {
	for {
		s, err := syscall.WaitForSingleObject(syscall.Handle(ini), syscall.INFINITE)
		if err != nil || s != syscall.WAIT_OBJECT_0 {
			break
		}
		name, err = queryObjectName(rawHandle.Load().(handle.Handle))
		if err != nil {
			if err := done.Set(); err != nil {
				break
			}
			continue
		}
		if err := done.Set(); err != nil {
			break
		}
	}
	return 0
}

```

`pkg/handle/timeout_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTimeout(t *testing.T) {
	deadlockTimeout, err := GetHandleWithTimeout(1, 500)
	require.NoError(t, err)
	require.NotNil(t, deadlockTimeout)
}

```

`pkg/handle/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

const (
	// ALPCPort represents the ALPC (Advanced Local Procedure Call) object ports
	ALPCPort = "ALPC Port"
	// Directory designates directory objects. They exist only within the object manager scope and do not correspond to any directory on the disk.
	Directory = "Directory"
	// EtwRegistration represents the ETW registration object
	EtwRegistration = "EtwRegistration"
	// EtwConsumer represents the ETW consumer object
	EtwConsumer = "EtwConsumer"
	// Event denotest the event object
	Event = "Event"
	// File designates file handles (e.g. pipe, device, mailslot)
	File = "File"
	// Key represents the registry key object
	Key = "Key"
	// Job represents the job object
	Job = "Job"
	// WaitCompletionPacket is the wait completion packet object
	WaitCompletionPacket = "WaitCompletionPacket"
	// IRTimer is the IR timer object
	IRTimer = "IRTimer"
	// TpWorkerFactory represents the thread pool worker factory object
	TpWorkerFactory = "TpWorkerFactory"
	// IoCompletion represents the IO completion object
	IoCompletion = "IoCompletion"
	// Thread is the thread object
	Thread = "Thread"
	// Semaphore represents the semaphore object
	Semaphore = "Semaphore"
	// Section represents the section object
	Section = "Section"
	// Mutant represents the mutant object
	Mutant = "Mutant"
	// Desktop represents the desktop object
	Desktop = "Desktop"
	// WindowStation represents the window station object
	WindowStation = "WindowStation"
	// Token represents the token object
	Token = "Token"
	// UserApcReserve represents the user APC reserve object
	UserApcReserve = "UserApcReserve"
	// Process represents the process object
	Process = "Process"
	// SymbolicLink represents the symbolic link object
	SymbolicLink = "SymbolicLink"
	// Unknown is the unknown handle object
	Unknown = "Unknown"
)

// GetShortName returns the short name for the handle type.
func GetShortName(typ string) string {
	switch typ {
	case ALPCPort:
		return "alpc"
	case Directory:
		return "d"
	case EtwRegistration:
		return "etwr"
	case Event:
		return "e"
	case File:
		return "f"
	case Process:
		return "ps"
	case Section:
		return "sec"
	case Semaphore:
		return "sem"
	default:
		return Unknown
	}
}

```

`pkg/handle/types/marshaller.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"unsafe"
)

// md is the type alias for the metadata type
type md uint8

const (
	alpcport md = iota + 1
	mutant
	file
	unknown
	none
)

// Offset returns the next offset from which to read the binary data.
func (h Handle) Offset() uint16 {
	offset := 8 + 8 + 4 + 2 + uint16(len(h.Type)) + 2 + uint16(len(h.Name)) + 1
	if h.MD != nil {
		switch h.MD.(type) {
		case *AlpcPortInfo:
			offset += 16
		case *MutantInfo:
			offset += 5
		case *FileInfo:
			offset++
		}
	}
	return offset
}

// Marshal dumps the state of the handle to byte slice that is suitable for serializing to kcap file.
func (h *Handle) Marshal() []byte {
	b := make([]byte, 0)

	// write handle id, object address and the pid that owns this handle
	b = append(b, bytes.WriteUint64(uint64(h.Num))...)
	b = append(b, bytes.WriteUint64(h.Object)...)
	b = append(b, bytes.WriteUint32(h.Pid)...)

	// write handle type and name
	b = append(b, bytes.WriteUint16(uint16(len(h.Type)))...)
	b = append(b, h.Type...)

	b = append(b, bytes.WriteUint16(uint16(len(h.Name)))...)
	b = append(b, h.Name...)

	// write handle metadata
	if h.MD != nil {
		switch meta := h.MD.(type) {
		case *AlpcPortInfo:
			b = append(b, byte(alpcport))
			b = append(b, bytes.WriteUint32(meta.Flags)...)
			b = append(b, bytes.WriteUint32(meta.Seqno)...)
			b = append(b, bytes.WriteUint64(uint64(meta.Context))...)
		case *MutantInfo:
			b = append(b, byte(mutant))
			b = append(b, bytes.WriteUint32(uint32(meta.Count))...)
			if meta.IsAbandoned {
				b = append(b, 1)
			} else {
				b = append(b, 0)
			}
		case *FileInfo:
			b = append(b, byte(file))
			if meta.IsDirectory {
				b = append(b, 1)
			} else {
				b = append(b, 0)
			}
		default:
			b = append(b, byte(unknown))
		}
	} else {
		b = append(b, byte(none))
	}

	return b
}

// Unmarshal transforms the byte slice back to handle structure.
func (h *Handle) Unmarshal(b []byte) error {
	if len(b) < 20 {
		return fmt.Errorf("expected at least 20 bytes but got %d bytes", len(b))
	}

	// read handle identifier
	h.Num = handle.Handle(bytes.ReadUint64(b[0:]))
	// read object address
	h.Object = bytes.ReadUint64(b[8:])
	// read pid
	h.Pid = bytes.ReadUint32(b[16:])

	// read handle type and name
	l := bytes.ReadUint16(b[20:])
	buf := b[22:]
	offset := l
	if len(buf) > 0 {
		h.Type = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}

	l = bytes.ReadUint16(b[22+offset:])
	buf = b[24+offset:]
	offset += l
	if len(buf) > 0 {
		h.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}

	typ := md(b[24+offset])
	if typ == none {
		return nil
	}

	switch typ {
	case alpcport:
		alpcPort := &AlpcPortInfo{
			Flags:   bytes.ReadUint32(b[25+offset:]),
			Seqno:   bytes.ReadUint32(b[29+offset:]),
			Context: uintptr(bytes.ReadUint64(b[33+offset:])),
		}
		h.MD = alpcPort
	case mutant:
		mut := &MutantInfo{
			Count:       int32(bytes.ReadUint32(b[25+offset:])),
			IsAbandoned: utob(b[29+offset]),
		}
		h.MD = mut
	case file:
		f := &FileInfo{
			IsDirectory: utob(b[25+offset]),
		}
		h.MD = f
	}

	return nil
}

func utob(u uint8) bool { return u > 0 }

```

`pkg/handle/types/marshaller_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestMarshaller(t *testing.T) {
	h := Handle{
		Num:    handle.Handle(0xffffd105e9baaf70),
		Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
		Type:   "Key",
		Object: 777488883434455544,
		Pid:    uint32(1023),
	}
	buf := h.Marshal()

	clone := Handle{}
	err := clone.Unmarshal(buf)
	require.NoError(t, err)

	assert.Equal(t, handle.Handle(18446692422059208560), clone.Num)
	assert.Equal(t, "Key", clone.Type)
	assert.Equal(t, `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`, clone.Name)
	assert.Equal(t, uint32(1023), clone.Pid)
	assert.Equal(t, uint64(777488883434455544), clone.Object)

	h = Handle{
		Num:  handle.Handle(0xefffd105e9adaf70),
		Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
		Type: "ALPC Port",
		Pid:  uint32(1023),
		MD: &AlpcPortInfo{
			Seqno:   1,
			Context: 0x0,
			Flags:   0x0,
		},
	}
	buf = h.Marshal()

	err = clone.Unmarshal(buf)
	require.NoError(t, err)

	assert.Equal(t, handle.Handle(0xefffd105e9adaf70), clone.Num)
	assert.Equal(t, "ALPC Port", clone.Type)
	assert.Equal(t, `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`, clone.Name)
	assert.Equal(t, uint32(1023), clone.Pid)
	assert.NotNil(t, clone.MD)
	assert.IsType(t, &AlpcPortInfo{}, clone.MD)
	alpcPortInfo := clone.MD.(*AlpcPortInfo)
	assert.Equal(t, uint32(1), alpcPortInfo.Seqno)
}

```

`pkg/handle/types/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"strings"
)

// Meta represents the type alias for handle meta information
type Meta interface{}

// Handles represents a collection of handles.
type Handles []Handle

// Handle stores various metadata specific to the handle allocated by a process.
type Handle struct {
	// Num represents the internal handle identifier.
	Num handle.Handle `json:"id"`
	// Object is the kernel address that this handle references.
	Object uint64 `json:"-"`
	// Pid represents the process's identifier that owns the handle.
	Pid uint32 `json:"-"`
	// Type is the type of this handle (e.g. File, Key, Mutant, Section)
	Type string `json:"type"`
	// Name is the actual value of the handle (e.g. \Device\HarddiskVolume4\Windows\Temp\DPTF)
	Name string `json:"name"`
	// MD is the handle meta information (e.g. ALPC port info)
	MD Meta `json:"meta,omitempty"`
}

// String returns a string representation of the handle.
func (h Handle) String() string {
	return fmt.Sprintf("Num: %d Type: %s, Name: %s, Object: 0x%x, PID: %d", h.Num, h.Type, h.Name, h.Object, h.Pid)
}

// Len returns the length in bytes of the Handle structure.
func (h Handle) Len() int {
	l := 8 + 8 + 4 + len(h.Type) + len(h.Name)
	if h.MD != nil {
		switch h.MD.(type) {
		case *AlpcPortInfo:
			l += 16
		case *MutantInfo:
			l += 5
		case *FileInfo:
			l++
		}
	}
	return l
}

// NewFromKcap restores handle state from the kcap buffer.
func NewFromKcap(buf []byte) (Handle, error) {
	h := Handle{}
	err := h.Unmarshal(buf)
	if err != nil {
		return Handle{}, err
	}
	return h, nil
}

// AlpcPortInfo stores ALPC port basic information.
type AlpcPortInfo struct {
	Flags   uint32
	Seqno   uint32
	Context uintptr
}

// MutantInfo stores metadata about particular mutant object.
type MutantInfo struct {
	Count       int32
	IsAbandoned bool
}

// FileInfo contains file handle metadata.
type FileInfo struct {
	IsDirectory bool
}

// String returns the string representation of all handles.
func (handles Handles) String() string {
	var sb strings.Builder
	for _, h := range handles {
		sb.WriteString(h.String() + " | ")
	}
	return strings.TrimSuffix(sb.String(), " | ")
}

```

`pkg/kcap/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import "time"

// Config stores options that influences the behaviour of the kernel capture reader/writer.
type Config struct {
	FlushPeriod time.Duration
}

```

`pkg/kcap/header.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
)

// magic has two purposes. It is used to identify kcap files. The magic is stored within the first 8 bytes of the file.
// The reader ensures the magic number matches this constant. Besides identifying the capture file, it serves as an
// input for initializing the byte order on the machine where kcap file is read. This implies capture can be taken on a
// machine with different endianness from the one capture is replayed.
const magic = 0x6669627261747573

// major represents the major digit of the kcap file format. Incrementing the major digit makes older kcap readers not
// capable to replay the capture file.
const major = uint8(1)

// minor represents the minor digit of the kcap file format
const minor = uint8(0)

// flags denotes extra flags for the purpose of the header description
const flags = uint64(0)

// ws writes the section block with the specified parameters.
func (w *writer) ws(typ section.Type, ver kcapver.Version, l, size uint32) error {
	sec := section.New(typ, ver, l, size)
	if _, err := w.zw.Write(sec[:]); err != nil {
		return errWriteSection(typ, err)
	}
	return nil
}

```

`pkg/kcap/reader.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
)

var (
	errKcapMagicMismatch = errors.New("invalid kcap file magic number")
	errMajorVer          = errors.New("incompatible kcap version format. Please upgrade Fibratus to newer version")
	errReadVersion       = func(s string, err error) error { return fmt.Errorf("couldn't read %s version digit: %v", s, err) }
	errReadSection       = func(s section.Type, err error) error { return fmt.Errorf("couldn't read %s section: %v", s, err) }

	kcapReadKevents           = expvar.NewInt("kcap.read.kevents")
	kcapReadBytes             = expvar.NewInt("kcap.read.bytes")
	kcapKeventUnmarshalErrors = expvar.NewInt("kcap.kevent.unmarshal.errors")
	kcapHandleUnmarshalErrors = expvar.NewInt("kcap.reader.handle.unmarshal.errors")
	kcapDroppedByFilter       = expvar.NewInt("kcap.reader.dropped.by.filter")
)

```

`pkg/kcap/reader_unsupported.go`:

```go
//go:build !kcap
// +build !kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
)

// NewReader returns unsupported reader.
func NewReader(filename string, config *config.Config) (Reader, error) {
	return nil, kerrors.ErrFeatureUnsupported("kcap")
}

```

`pkg/kcap/reader_windows.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"context"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	log "github.com/sirupsen/logrus"
	zstd "github.com/valyala/gozstd"
	"io"
	"os"
	"path/filepath"
	"sync"
)

type reader struct {
	zr           *zstd.Reader
	f            *os.File
	psnapshotter ps.Snapshotter
	hsnapshotter handle.Snapshotter
	filter       filter.Filter
	config       *config.Config
	mu           sync.Mutex // guards the underlying zstd byte buffer
}

// NewReader builds a new instance of the kcap reader.
func NewReader(filename string, config *config.Config) (Reader, error) {
	if filepath.Ext(filename) == "" {
		filename += ".kcap"
	}
	f, err := os.Open(filename)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("%q capture file does not exist", filename)
		}
		return nil, err
	}
	zr := zstd.NewReader(f)

	mag := make([]byte, 8)
	if n, err := zr.Read(mag); err != nil || n != 8 {
		return nil, errKcapMagicMismatch
	}
	bytes.InitNativeEndian(mag)
	// from now on all byte reads will use the endianness of the magic number.
	// This guarantees we'll be able to replay kcaptures that were taken
	// on a machine with a different endianness from the machine where
	// actual kcapture is being read.
	if bytes.ReadUint64(mag) != magic {
		return nil, errKcapMagicMismatch
	}

	maj := make([]byte, 1)
	min := make([]byte, 1)

	if n, err := zr.Read(maj); err != nil || n != 1 {
		return nil, errReadVersion("major", err)
	}
	if n, err := zr.Read(min); err != nil || n != 1 {
		return nil, errReadVersion("minor", err)
	}
	if maj[0] < major {
		return nil, errMajorVer
	}

	// read the flags bit vector but do nothing with it at the moment
	flags := make([]byte, 8)
	if n, err := zr.Read(flags); err != nil || n != 8 {
		return nil, fmt.Errorf("fail to read kcap flags: %v", err)
	}

	return &reader{f: f, zr: zr, config: config}, nil
}

func (r *reader) SetFilter(f filter.Filter) { r.filter = f }

func (r *reader) Read(ctx context.Context) (chan *kevent.Kevent, chan error) {
	errsc := make(chan error, 100)
	keventsc := make(chan *kevent.Kevent, 2000)
	go func() {
		r.mu.Lock()
		defer r.mu.Unlock()
		for {
			select {
			case <-ctx.Done():
				return
			default:
			}

			var sec section.Section
			if _, err := io.ReadFull(r.zr, sec[:]); err != nil {
				if err != io.EOF {
					errsc <- err
					continue
				}
				break
			}

			l := sec.Size()
			buf := make([]byte, l)
			if _, err := io.ReadFull(r.zr, buf); err != nil {
				if err != io.EOF {
					errsc <- err
					continue
				}
				break
			}
			kevt, err := kevent.NewFromKcap(buf)
			if err != nil {
				errsc <- fmt.Errorf("fail to unmarshal kevent: %v", err)
				kcapKeventUnmarshalErrors.Add(1)
				continue
			}
			kcapReadBytes.Add(int64(len(buf)))
			// update the state of the ps/handle snapshotters
			if err := r.updateSnapshotters(kevt); err != nil {
				log.Warn(err)
			}
			// push the event to the chanel
			r.read(kevt, keventsc)
		}
	}()

	return keventsc, errsc
}

func (r *reader) Close() error {
	r.mu.Lock()
	defer r.mu.Unlock()
	if r.zr != nil {
		r.zr.Release()
	}
	if r.f != nil {
		return r.f.Close()
	}
	return nil
}

func (r *reader) read(kevt *kevent.Kevent, keventsc chan *kevent.Kevent) {
	if kevt.Type.Dropped(false) {
		return
	}
	if r.filter != nil && !r.filter.Run(kevt) {
		kcapDroppedByFilter.Add(1)
		return
	}
	keventsc <- kevt
	kcapReadKevents.Add(1)
}

func (r *reader) updateSnapshotters(kevt *kevent.Kevent) error {
	switch kevt.Type {
	case ktypes.TerminateThread,
		ktypes.TerminateProcess,
		ktypes.UnloadImage:
		if err := r.psnapshotter.Remove(kevt); err != nil {
			return err
		}
	case ktypes.CreateProcess,
		ktypes.CreateThread,
		ktypes.LoadImage,
		ktypes.EnumImage,
		ktypes.EnumProcess,
		ktypes.EnumThread:
		if err := r.psnapshotter.WriteFromKcap(kevt); err != nil {
			return err
		}
	case ktypes.CreateHandle:
		if err := r.hsnapshotter.Write(kevt); err != nil {
			return err
		}
	case ktypes.CloseHandle:
		if err := r.hsnapshotter.Remove(kevt); err != nil {
			return err
		}
	}
	if kevt.PS == nil {
		kevt.PS = r.psnapshotter.Find(kevt.PID)
	}
	return nil
}

func (r *reader) RecoverSnapshotters() (handle.Snapshotter, ps.Snapshotter, error) {
	hsnap, err := r.recoverHandleSnapshotter()
	if err != nil {
		return nil, nil, err
	}
	r.psnapshotter = ps.NewSnapshotterFromKcap(hsnap, r.config)
	return hsnap, r.psnapshotter, nil
}

func (r *reader) recoverHandleSnapshotter() (handle.Snapshotter, error) {
	var sec section.Section
	if _, err := io.ReadFull(r.zr, sec[:]); err != nil {
		return nil, errReadSection(section.Handle, err)
	}
	nbHandles := sec.Len()
	handles := make([]htypes.Handle, nbHandles)
	for i := 0; i < int(nbHandles); i++ {
		b := make([]byte, 2)
		if _, err := io.ReadFull(r.zr, b); err != nil {
			continue
		}

		l := bytes.ReadUint16(b)
		b = make([]byte, l)
		if _, err := io.ReadFull(r.zr, b); err != nil {
			continue
		}

		var err error
		handles[i], err = htypes.NewFromKcap(b)
		if err != nil {
			kcapHandleUnmarshalErrors.Add(1)
		}
	}
	r.hsnapshotter = handle.NewFromKcap(handles)
	return r.hsnapshotter, nil
}

```

`pkg/kcap/reader_windows_test.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"context"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestRead(t *testing.T) {
	r, err := NewReader("_fixtures/cap1.kcap", &config.Config{})
	if err != nil {
		t.Fatal(err)
	}
	defer r.Close()
	_, _, err = r.RecoverSnapshotters()
	require.NoError(t, err)

	ctx, cancel := context.WithCancel(context.Background())

	kevtsc, errs := r.Read(ctx)
	i := 0
	for {
		select {
		case kevt := <-kevtsc:
			require.NotNil(t, kevt)
			require.True(t, kevt.Seq > 0)
			i++
			if i == 90 {
				cancel()
				return
			}
		case err := <-errs:
			t.Fatal(t, err)
		}
	}
}

```

`pkg/kcap/section/section.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package section

import (
	"fmt"
	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
)

// Section represents the header describing the type, length and the version of each section.
type Section [10]byte

// String returns the string representation of the kcap section.
func (s Section) String() string {
	return fmt.Sprintf("type: %s, version: %d, len: %d, size: %d", s.Type(), s.Version(), s.Len(), s.Size())
}

// New builds a new section block with the specified type, version, optional length and size.
func New(typ Type, ver kcapver.Version, l, size uint32) Section {
	var s Section
	s[0] = uint8(typ)
	s[1] = uint8(ver)
	copy(s[2:6], bytes.WriteUint32(l))
	copy(s[6:], bytes.WriteUint32(size))
	return s
}

// Read reads the section from the byte slice.
func Read(b []byte) Section {
	var s Section
	copy(s[:], b)
	return s
}

// Type returns the type of this section.
func (s Section) Type() Type { return Type(s[0]) }

// Version returns the version of the captured section block.
func (s Section) Version() kcapver.Version { return kcapver.Version(s[1]) }

// Len returns the length of the section.
func (s Section) Len() uint32 { return bytes.ReadUint32(s[2:6]) }

// Size returns the size of the section.
func (s Section) Size() uint32 { return bytes.ReadUint32(s[6:]) }

```

`pkg/kcap/section/section_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package section

// Type describes the type of a section
type Type uint8

const (
	// Process is the process header type
	Process Type = iota + 1
	// Handle is the handle header type
	Handle
	// Kevt is the kernel event header type
	Kevt
	// PE is the Portable Executable header type
	PE
)

// String returns the type name.
func (s Type) String() string {
	switch s {
	case Process:
		return "process"
	case Handle:
		return "handle"
	case Kevt:
		return "kevent"
	case PE:
		return "pe"
	default:
		return ""
	}
}

```

`pkg/kcap/section/section_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package section

import (
	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestSection(t *testing.T) {
	s := New(Process, kcapver.ProcessSecV1, uint32(2456), uint32(30000))
	assert.Equal(t, Process, s.Type())
	assert.Equal(t, kcapver.ProcessSecV1, s.Version())
	assert.Equal(t, uint32(2456), s.Len())
	assert.Equal(t, uint32(30000), s.Size())
}

```

`pkg/kcap/types_linux.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

type Writer interface {
	// Write accepts two channels. The event channel receives events pushed by the kstream consumer. When the event
	// is peeked from the channel, it is serialized and written to the underlying byte buffer.
	Write(chan *kevent.Kevent, chan error) chan error
	// Close disposes all resources allocated by the writer.
	Close() error
}

// Reader offers the mechanism for recovering the state of the kcapture and replaying all captured events.
type Reader interface {
	// Read returns two channels. The event channel is poplated with event instances pulled from the kcap. If
	// any error occurs during kcap processing, it is pushed to the error channel.
	Read(ctx context.Context) (chan *kevent.Kevent, chan error)
	// Close shutdowns the reader gracefully.
	Close() error
	// SetFilter sets the filter that's is applied to each event coming out of the kcap.
	SetFilter(f filter.Filter)
}

```

`pkg/kcap/types_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"context"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

// Writer is the minimal interface that all kcap writers need to satisfy. The Windows kcap
// file format has the layout as depicted in the following diagram:
//
//  +-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-++-+-+-+
//  | Magic Number  | Major | Minor | Flags |
//	|----------------------------------------
//  | Handle Section |       Handles        |
//  -----------------------------------------
//  | Kevt Section | Kevt ..................|
// 	| ......................................|
//	| ......................................|
//	| ......................................|
//  | ........ Kevt Section n  Kevt n  EOF  |
//  +-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-++-+-+-+
//
type Writer interface {
	// Write accepts two channels. The event channel receives events pushed by the kstream consumer. When the event
	// is peeked from the channel, it is serialized and written to the underlying byte buffer.
	Write(chan *kevent.Kevent, chan error) chan error
	// Close disposes all resources allocated by the writer.
	Close() error
}

// Reader offers the mechanism for recovering the state of the kcapture and replaying all captured events.
type Reader interface {
	// Read returns two channels. The event channel is poplated with event instances pulled from the kcap. If
	// any error occurs during kcap processing, it is pushed to the error channel.
	Read(ctx context.Context) (chan *kevent.Kevent, chan error)
	// Close shutdowns the reader gracefully.
	Close() error
	// RecoverSnapshotters recovers the statate of the snapshotters from the kcap.
	RecoverSnapshotters() (handle.Snapshotter, ps.Snapshotter, error)
	// SetFilter sets the filter that's is applied to each event coming out of the kcap.
	SetFilter(f filter.Filter)
}

```

`pkg/kcap/version/version_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package version

// Version designates the type for specifying the current section version.
type Version uint16

const (
	// KevtSecV1 is the v1 of the kernel event section
	KevtSecV1 Version = iota + 1
)

const (
	// ProcessSecV1 is the v1 of the process section
	ProcessSecV1 Version = iota + 1
)

const (
	// HandleSecV1 is the v1 of the handle section
	HandleSecV1 Version = iota + 1
)

const (
	// PESecV1 is the v1 of the PE section
	PESecV1 Version = iota + 1
)

```

`pkg/kcap/writer.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
	"math"
)

var (
	errWriteMagic   = func(err error) error { return fmt.Errorf("couldn't write magic number: %v", err) }
	errWriteVersion = func(v string, err error) error { return fmt.Errorf("couldn't write %s kcap digit: %v", v, err) }
	errWriteSection = func(s section.Type, err error) error { return fmt.Errorf("couldn't write %s kcap section: %v", s, err) }

	handleWriteErrors     = expvar.NewInt("kcap.handle.write.errors")
	kevtWriteErrors       = expvar.NewInt("kcap.kevt.write.errors")
	flusherErrors         = expvar.NewMap("kcap.flusher.errors")
	overflowKevents       = expvar.NewInt("kcap.overflow.kevents")
	kstreamConsumerErrors = expvar.NewInt("kcap.kstream.consumer.errors")
)

const maxKevtSize = math.MaxUint32

```

`pkg/kcap/writer_unsupported.go`:

```go
//go:build !kcap
// +build !kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

// NewWriter returns unsupported writer.
func NewWriter(filename string, psnap ps.Snapshotter, hsnap handle.Snapshotter) (Writer, error) {
	return nil, kerrors.ErrFeatureUnsupported("kcap")
}

```

`pkg/kcap/writer_windows.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"sync/atomic"
	"time"

	"github.com/dustin/go-humanize"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	zstd "github.com/valyala/gozstd"
)

type stats struct {
	kcapFile string

	kevtsWritten   uint64
	bytesWritten   uint64
	handlesWritten uint64
	procsWritten   uint64

	pids map[uint32]bool
}

func (s *stats) incKevts(kevt *kevent.Kevent) {
	switch kevt.Type {
	case ktypes.FileRundown, ktypes.RegCreateKCB, ktypes.FileOpEnd,
		ktypes.EnumProcess, ktypes.EnumThread, ktypes.EnumImage, ktypes.RegKCBRundown:
	default:
		atomic.AddUint64(&s.kevtsWritten, 1)
	}
}
func (s *stats) incBytes(bytes uint64) { atomic.AddUint64(&s.bytesWritten, bytes) }
func (s *stats) incHandles()           { atomic.AddUint64(&s.handlesWritten, 1) }
func (s *stats) incProcs(kevt *kevent.Kevent) {
	// EnumProcess events can arrive twice for the same kernel session, so we
	// ignore incrementing the number of processes if we've already seen the process
	if kevt.Type == ktypes.EnumProcess {
		pid, _ := kevt.Kparams.GetPid()
		if _, ok := s.pids[pid]; ok {
			return
		}
		s.pids[pid] = true
	}
	if kevt.Type == ktypes.CreateProcess || kevt.Type == ktypes.EnumProcess {
		atomic.AddUint64(&s.procsWritten, 1)
	}
}

func (s *stats) printStats() {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.SetTitle("Capture Statistics")
	t.SetStyle(table.StyleLight)

	t.AppendRow(table.Row{"File", filepath.Base(s.kcapFile)})
	t.AppendSeparator()

	t.AppendRow(table.Row{"Events written", atomic.LoadUint64(&s.kevtsWritten)})
	t.AppendRow(table.Row{"Bytes written", atomic.LoadUint64(&s.bytesWritten)})
	t.AppendRow(table.Row{"Processes written", atomic.LoadUint64(&s.procsWritten)})
	t.AppendRow(table.Row{"Handles written", atomic.LoadUint64(&s.handlesWritten)})

	f, err := os.Stat(s.kcapFile)
	if err != nil {
		t.Render()
		return
	}
	t.AppendSeparator()
	t.AppendRow(table.Row{"Capture size", humanize.Bytes(uint64(f.Size()))})

	t.Render()
}

type writer struct {
	zw      *zstd.Writer
	f       *os.File
	flusher *time.Ticker
	psnap   ps.Snapshotter
	hsnap   handle.Snapshotter
	stop    chan struct{}
	// stats contains the capture statistics
	stats *stats
	// mu protects the underlying zstd buffer
	mu sync.Mutex
}

// NewWriter constructs a new instance of the kcap writer.
func NewWriter(filename string, psnap ps.Snapshotter, hsnap handle.Snapshotter) (Writer, error) {
	if filepath.Ext(filename) == "" {
		filename += ".kcap"
	}
	f, err := os.Create(filename)
	if err != nil {
		return nil, err
	}
	zw := zstd.NewWriter(f)
	// start by writing the kcap header that is comprised
	// of magic number, major/minor digits and the optional
	// flags bit vector. The flags bit vector is reserved
	// for the future uses.
	// The header is followed by the handle snapshot.
	// It contains the current state of the system handles
	// at the time the capture was started.
	// Handle snapshots are prepended with a section
	// that describes the version and the number of handles
	// in the snapshot. This information is used by the reader to
	// restore the state of the snapshotters.
	if _, err := zw.Write(bytes.WriteUint64(magic)); err != nil {
		return nil, errWriteMagic(err)
	}
	if _, err := zw.Write([]byte{major}); err != nil {
		return nil, errWriteVersion("major", err)
	}
	if _, err := zw.Write([]byte{minor}); err != nil {
		return nil, errWriteVersion("minor", err)
	}
	if _, err := zw.Write(bytes.WriteUint64(flags)); err != nil {
		return nil, err
	}

	w := &writer{
		zw:      zw,
		f:       f,
		flusher: time.NewTicker(time.Second),
		psnap:   psnap,
		hsnap:   hsnap,
		stop:    make(chan struct{}),
		stats:   &stats{kcapFile: filename, pids: make(map[uint32]bool)},
	}

	if err := w.writeSnapshots(); err != nil {
		return nil, err
	}

	go w.flush()

	return w, nil
}

func (w *writer) writeSnapshots() error {
	handles := w.hsnap.GetSnapshot()
	// write handle section and the data blocks
	err := w.ws(section.Handle, kcapver.HandleSecV1, uint32(len(handles)), 0)
	if err != nil {
		return err
	}
	for _, khandle := range handles {
		if err := w.writeHandle(khandle.Marshal()); err != nil {
			handleWriteErrors.Add(1)
			continue
		}
		w.stats.incHandles()
	}
	return w.zw.Flush()
}

func (w *writer) Write(kevtsc chan *kevent.Kevent, errs chan error) chan error {
	errsc := make(chan error, 100)
	go func() {
		for {
			select {
			case kevt := <-kevtsc:
				b := kevt.MarshalRaw()
				l := len(b)
				if l == 0 {
					continue
				}
				// write event buffer
				err := w.write(b)
				if err != nil {
					errs <- err
					kevt.Release()
					continue
				}
				// update stats
				w.stats.incKevts(kevt)
				w.stats.incBytes(uint64(l))
				w.stats.incProcs(kevt)
				// return to pool
				kevt.Release()
			case err := <-errs:
				errsc <- err
				kstreamConsumerErrors.Add(1)
			case <-w.stop:
				return
			}
		}
	}()
	return errsc
}

func (w *writer) write(b []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()
	l := len(b)
	if l > maxKevtSize {
		overflowKevents.Add(1)
		return fmt.Errorf("kevent size overflow by %d bytes", l-maxKevtSize)
	}
	if err := w.ws(section.Kevt, kcapver.KevtSecV1, 0, uint32(l)); err != nil {
		kevtWriteErrors.Add(1)
		return err
	}
	if _, err := w.zw.Write(b); err != nil {
		kevtWriteErrors.Add(1)
		return err
	}
	return nil
}

func (w *writer) Close() error {
	w.stats.printStats()

	w.flusher.Stop()
	w.stop <- struct{}{}
	w.mu.Lock()
	defer w.mu.Unlock()

	if w.zw != nil {
		if err := w.zw.Close(); err != nil {
			return err
		}
		w.zw.Release()
	}
	if w.f != nil {
		return w.f.Close()
	}
	return nil
}

func (w *writer) flush() {
	for {
		<-w.flusher.C
		w.mu.Lock()
		err := w.zw.Flush()
		w.mu.Unlock()
		if err != nil {
			flusherErrors.Add(err.Error(), 1)
		}
	}
}

func (w *writer) writeHandle(buf []byte) error {
	l := bytes.WriteUint16(uint16(len(buf)))
	if _, err := w.zw.Write(l); err != nil {
		return err
	}
	if _, err := w.zw.Write(buf); err != nil {
		return err
	}
	return nil
}

```

`pkg/kcap/writer_windows_test.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kcap

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/kstream"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestWrite(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)

	procs := []*pstypes.PS{
		{PID: 8390, Ppid: 1096, Name: "spotify.exe", Exe: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`, Comm: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`, Cwd: `C:\Users\admin\AppData\Roaming\Spotify`, SID: "admin\\SYSTEM"},
		{PID: 2436, Ppid: 6304, Name: "firefox.exe", Exe: `C:\Program Files\Mozilla Firefox\firefox.exe`, Comm: `C:\Program Files\Mozilla Firefox\firefox.exe" -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`, Cwd: `C:\Program Files\Mozilla Firefox\`, SID: "archrabbit\\SYSTEM"},
	}

	handles := []htypes.Handle{
		{Pid: 8390, Name: "C:\\Windows", Type: "File"},
		{Pid: 8390, Name: "C:\\Windows\\System32", Type: "File"},
	}

	psnap.On("GetSnapshot").Return(procs)
	psnap.On("Size").Return(len(procs))

	hsnap.On("GetSnapshot").Return(handles)

	w, err := NewWriter("_fixtures/cap.kcap", psnap, hsnap)
	require.NoError(t, err)
	require.NotNil(t, w)
	defer w.Close()

	kevtsc := make(chan *kevent.Kevent, 100)
	errs := make(chan error, 10)

	for i := 0; i < 100; i++ {
		kevt := &kevent.Kevent{
			Type:        ktypes.CreateFile,
			Tid:         2484,
			PID:         859,
			CPU:         uint8(i / 2),
			Seq:         uint64(i + 1),
			Name:        "CreateFile",
			Timestamp:   time.Now(),
			Category:    ktypes.File,
			Host:        "archrabbit",
			Description: "Creates or opens a new file, directory, I/O device, pipe, console",
			Kparams: kevent.Kparams{
				kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
				kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
				kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
				kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			},
			Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "barz"},
			PS: &pstypes.PS{
				PID:       2436,
				Ppid:      6304,
				Name:      "firefox.exe",
				Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
				Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
				Cwd:       `C:\Program Files\Mozilla Firefox\`,
				SID:       "archrabbit\\SYSTEM",
				Args:      []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
				SessionID: 4,
				Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
				Handles: []htypes.Handle{
					{
						Num:    shandle.Handle(0xffffd105e9baaf70),
						Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
						Type:   "Key",
						Object: 777488883434455544,
						Pid:    uint32(1023),
					},
					{
						Num:    shandle.Handle(0xe1ffd105e9baaf70),
						Type:   "Event",
						Object: 777488883434455544,
						Pid:    uint32(1023),
					},
					{
						Type: "Event",
					},
					{
						Num:  shandle.Handle(0xe1ecd105e9baaf70),
						Type: "Event",
						Pid:  uint32(1023),
					},
					{
						Num:  shandle.Handle(0xffffd105e9adaf70),
						Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
						Type: "ALPC Port",
						Pid:  uint32(1023),
						MD: &htypes.AlpcPortInfo{
							Seqno:   1,
							Context: 0x0,
							Flags:   0x0,
						},
						Object: 457488883434455544,
					},
					{
						Num:  shandle.Handle(0xeaffd105e9adaf30),
						Name: `C:\Users\bunny`,
						Type: "File",
						Pid:  uint32(1023),
						MD: &htypes.FileInfo{
							IsDirectory: true,
						},
						Object: 357488883434455544,
					},
				},
			},
		}
		if i%2 == 0 {
			kevt.PS.Handles = append(kevt.PS.Handles, htypes.Handle{})
		}
		kevtsc <- kevt
	}

	werrs := w.Write(kevtsc, errs)
	quit := make(chan struct{}, 1)
	time.AfterFunc(time.Second*5, func() {
		quit <- struct{}{}
	})
	select {
	case err := <-werrs:
		t.Fatal(err)
	case <-quit:
		return
	}
}

func TestLiveKcap(t *testing.T) {
	t.SkipNow()
	cfg := &config.Config{
		Kstream: config.KstreamConfig{
			EnableFileIOKevents:   true,
			EnableImageKevents:    true,
			EnableRegistryKevents: true,
			EnableNetKevents:      true,
			EnableThreadKevents:   true,
			EnableHandleKevents:   true,
		},
		KcapFile:           "../../test.kcap",
		Filters:            &config.Filters{},
		InitHandleSnapshot: true,
	}
	wait := make(chan struct{}, 1)
	cb := func(total uint64, withName uint64) {
		wait <- struct{}{}
	}
	hsnap := handle.NewSnapshotter(cfg, cb)
	psnap := ps.NewSnapshotter(hsnap, cfg)

	<-wait

	// initiate the kernel trace and start consuming from the event stream
	ktracec := kstream.NewKtraceController(cfg.Kstream)
	err := ktracec.StartKtrace()
	if err != nil {
		t.Fatal(err)
	}

	kstreamc := kstream.NewConsumer(ktracec, psnap, hsnap, cfg)
	if err != nil {
		t.Fatal(err)
	}

	err = kstreamc.OpenKstream(ktracec.Traces())
	if err != nil {
		t.Fatal(err)
	}

	// bootstrap kcap writer with inbound event channel
	writer, err := NewWriter(cfg.KcapFile, psnap, hsnap)
	if err != nil {
		t.Fatal(err)
	}
	writer.Write(kstreamc.Events(), kstreamc.Errors())

	// capture for a minute
	<-time.After(time.Minute)

	writer.Close()

	_ = kstreamc.CloseKstream()
	_ = ktracec.CloseKtrace()
}

```

`pkg/kevent/README.md`:

```md
`Kevent` is the fundamental data structure for transporting kernel events.

Each kernel event structure contains a series of canonical fields that describe the nature of the event such as its name, the process identifier that generated the event and such. The following is the list of all canonical fields.

- **Sequence** is a monotonically increasing integer value that uniquely identifies an event. The sequence value is guaranteed to increment monotonically as long as the machine is not rebooted. After the restart, the sequence is restored to the zero value.
- **PID** represents the process identifier that triggered the kernel event.
- **TID** is the thread identifier connected to the kernel event.
- **CPU** designates the logical CPU core on which the event was originated.
- **Name** is the human-readable event name such as `CreateProcess` or `RegOpenKey`.
- **Timestamp** denotes the timestamp expressed in nanosecond precision as the instant the event occurred.
- **Category** designates the category to which the event pertains, e.g. `file` or `thread`. Each particular category is explained thoroughly in the next
 sections.
- **Description** is a short explanation about the purpose of the event. For example, `CreateFile` kernel event creates or opens a file, directory, I/O device, pipe, console buffer or other block/pseudo device.
- **Host** represents the host name where the event was produced.

### Parameters

Also called as `kparams` in Fibratus parlance, contain each of the event's parameters. Internally, they are modeled as a collection of key/value pairs where the key is mapped to the structure consisting of parameter name, parameter type and the value. An example of the parameter tuple could be the `dip` parameter
that denotes a destination IP address with value `172.17.0.2` and therefore `IPv4` type. Additionally, parameter types can be scalar values, strings, slices, enumerations, and timestamps among others.

### Process state

Each event stores the process state that represents an extended information about the process including its allocated resources such as handles, dynamically-linked libraries, exported environment variables and other attributes. The process state internals are thoroughly explained in the [Process](/kevents/process) events section.

### Metadata

Metadata are an arbitrary sequence of tags in form of key/value pairs that you can squash into the event on behalf of [transformers](/transformers/introduction). A tag can be virtually any string data that you find meaningful to either identify the event or apply filtering/grouping once event is persisted in the data store.

```

`pkg/kevent/_fixtures/handles.json`:

```json
[
	{
		"id": 4,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options"
	},
	{
		"id": 16,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 20,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 24,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 28,
		"object": 0,
		"type": "TpWorkerFactory",
		"name": ""
	},
	{
		"id": 32,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 36,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 40,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 44,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 60,
		"object": 0,
		"type": "Directory",
		"name": "\\KnownDlls"
	},
	{
		"id": 64,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 68,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 88,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager"
	},
	{
		"id": 92,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 196608,
			"Seqno": 77,
			"Context": 92
		}
	},
	{
		"id": 100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 112,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MSF\\Registration\\Listen"
	},
	{
		"id": 116,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 128,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Nls\\Sorting\\Versions"
	},
	{
		"id": 140,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 144,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 148,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE"
	},
	{
		"id": 152,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Ole"
	},
	{
		"id": 156,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 160,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft"
	},
	{
		"id": 164,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings"
	},
	{
		"id": 168,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 180,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 188,
		"object": 0,
		"type": "Directory",
		"name": "\\Sessions\\1\\BaseNamedObjects"
	},
	{
		"id": 232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 236,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 240,
		"object": 0,
		"type": "WindowStation",
		"name": "\\Sessions\\1\\Windows\\WindowStations\\WinSta0"
	},
	{
		"id": 244,
		"object": 0,
		"type": "Desktop",
		"name": "\\Default"
	},
	{
		"id": 248,
		"object": 0,
		"type": "WindowStation",
		"name": "\\Sessions\\1\\Windows\\WindowStations\\WinSta0"
	},
	{
		"id": 396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 420,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 424,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 428,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 488,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 492,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 536,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:304:WilStaging_02_p0"
	},
	{
		"id": 540,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:304:WilStaging_02_p0h"
	},
	{
		"id": 576,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER"
	},
	{
		"id": 580,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 196608,
			"Seqno": 1,
			"Context": 580
		}
	},
	{
		"id": 588,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 592,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Nls\\Sorting\\Ids"
	},
	{
		"id": 596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 632,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 648,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 664,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:4040c"
	},
	{
		"id": 668,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 672,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SessionImmersiveColorPreference"
	},
	{
		"id": 684,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 688,
		"object": 0,
		"type": "Section",
		"name": "\\BaseNamedObjects\\__ComCatalogCache__"
	},
	{
		"id": 696,
		"object": 0,
		"type": "Event",
		"name": "\\KernelObjects\\MaximumCommitCondition"
	},
	{
		"id": 700,
		"object": 0,
		"type": "Section",
		"name": "\\BaseNamedObjects\\__ComCatalogCache__"
	},
	{
		"id": 708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 712,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 716,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 728,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 748,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 752,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\windows_shell_global_counters"
	},
	{
		"id": 756,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 760,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:120:WilError_02_p0h"
	},
	{
		"id": 764,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 768,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:120:WilError_02_p0"
	},
	{
		"id": 772,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 780,
		"object": 0,
		"type": "Section",
		"name": "\\BaseNamedObjects\\windows_shell_global_counters"
	},
	{
		"id": 784,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\PropertyBag"
	},
	{
		"id": 788,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 792,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{f42ee2d3-909f-4907-8871-4c22fc0bf756}\\PropertyBag"
	},
	{
		"id": 796,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{a0c69a99-21c8-4671-8703-7934162fcf1d}\\PropertyBag"
	},
	{
		"id": 800,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{0ddd015d-b06c-45d5-8c4c-f59713854639}\\PropertyBag"
	},
	{
		"id": 804,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{35286a68-3c57-41a1-bbb1-0eae73d76c95}\\PropertyBag"
	},
	{
		"id": 812,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{7d83ee9b-2244-4e70-b1f5-5393042af1e4}\\PropertyBag"
	},
	{
		"id": 816,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 662,
			"Context": 5849088
		}
	},
	{
		"id": 824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 832,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 836,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\StateRepository.SecondaryTileUserNotificationChannel.{45F7AD0F-AB53-4EB1-B5A8-7091C8251662}"
	},
	{
		"id": 844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 848,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 856,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsRuntime"
	},
	{
		"id": 860,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 20385,
			"Context": 860
		}
	},
	{
		"id": 864,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:890794"
	},
	{
		"id": 868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 872,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34209792,
			"Seqno": 46,
			"Context": 0
		}
	},
	{
		"id": 880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 888,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 892,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 896,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 900,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 912,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 916,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsRuntime\\ActivatableClassId"
	},
	{
		"id": 928,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 928
		}
	},
	{
		"id": 940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\MSF\\Registration\\Listen"
	},
	{
		"id": 944,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 952,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 972,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 976,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 980,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 984,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 45,
			"Context": 984
		}
	},
	{
		"id": 996,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1004,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsRuntime\\Server"
	},
	{
		"id": 1008,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1016,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1020,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 3,
			"Context": 100344272
		}
	},
	{
		"id": 1032,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1036,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1040,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1064,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1068,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:404e6"
	},
	{
		"id": 1084,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1088,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1096,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1104,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1112,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1120,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*Users*bunny*AppData*Local*Microsoft*Windows*Caches*cversions.3.ro"
	},
	{
		"id": 1132,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1184,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Tcpip\\Parameters\\Interfaces"
	},
	{
		"id": 1188,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Tcpip6\\Parameters\\Interfaces"
	},
	{
		"id": 1212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1224,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 4,
			"Context": 1224
		}
	},
	{
		"id": 1228,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 36,
			"Context": 100339568
		}
	},
	{
		"id": 1232,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppModel\\Deployment\\Package\\*\\S-1-5-21-2271034452-2606270099-984871569-1001\\{A2595E0B-CF05-4E86-A18B-7B8B98616B5F}"
	},
	{
		"id": 1236,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1240,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1244,
		"object": 0,
		"type": "TpWorkerFactory",
		"name": ""
	},
	{
		"id": 1248,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 1252,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1256,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 1260,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1268,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 5931,
			"Context": 1268
		}
	},
	{
		"id": 1272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1296,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1304,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1308,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1312,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\TermSrvReadyEvent"
	},
	{
		"id": 1320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1364,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 22,
			"Context": 1364
		}
	},
	{
		"id": 1368,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1372,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1388,
		"object": 0,
		"type": "Section",
		"name": "\\Windows\\Theme4136432297"
	},
	{
		"id": 1392,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\Windows\\Theme4282677873"
	},
	{
		"id": 1396,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100e4"
	},
	{
		"id": 1400,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1404,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\StateRepository.SecondaryTileUserNotificationChannel.{55CC93E3-1E5B-40A9-BD6A-6705CAFF7649}"
	},
	{
		"id": 1408,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1440,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1452,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1460,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100e4"
	},
	{
		"id": 1500,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SessionImmersiveColorPreference"
	},
	{
		"id": 1548,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1560,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1568,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1572,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1584,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1588,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1592,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1596,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1600,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1604,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1608,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1612,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1636,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1640,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1648,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1656,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*cversions.2.ro"
	},
	{
		"id": 1660,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*cversions.2.ro"
	},
	{
		"id": 1664,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*{6AF0698E-D558-4F6E-9B3C-3716689AF493}.2.ver0x0000000000000001.db"
	},
	{
		"id": 1668,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*{DDF571F2-BE98-426D-8288-1A9A39C3FDA2}.2.ver0x0000000000000001.db"
	},
	{
		"id": 1688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1692,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1696,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache\\Extensible Cache"
	},
	{
		"id": 1700,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
	},
	{
		"id": 1704,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
	},
	{
		"id": 1708,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl"
	},
	{
		"id": 1712,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl"
	},
	{
		"id": 1716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1724,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1010a"
	},
	{
		"id": 1732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1740,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1744,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1748,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1760,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1010a"
	},
	{
		"id": 1764,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10104"
	},
	{
		"id": 1768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1776,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1780,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1792,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop"
	},
	{
		"id": 1796,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1800,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell"
	},
	{
		"id": 1804,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 2107,
			"Context": 1804
		}
	},
	{
		"id": 1808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom\\ClassIndex"
	},
	{
		"id": 1816,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 15,
			"Context": 1816
		}
	},
	{
		"id": 1824,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom"
	},
	{
		"id": 1836,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1860,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1864,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{FDD39AD0-238F-46AF-ADB4-6C85480369C7}\\PropertyBag"
	},
	{
		"id": 1868,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1872,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}\\PropertyBag"
	},
	{
		"id": 1876,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10104"
	},
	{
		"id": 1880,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{F38BF404-1D43-42F2-9305-67DE0B28FC23}\\PropertyBag"
	},
	{
		"id": 1884,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}\\PropertyBag"
	},
	{
		"id": 1892,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts"
	},
	{
		"id": 1896,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1900,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1924,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1928,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1936,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1944,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1964,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Shell"
	},
	{
		"id": 1968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1972,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell"
	},
	{
		"id": 1984,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1988,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2000,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2004,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2008,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2012,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 278,
			"Context": 2012
		}
	},
	{
		"id": 2016,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2028,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{A8CDFF1C-4878-43be-B5FD-F8091C1C60D0}\\Instance"
	},
	{
		"id": 2036,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\CfProgressEvent"
	},
	{
		"id": 2040,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2044,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2052,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2056,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2060,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2064,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2072,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100ec"
	},
	{
		"id": 2076,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100ec"
	},
	{
		"id": 2084,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2088,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 714,
			"Context": 2088
		}
	},
	{
		"id": 2092,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2100,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 206,
			"Context": 67769888
		}
	},
	{
		"id": 2104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2108,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Desktop"
	},
	{
		"id": 2112,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2116,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2120,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2128,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2132,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2136,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2148,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 2148
		}
	},
	{
		"id": 2152,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2180,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2188,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2204,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop"
	},
	{
		"id": 2272,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{767E6811-49CB-4273-87C2-20F355E1085B}\\PropertyBag"
	},
	{
		"id": 2276,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\ApplicationViewManagement"
	},
	{
		"id": 2280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2288,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{24D89E24-2F19-4534-9DDE-6A6671FBB8FE}\\PropertyBag"
	},
	{
		"id": 2292,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{339719B5-8C47-4894-94C2-D8F77ADD44A6}\\PropertyBag"
	},
	{
		"id": 2296,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{52528A6B-B9E3-4add-B60D-588C2DBA842D}\\PropertyBag"
	},
	{
		"id": 2300,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{C3F2459E-80D6-45DC-BFEF-1F769F2BE730}\\PropertyBag"
	},
	{
		"id": 2304,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}\\PropertyBag"
	},
	{
		"id": 2308,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{4BD8D571-6D19-48D3-BE97-422220080E43}\\PropertyBag"
	},
	{
		"id": 2312,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{905e63b6-c1bf-494e-b29c-65b732d3d21a}\\PropertyBag"
	},
	{
		"id": 2316,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{374DE290-123F-4565-9164-39C4925E467B}\\PropertyBag"
	},
	{
		"id": 2320,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{33E28130-4E1E-4676-835A-98395C3BC3BB}\\PropertyBag"
	},
	{
		"id": 2324,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SyncRootManager"
	},
	{
		"id": 2328,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{18989B1D-99B5-455B-841C-AB7C74E4DDFC}\\PropertyBag"
	},
	{
		"id": 2340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2344,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2348,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2360,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2364,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2368,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2372,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2376,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2404,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2412,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2416,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2424,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 2432,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 2436,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2452,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{9B74B6A3-0DFD-4f11-9E78-5F7800F2E772}\\PropertyBag"
	},
	{
		"id": 2456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2460,
		"object": 0,
		"type": "Process",
		"name": "C:\\Windows\\System32\\sihost.exe"
	},
	{
		"id": 2464,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2468,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones"
	},
	{
		"id": 2472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2476,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Current\\default$windows.data.bluelightreduction.settings\\windows.data.bluelightreduction.settings"
	},
	{
		"id": 2496,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2500,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}\\PropertyBag"
	},
	{
		"id": 2504,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{ED4824AF-DCE4-45A8-81E2-FC7965083634}\\PropertyBag"
	},
	{
		"id": 2508,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 2512,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2520,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 2528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2536,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2544,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2548,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:20110"
	},
	{
		"id": 2556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2560,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2572,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2576,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2584,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2596,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 13,
			"Context": 2596
		}
	},
	{
		"id": 2600,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 373,
			"Context": 2600
		}
	},
	{
		"id": 2608,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2620,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2632,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2640,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{3214FAB5-9757-4298-BB61-92A9DEAA44FF}\\PropertyBag"
	},
	{
		"id": 2644,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2656,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2660,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{DE92C1C7-837F-4F69-A3BB-86E631204A23}\\PropertyBag"
	},
	{
		"id": 2668,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2672,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{A990AE9F-A03B-4e80-94BC-9912D7504104}\\PropertyBag"
	},
	{
		"id": 2676,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2680,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2684,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}\\PropertyBag"
	},
	{
		"id": 2688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2692,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2696,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2700,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{2B20DF75-1EDA-4039-8097-38798227D5B7}\\PropertyBag"
	},
	{
		"id": 2704,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\2\\Shell\\{24CCB8A6-C45A-477D-B940-3382B9225668}"
	},
	{
		"id": 2712,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Cloud\\default$windows.data.bluelightreduction.settings\\windows.data.bluelightreduction.settings"
	},
	{
		"id": 2716,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2728,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2740,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:20110"
	},
	{
		"id": 2744,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\ModeTriggerCachedKey"
	},
	{
		"id": 2756,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2772,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2776,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace"
	},
	{
		"id": 2784,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2796,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2800,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2804,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\DelegateFolders"
	},
	{
		"id": 2808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\Instance"
	},
	{
		"id": 2828,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2860,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 99,
			"Context": 2860
		}
	},
	{
		"id": 2864,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_DDEC674B-99D8-42D4-5B17-2C40D71B2989"
	},
	{
		"id": 2868,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2872,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2876,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2884,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 7,
			"Context": 2884
		}
	},
	{
		"id": 2888,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2892,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2904,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{7b0db17d-9cd2-4a93-9733-46cc89022e7c}\\PropertyBag"
	},
	{
		"id": 2912,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\ImmersiveShell\\PersistedApplicationData\\Volatile"
	},
	{
		"id": 2916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2920,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2928,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 42,
			"Context": 2928
		}
	},
	{
		"id": 2932,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2936,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\VirtualDesktops"
	},
	{
		"id": 2940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VirtualDesktops"
	},
	{
		"id": 2948,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2952,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2956,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}\\PropertyBag"
	},
	{
		"id": 2960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2964,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2972,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2976,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2980,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2984,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2988,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2992,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 2996,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3000,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1884,
			"Context": 3000
		}
	},
	{
		"id": 3004,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3008,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3012,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3016,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{2112AB0A-C86A-4ffe-A368-0DE96E47012E}\\PropertyBag"
	},
	{
		"id": 3020,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{E25B5812-BE88-4bd9-94B0-29233477B6C3}\\PropertyBag"
	},
	{
		"id": 3028,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{491E922F-5643-4af4-A7EB-4E7A138D8174}\\PropertyBag"
	},
	{
		"id": 3032,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{2400183A-6185-49FB-A2D8-4A392A602BA3}\\PropertyBag"
	},
	{
		"id": 3036,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3040,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3044,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3048,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{56784854-C6CB-462B-8169-88E350ACB882}\\PropertyBag"
	},
	{
		"id": 3052,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1882,
			"Context": 3052
		}
	},
	{
		"id": 3060,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3064,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager"
	},
	{
		"id": 3068,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{A302545D-DEFF-464b-ABE8-61C8648D939B}\\PropertyBag"
	},
	{
		"id": 3084,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Current\\default$windows.data.bluelightreduction.bluelightreductionstate\\windows.data.bluelightreduction.bluelightreductionstate"
	},
	{
		"id": 3088,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Cloud\\default$windows.data.bluelightreduction.bluelightreductionstate\\windows.data.bluelightreduction.bluelightreductionstate"
	},
	{
		"id": 3092,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3096,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3104,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3116,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3120,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3124,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 3128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3136,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3140,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3156,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3164,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3168,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3176,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 196608,
			"Seqno": 1,
			"Context": 3176
		}
	},
	{
		"id": 3180,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3188,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3196,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3200,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 3204,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\ActivityDataModel\\ReaderRevisionInfo"
	},
	{
		"id": 3208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3216,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3224,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\TabletTip\\1.7"
	},
	{
		"id": 3228,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3232,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3236,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\TabletTip\\1.7"
	},
	{
		"id": 3240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3244,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3268,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3276,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3284,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 3288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3296,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3300,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3304,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3324,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 3328,
		"object": 0,
		"type": "Process",
		"name": "C:\\Windows\\System32\\ApplicationFrameHost.exe"
	},
	{
		"id": 3332,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3336,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3356,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3360,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_B59BF58B-B658-3070-A3B6-D69128DC0AF1"
	},
	{
		"id": 3368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3384,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3412,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3416,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 3386,
			"Context": 3416
		}
	},
	{
		"id": 3420,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10158"
	},
	{
		"id": 3424,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10168"
	},
	{
		"id": 3428,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_12541A3D-DFB6-BD6F-FACE-BB3E6841EB46"
	},
	{
		"id": 3432,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3436,
		"object": 0,
		"type": "TpWorkerFactory",
		"name": ""
	},
	{
		"id": 3440,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 3444,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3448,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 3452,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3456,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\{F6151BD3-458B-4C93-9088-9F6A37F9EE97}"
	},
	{
		"id": 3460,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3464,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3480,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3484,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_FC12EE91-49F1-DC96-0D54-0B587D5A88FC"
	},
	{
		"id": 3492,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:ca0706"
	},
	{
		"id": 3508,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 163,
			"Context": 3508
		}
	},
	{
		"id": 3512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3520,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 406,
			"Context": 3520
		}
	},
	{
		"id": 3532,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3540,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_072CE8F2-A62E-55F4-CE88-CB84F0268487"
	},
	{
		"id": 3544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3552,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize"
	},
	{
		"id": 3556,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3560,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10160"
	},
	{
		"id": 3564,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10160"
	},
	{
		"id": 3568,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10158"
	},
	{
		"id": 3572,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015a"
	},
	{
		"id": 3576,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015a"
	},
	{
		"id": 3580,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015c"
	},
	{
		"id": 3584,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015c"
	},
	{
		"id": 3588,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015e"
	},
	{
		"id": 3592,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015e"
	},
	{
		"id": 3596,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10162"
	},
	{
		"id": 3600,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10162"
	},
	{
		"id": 3604,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10164"
	},
	{
		"id": 3608,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10164"
	},
	{
		"id": 3612,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10166"
	},
	{
		"id": 3616,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3620,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10166"
	},
	{
		"id": 3624,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10168"
	},
	{
		"id": 3632,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3636,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Holographic"
	},
	{
		"id": 3640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3648,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3652,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PerceptionSimulationExtensions"
	},
	{
		"id": 3656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3664,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3668,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3672,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3676,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3680,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3700,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 3704,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3712,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 138,
			"Context": 99580000
		}
	},
	{
		"id": 3716,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3728,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3736,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3740,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3744,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3748,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3752,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3760,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3764,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:ca0706"
	},
	{
		"id": 3768,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3772,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 3776,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3784,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3796,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3800,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 3804,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3812,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3816,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3820,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3828,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 3828
		}
	},
	{
		"id": 3848,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3856,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3860,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3864,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3880,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3884,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3888,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"
	},
	{
		"id": 3912,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PRS_EXTERNAL_CHECK_CHANGED_NOTIFY"
	},
	{
		"id": 3916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3920,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3928,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.undo"
	},
	{
		"id": 3948,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3952,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3956,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3964,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3984,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3988,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 19,
			"Context": 99592368
		}
	},
	{
		"id": 3992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4000,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4012,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 9,
			"Context": 4012
		}
	},
	{
		"id": 4024,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.undo"
	},
	{
		"id": 4028,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4032,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4052,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4072,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 4076,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4080,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 4092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4100,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.help"
	},
	{
		"id": 4104,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4112,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{DFFACDC5-679F-4156-8947-C5C76BC0B67F}\\Instance"
	},
	{
		"id": 4120,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Keyboard"
	},
	{
		"id": 4124,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\SignalManager\\Peek\\CacheStore"
	},
	{
		"id": 4128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4136,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10804"
	},
	{
		"id": 4144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4148,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 51,
			"Context": 4148
		}
	},
	{
		"id": 4152,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100a6"
	},
	{
		"id": 4156,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4160,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4168,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion"
	},
	{
		"id": 4172,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{9D4A3865-6969-4B24-928C-C60ACC181E40}"
	},
	{
		"id": 4176,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4188,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4196,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 4204,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4212,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4216,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.properties"
	},
	{
		"id": 4220,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\{43a2b8d7-6fed-4c18-bd36-b4630d61afb5}"
	},
	{
		"id": 4224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4228,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 4236,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4240,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 2949,
			"Context": 4240
		}
	},
	{
		"id": 4244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4248,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 108,
			"Context": 4248
		}
	},
	{
		"id": 4252,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4256,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SignalManager\\Peek\\CacheStore"
	},
	{
		"id": 4260,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4280,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4284,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4288,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4296,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4300,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4304,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4312,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4320,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4324,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4328,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4332,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4336,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4364,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4380,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4388,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 56,
			"Context": 99600432
		}
	},
	{
		"id": 4396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4420,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4424,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1,
			"Context": 4424
		}
	},
	{
		"id": 4428,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4432,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 4436,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4440,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4444,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4448,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4460,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4468,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4472,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4476,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4480,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4484,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4492,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4508,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\IdentityStore\\Providers"
	},
	{
		"id": 4512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4528,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 4532,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4540,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 14,
			"Context": 100338224
		}
	},
	{
		"id": 4544,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4548,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4564,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4568,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10804"
	},
	{
		"id": 4572,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4576,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4580,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4584,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.RibbonDelete"
	},
	{
		"id": 4588,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 4592,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4608,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4612,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4620,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4632,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4660,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 4664,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4684,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4692,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4696,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4700,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4704,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4712,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4720,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4728,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4736,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4740,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4744,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4752,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 4764,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 75,
			"Context": 4764
		}
	},
	{
		"id": 4768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4772,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 4776,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4784,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 2,
			"Context": 327862048
		}
	},
	{
		"id": 4796,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4808,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4812,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4820,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10380"
	},
	{
		"id": 4824,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4828,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4832,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4836,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4840,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4848,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1800,
			"Context": 4848
		}
	},
	{
		"id": 4852,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.properties"
	},
	{
		"id": 4856,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4860,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4864,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4868,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4872,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Security Center"
	},
	{
		"id": 4880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4896,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 4904,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4908,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4920,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4928,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4936,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4940,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4944,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4948,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER"
	},
	{
		"id": 4952,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 282,
			"Context": 0
		}
	},
	{
		"id": 4956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4960,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4964,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4968,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4976,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:890794"
	},
	{
		"id": 4984,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4992,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 5000,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5008,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 5012,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5016,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5024,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ShellReadyEvent"
	},
	{
		"id": 5048,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5056,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 5064,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5084,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5092,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5108,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5112,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5116,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5128,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 5136,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 198,
			"Context": 5136
		}
	},
	{
		"id": 5140,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:4040c"
	},
	{
		"id": 5144,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*cversions.2.ro"
	},
	{
		"id": 5148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5152,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:107e2"
	},
	{
		"id": 5156,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_C59FE15A-8D83-87A7-9461-4DA519BF2583"
	},
	{
		"id": 5160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5164,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5184,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5196,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5232,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 5236,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 5240,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5248,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5252,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5264,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 4,
			"Context": 5264
		}
	},
	{
		"id": 5268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5276,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 21,
			"Context": 5276
		}
	},
	{
		"id": 5280,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5292,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\AllFolders\\Shell"
	},
	{
		"id": 5300,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 5312,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5316,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\KGL\\OneSettings"
	},
	{
		"id": 5320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5328,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5332,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5368,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{CF8F7C29-0D29-4AAA-8A98-2674979117A1}"
	},
	{
		"id": 5372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5380,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5392,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5412,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BcastdvrStartup73BD1D72-A850-47FF-82E1-8F30D2C38FFE"
	},
	{
		"id": 5420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5428,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 5432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5436,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 3,
			"Context": 109119872
		}
	},
	{
		"id": 5520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5524,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 23,
			"Context": 5524
		}
	},
	{
		"id": 5528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5532,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\GameBar"
	},
	{
		"id": 5536,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5540,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5548,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5552,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5556,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\GameDVR"
	},
	{
		"id": 5560,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5568,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5584,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.rename"
	},
	{
		"id": 5596,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5608,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 5608
		}
	},
	{
		"id": 5612,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5628,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE"
	},
	{
		"id": 5632,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:ca0706"
	},
	{
		"id": 5636,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5668,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5672,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5700,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5720,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.newfolder"
	},
	{
		"id": 5724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5732,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5756,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 5760,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5764,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5784,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5804,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5808,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5828,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5836,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 5844,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5848,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 5852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5888,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5896,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5900,
		"object": 0,
		"type": "WmiGuid",
		"name": ""
	},
	{
		"id": 5920,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5924,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 6,
			"Context": 5924
		}
	},
	{
		"id": 5932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5936,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5940,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5944,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5948,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5956,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 10,
			"Context": 5956
		}
	},
	{
		"id": 5960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5968,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6000,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6004,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6008,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6012,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 6020,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6024,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6048,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6056,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6072,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 6084,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 6104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6116,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 6128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6132,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 34,
			"Context": 99590352
		}
	},
	{
		"id": 6140,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{DFFACDC5-679F-4156-8947-C5C76BC0B67F}\\Instance"
	},
	{
		"id": 6160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6164,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6168,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 6172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6176,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 52,
			"Context": 327856672
		}
	},
	{
		"id": 6180,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10380"
	},
	{
		"id": 6184,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6188,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10380"
	},
	{
		"id": 6192,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 6196,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6200,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6204,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6208,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6224,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6228,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\SettingSync\\Groups"
	},
	{
		"id": 6240,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6244,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Console"
	},
	{
		"id": 6248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6252,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Notifications\\Settings"
	},
	{
		"id": 6256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6260,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6268,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 10277,
			"Context": 6268
		}
	},
	{
		"id": 6292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6320,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6324,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6332,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:404e6"
	},
	{
		"id": 6336,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6344,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FeatureUsage"
	},
	{
		"id": 6356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6372,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6396,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6412,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Render\\{0868fdbf-c90c-41c7-be4c-7c220094765a}\\Properties"
	},
	{
		"id": 6416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6420,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6424,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 6428,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6436,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6440,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6444,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 2,
			"Context": 327858688
		}
	},
	{
		"id": 6448,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6452,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6460,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6484,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6496,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6504,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6516,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_1753CA72-8431-5BA1-568C-695D2B1C5FD1"
	},
	{
		"id": 6524,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 6528,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\AllFolders\\Shell"
	},
	{
		"id": 6532,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6536,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6540,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 6540
		}
	},
	{
		"id": 6544,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6548,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 10,
			"Context": 6548
		}
	},
	{
		"id": 6552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6560,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6564,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 6568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6576,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6584,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6600,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6608,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1,
			"Context": 65216448
		}
	},
	{
		"id": 6616,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6636,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 3527,
			"Context": 6636
		}
	},
	{
		"id": 6640,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100a6"
	},
	{
		"id": 6648,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6660,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6664,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6720,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6736,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{4D5078EE-878B-4E83-A77E-C558B283594A}"
	},
	{
		"id": 6772,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 11,
			"Context": 99594384
		}
	},
	{
		"id": 6776,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6780,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 6,
			"Context": 6780
		}
	},
	{
		"id": 6784,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6804,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6812,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ShellDesktopSwitchEvent"
	},
	{
		"id": 6816,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*Users*bunny*AppData*Local*Microsoft*Windows*Caches*{3DA71D5A-20CC-432F-A115-DFE92379E91F}.3.ver0x00000000000001ab.db"
	},
	{
		"id": 6820,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\CLSID\\{031E4825-7B94-4dc3-B131-E946B44C8DD5}"
	},
	{
		"id": 6828,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6832,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\BannerStore"
	},
	{
		"id": 6840,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6844,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"
	},
	{
		"id": 6848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6852,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"
	},
	{
		"id": 6856,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SyncRootManager"
	},
	{
		"id": 6860,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6864,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6880,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6884,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 6888,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:107e2"
	},
	{
		"id": 6892,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6900,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6908,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6916,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\PrimaryProperties\\IndexedLocations"
	},
	{
		"id": 6920,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Ribbon"
	},
	{
		"id": 6924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6928,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6932,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6936,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\PrimaryProperties\\UnindexedLocations"
	},
	{
		"id": 6944,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Modules\\GlobalSettings\\DetailsContainer"
	},
	{
		"id": 6948,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\Preferences"
	},
	{
		"id": 6952,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6960,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6968,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6976,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6980,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6984,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6988,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6992,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6996,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize"
	},
	{
		"id": 7004,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\International"
	},
	{
		"id": 7008,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\HomeGroup\\Roaming"
	},
	{
		"id": 7012,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7016,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7020,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\JPN\\roaming\\mon"
	},
	{
		"id": 7024,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7028,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7032,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\KOR\\roaming\\mon"
	},
	{
		"id": 7036,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7040,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7044,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\International\\User Profile"
	},
	{
		"id": 7048,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7052,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7056,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7060,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7072,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7076,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7080,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7084,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7092,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7116,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\NetworkUxManager"
	},
	{
		"id": 7124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7136,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7140,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7144,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Quick Actions"
	},
	{
		"id": 7160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7164,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7172,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\Settings"
	},
	{
		"id": 7176,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7180,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7184,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7188,
		"object": 0,
		"type": "UserApcReserve",
		"name": ""
	},
	{
		"id": 7208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7216,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9"
	},
	{
		"id": 7220,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\NameSpace_Catalog5"
	},
	{
		"id": 7228,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7232,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7236,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7248,
		"object": 0,
		"type": "UserApcReserve",
		"name": ""
	},
	{
		"id": 7252,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7260,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\DWM"
	},
	{
		"id": 7264,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7268,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7288,
		"object": 0,
		"type": "UserApcReserve",
		"name": ""
	},
	{
		"id": 7296,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7300,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\IntelliForms\\FormData"
	},
	{
		"id": 7304,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SettingSync\\BrowserSettings"
	},
	{
		"id": 7308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7312,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7320,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 5,
			"Context": 99601776
		}
	},
	{
		"id": 7324,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 2,
			"Context": 99588336
		}
	},
	{
		"id": 7332,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7336,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\DomainSuggestion\\Exclude"
	},
	{
		"id": 7340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7344,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7348,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\TabbedBrowsing"
	},
	{
		"id": 7352,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7356,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34209792,
			"Seqno": 23,
			"Context": 0
		}
	},
	{
		"id": 7360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7364,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7368,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7372,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3"
	},
	{
		"id": 7376,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7440,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Favorites"
	},
	{
		"id": 7444,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7448,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\FlipAhead"
	},
	{
		"id": 7452,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7456,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7464,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7468,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore"
	},
	{
		"id": 7472,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main"
	},
	{
		"id": 7476,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7480,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7484,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7488,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\IntelliForms"
	},
	{
		"id": 7500,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7504,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7508,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7512,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\FullScreen\\AllowDomains"
	},
	{
		"id": 7516,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 7516
		}
	},
	{
		"id": 7520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7524,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7532,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\New Windows\\Allow"
	},
	{
		"id": 7536,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7540,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
	},
	{
		"id": 7544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7548,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7552,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\SearchScopes"
	},
	{
		"id": 7556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7560,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7564,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main"
	},
	{
		"id": 7568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7572,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7576,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main"
	},
	{
		"id": 7580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7584,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7596,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7600,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Safety\\PrivacIE"
	},
	{
		"id": 7604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7608,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7612,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Safety\\Tracking Protection Exceptions"
	},
	{
		"id": 7616,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7620,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7624,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Safety\\PrivacIE\\Lists"
	},
	{
		"id": 7628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7632,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7636,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\TypedURLs"
	},
	{
		"id": 7640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7644,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7648,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7652,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7664,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7676,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7680,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7684,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"
	},
	{
		"id": 7688,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7692,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7700,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7704,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7744,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7748,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7756,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7760,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 7764,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 20,
			"Context": 109113136
		}
	},
	{
		"id": 7768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7772,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7776,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ShellLauncherLoginEvent"
	},
	{
		"id": 7796,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7804,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1401,
			"Context": 108332496
		}
	},
	{
		"id": 7812,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 8,
			"Context": 0
		}
	},
	{
		"id": 7816,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7820,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 10,
			"Context": 7820
		}
	},
	{
		"id": 7824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7828,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 7832,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 7836,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7840,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7852,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7856,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7860,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7864,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7868,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7872,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 7872
		}
	},
	{
		"id": 7876,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7892,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7908,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7940,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7952,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7976,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7980,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7988,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7996,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8004,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 4,
			"Context": 8004
		}
	},
	{
		"id": 8024,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8028,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8036,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8040,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8048,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8060,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8072,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8080,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8088,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8112,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8116,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8120,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8132,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8152,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8156,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8168,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8176,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8188,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8200,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8216,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8296,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 8300,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 8304,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8332,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8344,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8392,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8424,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8436,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8440,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8444,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8448,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8464,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8468,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8476,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8492,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 8496,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 8500,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8504,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8520,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies"
	},
	{
		"id": 8532,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8540,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 8544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8568,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8576,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 255,
			"Context": 8576
		}
	},
	{
		"id": 8580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8596,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Search\\CrawlScopeManager\\Windows\\SystemIndex\\SearchRoots"
	},
	{
		"id": 8628,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8632,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 11,
			"Context": 8632
		}
	},
	{
		"id": 8636,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8728,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8740,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8744,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8748,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8752,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8756,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8760,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8764,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8768,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8772,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8776,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8780,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8784,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8788,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 8792,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8796,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 7,
			"Context": 0
		}
	},
	{
		"id": 8800,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8804,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 8804
		}
	},
	{
		"id": 8808,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8812,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Policies"
	},
	{
		"id": 8816,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8820,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 21,
			"Context": 64834608
		}
	},
	{
		"id": 8824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8828,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software"
	},
	{
		"id": 8836,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8840,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8844,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8856,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 18,
			"Context": 8856
		}
	},
	{
		"id": 8864,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 5,
			"Context": 99598416
		}
	},
	{
		"id": 8868,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 7,
			"Context": 8868
		}
	},
	{
		"id": 8880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8892,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8908,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8928,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 8948,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8952,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8976,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8980,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8984,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8996,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE"
	},
	{
		"id": 9000,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node"
	},
	{
		"id": 9004,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap"
	},
	{
		"id": 9008,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap"
	},
	{
		"id": 9012,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\UrlZonesSM_bunny"
	},
	{
		"id": 9020,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9024,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9032,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9040,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9044,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{CEBFF5CD-ACE2-4F4F-9178-9926F41749EA}\\Count"
	},
	{
		"id": 9048,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{F4E57C4B-2036-45F0-A9AB-443BCFE33D9F}\\Count"
	},
	{
		"id": 9052,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{B267E3AD-A825-4A09-82B9-EEC22AA3B847}\\Count"
	},
	{
		"id": 9056,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{9E04CAB2-CC14-11DF-BB8C-A2F1DED72085}\\Count"
	},
	{
		"id": 9060,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{FA99DFC7-6AC2-453A-A5E2-5E2AFF4507BD}\\Count"
	},
	{
		"id": 9064,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{CAA59E3C-4792-41A5-9909-6A6A8D32490E}\\Count"
	},
	{
		"id": 9068,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{A3D53349-6E61-4557-8FC7-0028EDCEEBF6}\\Count"
	},
	{
		"id": 9072,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{F2A1CB5A-E3CC-4A2E-AF9D-505A7009D442}\\Count"
	},
	{
		"id": 9076,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{BCB48336-4DDD-48FF-BB0B-D3190DACB3E2}\\Count"
	},
	{
		"id": 9088,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9096,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\NetworkProvider\\HwOrder"
	},
	{
		"id": 9100,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\NetworkProvider\\ProviderOrder"
	},
	{
		"id": 9104,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 9108,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 9124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9132,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 6,
			"Context": 9132
		}
	},
	{
		"id": 9144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9152,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9160,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9164,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9168,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9172,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9180,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9184,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9196,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9200,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9228,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9236,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9252,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9260,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9296,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9300,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9304,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9312,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9324,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9328,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9332,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9336,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9344,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9348,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9380,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9388,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9392,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9412,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9424,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9428,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9436,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9440,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9444,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9448,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9452,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9460,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9464,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9468,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9476,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9480,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9484,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9492,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9496,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9504,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9508,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9516,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9524,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9532,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9536,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9540,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9548,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9552,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9560,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9564,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9572,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9576,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9584,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9600,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9608,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9612,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9616,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9620,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9632,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9636,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9644,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9648,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9652,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9656,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9668,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9672,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9676,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9680,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9684,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9692,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9704,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9708,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9712,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9716,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9720,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9724,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9728,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 243,
			"Context": 9728
		}
	},
	{
		"id": 9732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9740,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9744,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\MuiCache"
	},
	{
		"id": 9748,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 7,
			"Context": 9748
		}
	},
	{
		"id": 9760,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9764,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9768,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9772,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9776,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore"
	},
	{
		"id": 9792,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9804,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 9816,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\PlayToReceiver"
	},
	{
		"id": 9820,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9828,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{b155bdf8-02f0-451e-9a26-ae317cfd7779}\\Instance"
	},
	{
		"id": 9832,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9864,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9872,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9884,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9888,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\Instance"
	},
	{
		"id": 9896,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 9904,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 23,
			"Context": 9904
		}
	},
	{
		"id": 9908,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9916,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9920,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9924,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9932,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\PackagedCom"
	},
	{
		"id": 9936,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\PackagedCom\\Package"
	},
	{
		"id": 9944,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom\\Package"
	},
	{
		"id": 9952,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 9964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9976,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9980,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9984,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 183,
			"Context": 327866752
		}
	},
	{
		"id": 9988,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9996,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10000,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10004,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\StateRepository.PrimaryTileUserNotificationChannel.{F0DE26AA-90D1-4928-BBDF-41F137A7B6B3}"
	},
	{
		"id": 10008,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 10044,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10048,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10056,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\Instance"
	},
	{
		"id": 10060,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10068,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.newfolder"
	},
	{
		"id": 10072,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10080,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10092,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10112,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10116,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 10124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10128,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:4040c"
	},
	{
		"id": 10132,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10136,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10164,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10168,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 10172,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 195,
			"Context": 327867424
		}
	},
	{
		"id": 10180,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10188,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10208,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\Cache\\DefaultAccount\\$de${6ca1ca25-d1e2-4563-945a-eb5b802393e7}$$windows.data.unifiedtile.localstarttilepropertiesmap\\Current"
	},
	{
		"id": 10212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10228,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\Cache\\DefaultAccount\\$de${6ca1ca25-d1e2-4563-945a-eb5b802393e7}$$windows.data.unifiedtile.localstartvolatiletilepropertiesmap\\Current"
	},
	{
		"id": 10232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10244,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10248,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 12,
			"Context": 10248
		}
	},
	{
		"id": 10252,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 12,
			"Context": 10252
		}
	},
	{
		"id": 10256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10260,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10264,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10272,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10280,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10284,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10292,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10296,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10300,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10304,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10308,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10312,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10316,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10324,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10328,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10332,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10336,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10340,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10344,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 10348,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 10352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10360,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10380,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasAnimations.9308.12724"
	},
	{
		"id": 10384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10388,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10392,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10396,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10412,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10424,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10428,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 10432,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 10436,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10440,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10448,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10460,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10464,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimationsComplete.9308.12724"
	},
	{
		"id": 10468,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10476,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10480,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10484,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10492,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10496,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10504,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10508,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10512,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10516,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10520,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 720896,
			"Seqno": 5,
			"Context": 10520
		}
	},
	{
		"id": 10524,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10532,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10536,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasDeferredAnimationOperations.9308.12724"
	},
	{
		"id": 10540,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1568,
			"Context": 108263392
		}
	},
	{
		"id": 10544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10548,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10560,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10564,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10572,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10576,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10584,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1,
			"Context": 0
		}
	},
	{
		"id": 10588,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10592,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10600,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 10600
		}
	},
	{
		"id": 10604,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10608,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 10612,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1,
			"Context": 0
		}
	},
	{
		"id": 10616,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10620,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 10620
		}
	},
	{
		"id": 10624,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10628,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e4"
	},
	{
		"id": 10632,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e4"
	},
	{
		"id": 10640,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e6"
	},
	{
		"id": 10644,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10648,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10652,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e6"
	},
	{
		"id": 10656,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize"
	},
	{
		"id": 10660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10664,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10668,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Colors"
	},
	{
		"id": 10672,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10676,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10680,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Accent"
	},
	{
		"id": 10684,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10688,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10692,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1,
			"Context": 64625152
		}
	},
	{
		"id": 10696,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10700,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10704,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10712,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10720,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasAnimations.9308.12732"
	},
	{
		"id": 10724,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimationsComplete.9308.12732"
	},
	{
		"id": 10728,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasDeferredAnimationOperations.9308.12732"
	},
	{
		"id": 10732,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\DeferredAnimationOperationsComplete.9308.12732"
	},
	{
		"id": 10736,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\RootVisualReset.9308.12732"
	},
	{
		"id": 10740,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImageDecodingIdle.9308.12732"
	},
	{
		"id": 10744,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FontDownloadsIdle.9308.12732"
	},
	{
		"id": 10748,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PopupMenuCommandInvoked.9308.12732"
	},
	{
		"id": 10752,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBuildTreeWorks.9308.12732"
	},
	{
		"id": 10756,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BuildTreeServiceDrained.9308.12732"
	},
	{
		"id": 10760,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\KeyboardInputReceived.9308.12732"
	},
	{
		"id": 10764,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImplicitShowHideComplete.9308.12732"
	},
	{
		"id": 10768,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasFacadeAnimations.9308.12732"
	},
	{
		"id": 10772,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FacadeAnimationsComplete.9308.12732"
	},
	{
		"id": 10776,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimatedFacadePropertyChangesComplete.9308.12732"
	},
	{
		"id": 10780,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBrushTransitions.9308.12732"
	},
	{
		"id": 10784,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BrushTransitionsComplete.9308.12732"
	},
	{
		"id": 10788,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PageNavigationComplete.9308.12732"
	},
	{
		"id": 10792,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\DeferredAnimationOperationsComplete.9308.12724"
	},
	{
		"id": 10796,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\RootVisualReset.9308.12724"
	},
	{
		"id": 10800,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImageDecodingIdle.9308.12724"
	},
	{
		"id": 10804,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FontDownloadsIdle.9308.12724"
	},
	{
		"id": 10808,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBuildTreeWorks.9308.12724"
	},
	{
		"id": 10812,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PopupMenuCommandInvoked.9308.12724"
	},
	{
		"id": 10816,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BuildTreeServiceDrained.9308.12724"
	},
	{
		"id": 10820,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\KeyboardInputReceived.9308.12724"
	},
	{
		"id": 10824,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImplicitShowHideComplete.9308.12724"
	},
	{
		"id": 10828,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasFacadeAnimations.9308.12724"
	},
	{
		"id": 10832,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FacadeAnimationsComplete.9308.12724"
	},
	{
		"id": 10836,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimatedFacadePropertyChangesComplete.9308.12724"
	},
	{
		"id": 10840,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBrushTransitions.9308.12724"
	},
	{
		"id": 10844,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BrushTransitionsComplete.9308.12724"
	},
	{
		"id": 10848,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PageNavigationComplete.9308.12724"
	},
	{
		"id": 10852,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10856,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10860,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1,
			"Context": 65347152
		}
	},
	{
		"id": 10864,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 452,
			"Context": 0
		}
	},
	{
		"id": 10868,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 10868
		}
	},
	{
		"id": 10872,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10876,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10900,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10924,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10928,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 11,
			"Context": 10928
		}
	},
	{
		"id": 10932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10936,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10940,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10944,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10952,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 10952
		}
	},
	{
		"id": 10956,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10960,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10968,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10976,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10980,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10984,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10988,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10992,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10996,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 11000,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11004,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 627,
			"Context": 0
		}
	},
	{
		"id": 11008,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11012,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 11012
		}
	},
	{
		"id": 11016,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11024,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11032,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 11040,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 10,
			"Context": 11040
		}
	},
	{
		"id": 11044,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11048,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1930,
			"Context": 133471376
		}
	},
	{
		"id": 11052,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11056,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11064,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11072,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones"
	},
	{
		"id": 11076,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11080,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11088,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11096,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11100,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11104,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11112,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 11116,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\{43a2b8d7-6fed-4c18-bd36-b4630d61afb5}"
	},
	{
		"id": 11124,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11128,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 11132,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11136,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11152,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11168,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11180,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11188,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 11192,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11196,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11200,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11216,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 19,
			"Context": 327872128
		}
	},
	{
		"id": 11220,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11232,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11236,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11240,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\AllFolders\\Shell"
	},
	{
		"id": 11244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11252,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 96,
			"Context": 11252
		}
	},
	{
		"id": 11260,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11272,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11300,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11320,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11324,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"
	},
	{
		"id": 11332,
		"object": 0,
		"type": "Key",
		"name": "HKEY_USERS"
	},
	{
		"id": 11336,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 7,
			"Context": 11336
		}
	},
	{
		"id": 11340,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\windows_webcache_counters_{9B6AB5B3-91BC-4097-835C-EA2DEC95E9CC}_S-1-5-21-2271034452-2606270099-984871569-1001"
	},
	{
		"id": 11348,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 3,
			"Context": 65322496
		}
	},
	{
		"id": 11356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11360,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 11360
		}
	},
	{
		"id": 11364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11372,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11376,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11380,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11388,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11392,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11408,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11412,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\2\\Shell"
	},
	{
		"id": 11428,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Applications\\taskmgr.exe"
	},
	{
		"id": 11496,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11508,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11512,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11524,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11532,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.redo"
	},
	{
		"id": 11536,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 7,
			"Context": 11536
		}
	},
	{
		"id": 11540,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11556,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 11576,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{8092FD1B-FFD3-4F2A-91D2-232E90AAFAC3}"
	},
	{
		"id": 11588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11620,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11644,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.RibbonDelete"
	},
	{
		"id": 11688,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\C::Users:bunny:AppData:Local:Microsoft:Windows:Explorer:iconcache_idx.db!rwWriterEvent"
	},
	{
		"id": 11692,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11700,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11712,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11720,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11728,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11732,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.help"
	},
	{
		"id": 11736,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11740,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11752,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11764,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11768,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11772,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 11776,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 11780,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.rename"
	},
	{
		"id": 11788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11792,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11800,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11816,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11832,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11836,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 11852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11868,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11872,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11876,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.redo"
	},
	{
		"id": 11880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11900,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11916,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11928,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5748,
		"object": 18446616034694817200,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\stobject.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7752,
		"object": 18446616034694946400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingFinance_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8412,
		"object": 18446616034694995600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ZuneVideo_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7740,
		"object": 18446616034690721664,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BioEnrollment_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8076,
		"object": 18446616034694973200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.People_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3972,
		"object": 18446616034747445808,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5928,
		"object": 18446616034686617392,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\batmeter.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5640,
		"object": 18446616034858273424,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Network Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1828,
		"object": 18446616034686815792,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10196,
		"object": 18446616034704160752,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8276,
		"object": 18446616034694983200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.SecureAssessmentBrowser_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7800,
		"object": 18446616034694944000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.AsyncTextService_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8056,
		"object": 18446616034686563792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.PPIProjection_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7936,
		"object": 18446616034694961600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11724,
		"object": 18446616034858271824,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\User Pinned",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8044,
		"object": 18446616034694951200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Wallet_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5592,
		"object": 18446616034682718736,
		"type": "File",
		"name": "C:\\Windows\\bcastdvr",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10948,
		"object": 18446616034858272624,
		"type": "File",
		"name": "C:\\Users\\bunny\\Favorites",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5396,
		"object": 18446616034666524016,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\GameDVR",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11344,
		"object": 18446616034858263824,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4816,
		"object": 18446616034858284624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Internet Explorer\\TabRoaming",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8260,
		"object": 18446616034694974800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.PinningConfirmationDialog_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3144,
		"object": 18446616034858263024,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5800,
		"object": 18446616034690712464,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\batmeter.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8428,
		"object": 18446616034690731264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.YourPhone_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10052,
		"object": 18446616034704120752,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\mpr.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7708,
		"object": 18446616034694945600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\E2A4F912-2574-4A75-9BB0-0D023378592B_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7720,
		"object": 18446616034694955200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\InputApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8624,
		"object": 18446616034700692208,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11528,
		"object": 18446616034858261024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8220,
		"object": 18446616034679797136,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.OOBENetworkCaptivePortal_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8236,
		"object": 18446616034694980400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.ParentalControls_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1384,
		"object": 18446616034686750192,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\oleaccrc.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8008,
		"object": 18446616034686748192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftOfficeHub_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9844,
		"object": 18446616034700855408,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8284,
		"object": 18446616034686778192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.StartMenuExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8584,
		"object": 18446616034700826608,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7956,
		"object": 18446616034686731392,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Getstarted_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8184,
		"object": 18446616034686739792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.CloudExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 908,
		"object": 18446616034858292624,
		"type": "File",
		"name": "C:\\Users\\bunny\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7276,
		"object": 18446616034684668048,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5816,
		"object": 18446616034679688736,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8292,
		"object": 18446616034694989200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.ShellExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7328,
		"object": 18446616034663462288,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\bthprops.cpl.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5052,
		"object": 18446616034690669264,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\imageres.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8104,
		"object": 18446616034686608192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ScreenSketch_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5856,
		"object": 18446616034690708064,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\InputSwitch.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 72,
		"object": 18446616034686702992,
		"type": "File",
		"name": "C:\\Windows\\System32",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4108,
		"object": 18446616034690650864,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1772,
		"object": 18446616034670756720,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\propsys.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 3836,
		"object": 18446616034858267024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8108,
		"object": 18446616034690499264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.StorePurchaseApp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4656,
		"object": 18446616034684636448,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\GameDVR\\KnownGameList.bin",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7204,
		"object": 18446616034684654848,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\pnidui.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8064,
		"object": 18446616034694956800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Office.Sway_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6156,
		"object": 18446616034694941600,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\KernelBase.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 2816,
		"object": 18446616034690592464,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\windows.storage.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 10892,
		"object": 18446616034717027104,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11664,
		"object": 18446616034858280224,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\Burn",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7948,
		"object": 18446616034694950400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.GetHelp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 2824,
		"object": 18446616034690597264,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\twinui.pcshell.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8000,
		"object": 18446616034694964400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Microsoft3DViewer_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8832,
		"object": 18446616034684504448,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\netmsg.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7944,
		"object": 18446616034694949600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ECApp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7132,
		"object": 18446616034694935200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\PicturePassword",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6148,
		"object": 18446616034690719264,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8016,
		"object": 18446616034679711936,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftSolitaireCollection_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7808,
		"object": 18446616034690726864,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingSports_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 252,
		"object": 18446616034686714992,
		"type": "File",
		"name": "C:\\Windows\\en-US\\explorer.exe.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8084,
		"object": 18446616034686617792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Print3D_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9892,
		"object": 18446616034686714592,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\imageres.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5752,
		"object": 18446616034690689664,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7788,
		"object": 18446616034694960000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MSPaint_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4748,
		"object": 18446616034747446208,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\hcproviders.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 3808,
		"object": 18446616034747451808,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\wscui.cpl.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5604,
		"object": 18446616034798478992,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\explorerframe.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 6124,
		"object": 18446616034684658048,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\sndvolsso.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8244,
		"object": 18446616034686753792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.PeopleExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1512,
		"object": 18446616034686777392,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9080,
		"object": 18446616034700847808,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.18362.720_none_17a9a8aa6da6fd39",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8452,
		"object": 18446616034694997600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Windows.CBSPreview_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11648,
		"object": 18446616034858266224,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4780,
		"object": 18446616034858269024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\User Pinned",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8096,
		"object": 18446616034686602192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.SkypeApp_kzf8qxf38zg5c\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8196,
		"object": 18446616034694976400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8164,
		"object": 18446616034690680864,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.AssignedAccessLockApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8328,
		"object": 18446616034642137968,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsCalculator_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4452,
		"object": 18446616034747446608,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\ActionCenter.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7984,
		"object": 18446616034694965200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Messaging_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8212,
		"object": 18446616034686604592,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.NarratorQuickStart_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8180,
		"object": 18446616034679697536,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.CallingShellApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5572,
		"object": 18446616034858291424,
		"type": "File",
		"name": "C:\\Users\\Public\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8140,
		"object": 18446616034694972000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WebpImageExtension_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8052,
		"object": 18446616034694958000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MixedReality.Portal_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8316,
		"object": 18446616034694982000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsCamera_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1436,
		"object": 18446616034686761792,
		"type": "File",
		"name": "C:\\Windows\\Fonts\\StaticCache.dat",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 9852,
		"object": 18446616034700855808,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\acppage.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7728,
		"object": 18446616034694954400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingNews_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7920,
		"object": 18446616034694944800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.CredDialogHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8720,
		"object": 18446616034700827408,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\twext.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7780,
		"object": 18446616034694953200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.AAD.BrokerPlugin_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8408,
		"object": 18446616034694992800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ZuneMusic_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1956,
		"object": 18446616034670771920,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7392,
		"object": 18446616034747449808,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7888,
		"object": 18446616034694968000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8416,
		"object": 18446616034694994000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGamingOverlay_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7968,
		"object": 18446616034694964000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8432,
		"object": 18446616034694994400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxIdentityProvider_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7972,
		"object": 18446616034694965600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.LockApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8128,
		"object": 18446616034683651472,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.TheNorthernLights_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7928,
		"object": 18446616034679699136,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.LanguageExperiencePackes-ES_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11276,
		"object": 18446616034858278624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Libraries",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6388,
		"object": 18446616034858280624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\Burn",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8268,
		"object": 18446616034694981600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.SecHealthUI_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8136,
		"object": 18446616034694972400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WebMediaExtensions_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11256,
		"object": 18446616034747447808,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\WER\\ERC",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9664,
		"object": 18446616034700850208,
		"type": "File",
		"name": "C:\\ProgramData\\AVG\\Antivirus",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1676,
		"object": 18446616034858282624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Network Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8372,
		"object": 18446616034686792992,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsSoundRecorder_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9688,
		"object": 18446616034700854608,
		"type": "File",
		"name": "C:\\Program Files\\AVG\\Antivirus\\setup",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1784,
		"object": 18446616034670779120,
		"type": "File",
		"name": "\\FileSystem\\Filters\\FltMgrMsg",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7964,
		"object": 18446616034690725264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.HEIFImageExtension_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5580,
		"object": 18446616034684635248,
		"type": "File",
		"name": "C:\\Program Files\\WindowsApps\\Microsoft.XboxGameOverlay_1.54.4001.0_x64__8wekyb3d8bbwe",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5576,
		"object": 18446616034684639248,
		"type": "File",
		"name": "C:\\Program Files\\WindowsApps\\Microsoft.XboxGameOverlay_1.54.4001.0_x64__8wekyb3d8bbwe",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3344,
		"object": 18446616034858261824,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8068,
		"object": 18446616034694967600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.OneConnect_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6036,
		"object": 18446616034690710864,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\SndVolSSO.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8324,
		"object": 18446616034694961200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsAlarms_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11640,
		"object": 18446616034858284224,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Libraries",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7900,
		"object": 18446616034694966000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftEdgeDevToolsClient_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8404,
		"object": 18446616034686804592,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGameOverlay_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8312,
		"object": 18446616034690718064,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.XGpuEjectDialog_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8380,
		"object": 18446616034694829600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxApp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8572,
		"object": 18446616034700683008,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 676,
		"object": 18446616034686720192,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8160,
		"object": 18446616034694976000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.Apprep.ChxApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5324,
		"object": 18446616034858276624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Internet Explorer\\TabRoaming",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8172,
		"object": 18446616034694971600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.CapturePicker_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8456,
		"object": 18446616034694998400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Windows.PrintDialog_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9912,
		"object": 18446616034858283424,
		"type": "File",
		"name": "C:\\Users\\Public\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10024,
		"object": 18446616034858259824,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7712,
		"object": 18446616034694953600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\F46D4000-FD22-4DB4-AC8E-4E1DDDE828FE_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8348,
		"object": 18446616034690734464,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\microsoft.windowscommunicationsapps_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11708,
		"object": 18446616034858285824,
		"type": "File",
		"name": "C:\\Users\\bunny\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11584,
		"object": 18446616034858281824,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Printer Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6272,
		"object": 18446616034858267424,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1680,
		"object": 18446616034736151712,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\user32.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 1832,
		"object": 18446616034670748720,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7732,
		"object": 18446616034694948400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.3DBuilder_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6904,
		"object": 18446616034694938800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Vault\\UserProfileRoaming",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 2428,
		"object": 18446616034690557264,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7696,
		"object": 18446616034679698336,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\c5e2524a-ea46-4f67-841f-6a9465d9d515_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7428,
		"object": 18446616034686635392,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\1527c705-839a-4832-9118-54d4Bd6a0c89_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8548,
		"object": 18446616034700674208,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8204,
		"object": 18446616034694978800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.Cortana_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7792,
		"object": 18446616034694947600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.AccountsControl_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8352,
		"object": 18446616034694986000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsFeedbackHub_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3844,
		"object": 18446616034690701264,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\dsreg.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 6676,
		"object": 18446616034684660848,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8012,
		"object": 18446616034694962000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.VP9VideoExtensions_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8368,
		"object": 18446616034694993600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsMaps_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5564,
		"object": 18446616034684644848,
		"type": "File",
		"name": "C:\\Program Files\\WindowsApps\\Microsoft.XboxGameOverlay_1.54.4001.0_x64__8wekyb3d8bbwe",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6468,
		"object": 18446616034858273024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Printer Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3468,
		"object": 18446616034694941200,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8336,
		"object": 18446616034694991600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsTerminal_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7884,
		"object": 18446616034690727264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingWeather_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5588,
		"object": 18446616034684652448,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGamingOverlay_8wekyb3d8bbwe\\LocalCache",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1140,
		"object": 18446616034686748992,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\shell32.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8360,
		"object": 18446616034694756400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsStore_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8032,
		"object": 18446616034694974400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Win32WebViewHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8388,
		"object": 18446616034694991200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGameCallableUI_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8252,
		"object": 18446616034694980800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.Photos_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5772,
		"object": 18446616034694830000,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\stobject.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 10596,
		"object": 18446616034717010304,
		"type": "File",
		"name": "C:\\Windows\\Fonts\\segoeui.ttf",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8228,
		"object": 18446616034694978400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.OOBENetworkConnectionFlow_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11228,
		"object": 18446616034755486576,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\ApplicationFrame.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 3252,
		"object": 18446616034858273824,
		"type": "File",
		"name": "C:\\Users\\bunny\\Favorites",
		"meta": {
			"IsDirectory": true
		}
	}
]
```

`pkg/kevent/batch.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

// Batch contains a sequence of kernel events.
type Batch struct {
	Events []*Kevent
}

// NewBatch produces a new batch from the group of events.
func NewBatch(evts ...*Kevent) *Batch {
	return &Batch{Events: evts}
}

// Len returns the length of the batch.
func (b *Batch) Len() int64 { return int64(len(b.Events)) }

// Release releases all events from the batch and returns them to the pool.
func (b *Batch) Release() {
	for _, e := range b.Events {
		e.Release()
	}
}

// MarshalJSON serializes the batch of events to JSON format.
func (b *Batch) MarshalJSON() []byte {
	buf := make([]byte, 0)
	buf = append(buf, '[')
	for i, kevt := range b.Events {
		writeMore := true
		if i == len(b.Events)-1 {
			writeMore = false
		}
		buf = append(buf, kevt.MarshalJSON()...)
		buf = append(buf, '\n')
		if writeMore {
			buf = append(buf, ',')
		}
	}
	buf = append(buf, ']')
	return buf
}

```

`pkg/kevent/batch_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"encoding/json"
	"github.com/magiconair/properties/assert"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestBatchMarshalJSON(t *testing.T) {
	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt1 := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt2 := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	b := NewBatch(kevt, kevt1, kevt2)
	require.Equal(t, int64(3), b.Len())

	buf := b.MarshalJSON()
	var kevts []*Kevent

	err := json.Unmarshal(buf, &kevts)
	require.NoError(t, err)
	require.Len(t, kevts, 3)

	assert.Equal(t, uint32(859), kevts[0].PID)
	assert.Equal(t, uint32(459), kevts[1].PID)
	assert.Equal(t, uint32(829), kevts[2].PID)
}

```

`pkg/kevent/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package kevent defines the fundamental data structures that underpin the state of every kernel event pushed from the
// consumer.
package kevent

```

`pkg/kevent/formatter.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/fasttemplate"
	"regexp"
	"sort"
	"strings"
	"unicode"
)

const (
	// startTag represents the leading tag surrounding field name
	startTag = "{{"
	// endTag represents the trailing tag surrounding field name
	endTag = "}}"

	seq           = ".Seq"
	ts            = ".Timestamp"
	pid           = ".Pid"
	ppid          = ".Ppid"
	pexe          = ".Pexe"
	pcomm         = ".Pcomm"
	pproc         = ".Pname"
	cwd           = ".Cwd"
	exe           = ".Exe"
	comm          = ".Comm"
	tid           = ".Tid"
	sid           = ".Sid"
	proc          = ".Process"
	cat           = ".Category"
	desc          = ".Description"
	cpu           = ".CPU"
	typ           = ".Type"
	kparameters   = ".Kparams"
	meta          = ".Meta"
	host          = ".Host"
	pe            = ".PE"
	kparsAccessor = ".Kparams."
)

var (
	// tmplRegexp defines the regular expression for parsing template fields.
	tmplRegexp = regexp.MustCompile(`({{2}.*?}{2})`)
	// tmplNormRegepx defines the regular expression for normalizing the template. This basically consists in removing
	// the brackets and trailing/leading spaces from the field name.
	tmplNormRegexp = regexp.MustCompile(`({{2}\s*([A-Za-z.]+)\s*}{2})`)
	// tmplExpandKparamsRegexp determines whether Kparams. fields are expanded
	tmplExpandKparamsRegexp = regexp.MustCompile(`{{\s*.Kparams.\S+}}`)
)

var kfields = map[string]bool{
	seq:         true,
	ts:          true,
	pid:         true,
	ppid:        true,
	pexe:        true,
	pcomm:       true,
	pproc:       true,
	cwd:         true,
	exe:         true,
	comm:        true,
	tid:         true,
	sid:         true,
	proc:        true,
	cat:         true,
	desc:        true,
	cpu:         true,
	typ:         true,
	kparameters: true,
	meta:        true,
	host:        true,
	pe:          true,
}

func hintFields() string {
	s := make([]string, 0, len(kfields))
	for field := range kfields {
		s = append(s, field)
	}
	sort.Slice(s, func(i, j int) bool { return s[i] < s[j] })
	return strings.Join(s, " ")
}

// Formatter deals with producing event's output that is dictated by the template.
type Formatter struct {
	t                *fasttemplate.Template
	expandKparamsDot bool
}

// NewFormatter builds a new instance of event's formatter.
func NewFormatter(template string) (*Formatter, error) {
	// check basic template format and ensure all fields
	// defined in the template are known to us
	fields := tmplRegexp.FindAllStringSubmatch(template, -1)
	if len(fields) == 0 {
		return nil, fmt.Errorf("invalid template format: %q", template)
	}
	if ok, pos := isTemplateBalanced(template); !ok {
		return nil, fmt.Errorf("template syntax error near field #%d: %q", pos, template)
	}
	for i, field := range fields {
		if len(field) > 0 {
			name := sanitize(field[0])
			if strings.HasPrefix(name, kparsAccessor) {
				continue
			}
			if name == "" {
				return nil, fmt.Errorf("empty field found at position %d", i+1)
			}
			if _, ok := kfields[name]; !ok {
				return nil, fmt.Errorf("%s is not a known field name. Maybe you meant one "+
					"of the following fields: %s", name, hintFields())
			}
		}
	}
	// user might define the tag such as `{{ .Seq }}` or {{ .Seq}}`. We have to make sure
	// inner spaces are removed before building the fast template instance
	norm := normalizeTemplate(template)
	t, err := fasttemplate.NewTemplate(norm, startTag, endTag)
	if err != nil {
		return nil, fmt.Errorf("invalid template format %q: %v", norm, err)
	}
	return &Formatter{
		t:                t,
		expandKparamsDot: tmplExpandKparamsRegexp.MatchString(norm),
	}, nil
}

func sanitize(s string) string {
	return strings.Map(func(r rune) rune {
		if r == '{' || r == '}' || unicode.IsSpace(r) {
			return -1
		}
		return r
	},
		s,
	)
}

func normalizeTemplate(tmpl string) string { return tmplNormRegexp.ReplaceAllString(tmpl, "{{$2}}") }

const expectedBracketsSeq = "{{}}"

// isTemplateBalanced ensures the template string is balanced. This means that each tag in the template
// has its pair of leading/trailing brackets.
func isTemplateBalanced(tmpl string) (bool, int) {
	// drop all but brackets
	s := strings.Map(func(r rune) rune {
		if r == '{' || r == '}' {
			return r
		}
		return -1
	},
		tmpl,
	)
	// partition slice into 4 groups. Each group must follow
	// the correct sequence, otherwise it is an invalid field
	partSize := 4
	partitions := len(s) / partSize
	var i int
	for ; i < partitions; i++ {
		if s[i*partSize:(i+1)*partSize] != expectedBracketsSeq {
			return false, i + 1
		}
	}
	if len(s)%partSize != 0 {
		if s[i*partSize:] != expectedBracketsSeq {
			return false, i + 1
		}
	}
	return true, -1
}

```

`pkg/kevent/formatter_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"

	kpars "github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTemplateUnknownField(t *testing.T) {
	template := "{{ .Seq }} {{NUllField1}} {{.Type}}"
	_, err := NewFormatter(template)
	require.Error(t, err, "NUllField1 is not a known field name. Maybe you meant one of the following fields: .CPU .Category .Comm .Cwd .Description .Exe .Handles .Host .Kparams .Meta .Pid .Ppid .Process .Seq .Sid .Tid .Timestamp .Type")
}

func TestTemplateEmptyField(t *testing.T) {
	template := "{{ .Seq }} {{}} {{.Type}}"
	_, err := NewFormatter(template)
	require.Error(t, err, "empty field found at position 2")

	template1 := "{{ .Seq }} {{.CPU}} -  ({{.Type}}) -- pid: {{}} {{ .Kparams.Pid }} ({{.Kparams}}) {{ .Meta }}"
	_, err = NewFormatter(template1)
	require.Error(t, err, "empty field found at position 4")
}

func TestTemplateSyntaxError(t *testing.T) {
	template := "{{ .Seq }} {{.CPU}} {.Type}}"
	_, err := NewFormatter(template)
	require.Error(t, err, "template syntax error near field #3: {{ .Seq }} {{.CPU}} {.Type}}")
}

func TestFormat(t *testing.T) {
	template := "{{ .Seq }} {{.CPU}} -  ({{.Type}}) -- pid: {{ .Kparams.Pid }} ({{.Kparams}}) {{ .Meta }}"
	f, err := NewFormatter(template)
	require.NoError(t, err)
	params := Kparams{
		kpars.ProcessID: {Name: kpars.ProcessID, Type: kpars.HexInt32, Value: kpars.Hex("0x36c")},
	}
	s := f.Format(&Kevent{CPU: uint8(4), Name: "CreateProcess", Seq: uint64(1999), Kparams: params, Metadata: map[MetadataKey]string{"key1": "value1"}})
	assert.Equal(t, "1999 4 -  (CreateProcess) -- pid: 0x36c (pid➜ 0x36c) key1: value1", string(s))
}

func TestFormatPS(t *testing.T) {
	template := "{{ .Seq }} {{ .Process }} ({{ .Cwd }}) {{ .Ppid }} ({{ .Sid }})"
	f, err := NewFormatter(template)
	require.NoError(t, err)
	params := Kparams{
		kpars.ProcessID: {Name: kpars.ProcessID, Type: kpars.HexInt32, Value: kpars.Hex("0x36c")},
	}
	s := f.Format(&Kevent{
		CPU:     uint8(4),
		Name:    "CreateProcess",
		Seq:     uint64(1999),
		Kparams: params,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Cwd:  "C:/Windows/System32",
			SID:  "nedo/archrabbit",
			Ppid: 2324,
			Handles: htypes.Handles{
				{Name: "C:/Windows/notepad.exe", Type: "File"},
				{Name: "HKEY_LOCAL_MACHINE/Software", Type: "Key"},
			},
		},
	})
	assert.Equal(t, "1999 cmd.exe (C:/Windows/System32) 2324 (nedo/archrabbit)", string(s))
}

func TestNormalizeTemplate(t *testing.T) {
	assert.Equal(t, "{{.Seq}}   {{.CPU}}", normalizeTemplate("{{ .Seq }}   {{   .CPU   }}"))
}

func TestIsTemplateBalanced(t *testing.T) {
	ok, pos := isTemplateBalanced("{{ .Seq }} {{.CPU}}")
	require.True(t, ok)
	assert.Equal(t, -1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} ({{.CPU}}) [] {{.Type}}")
	require.True(t, ok)
	assert.Equal(t, -1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {.CPU}} {{.Type}}")
	require.False(t, ok)
	assert.Equal(t, 2, pos)

	ok, pos = isTemplateBalanced("{.Seq}")
	require.False(t, ok)
	assert.Equal(t, 1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} .CPU }}")
	require.False(t, ok)
	assert.Equal(t, 2, pos)

	ok, pos = isTemplateBalanced("{{{ .Seq }} {{.CPU}} {{} {{ .Kparams }} { .Kparams.pid}}")
	require.False(t, ok)
	assert.Equal(t, 1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {{.CPU}} {{} {{ .Kparams }} { .Kparams.pid}}")
	require.False(t, ok)
	assert.Equal(t, 3, pos)

	ok, pos = isTemplateBalanced("({{ .Seq }}) {{.CPU}} {{}} {{ .Kparams }} { .Kparams.pid}}")
	require.False(t, ok)
	assert.Equal(t, 5, pos)

	ok, pos = isTemplateBalanced("{{ .Seq } {{.CPU}} {.Type}}")
	require.False(t, ok)
	assert.Equal(t, 1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {{.CPU}} {.Type}}")
	require.False(t, ok)
	assert.Equal(t, 3, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {{.CPU}} -  ({{.Type}}) -- pid: {{]} {{ .Kparams.Pid }} ({{.Kparams}}) {{ .Meta }}")
	require.False(t, ok)
	assert.Equal(t, 4, pos)
}

```

`pkg/kevent/formatter_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"strconv"
	"strings"
)

// Format applies the template on the provided kernel event.
func (f *Formatter) Format(kevt *Kevent) []byte {
	if kevt == nil {
		return []byte{}
	}
	values := map[string]interface{}{
		ts:          kevt.Timestamp.String(),
		pid:         strconv.FormatUint(uint64(kevt.PID), 10),
		tid:         strconv.FormatUint(uint64(kevt.Tid), 10),
		seq:         strconv.FormatUint(kevt.Seq, 10),
		cpu:         strconv.FormatUint(uint64(kevt.CPU), 10),
		typ:         kevt.Name,
		cat:         kevt.Category,
		desc:        kevt.Description,
		host:        kevt.Host,
		meta:        kevt.Metadata.String(),
		kparameters: kevt.Kparams.String(),
	}

	// add process' metadata
	ps := kevt.PS
	if ps != nil {
		values[proc] = ps.Name
		values[ppid] = strconv.FormatUint(uint64(ps.Ppid), 10)
		values[cwd] = ps.Cwd
		values[exe] = ps.Exe
		values[comm] = ps.Comm
		values[sid] = ps.SID
		parent := ps.Parent
		if parent != nil {
			values[pproc] = parent.Name
			values[pexe] = parent.Exe
			values[pcomm] = parent.Comm
		}
		if ps.PE != nil {
			values[pe] = ps.PE.String()
		}
	}

	if f.expandKparamsDot {
		// expand all parameters into the map so we can ask
		// for specific parameter names in the template
		for _, kpar := range kevt.Kparams {
			values[".Kparams."+strings.Title(kpar.Name)] = kpar.String()
		}
	}

	return f.t.ExecuteString(values)
}

```

`pkg/kevent/kevent.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"fmt"
	"strings"
	"sync"
	"time"

	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/hostname"
)

// pool is used to alleviate the pressure on the heap allocator
var pool = sync.Pool{
	New: func() interface{} {
		return &Kevent{}
	},
}

// TimestampFormat is the Go valid format for the kernel event timestamp
var TimestampFormat string

// MetadataKey represents the type definition for the metadata keys
type MetadataKey string

// Metadata is a type alias for event metadata. Any tag, i.e. key/value pair could be attached to metadata.
type Metadata map[MetadataKey]string

const (
	// YaraMatchesKey is the tag name for the yara matches JSON representation
	YaraMatchesKey MetadataKey = "yara.matches"
	// RuleNameKey identifies the rule that was triggered by the event
	RuleNameKey MetadataKey = "rule.name"
	// RuleGroupKey identifies the group to which the triggered rule pertains
	RuleGroupKey MetadataKey = "rule.group"
)

func (key MetadataKey) String() string { return string(key) }

// String turns kernel event's metadata into string.
func (md Metadata) String() string {
	var sb strings.Builder
	for k, v := range md {
		sb.WriteString(k.String() + ": " + v + ", ")
	}
	return strings.TrimSuffix(sb.String(), ", ")
}

// Kevent encapsulates kernel event's payload.
type Kevent struct {
	// Seq is monotonically incremented kernel event sequence.
	Seq uint64 `json:"seq"`
	// PID is the identifier of the process that generated the event.
	PID uint32 `json:"pid"`
	// Tid is the thread identifier of the thread that generated the event.
	Tid uint32 `json:"tid"`
	// Type is the internal representation of the kernel event. This field should be ignored by serializers.
	Type ktypes.Ktype `json:"-"`
	// CPU designates the processor logical core where the event was originated.
	CPU uint8 `json:"cpu"`
	// Name is the human friendly name of the kernel event.
	Name string `json:"name"`
	// Category designates the category to which this event pertains.
	Category ktypes.Category `json:"category"`
	// Description is the short explanation that describes the purpose of the event.
	Description string `json:"description"`
	// Host is the machine name that reported the generated event.
	Host string `json:"host"`
	// Timestamp represents the temporal occurrence of the event.
	Timestamp time.Time `json:"timestamp"`
	// Kparams stores the collection of kernel event parameters.
	Kparams Kparams `json:"params"`
	// Metadata represents any tags that are meaningful to this event.
	Metadata Metadata `json:"metadata"`
	// PS represents process' metadata and its allocated resources such as handles, DLLs, etc.
	PS *pstypes.PS `json:"ps,omitempty"`
}

// String returns event's string representation.
func (kevt *Kevent) String() string {
	if kevt.PS != nil {
		return fmt.Sprintf(`
		Seq: %d
		Pid: %d
		Tid: %d
		Type: %s
		CPU: %d
		Name: %s
		Category: %s
		Description: %s
		Host: %s,
		Timestamp: %s,
		Kparams: %s,
		Metadata: %s,
	    %s
	`,
			kevt.Seq,
			kevt.PID,
			kevt.Tid,
			kevt.Type,
			kevt.CPU,
			kevt.Name,
			kevt.Category,
			kevt.Description,
			kevt.Host,
			kevt.Timestamp,
			kevt.Kparams,
			kevt.Metadata,
			kevt.PS,
		)
	}
	return fmt.Sprintf(`
		Seq: %d
		Pid: %d
		Tid: %d
		Type: %s
		CPU: %d
		Name: %s
		Category: %s
		Description: %s
		Host: %s,
		Timestamp: %s,
		Kparams: %s,
		Metadata: %s
	`,
		kevt.Seq,
		kevt.PID,
		kevt.Tid,
		kevt.Type,
		kevt.CPU,
		kevt.Name,
		kevt.Category,
		kevt.Description,
		kevt.Host,
		kevt.Timestamp,
		kevt.Kparams,
		kevt.Metadata,
	)
}

// New constructs a new kernel event instance.
func New(seq uint64, pid, tid uint32, cpu uint8, ktype ktypes.Ktype, ts time.Time, kpars Kparams) *Kevent {
	kevt := pool.Get().(*Kevent)
	*kevt = Kevent{
		Seq:         seq,
		PID:         pid,
		Tid:         tid,
		CPU:         cpu,
		Type:        ktype,
		Category:    ktype.Category(),
		Name:        ktype.String(),
		Description: ktype.Description(),
		Timestamp:   ts,
		Kparams:     kpars,
		Metadata:    make(map[MetadataKey]string),
		Host:        hostname.Get(),
	}
	return kevt
}

// Empty return a pristine kernel event instance.
func Empty() *Kevent {
	return &Kevent{
		Kparams:  map[string]*Kparam{},
		Metadata: make(map[MetadataKey]string),
		PS:       &pstypes.PS{},
	}
}

// NewFromKcap recovers the kernel event instance from the kcapture byte buffer.
func NewFromKcap(buf []byte) (*Kevent, error) {
	kevt := &Kevent{
		Kparams:  make(Kparams),
		Metadata: make(map[MetadataKey]string),
	}
	if err := kevt.UnmarshalRaw(buf, kcapver.KevtSecV1); err != nil {
		return nil, err
	}
	return kevt, nil
}

// AddMeta appends a key/value pair to event's metadata.
func (kevt *Kevent) AddMeta(k MetadataKey, v string) {
	kevt.Metadata[k] = v
}

// Release returns an event to the pool.
func (kevt *Kevent) Release() {
	*kevt = Kevent{} // clear kevent
	pool.Put(kevt)
}

```

`pkg/kevent/kevent_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import "github.com/rabbitstack/fibratus/pkg/kevent/ktypes"

// IsNetworkTCP determines whether the kevent pertains to network TCP events.
func (kevt Kevent) IsNetworkTCP() bool {
	return kevt.Type != ktypes.RecvUDPv4 && kevt.Type != ktypes.RecvUDPv6 && kevt.Type != ktypes.SendUDPv4 && kevt.Type != ktypes.SendUDPv6
}

// IsNetworkUDP determines whether the kevent pertains to network UDP events.
func (kevt Kevent) IsNetworkUDP() bool {
	return kevt.Type == ktypes.RecvUDPv4 || kevt.Type == ktypes.RecvUDPv6 || kevt.Type == ktypes.SendUDPv4 || kevt.Type == ktypes.SendUDPv6
}

```

`pkg/kevent/kevent_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestKeventIsNetworkTCP(t *testing.T) {
	assert.True(t, Kevent{Type: ktypes.AcceptTCPv4}.IsNetworkTCP())
	assert.False(t, Kevent{Type: ktypes.SendUDPv6}.IsNetworkTCP())
}

func TestKeventIsNetworkUDP(t *testing.T) {
	assert.True(t, Kevent{Type: ktypes.RecvUDPv4}.IsNetworkUDP())
	assert.False(t, Kevent{Type: ktypes.SendTCPv6}.IsNetworkUDP())
}

```

`pkg/kevent/kparam.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"fmt"
	"net"
	"reflect"
	"sort"
	"strings"
	"time"

	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
)

// ParamCaseStyle is the type definition for parameter name case style
type ParamCaseStyle uint8

const (
	// SnakeCase is the default parameter's name case style. Multi-word parameters are delimited by underscore symbol (e.g. process_object)
	SnakeCase ParamCaseStyle = 1
	// DotCase style uses a dot to separate multi-word parameter names (e.g. process.object)
	DotCase ParamCaseStyle = 2
	// PascalCase renders parameter name with pascal case naming style (e.g. ProcessObject)
	PascalCase ParamCaseStyle = 3
	// CamelCase represents parameter names with camel case naming style (e.g. processObject)
	CamelCase ParamCaseStyle = 4
)

// ParamNameCaseStyle designates the case style for kernel parameter names
var ParamNameCaseStyle = SnakeCase

// ParamKVDelimiter specifies the character that delimits parameter's key from its value
var ParamKVDelimiter = "➜ "

// Kparam defines the layout of the kernel event parameter.
type Kparam struct {
	// Type is the type of the parameter. For example, `sport` parameter has the `Port` type although its value
	// is the uint16 numeric type.
	Type kparams.Type `json:"-"`
	// Value is the container for parameter values. To access the underlying value use the appropriate `Get` methods.
	Value kparams.Value `json:"value"`
	// Name represents the name of the parameter (e.g. pid, sport).
	Name string `json:"name"`
}

// Kparams is the type that represents the sequence of kernel event parameters
type Kparams map[string]*Kparam

// KparamsFromSlice creates the params map from the variadic param list.
func KparamsFromSlice(pars ...*Kparam) Kparams {
	kpars := make(Kparams, len(pars))
	for _, kpar := range pars {
		kpars[kpar.Name] = kpar
	}
	return kpars
}

// NewKparamFromKcap builds a kparam instance from the restored state.
func NewKparamFromKcap(name string, typ kparams.Type, value kparams.Value) *Kparam {
	return &Kparam{Name: name, Type: typ, Value: value}
}

// Append adds a new parameter with the specified name, type and value.
func (kpars Kparams) Append(name string, typ kparams.Type, value kparams.Value) Kparams {
	kpars[name] = NewKparam(name, typ, value)
	return kpars
}

// AppendFromKcap adds a new parameter with the specified name, type and value from the kcap state.
func (kpars Kparams) AppendFromKcap(name string, typ kparams.Type, value kparams.Value) Kparams {
	kpars[name] = NewKparamFromKcap(name, typ, value)
	return kpars
}

// Contains determines whether the specified parameter name exists.
func (kpars Kparams) Contains(name string) bool {
	_, err := kpars.findParam(name)
	return err == nil
}

// Remove deletes the specified parameter from the map.
func (kpars Kparams) Remove(name string) {
	delete(kpars, name)
}

// Len returns the number of parameters.
func (kpars Kparams) Len() int { return len(kpars) }

// Set replaces the value that is indexed at existing parameter name. It will return an error
// if the supplied parameter is not present.
func (kpars Kparams) Set(name string, value kparams.Value, typ kparams.Type) error {
	_, err := kpars.findParam(name)
	if err != nil {
		return fmt.Errorf("setting the value on a missing %q parameter is not allowed", name)
	}
	kpars[name] = &Kparam{Name: name, Value: value, Type: typ}
	return nil
}

// SetValue replaces the value for the given parameter name. It will return an error
// if the supplied parameter is not present in the parameter map.
func (kpars Kparams) SetValue(name string, value kparams.Value) error {
	_, err := kpars.findParam(name)
	if err != nil {
		return fmt.Errorf("setting the value on a missing %q parameter is not allowed", name)
	}
	kpars[name].Value = value
	return nil
}

// Get returns the raw value for given parameter name. It is the responsibility of the caller to probe type assertion
// on the value before yielding its underlying type.
func (kpars Kparams) Get(name string) (kparams.Value, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return "", err
	}
	return kpar.Value, nil
}

// GetString returns the underlying string value from the parameter.
func (kpars Kparams) GetString(name string) (string, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return "", err
	}
	if _, ok := kpar.Value.(string); !ok {
		return "", fmt.Errorf("unable to type cast %q parameter to string value", name)
	}
	return kpar.Value.(string), nil
}

// MustGetString returns the string parameter or panics
// if an error occurs while trying to get the parameter.
func (kpars Kparams) MustGetString(name string) string {
	s, err := kpars.GetString(name)
	if err != nil {
		panic(err)
	}
	return s
}

// GetPid returns the pid from the parameter.
func (kpars Kparams) GetPid() (uint32, error) {
	return kpars.getPid(kparams.ProcessID)
}

// MustGetPid returns the pid parameter. It panics if
// an error occurs while trying to get the pid parameter.
func (kpars Kparams) MustGetPid() uint32 {
	pid, err := kpars.GetPid()
	if err != nil {
		panic(err)
	}
	return pid
}

// GetPpid returns the parent pid from the parameter.
func (kpars Kparams) GetPpid() (uint32, error) {
	return kpars.getPid(kparams.ProcessParentID)
}

func (kpars Kparams) getPid(name string) (uint32, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return uint32(0), err
	}
	if kpar.Type != kparams.PID {
		return uint32(0), fmt.Errorf("%q parameter is not a PID", name)
	}
	v, ok := kpar.Value.(uint32)
	if !ok {
		return uint32(0), fmt.Errorf("unable to type cast %q parameter to uint32 value from pid", name)
	}
	return v, nil
}

// GetTid returns the thread id from the parameter.
func (kpars Kparams) GetTid() (uint32, error) {
	kpar, err := kpars.findParam(kparams.ThreadID)
	if err != nil {
		return uint32(0), err
	}
	if kpar.Type != kparams.TID {
		return uint32(0), fmt.Errorf("%q parameter is not a TID", kparams.ThreadID)
	}
	v, ok := kpar.Value.(uint32)
	if !ok {
		return uint32(0), fmt.Errorf("unable to type cast %q parameter to uint32 value from tid", kparams.ThreadID)
	}
	return v, nil
}

// GetUint8 returns the underlying uint8 value from the parameter.
func (kpars Kparams) GetUint8(name string) (uint8, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return uint8(0), err
	}
	v, ok := kpar.Value.(uint8)
	if !ok {
		return uint8(0), fmt.Errorf("unable to type cast %q parameter to uint8 value", name)
	}
	return v, nil
}

// GetInt8 returns the underlying int8 value from the parameter.
func (kpars Kparams) GetInt8(name string) (int8, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return int8(0), err
	}
	v, ok := kpar.Value.(int8)
	if !ok {
		return int8(0), fmt.Errorf("unable to type cast %q parameter to int8 value", name)
	}
	return v, nil
}

// GetUint16 returns the underlying int16 value from the parameter.
func (kpars Kparams) GetUint16(name string) (uint16, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return uint16(0), err
	}
	v, ok := kpar.Value.(uint16)
	if !ok {
		return uint16(0), fmt.Errorf("unable to type cast %q parameter to uint16 value", name)
	}
	return v, nil
}

// GetInt16 returns the underlying int16 value from the parameter.
func (kpars Kparams) GetInt16(name string) (int16, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return int16(0), err
	}
	v, ok := kpar.Value.(int16)
	if !ok {
		return int16(0), fmt.Errorf("unable to type cast %q parameter to int16 value", name)
	}
	return v, nil
}

// GetUint32 returns the underlying uint32 value from the parameter.
func (kpars Kparams) GetUint32(name string) (uint32, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return uint32(0), err
	}
	v, ok := kpar.Value.(uint32)
	if !ok {
		return uint32(0), fmt.Errorf("unable to type cast %q parameter to uint32 value", name)
	}
	return v, nil
}

// MustGetUint32 returns  the underlying uint32 value parameter. It panics if
// an error occurs while trying to get the parameter.
func (kpars Kparams) MustGetUint32(name string) uint32 {
	v, err := kpars.GetUint32(name)
	if err != nil {
		panic(err)
	}
	return v
}

// GetInt32 returns the underlying int32 value from the parameter.
func (kpars Kparams) GetInt32(name string) (int32, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return int32(0), err
	}
	v, ok := kpar.Value.(int32)
	if !ok {
		return int32(0), fmt.Errorf("unable to type cast %q parameter to int32 value", name)
	}
	return v, nil
}

// GetUint64 returns the underlying uint64 value from the parameter.
func (kpars Kparams) GetUint64(name string) (uint64, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return uint64(0), err
	}
	v, ok := kpar.Value.(uint64)
	if !ok {
		return uint64(0), fmt.Errorf("unable to type cast %q parameter to uint64 value", name)
	}
	return v, nil
}

// GetInt64 returns the underlying int64 value from the parameter.
func (kpars Kparams) GetInt64(name string) (int64, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return int64(0), err
	}
	v, ok := kpar.Value.(int64)
	if !ok {
		return int64(0), fmt.Errorf("unable to type cast %q parameter to int64 value", name)
	}
	return v, nil
}

// GetFloat returns the underlying float value from the parameter.
func (kpars Kparams) GetFloat(name string) (float32, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return float32(0), err
	}
	v, ok := kpar.Value.(float32)
	if !ok {
		return float32(0), fmt.Errorf("unable to type cast %q parameter to float32 value", name)
	}
	return v, nil
}

// GetDouble returns the underlying double (float64) value from the parameter.
func (kpars Kparams) GetDouble(name string) (float64, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return float64(0), err
	}
	v, ok := kpar.Value.(float64)
	if !ok {
		return float64(0), fmt.Errorf("unable to type cast %q parameter to float64 value", name)
	}
	return v, nil
}

// GetHexAsUint32 returns the number hexadecimal representation as uint32 value.
func (kpars Kparams) GetHexAsUint32(name string) (uint32, error) {
	hex, err := kpars.GetHex(name)
	if err != nil {
		return uint32(0), err
	}
	return hex.Uint32(), nil
}

// TryGetHexAsUint32 attempts to get the uint8 value from its hexadecimal representation.
// If the param is present, but doesn't have the hex type, then the param value is directly
// coerced into uint32 scalar.
func (kpars Kparams) TryGetHexAsUint32(name string) (uint32, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return 0, err
	}
	if kpar.Type == kparams.HexInt32 {
		return kpars.GetHexAsUint32(name)
	}
	return kpars.GetUint32(name)
}

// GetHexAsUint8 returns the number hexadecimal representation as uint8 value.
func (kpars Kparams) GetHexAsUint8(name string) (uint8, error) {
	hex, err := kpars.GetHex(name)
	if err != nil {
		return uint8(0), err
	}
	return hex.Uint8(), nil
}

// TryGetHexAsUint8 attempts to get the uint8 value from its hexadecimal representation.
// If the param is present, but doesn't have the hex type, then the param value is directly
// coerced into uint8 scalar.
func (kpars Kparams) TryGetHexAsUint8(name string) (uint8, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return 0, err
	}
	if kpar.Type == kparams.HexInt8 {
		return kpars.GetHexAsUint8(name)
	}
	return kpars.GetUint8(name)
}

// GetHexAsUint64 returns the number hexadecimal representation as uint64 value.
func (kpars Kparams) GetHexAsUint64(name string) (uint64, error) {
	hex, err := kpars.GetHex(name)
	if err != nil {
		return uint64(0), err
	}
	return hex.Uint64(), nil
}

// TryGetHexAsUint64 attempts to get the uint64 value from its hexadecimal representation.
// If the param is present, but doesn't have the hex type, then the param value is directly
// coerced into uint64 scalar.
func (kpars Kparams) TryGetHexAsUint64(name string) (uint64, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return 0, err
	}
	if kpar.Type == kparams.HexInt64 {
		return kpars.GetHexAsUint64(name)
	}
	return kpars.GetUint64(name)
}

// GetHex returns the generic hexadecimal type for the specified parameter name.
func (kpars Kparams) GetHex(name string) (kparams.Hex, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return "", err
	}
	v, ok := kpar.Value.(kparams.Hex)
	if !ok {
		return "", fmt.Errorf("unable to type cast %q parameter to Hex value", name)
	}
	return v, nil
}

// GetIPv4 returns the underlying IPv4 address from the parameter.
func (kpars Kparams) GetIPv4(name string) (net.IP, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return net.IP{}, err
	}
	if kpar.Type != kparams.IPv4 {
		return net.IP{}, fmt.Errorf("%q parameter is not an IPv4 address", name)
	}
	v, ok := kpar.Value.(net.IP)
	if !ok {
		return net.IP{}, fmt.Errorf("unable to type cast %q parameter to net.IP value", name)
	}
	return v, nil
}

// GetIPv6 returns the underlying IPv6 address from the parameter.
func (kpars Kparams) GetIPv6(name string) (net.IP, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return net.IP{}, err
	}
	if kpar.Type != kparams.IPv6 {
		return net.IP{}, fmt.Errorf("%q parameter is not an IPv6 address", name)
	}
	v, ok := kpar.Value.(net.IP)
	if !ok {
		return net.IP{}, fmt.Errorf("unable to type cast %q parameter to net.IP value", name)
	}
	return v, nil
}

// GetIP returns either the IPv4 or IPv6 address from the parameter.
func (kpars Kparams) GetIP(name string) (net.IP, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return net.IP{}, err
	}
	if kpar.Type != kparams.IPv4 && kpar.Type != kparams.IPv6 {
		return net.IP{}, fmt.Errorf("%q parameter is not an IP address", name)
	}
	v, ok := kpar.Value.(net.IP)
	if !ok {
		return net.IP{}, fmt.Errorf("unable to type cast %q parameter to net.IP value", name)
	}
	return v, nil
}

// GetTime returns the underlying time structure from the parameter.
func (kpars Kparams) GetTime(name string) (time.Time, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return time.Unix(0, 0), err
	}
	v, ok := kpar.Value.(time.Time)
	if !ok {
		return time.Unix(0, 0), fmt.Errorf("unable to type cast %q parameter to Time value", name)
	}
	return v, nil
}

// GetStringSlice returns the string slice from the event parameter.
func (kpars Kparams) GetStringSlice(name string) ([]string, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return nil, err
	}
	v, ok := kpar.Value.([]string)
	if !ok {
		return nil, fmt.Errorf("unable to type cast %q parameter to string slice", name)
	}
	return v, nil
}

// GetSlice returns the slice of generic values from the parameter.
func (kpars Kparams) GetSlice(name string) (kparams.Value, error) {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return nil, err
	}
	if reflect.TypeOf(kpar.Value).Kind() != reflect.Slice {
		return nil, fmt.Errorf("%q parameter is not a slice", name)
	}
	return kpar.Value, nil
}

// String returns the string representation of the event parameters. Parameter names are rendered according
// to the currently active parameter style case.
func (kpars Kparams) String() string {
	var sb strings.Builder
	// sort parameters by name
	pars := make([]*Kparam, 0, len(kpars))
	for _, kpar := range kpars {
		pars = append(pars, kpar)
	}
	sort.Slice(pars, func(i, j int) bool { return pars[i].Name < pars[j].Name })
	for i, kpar := range pars {
		switch ParamNameCaseStyle {
		case SnakeCase:
			sb.WriteString(kpar.Name + ParamKVDelimiter + kpar.String())
		case DotCase:
			sb.WriteString(strings.Replace(kpar.Name, "_", ".", -1) + ParamKVDelimiter + kpar.String())
		case PascalCase:
			sb.WriteString(strings.Replace(strings.Title(strings.Replace(kpar.Name, "_", " ", -1)), " ", "", -1) + ParamKVDelimiter + kpar.String())
		case CamelCase:
		}
		if i != len(pars)-1 {
			sb.WriteString(", ")
		}
	}
	return sb.String()
}

// Find returns the kparam with specified name. If it is not found, nil value is returned.
func (kpars Kparams) Find(name string) *Kparam {
	kpar, err := kpars.findParam(name)
	if err != nil {
		return nil
	}
	return kpar
}

// findParam lookups a parameter in the map and returns an error if it doesn't exist.
func (kpars Kparams) findParam(name string) (*Kparam, error) {
	if _, ok := kpars[name]; !ok {
		return nil, &kerrors.ErrKparamNotFound{Name: name}
	}
	return kpars[name], nil
}

```

`pkg/kevent/kparam_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestKparams(t *testing.T) {
	kpars := Kparams{
		kparams.FileObject:        {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(18446738026482168384)},
		kparams.ThreadID:          {Name: kparams.ThreadID, Type: kparams.Uint32, Value: uint32(1484)},
		kparams.FileCreateOptions: {Name: kparams.FileCreateOptions, Type: kparams.Uint32, Value: uint32(1223456)},
		kparams.FileName:          {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\kernel32.dll"},
		kparams.FileShareMask:     {Name: kparams.FileShareMask, Type: kparams.Uint32, Value: uint32(5)},
	}

	assert.True(t, kpars.Contains(kparams.FileObject))
	assert.False(t, kpars.Contains(kparams.FileOffset))

	filename, err := kpars.GetString(kparams.FileName)
	require.NoError(t, err)
	assert.Equal(t, "\\Device\\HarddiskVolume2\\Windows\\system32\\kernel32.dll", filename)

	_, err = kpars.GetString(kparams.FileObject)
	require.Error(t, err)

	assert.Equal(t, 5, kpars.Len())

	kpars.Remove(kparams.ThreadID)

	assert.False(t, kpars.Contains(kparams.ThreadID))
	assert.Equal(t, 4, kpars.Len())

	require.NoError(t, kpars.Set(kparams.FileShareMask, fs.FileShareMode(5), kparams.Enum))

	filemode, err := kpars.Get(kparams.FileShareMask)
	require.NoError(t, err)
	mode := filemode.(fs.FileShareMode)

	assert.Equal(t, "r-d", mode.String())

	fileObject, err := kpars.TryGetHexAsUint64(kparams.FileObject)
	require.NoError(t, err)
	assert.Equal(t, uint64(18446738026482168384), fileObject)

	kpars1 := Kparams{
		kparams.FileObject: {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("FFFFFA800528F240")},
	}

	fileObjectFromHex, err := kpars1.TryGetHexAsUint64(kparams.FileObject)
	require.NoError(t, err)
	assert.Equal(t, uint64(18446738026482168384), fileObjectFromHex)

	require.NoError(t, kpars.SetValue(kparams.FileName, "\\Device\\HarddiskVolume2\\Windows\\system32\\KERNEL32.dll"))
	filename1, err := kpars.GetString(kparams.FileName)
	require.NoError(t, err)
	assert.Equal(t, "\\Device\\HarddiskVolume2\\Windows\\system32\\KERNEL32.dll", filename1)
}

```

`pkg/kevent/kparam_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"fmt"
	"net"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/network"
	"github.com/rabbitstack/fibratus/pkg/syscall/security"
	"github.com/rabbitstack/fibratus/pkg/util/ip"
)

// NewKparam creates a new event parameter. Since the parameter type is already categorized,
// we can coerce the value to the appropriate representation (e.g. hex, IP address, user security identifier, etc.)
func NewKparam(name string, typ kparams.Type, value kparams.Value) *Kparam {
	var v kparams.Value
	switch typ {
	case kparams.HexInt8, kparams.HexInt16, kparams.HexInt32, kparams.HexInt64:
		v = kparams.NewHex(value)
	case kparams.IPv4:
		v = ip.ToIPv4(value.(uint32))
	case kparams.IPv6:
		v = ip.ToIPv6(value.([]byte))
	case kparams.Port:
		v = syscall.Ntohs(value.(uint16))
	case kparams.SID:
		account, domain := security.LookupAccount(value.([]byte), false)
		if account != "" || domain != "" {
			v = joinSID(account, domain)
		}
	case kparams.WbemSID:
		account, domain := security.LookupAccount(value.([]byte), true)
		if account != "" || domain != "" {
			v = joinSID(account, domain)
		}
	default:
		v = value
	}

	return &Kparam{Name: name, Type: typ, Value: v}
}

// String returns the string representation of the parameter value.
func (k Kparam) String() string {
	if k.Value == nil {
		return ""
	}
	switch k.Type {
	case kparams.UnicodeString, kparams.AnsiString, kparams.SID, kparams.WbemSID:
		return k.Value.(string)
	case kparams.HexInt32, kparams.HexInt64, kparams.HexInt16, kparams.HexInt8:
		return string(k.Value.(kparams.Hex))
	case kparams.Int8:
		return strconv.Itoa(int(k.Value.(int8)))
	case kparams.Uint8:
		return strconv.Itoa(int(k.Value.(uint8)))
	case kparams.Int16:
		return strconv.Itoa(int(k.Value.(int16)))
	case kparams.Uint16, kparams.Port:
		return strconv.Itoa(int(k.Value.(uint16)))
	case kparams.Uint32, kparams.PID, kparams.TID:
		return strconv.Itoa(int(k.Value.(uint32)))
	case kparams.Int32:
		return strconv.Itoa(int(k.Value.(int32)))
	case kparams.Uint64:
		return strconv.FormatUint(k.Value.(uint64), 10)
	case kparams.Int64:
		return strconv.Itoa(int(k.Value.(int64)))
	case kparams.IPv4, kparams.IPv6:
		return k.Value.(net.IP).String()
	case kparams.Bool:
		return strconv.FormatBool(k.Value.(bool))
	case kparams.Float:
		return strconv.FormatFloat(float64(k.Value.(float32)), 'f', 6, 32)
	case kparams.Double:
		return strconv.FormatFloat(k.Value.(float64), 'f', 6, 64)
	case kparams.Time:
		return k.Value.(time.Time).String()
	case kparams.Enum:
		switch typ := k.Value.(type) {
		case fs.FileShareMode:
			return typ.String()
		case network.L4Proto:
			return typ.String()
		case fs.FileDisposition:
			return typ.String()
		default:
			return fmt.Sprintf("%v", k.Value)
		}
	case kparams.Slice:
		switch slice := k.Value.(type) {
		case []string:
			return strings.Join(slice, ",")
		case []fs.FileAttr:
			attrs := make([]string, 0, len(slice))
			for _, s := range slice {
				attrs = append(attrs, s.String())
			}
			return strings.Join(attrs, ",")
		default:
			return fmt.Sprintf("%v", slice)
		}
	default:
		return fmt.Sprintf("%v", k.Value)
	}
}

func joinSID(account, domain string) string { return fmt.Sprintf("%s\\%s", domain, account) }

```

`pkg/kevent/kparams/canonicalize.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

const (
	uniqueProcessKey = "UniqueProcessKey"
	processID        = "ProcessId"
	parentID         = "ParentId"
	sessionID        = "SessionId"
	exitStatus       = "ExitStatus"
	dirTableBase     = "DirectoryTableBase"
	userSID          = "UserSID"
	imageFileName    = "ImageFileName"
	commandLine      = "CommandLine"

	tthreadID       = "TThreadId"
	issuingThreadID = "IssuingThreadId"
	ttid            = "TTID"

	targetThreatID = "TargetThreatId" // Threat? MS typo?

	pid             = "PID"
	targetProcessID = "TargetProcessId"

	desiredAccess = "DesiredAccess"

	basePriority   = "BasePriority"
	ioPriority     = "IoPriority"
	pagePriority   = "PagePriority"
	stackBase      = "StackBase"
	stackLimit     = "StackLimit"
	userStackBase  = "UserStackBase"
	userStackLimit = "UserStackLimit"
	win32StartAddr = "Win32StartAddr"

	fileObject        = "FileObject"
	fileName          = "FileName"
	openPath          = "OpenPath"
	fileCreateOptions = "CreateOptions"
	fileShareAccess   = "ShareAccess"
	fileOffset        = "Offset"
	fileIoSize        = "IoSize"
	fileInfoClass     = "InfoClass"
	fileKey           = "FileKey"
	fileExtraInfo     = "ExtraInfo"
	fileIrpPtr        = "IrpPtr"
	fileAttributes    = "FileAttributes"

	keyName        = "KeyName"
	keyHandle      = "KeyHandle"
	registryStatus = "Status"

	ntStatus   = "NtStatus"
	returnCode = "ReturnCode"

	imageBase        = "ImageBase"
	imageSize        = "ImageSize"
	imageChecksum    = "ImageCheckSum"
	imageDefaultBase = "DefaultBase"

	netDaddr = "daddr"
	netSaddr = "saddr"
	netDport = "dport"
	netSport = "sport"
	netSize  = "size"

	handleID         = "Handle"
	handleObject     = "Object"
	handleObjectName = "ObjectName"
	handleObjectType = "ObjectType"
)

// Canonicalize takes an original kernel event property name and normalizes it
// to canonical parameter name.
func Canonicalize(name string) string {
	switch name {
	case tthreadID, issuingThreadID, ttid, targetThreatID:
		return ThreadID
	case processID, pid, targetProcessID:
		return ProcessID
	case uniqueProcessKey:
		return ProcessObject
	case parentID:
		return ProcessParentID
	case sessionID:
		return SessionID
	case imageFileName:
		return ProcessName
	case commandLine:
		return Comm
	case userSID:
		return UserSID
	case exitStatus:
		return ExitStatus
	case dirTableBase:
		return DTB
	case basePriority:
		return BasePrio
	case ioPriority:
		return IOPrio
	case pagePriority:
		return PagePrio
	case stackBase:
		return KstackBase
	case stackLimit:
		return KstackLimit
	case userStackBase:
		return UstackBase
	case userStackLimit:
		return UstackLimit
	case win32StartAddr:
		return ThreadEntrypoint
	case fileObject:
		return FileObject
	case fileName, openPath:
		return FileName
	case fileCreateOptions:
		return FileCreateOptions
	case fileShareAccess:
		return FileShareMask
	case fileOffset:
		return FileOffset
	case fileIoSize:
		return FileIoSize
	case fileInfoClass:
		return FileInfoClass
	case fileKey:
		return FileKey
	case fileExtraInfo:
		return FileExtraInfo
	case fileIrpPtr:
		return FileIrpPtr
	case keyName:
		return RegKeyName
	case keyHandle:
		return RegKeyHandle
	case imageBase:
		return ImageBase
	case imageDefaultBase:
		return ImageDefaultBase
	case imageSize:
		return ImageSize
	case imageChecksum:
		return ImageCheckSum
	case netDaddr:
		return NetDIP
	case netSaddr:
		return NetSIP
	case netDport:
		return NetDport
	case netSport:
		return NetSport
	case netSize:
		return NetSize
	case handleID:
		return HandleID
	case handleObject:
		return HandleObject
	case handleObjectName:
		return HandleObjectName
	case handleObjectType:
		return HandleObjectTypeID
	case registryStatus, ntStatus, returnCode:
		return NTStatus
	case desiredAccess:
		return DesiredAccess
	case fileAttributes:
		return FileAttributes
	default:
		return ""
	}
}

```

`pkg/kevent/kparams/canonicalize_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

```

`pkg/kevent/kparams/fields_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

const (
	// NTStatus is the parameter that identifies the NTSTATUS value.
	NTStatus = "status"

	// ProcessID represents the process identifier.
	ProcessID = "pid"
	// ProcessObject field represents the address of the process object in the kernel.
	ProcessObject = "kproc"
	// ThreadID field represents the thread identifier.
	ThreadID = "tid"
	// ProcessParentID field represents the parent process identifier.
	ProcessParentID = "ppid"
	// SessionID fields represents the session identifier.
	SessionID = "session_id"
	// UserSID field is the security identifier associated to the process token under which it is run.
	UserSID = "sid"
	// ProcessName field denotes the process image name.
	ProcessName = "name"
	// Exe field denotes the full path of the executable.
	Exe = "exe"
	// Comm field represents the process command line.
	Comm = "comm"
	// DTB field denotes the address of the process directory table.
	DTB = "directory_table_base"
	// ExitStatus is the field that represents the process exit status.
	ExitStatus = "exit_status"
	// StartTime field denotes the process start time.
	StartTime = "start_time"

	// DesiredAccess field denotes the access rights for different kernel objects such as processes or threads.
	DesiredAccess = "desired_access"
	// DesiredAccessNames field denotes the list of human-readable access rights.
	DesiredAccessNames = "desired_access_names"

	// BasePrio field is the thread base priority assigned by the scheduler.
	BasePrio = "base_prio"
	// IOPrio represents the filed that indicates the thread I/O priority.
	IOPrio = "io_prio"
	// PagePrio field denotes page priority.
	PagePrio = "page_prio"
	// KstackBase field is the start address of the kernel space stack.
	KstackBase = "kstack"
	// KstackLimit field is the end address of the kernel space stack.
	KstackLimit = "kstack_limit"
	// UstackBase field is the start address of the user space stack.
	UstackBase = "ustack"
	// UstackLimit field is the end address of the user space stack.
	UstackLimit = "ustack_limit"
	// ThreadEntrypoint field is the address of the thread main function.
	ThreadEntrypoint = "entrypoint"

	// FileObject determines the field name for the file object pointer.
	FileObject = "file_object"
	// FileName represents the field that designates the absolute path of the file.
	FileName = "file_name"
	// FileCreateOptions is the field that represents the values passed in the CreateDispositions parameter to the NtCreateFile function.
	FileCreateOptions = "options"
	// FileOperation is the field that represents the values passed in the CreateOptions parameter to the NtCreateFile function.
	FileOperation = "operation"
	// FileCreated represents the name for the file creation field.
	FileCreated = "created"
	// FileAccessed represents the name for the file access field.
	FileAccessed = "accessed"
	// FileModified represents the name for the file modification field.
	FileModified = "modified"
	// FileShareMask represents the field name for the share access mask.
	FileShareMask = "share_mask"
	// FileType represents the field name that indicates the file type.
	FileType = "type"
	// FileAttributes is the field that represents file attribute values.
	FileAttributes = "attributes"
	// FileIoSize is the filed that represents the number of bytes in file read/write operations.
	FileIoSize = "io_size"
	// FileOffset represents the file for the file offset in read/write operations.
	FileOffset = "offset"
	// FileInfoClass represents the file information class.
	FileInfoClass = "class"
	// FileKey represents the directory key identifier in EnumDirectory events.
	FileKey = "file_key"
	// FileDirectory represents the filed for the directory name in EnumDirectory events.
	FileDirectory = "dir"
	// FileIrpPtr represents the I/O request packet id.
	FileIrpPtr = "irp"
	// FileExtraInfo is the parameter that represents extra information returned by the file system for the operation. For example for a read request, the actual number of bytes that were read.
	FileExtraInfo = "extra_info"

	// RegKeyHandle identifies the parameter name for the registry key handle.
	RegKeyHandle = "key_handle"
	// RegKeyName represents the parameter name for the fully qualified key name.
	RegKeyName = "key_name"
	// RegValue identifies the parameter name that contains the value
	RegValue = "value"
	// RegValueType identifies the parameter that represents registry value type e.g (DWORD, BINARY)
	RegValueType = "type"

	// ImageBase identifies the parameter name for the base address of the process in which the image is loaded.
	ImageBase = "base_address"
	// ImageSize represents the parameter name for the size of the image in bytes.
	ImageSize = "image_size"
	// ImageCheckSum is the parameter name for image checksum.
	ImageCheckSum = "checksum"
	// ImageDefaultBase is the parameter name that represents image's base address.
	ImageDefaultBase = "default_address"
	// ImageFilename is the parameter name that denotes file name and extension of the DLL/executable image.
	ImageFilename = "file_name"

	// NetSize identifies the parameter name that represents the packet size.
	NetSize = "size"
	// NetDIP is the parameter name that denotes the destination IP address.
	NetDIP = "dip"
	// NetSIP is the parameter name that denotes the source IP address.
	NetSIP = "sip"
	// NetDport identifies the parameter name that represents destination port number.
	NetDport = "dport"
	// NetSport identifies the parameter name that represents source port number.
	NetSport = "sport"
	// NetMSS is the parameter name that represents the maximum TCP segment size.
	NetMSS = "mss"
	// NetRcvWin is the parameter name that represents TCP segment's receive window size.
	NetRcvWin = "rcvwin"
	// NetSAckopt is the parameter name that represents Selective Acknowledgment option in TCP header.
	NetSAckopt = "sack_opt"
	// NetTsopt is the parameter name that represents the time stamp option in TCP header.
	NetTsopt = "timestamp_opt"
	// NetWsopt is the parameter name that represents the window scale option in TCP header.
	NetWsopt = "window_scale_opt"
	// NetRcvWinScale is the parameter name that represents the TCP receive window scaling factor.
	NetRcvWinScale = "recv_winscale"
	// NetSendWinScale is the parameter name that represents the TCP send window scaling factor.
	NetSendWinScale = "send_winscale"
	// NetSeqNum is the parameter name that represents that represents the TCP sequence number.
	NetSeqNum = "seqnum"
	// NetConnID is the parameter name that represents a unique connection identifier.
	NetConnID = "connid"
	// NetL4Proto is the parameter name that identifies the Layer 4 protocol name.
	NetL4Proto = "l4_proto"
	// NetDportName is the field that denotes the destination port name.
	NetDportName = "dport_name"
	// NetSportName is the field that denotes the source port name.
	NetSportName = "sport_name"
	// NetSIPNames is the field that denotes the source IP address names.
	NetSIPNames = "sip_names"
	// NetDIPNames is the field that denotes the destination IP address names.
	NetDIPNames = "dip_names"

	// HandleID identifies the parameter that specifies the handle identifier.
	HandleID = "handle_id"
	// HandleObject identifies the parameter that represents the kernel object to which handle is associated.
	HandleObject = "handle_object"
	// HandleObjectName identifies the parameter that represents the kernel object name.
	HandleObjectName = "handle_name"
	// HandleObjectTypeID identifies the parameter that represents the kernel object type identifier.
	HandleObjectTypeID = "type_id"
	// HandleObjectTypeName identifies the parameter that represents the kernel object type name.
	HandleObjectTypeName = "handle_type"
)

```

`pkg/kevent/kparams/readers.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2022-2023 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

import (
	"syscall"
	"unicode/utf16"
	"unsafe"
)

// ReadByte reads the byte from the buffer at the specified offset.
func ReadByte(buf uintptr, offset uint16) byte {
	return *(*byte)(unsafe.Pointer(buf + uintptr(offset)))
}

// ReadBytes reads a contiguous block of bytes from the buffer.
func ReadBytes(buf uintptr, offset uint16, nbytes uint16) []byte {
	return (*[1<<30 - 1]byte)(unsafe.Pointer(buf + uintptr(offset) + uintptr(nbytes)))[:nbytes:nbytes]
}

// ReadUint16 reads the uint16 value from the buffer at the specified offset.
func ReadUint16(buf uintptr, offset uint16) uint16 {
	return *(*uint16)(unsafe.Pointer(buf + uintptr(offset)))
}

// ReadUint32 reads the uint32 value from the buffer at the specified offset.
func ReadUint32(buf uintptr, offset uint16) uint32 {
	return *(*uint32)(unsafe.Pointer(buf + uintptr(offset)))
}

// ReadUint64 reads the uint64 value from the buffer at the specified offset.
func ReadUint64(buf uintptr, offset uint16) uint64 {
	return *(*uint64)(unsafe.Pointer(buf + uintptr(offset)))
}

// ReadAnsiString reads the ANSI string from the buffer at the specified offset and buffer length.
func ReadAnsiString(buf uintptr, offset, length uint16) (string, uint16) {
	if offset > length {
		return "", 0
	}
	b := make([]byte, length)
	var i uint16
	for i < length {
		c := *(*byte)(unsafe.Pointer(buf + uintptr(offset) + uintptr(i)))
		if c == 0 {
			break // null terminator
		}
		b[i] = c
		i++
	}
	if int(i) > len(b) {
		return string(b[:len(b)-1]), uint16(len(b))
	}
	return string(b[:i]), i + 1
}

// ReadUTF16String reads the UTF-16 string from the buffer at the specified offset and buffer length.
func ReadUTF16String(buf uintptr, offset, length uint16) (string, uint16) {
	if offset > length {
		return "", 0
	}
	s := (*[1<<30 - 1]uint16)(unsafe.Pointer(buf + uintptr(offset)))[: length-offset : length-offset]
	return syscall.UTF16ToString(s), uint16(len(s) + 2)
}

// ConsumeUTF16String reads the byte slice with UTF16-encoded string
// when the UTF16 string is located at the end of the buffer.
func ConsumeUTF16String(buf uintptr, offset, length uint16) string {
	if offset > length {
		return ""
	}
	s := (*[1<<30 - 1]uint16)(unsafe.Pointer(buf + uintptr(offset)))[: length-offset : length-offset]
	return string(utf16.Decode(s[:len(s)/2-1]))
}

// ReadSID reads the security identifier from the provided buffer.
func ReadSID(buf uintptr, offset uint16) ([]byte, uint16) {
	// this is a Security Token which can be null and takes 4 bytes.
	// Otherwise it is an 8 byte structure (TOKEN_USER) followed by SID,
	// which is variable size depending on the 2nd byte in the SID
	sid := ReadUint32(buf, offset)
	if sid == 0 {
		return nil, offset + 4
	}
	const tokenSize uint16 = 16

	authorities := ReadByte(buf, offset+(tokenSize+1))
	end := offset + tokenSize + 8 + 4*uint16(authorities)
	b := make([]byte, end-offset)
	i := offset
	for i < end {
		b[i-offset] = *(*byte)(unsafe.Pointer(buf + uintptr(i)))
		i++
	}
	return b, end
}

```

`pkg/kevent/kparams/readers_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

import (
	"github.com/stretchr/testify/assert"
	"testing"
	"unsafe"
)

func TestReadBuffer(t *testing.T) {
	b := []byte{
		0x70, 0x3B, 0xD1, 0x24, 0x8E, 0xD6, 0xFF, 0xFF, 0x9C, 0x02, 0x00, 0x00, 0x2C, 0x00, 0x5C, 0x00,
		0x52, 0x00, 0x45, 0x00, 0x47, 0x00, 0x49, 0x00, 0x53, 0x00, 0x54, 0x00, 0x52, 0x00, 0x59, 0x00,
		0x5C, 0x00, 0x55, 0x00, 0x53, 0x00, 0x45, 0x00, 0x52, 0x00, 0x5C, 0x00, 0x53, 0x00, 0x2D, 0x00,
		0x31, 0x00, 0x2D, 0x00, 0x35, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x31, 0x00, 0x2D, 0x00, 0x32, 0x00,
		0x32, 0x00, 0x37, 0x00, 0x31, 0x00, 0x30, 0x00, 0x33, 0x00, 0x34, 0x00, 0x34, 0x00, 0x35, 0x00,
		0x32, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x36, 0x00, 0x30, 0x00, 0x36, 0x00, 0x32, 0x00, 0x37, 0x00,
		0x30, 0x00, 0x30, 0x00, 0x39, 0x00, 0x39, 0x00, 0x2D, 0x00, 0x39, 0x00, 0x38, 0x00, 0x34, 0x00,
		0x38, 0x00, 0x37, 0x00, 0x31, 0x00, 0x35, 0x00, 0x36, 0x00, 0x39, 0x00, 0x2D, 0x00, 0x31, 0x00,
		0x30, 0x00, 0x30, 0x00, 0x31, 0x00, 0x00, 0x00}
	p := uintptr(unsafe.Pointer(&b[0]))

	assert.Equal(t, uint64(18446698504724233072), ReadUint64(p, 0))
	assert.Equal(t, uint32(668), ReadUint32(p, 8))
	assert.Equal(t, uint16(44), ReadUint16(p, 12))
	assert.Equal(t, "\\REGISTRY\\USER\\S-1-5-21-2271034452-2606270099-984871569-1001", ConsumeUTF16String(p, 14, uint16(len(b))))
}

```

`pkg/kevent/kparams/size.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

// SizeOf returns the size in bytes of the event parameters
// that are known at compile time. This can notably offload
// the API calls that fetch the property size at runtime.
func SizeOf(kpar string) uint32 {
	switch kpar {
	case RegKeyHandle, KstackLimit, KstackBase, UstackLimit,
		UstackBase, ThreadEntrypoint, ImageBase, ImageSize,
		ImageDefaultBase, DTB, ProcessObject, FileIrpPtr, FileObject,
		FileExtraInfo, HandleObject, FileKey, FileOffset:
		return 8
	case NTStatus, ProcessID, ThreadID, ProcessParentID,
		SessionID, ExitStatus, FileCreateOptions, FileShareMask,
		HandleID, FileIoSize, FileInfoClass, FileAttributes:
		return 4
	case NetDport, NetSport, HandleObjectTypeID:
		return 2
	case PagePrio, BasePrio, IOPrio:
		return 1
	default:
		return 0
	}
}

```

`pkg/kevent/kparams/size_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestSizeOf(t *testing.T) {
	require.Equal(t, uint32(4), SizeOf(ProcessID))
	require.Equal(t, uint32(8), SizeOf(RegKeyHandle))
	require.Equal(t, uint32(0), SizeOf(ProcessName))
}

```

`pkg/kevent/kparams/types_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

import (
	"strconv"
)

const (
	// NA defines absent parameter's value
	NA = "na"
)

// Value defines the container for parameter values
type Value interface{}

// Type defines kernel event parameter type
type Type uint16

// Hex is the type alias for hexadecimal values
type Hex string

// NewHex creates a new Hex type from the given integer value.
func NewHex(v Value) Hex {
	switch n := v.(type) {
	case uint8:
		return Hex(strconv.FormatUint(uint64(n), 16))
	case uint16:
		return Hex(strconv.FormatUint(uint64(n), 16))
	case uint32:
		return Hex(strconv.FormatUint(uint64(n), 16))
	case int32:
		return Hex(strconv.FormatInt(int64(n), 16))
	case uint64:
		return Hex(strconv.FormatUint(n, 16))
	case int64:
		return Hex(strconv.FormatInt(n, 16))
	default:
		return ""
	}
}

// Uint8 yields an uint8 value from its hex representation.
func (hex Hex) Uint8() uint8 { return uint8(hex.parseUint(8)) }

// Uint16 yields an uint16 value from its hex representation.
func (hex Hex) Uint16() uint16 { return uint16(hex.parseUint(16)) }

// Uint32 yields an uint32 value from its hex representation.
func (hex Hex) Uint32() uint32 { return uint32(hex.parseUint(32)) }

// Uint64 yields an uint64 value from its hex representation.
func (hex Hex) Uint64() uint64 { return hex.parseUint(64) }

func (hex Hex) parseUint(bitSize int) uint64 {
	num, err := strconv.ParseUint(string(hex), 16, bitSize)
	if err != nil {
		return uint64(0)
	}
	return num
}

// String returns a string representation of the hex value.
func (hex Hex) String() string {
	return string(hex)
}

const (
	// Null is a null parameter type
	Null Type = iota
	// UnicodeString a string of 16-bit characters. By default, assumed to have been encoded using UTF-16LE
	UnicodeString
	// AnsiString a string of 8-bit characters
	AnsiString
	// Int8 a signed 8-bit integer
	Int8
	// Uint8 an unsigned 8-bit integer
	Uint8
	// Int16 a signed 16-bit integer
	Int16
	// Uint16 an unsigned 16-bit integer
	Uint16
	// Int32 a signed 32-bit integer
	Int32
	// Uint32 an unsigned 32-bit integer
	Uint32
	// Int64 a signed 64-bit integer
	Int64
	// Uint64 an unsigned 64-bit integer
	Uint64
	// Float an IEEE 4-byte floating-point number
	Float
	// Double an IEEE 8-byte floating-point number
	Double
	// Bool a 32-bit value where 0 is false and 1 is true
	Bool
	// Binary is a binary data of variable size. The size must be specified in the data definition as a constant or a reference to another (integer) data item.For an IP V6 address, the data should be an IN6_ADDR structure.
	// For a socket address, the data should be a SOCKADDR_STORAGE structure. The AF_INET, AF_INET6, and AF_LINK address families are supported
	Binary
	// GUID is a GUID structure. On output, the GUID is rendered in the registry string form, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	GUID
	// Pointer an unsigned 32-bit or 64-bit pointer value. The size depends on the architecture of the computer logging the event
	Pointer
	// SID a security identifier (SID) structure that uniquely identifies a user or group
	SID
	// PID is the process identifier
	PID
	// TID is the thread identifier
	TID
	// WbemSID is the Web-Based Enterprise Management security identifier.
	WbemSID
	// HexInt8 is the hexadecimal representation of 8-bit integer
	HexInt8
	// HexInt16 is the hexadecimal representation of 16-bit integer
	HexInt16
	// HexInt32 is the hexadecimal representation of 32-bit integer
	HexInt32
	// HexInt64 is the hexadecimal representation of 64-bit integer
	HexInt64
	// Port represents the endpoint port number
	Port
	// IP is the IP address
	IP
	// IPv4 is the IPv4 address
	IPv4
	// IPv6 is the IPv6 address
	IPv6
	// Time represents the timestamp
	Time
	// Slice represents a collection of items
	Slice
	// Enum represents an enumeration
	Enum
	// Map represents a map
	Map
	// Object is the generic object
	Object
	// Unknown represent an unknown parameter type
	Unknown
)

// String return the type string representation.
func (t Type) String() string {
	switch t {
	case UnicodeString:
		return "unicode"
	case AnsiString:
		return "ansi"
	case Int8:
		return "int8"
	case Uint8:
		return "uint8"
	case HexInt8:
		return "hex8"
	case Int16:
		return "int16"
	case Uint16:
		return "uint16"
	case HexInt16:
		return "hex16"
	case Int32:
		return "int32"
	case Uint32:
		return "uint32"
	case Int64:
		return "int64"
	case Uint64:
		return "uint64"
	case HexInt32:
		return "hex32"
	case HexInt64:
		return "hex64"
	case SID, WbemSID:
		return "sid"
	case TID:
		return "tid"
	case PID:
		return "pid"
	case Port:
		return "port"
	case IPv6:
		return "ipv6"
	case IPv4:
		return "ipv4"
	default:
		return "unknown"
	}
}

```

`pkg/kevent/kparams/types_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kparams

import (
	"github.com/stretchr/testify/assert"

	"testing"
)

func TestNewHex(t *testing.T) {
	hex := NewHex(uint32(7264))
	assert.Equal(t, Hex("1c60"), hex)
	assert.Equal(t, uint32(7264), hex.Uint32())

	hex = NewHex(uint32(4294967295))
	assert.Equal(t, Hex("ffffffff"), hex)

	hex = NewHex(uint64(18446744073709551615))
	assert.Equal(t, Hex("ffffffffffffffff"), hex)
	assert.Equal(t, uint64(18446744073709551615), hex.Uint64())
}

```

`pkg/kevent/ktypes/category.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ktypes

import "hash/fnv"

// Category is the type alias for kernel event categories
type Category string

const (
	// Registry is the category for registry related kernel events
	Registry Category = "registry"
	// File is the category for file system events
	File Category = "file"
	// Net is the category for network events
	Net Category = "net"
	// Process is the category for process events
	Process Category = "process"
	// Thread is the category for thread events
	Thread Category = "thread"
	// Image is the category for image events
	Image Category = "image"
	// Handle is the category for handle events
	Handle Category = "handle"
	// Other is the category for uncategorized events
	Other Category = "other"
	// Unknown is the category for events that couldn't match any of the previous categories
	Unknown Category = "unknown"
)

// Hash obtains the hash of the category string.
func (c Category) Hash() uint32 {
	h := fnv.New32()
	_, err := h.Write([]byte(c))
	if err != nil {
		return 0
	}
	return h.Sum32()
}

```

`pkg/kevent/ktypes/ktypes_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ktypes

import (
	"hash/fnv"
	"syscall"
)

// Ktype identifies a kernel event type. It comprises the kernel event GUID + one extra opcode byte to uniquely identify a kernel event
type Ktype [17]byte

var (
	// CreateProcess identifies process creation kernel events
	CreateProcess = Pack(syscall.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 1)
	// TerminateProcess identifies process termination kernel events
	TerminateProcess = Pack(syscall.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 2)
	// EnumProcess represents the start data collection process event that enumerates processes that are currently running at the time the kernel session starts
	EnumProcess = Pack(syscall.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 3)
	// OpenProcess identifies the kernel events that are triggered when the process handle is acquired
	OpenProcess = Pack(syscall.GUID{Data1: 0xe02a841c, Data2: 0x75a3, Data3: 0x4fa7, Data4: [8]byte{0xaf, 0xc8, 0xae, 0x09, 0xcf, 0x9b, 0x7f, 0x23}}, 5)

	// CreateThread identifies thread creation kernel events
	CreateThread = Pack(syscall.GUID{Data1: 0x3d6fa8d1, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 1)
	// TerminateThread identifies thread termination kernel events
	TerminateThread = Pack(syscall.GUID{Data1: 0x3d6fa8d1, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 2)
	// EnumThread represents the start data collection thread event that enumerates threads that are currently running at the time the kernel session starts
	EnumThread = Pack(syscall.GUID{Data1: 0x3d6fa8d1, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 3)
	// OpenThread identifies the kernel events that are triggered when the process acquires a thread handle
	OpenThread = Pack(syscall.GUID{Data1: 0xe02a841c, Data2: 0x75a3, Data3: 0x4fa7, Data4: [8]byte{0xaf, 0xc8, 0xae, 0x09, 0xcf, 0x9b, 0x7f, 0x23}}, 6)

	// FileRundown events are generated by kernel rundown logger to enumerate all open files on the start of the kernel session
	FileRundown = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 36)
	// CreateFile represents events that create/open a file or I/O device
	CreateFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 64)
	// ReleaseFile represents events that occur when the last file handle is disposed
	ReleaseFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 65)
	// CloseFile represents events that dispose existing kernel file objects
	CloseFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 66)
	// ReadFile represents events that read data from the file or I/O device
	ReadFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 67)
	// WriteFile represents events that write data to the file or I/O device
	WriteFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 68)
	// SetFileInformation represents events that set file information
	SetFileInformation = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 69)
	// DeleteFile identifies file deletion events
	DeleteFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 70)
	// RenameFile identifies events that are responsible for renaming files
	RenameFile = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 71)
	// EnumDirectory identifies enumerate directory and directory notification events
	EnumDirectory = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 72)
	// FileOpEnd signals the finalization of the file operation
	FileOpEnd = Pack(syscall.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}, 76)

	// RegCreateKey represents registry key creation kernel events
	RegCreateKey = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 10)
	// RegOpenKey represents registry open key kernel events
	RegOpenKey = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 11)
	// RegDeleteKey represents registry key deletion kernel events
	RegDeleteKey = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 12)
	// RegQueryKey represents registry query key kernel events
	RegQueryKey = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 13)
	// RegSetValue represents registry set value kernel events
	RegSetValue = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 14)
	// RegDeleteValue are kernel events for registry value removals
	RegDeleteValue = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 15)
	// RegQueryValue are kernel events for registry value queries
	RegQueryValue = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 16)
	// RegCreateKCB represents kernel events for KCB (Key Control Block) creation requests
	RegCreateKCB = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 22)
	// RegDeleteKCB represents kernel events for KCB(Key Control Block) closures
	RegDeleteKCB = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 23)
	// RegKCBRundown enumerates the registry keys open at the start of the kernel session.
	RegKCBRundown = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 25)
	// RegOpenKeyV1 represents registry open key kernel event. It looks like this event type defines identical kernel event type as RegOpenKey
	RegOpenKeyV1 = Pack(syscall.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}, 27)

	// UnloadImage represents unload image kernel events
	UnloadImage = Pack(syscall.GUID{Data1: 0x2cb15d1d, Data2: 0x5fc1, Data3: 0x11d2, Data4: [8]byte{0xab, 0xe1, 0x0, 0xa0, 0xc9, 0x11, 0xf5, 0x18}}, 2)
	// EnumImage represents kernel events that is triggered to enumerate all loaded images
	EnumImage = Pack(syscall.GUID{Data1: 0x2cb15d1d, Data2: 0x5fc1, Data3: 0x11d2, Data4: [8]byte{0xab, 0xe1, 0x0, 0xa0, 0xc9, 0x11, 0xf5, 0x18}}, 3)
	// LoadImage represents load image kernel events that are triggered when a DLL or executable file  is loaded
	LoadImage = Pack(syscall.GUID{Data1: 0x2cb15d1d, Data2: 0x5fc1, Data3: 0x11d2, Data4: [8]byte{0xab, 0xe1, 0x0, 0xa0, 0xc9, 0x11, 0xf5, 0x18}}, 10)

	// AcceptTCPv4 represents the TCPv4 kernel events for accepting connection requests from the socket queue.
	AcceptTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 15)
	// AcceptTCPv6 represents the TCPv6 kernel events for accepting connection requests from the socket queue.
	AcceptTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 31)
	// SendTCPv4 represents the TCPv4 kernel events for sending data to the connected socket.
	SendTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 10)
	// SendTCPv6 represents the TCPv6 kernel events for sending data to the connected socket.
	SendTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 26)
	// SendUDPv4 represents the UDPv4 kernel events for sending datagrams to connectionless sockets.
	SendUDPv4 = Pack(syscall.GUID{Data1: 0xbf3a50c5, Data2: 0xa9c9, Data3: 0x4988, Data4: [8]byte{0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80}}, 10)
	// SendUDPv6 represents the UDPv6 kernel events for sending datagrams to connectionless sockets.
	SendUDPv6 = Pack(syscall.GUID{Data1: 0xbf3a50c5, Data2: 0xa9c9, Data3: 0x4988, Data4: [8]byte{0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80}}, 26)

	// RecvTCPv4 represents the TCP IPv4 network receive event.
	RecvTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 11)
	// RecvTCPv6 represents the TCP IPv6 network receive event.
	RecvTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 27)
	// RecvUDPv4 represents the UDP IPv4 network receive event.
	RecvUDPv4 = Pack(syscall.GUID{Data1: 0xbf3a50c5, Data2: 0xa9c9, Data3: 0x4988, Data4: [8]byte{0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80}}, 11)
	// RecvUDPv6 represents the UDP IPv6 network receive event.
	RecvUDPv6 = Pack(syscall.GUID{Data1: 0xbf3a50c5, Data2: 0xa9c9, Data3: 0x4988, Data4: [8]byte{0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80}}, 27)

	// ConnectTCPv4 represents the TCP IPv4 network connect event.
	ConnectTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 12)
	// ConnectTCPv6 represents the TCP IPv6 network connect event.
	ConnectTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 28)

	// DisconnectTCPv4 is the TCP IPv4 network disconnect event.
	DisconnectTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 13)
	// DisconnectTCPv6 is the TCP IPv6 network disconnect event.
	DisconnectTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 29)
	// Disconnect encompasses TCP IPv4/6 network disconnect events.
	Disconnect = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 42)

	// ReconnectTCPv4 is the TCP IPv4 network reconnect event.
	ReconnectTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 16)
	// ReconnectTCPv6 is the TCP IPv6 network reconnect event.
	ReconnectTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 32)

	// RetransmitTCPv4 is the TCP IPv4 network retransmit event.
	RetransmitTCPv4 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 14)
	// RetransmitTCPv6 is the TCP IPv6 network retransmit event.
	RetransmitTCPv6 = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 30)

	// Accept represents the global kernel event type for both TCP v4/v6 connections. Note this is an artificial kernel event that is never published by the provider.
	Accept = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 46)
	// Send represents the global kernel event for all variants of sending data to sockets. Note this is an artificial kernel event that is never published by the provider.
	Send = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xa9c9, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 72)
	// Recv represents the global kernel event for all variants of receiving data from sockets. Note this is an artificial kernel event that is never published by the provider.
	Recv = Pack(syscall.GUID{Data1: 0xbf3a50c5, Data2: 0xc8e0, Data3: 0x4988, Data4: [8]byte{0xa0, 0x05, 0x2d, 0xc0, 0xb7, 0xc8, 0x0f, 0x80}}, 75)
	// Connect represents the global kernel event for all variants of connecting to sockets sockets. Note this is an artificial kernel event that is never published by the provider.
	Connect = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 40)
	// Reconnect represents the global kernel event for all variants of reconnecting to sockets sockets. Note this is an artificial kernel event that is never published by the provider.
	Reconnect = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 47)
	// Retransmit represents the global kernel event for all variants of retransmitting TCP segments. Note this is an artificial kernel event that is never published by the provider.
	Retransmit = Pack(syscall.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}, 44)

	// CreateHandle represents handle creation kernel event
	CreateHandle = Pack(syscall.GUID{Data1: 0x89497f50, Data2: 0xeffe, Data3: 0x4440, Data4: [8]byte{0x8c, 0xf2, 0xce, 0x6b, 0x1c, 0xdc, 0xac, 0xa7}}, 32)
	// CloseHandle represents handle closure kernel event
	CloseHandle = Pack(syscall.GUID{Data1: 0x89497f50, Data2: 0xeffe, Data3: 0x4440, Data4: [8]byte{0x8c, 0xf2, 0xce, 0x6b, 0x1c, 0xdc, 0xac, 0xa7}}, 33)

	// UnknownKtype designates unknown kernel event type
	UnknownKtype = Pack(syscall.GUID{}, 0)
)

// String returns the string representation of the kernel event type. If event is unknown a GUID representation that includes the GUID of the event's provider + the opcode type is presented.
func (k Ktype) String() string {
	switch k {
	case CreateProcess:
		return "CreateProcess"
	case TerminateProcess:
		return "TerminateProcess"
	case OpenProcess:
		return "OpenProcess"
	case CreateThread:
		return "CreateThread"
	case TerminateThread:
		return "TerminateThread"
	case OpenThread:
		return "OpenThread"
	case CreateFile:
		return "CreateFile"
	case CloseFile:
		return "CloseFile"
	case ReleaseFile:
		return "ReleaseFile"
	case ReadFile:
		return "ReadFile"
	case WriteFile:
		return "WriteFile"
	case SetFileInformation:
		return "SetFileInformation"
	case DeleteFile:
		return "DeleteFile"
	case RenameFile:
		return "RenameFile"
	case EnumDirectory:
		return "EnumDirectory"
	case FileOpEnd:
		return "FileOpEnd"
	case FileRundown:
		return "FileRundown"
	case CreateHandle:
		return "CreateHandle"
	case CloseHandle:
		return "CloseHandle"
	case RegKCBRundown:
		return "RegKCBRundown"
	case RegOpenKey, RegOpenKeyV1:
		return "RegOpenKey"
	case RegCreateKey:
		return "RegCreateKey"
	case RegDeleteKey:
		return "RegDeleteKey"
	case RegDeleteValue:
		return "RegDeleteValue"
	case RegQueryKey:
		return "RegQueryKey"
	case RegQueryValue:
		return "RegQueryValue"
	case RegCreateKCB:
		return "RegCreateKCB"
	case RegSetValue:
		return "RegSetValue"
	case LoadImage:
		return "LoadImage"
	case UnloadImage:
		return "UnloadImage"
	case Accept, AcceptTCPv4, AcceptTCPv6:
		return "Accept"
	case Send, SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6:
		return "Send"
	case Recv, RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6:
		return "Recv"
	case Connect, ConnectTCPv4, ConnectTCPv6:
		return "Connect"
	case Reconnect, ReconnectTCPv4, ReconnectTCPv6:
		return "Reconnect"
	case Disconnect, DisconnectTCPv4, DisconnectTCPv6:
		return "Disconnect"
	case Retransmit, RetransmitTCPv4, RetransmitTCPv6:
		return "Retransmit"
	default:
		return string(k[:])
	}
}

// Category determines the category to which the ktype pertains.
func (k Ktype) Category() Category {
	switch k {
	case CreateProcess, TerminateProcess, OpenProcess:
		return Process
	case CreateThread, TerminateThread, OpenThread:
		return Thread
	case LoadImage, UnloadImage:
		return Image
	case CreateFile, ReadFile, WriteFile, EnumDirectory, DeleteFile, RenameFile, CloseFile, SetFileInformation:
		return File
	case RegCreateKey, RegDeleteKey, RegOpenKey, RegQueryKey, RegQueryValue, RegSetValue, RegDeleteValue:
		return Registry
	case AcceptTCPv4, AcceptTCPv6,
		ConnectTCPv4, ConnectTCPv6,
		ReconnectTCPv4, ReconnectTCPv6,
		RetransmitTCPv4, RetransmitTCPv6,
		DisconnectTCPv4, DisconnectTCPv6,
		SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6,
		RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6:
		return Net
	case CreateHandle, CloseHandle:
		return Handle
	default:
		return Unknown
	}
}

// Description returns a brief description of the event type.
func (k Ktype) Description() string {
	switch k {
	case CreateProcess:
		return "Creates a new process and its primary thread"
	case TerminateProcess:
		return "Terminates the process and all of its threads"
	case OpenProcess:
		return "Opens the process handle"
	case CreateThread:
		return "Creates a thread to execute within the virtual address space of the calling process"
	case TerminateThread:
		return "Terminates a thread within the process"
	case OpenThread:
		return "Opens the thread handle"
	case ReadFile:
		return "Reads data from the file or I/O device"
	case WriteFile:
		return "Writes data to the file or I/O device"
	case CreateFile:
		return "Creates or opens a file or I/O device"
	case CloseFile:
		return "Closes the file handle"
	case DeleteFile:
		return "Removes the file from the file system"
	case RenameFile:
		return "Changes the file name"
	case SetFileInformation:
		return "Sets the file meta information"
	case EnumDirectory:
		return "Enumerates a directory or dispatches a directory change notification to registered listeners"
	case RegCreateKey:
		return "Creates a registry key or opens it if the key already exists"
	case RegOpenKey, RegOpenKeyV1:
		return "Opens the registry key"
	case RegSetValue:
		return "Sets the data for the value of a registry key"
	case RegQueryValue:
		return "Reads the data for the value of a registry key"
	case RegQueryKey:
		return "Enumerates subkeys of the parent key"
	case RegDeleteKey:
		return "Removes the registry key"
	case RegDeleteValue:
		return "Removes the registry value"
	case AcceptTCPv4, AcceptTCPv6:
		return "Accepts the connection request from the socket queu"
	case ConnectTCPv4, ConnectTCPv6:
		return "Connects establishes a connection to the socket"
	case DisconnectTCPv4, DisconnectTCPv6:
		return "Terminates data reception on the socket"
	case ReconnectTCPv4, ReconnectTCPv6:
		return "Reconnects to the socket"
	case RetransmitTCPv4, RetransmitTCPv6:
		return "Retransmits unacknowledged TCP segments"
	case SendTCPv4, SendUDPv4, SendTCPv6, SendUDPv6:
		return "Sends data over the wire"
	case RecvTCPv4, RecvUDPv4, RecvTCPv6, RecvUDPv6:
		return "Receives data from the socket"
	case LoadImage:
		return "Loads the module into the address space of the calling process"
	case UnloadImage:
		return "Unloads the module from the address space of the calling process"
	case CreateHandle:
		return "Creates a new handle"
	case CloseHandle:
		return "Closes the handle"
	default:
		return ""
	}
}

// Hash calculates the hash number of the ktype.
func (k Ktype) Hash() uint32 {
	if k == UnknownKtype {
		return 0
	}
	h := fnv.New32()
	_, err := h.Write([]byte(k.String()))
	if err != nil {
		return 0
	}
	return h.Sum32()
}

// Exists determines whether particular ktype exists.
func (k Ktype) Exists() bool {
	switch k {
	case EnumProcess,
		EnumThread,
		FileRundown,
		FileOpEnd,
		ReleaseFile,
		EnumImage,
		RegCreateKCB,
		RegDeleteKCB,
		RegKCBRundown,
		CreateHandle,
		CloseHandle,
		CreateProcess,
		TerminateProcess,
		OpenProcess,
		CreateThread,
		TerminateThread,
		OpenThread,
		LoadImage,
		UnloadImage,
		CreateFile,
		WriteFile,
		ReadFile,
		DeleteFile,
		RenameFile,
		CloseFile,
		SetFileInformation,
		EnumDirectory,
		RegCreateKey,
		RegDeleteKey,
		RegOpenKey,
		RegOpenKeyV1,
		RegQueryKey,
		RegQueryValue,
		RegSetValue,
		RegDeleteValue,
		AcceptTCPv4, AcceptTCPv6,
		ConnectTCPv4, ConnectTCPv6,
		ReconnectTCPv4, ReconnectTCPv6,
		RetransmitTCPv4, RetransmitTCPv6,
		DisconnectTCPv4, DisconnectTCPv6,
		SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6,
		RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6:
		return true
	default:
		return false
	}
}

// Dropped determines whether certain events responsible for building the internal state are kept or dropped before hitting
// the output channel.
func (k Ktype) Dropped(capture bool) bool {
	switch k {
	case EnumProcess,
		EnumThread,
		FileRundown,
		FileOpEnd,
		ReleaseFile,
		EnumImage,
		RegCreateKCB,
		RegKCBRundown:
		if capture {
			return false
		}
		return true
	default:
		return false
	}
}

// UnmarshalYAML converts the ktype name to ktype array type.
func (k *Ktype) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var ktyp string
	err := unmarshal(&ktyp)
	if err != nil {
		return err
	}
	*k = KeventNameToKtype(ktyp)
	return nil
}

// Pack transforms event provider GUID and the op code into `Ktype` type. The type provides a convenient way
// to compare different kernel event types.
func Pack(g syscall.GUID, opcode uint8) Ktype {
	return [17]byte{
		byte(g.Data1 >> 24), byte(g.Data1 >> 16), byte(g.Data1 >> 8), byte(g.Data1),
		byte(g.Data2 >> 8), byte(g.Data2), byte(g.Data3 >> 8), byte(g.Data3),
		g.Data4[0], g.Data4[1], g.Data4[2], g.Data4[3], g.Data4[4], g.Data4[5], g.Data4[6], g.Data4[7],
		opcode,
	}
}

```

`pkg/kevent/ktypes/ktypes_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ktypes

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"syscall"
	"testing"
)

func TestPack(t *testing.T) {
	assert.Equal(t, byte(0x3d), CreateProcess[0])
	assert.Equal(t, byte(0x6f), CreateProcess[1])
	assert.Equal(t, byte(0xa8), CreateProcess[2])
	assert.Equal(t, byte(0xd0), CreateProcess[3])

	assert.Equal(t, byte(0xfe), CreateProcess[4])
	assert.Equal(t, byte(0x05), CreateProcess[5])

	assert.Equal(t, byte(0x11), CreateProcess[6])
	assert.Equal(t, byte(0xd0), CreateProcess[7])

	assert.Equal(t, byte(0x9d), CreateProcess[8])
	assert.Equal(t, byte(0xda), CreateProcess[9])
	assert.Equal(t, byte(0x0), CreateProcess[10])
	assert.Equal(t, byte(0xc0), CreateProcess[11])
	assert.Equal(t, byte(0x4f), CreateProcess[12])
	assert.Equal(t, byte(0xd7), CreateProcess[13])
	assert.Equal(t, byte(0xba), CreateProcess[14])
	assert.Equal(t, byte(0x7c), CreateProcess[15])

	assert.Equal(t, byte(0x1), CreateProcess[16])

	kt := Pack(syscall.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 1)
	assert.Equal(t, CreateProcess, kt)

	kt = Pack(syscall.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 2)
	assert.NotEqual(t, CreateProcess, kt)
	assert.Equal(t, TerminateProcess, kt)

	switch kt {
	case TerminateProcess:
	default:
		t.Fatal("expected TerminateProcess kernel event")
	}
}

func TestKtypeExists(t *testing.T) {
	require.True(t, AcceptTCPv4.Exists())
	require.True(t, AcceptTCPv6.Exists())
}

```

`pkg/kevent/ktypes/metainfo_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ktypes

import "sort"

// KeventInfo describes the kernel event meta info such as human readable name, category
// and event's description.
type KeventInfo struct {
	// Name is the human-readable representation of the kernel event (e.g. CreateProcess, DeleteFile).
	Name string
	// Category designates the category to which kernel event pertains. (e.g. process, net)
	Category Category
	// Description is the short explanation that describes the purpose of the kernel event.
	Description string
}

var kevents = map[Ktype]KeventInfo{
	CreateProcess:      {"CreateProcess", Process, "Creates a new process and its primary thread"},
	TerminateProcess:   {"TerminateProcess", Process, "Terminates the process and all of its threads"},
	OpenProcess:        {"OpenProcess", Process, "Opens the process handle"},
	CreateThread:       {"CreateThread", Thread, "Creates a thread to execute within the virtual address space of the calling process"},
	TerminateThread:    {"TerminateThread", Thread, "Terminates a thread within the process"},
	OpenThread:         {"OpenThread", Thread, "Opens the thread handle"},
	ReadFile:           {"ReadFile", File, "Reads data from the file or I/O device"},
	WriteFile:          {"WriteFile", File, "Writes data to the file or I/O device"},
	CreateFile:         {"CreateFile", File, "Creates or opens a file or I/O device"},
	CloseFile:          {"CloseFile", File, "Closes the file handle"},
	DeleteFile:         {"DeleteFile", File, "Removes the file from the file system"},
	RenameFile:         {"RenameFile", File, "Changes the file name"},
	SetFileInformation: {"SetFileInformation", File, "Sets the file meta information"},
	EnumDirectory:      {"EnumDirectory", File, "Enumerates a directory or dispatches a directory change notification to registered listeners"},
	RegCreateKey:       {"RegCreateKey", Registry, "Creates a registry key or opens it if the key already exists"},
	RegOpenKey:         {"RegOpenKey", Registry, "Opens the registry key"},
	RegSetValue:        {"RegSetValue", Registry, "Sets the data for the value of a registry key"},
	RegQueryValue:      {"RegQueryValue", Registry, "Reads the data for the value of a registry key"},
	RegQueryKey:        {"RegQueryKey", Registry, "Enumerates subkeys of the parent key"},
	RegDeleteKey:       {"RegDeleteKey", Registry, "Removes the registry key"},
	RegDeleteValue:     {"RegDeleteValue", Registry, "Removes the registry value"},
	Accept:             {"Accept", Net, "Accepts the connection request from the socket queue"},
	Send:               {"Send", Net, "Sends data over the wire"},
	Recv:               {"Recv", Net, "Receives data from the socket"},
	Connect:            {"Connect", Net, "Connects establishes a connection to the socket"},
	Disconnect:         {"Disconnect", Net, "Terminates data reception on the socket"},
	Reconnect:          {"Reconnect", Net, "Reconnects to the socket"},
	Retransmit:         {"Retransmit", Net, "Retransmits unacknowledged TCP segments"},
	LoadImage:          {"LoadImage", Image, "Loads the module into the address space of the calling process"},
	UnloadImage:        {"UnloadImage", Image, "Unloads the module from the address space of the calling process"},
	CreateHandle:       {"CreateHandle", Handle, "Creates a new handle"},
	CloseHandle:        {"CloseHandle", Handle, "Closes the handle"},
}

var ktypes = map[string]Ktype{
	"CreateProcess":      CreateProcess,
	"TerminateProcess":   TerminateProcess,
	"OpenProcess":        OpenProcess,
	"CreateThread":       CreateThread,
	"TerminateThread":    TerminateThread,
	"OpenThread":         OpenThread,
	"LoadImage":          LoadImage,
	"UnloadImage":        UnloadImage,
	"CreateFile":         CreateFile,
	"CloseFile":          CloseFile,
	"ReadFile":           ReadFile,
	"WriteFile":          WriteFile,
	"SetFileInformation": SetFileInformation,
	"DeleteFile":         DeleteFile,
	"RenameFile":         RenameFile,
	"EnumDirectory":      EnumDirectory,
	"RegCreateKey":       RegCreateKey,
	"RegOpenKey":         RegOpenKey,
	"RegSetValue":        RegSetValue,
	"RegQueryValue":      RegQueryValue,
	"RegQueryKey":        RegQueryKey,
	"RegDeleteKey":       RegDeleteKey,
	"RegDeleteValue":     RegDeleteValue,
	"Accept":             Accept,
	"Send":               Send,
	"Recv":               Recv,
	"Connect":            Connect,
	"Reconnect":          Reconnect,
	"Disconnect":         Disconnect,
	"Retransmit":         Retransmit,
	"CreateHandle":       CreateHandle,
	"CloseHandle":        CloseHandle,
}

// KtypeToKeventInfo maps the kernel event type to a structure that stores detailed information about the event.
func KtypeToKeventInfo(ktype Ktype) KeventInfo {
	if ktype == RegOpenKeyV1 {
		return kevents[RegOpenKey]
	}
	if ktype == AcceptTCPv4 || ktype == AcceptTCPv6 {
		return kevents[Accept]
	}
	if ktype == ConnectTCPv4 || ktype == ConnectTCPv6 {
		return kevents[Connect]
	}
	if ktype == ReconnectTCPv4 || ktype == ReconnectTCPv6 {
		return kevents[Reconnect]
	}
	if ktype == RetransmitTCPv4 || ktype == RetransmitTCPv6 {
		return kevents[Retransmit]
	}
	if ktype == DisconnectTCPv4 || ktype == DisconnectTCPv6 {
		return kevents[Disconnect]
	}
	if ktype == SendTCPv4 || ktype == SendTCPv6 || ktype == SendUDPv4 || ktype == SendUDPv6 {
		return kevents[Send]
	}
	if ktype == RecvTCPv4 || ktype == RecvTCPv6 || ktype == RecvUDPv4 || ktype == RecvUDPv6 {
		return kevents[Recv]
	}

	if kinfo, ok := kevents[ktype]; ok {
		return kinfo
	}
	return KeventInfo{Name: "N/A", Category: Unknown}
}

// KeventNameToKtype converts a human-readable kernel event name to its internal kernel type representation.
func KeventNameToKtype(name string) Ktype {
	if ktype, ok := ktypes[name]; ok {
		return ktype
	}
	return UnknownKtype
}

// GetKtypesMeta returns kernel event types metadata.
func GetKtypesMeta() []KeventInfo {
	ktypes := make([]KeventInfo, 0, len(kevents))
	for _, ktyp := range kevents {
		ktypes = append(ktypes, ktyp)
	}
	sort.Slice(ktypes, func(i, j int) bool { return ktypes[i].Category < ktypes[j].Category })
	return ktypes
}

```

`pkg/kevent/ktypes/metainfo_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ktypes

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestKeventNameToKtype(t *testing.T) {
	ktype := KeventNameToKtype("CreateProcess")

	assert.Equal(t, CreateProcess, ktype)

	ktype = KeventNameToKtype("CreateRemoteThread")
	assert.Equal(t, UnknownKtype, ktype)
}

func TestKtypeToKeventInfo(t *testing.T) {
	kinfo := KtypeToKeventInfo(CreateProcess)

	assert.Equal(t, "CreateProcess", kinfo.Name)
	assert.Equal(t, Process, kinfo.Category)
	assert.Equal(t, "Creates a new process and its primary thread", kinfo.Description)

	kinfo = KtypeToKeventInfo(UnknownKtype)
	assert.Equal(t, "N/A", kinfo.Name)
	assert.Equal(t, Unknown, kinfo.Category)
	assert.Empty(t, kinfo.Description)
}

```

`pkg/kevent/marshaller.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"math"
	"strconv"
	"unicode/utf8"
)

type jsonStream struct {
	buf []byte
}

func newJSONStream() *jsonStream {
	return &jsonStream{buf: make([]byte, 0)}
}

func (js *jsonStream) flush() []byte {
	buf := js.buf
	js.buf = nil
	return buf
}

func (js *jsonStream) writeByte(c byte) {
	js.buf = append(js.buf, c)
}

func (js *jsonStream) writeTwoBytes(c1, c2 byte) {
	js.buf = append(js.buf, c1, c2)
}

func (js *jsonStream) writeString(s string) *jsonStream {
	js.writeByte('"')
	js.buf = append(js.buf, s...)
	js.writeByte('"')
	return js
}

func (js *jsonStream) writeRaw(s string) {
	js.buf = append(js.buf, s...)
}

func (js *jsonStream) writeEscapeString(s string) *jsonStream {
	valLen := len(s)
	js.buf = append(js.buf, '"')
	// write string, the fast path, without utf8 and escape support
	i := 0
	for ; i < valLen; i++ {
		c := s[i]
		if c > 31 && c != '"' && c != '\\' {
			js.buf = append(js.buf, c)
		} else {
			break
		}
	}
	if i == valLen {
		js.buf = append(js.buf, '"')
		return js
	}

	// write remaining part of the string with escape support
	writeStringSlowPath(js, i, s, valLen)
	return js
}

//nolint:unparam
func (js *jsonStream) writeObjectStart() *jsonStream {
	js.writeByte('{')
	return js
}

//nolint:unparam
func (js *jsonStream) writeArrayStart() *jsonStream {
	js.writeByte('[')
	return js
}

func (js *jsonStream) writeArrayEnd() *jsonStream {
	js.writeByte(']')
	return js
}

func (js *jsonStream) writeObjectField(f string) *jsonStream {
	js.writeString(f)
	js.writeTwoBytes(':', ' ')
	return js
}

func (js *jsonStream) writeBool(b bool) *jsonStream {
	if b {
		js.writeString("true")
		return js
	}
	js.writeString("false")
	return js
}

func (js *jsonStream) writeObjectEnd() *jsonStream {
	js.writeByte('}')
	return js
}

//nolint:unparam
func (js *jsonStream) writeMore() *jsonStream {
	js.writeByte(',')
	return js
}

func (js *jsonStream) shouldWriteMore(i, l int) bool {
	return !(i == l-1)
}

// borrowed from jsointer: https://github.com/json-iterator/go/blob/2fbdfbb5951116fb8bede4fd8b919a19e4a6b647/stream_int.go and https://github.com/json-iterator/go/blob/2fbdfbb5951116fb8bede4fd8b919a19e4a6b647/stream_float.go

var digits []uint32

// safeSet holds the value true if the ASCII character with the given array
// position can be represented inside a JSON string without any further
// escaping.
//
// All values are true except for the ASCII control characters (0-31), the
// double quote ("), and the backslash character ("\").
var safeSet = [utf8.RuneSelf]bool{
	' ':      true,
	'!':      true,
	'"':      false,
	'#':      true,
	'$':      true,
	'%':      true,
	'&':      true,
	'\'':     true,
	'(':      true,
	')':      true,
	'*':      true,
	'+':      true,
	',':      true,
	'-':      true,
	'.':      true,
	'/':      true,
	'0':      true,
	'1':      true,
	'2':      true,
	'3':      true,
	'4':      true,
	'5':      true,
	'6':      true,
	'7':      true,
	'8':      true,
	'9':      true,
	':':      true,
	';':      true,
	'<':      true,
	'=':      true,
	'>':      true,
	'?':      true,
	'@':      true,
	'A':      true,
	'B':      true,
	'C':      true,
	'D':      true,
	'E':      true,
	'F':      true,
	'G':      true,
	'H':      true,
	'I':      true,
	'J':      true,
	'K':      true,
	'L':      true,
	'M':      true,
	'N':      true,
	'O':      true,
	'P':      true,
	'Q':      true,
	'R':      true,
	'S':      true,
	'T':      true,
	'U':      true,
	'V':      true,
	'W':      true,
	'X':      true,
	'Y':      true,
	'Z':      true,
	'[':      true,
	'\\':     false,
	']':      true,
	'^':      true,
	'_':      true,
	'`':      true,
	'a':      true,
	'b':      true,
	'c':      true,
	'd':      true,
	'e':      true,
	'f':      true,
	'g':      true,
	'h':      true,
	'i':      true,
	'j':      true,
	'k':      true,
	'l':      true,
	'm':      true,
	'n':      true,
	'o':      true,
	'p':      true,
	'q':      true,
	'r':      true,
	's':      true,
	't':      true,
	'u':      true,
	'v':      true,
	'w':      true,
	'x':      true,
	'y':      true,
	'z':      true,
	'{':      true,
	'|':      true,
	'}':      true,
	'~':      true,
	'\u007f': true,
}

var hex = "0123456789abcdef"

func init() {
	digits = make([]uint32, 1000)
	for i := uint32(0); i < 1000; i++ {
		digits[i] = (((i / 100) + '0') << 16) + ((((i / 10) % 10) + '0') << 8) + i%10 + '0'
		if i < 10 {
			digits[i] += 2 << 24
		} else if i < 100 {
			digits[i] += 1 << 24
		}
	}
}

func writeStringSlowPath(stream *jsonStream, i int, s string, valLen int) {
	start := i
	// for the remaining parts, we process them char by char
	for i < valLen {
		if b := s[i]; b < utf8.RuneSelf {
			if safeSet[b] {
				i++
				continue
			}
			if start < i {
				stream.writeRaw(s[start:i])
			}
			switch b {
			case '\\', '"':
				stream.writeTwoBytes('\\', b)
			case '\n':
				stream.writeTwoBytes('\\', 'n')
			case '\r':
				stream.writeTwoBytes('\\', 'r')
			case '\t':
				stream.writeTwoBytes('\\', 't')
			default:
				// This encodes bytes < 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes <, >, and &
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				stream.writeRaw(`\u00`)
				stream.writeTwoBytes(hex[b>>4], hex[b&0xF])
			}
			i++
			start = i
			continue
		}
		i++
		continue
	}
	if start < len(s) {
		stream.writeRaw(s[start:])
	}
	stream.writeByte('"')
}

func writeFirstBuf(space []byte, v uint32) []byte {
	start := v >> 24
	if start == 0 {
		space = append(space, byte(v>>16), byte(v>>8))
	} else if start == 1 {
		space = append(space, byte(v>>8))
	}
	space = append(space, byte(v))
	return space
}

func writeBuf(buf []byte, v uint32) []byte {
	return append(buf, byte(v>>16), byte(v>>8), byte(v))
}

func (js *jsonStream) writeUint8(val uint8) *jsonStream {
	js.buf = writeFirstBuf(js.buf, digits[val])
	return js
}

func (js *jsonStream) writeInt8(nval int8) *jsonStream {
	var val uint8
	if nval < 0 {
		val = uint8(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint8(nval)
	}
	js.buf = writeFirstBuf(js.buf, digits[val])
	return js
}

func (js *jsonStream) writeUint16(val uint16) *jsonStream {
	q1 := val / 1000
	if q1 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[val])
		return js
	}
	r1 := val - q1*1000
	js.buf = writeFirstBuf(js.buf, digits[q1])
	js.buf = writeBuf(js.buf, digits[r1])
	return js
}

func (js *jsonStream) writeInt16(nval int16) *jsonStream {
	var val uint16
	if nval < 0 {
		val = uint16(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint16(nval)
	}
	js.writeUint16(val)
	return js
}

func (js *jsonStream) writeUint32(val uint32) *jsonStream {
	q1 := val / 1000
	if q1 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[val])
		return js
	}
	r1 := val - q1*1000
	q2 := q1 / 1000
	if q2 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q1])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r2 := q1 - q2*1000
	q3 := q2 / 1000
	if q3 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q2])
	} else {
		r3 := q2 - q3*1000
		js.buf = append(js.buf, byte(q3+'0'))
		js.buf = writeBuf(js.buf, digits[r3])
	}
	js.buf = writeBuf(js.buf, digits[r2])
	js.buf = writeBuf(js.buf, digits[r1])
	return js
}

func (js *jsonStream) writeInt32(nval int32) *jsonStream {
	var val uint32
	if nval < 0 {
		val = uint32(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint32(nval)
	}
	js.writeUint32(val)
	return js
}

func (js *jsonStream) writeUint64(val uint64) *jsonStream {
	q1 := val / 1000
	if q1 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[val])
		return js
	}
	r1 := val - q1*1000
	q2 := q1 / 1000
	if q2 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q1])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r2 := q1 - q2*1000
	q3 := q2 / 1000
	if q3 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q2])
		js.buf = writeBuf(js.buf, digits[r2])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r3 := q2 - q3*1000
	q4 := q3 / 1000
	if q4 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q3])
		js.buf = writeBuf(js.buf, digits[r3])
		js.buf = writeBuf(js.buf, digits[r2])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r4 := q3 - q4*1000
	q5 := q4 / 1000
	if q5 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q4])
		js.buf = writeBuf(js.buf, digits[r4])
		js.buf = writeBuf(js.buf, digits[r3])
		js.buf = writeBuf(js.buf, digits[r2])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r5 := q4 - q5*1000
	q6 := q5 / 1000
	if q6 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q5])
	} else {
		js.buf = writeFirstBuf(js.buf, digits[q6])
		r6 := q5 - q6*1000
		js.buf = writeBuf(js.buf, digits[r6])
	}
	js.buf = writeBuf(js.buf, digits[r5])
	js.buf = writeBuf(js.buf, digits[r4])
	js.buf = writeBuf(js.buf, digits[r3])
	js.buf = writeBuf(js.buf, digits[r2])
	js.buf = writeBuf(js.buf, digits[r1])
	return js
}

func (js *jsonStream) writeInt64(nval int64) *jsonStream {
	var val uint64
	if nval < 0 {
		val = uint64(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint64(nval)
	}
	js.writeUint64(val)
	return js
}

// writeFloat32 write float32 to stream
func (js *jsonStream) writeFloat32(val float32) *jsonStream {
	abs := math.Abs(float64(val))
	format := byte('f')
	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
	if abs != 0 {
		if float32(abs) < 1e-6 || float32(abs) >= 1e21 {
			format = 'e'
		}
	}
	js.buf = strconv.AppendFloat(js.buf, float64(val), format, -1, 32)
	return js
}

// writeFloat64 write float64 to stream
func (js *jsonStream) writeFloat64(val float64) *jsonStream {
	abs := math.Abs(val)
	format := byte('f')
	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
	if abs != 0 {
		if abs < 1e-6 || abs >= 1e21 {
			format = 'e'
		}
	}
	js.buf = strconv.AppendFloat(js.buf, val, format, -1, 64)
	return js
}

```

`pkg/kevent/marshaller_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"encoding/json"
	"io/ioutil"
	"testing"
	"time"

	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	pex "github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func init() {
	SerializeThreads = true
	SerializeImages = true
	SerializeHandles = true
	SerializePE = true
	SerializeEnvs = true
}

func TestMarshaller(t *testing.T) {
	now, err := time.Parse(time.RFC3339Nano, time.Now().Format(time.RFC3339Nano))
	require.NoError(t, err)

	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   now,
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
			kparams.KstackLimit:   {Name: kparams.KstackLimit, Type: kparams.HexInt8, Value: kparams.Hex("ff")},
			kparams.StartTime:     {Name: kparams.StartTime, Type: kparams.Time, Value: time.Now()},
			kparams.ProcessID:     {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(1204)},
			kparams.NetDIPNames:   {Name: kparams.NetDIPNames, Type: kparams.Slice, Value: []string{"dns.google.", "github.com."}},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "barzz"},
	}

	b := kevt.MarshalRaw()
	require.NotEmpty(t, b)

	clone, err := NewFromKcap(b)
	require.NoError(t, err)

	assert.Equal(t, uint64(2), clone.Seq)
	assert.Equal(t, uint32(859), clone.PID)
	assert.Equal(t, uint32(2484), clone.Tid)
	assert.Equal(t, ktypes.CreateFile, clone.Type)
	assert.Equal(t, uint8(1), clone.CPU)
	assert.Equal(t, "CreateFile", clone.Name)
	assert.Equal(t, ktypes.File, clone.Category)
	assert.Equal(t, "Creates or opens a new file, directory, I/O device, pipe, console", clone.Description)
	assert.Equal(t, "archrabbit", clone.Host)
	assert.Equal(t, now, clone.Timestamp)

	assert.Len(t, clone.Kparams, 10)

	filename, err := clone.Kparams.GetString(kparams.FileName)
	require.NoError(t, err)
	assert.Equal(t, "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll", filename)
	fileobject, err := clone.Kparams.GetUint64(kparams.FileObject)
	require.NoError(t, err)
	assert.Equal(t, uint64(12456738026482168384), fileobject)

	assert.Len(t, clone.Metadata, 2)

	assert.Equal(t, "bar", clone.Metadata["foo"])
	assert.Equal(t, "barzz", clone.Metadata["fooz"])
}

func TestKeventMarshalJSON(t *testing.T) {
	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
			kparams.NetDIPNames:   {Name: kparams.NetDIPNames, Type: kparams.Slice, Value: []string{"dns.google.", "github.com."}},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:  2436,
			Ppid: 6304,
			Parent: &pstypes.PS{
				Name: "explorer.exe",
				Exe:  `C:\Windows\System32\explorer.exe`,
				Cwd:  `C:\Windows\System32`,
				SID:  "admin\\SYSTEM",
			},
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pex.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}
	s := kevt.MarshalJSON()
	var newKevt Kevent
	err := json.Unmarshal(s, &newKevt)
	require.NoError(t, err)

	assert.Equal(t, uint32(2484), newKevt.Tid)
	assert.Equal(t, uint32(859), newKevt.PID)
	assert.Equal(t, "archrabbit\\SYSTEM", newKevt.PS.SID)
	assert.Len(t, newKevt.PS.Envs, 2)
	assert.Len(t, newKevt.PS.Handles, 3)

	assert.NotNil(t, newKevt.PS.PE)
	assert.Equal(t, "explorer.exe", newKevt.PS.Parent.Name)
	assert.Equal(t, uint32(10), newKevt.PS.PE.NumberOfSymbols)
	assert.Equal(t, uint16(2), newKevt.PS.PE.NumberOfSections)
	assert.Len(t, newKevt.PS.PE.Sections, 2)
	assert.Len(t, newKevt.PS.PE.Symbols, 5)
	assert.Len(t, newKevt.PS.PE.Imports, 4)
	assert.Len(t, newKevt.PS.PE.VersionResources, 3)
}

func TestUnmarshalHugeHandles(t *testing.T) {
	b, err := ioutil.ReadFile("_fixtures\\handles.json")
	require.NoError(t, err)
	handles := make([]htypes.Handle, 0)
	err = json.Unmarshal(b, &handles)
	require.NoError(t, err)

	kevt := &Kevent{
		Type:        ktypes.CreateProcess,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateProcess",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates a new process",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: handles,
			PE: &pex.PE{
				NumberOfSections: 7,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	s := kevt.MarshalRaw()
	clone, err := NewFromKcap(s)
	require.NoError(t, err)
	require.NotNil(t, clone)
}

func TestKeventMarshalJSONMultiple(t *testing.T) {
	for i := 0; i < 10; i++ {
		seq := uint64(i + 1)
		kevt := &Kevent{
			Type:        ktypes.CreateFile,
			Tid:         2484,
			PID:         859,
			CPU:         1,
			Seq:         seq,
			Name:        "CreateFile",
			Timestamp:   time.Now(),
			Category:    ktypes.File,
			Host:        "archrabbit",
			Description: "Creates or opens a new file, directory, I/O device, pipe, console",
			Kparams: Kparams{
				kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
				kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
				kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
				kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
				kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
				kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
			},
			Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
			PS: &pstypes.PS{
				PID:       2436,
				Ppid:      6304,
				Name:      "firefox.exe",
				Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
				Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
				Cwd:       `C:\Program Files\Mozilla Firefox\`,
				SID:       "archrabbit\\SYSTEM",
				Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
				SessionID: 4,
				Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
				Threads: map[uint32]pstypes.Thread{
					3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
					3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				},
				Handles: []htypes.Handle{
					{Num: shandle.Handle(0xffffd105e9baaf70),
						Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
						Type:   "Key",
						Object: 777488883434455544,
						Pid:    uint32(1023),
					},
					{
						Num:  shandle.Handle(0xffffd105e9adaf70),
						Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
						Type: "ALPC Port",
						Pid:  uint32(1023),
						MD: &htypes.AlpcPortInfo{
							Seqno:   1,
							Context: 0x0,
							Flags:   0x0,
						},
						Object: 457488883434455544,
					},
					{
						Num:  shandle.Handle(0xeaffd105e9adaf30),
						Name: `C:\Users\bunny`,
						Type: "File",
						Pid:  uint32(1023),
						MD: &htypes.FileInfo{
							IsDirectory: true,
						},
						Object: 357488883434455544,
					},
				},
			},
		}
		s := kevt.MarshalJSON()
		var newKevt Kevent
		err := json.Unmarshal(s, &newKevt)
		require.NoError(t, err)

		assert.Equal(t, uint32(2484), newKevt.Tid)
		assert.Equal(t, uint32(859), newKevt.PID)
		assert.Equal(t, seq, newKevt.Seq)
		assert.Len(t, newKevt.PS.Handles, 3)
	}
}

func BenchmarkKeventMarshalJSON(b *testing.B) {
	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pex.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		kevt.MarshalJSON()
	}
}

func BenchmarkKeventMarshalJSONStdlib(b *testing.B) {
	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pex.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		if _, err := json.Marshal(kevt); err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkMarshal(b *testing.B) {
	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "barz"},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		if buf := kevt.MarshalRaw(); len(buf) == 0 {
			b.Fatal("empty buffer")
		}
	}
}

func BenchmarkUnmarshal(b *testing.B) {
	kevt := &Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
		},
		Metadata: map[MetadataKey]string{"foo": "bar", "fooz": "barz"},
	}
	buf := kevt.MarshalRaw()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		ke, err := NewFromKcap(buf)
		if err != nil {
			b.Fatal(err)
		}
		if ke.Name == "" {
			b.Fatal("invalid unmarshal byte slice")
		}
	}
}

```

`pkg/kevent/marshaller_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"expvar"
	"fmt"
	"math"
	"net"
	"sort"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/network"
	ptypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"github.com/rabbitstack/fibratus/pkg/util/ip"
)

var (
	// SerializeHandles indicates if handles are serialized as part of the process' state
	SerializeHandles bool
	// SerializeThreads indicates if threads are serialized as part of the process' state
	SerializeThreads bool
	// SerializeImages indicates if images are serialized as part of the process' state
	SerializeImages bool
	// SerializePE indicates if PE metadata are serialized as part of the process' state
	SerializePE bool
	// SerializeEnvs indicates if the environment variables are serialized as part of the process's state
	SerializeEnvs bool
)

// unmarshalTimestampErrors counts timestamp unmarshal errors
var unmarshalTimestampErrors = expvar.NewInt("kevent.timestamp.unmarshal.errors")

// MarshalRaw produces a byte stream of the kernel event suitable for writing to disk.
func (kevt *Kevent) MarshalRaw() []byte {
	b := make([]byte, 0)

	// write seq, pid, tid fields
	b = append(b, bytes.WriteUint64(kevt.Seq)...)
	b = append(b, bytes.WriteUint32(kevt.PID)...)
	b = append(b, bytes.WriteUint32(kevt.Tid)...)

	// write ktype and CPU
	b = append(b, kevt.Type[:]...)
	b = append(b, kevt.CPU)

	// for the string fields we have to write the length prior to
	// the string buffer itself so we can decode the string correctly
	//
	// write event name
	b = append(b, bytes.WriteUint16(uint16(len(kevt.Name)))...)
	b = append(b, kevt.Name...)
	// write category
	b = append(b, bytes.WriteUint16(uint16(len(kevt.Category)))...)
	b = append(b, kevt.Category...)
	// write description
	b = append(b, bytes.WriteUint16(uint16(len(kevt.Description)))...)
	b = append(b, kevt.Description...)
	// write host name
	b = append(b, bytes.WriteUint16(uint16(len(kevt.Host)))...)
	b = append(b, kevt.Host...)

	// write event's timestamp
	timestamp := make([]byte, 0)
	timestamp = kevt.Timestamp.AppendFormat(timestamp, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(timestamp)))...)
	b = append(b, timestamp...)

	// write the number of kernel parameters followed by each parameter
	b = append(b, bytes.WriteUint16(uint16(len(kevt.Kparams)))...)
	for _, kpar := range kevt.Kparams {
		// append the type, parameter size and name
		b = append(b, bytes.WriteUint16(uint16(kpar.Type))...)
		b = append(b, bytes.WriteUint16(uint16(len(kpar.Name)))...)
		b = append(b, kpar.Name...)
		switch kpar.Type {
		case kparams.AnsiString, kparams.UnicodeString, kparams.SID, kparams.WbemSID:
			b = append(b, bytes.WriteUint16(uint16(len(kpar.Value.(string))))...)
			b = append(b, kpar.Value.(string)...)
		case kparams.Uint8:
			b = append(b, kpar.Value.(uint8))
		case kparams.Int8:
			b = append(b, byte(kpar.Value.(int8)))
		case kparams.HexInt8:
			b = append(b, kpar.Value.(kparams.Hex).Uint8())
		case kparams.HexInt16:
			b = append(b, bytes.WriteUint16(kpar.Value.(kparams.Hex).Uint16())...)
		case kparams.HexInt32:
			b = append(b, bytes.WriteUint32(kpar.Value.(kparams.Hex).Uint32())...)
		case kparams.HexInt64:
			b = append(b, bytes.WriteUint64(kpar.Value.(kparams.Hex).Uint64())...)
		case kparams.Uint16, kparams.Port:
			b = append(b, bytes.WriteUint16(kpar.Value.(uint16))...)
		case kparams.Int16:
			b = append(b, bytes.WriteUint16(uint16(kpar.Value.(int16)))...)
		case kparams.Uint32:
			b = append(b, bytes.WriteUint32(kpar.Value.(uint32))...)
		case kparams.Int32:
			b = append(b, bytes.WriteUint32(uint32(kpar.Value.(int32)))...)
		case kparams.Uint64:
			b = append(b, bytes.WriteUint64(kpar.Value.(uint64))...)
		case kparams.Int64:
			b = append(b, bytes.WriteUint64(uint64(kpar.Value.(int64)))...)
		case kparams.Double:
			b = append(b, bytes.WriteUint32(math.Float32bits(kpar.Value.(float32)))...)
		case kparams.Float:
			b = append(b, bytes.WriteUint64(math.Float64bits(kpar.Value.(float64)))...)
		case kparams.IPv4:
			b = append(b, kpar.Value.(net.IP).To4()...)
		case kparams.IPv6:
			b = append(b, kpar.Value.(net.IP).To16()...)
		case kparams.PID, kparams.TID:
			b = append(b, bytes.WriteUint32(kpar.Value.(uint32))...)
		case kparams.Bool:
			v := kpar.Value.(bool)
			if v {
				b = append(b, 1)
			} else {
				b = append(b, 0)
			}
		case kparams.Time:
			v := kpar.Value.(time.Time)
			ts := make([]byte, 0)
			ts = v.AppendFormat(ts, time.RFC3339Nano)
			b = append(b, bytes.WriteUint16(uint16(len(ts)))...)
			b = append(b, ts...)
		case kparams.Enum:
			switch e := kpar.Value.(type) {
			case fs.FileDisposition:
				b = append(b, uint8(e))
			case fs.FileShareMode:
				b = append(b, uint8(e))
			case network.L4Proto:
				b = append(b, uint8(e))
			}
		case kparams.Slice:
			switch slice := kpar.Value.(type) {
			case []string:
				// append the type for slice elements
				b = append(b, uint8('s'))
				b = append(b, bytes.WriteUint16(uint16(len(slice)))...)
				for _, s := range slice {
					b = append(b, bytes.WriteUint16(uint16(len(s)))...)
					b = append(b, s...)
				}
			case []fs.FileAttr:
				b = append(b, uint8('s'))
				b = append(b, bytes.WriteUint16(uint16(len(slice)))...)
				for _, s := range slice {
					b = append(b, bytes.WriteUint16(uint16(len(s.String())))...)
					b = append(b, s.String()...)
				}
			}
		}
	}
	// write metadata key/value pairs
	b = append(b, bytes.WriteUint16(uint16(len(kevt.Metadata)))...)
	for key, value := range kevt.Metadata {
		b = append(b, bytes.WriteUint16(uint16(len(key)))...)
		b = append(b, key...)
		b = append(b, bytes.WriteUint16(uint16(len(value)))...)
		b = append(b, value...)
	}

	// write process state
	if kevt.PS != nil && (kevt.Type == ktypes.CreateProcess || kevt.Type == ktypes.EnumProcess) {
		buf := kevt.PS.Marshal()
		sec := section.New(section.Process, kcapver.ProcessSecV1, 0, uint32(len(buf)))
		b = append(b, sec[:]...)
		b = append(b, buf...)
	} else {
		sec := section.New(section.Process, kcapver.ProcessSecV1, 0, 0)
		b = append(b, sec[:]...)
	}

	return b
}

// UnmarshalRaw recovers the state of the kernel event from the byte stream.
func (kevt *Kevent) UnmarshalRaw(b []byte, ver kcapver.Version) error {
	if len(b) < 34 {
		return fmt.Errorf("expected at least 34 bytes but got %d bytes", len(b))
	}

	// read seq, pid, tid
	kevt.Seq = bytes.ReadUint64(b[0:])
	kevt.PID = bytes.ReadUint32(b[8:])
	kevt.Tid = bytes.ReadUint32(b[12:])

	// read ktype and CPU
	var ktype ktypes.Ktype
	copy(ktype[:], b[16:33])
	kevt.Type = ktype
	kevt.CPU = b[33:34][0]

	// read event name
	l := bytes.ReadUint16(b[34:])
	buf := b[36:]
	offset := l
	kevt.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read category
	l = bytes.ReadUint16(b[36+offset:])
	buf = b[38+offset:]
	offset += l
	kevt.Category = ktypes.Category(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	// read description
	l = bytes.ReadUint16(b[38+offset:])
	buf = b[40+offset:]
	offset += l
	kevt.Description = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read host name
	l = bytes.ReadUint16(b[40+offset:])
	buf = b[42+offset:]
	offset += l
	kevt.Host = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read timestamp
	l = bytes.ReadUint16(b[42+offset:])
	buf = b[44+offset:]
	offset += l
	if len(buf) > 0 {
		var err error
		kevt.Timestamp, err = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		if err != nil {
			unmarshalTimestampErrors.Add(1)
		}
	}

	// read parameters
	nbKparams := bytes.ReadUint16(b[44+offset:])
	// accumulates the offset of all parameter name and value lengths
	var poffset uint16

	for i := 0; i < int(nbKparams); i++ {
		// read kparam type
		typ := bytes.ReadUint16(b[46+offset+poffset:])
		// read kparam name
		kparamNameLength := bytes.ReadUint16(b[48+offset+poffset:])
		buf = b[50+offset+poffset:]
		kparamName := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:kparamNameLength:kparamNameLength])

		var kval kparams.Value
		switch kparams.Type(typ) {
		case kparams.AnsiString, kparams.UnicodeString, kparams.SID, kparams.WbemSID:
			// read string parameter
			l := bytes.ReadUint16(b[50+offset+kparamNameLength+poffset:])
			buf = b[52+offset+kparamNameLength+poffset:]
			if len(buf) > 0 {
				kval = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
			}
			// increment parameter offset by string by type length + name length bytes + length of
			// the string parameter + string parameter size
			poffset += kparamNameLength + 6 + l
		case kparams.Uint64:
			kval = bytes.ReadUint64(b[50+offset+kparamNameLength+poffset:])
			// increment parameter offset by type length + name length sizes + size of uint64
			poffset += kparamNameLength + 4 + 8
		case kparams.Int64:
			kval = int64(bytes.ReadUint64(b[50+offset+kparamNameLength+poffset:]))
			// increment parameter offset by type length + name length sizes + size of int64
			poffset += kparamNameLength + 4 + 8
		case kparams.Double:
			kval = float64(bytes.ReadUint64(b[50+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 8
		case kparams.Float:
			kval = float32(bytes.ReadUint32(b[50+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 4
		case kparams.IPv4:
			kval = ip.ToIPv4(bytes.ReadUint32(b[50+offset+kparamNameLength+poffset:]))
			// // increment by IPv4 length
			poffset += kparamNameLength + 4 + 4
		case kparams.IPv6:
			kval = ip.ToIPv6(b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+16])
			// increment by IPv6 length
			poffset += kparamNameLength + 4 + 16
		case kparams.PID, kparams.TID:
			kval = bytes.ReadUint32(b[50+offset+kparamNameLength+poffset:])
			poffset += kparamNameLength + 4 + 4
		case kparams.Int32:
			kval = int32(bytes.ReadUint32(b[50+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 4
		case kparams.Uint32:
			kval = bytes.ReadUint32(b[50+offset+kparamNameLength+poffset:])
			poffset += kparamNameLength + 4 + 4
		case kparams.Uint16, kparams.Port:
			kval = bytes.ReadUint16(b[50+offset+kparamNameLength+poffset:])
			poffset += kparamNameLength + 4 + 2
		case kparams.Int16:
			kval = int16(bytes.ReadUint16(b[50+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 2
		case kparams.Uint8, kparams.Enum:
			switch kparamName {
			case kparams.FileOperation:
				kval = fs.FileDisposition(b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0])
			case kparams.FileShareMask:
				kval = fs.FileShareMode(b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0])
			case kparams.NetL4Proto:
				kval = network.L4Proto(b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0])
			default:
				kval = b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0]
			}
			poffset += kparamNameLength + 4 + 1
		case kparams.Int8:
			kval = int8(b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0])
			poffset += kparamNameLength + 4 + 1
		case kparams.HexInt8:
			v := b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0]
			kval = kparams.NewHex(v)
			poffset += kparamNameLength + 4 + 1
		case kparams.HexInt16:
			v := bytes.ReadUint16(b[50+offset+kparamNameLength+poffset:])
			kval = kparams.NewHex(v)
			poffset += kparamNameLength + 4 + 2
		case kparams.HexInt32:
			v := bytes.ReadUint32(b[50+offset+kparamNameLength+poffset:])
			kval = kparams.NewHex(v)
			poffset += kparamNameLength + 4 + 4
		case kparams.HexInt64:
			v := bytes.ReadUint64(b[50+offset+kparamNameLength+poffset:])
			kval = kparams.NewHex(v)
			poffset += kparamNameLength + 4 + 8
		case kparams.Bool:
			v := b[50+offset+kparamNameLength+poffset : 50+offset+kparamNameLength+poffset+1][0]
			if v == 1 {
				kval = true
			} else {
				kval = false
			}
			poffset += kparamNameLength + 4 + 1
		case kparams.Time:
			// read ts length
			l := bytes.ReadUint16(b[50+offset+kparamNameLength+poffset:])
			buf = b[52+offset+kparamNameLength+poffset:]
			if len(buf) > 0 {
				var err error
				kval, err = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
				if err != nil {
					unmarshalTimestampErrors.Add(1)
				}
			}
			poffset += kparamNameLength + 6 + l
		case kparams.Slice:
			// read slice element type
			typ := b[50+offset+kparamNameLength+poffset]
			// read slice size
			l := bytes.ReadUint16(b[51+offset+kparamNameLength+poffset:])
			var off uint16
			switch typ {
			case 's':
				s := make([]string, l)
				for i := 0; i < int(l); i++ {
					size := bytes.ReadUint16(b[53+offset+kparamNameLength+poffset+off:])
					buf := b[55+offset+kparamNameLength+poffset+off:]
					s[i] = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:size:size])
					off += 2 + size
				}
				kval = s
			}
			poffset += kparamNameLength + 4 + 1 + 2 + off
		}
		if kval != nil {
			kevt.Kparams.AppendFromKcap(kparamName, kparams.Type(typ), kval)
		}
	}

	offset += poffset

	// read metadata tags
	nbTags := bytes.ReadUint16(b[46+offset:])
	var moffset uint16
	for i := 0; i < int(nbTags); i++ {
		// read key
		klen := bytes.ReadUint16(b[48+offset+moffset:])
		buf = b[50+offset+moffset:]
		key := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:klen:klen])
		// read value
		vlen := bytes.ReadUint16(b[50+offset+klen+moffset:])
		buf = b[52+offset+klen+moffset:]
		value := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:vlen:vlen])
		// increment the offset by the length of the key + length value + size of uint16 * 2
		// that corresponds to bytes storing the lengths of keys/values
		moffset += klen + vlen + 4
		if key != "" {
			kevt.AddMeta(MetadataKey(key), value)
		}
	}

	offset += moffset

	// read process state
	sec := section.Read(b[48+offset:])
	if sec.Size() != 0 {
		ps, err := ptypes.NewFromKcap(b[58+offset:])
		if err != nil {
			return err
		}
		kevt.PS = ps
	}

	return nil
}

var js = newJSONStream()

func writePsResources() bool {
	return SerializeHandles || SerializeThreads || SerializeImages || SerializePE
}

// MarshalJSON produces a JSON payload for this kevent.
func (kevt *Kevent) MarshalJSON() []byte {
	if kevt == nil {
		return []byte{}
	}

	// start of JSON
	js.writeObjectStart()

	js.writeObjectField("seq").writeUint64(kevt.Seq).writeMore()
	js.writeObjectField("pid").writeUint32(kevt.PID).writeMore()
	js.writeObjectField("tid").writeUint32(kevt.Tid).writeMore()
	js.writeObjectField("cpu").writeUint8(kevt.CPU).writeMore()

	js.writeObjectField("name").writeString(kevt.Name).writeMore()
	js.writeObjectField("category").writeString(string(kevt.Category)).writeMore()
	js.writeObjectField("description").writeString(kevt.Description).writeMore()
	js.writeObjectField("host").writeString(kevt.Host).writeMore()

	timestamp := make([]byte, 0)
	timestamp = kevt.Timestamp.AppendFormat(timestamp, time.RFC3339Nano)
	js.writeObjectField("timestamp").writeString(string(timestamp)).writeMore()

	// start kparams
	js.writeObjectField("kparams")
	js.writeObjectStart()

	pars := make([]*Kparam, 0, len(kevt.Kparams))
	for _, kpar := range kevt.Kparams {
		pars = append(pars, kpar)
	}
	sort.Slice(pars, func(i, j int) bool { return pars[i].Name < pars[j].Name })

	for i, kpar := range pars {
		writeMore := js.shouldWriteMore(i, len(pars))
		js.writeObjectField(kpar.Name)
		switch kpar.Type {
		case kparams.AnsiString, kparams.UnicodeString, kparams.SID, kparams.WbemSID:
			js.writeEscapeString(kpar.Value.(string))
		case kparams.Int64:
			js.writeInt64(kpar.Value.(int64))
		case kparams.Uint64:
			js.writeUint64(kpar.Value.(uint64))
		case kparams.Int32:
			js.writeInt32(kpar.Value.(int32))
		case kparams.Uint32:
			js.writeUint32(kpar.Value.(uint32))
		case kparams.Int16:
			js.writeInt16(kpar.Value.(int16))
		case kparams.Uint16, kparams.Port:
			js.writeUint16(kpar.Value.(uint16))
		case kparams.Int8:
			js.writeInt8(kpar.Value.(int8))
		case kparams.Uint8:
			js.writeUint8(kpar.Value.(uint8))
		case kparams.Float:
			js.writeFloat32(kpar.Value.(float32))
		case kparams.Double:
			js.writeFloat64(kpar.Value.(float64))
		case kparams.PID, kparams.TID:
			js.writeUint32(kpar.Value.(uint32))
		case kparams.IPv4, kparams.IPv6:
			js.writeString(kpar.Value.(net.IP).String())
		case kparams.HexInt8, kparams.HexInt16, kparams.HexInt32, kparams.HexInt64:
			js.writeString(kpar.Value.(kparams.Hex).String())
		case kparams.Enum:
			switch kpar.Name {
			case kparams.FileOperation:
				js.writeString(kpar.Value.(fs.FileDisposition).String())
			case kparams.FileShareMask:
				js.writeString(kpar.Value.(fs.FileShareMode).String())
			case kparams.NetL4Proto:
				js.writeString(kpar.Value.(network.L4Proto).String())
			default:
				val, ok := kpar.Value.(uint8)
				if !ok {
					continue
				}
				js.writeUint8(val)
			}
		case kparams.Bool:
			js.writeBool(kpar.Value.(bool))
		case kparams.Time:
			js.writeString(kpar.Value.(time.Time).String())
		case kparams.Slice:
			switch slice := kpar.Value.(type) {
			case []string:
				js.writeArrayStart()
				for i, s := range slice {
					writeMore := js.shouldWriteMore(i, len(slice))
					js.writeEscapeString(s)
					if writeMore {
						js.writeMore()
					}
				}
				js.writeArrayEnd()
			}
		}
		if writeMore {
			js.writeMore()
		}
	}
	// end kparams
	js.writeObjectEnd().writeMore()

	// start metadata
	js.writeObjectField("meta")
	js.writeObjectStart()
	var i int
	for k, v := range kevt.Metadata {
		writeMore := js.shouldWriteMore(i, len(kevt.Metadata))
		js.writeObjectField(k.String()).writeEscapeString(v)
		if writeMore {
			js.writeMore()
		}
		i++
	}

	// end metadata
	js.writeObjectEnd()
	ps := kevt.PS
	if ps != nil {
		js.writeMore()
	}

	// start process state
	if ps != nil {
		js.writeObjectField("ps")
		js.writeObjectStart()

		js.writeObjectField("pid").writeUint32(ps.PID).writeMore()
		js.writeObjectField("ppid").writeUint32(ps.Ppid).writeMore()
		js.writeObjectField("name").writeString(ps.Name).writeMore()
		js.writeObjectField("comm").writeEscapeString(ps.Comm).writeMore()
		js.writeObjectField("exe").writeEscapeString(ps.Exe).writeMore()
		js.writeObjectField("cwd").writeEscapeString(ps.Cwd).writeMore()
		js.writeObjectField("sid").writeEscapeString(ps.SID).writeMore()

		js.writeObjectField("args")
		js.writeArrayStart()
		for i, arg := range ps.Args {
			writeMore := js.shouldWriteMore(i, len(ps.Args))
			js.writeEscapeString(arg)
			if writeMore {
				js.writeMore()
			}
		}
		js.writeArrayEnd().writeMore()

		js.writeObjectField("sessionid").writeUint8(ps.SessionID)

		parent := ps.Parent
		if parent != nil {
			js.writeMore()
			js.writeObjectField("parent")
			js.writeObjectStart()

			js.writeObjectField("name").writeString(parent.Name).writeMore()
			js.writeObjectField("comm").writeEscapeString(parent.Comm).writeMore()
			js.writeObjectField("exe").writeEscapeString(parent.Exe).writeMore()
			js.writeObjectField("cwd").writeEscapeString(parent.Cwd).writeMore()
			js.writeObjectField("sid").writeEscapeString(parent.SID)

			js.writeObjectEnd()
		}

		if SerializeEnvs {
			js.writeMore()
			js.writeObjectField("envs")
			js.writeObjectStart()
			var i int
			for k, v := range ps.Envs {
				writeMore := js.shouldWriteMore(i, len(ps.Envs))
				js.writeObjectField(k).writeEscapeString(v)
				if writeMore {
					js.writeMore()
				}
				i++
			}
			js.writeObjectEnd()
		}

		if writePsResources() {
			js.writeMore()
		}

		if SerializeThreads {
			// start threads
			js.writeObjectField("threads")
			js.writeArrayStart()
			var i int
			ps.RLock()
			for _, thread := range ps.Threads {
				writeMore := js.shouldWriteMore(i, len(ps.Threads))
				js.writeObjectStart()
				js.writeObjectField("tid").writeUint32(thread.Tid).writeMore()
				js.writeObjectField("ioprio").writeUint8(thread.IOPrio).writeMore()
				js.writeObjectField("baseprio").writeUint8(thread.BasePrio).writeMore()
				js.writeObjectField("pageprio").writeUint8(thread.PagePrio).writeMore()
				js.writeObjectField("entrypoint").writeString(thread.Entrypoint.String()).writeMore()
				js.writeObjectField("ustack_base").writeString(thread.UstackBase.String()).writeMore()
				js.writeObjectField("ustack_limit").writeString(thread.UstackLimit.String()).writeMore()
				js.writeObjectField("kstack_base").writeString(thread.KstackBase.String()).writeMore()
				js.writeObjectField("kstack_limit").writeString(thread.KstackLimit.String())
				js.writeObjectEnd()
				if writeMore {
					js.writeMore()
				}
				i++
			}
			ps.RUnlock()
			// end threads
			js.writeArrayEnd()
			if SerializeImages || SerializeHandles {
				js.writeMore()
			}
		}

		if SerializeImages {
			// start modules
			js.writeObjectField("modules")
			js.writeArrayStart()

			for i, m := range ps.Modules {
				writeMore := js.shouldWriteMore(i, len(ps.Modules))
				js.writeObjectStart()
				js.writeObjectField("name").writeEscapeString(m.Name).writeMore()
				js.writeObjectField("size").writeUint32(m.Size)
				js.writeObjectEnd()
				if writeMore {
					js.writeMore()
				}
			}

			// end modules
			js.writeArrayEnd()
			if SerializeHandles {
				js.writeMore()
			}
		}

		if SerializeHandles {
			// start handles
			js.writeObjectField("handles")
			js.writeArrayStart()

			for i, handle := range ps.Handles {
				writeMore := js.shouldWriteMore(i, len(ps.Handles))
				js.writeObjectStart()
				js.writeObjectField("name").writeEscapeString(handle.Name).writeMore()
				js.writeObjectField("type").writeString(handle.Type).writeMore()
				js.writeObjectField("id").writeUint64(uint64(handle.Num)).writeMore()
				js.writeObjectField("object").writeEscapeString(string(kparams.NewHex(handle.Object)))
				js.writeObjectEnd()

				if writeMore {
					js.writeMore()
				}
			}
			// end handles
			js.writeArrayEnd()
			if SerializePE && ps.PE != nil {
				js.writeMore()
			}
		}

		pe := ps.PE
		if SerializePE && pe != nil {
			// start PE
			js.writeObjectField("pe")
			js.writeObjectStart()

			js.writeObjectField("nsections").writeUint16(pe.NumberOfSections).writeMore()
			js.writeObjectField("nsymbols").writeUint32(pe.NumberOfSymbols).writeMore()
			js.writeObjectField("image_base").writeString(pe.ImageBase).writeMore()
			js.writeObjectField("entrypoint").writeString(pe.EntryPoint).writeMore()

			timestamp := make([]byte, 0)
			timestamp = kevt.Timestamp.AppendFormat(timestamp, time.RFC3339Nano)
			js.writeObjectField("link_time").writeString(string(timestamp)).writeMore()

			// sections
			if len(pe.Sections) > 0 {
				js.writeObjectField("sections")
				js.writeArrayStart()

				for i, sec := range pe.Sections {
					writeMore := js.shouldWriteMore(i, len(pe.Sections))
					js.writeObjectStart()
					js.writeObjectField("name").writeEscapeString(sec.Name).writeMore()
					js.writeObjectField("size").writeUint32(sec.Size).writeMore()
					js.writeObjectField("entropy").writeFloat64(sec.Entropy).writeMore()
					js.writeObjectField("md5").writeString(sec.Md5)

					js.writeObjectEnd()
					if writeMore {
						js.writeMore()
					}
				}

				js.writeArrayEnd()
				if len(pe.Symbols) > 0 {
					js.writeMore()
				}
			}

			// imported symbols
			if len(pe.Symbols) > 0 {
				js.writeObjectField("symbols")
				js.writeArrayStart()

				for i, sym := range pe.Symbols {
					writeMore := js.shouldWriteMore(i, len(pe.Symbols))
					js.writeEscapeString(sym)

					if writeMore {
						js.writeMore()
					}
				}

				js.writeArrayEnd()
				if len(pe.Imports) > 0 {
					js.writeMore()
				}
			}

			// imports
			if len(pe.Imports) > 0 {
				js.writeObjectField("imports")
				js.writeArrayStart()

				for i, imp := range pe.Imports {
					writeMore := js.shouldWriteMore(i, len(pe.Imports))
					js.writeEscapeString(imp)

					if writeMore {
						js.writeMore()
					}
				}

				js.writeArrayEnd()
				if len(pe.VersionResources) > 0 {
					js.writeMore()
				}
			}

			// version resources
			if len(pe.VersionResources) > 0 {
				js.writeObjectField("resources")
				js.writeObjectStart()

				var i int
				for k, v := range pe.VersionResources {
					writeMore := js.shouldWriteMore(i, len(pe.VersionResources))
					js.writeObjectField(k).writeEscapeString(v)

					if writeMore {
						js.writeMore()
					}
					i++
				}
				js.writeObjectEnd()
			}

			// end PE
			js.writeObjectEnd()
		}

		// end process state
		js.writeObjectEnd()
	}

	// end of JSON
	js.writeObjectEnd()

	return js.flush()
}

```

`pkg/kevent/sequencer_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"errors"
	"expvar"
	"fmt"
	"golang.org/x/sys/windows/registry"
	"sync/atomic"
	"syscall"
	"time"
)

const (
	// seqVName is the name of the registry value that stores the QWORD sequence.
	seqVName   = "KeventSeq"
	invalidKey = registry.Key(syscall.InvalidHandle)
)

var seqStoreErrors = expvar.NewInt("kevent.seq.store.errors")
var seqInitErrors = expvar.NewMap("kevent.seq.init.errors")
var errInvalidVolatileKey = errors.New("couldn't open HKCU/Volatile Environment key")

const flags = uint32(registry.QUERY_VALUE | registry.SET_VALUE)

// Sequencer is responsible for incrementing, getting and persisting the kevent sequence number in the Windows registry.
type Sequencer struct {
	key  registry.Key
	quit chan struct{}
	seq  uint64
}

// NewSequencer creates a fresh kevent sequencer. If the `KeventSeq` value is present under the volatile key, the current
// sequence number is initialized to the last stored sequence. The sequencer schedules a ticker that periodically dumps
// the current sequence number into the registry value.
func NewSequencer() *Sequencer {
	key, err := registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", flags)
	if err != nil {
		seqInitErrors.Add(err.Error(), 1)
		return &Sequencer{key: invalidKey, quit: make(chan struct{}, 1)}
	}
	s := &Sequencer{
		key:  key,
		quit: make(chan struct{}, 1),
		seq:  uint64(0),
	}
	s.seq, _, _ = key.GetIntegerValue(seqVName)

	go s.store()

	return s
}

// Store saves the current sequence value in the registry.
func (s *Sequencer) Store() error {
	if s.key == invalidKey {
		// try to open the key again
		var err error
		s.key, err = registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", flags)
		if err != nil {
			return errInvalidVolatileKey
		}
	}
	nextSeq := s.Get()
	prevSeq, _, err := s.key.GetIntegerValue(seqVName)
	if err == nil && nextSeq < prevSeq {
		return fmt.Errorf("current sequence number %d is lower than registry value %d", nextSeq, prevSeq)
	}
	return s.key.SetQWordValue(seqVName, nextSeq)
}

// Increment increments the sequence number atomically.
func (s *Sequencer) Increment() {
	atomic.AddUint64(&s.seq, 1)
}

// Get returns the current sequence number.
func (s *Sequencer) Get() uint64 {
	return atomic.LoadUint64(&s.seq)
}

// Reset removes the sequence value from the registry and sets the sequence number to zero.
func (s *Sequencer) Reset() error {
	atomic.StoreUint64(&s.seq, 0)
	if s.key == invalidKey {
		return errInvalidVolatileKey
	}
	return s.key.DeleteValue(seqVName)
}

// Close shutdowns the event sequencer.
func (s *Sequencer) Close() error {
	s.quit <- struct{}{}
	return s.key.Close()
}

// store periodically dumps the sequence number into registry value.
func (s *Sequencer) store() {
	ticker := time.NewTicker(time.Second * 5)
	for {
		select {
		case <-ticker.C:
			if err := s.Store(); err != nil {
				seqStoreErrors.Add(1)
			}
		case <-s.quit:
			ticker.Stop()
			return
		}
	}
}

```

`pkg/kevent/sequencer_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kevent

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestSequencer(t *testing.T) {
	sequencer := NewSequencer()
	sequencer.seq = 0
	defer sequencer.Close()

	for i := 0; i < 10; i++ {
		sequencer.Increment()
	}
	assert.Equal(t, uint64(10), sequencer.Get())
	require.NoError(t, sequencer.Store())

	sequencer = NewSequencer()
	defer sequencer.Close()
	assert.Equal(t, uint64(10), sequencer.Get())

	require.NoError(t, sequencer.Reset())
	assert.Equal(t, uint64(0), sequencer.Get())
}

func TestSequencerMonotonic(t *testing.T) {
	sequencer := NewSequencer()
	sequencer.seq = 0
	defer sequencer.Close()

	for i := 0; i < 10; i++ {
		sequencer.Increment()
	}
	require.NoError(t, sequencer.Store())

	sequencer = NewSequencer()
	defer sequencer.Close()
	sequencer.seq = uint64(0)

	require.Error(t, sequencer.Store())
	require.NoError(t, sequencer.Reset())
}

```

`pkg/kstream/README.md`:

```md
### package `kstream`

This package represents the backbone of the kernel event collection. It configures the processing of the trace session, consumes events and parses the required parameters. 

```

`pkg/kstream/controller_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kstream

import (
	"fmt"
	"runtime"
	"syscall"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/etw"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows/registry"
)

const (
	// maxBufferSize specifies the maximum buffer size for event tracing session buffer
	maxBufferSize = 1024
	// etwMaxLoggersPath is the registry subkey that contains ETW logger preferences
	etwMaxLoggersPath = `SYSTEM\CurrentControlSet\Control\WMI`
	// etwMaxLoggersValue is the registry value that dictates the maximum number of loggers. Default value is 64 on most systems
	etwMaxLoggersValue = "EtwMaxLoggers"
	maxStringLen       = 1024
)

// for testing purposes
var (
	startTrace   = etw.StartTrace
	controlTrace = etw.ControlTrace
	enableTrace  = etw.EnableTrace
)

// TraceSession stores metadata of the initiated tracing session.
type TraceSession struct {
	Handle etw.TraceHandle
	Name   string
	GUID   syscall.GUID
}

// IsKernelLogger determines if the session is tied to the NT Kernel Logger provider.
func (s TraceSession) IsKernelLogger() bool {
	return s.GUID == etw.KernelTraceControlGUID
}

// TraceProvider describes the ETW provider metainfo. The provider
// acts as a source of events that are published to the tracing
// session.
type TraceProvider struct {
	TraceName string       // trace name
	GUID      syscall.GUID // provider GUID
	Keywords  uint32       // enabled keywords
	Enabled   bool         // whether the provider is enabled
}

// IsKernelLogger determines if this provider is the NT Kernel Logger.
func (p TraceProvider) IsKernelLogger() bool {
	return p.GUID == etw.KernelTraceControlGUID
}

var providers = []TraceProvider{
	{
		// core system events
		etw.KernelLoggerSession,
		etw.KernelTraceControlGUID,
		0x0, // no keywords
		true,
	},
	{
		// provides a source of events for constructing the state of opened file objects
		etw.KernelLoggerRundownSession,
		etw.KernelRundownGUID,
		0x10, // file rundown events
		true,
	},
	{
		// supplies the `OpenProcess` and `OpenThread` events
		etw.KernelAuditAPICallsSession,
		etw.KernelAuditAPICallsGUID,
		0x0, // no keywords, so we accept all events
		true,
	},
}

// KtraceController is responsible for managing the life cycle of the tracing sessions.
type KtraceController interface {
	// StartKtrace starts configured tracing sessions.
	StartKtrace() error
	// CloseKtrace stops currently running tracing sessions.
	CloseKtrace() error
	// Traces returns initiated tracing sessions.
	Traces() map[string]TraceSession
}

type ktraceController struct {
	// kstreamConfig stores kernel stream-specific settings
	kstreamConfig config.KstreamConfig
	// traces contains initiated tracing sessions
	traces map[string]TraceSession
}

// NewKtraceController spins up a new instance of kernel trace controller.
func NewKtraceController(kstreamConfig config.KstreamConfig) KtraceController {
	controller := &ktraceController{
		kstreamConfig: kstreamConfig,
		traces:        make(map[string]TraceSession),
	}
	return controller
}

// StartKtrace starts configured tracing sessions. User has the ability to disable
// a specific subset of collected kernel events, even though by default most events
// are forwarded from the provider. Flags are only valid in context of the NT Kernel
// Logger sessions. On the contrary, keywords can only be used on the non-NT Kernel
// Logger tracing sessions.
func (k *ktraceController) StartKtrace() error {
	// at least process events have to be enabled
	// for the purpose of building the state machine
	flags := etw.Process
	if k.kstreamConfig.EnableThreadKevents {
		flags |= etw.Thread
	}
	if k.kstreamConfig.EnableImageKevents {
		flags |= etw.ImageLoad
	}
	if k.kstreamConfig.EnableNetKevents {
		flags |= etw.NetTCPIP
	}
	if k.kstreamConfig.EnableRegistryKevents {
		flags |= etw.Registry
	}
	if k.kstreamConfig.EnableFileIOKevents {
		flags |= etw.DiskFileIO | etw.FileIO | etw.FileIOInit
	}

	bufferSize := k.kstreamConfig.BufferSize
	if bufferSize > maxBufferSize {
		bufferSize = maxBufferSize
	}
	// validate min/max buffers. The minimal
	// number of buffers is 2 per CPU logical core
	minBuffers := k.kstreamConfig.MinBuffers
	if minBuffers < uint32(runtime.NumCPU()*2) {
		minBuffers = uint32(runtime.NumCPU() * 2)
	}
	maxBuffers := k.kstreamConfig.MaxBuffers
	maxBuffersAllowed := minBuffers + 20
	if maxBuffers > maxBuffersAllowed {
		maxBuffers = maxBuffersAllowed
	}
	if minBuffers > maxBuffers {
		minBuffers = maxBuffers
	}

	flushTimer := k.kstreamConfig.FlushTimer
	if flushTimer < time.Second {
		flushTimer = time.Second
	}

	for _, prov := range providers {
		if !prov.Enabled {
			log.Warnf("provider for trace [%s] is disabled", prov.TraceName)
			continue
		}
		props := &etw.EventTraceProperties{
			Wnode: etw.WnodeHeader{
				BufferSize: uint32(unsafe.Sizeof(etw.EventTraceProperties{})) + 2*maxStringLen,
				Flags:      etw.WnodeTraceFlagGUID,
			},
			LoggerNameOffset:  uint32(unsafe.Sizeof(etw.EventTraceProperties{})),
			LogFileNameOffset: 0,
			BufferSize:        bufferSize,
			LogFileMode:       etw.ProcessTraceModeRealtime,
			MinimumBuffers:    minBuffers,
			MaximumBuffers:    maxBuffers,
			FlushTimer:        uint32(flushTimer.Seconds()),
		}
		if prov.IsKernelLogger() {
			props.EnableFlags = flags
			props.Wnode.GUID = prov.GUID
			log.Debugf("starting kernel trace with %q event flags", flags)
		}
		traceName := prov.TraceName

		handle, err := startTrace(
			traceName,
			props,
		)
		log.Debugf("starting trace [%s]", traceName)

		if err == nil {
			if !handle.IsValid() {
				return kerrors.ErrInvalidTrace
			}
			if prov.IsKernelLogger() {
				handleCopy := handle
				// poorly documented ETW feature that allows for enabling an extended set of
				// kernel event tracing flags. According to the MSDN documentation, aside from
				// invoking `EventTraceProperties` function to enable object manager tracking
				// the `EventTraceProperties` structure's `EnableFlags` member needs to be set to PERF_OB_HANDLE (0x80000040).
				// This actually results in an erroneous trace start. The documentation neither specifies how the function
				// should be called (group mask array with its 4th element set to 0x80000040).
				sysTraceFlags := make([]etw.EventTraceFlags, 8)
				// when we call the`TraceSetInformation` with event empty group mask reserved for the
				// flags that are bitvectored into `EventTraceProperties` structure's `EnableFlags` field,
				// it will trigger the arrival of rundown events including open file objects and
				// registry keys that are very valuable for us to construct the initial snapshot of
				// these system resources and let us build the event's context
				if err := etw.SetTraceInformation(handle, etw.TraceSystemTraceEnableFlagsInfo, sysTraceFlags); err != nil {
					log.Warn(err)
				}
				sysTraceFlags[0] = flags
				// enable object manager tracking
				if k.kstreamConfig.EnableHandleKevents {
					sysTraceFlags[4] = etw.Handle
				}
				// call again to enable all kernel events. Just to recap. The first call to `TraceSetInformation` with empty
				// group masks activates rundown events, while this second call enables the rest of the kernel events specified in flags.
				if err := etw.SetTraceInformation(handle, etw.TraceSystemTraceEnableFlagsInfo, sysTraceFlags); err != nil {
					log.Warnf("unable to set trace information: %v", err)
				}
				k.insertTrace(traceName, handleCopy, prov.GUID)
			} else {
				// enable the specified trace provider
				if err := enableTrace(prov.GUID, handle, prov.Keywords); err != nil {
					return fmt.Errorf("unable to activate %s provider: %v", traceName, err)
				}
				k.insertTrace(traceName, handle, prov.GUID)
			}
		}

		switch err {
		case kerrors.ErrTraceAlreadyRunning:
			if err := controlTrace(etw.TraceHandle(0), traceName, props, etw.Query); err == kerrors.ErrKsessionNotRunning {
				return kerrors.ErrCannotUpdateTrace
			}
			if err := controlTrace(etw.TraceHandle(0), traceName, props, etw.Stop); err != nil {
				return kerrors.ErrStopTrace
			}

			time.Sleep(time.Millisecond * 100)
			props := &etw.EventTraceProperties{
				Wnode: etw.WnodeHeader{
					BufferSize: uint32(unsafe.Sizeof(etw.EventTraceProperties{})) + 2*maxStringLen,
					Flags:      etw.WnodeTraceFlagGUID,
				},
				LoggerNameOffset:  uint32(unsafe.Sizeof(etw.EventTraceProperties{})),
				LogFileNameOffset: 0,
				BufferSize:        bufferSize,
				LogFileMode:       etw.ProcessTraceModeRealtime,
				MinimumBuffers:    minBuffers,
				MaximumBuffers:    maxBuffers,
				FlushTimer:        uint32(flushTimer.Seconds()),
			}
			if prov.IsKernelLogger() {
				props.EnableFlags = flags
				props.Wnode.GUID = prov.GUID
			}
			handle, err := startTrace(
				traceName,
				props,
			)
			if err != nil {
				return kerrors.ErrRestartTrace
			}
			if !handle.IsValid() {
				return kerrors.ErrInvalidTrace
			}
			if prov.IsKernelLogger() {
				handleCopy := handle

				sysTraceFlags := make([]etw.EventTraceFlags, 8)
				if err := etw.SetTraceInformation(handle, etw.TraceSystemTraceEnableFlagsInfo, sysTraceFlags); err != nil {
					log.Warn(err)
				}
				sysTraceFlags[0] = flags
				// enable object manager tracking
				if k.kstreamConfig.EnableHandleKevents {
					sysTraceFlags[4] = etw.Handle
				}
				// call again to enable all kernel events. Just to recap. The first call to `TraceSetInformation` with empty
				// group masks activates rundown events, while this second call enables the rest of the kernel events specified in flags.
				if err := etw.SetTraceInformation(handle, etw.TraceSystemTraceEnableFlagsInfo, sysTraceFlags); err != nil {
					log.Warnf("unable to set trace information: %v", err)
				}
				k.insertTrace(traceName, handleCopy, prov.GUID)
			} else {
				if err := enableTrace(prov.GUID, handle, prov.Keywords); err != nil {
					return fmt.Errorf("unable to activate %s provider: %v", traceName, err)
				}
				k.insertTrace(traceName, handle, prov.GUID)
			}
		case kerrors.ErrTraceNoSysResources:
			// get the number of maximum allowed loggers from registry
			key, err := registry.OpenKey(registry.LOCAL_MACHINE, etwMaxLoggersPath, registry.QUERY_VALUE)
			if err != nil {
				return err
			}
			v, _, err := key.GetIntegerValue(etwMaxLoggersValue)
			if err != nil {
				_ = key.Close()
				return err
			}
			_ = key.Close()
			return fmt.Errorf(`the limit for logging sessions on your system is %d. Please consider increasing this number `+
				`by editing HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\EtwMaxLoggers key in registry. `+
				`Permissible values are 32 through 256 inclusive, and a reboot is required for any change to take effect`, v)
		default:
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// CloseKtrace stops currently running trace sessions.
func (k *ktraceController) CloseKtrace() error {
	for _, trace := range k.traces {
		props := &etw.EventTraceProperties{
			Wnode: etw.WnodeHeader{
				BufferSize: uint32(unsafe.Sizeof(etw.EventTraceProperties{})) + 2*maxStringLen,
				GUID:       trace.GUID,
			},
			LoggerNameOffset:  uint32(unsafe.Sizeof(etw.EventTraceProperties{})),
			LogFileNameOffset: 0,
		}
		if err := controlTrace(etw.TraceHandle(0), trace.Name, props, etw.Flush); err != nil {
			log.Warnf("couldn't flush trace session for [%s]: %v", trace.Name, err)
		}
		time.Sleep(time.Millisecond * 50)
		if err := controlTrace(etw.TraceHandle(0), trace.Name, props, etw.Stop); err != nil {
			log.Warnf("couldn't stop trace session for [%s]: %v", trace.Name, err)
		}
	}
	return nil
}

func (k *ktraceController) Traces() map[string]TraceSession { return k.traces }

func (k *ktraceController) insertTrace(name string, handle etw.TraceHandle, guid syscall.GUID) {
	trace := TraceSession{
		Handle: handle,
		Name:   name,
		GUID:   guid,
	}
	k.traces[name] = trace
}

```

`pkg/kstream/controller_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kstream

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/etw"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"syscall"
	"testing"
	"time"
)

func TestStartKtraceSuccess(t *testing.T) {
	startTrace = func(name string, flags *etw.EventTraceProperties) (etw.TraceHandle, error) {
		return etw.TraceHandle(1), nil
	}
	enableTrace = func(guid syscall.GUID, handle etw.TraceHandle, keyword uint32) error {
		return nil
	}

	ktracec := NewKtraceController(config.KstreamConfig{
		EnableThreadKevents: true,
		EnableNetKevents:    true,
		BufferSize:          1024,
		FlushTimer:          time.Millisecond * 2300,
	})

	err := ktracec.StartKtrace()

	require.NoError(t, err)
	assert.Len(t, ktracec.(*ktraceController).traces, 3)
}

func TestStartKtraceNoSysResources(t *testing.T) {
	startTrace = func(name string, props *etw.EventTraceProperties) (etw.TraceHandle, error) {
		return etw.TraceHandle(0), errors.ErrTraceNoSysResources
	}

	ktracec := NewKtraceController(config.KstreamConfig{EnableThreadKevents: true, BufferSize: 1024})

	err := ktracec.StartKtrace()

	require.Error(t, err)
}

```

`pkg/kstream/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package kstream contains facilities for controlling the kernel logger session and opening kernel event stream
// for the purpose of collecting and processing kernel events.
package kstream

```

`pkg/kstream/interceptors/chain.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"
	"fmt"

	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
)

// interceptorFailures counts the number of failures caused by interceptors while processing kernel events
var interceptorFailures = expvar.NewInt("kevent.interceptor.failures")

// Chain defines the method that all chan interceptors have to satisfy.
type Chain interface {
	// Dispatch pushes a kernel event into interceptor chain. Interceptors are applied sequentially, so we have to make
	// sure that any interceptor providing additional context to the next interceptor is defined first in the chain. If
	// one interceptor fails, the next interceptor in chain is invoked.
	Dispatch(kevt *kevent.Kevent) (*kevent.Kevent, error)
	// Close closes the interceptor chain and frees all allocated resources.
	Close() error
}

func (c *chain) addInterceptor(interceptor KstreamInterceptor) {
	if interceptor == nil {
		return
	}
	c.interceptors = append(c.interceptors, interceptor)
}

// Dispatch pushes a kernel event into interceptor chain. Interceptors are applied sequentially, so we have to make
// sure that any interceptor providing additional context to the next interceptor is defined first in the chain. If
// one interceptor fails, the next interceptor in chain is invoked.
func (c chain) Dispatch(kevt *kevent.Kevent) (*kevent.Kevent, error) {
	var errs = make([]error, 0)
	var cukerr error

	for _, interceptor := range c.interceptors {
		var err error
		var next bool
		kevt, next, err = interceptor.Intercept(kevt)
		if err != nil {
			if !kerrors.IsCancelUpstreamKevent(err) {
				interceptorFailures.Add(1)
				errs = append(errs, fmt.Errorf("%q interceptor failed with error: %v", interceptor.Name(), err))
				continue
			} else {
				cukerr = err
			}
		}
		if !next {
			break
		}
	}

	if len(errs) > 0 {
		return kevt, multierror.Wrap(errs...)
	}

	if cukerr != nil {
		return kevt, cukerr
	}

	return kevt, nil
}

// Close closes the interceptor chain and frees all allocated resources.
func (c chain) Close() error {
	for _, interceptor := range c.interceptors {
		interceptor.Close()
	}
	close(c.deferredKevts)
	return nil
}

```

`pkg/kstream/interceptors/chain_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/yara"
	log "github.com/sirupsen/logrus"
)

// EnqueueKeventCallback is the type definition for the event enqueue callback function
type EnqueueKeventCallback func(kevent *kevent.Kevent) error

// deferredEnqueued counts the number of deferred events
var deferredEnqueued = expvar.NewInt("kstream.deferred.kevents.enqueued")

type chain struct {
	interceptors  []KstreamInterceptor
	deferredKevts chan *kevent.Kevent
	psnapshotter  ps.Snapshotter
	cb            EnqueueKeventCallback
}

// NewChain constructs the interceptor chain. It arranges all the interceptors
// according to enabled kernel event categories.
func NewChain(
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
	cb EnqueueKeventCallback,
) Chain {
	var (
		chain = &chain{
			psnapshotter:  psnap,
			cb:            cb,
			interceptors:  make([]KstreamInterceptor, 0),
			deferredKevts: make(chan *kevent.Kevent, 1000),
		}
		devMapper = fs.NewDevMapper()
		scanner   yara.Scanner
	)

	if config.Yara.Enabled {
		var err error
		scanner, err = yara.NewScanner(psnap, config.Yara)
		if err != nil {
			log.Warnf("unable to start YARA scanner: %v", err)
		}
	}

	chain.addInterceptor(newPsInterceptor(psnap, scanner))

	if config.Kstream.EnableFileIOKevents {
		chain.addInterceptor(newFsInterceptor(devMapper, hsnap))
	}
	if config.Kstream.EnableRegistryKevents {
		chain.addInterceptor(newRegistryInterceptor(hsnap))
	}
	if config.Kstream.EnableImageKevents {
		chain.addInterceptor(newImageInterceptor(psnap, devMapper, scanner))
	}
	if config.Kstream.EnableNetKevents {
		chain.addInterceptor(newNetInterceptor())
	}
	if config.Kstream.EnableHandleKevents {
		chain.addInterceptor(newHandleInterceptor(hsnap, handle.NewObjectTypeStore(), devMapper, chain.deferredKevts))
		go chain.consumeDeferred()
	}

	return chain
}

// consumeDeferred is responsible for receiving the events
// that have been deferred by the interceptors. Events are
// usually deferred when some of their parameters or global
// state depend on the presence of other events. For example,
// CreateHandle events sometimes lack the involved handle name,
// but their counterpart, CloseHandle events contain that
// information. So, we wait for the CloseHandle counterpart to
// occur to augment the deferred event with the handle name param.
func (c *chain) consumeDeferred() {
	for kevt := range c.deferredKevts {
		if c.cb != nil {
			err := c.cb(kevt)
			if err == nil {
				deferredEnqueued.Add(1)
			}
		}
	}
}

```

`pkg/kstream/interceptors/fs_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"
	"sync"

	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
)

var (
	// totalRundownFiles counts the number of opened files
	totalRundownFiles = expvar.NewInt("fs.total.rundown.files")
	// fileObjectMisses computes file object cache misses
	fileObjectMisses     = expvar.NewInt("fs.file.objects.misses")
	fileObjectHandleHits = expvar.NewInt("fs.file.object.handle.hits")
	fileReleaseCount     = expvar.NewInt("fs.file.releases")
)

type fsInterceptor struct {
	// files stores the file metadata indexed by file object
	files map[uint64]*fileInfo
	mux   sync.Mutex
	// devMapper translates DOS device names to regular drive letters
	devMapper fs.DevMapper
	hsnap     handle.Snapshotter

	pendingKevents map[uint64]*kevent.Kevent
}

type fileInfo struct {
	name string
	typ  fs.FileType
}

// fileInfoClass contains the values that specify which structure to use to query or set information for a file object.
// For more information see https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_file_information_class
var fileInfoClasses = map[uint32]string{
	1:  "Directory",
	2:  "Full Directory",
	3:  "Both Directory",
	4:  "Basic",
	5:  "Standard",
	6:  "Internal",
	7:  "EA",
	8:  "Access",
	9:  "Name",
	10: "Rename",
	11: "Link",
	12: "Names",
	13: "Disposition",
	14: "Position",
	15: "Full EA",
	16: "Mode",
	17: "Alignment",
	18: "All",
	19: "Allocation",
	20: "EOF",
	21: "Alternative Name",
	22: "Stream",
	23: "Pipe",
	24: "Pipe Local",
	25: "Pipe Remote",
	26: "Mailslot Query",
	27: "Mailslot Set",
	28: "Compression",
	29: "Object ID",
	30: "Completion",
	31: "Move Cluster",
	32: "Quota",
	33: "Reparse Point",
	34: "Network Open",
	35: "Attribute Tag",
	36: "Tracking",
	37: "ID Both Directory",
	38: "ID Full Directory",
	39: "Valid Data Length",
	40: "Short Name",
	41: "IO Completion Notification",
	42: "IO Status Block Range",
	43: "IO Priority Hint",
	44: "Sfio Reserve",
	45: "Sfio Volume",
	46: "Hard Link",
	47: "Process IDS Using File",
	48: "Normalized Name",
	49: "Network Physical Name",
	50: "ID Global Tx Directory",
	51: "Is Remote Device",
	52: "Unused",
	53: "Numa Node",
	54: "Standard Link",
	55: "Remote Protocol",
	56: "Rename Bypass Access Check",
	57: "Link Bypass Access Check",
	58: "Volume Name",
	59: "ID",
	60: "ID Extended Directory",
	61: "Replace Completion",
	62: "Hard Link Full ID",
	63: "ID Extended Both Directory",
	64: "Disposition Extended",
	65: "Rename Extended",
	66: "Rename Extended Bypass Access Check",
	67: "Desired Storage",
	68: "Stat",
	69: "Memory Partition",
	70: "Stat LX",
	71: "Case Sensitive",
	72: "Link Extended",
	73: "Link Extended Bypass Access Check",
	74: "Storage Reserve ID",
	75: "Case Sensitive Force Access Check",
}

func infoClassFromID(klass uint32) string {
	class, ok := fileInfoClasses[klass]
	if !ok {
		return "Unknown"
	}
	return class
}

func newFsInterceptor(devMapper fs.DevMapper, hsnap handle.Snapshotter) KstreamInterceptor {
	interceptor := &fsInterceptor{
		files:          make(map[uint64]*fileInfo),
		pendingKevents: make(map[uint64]*kevent.Kevent),
		devMapper:      devMapper,
		hsnap:          hsnap,
	}
	return interceptor
}

func (f *fsInterceptor) Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error) {
	switch kevt.Type {
	case ktypes.FileRundown,
		ktypes.FileOpEnd,
		ktypes.CreateFile,
		ktypes.DeleteFile,
		ktypes.CloseFile,
		ktypes.WriteFile,
		ktypes.ReadFile,
		ktypes.RenameFile,
		ktypes.ReleaseFile,
		ktypes.SetFileInformation,
		ktypes.EnumDirectory:

		fobj, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileObject)
		if err != nil && kevt.Type != ktypes.FileOpEnd {
			return kevt, true, err
		}
		// when the file rundown event comes in we store the file info
		// in the map in order to augment the rest of file events
		// that lack the file name field
		if kevt.Type == ktypes.FileRundown {
			filename, err := kevt.Kparams.GetString(kparams.FileName)
			if err != nil {
				return kevt, true, err
			}

			f.mux.Lock()
			defer f.mux.Unlock()
			if _, ok := f.files[fobj]; !ok {
				filename = f.devMapper.Convert(filename)
				totalRundownFiles.Add(1)
				f.files[fobj] = &fileInfo{name: filename, typ: fs.GetFileType(filename, 0)}
			}

			return kevt, false, nil
		}
		// we'll update event's thread identifier with the one
		// that's involved in the file system operation
		kevt.Tid, err = kevt.Kparams.GetUint32(kparams.ThreadID)
		if err != nil {
			// tid is sometimes represented in hex format
			kevt.Tid, _ = kevt.Kparams.GetHexAsUint32(kparams.ThreadID)
		}

		switch kevt.Type {
		case ktypes.CreateFile:
			// we defer the processing of the CreateFile event until we get
			// the matching FileOpEnd event. This event contains the operation
			// that was done on behalf of the file, e.g. create or open.
			irp, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileIrpPtr)
			if err != nil {
				return kevt, true, err
			}
			f.pendingKevents[irp] = kevt
			return kevt, false, kerrors.ErrCancelUpstreamKevent

		case ktypes.FileOpEnd:
			// get the CreateFile pending event by IRP identifier
			irp, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileIrpPtr)
			if err != nil {
				return kevt, true, err
			}
			extraInfo, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileExtraInfo)
			if err != nil {
				return kevt, true, err
			}
			fkevt, ok := f.pendingKevents[irp]
			if !ok {
				return kevt, true, kerrors.ErrCancelUpstreamKevent
			}
			fkevt.Kparams.Append(kparams.FileExtraInfo, kparams.Uint64, extraInfo)

			// resolve the status of the file operation
			status, err := kevt.Kparams.GetUint32(kparams.NTStatus)
			if err == nil {
				_ = fkevt.Kparams.Append(kparams.NTStatus, kparams.UnicodeString, formatStatus(status, fkevt))
			}

			delete(f.pendingKevents, irp)
			if err := f.processCreateFile(fkevt); err != nil {
				return kevt, true, err
			}
			return fkevt, false, nil

		case ktypes.ReleaseFile:
			fileReleaseCount.Add(1)
			// delete both, the file object and the file key from files map
			fileKey, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileKey)
			f.mux.Lock()
			defer f.mux.Unlock()
			if err == nil {
				delete(f.files, fileKey)
			}
			delete(f.files, fobj)

		case ktypes.DeleteFile, ktypes.RenameFile,
			ktypes.CloseFile, ktypes.ReadFile,
			ktypes.WriteFile, ktypes.SetFileInformation, ktypes.EnumDirectory:

			fileKey, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileKey)
			if err != nil {
				return kevt, true, err
			}

			// attempt to get the file by file key. If there is no such file referenced
			// by the file key, then try to fetch it by file object. Even if file object
			// references fails, we search in the file handles for such file
			f.mux.Lock()
			defer f.mux.Unlock()
			fileinfo, ok := f.files[fileKey]
			if !ok {
				fileinfo, ok = f.files[fobj]
				if !ok {
					// look in the system handles for file objects
					var h htypes.Handle
					h, ok = f.hsnap.FindByObject(fobj)
					if ok && h.Type == handle.File {
						fileObjectHandleHits.Add(1)
						f.files[fobj] = &fileInfo{name: h.Name, typ: fs.GetFileType(h.Name, 0)}
					}
				}
			}

			// ignore object misses that are produced by CloseFile
			if !ok && kevt.Type != ktypes.CloseFile {
				fileObjectMisses.Add(1)
			}

			if kevt.Type == ktypes.DeleteFile {
				delete(f.files, fobj)
			}

			if kevt.Type == ktypes.SetFileInformation || kevt.Type == ktypes.EnumDirectory || kevt.Type == ktypes.RenameFile || kevt.Type == ktypes.DeleteFile {
				// assign a human-readable information class from the class ID
				infoClassID, err := kevt.Kparams.GetUint32(kparams.FileInfoClass)
				if err == nil {
					kevt.Kparams.Remove(kparams.FileInfoClass)
					kevt.Kparams.Append(kparams.FileInfoClass, kparams.AnsiString, infoClassFromID(infoClassID))
				}
				kevt.Kparams.Remove(kparams.FileExtraInfo)
			}

			if kevt.Type == ktypes.EnumDirectory {
				// the file key kparam contains the reference to the directory name
				fileKey, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileKey)
				if err != nil {
					kevt.Kparams.Remove(kparams.FileKey)
					removeKparams(kevt)
					return kevt, true, nil
				}
				kevt.Kparams.Remove(kparams.FileKey)
				fileinfo, ok := f.files[fileKey]
				if ok && fileinfo != nil {
					kevt.Kparams.Append(kparams.FileDirectory, kparams.UnicodeString, fileinfo.name)
				}
			}

			removeKparams(kevt)

			if err := f.appendKparams(fileinfo, kevt); err != nil {
				return kevt, true, err
			}
		}
	default:
		return kevt, true, nil
	}

	return kevt, true, nil
}

func (*fsInterceptor) Name() InterceptorType { return Fs }
func (f *fsInterceptor) Close()              {}

func (f *fsInterceptor) getFileInfo(name string, opts uint32) *fileInfo {
	return &fileInfo{name: name, typ: fs.GetFileType(name, opts)}
}

func (f *fsInterceptor) processCreateFile(kevt *kevent.Kevent) error {
	fobj, err := kevt.Kparams.TryGetHexAsUint64(kparams.FileObject)
	if err != nil {
		return err
	}
	extraInfo, err := kevt.Kparams.GetUint64(kparams.FileExtraInfo)
	if err != nil {
		return err
	}

	// delete raw event parameters
	kevt.Kparams.Remove(kparams.FileExtraInfo)
	// append human-readable file operation param
	kevt.Kparams.Append(kparams.FileOperation, kparams.Enum, fs.FileDisposition(extraInfo))
	// include file attributes as a slice parameter type
	attrs, _ := kevt.Kparams.GetUint32(kparams.FileAttributes)
	if attrs != 0 {
		_ = kevt.Kparams.Set(kparams.FileAttributes, fs.FileAttributes(attrs), kparams.Slice)
	} else {
		kevt.Kparams.Remove(kparams.FileAttributes)
	}

	filename, err := kevt.Kparams.GetString(kparams.FileName)
	if err != nil {
		return err
	}
	filename = f.devMapper.Convert(filename)
	if err := kevt.Kparams.Set(kparams.FileName, filename, kparams.UnicodeString); err != nil {
		return err
	}
	// figure out the file share mask that determines
	// the type of share access that the caller thread
	// would like to grant to other threads
	mask, err := kevt.Kparams.GetUint32(kparams.FileShareMask)
	if err != nil {
		return err
	}
	if err := kevt.Kparams.Set(kparams.FileShareMask, fs.FileShareMode(mask), kparams.Enum); err != nil {
		return err
	}
	// try to get extended file info. If the file object is already
	// present in the map, we'll reuse the existing file information
	f.mux.Lock()
	defer f.mux.Unlock()
	fileinfo, ok := f.files[fobj]
	if !ok {
		opts, _ := kevt.Kparams.GetUint32(kparams.FileCreateOptions)
		opts &= 0xFFFFFF

		fileinfo = f.getFileInfo(filename, opts)
		// file type couldn't be resolved so we perform the lookup
		// in system handles to determine whether file object is
		// a directory
		if fileinfo.typ == fs.Unknown {
			fileinfo.typ = f.findDirHandle(fobj)
		}
		kevt.Kparams.Append(kparams.FileType, kparams.AnsiString, fileinfo.typ.String())

		f.files[fobj] = fileinfo
	}

	removeKparams(kevt)

	return f.appendKparams(fileinfo, kevt)
}

func (f *fsInterceptor) findDirHandle(fobj uint64) fs.FileType {
	fhandle, ok := f.hsnap.FindByObject(fobj)
	if !ok || fhandle.Type != handle.File {
		return fs.Unknown
	}
	if fhandle.MD == nil {
		return fs.Unknown
	}
	md, ok := fhandle.MD.(*htypes.FileInfo)
	if ok && md.IsDirectory {
		return fs.Directory
	}
	return fs.Unknown
}

func (f *fsInterceptor) appendKparams(fileinfo *fileInfo, kevt *kevent.Kevent) error {
	if kevt.Type == ktypes.EnumDirectory {
		return nil
	}
	if fileinfo == nil {
		if kevt.Type != ktypes.CreateFile {
			kevt.Kparams.Append(kparams.FileName, kparams.UnicodeString, kparams.NA)
		}
		return nil
	}
	if fileinfo.typ != fs.Unknown {
		kevt.Kparams.Append(kparams.FileType, kparams.AnsiString, fileinfo.typ.String())
	}
	if kevt.Type != ktypes.CreateFile {
		kevt.Kparams.Append(kparams.FileName, kparams.UnicodeString, fileinfo.name)
	}
	return nil
}

// removeKparams removes unwanted kparams, either because they are already present in kevent
// canonical attributes or are not very useful.
func removeKparams(kevt *kevent.Kevent) {
	if kevt.Kparams.Contains(kparams.ProcessID) {
		kevt.Kparams.Remove(kparams.ProcessID)
	}
	if kevt.Kparams.Contains(kparams.ThreadID) {
		kevt.Kparams.Remove(kparams.ThreadID)
	}
	if kevt.Kparams.Contains(kparams.FileCreateOptions) {
		kevt.Kparams.Remove(kparams.FileCreateOptions)
	}
	if kevt.Kparams.Contains(kparams.FileKey) {
		kevt.Kparams.Remove(kparams.FileKey)
	}
}

```

`pkg/kstream/interceptors/fs_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"fmt"
	"os"
	"testing"

	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

type devMapperMock struct {
	mock.Mock
}

func (dm *devMapperMock) Convert(filename string) string {
	args := dm.Called(filename)
	return args.String(0)
}

func TestCreateFile(t *testing.T) {
	devMapper := new(devMapperMock)
	hsnapMock := new(handle.SnapshotterMock)

	sysRoot := os.Getenv("SystemRoot")
	devMapper.On("Convert", "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll").Return(fmt.Sprintf("%s\\system32\\user32.dll", sysRoot))

	fsi := newFsInterceptor(devMapper, hsnapMock)

	_, _, err := fsi.Intercept(&kevent.Kevent{
		Type: ktypes.FileRundown,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.FileObject: {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("12456738026482168384")},
			kparams.FileName:   {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileIrpPtr: {Name: kparams.FileIrpPtr, Type: kparams.HexInt64, Value: kparams.Hex("1234543123112321")},
		},
	})
	require.NoError(t, err)

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateFile,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.FileObject:        {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("18446738026482168384")},
			kparams.ThreadID:          {Name: kparams.ThreadID, Type: kparams.Uint32, Value: uint32(1484)},
			kparams.FileCreateOptions: {Name: kparams.FileCreateOptions, Type: kparams.Uint32, Value: uint32(1223456)},
			kparams.FileName:          {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\kernel32.dll"},
			kparams.FileShareMask:     {Name: kparams.FileShareMask, Type: kparams.Uint32, Value: uint32(5)},
			kparams.FileIrpPtr:        {Name: kparams.FileIrpPtr, Type: kparams.HexInt64, Value: kparams.Hex("1234543123112321")},
		},
	}
	devMapper.On("Convert", "\\Device\\HarddiskVolume2\\Windows\\system32\\kernel32.dll").Return(fmt.Sprintf("%s\\system32\\kernel32.dll", sysRoot))

	_, _, err = fsi.Intercept(kevt1)
	require.EqualErrorf(t, err, "cancel bubbling up the kernel event to upstream components", "")

	pendingKevents := fsi.(*fsInterceptor).pendingKevents
	require.Len(t, pendingKevents, 1)

	opEnd := &kevent.Kevent{
		Type: ktypes.FileOpEnd,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("18446738026482168384")},
			kparams.ThreadID:      {Name: kparams.ThreadID, Type: kparams.Uint32, Value: uint32(1484)},
			kparams.FileIrpPtr:    {Name: kparams.FileIrpPtr, Type: kparams.HexInt64, Value: kparams.Hex("1234543123112321")},
			kparams.FileExtraInfo: {Name: kparams.FileExtraInfo, Type: kparams.Uint64, Value: uint64(2)},
		},
	}
	kevt1, _, err = fsi.Intercept(opEnd)
	require.NoError(t, err)

	dispo, err := kevt1.Kparams.Get(kparams.FileOperation)
	require.NoError(t, err)
	assert.Equal(t, fs.Create, dispo.(fs.FileDisposition))
	filename, err := kevt1.Kparams.GetString(kparams.FileName)
	require.NoError(t, err)
	assert.Equal(t, fmt.Sprintf("%s\\system32\\kernel32.dll", sysRoot), filename)
	mask, err := kevt1.Kparams.Get(kparams.FileShareMask)
	require.NoError(t, err)
	assert.Equal(t, "r-d", mask.(fs.FileShareMode).String())

	require.Empty(t, pendingKevents)
}

func TestRundownFile(t *testing.T) {
	devMapper := new(devMapperMock)
	hsnapMock := new(handle.SnapshotterMock)

	sysRoot := os.Getenv("SystemRoot")
	devMapper.On("Convert", "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll").Return(fmt.Sprintf("%s\\system32\\user32.dll", sysRoot))

	fsi := newFsInterceptor(devMapper, hsnapMock)

	_, _, err := fsi.Intercept(&kevent.Kevent{
		Type: ktypes.FileRundown,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.FileObject: {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("124567380264")},
			kparams.FileName:   {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
		},
	})
	require.NoError(t, err)

	files := fsi.(*fsInterceptor).files
	require.Len(t, files, 1)

	fileinfo := files[20089293767268]
	require.NotNil(t, fileinfo)

	assert.Equal(t, fmt.Sprintf("%s\\system32\\user32.dll", sysRoot), fileinfo.name)
	assert.Equal(t, fs.Regular, fileinfo.typ)
}

func TestDeleteFile(t *testing.T) {
	devMapper := new(devMapperMock)
	hsnapMock := new(handle.SnapshotterMock)

	sysRoot := os.Getenv("SystemRoot")
	devMapper.On("Convert", "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll").Return(fmt.Sprintf("%s\\system32\\user32.dll", sysRoot))

	fsi := newFsInterceptor(devMapper, hsnapMock)

	_, _, err := fsi.Intercept(&kevent.Kevent{
		Type: ktypes.FileRundown,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.FileObject: {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("12456738026482168384")},
			kparams.FileName:   {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
		},
	})
	require.NoError(t, err)

	kevt := &kevent.Kevent{
		Type: ktypes.DeleteFile,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.FileObject: {Name: kparams.FileObject, Type: kparams.HexInt64, Value: kparams.Hex("12456738026482168384")},
			kparams.FileKey:    {Name: kparams.FileKey, Type: kparams.HexInt64, Value: kparams.Hex("12456738026482168384")},
			kparams.ThreadID:   {Name: kparams.ThreadID, Type: kparams.Uint32, Value: uint32(1484)},
		},
	}

	files := fsi.(*fsInterceptor).files
	require.Len(t, files, 1)

	_, _, err = fsi.Intercept(kevt)
	require.NoError(t, err)

	require.Empty(t, files)

	filename, err := kevt.Kparams.GetString(kparams.FileName)
	require.NoError(t, err)

	assert.Equal(t, fmt.Sprintf("%s\\system32\\user32.dll", sysRoot), filename)
	typ, err := kevt.Kparams.GetString(kparams.FileType)
	require.NoError(t, err)
	assert.Equal(t, "file", typ)
}

```

`pkg/kstream/interceptors/handle_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"
	"time"

	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	syshandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/registry"
)

var (
	handleDeferEvictions = expvar.NewInt("handle.deferred.evictions")
	handleDeferMatches   = expvar.NewInt("handle.deferred.matches")
)

// waitPeriod specifies the interval for which the accumulated
// CreateHandle events are drained from the map
var waitPeriod = time.Second * 5

type handleInterceptor struct {
	hsnap         handle.Snapshotter
	typeStore     handle.ObjectTypeStore
	devMapper     fs.DevMapper
	defers        map[uint64]*kevent.Kevent
	deferredKevts chan *kevent.Kevent
	isClosed      bool
}

func newHandleInterceptor(
	hsnap handle.Snapshotter,
	typeStore handle.ObjectTypeStore,
	devMapper fs.DevMapper,
	defferedKevts chan *kevent.Kevent,
) KstreamInterceptor {
	return &handleInterceptor{
		hsnap:         hsnap,
		typeStore:     typeStore,
		devMapper:     devMapper,
		defers:        make(map[uint64]*kevent.Kevent, 1000),
		deferredKevts: defferedKevts,
	}
}

func (h *handleInterceptor) Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error) {
	if kevt.Category == ktypes.Handle {
		handleID, err := kevt.Kparams.TryGetHexAsUint32(kparams.HandleID)
		if err != nil {
			return kevt, true, err
		}
		typeID, err := kevt.Kparams.GetUint16(kparams.HandleObjectTypeID)
		if err != nil {
			return kevt, true, err
		}
		object, err := kevt.Kparams.TryGetHexAsUint64(kparams.HandleObject)
		if err != nil {
			return kevt, true, err
		}
		// map object type identifier to its name. Query for object type if
		// we didn't find in the object store
		typeName := h.typeStore.FindByID(uint8(typeID))
		if typeName == "" {
			dup, err := handle.Duplicate(syshandle.Handle(handleID), kevt.PID, syshandle.AllAccess)
			if err != nil {
				return kevt, true, err
			}
			defer dup.Close()
			typeName, err = handle.QueryType(dup)
			if err != nil {
				return kevt, true, err
			}
			h.typeStore.RegisterType(uint8(typeID), typeName)
		}

		kevt.Kparams.Append(kparams.HandleObjectTypeName, kparams.AnsiString, typeName)
		kevt.Kparams.Remove(kparams.HandleObjectTypeID)

		// get the best possible object name according to its type
		name, err := kevt.Kparams.GetString(kparams.HandleObjectName)
		if err != nil {
			return kevt, true, err
		}

		switch typeName {
		case handle.Key:
			rootKey, keyName := handle.FormatKey(name)
			if rootKey == registry.InvalidKey {
				break
			}
			name = rootKey.String()
			if keyName != "" {
				name += "\\" + keyName
			}
		case handle.File:
			name = h.devMapper.Convert(name)
		}
		// assign the formatted handle name
		if err := kevt.Kparams.Set(kparams.HandleObjectName, name, kparams.AnsiString); err != nil {
			return kevt, true, err
		}

		if kevt.Type == ktypes.CreateHandle {
			// for some handle objects, the CreateHandle usually lacks the handle name
			// but its counterpart CloseHandle kevent ships with the handle name. We'll
			// defer emitting the CreateHandle kevent until we receive a CloseHandle targeting
			// the same object
			if name == "" {
				h.defers[object] = kevt
				return kevt, false, kerrors.ErrCancelUpstreamKevent
			}
			return kevt, false, h.hsnap.Write(kevt)
		}

		// at this point we hit CloseHandle kernel event and have the awaiting CreateHandle
		// event reference. So we set handle object name to the name of its CloseHandle counterpart
		if hkevt, ok := h.defers[object]; ok {
			delete(h.defers, object)
			if err := hkevt.Kparams.Set(kparams.HandleObjectName, name, kparams.AnsiString); err != nil {
				return kevt, true, err
			}
			handleDeferMatches.Add(1)

			// send the deferred event
			if !h.isClosed {
				select {
				case h.deferredKevts <- hkevt:
				default:
				}
			}

			err := h.hsnap.Write(hkevt)
			if err != nil {
				err = h.hsnap.Remove(kevt)
				if err != nil {
					return kevt, false, err
				}
			}

			// return the CloseHandle event
			return kevt, false, h.hsnap.Remove(kevt)
		}
		// drain pending CreateHandle kevents if they remained longer then expected. Possible
		// cause could be that we lost the corresponding CloseHandle kernel event or the
		// CreateHandle event was produced but the corresponding CloseHandle event will happen
		// during the longer time frame
		for kobj, kvt := range h.defers {
			evict := kvt.Timestamp.Before(time.Now().Add(waitPeriod))
			if evict {
				handleDeferEvictions.Add(1)
				delete(h.defers, kobj)
				// push the CreateHandle event
				if !h.isClosed {
					select {
					case h.deferredKevts <- kvt:
					default:
					}
				}
			}
		}
		return kevt, false, h.hsnap.Remove(kevt)
	}

	return kevt, true, nil
}

func (handleInterceptor) Name() InterceptorType { return Handle }
func (h *handleInterceptor) Close()             { h.isClosed = true }

```

`pkg/kstream/interceptors/handle_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

type objectTypeStoreMock struct {
	mock.Mock
}

func (s *objectTypeStoreMock) FindByID(id uint8) string {
	args := s.Called(id)
	return args.String(0)
}

func (s *objectTypeStoreMock) TypeNames() []string {
	args := s.Called()
	return args.Get(0).([]string)
}

func (s *objectTypeStoreMock) RegisterType(id uint8, typ string) {}

func TestCloseHandle(t *testing.T) {
	objectTypeStore := new(objectTypeStoreMock)
	hsnapMock := new(handle.SnapshotterMock)
	devMapper := new(devMapperMock)
	deferredKevts := make(chan *kevent.Kevent, 1)

	kevt := &kevent.Kevent{
		Type:     ktypes.CloseHandle,
		Tid:      2484,
		PID:      859,
		Category: ktypes.Handle,
		Kparams: kevent.Kparams{
			kparams.HandleID:           {Name: kparams.HandleID, Type: kparams.Uint32, Value: uint32(21)},
			kparams.HandleObjectTypeID: {Name: kparams.HandleObjectTypeID, Type: kparams.Uint16, Value: uint16(23)},
			kparams.HandleObject:       {Name: kparams.HandleObject, Type: kparams.HexInt64, Value: kparams.Hex("ffffd105e9baaf70")},
			kparams.HandleObjectName:   {Name: kparams.HandleObjectName, Type: kparams.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`},
		},
	}

	hsnapMock.On("Remove", kevt).Return(nil)

	hi := newHandleInterceptor(hsnapMock, objectTypeStore, devMapper, deferredKevts)

	objectTypeStore.On("FindByID", uint8(23)).Return(handle.Key)

	assert.Len(t, hi.(*handleInterceptor).defers, 0)

	_, _, err := hi.Intercept(kevt)
	require.NoError(t, err)

	keyName, err := kevt.Kparams.GetString(kparams.HandleObjectName)
	require.NoError(t, err)
	typ, err := kevt.Kparams.GetString(kparams.HandleObjectTypeName)
	require.NoError(t, err)
	assert.Equal(t, handle.Key, typ)
	assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`, keyName)
}

func TestHandleCoalescing(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:     ktypes.CreateHandle,
		Tid:      2484,
		PID:      859,
		Category: ktypes.Handle,
		Kparams: kevent.Kparams{
			kparams.HandleID:           {Name: kparams.HandleID, Type: kparams.Uint32, Value: uint32(21)},
			kparams.HandleObjectTypeID: {Name: kparams.HandleObjectTypeID, Type: kparams.Uint16, Value: uint16(23)},
			kparams.HandleObject:       {Name: kparams.HandleObject, Type: kparams.HexInt64, Value: kparams.Hex("ffffd105e9baaf70")},
			kparams.HandleObjectName:   {Name: kparams.HandleObjectName, Type: kparams.UnicodeString, Value: ""},
		},
	}
	deferredKevts := make(chan *kevent.Kevent, 1)
	devMapper := new(devMapperMock)

	hsnapMock := new(handle.SnapshotterMock)
	objectTypeStore := new(objectTypeStoreMock)

	hsnapMock.On("Write", mock.Anything).Return(nil)
	hsnapMock.On("Remove", mock.Anything).Return(nil)

	hi := newHandleInterceptor(hsnapMock, objectTypeStore, devMapper, deferredKevts)

	objectTypeStore.On("FindByID", uint8(23)).Return(handle.Key)

	_, _, err := hi.Intercept(kevt)
	require.Error(t, err)
	require.True(t, kerrors.IsCancelUpstreamKevent(err))

	assert.Len(t, hi.(*handleInterceptor).defers, 1)

	kevt1 := &kevent.Kevent{
		Type:     ktypes.CloseHandle,
		Tid:      2484,
		PID:      859,
		Category: ktypes.Handle,
		Kparams: kevent.Kparams{
			kparams.HandleID:           {Name: kparams.HandleID, Type: kparams.Uint32, Value: uint32(21)},
			kparams.HandleObjectTypeID: {Name: kparams.HandleObjectTypeID, Type: kparams.Uint16, Value: uint16(23)},
			kparams.HandleObject:       {Name: kparams.HandleObject, Type: kparams.HexInt64, Value: kparams.Hex("ffffd105e9baaf70")},
			kparams.HandleObjectName:   {Name: kparams.HandleObjectName, Type: kparams.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`},
		},
	}

	ckevt, _, err := hi.Intercept(kevt1)
	require.NoError(t, err)

	keyName, err := ckevt.Kparams.GetString(kparams.HandleObjectName)
	require.NoError(t, err)
	assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`, keyName)

	assert.Len(t, hi.(*handleInterceptor).defers, 0)

	dkevt := <-deferredKevts
	require.NotNil(t, dkevt)

	assert.Equal(t, ktypes.CreateHandle, dkevt.Type)

	keyName, err = dkevt.Kparams.GetString(kparams.HandleObjectName)
	require.NoError(t, err)
	assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`, keyName)
}

func init() {
	waitPeriod = time.Millisecond * 500
}

func TestHandleCoalescingWaiting(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:      ktypes.CreateHandle,
		Tid:       2484,
		PID:       859,
		Timestamp: time.Now(),
		Category:  ktypes.Handle,
		Kparams: kevent.Kparams{
			kparams.HandleID:           {Name: kparams.HandleID, Type: kparams.Uint32, Value: uint32(21)},
			kparams.HandleObjectTypeID: {Name: kparams.HandleObjectTypeID, Type: kparams.Uint16, Value: uint16(23)},
			kparams.HandleObject:       {Name: kparams.HandleObject, Type: kparams.HexInt64, Value: kparams.Hex("ffffd105e9baaf70")},
			kparams.HandleObjectName:   {Name: kparams.HandleObjectName, Type: kparams.UnicodeString, Value: ""},
		},
	}

	deferredKevts := make(chan *kevent.Kevent, 1)

	devMapper := new(devMapperMock)
	objectTypeStore := new(objectTypeStoreMock)
	hsnapMock := new(handle.SnapshotterMock)

	hsnapMock.On("Write", mock.Anything).Return(nil)
	hsnapMock.On("Remove", mock.Anything).Return(nil)

	hi := newHandleInterceptor(hsnapMock, objectTypeStore, devMapper, deferredKevts)

	objectTypeStore.On("FindByID", uint8(23)).Return(handle.Key)

	_, _, err := hi.Intercept(kevt)
	require.Error(t, err)
	require.True(t, kerrors.IsCancelUpstreamKevent(err))

	assert.Len(t, hi.(*handleInterceptor).defers, 1)

	kevt1 := &kevent.Kevent{
		Type:     ktypes.CloseHandle,
		Tid:      2484,
		PID:      859,
		Category: ktypes.Handle,
		Kparams: kevent.Kparams{
			kparams.HandleID:           {Name: kparams.HandleID, Type: kparams.Uint32, Value: uint32(21)},
			kparams.HandleObjectTypeID: {Name: kparams.HandleObjectTypeID, Type: kparams.Uint16, Value: uint16(23)},
			kparams.HandleObject:       {Name: kparams.HandleObject, Type: kparams.HexInt64, Value: kparams.Hex("affdd155e9baaf70")},
			kparams.HandleObjectName:   {Name: kparams.HandleObjectName, Type: kparams.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`},
		},
	}

	time.Sleep(time.Millisecond * 510)

	_, _, err = hi.Intercept(kevt1)
	require.NoError(t, err)

	assert.Len(t, hi.(*handleInterceptor).defers, 0)
}

```

`pkg/kstream/interceptors/image_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"

	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/yara"
	log "github.com/sirupsen/logrus"
)

// imageYaraScans stores the total count of yara image scans
var imageYaraScans = expvar.NewInt("yara.image.scans")

type imageInterceptor struct {
	devMapper fs.DevMapper
	snap      ps.Snapshotter
	yara      yara.Scanner
}

func newImageInterceptor(snap ps.Snapshotter, devMapper fs.DevMapper, yara yara.Scanner) KstreamInterceptor {
	return &imageInterceptor{snap: snap, devMapper: devMapper, yara: yara}
}

func (imageInterceptor) Name() InterceptorType { return Image }

func (i *imageInterceptor) Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error) {
	if kevt.Type == ktypes.LoadImage || kevt.Type == ktypes.UnloadImage || kevt.Type == ktypes.EnumImage {
		// normalize image parameters to convert the size of hex to decimal representation
		// and replace the DOS image path to regular drive-based file path
		pid, err := kevt.Kparams.GetUint32(kparams.ProcessID)
		if err != nil {
			return kevt, true, err
		}
		if err := kevt.Kparams.Set(kparams.ProcessID, pid, kparams.PID); err != nil {
			return kevt, true, err
		}
		size, _ := kevt.Kparams.GetHexAsUint32(kparams.ImageSize)
		if err := kevt.Kparams.Set(kparams.ImageSize, size, kparams.Uint32); err != nil {
			return kevt, true, err
		}
		filename, _ := kevt.Kparams.GetString(kparams.ImageFilename)
		if err := kevt.Kparams.Set(kparams.ImageFilename, i.devMapper.Convert(filename), kparams.UnicodeString); err != nil {
			return kevt, true, err
		}
		if i.yara != nil && kevt.Type == ktypes.LoadImage {
			// scan the target filename
			go func() {
				imageYaraScans.Add(1)
				err := i.yara.ScanFile(filename, kevt)
				if err != nil {
					log.Warnf("unable to run yara scanner on %s image: %v", filename, err)
				}
			}()
		}
		if kevt.Type != ktypes.UnloadImage {
			return kevt, false, i.snap.Write(kevt)
		}
		return kevt, false, i.snap.Remove(kevt)
	}

	return kevt, true, nil
}

func (imageInterceptor) Close() {}

```

`pkg/kstream/interceptors/image_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

```

`pkg/kstream/interceptors/interceptor.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import "github.com/rabbitstack/fibratus/pkg/kevent"

// InterceptorType is an alias for the interceptor type
type InterceptorType uint8

const (
	// Ps represents the process interceptor.
	Ps InterceptorType = iota
	// Fs represents the file system interceptor.
	Fs
	// Registry represents the registry interceptor.
	Registry
	// Image represents the image interceptor.
	Image
	// Net represents the network interceptor.
	Net
	// Handle represents the handle interceptor.
	Handle
)

// KstreamInterceptor is the minimal interface that each kernel stream interceptor has to satisfy. Kernel stream interceptor
// has the ability to augment kernel event with additional parameters. It is also capable of building a state machine
// from the flow of kernel events going through it. The interceptor can also decide to drop the inbound kernel event by
// returning an error via its `Intercept` method.
type KstreamInterceptor interface {
	// Intercept receives an existing kernel event possibly mutating its state. The event is filtered out if
	// this method returns an error. If it returns true, the next interceptor in the chain is evaluated.
	Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error)

	// Name returns a human-readable name of this interceptor.
	Name() InterceptorType

	// Close closes the interceptor and disposes allocated resources.
	Close()
}

// String returns a human-friendly interceptor name.
func (typ InterceptorType) String() string {
	switch typ {
	case Ps:
		return "process"
	case Fs:
		return "file"
	case Registry:
		return "registry"
	case Image:
		return "image"
	case Net:
		return "net"
	case Handle:
		return "handle"
	default:
		return "unknown"
	}
}

```

`pkg/kstream/interceptors/net_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"net"
	"time"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/network"
	"github.com/rabbitstack/fibratus/pkg/util/ports"
)

var (
	remappedKtypes = map[ktypes.Ktype]ktypes.Ktype{
		ktypes.AcceptTCPv4:     ktypes.Accept,
		ktypes.AcceptTCPv6:     ktypes.Accept,
		ktypes.ConnectTCPv4:    ktypes.Connect,
		ktypes.ConnectTCPv6:    ktypes.Connect,
		ktypes.ReconnectTCPv4:  ktypes.Reconnect,
		ktypes.ReconnectTCPv6:  ktypes.Reconnect,
		ktypes.RetransmitTCPv4: ktypes.Retransmit,
		ktypes.RetransmitTCPv6: ktypes.Retransmit,
		ktypes.DisconnectTCPv4: ktypes.Disconnect,
		ktypes.DisconnectTCPv6: ktypes.Disconnect,
		ktypes.SendTCPv4:       ktypes.Send,
		ktypes.SendTCPv6:       ktypes.Send,
		ktypes.SendUDPv4:       ktypes.Send,
		ktypes.SendUDPv6:       ktypes.Send,
		ktypes.RecvTCPv4:       ktypes.Recv,
		ktypes.RecvTCPv6:       ktypes.Recv,
		ktypes.RecvUDPv4:       ktypes.Recv,
		ktypes.RecvUDPv6:       ktypes.Recv,
	}
)

type netInterceptor struct {
	reverseDNS *network.ReverseDNS
}

// newNetInterceptor creates a new instance of the network kernel stream interceptor.
func newNetInterceptor() KstreamInterceptor {
	return &netInterceptor{
		reverseDNS: network.NewReverseDNS(2000, time.Minute*30, time.Minute*2),
	}
}

func (netInterceptor) Name() InterceptorType {
	return Net
}

func (n netInterceptor) Close() {
	n.reverseDNS.Close()
}

// Intercept overrides the kernel event type according to the transport layer
// and/or IP protocol version. At this point we also append the port names for all
// network kernel events and perform reverse DNS lookups to obtain the domain names.
func (n *netInterceptor) Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error) {
	if kevt.Category == ktypes.Net {
		if kevt.IsNetworkTCP() {
			kevt.Kparams.Append(kparams.NetL4Proto, kparams.Enum, network.TCP)
		}
		if kevt.IsNetworkUDP() {
			kevt.Kparams.Append(kparams.NetL4Proto, kparams.Enum, network.UDP)
		}

		n.resolvePortName(kevt)

		names := n.resolveNamesForIP(unwrapIP(kevt.Kparams.GetIP(kparams.NetDIP)))
		if len(names) > 0 {
			kevt.Kparams.Append(kparams.NetDIPNames, kparams.Slice, names)
		}

		names = n.resolveNamesForIP(unwrapIP(kevt.Kparams.GetIP(kparams.NetSIP)))
		if len(names) > 0 {
			kevt.Kparams.Append(kparams.NetSIPNames, kparams.Slice, names)
		}

		return remapKtype(kevt), false, nil
	}
	return kevt, true, nil
}

func (n *netInterceptor) resolveNamesForIP(ip net.IP) []string {
	names, err := n.reverseDNS.Add(network.AddressFromIP(ip))
	if err != nil {
		return nil
	}
	return names
}

// resolvePortName resolves the IANA service name for the particular port and transport protocol as
// per https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.
func (n netInterceptor) resolvePortName(kevt *kevent.Kevent) *kevent.Kevent {
	dport := unwrapPort(kevt.Kparams.GetUint16(kparams.NetDport))
	sport := unwrapPort(kevt.Kparams.GetUint16(kparams.NetSport))

	if kevt.IsNetworkTCP() {
		if name, ok := ports.TCPPortNames[dport]; ok {
			kevt.Kparams.Append(kparams.NetDportName, kparams.AnsiString, name)
		}
		if name, ok := ports.TCPPortNames[sport]; ok {
			kevt.Kparams.Append(kparams.NetSportName, kparams.AnsiString, name)
		}
		return kevt
	}

	if name, ok := ports.UDPPortNames[dport]; ok {
		kevt.Kparams.Append(kparams.NetDportName, kparams.AnsiString, name)
	}
	if name, ok := ports.UDPPortNames[sport]; ok {
		kevt.Kparams.Append(kparams.NetSportName, kparams.AnsiString, name)
	}
	return kevt
}

func unwrapIP(ip net.IP, _ error) net.IP     { return ip }
func unwrapPort(port uint16, _ error) uint16 { return port }

func remapKtype(kevt *kevent.Kevent) *kevent.Kevent {
	ktyp, ok := remappedKtypes[kevt.Type]
	if !ok {
		return kevt
	}
	kevt.Type = ktyp
	return kevt
}

```

`pkg/kstream/interceptors/net_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/network"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestNetInterceptorSend(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:     ktypes.SendTCPv4,
		Tid:      2484,
		PID:      859,
		Category: ktypes.Net,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(443)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
	}
	ni := newNetInterceptor()

	_, _, err := ni.Intercept(kevt)
	require.NoError(t, err)

	assert.Equal(t, ktypes.Send, kevt.Type)

	assert.Contains(t, kevt.Kparams, kparams.NetDportName)
	dportName, err := kevt.Kparams.GetString(kparams.NetDportName)
	require.NoError(t, err)
	assert.Equal(t, "https", dportName)

	v, err := kevt.Kparams.Get(kparams.NetL4Proto)
	require.NoError(t, err)
	assert.IsType(t, network.L4Proto(1), v)
	assert.Equal(t, "tcp", v.(network.L4Proto).String())

	sip, err := kevt.Kparams.GetIPv4(kparams.NetSIP)
	require.NoError(t, err)
	assert.Equal(t, "127.0.0.1", sip.String())

	dip, err := kevt.Kparams.GetIPv4(kparams.NetDIP)
	require.NoError(t, err)
	assert.Equal(t, "216.58.201.174", dip.String())
}

func TestNetInterceptorReverseDNS(t *testing.T) {
	kevt := &kevent.Kevent{
		Type:     ktypes.SendTCPv4,
		Tid:      2484,
		PID:      859,
		Category: ktypes.Net,
		Kparams: kevent.Kparams{
			kparams.NetDport: {Name: kparams.NetDport, Type: kparams.Uint16, Value: uint16(53)},
			kparams.NetSport: {Name: kparams.NetSport, Type: kparams.Uint16, Value: uint16(43123)},
			kparams.NetSIP:   {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			kparams.NetDIP:   {Name: kparams.NetDIP, Type: kparams.IPv4, Value: net.ParseIP("8.8.8.8")},
		},
	}
	ni := newNetInterceptor()

	_, _, err := ni.Intercept(kevt)
	require.NoError(t, err)

	assert.Equal(t, ktypes.Send, kevt.Type)

	assert.Contains(t, kevt.Kparams, kparams.NetDIPNames)
	names, err := kevt.Kparams.GetStringSlice(kparams.NetDIPNames)
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
}

func TestNetInterceptorL4LayerProtocol(t *testing.T) {
	tests := []struct {
		typ      ktypes.Ktype
		protocol network.L4Proto
	}{
		{ktypes.ReconnectTCPv6, network.TCP},
		{ktypes.ReconnectTCPv4, network.TCP},
		{ktypes.AcceptTCPv6, network.TCP},
		{ktypes.AcceptTCPv4, network.TCP},
		{ktypes.RetransmitTCPv4, network.TCP},
		{ktypes.RetransmitTCPv6, network.TCP},
		{ktypes.DisconnectTCPv6, network.TCP},
		{ktypes.DisconnectTCPv4, network.TCP},
		{ktypes.SendTCPv4, network.TCP},
		{ktypes.SendTCPv6, network.TCP},
		{ktypes.RecvTCPv4, network.TCP},
		{ktypes.RecvTCPv6, network.TCP},
		{ktypes.RecvUDPv4, network.UDP},
		{ktypes.RecvUDPv6, network.UDP},
		{ktypes.SendUDPv4, network.UDP},
		{ktypes.SendUDPv6, network.UDP},
	}

	ni := newNetInterceptor()

	for i, tt := range tests {
		kevt := &kevent.Kevent{
			Type:     tt.typ,
			Tid:      2484,
			PID:      859,
			Category: ktypes.Net,
			Kparams: kevent.Kparams{
				kparams.NetSIP: {Name: kparams.NetSIP, Type: kparams.IPv4, Value: net.ParseIP("127.0.0.1")},
			},
		}
		kevt, _, err := ni.Intercept(kevt)
		require.NoError(t, err)

		v, err := kevt.Kparams.Get(kparams.NetL4Proto)
		require.NoError(t, err)
		assert.Equal(t, tt.protocol, v.(network.L4Proto), "#%d", i+1)
	}
}

```

`pkg/kstream/interceptors/ps_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/rabbitstack/fibratus/pkg/syscall/thread"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/rabbitstack/fibratus/pkg/yara"
	log "github.com/sirupsen/logrus"
)

// systemRootRegexp is the regular expression for detecting path with unexpanded SystemRoot environment variable
var systemRootRegexp = regexp.MustCompile(`%SystemRoot%|^\\SystemRoot|%systemroot%`)

// driveRegexp is used for determining if the command line start with a valid drive letter based path
var driveRegexp = regexp.MustCompile(`^[a-zA-Z]:\\`)

// procYaraScans stores the total count of yara process scans
var procYaraScans = expvar.NewInt("yara.proc.scans")

type psInterceptor struct {
	snap ps.Snapshotter
	yara yara.Scanner
}

var sysProcs = map[string]bool{
	"dwm.exe":         true,
	"wininit.exe":     true,
	"winlogon.exe":    true,
	"fontdrvhost.exe": true,
	"sihost.exe":      true,
	"taskhostw.exe":   true,
	"dashost.exe":     true,
	"ctfmon.exe":      true,
	"svchost.exe":     true,
	"csrss.exe":       true,
	"services.exe":    true,
	"audiodg.exe":     true,
	"kernel32.dll":    true,
}

// newPsInterceptor creates a new kstream interceptor for process events.
func newPsInterceptor(snap ps.Snapshotter, yara yara.Scanner) KstreamInterceptor {
	return psInterceptor{snap: snap, yara: yara}
}

func (ps psInterceptor) Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error) {
	switch kevt.Type {
	case ktypes.CreateProcess,
		ktypes.TerminateProcess,
		ktypes.EnumProcess:
		cmdline, err := kevt.Kparams.GetString(kparams.Comm)
		if err != nil {
			return kevt, true, err
		}
		// if leading/trailing quotes are found, get rid of them
		if len(cmdline) > 0 && cmdline[0] == '"' && cmdline[len(cmdline)-1] == '"' {
			cmdline = cmdline[1 : len(cmdline)-1]
		}
		// expand all variations of the SystemRoot env variable
		if systemRootRegexp.MatchString(cmdline) {
			cmdline = systemRootRegexp.ReplaceAllString(cmdline, os.Getenv("SystemRoot"))
		}
		// some system processes are reported without the path in the command line,
		// but we can expand the path from the SystemRoot environment variable
		if !driveRegexp.MatchString(cmdline) {
			proc, _ := kevt.Kparams.GetString(kparams.ProcessName)
			_, ok := sysProcs[proc]
			if ok {
				cmdline = filepath.Join(os.Getenv("SystemRoot"), "System32", cmdline)
			}
		}
		// append executable path parameter
		i := strings.Index(strings.ToLower(cmdline), ".exe")
		if i > 0 {
			exe := cmdline[0 : i+4]
			kevt.Kparams.Append(kparams.Exe, kparams.UnicodeString, exe)
		}
		_ = kevt.Kparams.SetValue(kparams.Comm, cmdline)

		// convert hexadecimal PID values to integers
		pid, err := kevt.Kparams.GetHexAsUint32(kparams.ProcessID)
		if err != nil {
			return kevt, true, err
		}
		if err := kevt.Kparams.Set(kparams.ProcessID, pid, kparams.PID); err != nil {
			return kevt, true, err
		}
		ppid, err := kevt.Kparams.GetHexAsUint32(kparams.ProcessParentID)
		if err != nil {
			return kevt, true, err
		}
		if err := kevt.Kparams.Set(kparams.ProcessParentID, ppid, kparams.PID); err != nil {
			return kevt, true, err
		}

		if kevt.Type != ktypes.TerminateProcess {
			if pid != 0 {
				// get the process's start time and append it to the parameters
				started, err := getStartTime(pid)
				if err != nil {
					started = kevt.Timestamp
				}
				_ = kevt.Kparams.Append(kparams.StartTime, kparams.Time, started)
			}
			if ps.yara != nil && kevt.Type == ktypes.CreateProcess {
				// run yara scanner on the target process
				go func() {
					procYaraScans.Add(1)
					err := ps.yara.ScanProc(pid, kevt)
					if err != nil {
						log.Warnf("unable to run yara scanner on pid %d: %v", pid, err)
					}
				}()
			}
			return kevt, false, ps.snap.Write(kevt)
		}
		return kevt, false, ps.snap.Remove(kevt)
	case ktypes.CreateThread,
		ktypes.TerminateThread,
		ktypes.EnumThread:
		pid, err := kevt.Kparams.GetHexAsUint32(kparams.ProcessID)
		if err != nil {
			return kevt, true, err
		}
		if err := kevt.Kparams.Set(kparams.ProcessID, pid, kparams.PID); err != nil {
			return kevt, true, err
		}
		tid, err := kevt.Kparams.GetHexAsUint32(kparams.ThreadID)
		if err != nil {
			return kevt, true, err
		}
		if err := kevt.Kparams.Set(kparams.ThreadID, tid, kparams.TID); err != nil {
			return kevt, true, err
		}
		if kevt.Type != ktypes.TerminateThread {
			return kevt, false, ps.snap.Write(kevt)
		}
		return kevt, false, ps.snap.Remove(kevt)
	case ktypes.OpenProcess,
		ktypes.OpenThread:
		pid, err := kevt.Kparams.GetUint32(kparams.ProcessID)
		if err != nil {
			return kevt, true, err
		}

		proc := ps.snap.Find(pid)
		if proc != nil {
			kevt.Kparams.Append(kparams.Exe, kparams.UnicodeString, proc.Exe).
				Append(kparams.ProcessName, kparams.UnicodeString, proc.Name)
		}
		_ = kevt.Kparams.Set(kparams.ProcessID, pid, kparams.PID)

		// format the status code
		status := kevt.Kparams.MustGetUint32(kparams.NTStatus)
		_ = kevt.Kparams.Set(kparams.NTStatus, formatStatus(status, kevt), kparams.UnicodeString)

		// convert desired access mask to hex value and transform
		// the access mask to a list of symbolical names
		access := kevt.Kparams.MustGetUint32(kparams.DesiredAccess)
		_ = kevt.Kparams.Set(kparams.DesiredAccess, toHex(access), kparams.AnsiString)

		if kevt.Type == ktypes.OpenProcess {
			kevt.Kparams.Append(kparams.DesiredAccessNames, kparams.Slice, process.DesiredAccess(access).Flags())
		} else {
			kevt.Kparams.Append(kparams.DesiredAccessNames, kparams.Slice, thread.DesiredAccess(access).Flags())
		}
		return kevt, false, nil
	}
	return kevt, true, nil
}

func (psInterceptor) Name() InterceptorType { return Ps }

func (ps psInterceptor) Close() {
	if ps.yara != nil {
		ps.yara.Close()
	}
}

func getStartTime(pid uint32) (time.Time, error) {
	handle, err := process.Open(process.QueryLimitedInformation, false, pid)
	if err != nil {
		return time.Now(), err
	}
	defer handle.Close()
	started, err := process.GetStartTime(handle)
	if err != nil {
		return time.Now(), err
	}
	return started, nil
}

func toHex(desiredAccess uint32) string { return "0x" + strconv.FormatInt(int64(desiredAccess), 16) }

```

`pkg/kstream/interceptors/ps_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
)

func TestPsInterceptorIntercept(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	psi := newPsInterceptor(psnap, nil)

	kpars := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.HexInt32, Value: kparams.Hex("36c")},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.HexInt32, Value: kparams.Hex("26c")},
	}

	kevt := &kevent.Kevent{
		Type:    ktypes.CreateProcess,
		Kparams: kpars,
	}
	_, _, err := psi.Intercept(kevt)
	require.NoError(t, err)

	require.True(t, kevt.Kparams.Contains(kparams.Exe))
	exe, _ := kevt.Kparams.GetString(kparams.Exe)
	assert.Equal(t, "C:\\Windows\\system32\\svchost.exe", exe)
	pid, _ := kpars.GetPid()
	assert.Equal(t, uint32(876), pid)
	ppid, _ := kpars.GetPpid()
	assert.Equal(t, uint32(620), ppid)

	kpars1 := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "C:\\Windows\\System32\\smss.exe"},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.HexInt32, Value: kparams.Hex("36c")},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.HexInt32, Value: kparams.Hex("26c")},
	}

	kevt1 := &kevent.Kevent{
		Type:    ktypes.EnumProcess,
		Kparams: kpars1,
	}
	err = os.Setenv("SystemRoot", "C:\\Windows")
	if err != nil {
		t.Fatal(err)
	}
	_, _, err = psi.Intercept(kevt1)
	require.NoError(t, err)
	exe, _ = kpars1.GetString(kparams.Exe)
	assert.Equal(t, "C:\\Windows\\System32\\smss.exe", exe)

	tpid := fmt.Sprintf("%x", os.Getpid())

	kpars2 := kevent.Kparams{
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "\"C:\\Windows\\System32\\smss.exe\""},
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.HexInt32, Value: kparams.Hex(tpid)},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.HexInt32, Value: kparams.Hex("26c")},
	}

	kevt2 := &kevent.Kevent{
		Type:    ktypes.CreateProcess,
		Kparams: kpars2,
	}
	_, _, err = psi.Intercept(kevt2)
	require.NoError(t, err)

	require.True(t, kevt2.Kparams.Contains(kparams.StartTime))

	cmdline, _ := kevt2.Kparams.GetString(kparams.Comm)
	require.Equal(t, "C:\\Windows\\System32\\smss.exe", cmdline)

	kpars3 := kevent.Kparams{
		kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.HexInt32, Value: kparams.Hex(tpid)},
		kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.HexInt32, Value: kparams.Hex("26c")},
		kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: "csrss.exe"},
		kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "csrss.exe"},
	}

	kevt3 := &kevent.Kevent{
		Type:    ktypes.CreateProcess,
		Kparams: kpars3,
	}

	_, _, err = psi.Intercept(kevt3)
	require.NoError(t, err)
	cmdline1, _ := kevt3.Kparams.GetString(kparams.Comm)
	require.Equal(t, "C:\\Windows\\System32\\csrss.exe", cmdline1)
}

```

`pkg/kstream/interceptors/registry_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"expvar"
	"path/filepath"
	"strings"
	"sync/atomic"
	"time"

	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/syscall/registry"
	reg "golang.org/x/sys/windows/registry"
)

var (
	// kcbCount counts the total KCBs found during the duration of the kernel session
	kcbCount         = expvar.NewInt("registry.kcb.count")
	kcbMissCount     = expvar.NewInt("registry.kcb.misses")
	unknownKeysCount = expvar.NewInt("registry.unknown.keys.count")
	keyHandleHits    = expvar.NewInt("registry.key.handle.hits")

	handleThrottleCount uint32
)

const (
	maxHandleQueries = 200
)

type registryInterceptor struct {
	// keys stores the mapping between the KCB (Key Control Block) and the key name.
	keys  map[uint64]string
	hsnap handle.Snapshotter
}

func newRegistryInterceptor(hsnap handle.Snapshotter) KstreamInterceptor {
	// schedule a ticker that resets the throttle count every minute
	tick := time.NewTicker(time.Minute)
	go func() {
		for {
			<-tick.C
			atomic.StoreUint32(&handleThrottleCount, 0)
		}
	}()
	return &registryInterceptor{
		keys:  make(map[uint64]string),
		hsnap: hsnap,
	}
}

func (r *registryInterceptor) Intercept(kevt *kevent.Kevent) (*kevent.Kevent, bool, error) {
	typ := kevt.Type
	switch typ {
	case ktypes.RegKCBRundown, ktypes.RegCreateKCB:
		khandle, err := kevt.Kparams.TryGetHexAsUint64(kparams.RegKeyHandle)
		if err != nil {
			return kevt, true, err
		}
		if _, ok := r.keys[khandle]; !ok {
			r.keys[khandle], _ = kevt.Kparams.GetString(kparams.RegKeyName)
		}
		kcbCount.Add(1)
		return kevt, false, nil
	case ktypes.RegDeleteKCB:
		khandle, err := kevt.Kparams.TryGetHexAsUint64(kparams.RegKeyHandle)
		if err != nil {
			return kevt, true, err
		}
		delete(r.keys, khandle)
		kcbCount.Add(-1)
		return kevt, false, nil
	case ktypes.RegCreateKey,
		ktypes.RegDeleteKey,
		ktypes.RegOpenKey, ktypes.RegOpenKeyV1,
		ktypes.RegQueryKey,
		ktypes.RegQueryValue,
		ktypes.RegSetValue,
		ktypes.RegDeleteValue:
		khandle, err := kevt.Kparams.TryGetHexAsUint64(kparams.RegKeyHandle)
		if err != nil {
			return kevt, true, err
		}
		// we have to obey a straightforward algorithm to connect relative
		// key names to their root keys. If key handle is equal to zero we
		// have a full key name and don't have to go further resolving the
		// missing part. Otherwise, we have to lookup existing KCBs to try
		// find the matching base key name and concatenate to its relative
		// path. If none of the aforementioned checks are successful, our
		// last resort is to scan process' handles and check if any of the
		// key handles contain the partial key name. In this case we assume
		// the correct key is encountered.
		var rootKey registry.Key
		keyName, err := kevt.Kparams.GetString(kparams.RegKeyName)
		if err != nil {
			return kevt, true, err
		}
		if khandle != 0 {
			if baseKey, ok := r.keys[khandle]; ok {
				keyName = baseKey + "\\" + keyName
			} else {
				kcbMissCount.Add(1)
				keyName = r.findMatchingKey(kevt.PID, keyName)
			}
		}

		if keyName != "" {
			rootKey, keyName = handle.FormatKey(keyName)
			k := rootKey.String()
			if keyName != "" && rootKey != registry.InvalidKey {
				k += "\\" + keyName
			}
			if rootKey == registry.InvalidKey {
				unknownKeysCount.Add(1)
				k = keyName
			}
			if err := kevt.Kparams.Set(kparams.RegKeyName, k, kparams.UnicodeString); err != nil {
				return kevt, true, err
			}
		}

		// format registry operation status code
		status, err := kevt.Kparams.GetUint32(kparams.NTStatus)
		if err == nil {
			_ = kevt.Kparams.Set(kparams.NTStatus, formatStatus(status, kevt), kparams.UnicodeString)
		}

		// get the type/value of the registry key and append to parameters
		if typ == ktypes.RegSetValue {
			if rootKey != registry.InvalidKey {
				subkey, value := filepath.Split(keyName)
				key, err := reg.OpenKey(reg.Key(rootKey), subkey, reg.QUERY_VALUE)
				if err != nil {
					return kevt, true, nil
				}
				defer key.Close()
				b := make([]byte, 0)
				_, typ, err := key.GetValue(value, b)
				if err != nil {
					return kevt, true, nil
				}
				kevt.Kparams.Append(kparams.RegValueType, kparams.AnsiString, typToString(typ))
				switch typ {
				case reg.SZ, reg.EXPAND_SZ:
					v, _, err := key.GetStringValue(value)
					if err != nil {
						return kevt, true, nil
					}
					kevt.Kparams.Append(kparams.RegValue, kparams.UnicodeString, v)

				case reg.DWORD, reg.QWORD:
					v, _, err := key.GetIntegerValue(value)
					if err != nil {
						return kevt, true, nil
					}
					kevt.Kparams.Append(kparams.RegValue, kparams.Uint64, v)

				case reg.MULTI_SZ:
					v, _, err := key.GetStringsValue(value)
					if err != nil {
						return kevt, true, nil
					}
					kevt.Kparams.Append(kparams.RegValue, kparams.UnicodeString, strings.Join(v, "\n\r"))

				case reg.BINARY:
					v, _, err := key.GetBinaryValue(value)
					if err != nil {
						return kevt, true, nil
					}
					kevt.Kparams.Append(kparams.RegValue, kparams.UnicodeString, string(v))
				}
				return kevt, false, nil
			}
		}
	}

	return kevt, true, nil
}

func (registryInterceptor) Name() InterceptorType { return Registry }
func (registryInterceptor) Close()                {}

func typToString(typ uint32) string {
	switch typ {
	case reg.DWORD:
		return "REG_DWORD"
	case reg.QWORD:
		return "REG_QWORD"
	case reg.SZ:
		return "REG_SZ"
	case reg.EXPAND_SZ:
		return "REG_EXPAND_SZ"
	case reg.MULTI_SZ:
		return "REG_MULTI_SZ"
	case reg.BINARY:
		return "REG_BINARY"
	default:
		return "UNKNOWN"
	}
}

func (r *registryInterceptor) findMatchingKey(pid uint32, relativeKeyName string) string {
	// we want to prevent too frequent queries on the process' handles
	// since that can cause significant performance overhead. When throttle
	// count is greater than the max permitted value we'll just return the partial key
	// and hold on querying the handles of target process
	atomic.AddUint32(&handleThrottleCount, 1)
	if handleThrottleCount > maxHandleQueries {
		return relativeKeyName
	}
	handles, err := r.hsnap.FindHandles(pid)
	if err != nil {
		return relativeKeyName
	}
	for _, h := range handles {
		if h.Type != handle.Key {
			continue
		}
		if strings.HasSuffix(h.Name, relativeKeyName) {
			keyHandleHits.Add(1)
			return h.Name
		}
	}
	return relativeKeyName
}

```

`pkg/kstream/interceptors/registry_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestRegistryInterceptor(t *testing.T) {
	r := newRegistryInterceptor(nil)

	_, _, err := r.Intercept(&kevent.Kevent{
		Type: ktypes.RegKCBRundown,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.RegKeyName:   {Name: kparams.RegKeyName, Type: kparams.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`},
			kparams.RegKeyHandle: {Name: kparams.RegKeyHandle, Type: kparams.HexInt64, Value: kparams.NewHex(uint64(18446666033549154696))},
		},
	})
	require.NoError(t, err)
	assert.Equal(t, int64(1), kcbCount.Value())

	_, _, err = r.Intercept(&kevent.Kevent{
		Type: ktypes.RegCreateKCB,
		Tid:  1484,
		PID:  259,
		Kparams: kevent.Kparams{
			kparams.RegKeyName:   {Name: kparams.RegKeyName, Type: kparams.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\Setup`},
			kparams.RegKeyHandle: {Name: kparams.RegKeyHandle, Type: kparams.HexInt64, Value: kparams.NewHex(uint64(18446666033449935464))},
		},
	})
	require.NoError(t, err)
	assert.Equal(t, int64(2), kcbCount.Value())

	kevt := &kevent.Kevent{
		Type: ktypes.RegCreateKey,
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.RegKeyName:   {Name: kparams.RegKeyName, Type: kparams.UnicodeString, Value: `Pid`},
			kparams.RegKeyHandle: {Name: kparams.RegKeyHandle, Type: kparams.HexInt64, Value: kparams.NewHex(uint64(18446666033449935464))},
		},
	}
	_, _, err = r.Intercept(kevt)
	require.NoError(t, err)

	keyName, err := kevt.Kparams.GetString(kparams.RegKeyName)
	require.NoError(t, err)
	assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`, keyName)
}

```

`pkg/kstream/interceptors/util.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package interceptors

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"strings"
	"sync"
	"syscall"
	"unicode/utf16"

	"github.com/rabbitstack/fibratus/pkg/syscall/sys"
	"golang.org/x/sys/windows"
)

// statusCache keeps the mappings of formatted NT status messages
var statusCache = map[uint32]string{}
var mux sync.Mutex

const (
	successStatusMessage      = "success"
	keyNotFoundStatusMessage  = "key not found"
	fileNotFoundStatusMessage = "file not found"
	unknownStatusMessage      = "unknown"

	notFoundNTStatus = 3221225524
)

func formatStatus(status uint32, kevt *kevent.Kevent) string {
	if status == 0 {
		return successStatusMessage
	}
	// this status code is return quite often, so we can offload the FormatMessage call
	if status == notFoundNTStatus {
		switch kevt.Category {
		case ktypes.Registry:
			return keyNotFoundStatusMessage
		case ktypes.File:
			return fileNotFoundStatusMessage
		}
	}
	// pick resolved status
	mux.Lock()
	defer mux.Unlock()
	if s, ok := statusCache[status]; ok {
		return s
	}
	var flags uint32 = syscall.FORMAT_MESSAGE_FROM_SYSTEM
	b := make([]uint16, 300)
	n, err := windows.FormatMessage(flags, 0, sys.CodeFromNtStatus(status), 0, b, nil)
	if err != nil {
		return unknownStatusMessage
	}
	// trim terminating \r and \n
	for ; n > 0 && (b[n-1] == '\n' || b[n-1] == '\r'); n-- {
	}

	s := strings.ToLower(string(utf16.Decode(b[:n])))
	statusCache[status] = s

	return s
}

```

`pkg/kstream/kstreamc_linux.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kstream

```

`pkg/kstream/kstreamc_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kstream

import (
	"errors"
	"expvar"
	"fmt"
	"os"
	"sync"
	"syscall"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/kstream/interceptors"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/syscall/etw"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/rabbitstack/fibratus/pkg/syscall/tdh"
	"github.com/rabbitstack/fibratus/pkg/syscall/thread"
	"github.com/rabbitstack/fibratus/pkg/syscall/utf16"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	"github.com/rabbitstack/fibratus/pkg/util/filetime"
	log "github.com/sirupsen/logrus"
)

const (
	// callbackNext is the return callback value which designates that callback execution should progress
	callbackNext = uintptr(1)
	// evtBufferSize determines the default buffer size in kilobytes for the`TraceEventInfo` structure
	evtBufferSize = uint32(4096)
)

var (
	// failedKevents counts the number of kevents that failed to process
	failedKevents                = expvar.NewMap("kstream.kevents.failures")
	failedKeventsByMissingSchema = expvar.NewMap("kstream.kevents.missing.schema.errors")
	// keventsEnqueued counts the number of events that are pushed to the queue
	keventsEnqueued = expvar.NewInt("kstream.kevents.enqueued")
	// failedKparams counts the number of kernel event parameters that failed to process
	failedKparams = expvar.NewInt("kstream.kevent.param.failures")

	// excludedKevents counts the number of excluded events
	excludedKevents = expvar.NewInt("kstream.excluded.kevents")
	// excludedProcs counts the number of excluded events by image name
	excludedProcs = expvar.NewInt("kstream.excluded.procs")

	// upstreamCancellations counts the event cancellations in interceptors
	upstreamCancellations = expvar.NewInt("kstream.upstream.cancellations")

	// buffersRead amount of buffers fetched from the ETW session
	buffersRead = expvar.NewInt("kstream.kbuffers.read")
)

var (
	openTrace       = etw.OpenTrace
	processTrace    = etw.ProcessTrace
	getPropertySize = tdh.GetPropertySize
	getProperty     = tdh.GetProperty

	currentPid = uint32(os.Getpid())
)

// EventCallbackFunc is the type alias for the event callback function
type EventCallbackFunc func(*kevent.Kevent) error

// Consumer is the interface for the kernel event stream consumer.
type Consumer interface {
	// OpenKstream initializes the kernel event stream by setting the event record callback and instructing it
	// to consume events from log buffers. This operation can fail if opening the kernel logger session results
	// in an invalid trace handler. Errors returned by `ProcessTrace` are sent to the channel since this function
	// blocks the current thread and we schedule its execution in a separate goroutine.
	OpenKstream(traces map[string]TraceSession) error
	// CloseKstream shutdowns the currently running kernel event stream consumer by closing the corresponding
	// session.
	CloseKstream() error
	// Errors returns the channel where errors are pushed.
	Errors() chan error
	// Events returns the buffered channel for pulling collected kernel events.
	Events() chan *kevent.Kevent
	// SetFilter initializes the filter that's applied on the kernel events.
	SetFilter(filter.Filter)
	// SetEventCallback registers a callback function that is invoked for
	// each incoming event. If the callback function is set up, the events
	// channel doesn't receive any inbound events.
	SetEventCallback(EventCallbackFunc)
}

type kstreamConsumer struct {
	traceHandles []etw.TraceHandle // trace session handles

	errs  chan error          // channel for event processing errors
	kevts chan *kevent.Kevent // channel for fanning out generated events

	interceptorChain interceptors.Chain
	config           *config.Config // main configuration

	ktraceController KtraceController  // trace session control plane
	psnapshotter     ps.Snapshotter    // process state tracker
	sequencer        *kevent.Sequencer // event sequence manager

	filter filter.Filter
	rules  filter.Rules

	capture bool // capture determines whether the event capture is triggered

	eventCallback EventCallbackFunc // called on each incoming event
}

func (k *kstreamConsumer) addTraceHandle(traceHandle etw.TraceHandle) {
	k.traceHandles = append(k.traceHandles, traceHandle)
}

// NewConsumer constructs a new kernel event stream consumer.
func NewConsumer(ktraceController KtraceController, psnap ps.Snapshotter, hsnap handle.Snapshotter, config *config.Config) Consumer {
	kconsumer := &kstreamConsumer{
		errs:             make(chan error, 1000),
		config:           config,
		psnapshotter:     psnap,
		ktraceController: ktraceController,
		capture:          config.KcapFile != "",
		sequencer:        kevent.NewSequencer(),
		kevts:            make(chan *kevent.Kevent, 500),
		rules:            filter.NewRules(config),
	}

	kconsumer.interceptorChain = interceptors.NewChain(psnap, hsnap, config, kconsumer.enqueueKevent)

	return kconsumer
}

// SetFilter initializes the filter that's applied on the kernel events.
func (k *kstreamConsumer) SetFilter(filter filter.Filter) { k.filter = filter }

// OpenKstream initializes the kernel event stream by setting the event record callback and instructing it
// to consume events from log buffers. This operation can fail if opening the kernel logger session results
// in an invalid trace handler. Errors returned by `ProcessTrace` are sent to the channel since this function
// blocks the current thread, and we schedule its execution in a separate goroutine.
func (k *kstreamConsumer) OpenKstream(traces map[string]TraceSession) error {
	err := k.rules.Compile()
	if err != nil {
		return err
	}
	for _, trace := range traces {
		err := k.openKstream(trace.Name)
		if err != nil {
			if trace.IsKernelLogger() {
				return err
			}
			log.Warnf("unable to open %s trace: %v", trace.Name, err)
		}
	}
	return nil
}

func (k *kstreamConsumer) openKstream(loggerName string) error {
	ktrace := etw.EventTraceLogfile{
		LoggerName:     utf16.StringToUTF16Ptr(loggerName),
		BufferCallback: syscall.NewCallback(k.bufferStatsCallback),
	}
	cb := syscall.NewCallback(k.processKeventCallback)
	modes := uint32(etw.ProcessTraceModeRealtime | etw.ProcessTraceModeEventRecord)
	// initialize real time trace mode and event callback functions
	// via these nasty pointer accesses to unions inside the structure
	*(*uint32)(unsafe.Pointer(&ktrace.LogFileMode[0])) = modes
	*(*uintptr)(unsafe.Pointer(&ktrace.EventCallback[4])) = cb

	traceHandle := openTrace(ktrace)
	if uint64(traceHandle) == winerrno.InvalidProcessTraceHandle {
		return fmt.Errorf("unable to open kernel trace: %v", syscall.GetLastError())
	}
	k.addTraceHandle(traceHandle)
	// since `ProcessTrace` blocks the current thread
	// we invoke it in a separate goroutine but send
	// any possible errors to the channel
	go func() {
		err := processTrace(traceHandle)
		log.Infof("stopping kernel trace processing for [%s]", loggerName)
		if err == nil {
			log.Infof("kernel trace processing successfully stopped for [%s]", loggerName)
			return
		}
		switch err {
		case kerrors.ErrTraceCancelled:
			if uint64(traceHandle) != winerrno.InvalidProcessTraceHandle {
				if err := etw.CloseTrace(traceHandle); err != nil {
					k.errs <- err
				}
			}
		default:
			k.errs <- err
		}
	}()

	return nil
}

// CloseKstream shutdowns the event stream consumer by closing all running traces.
func (k *kstreamConsumer) CloseKstream() error {
	for _, h := range k.traceHandles {
		if err := etw.CloseTrace(h); err != nil {
			log.Warn(err)
		}
	}

	if err := k.sequencer.Store(); err != nil {
		log.Warn(err)
	}
	if err := k.sequencer.Close(); err != nil {
		log.Warn(err)
	}

	return k.interceptorChain.Close()
}

// Errors returns a channel where errors are pushed.
func (k *kstreamConsumer) Errors() chan error {
	return k.errs
}

// Events returns the buffered channel for pulling collected kernel events.
func (k *kstreamConsumer) Events() chan *kevent.Kevent {
	return k.kevts
}

// SetEventCallback sets the event callback to receive inbound events.
func (k *kstreamConsumer) SetEventCallback(f EventCallbackFunc) {
	k.eventCallback = f
}

// bufferStatsCallback is periodically triggered by ETW subsystem for the purpose of reporting
// buffer statistics, such as the number of buffers processed.
func (k *kstreamConsumer) bufferStatsCallback(logfile *etw.EventTraceLogfile) uintptr {
	buffersRead.Add(int64(logfile.BuffersRead))
	return callbackNext
}

// processKeventCallback is the event callback function signature that delegates event processing
// to `processKevent`.
func (k *kstreamConsumer) processKeventCallback(evt *etw.EventRecord) uintptr {
	if err := k.processKevent(evt); err != nil {
		failedKevents.Add(err.Error(), 1)
		k.errs <- err
	}
	return callbackNext
}

// processKevent is the backbone of the kernel stream consumer.
// It does the heavy lifting of parsing inbound ETW events,
// iterating through event properties or raw parsing them and
// pushing kernel events to the channel.
func (k *kstreamConsumer) processKevent(evt *etw.EventRecord) error {
	var (
		pid   = evt.Header.ProcessID
		tid   = evt.Header.ThreadID
		ktype ktypes.Ktype
		// get the CPU core on which the event was generated
		cpu = *(*uint8)(unsafe.Pointer(&evt.BufferContext.ProcessorIndex[0]))
	)

	// obtain the ktype from provider GUID + event type that varies
	// across different provider types. For the NT Kernel Logger provider
	// this is the `Opcode` field, while other providers utilize the `ID`
	// field to transport the event type value
	switch evt.Header.ProviderID {
	case etw.KernelAuditAPICallsGUID:
		ktype = ktypes.Pack(evt.Header.ProviderID, uint8(evt.Header.EventDescriptor.ID))
	default:
		ktype = ktypes.Pack(evt.Header.ProviderID, evt.Header.EventDescriptor.Opcode)
	}

	if !ktype.Exists() {
		return nil
	}
	if k.config.Kstream.ExcludeImage(k.psnapshotter.Find(pid)) {
		excludedProcs.Add(1)
		return nil
	}

	// parse event parameters. Raw event parsing is preferred
	// over TDH (Trace Data Helper) API as it leverages huge
	// performance gains. However, we permit falling back to
	// TDH parsing if raw param parsing is not enabled in the
	// config options
	var kpars kevent.Kparams
	if k.config.Kstream.RawEventParsing {
		kpars = k.produceRawParams(ktype, evt)
	} else {
		trace, err := getTraceInfo(ktype, evt)
		if err != nil {
			return err
		}
		kpars = k.produceParams(ktype, evt, trace)
	}

	timestamp := filetime.ToEpoch(evt.Header.Timestamp)

	switch ktype.Category() {
	case ktypes.Image:
		// sometimes the pid present in event header is invalid
		// but, we can get the valid one from the event parameters
		if pid == winerrno.InvalidPID {
			pid, _ = kpars.GetUint32(kparams.ProcessID)
		}
	case ktypes.File:
		// on some Windows versions the value of
		// the PID attribute is invalid for the
		// file system kernel events
		if pid == winerrno.InvalidPID {
			// try to resolve a valid pid from thread ID
			threadID, err := kpars.GetHexAsUint32(kparams.ThreadID)
			if err != nil {
				break
			}
			h, err := thread.Open(thread.QueryLimitedInformation, false, threadID)
			if err != nil {
				break
			}
			defer h.Close()
			pid, err = process.GetPIDFromThread(h)
			if err != nil {
				log.Debugf("unable to get the pid from thread ID %d: %v", threadID, err)
			}
		}
		if pid != winerrno.InvalidPID {
			kpars.Append(kparams.ProcessID, kparams.PID, pid)
		}
	case ktypes.Process:
		// process start events may be logged in the context of the parent or child process.
		// As a result, the ProcessId member of EVENT_TRACE_HEADER may not correspond to the
		// process being created, so we set the event pid to be the one of the parent process
		if ktype == ktypes.CreateProcess {
			pid, _ = kpars.GetHexAsUint32(kparams.ProcessParentID)
		}
	case ktypes.Net:
		pid, _ = kpars.GetUint32(kparams.ProcessID)
		kpars.Remove(kparams.ProcessID)
	}

	// try to drop excluded processes after pid readjustment
	proc := k.psnapshotter.Find(pid)
	if k.config.Kstream.ExcludeImage(proc) {
		excludedProcs.Add(1)
		return nil
	}

	// build a new kernel event with all required fields. Kevent is the fundamental data structure
	// for propagating events to outputs sinks.
	kevt := kevent.New(
		k.sequencer.Get(),
		pid,
		tid,
		cpu,
		ktype,
		timestamp,
		kpars,
	)

	// dispatch each event to the interceptor chain that will further augment the kernel
	// event with useful fields, route events to corresponding snapshotters or initialize
	// open files/registry control blocks at the beginning of the kernel trace session
	kevt, err := k.interceptorChain.Dispatch(kevt)
	if err != nil {
		if kerrors.IsCancelUpstreamKevent(err) {
			upstreamCancellations.Add(1)
			return nil
		}
		log.Errorf("interceptor chain error(s) occurred: %v", err)
	}

	// associate process' state with the kernel event. We only override the process'
	// state if it hasn't been set previously like in the situation where captures
	// are being taken. The kernel events that construct the process' snapshot also
	// have attached process state, so simply by replaying the flow of these events
	// we are able to reconstruct system-wide process state.
	if kevt.PS == nil {
		kevt.PS = proc
	}
	if k.isKeventDropped(kevt) {
		kevt.Release()
		return nil
	}
	// run rules. In case of rule groups with sequence policy
	// the last event matching the group is forwarded to the
	// outputs
	if rulesFired := k.rules.Fire(kevt); !rulesFired {
		return nil
	}
	// increment sequence
	if !kevt.Type.Dropped(false) {
		k.sequencer.Increment()
	}
	if k.eventCallback != nil {
		return k.eventCallback(kevt)
	}

	k.kevts <- kevt
	keventsEnqueued.Add(1)

	return nil
}

// enqueueKevent is the callback method invoked on deferred event arrival.
func (k *kstreamConsumer) enqueueKevent(kevt *kevent.Kevent) error {
	if kevt.PS == nil {
		kevt.PS = k.psnapshotter.Find(kevt.PID)
	}
	if k.config.Kstream.ExcludeImage(kevt.PS) {
		excludedProcs.Add(1)
		return nil
	}
	if k.isKeventDropped(kevt) {
		kevt.Release()
		return nil
	}
	if rulesFired := k.rules.Fire(kevt); !rulesFired {
		return nil
	}
	// increment sequence
	if !kevt.Type.Dropped(false) {
		k.sequencer.Increment()
	}
	if k.eventCallback != nil {
		return k.eventCallback(kevt)
	}

	k.kevts <- kevt
	keventsEnqueued.Add(1)

	return nil
}

var offsets = map[uint32]string{}
var omux sync.RWMutex

// produceParams traverses ETW event's properties, gets the underlying property buffer and produces a kernel event
// parameter for the particular event.
func (k *kstreamConsumer) produceParams(ktype ktypes.Ktype, evt *etw.EventRecord, trace *tdh.TraceEventInfo) map[string]*kevent.Kparam {
	var (
		count = trace.PropertyCount
		kpars = make(map[string]*kevent.Kparam, count)
		// this yields a property array from the unsized array
		props = (*[1 << 30]tdh.EventPropertyInfo)(unsafe.Pointer(&trace.EventPropertyInfoArray[0]))[:count:count]
	)

	for _, property := range props {
		hashKey := ktype.Hash() + property.NameOffset
		omux.RLock()
		// lookup resolved kparam names if the hash key is not located in offsets cache
		kparName, ok := offsets[hashKey]
		omux.RUnlock()
		// compute the pointer to each property name and get the size of the buffer
		// that we'll allocate to accommodate the property value
		propp := unsafe.Pointer(uintptr(unsafe.Pointer(trace)) + uintptr(property.NameOffset))
		if !ok {
			kparName = utf16.PtrToString(propp)
			omux.Lock()
			offsets[hashKey] = kparName
			omux.Unlock()
		}
		kparName = kparams.Canonicalize(kparName)
		// discard unknown canonical names
		if kparName == "" {
			continue
		}
		descriptor := &tdh.PropertyDataDescriptor{
			PropertyName: propp,
			ArrayIndex:   0xFFFFFFFF,
		}
		// try to get the param size for static types
		// and fallback to TdhGetPropertySize for the
		// dynamic event parameters such as paths
		// process names, registry keys and so on
		size := kparams.SizeOf(kparName)
		if size == 0 {
			var err error
			size, err = getPropertySize(evt, descriptor)
			if err != nil || size == 0 {
				continue
			}
		}

		buffer := make([]byte, size)
		if err := getProperty(evt, descriptor, size, buffer); err != nil {
			continue
		}

		nst := *(*tdh.NonStructType)(unsafe.Pointer(&property.Types[0]))
		// obtain parameter value from the byte buffer
		kpar, err := getParam(kparName, buffer, size, nst)
		if err != nil {
			failedKparams.Add(1)
			continue
		}
		kpars[kparName] = kpar
	}

	return kpars
}

// produceRawParams parses the event binary layout to extract the parameters. Each event is annotated with the
// schema version number which will help us determine when the event schema changes to be able to parse
// new fields.
func (k *kstreamConsumer) produceRawParams(ktype ktypes.Ktype, evt *etw.EventRecord) map[string]*kevent.Kparam {
	buf := evt.Buffer
	length := evt.BufferLen
	version := evt.Header.EventDescriptor.Version
	switch ktype {
	case ktypes.EnumProcess,
		ktypes.CreateProcess,
		ktypes.TerminateProcess:
		var (
			kproc      uint64
			pid, ppid  uint32
			sessionID  uint32
			exitStatus uint32
			dtb        uint64
			sid        []byte
			name       string
			cmdline    string
		)
		var offset uint16
		var soffset uint16
		var noffset uint16
		if version >= 1 {
			pid = kparams.ReadUint32(buf, 8)
			ppid = kparams.ReadUint32(buf, 12)
			sessionID = kparams.ReadUint32(buf, 16)
			exitStatus = kparams.ReadUint32(buf, 20)
		}
		if version >= 2 {
			kproc = kparams.ReadUint64(buf, 0)
		}
		if version >= 3 {
			dtb = kparams.ReadUint64(buf, 24)
		}
		switch {
		case version >= 4:
			offset = 36
		case version >= 3:
			offset = 32
		default:
			offset = 24
		}
		sid, soffset = kparams.ReadSID(buf, offset)
		name, noffset = kparams.ReadAnsiString(buf, soffset, length)
		cmdline, _ = kparams.ReadUTF16String(buf, soffset+noffset, length)
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessObject, kparams.HexInt64, kproc),
			kevent.NewKparam(kparams.ProcessID, kparams.HexInt32, pid),
			kevent.NewKparam(kparams.ProcessParentID, kparams.HexInt32, ppid),
			kevent.NewKparam(kparams.SessionID, kparams.Uint32, sessionID),
			kevent.NewKparam(kparams.ExitStatus, kparams.Uint32, exitStatus),
			kevent.NewKparam(kparams.DTB, kparams.HexInt64, dtb),
			kevent.NewKparam(kparams.UserSID, kparams.WbemSID, sid),
			kevent.NewKparam(kparams.ProcessName, kparams.AnsiString, name),
			kevent.NewKparam(kparams.Comm, kparams.UnicodeString, cmdline),
		)
	case ktypes.OpenProcess:
		processID := kparams.ReadUint32(buf, 0)
		desiredAccess := kparams.ReadUint32(buf, 4)
		status := kparams.ReadUint32(buf, 8)
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessID, kparams.Uint32, processID),
			kevent.NewKparam(kparams.DesiredAccess, kparams.Uint32, desiredAccess),
			kevent.NewKparam(kparams.NTStatus, kparams.Uint32, status),
		)
	case ktypes.CreateThread,
		ktypes.TerminateThread,
		ktypes.EnumThread:
		var (
			pid            uint32
			tid            uint32
			kstack, klimit uint64
			ustack, ulimit uint64
			startAddr      uint64
			basePrio       uint8
			pagePrio       uint8
			ioPrio         uint8
		)
		if version >= 1 {
			pid = kparams.ReadUint32(buf, 0)
			tid = kparams.ReadUint32(buf, 4)
		} else {
			pid = kparams.ReadUint32(buf, 4)
			tid = kparams.ReadUint32(buf, 0)
		}
		if version >= 2 {
			kstack = kparams.ReadUint64(buf, 8)
			klimit = kparams.ReadUint64(buf, 16)
			ustack = kparams.ReadUint64(buf, 24)
			ulimit = kparams.ReadUint64(buf, 32)
			startAddr = kparams.ReadUint64(buf, 48)
		}
		if version >= 3 {
			basePrio = kparams.ReadByte(buf, 69)
			pagePrio = kparams.ReadByte(buf, 70)
			ioPrio = kparams.ReadByte(buf, 71)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessID, kparams.HexInt32, pid),
			kevent.NewKparam(kparams.ThreadID, kparams.HexInt32, tid),
			kevent.NewKparam(kparams.KstackBase, kparams.HexInt64, kstack),
			kevent.NewKparam(kparams.KstackLimit, kparams.HexInt64, klimit),
			kevent.NewKparam(kparams.UstackBase, kparams.HexInt64, ustack),
			kevent.NewKparam(kparams.UstackLimit, kparams.HexInt64, ulimit),
			kevent.NewKparam(kparams.ThreadEntrypoint, kparams.HexInt64, startAddr),
			kevent.NewKparam(kparams.BasePrio, kparams.Uint8, basePrio),
			kevent.NewKparam(kparams.PagePrio, kparams.Uint8, pagePrio),
			kevent.NewKparam(kparams.IOPrio, kparams.Uint8, ioPrio),
		)
	case ktypes.OpenThread:
		processID := kparams.ReadUint32(buf, 0)
		threadID := kparams.ReadUint32(buf, 4)
		desiredAccess := kparams.ReadUint32(buf, 8)
		status := kparams.ReadUint32(buf, 12)
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessID, kparams.Uint32, processID),
			kevent.NewKparam(kparams.ThreadID, kparams.Uint32, threadID),
			kevent.NewKparam(kparams.DesiredAccess, kparams.Uint32, desiredAccess),
			kevent.NewKparam(kparams.NTStatus, kparams.Uint32, status),
		)
	case ktypes.CreateHandle, ktypes.CloseHandle:
		object := kparams.ReadUint64(buf, 0)
		handleID := kparams.ReadUint32(buf, 8)
		typeID := kparams.ReadUint16(buf, 12)
		var handleName string
		if length >= 16 {
			handleName = kparams.ConsumeUTF16String(buf, 14, length)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.HandleObject, kparams.Uint64, object),
			kevent.NewKparam(kparams.HandleID, kparams.Uint32, handleID),
			kevent.NewKparam(kparams.HandleObjectTypeID, kparams.Uint16, typeID),
			kevent.NewKparam(kparams.HandleObjectName, kparams.UnicodeString, handleName),
		)
	case ktypes.LoadImage,
		ktypes.UnloadImage,
		ktypes.EnumImage:
		var (
			pid         uint32
			checksum    uint32
			defaultBase uint64
			filename    string
		)
		var offset uint16
		imageBase := kparams.ReadUint64(buf, 0)
		imageSize := kparams.ReadUint64(buf, 8)
		if version >= 1 {
			pid = kparams.ReadUint32(buf, 16)
		}
		if version >= 2 {
			checksum = kparams.ReadUint32(buf, 20)
			defaultBase = kparams.ReadUint64(buf, 30)
		}
		if version >= 3 {
			defaultBase = kparams.ReadUint64(buf, 32)
		}
		switch {
		case version >= 3:
			offset = 56
		case version >= 2:
			offset = 54
		case version >= 1:
			offset = 20
		default:
			offset = 16
		}
		filename, _ = kparams.ReadUTF16String(buf, offset, length)
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessID, kparams.Uint32, pid),
			kevent.NewKparam(kparams.ImageCheckSum, kparams.Uint32, checksum),
			kevent.NewKparam(kparams.ImageDefaultBase, kparams.HexInt64, defaultBase),
			kevent.NewKparam(kparams.ImageBase, kparams.HexInt64, imageBase),
			kevent.NewKparam(kparams.ImageSize, kparams.Uint32, uint32(imageSize)),
			kevent.NewKparam(kparams.ImageFilename, kparams.UnicodeString, filename),
		)
	case ktypes.RegOpenKey, ktypes.RegOpenKeyV1,
		ktypes.RegCreateKCB, ktypes.RegDeleteKCB,
		ktypes.RegKCBRundown, ktypes.RegCreateKey,
		ktypes.RegDeleteKey, ktypes.RegDeleteValue,
		ktypes.RegQueryKey, ktypes.RegQueryValue,
		ktypes.RegSetValue:
		var (
			status    uint32
			keyHandle uint64
			keyName   string
		)
		if version >= 2 {
			status = kparams.ReadUint32(buf, 8)
			keyHandle = kparams.ReadUint64(buf, 16)
		} else {
			status = kparams.ReadUint32(buf, 0)
			keyHandle = kparams.ReadUint64(buf, 4)
		}
		if version >= 1 {
			keyName = kparams.ConsumeUTF16String(buf, 24, length)
		} else {
			keyName = kparams.ConsumeUTF16String(buf, 20, length)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.RegKeyHandle, kparams.Uint64, keyHandle),
			kevent.NewKparam(kparams.RegKeyName, kparams.UnicodeString, keyName),
			kevent.NewKparam(kparams.NTStatus, kparams.Uint32, status),
		)
	case ktypes.CreateFile:
		var (
			irp            uint64
			fileObject     uint64
			tid            uint32
			createOptions  uint32
			fileAttributes uint32
			shareAccess    uint32
			filename       string
		)
		if version >= 2 {
			irp = kparams.ReadUint64(buf, 0)
			fileObject = kparams.ReadUint64(buf, 8)
			tid = kparams.ReadUint32(buf, 16)
			createOptions = kparams.ReadUint32(buf, 20)
			fileAttributes = kparams.ReadUint32(buf, 24)
			shareAccess = kparams.ReadUint32(buf, 28)
			filename = kparams.ConsumeUTF16String(buf, 32, length)
		} else {
			fileObject = kparams.ReadUint64(buf, 0)
			filename = kparams.ConsumeUTF16String(buf, 8, length)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileIrpPtr, kparams.Uint64, irp),
			kevent.NewKparam(kparams.FileObject, kparams.Uint64, fileObject),
			kevent.NewKparam(kparams.ThreadID, kparams.Uint32, tid),
			kevent.NewKparam(kparams.FileCreateOptions, kparams.Uint32, createOptions),
			kevent.NewKparam(kparams.FileAttributes, kparams.Uint32, fileAttributes),
			kevent.NewKparam(kparams.FileShareMask, kparams.Uint32, shareAccess),
			kevent.NewKparam(kparams.FileName, kparams.UnicodeString, filename),
		)
	case ktypes.FileOpEnd:
		var (
			irp       uint64
			extraInfo uint64
			status    uint32
		)
		if version >= 2 {
			irp = kparams.ReadUint64(buf, 0)
			extraInfo = kparams.ReadUint64(buf, 8)
			status = kparams.ReadUint32(buf, 16)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileIrpPtr, kparams.Uint64, irp),
			kevent.NewKparam(kparams.FileExtraInfo, kparams.Uint64, extraInfo),
			kevent.NewKparam(kparams.NTStatus, kparams.Uint32, status),
		)
	case ktypes.FileRundown:
		var (
			fileObject uint64
			filename   string
		)
		if version >= 2 {
			fileObject = kparams.ReadUint64(buf, 0)
			filename = kparams.ConsumeUTF16String(buf, 8, length)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileObject, kparams.Uint64, fileObject),
			kevent.NewKparam(kparams.FileName, kparams.UnicodeString, filename),
		)
	case ktypes.ReleaseFile, ktypes.CloseFile:
		var (
			irp        uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
		)
		if version >= 2 {
			irp = kparams.ReadUint64(buf, 0)
		}
		if version >= 3 {
			fileObject = kparams.ReadUint64(buf, 8)
			fileKey = kparams.ReadUint64(buf, 16)
			tid = kparams.ReadUint32(buf, 24)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileIrpPtr, kparams.Uint64, irp),
			kevent.NewKparam(kparams.FileObject, kparams.Uint64, fileObject),
			kevent.NewKparam(kparams.FileKey, kparams.Uint64, fileKey),
			kevent.NewKparam(kparams.ThreadID, kparams.Uint32, tid),
		)
	case ktypes.DeleteFile,
		ktypes.RenameFile,
		ktypes.SetFileInformation:
		var (
			irp        uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
			extraInfo  uint64
			infoClass  uint32
		)
		if version >= 2 {
			irp = kparams.ReadUint64(buf, 0)
		}
		if version >= 3 {
			fileObject = kparams.ReadUint64(buf, 8)
			fileKey = kparams.ReadUint64(buf, 16)
			extraInfo = kparams.ReadUint64(buf, 24)
			tid = kparams.ReadUint32(buf, 32)
			infoClass = kparams.ReadUint32(buf, 36)
		} else {
			tid = kparams.ReadUint32(buf, 8)
			fileObject = kparams.ReadUint64(buf, 12)
			fileKey = kparams.ReadUint64(buf, 18)
			extraInfo = kparams.ReadUint64(buf, 28)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileIrpPtr, kparams.Uint64, irp),
			kevent.NewKparam(kparams.FileObject, kparams.Uint64, fileObject),
			kevent.NewKparam(kparams.FileKey, kparams.Uint64, fileKey),
			kevent.NewKparam(kparams.ThreadID, kparams.Uint32, tid),
			kevent.NewKparam(kparams.FileExtraInfo, kparams.Uint64, extraInfo),
			kevent.NewKparam(kparams.FileInfoClass, kparams.Uint32, infoClass),
		)
	case ktypes.ReadFile, ktypes.WriteFile:
		var (
			irp        uint64
			offset     uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
			size       uint32
		)
		if version >= 2 {
			offset = kparams.ReadUint64(buf, 0)
			irp = kparams.ReadUint64(buf, 8)
		}
		if version >= 3 {
			fileObject = kparams.ReadUint64(buf, 16)
			fileKey = kparams.ReadUint64(buf, 24)
			tid = kparams.ReadUint32(buf, 32)
			size = kparams.ReadUint32(buf, 34)
		} else {
			fileObject = kparams.ReadUint64(buf, 20)
			fileKey = kparams.ReadUint64(buf, 28)
			tid = kparams.ReadUint32(buf, 16)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileIrpPtr, kparams.Uint64, irp),
			kevent.NewKparam(kparams.FileObject, kparams.Uint64, fileObject),
			kevent.NewKparam(kparams.FileKey, kparams.Uint64, fileKey),
			kevent.NewKparam(kparams.ThreadID, kparams.Uint32, tid),
			kevent.NewKparam(kparams.FileOffset, kparams.Uint64, offset),
			kevent.NewKparam(kparams.FileIoSize, kparams.Uint32, size),
		)
	case ktypes.EnumDirectory:
		var (
			irp        uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
			infoClass  uint32
			filename   string
		)
		if version >= 2 {
			irp = kparams.ReadUint64(buf, 0)
		}
		if version >= 3 {
			fileObject = kparams.ReadUint64(buf, 8)
			fileKey = kparams.ReadUint64(buf, 16)
			tid = kparams.ReadUint32(buf, 24)
			infoClass = kparams.ReadUint32(buf, 32)
			filename = kparams.ConsumeUTF16String(buf, 38, length)
		} else {
			tid = kparams.ReadUint32(buf, 8)
			fileObject = kparams.ReadUint64(buf, 12)
			fileKey = kparams.ReadUint64(buf, 20)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.FileIrpPtr, kparams.Uint64, irp),
			kevent.NewKparam(kparams.FileObject, kparams.Uint64, fileObject),
			kevent.NewKparam(kparams.ThreadID, kparams.Uint32, tid),
			kevent.NewKparam(kparams.FileKey, kparams.Uint64, fileKey),
			kevent.NewKparam(kparams.FileName, kparams.UnicodeString, filename),
			kevent.NewKparam(kparams.FileInfoClass, kparams.Uint32, infoClass),
		)
	case ktypes.SendTCPv4,
		ktypes.SendUDPv4,
		ktypes.RecvTCPv4,
		ktypes.RecvUDPv4,
		ktypes.DisconnectTCPv4,
		ktypes.RetransmitTCPv4,
		ktypes.ReconnectTCPv4,
		ktypes.ConnectTCPv4,
		ktypes.AcceptTCPv4:
		var (
			pid   uint32
			size  uint32
			dip   uint32
			sip   uint32
			dport uint16
			sport uint16
		)
		if version >= 1 {
			pid = kparams.ReadUint32(buf, 0)
			size = kparams.ReadUint32(buf, 4)
			dip = kparams.ReadUint32(buf, 8)
			sip = kparams.ReadUint32(buf, 12)
			dport = kparams.ReadUint16(buf, 16)
			sport = kparams.ReadUint16(buf, 18)
		} else {
			dip = kparams.ReadUint32(buf, 0)
			sip = kparams.ReadUint32(buf, 4)
			dport = kparams.ReadUint16(buf, 8)
			sport = kparams.ReadUint16(buf, 10)
			size = kparams.ReadUint32(buf, 12)
			pid = kparams.ReadUint32(buf, 16)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessID, kparams.Uint32, pid),
			kevent.NewKparam(kparams.NetSize, kparams.Uint32, size),
			kevent.NewKparam(kparams.NetDIP, kparams.IPv4, dip),
			kevent.NewKparam(kparams.NetSIP, kparams.IPv4, sip),
			kevent.NewKparam(kparams.NetDport, kparams.Port, dport),
			kevent.NewKparam(kparams.NetSport, kparams.Port, sport),
		)
	case ktypes.SendTCPv6,
		ktypes.SendUDPv6,
		ktypes.RecvTCPv6,
		ktypes.RecvUDPv6,
		ktypes.DisconnectTCPv6,
		ktypes.RetransmitTCPv6,
		ktypes.ReconnectTCPv6,
		ktypes.ConnectTCPv6,
		ktypes.AcceptTCPv6:
		var (
			pid   uint32
			size  uint32
			dip   []byte
			sip   []byte
			dport uint16
			sport uint16
		)
		if version >= 2 {
			pid = kparams.ReadUint32(buf, 0)
			size = kparams.ReadUint32(buf, 4)
			dip = kparams.ReadBytes(buf, 8, 16)
			sip = kparams.ReadBytes(buf, 24, 16)
			dport = kparams.ReadUint16(buf, 40)
			sport = kparams.ReadUint16(buf, 42)
		}
		return kevent.KparamsFromSlice(
			kevent.NewKparam(kparams.ProcessID, kparams.Uint32, pid),
			kevent.NewKparam(kparams.NetSize, kparams.Uint32, size),
			kevent.NewKparam(kparams.NetDIP, kparams.IPv6, dip),
			kevent.NewKparam(kparams.NetSIP, kparams.IPv6, sip),
			kevent.NewKparam(kparams.NetDport, kparams.Port, dport),
			kevent.NewKparam(kparams.NetSport, kparams.Port, sport),
		)
	default:
		return kevent.Kparams{}
	}
}

// getTraceInfo returns the trace info from the event record.
func getTraceInfo(ktype ktypes.Ktype, evt *etw.EventRecord) (*tdh.TraceEventInfo, error) {
	// it as required to initialize the size of the
	// event trace buffer that we'll have to reallocate
	// in case there's no enough room to store the whole trace
	bufferSize := evtBufferSize
	buffer := make([]byte, bufferSize)

	err := tdh.GetEventInformation(evt, buffer, bufferSize)
	if err == kerrors.ErrInsufficentBuffer {
		// not enough space to store the event, so we retry with bigger buffer
		buffer = make([]byte, bufferSize)
		if err = tdh.GetEventInformation(evt, buffer, bufferSize); err != nil {
			return nil, fmt.Errorf("failed to get event metadata after reallocating buffer size to %d KB: %v", bufferSize, err)
		}
	}
	if err != nil {
		if err == kerrors.ErrEventSchemaNotFound {
			// increment error count for events that lack the schema
			failedKeventsByMissingSchema.Add(ktype.String(), 1)
			return nil, fmt.Errorf("schema not found for event %q", ktype)
		}
		return nil, fmt.Errorf("unable to retrieve kernel event metadata for :%q: %v", ktype, err)
	}
	return (*tdh.TraceEventInfo)(unsafe.Pointer(&buffer[0])), nil
}

// getParam extracts parameter value from the property buffer and builds the kparam structure.
func getParam(name string, buffer []byte, size uint32, nonStructType tdh.NonStructType) (*kevent.Kparam, error) {
	if len(buffer) == 0 {
		return nil, errors.New("property buffer is empty")
	}

	var (
		typ   kparams.Type
		value kparams.Value
	)

	switch nonStructType.InType {
	case tdh.IntypeUnicodeString:
		typ, value = kparams.UnicodeString, utf16.PtrToString(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeAnsiString:
		typ, value = kparams.AnsiString, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buffer[0]))[:size-1:size-1])

	case tdh.IntypeInt8:
		typ, value = kparams.Int8, *(*int8)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeUint8:
		typ, value = kparams.Uint8, *(*uint8)(unsafe.Pointer(&buffer[0]))
		if nonStructType.OutType == tdh.OutypeHexInt8 {
			typ = kparams.HexInt8
		}
	case tdh.IntypeBoolean:
		typ, value = kparams.Bool, *(*bool)(unsafe.Pointer(&buffer[0]))

	case tdh.IntypeInt16:
		typ, value = kparams.Int16, *(*int16)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeUint16:
		typ, value = kparams.Uint16, *(*uint16)(unsafe.Pointer(&buffer[0]))
		switch nonStructType.OutType {
		case tdh.OutypeHexInt16:
			typ = kparams.HexInt16
		case tdh.OutypePort:
			typ = kparams.Port
		}

	case tdh.IntypeInt32:
		typ, value = kparams.Int32, *(*int32)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeUint32:
		typ, value = kparams.Uint32, *(*uint32)(unsafe.Pointer(&buffer[0]))
		switch nonStructType.OutType {
		case tdh.OutypeHexInt32:
			typ = kparams.HexInt32
		case tdh.OutypeIPv4:
			typ = kparams.IPv4
		}

	case tdh.IntypeInt64:
		typ, value = kparams.Int64, *(*int64)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeUint64:
		typ, value = kparams.Uint64, *(*uint64)(unsafe.Pointer(&buffer[0]))
		if nonStructType.OutType == tdh.OutypeHexInt64 {
			typ = kparams.HexInt64
		}

	case tdh.IntypeFloat:
		typ, value = kparams.Float, *(*float32)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeDouble:
		typ, value = kparams.Double, *(*float64)(unsafe.Pointer(&buffer[0]))

	case tdh.IntypeHexInt32:
		typ, value = kparams.HexInt32, *(*int32)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeHexInt64:
		typ, value = kparams.HexInt64, *(*int64)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypePointer, tdh.IntypeSizet:
		typ, value = kparams.HexInt64, *(*uint64)(unsafe.Pointer(&buffer[0]))
	case tdh.IntypeSID:
		typ, value = kparams.SID, buffer
	case tdh.IntypeWbemSID:
		typ, value = kparams.WbemSID, buffer
	case tdh.IntypeBinary:
		if nonStructType.OutType == tdh.OutypeIPv6 {
			typ, value = kparams.IPv6, buffer
		} else {
			typ, value = kparams.Binary, buffer
		}
	default:
		return nil, fmt.Errorf("unknown type for %q parameter", name)
	}

	return kevent.NewKparam(name, typ, value), nil
}

// isKeventDropped discards the kernel event before it hits the output channel.
// Dropping a kernel event occurs if any of the following conditions
// are met:
//
// - kernel event is used solely for building internal state of either
// needs to be stored in the capture file for the purpose of restoring
// the state
// - process that produced the kernel event is fibratus itself
// - kernel event is present in the exclude list, and thus it is always dropped
// - finally, the event is checked by the CLI filter
func (k *kstreamConsumer) isKeventDropped(kevt *kevent.Kevent) bool {
	// drops events of certain type. For example, EnumProcess
	// is solely used to create the snapshot of live processes
	if kevt.Type.Dropped(k.capture) {
		return true
	}
	// ignores anything produced by the fibratus process
	if kevt.PID == currentPid {
		return true
	}
	// discard excluded event types
	if k.config.Kstream.ExcludeKevent(kevt) {
		excludedKevents.Add(1)
		return true
	}
	// fallback to CLI filter
	if k.filter != nil {
		return !k.filter.Run(kevt)
	}
	return false
}

```

`pkg/kstream/kstreamc_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kstream

import (
	"encoding/gob"
	"github.com/rabbitstack/fibratus/pkg/config"
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/syscall/etw"
	"github.com/rabbitstack/fibratus/pkg/syscall/tdh"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"net"
	"os"
	"testing"
	"time"
	"unsafe"
)

func TestOpenKstream(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)
	ktraceController := NewKtraceController(config.KstreamConfig{})
	kstreamc := NewConsumer(ktraceController, psnap, hsnap, &config.Config{Filters: &config.Filters{}})
	openTrace = func(ktrace etw.EventTraceLogfile) etw.TraceHandle {
		return etw.TraceHandle(2)
	}
	processTrace = func(handle etw.TraceHandle) error {
		return nil
	}
	traces := map[string]TraceSession{
		etw.KernelLoggerSession: {},
	}
	err := kstreamc.OpenKstream(traces)
	require.NoError(t, err)
}

func TestOpenKstreamInvalidHandle(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)
	ktraceController := NewKtraceController(config.KstreamConfig{})
	kstreamc := NewConsumer(ktraceController, psnap, hsnap, &config.Config{Filters: &config.Filters{}})
	openTrace = func(ktrace etw.EventTraceLogfile) etw.TraceHandle {
		return etw.TraceHandle(0xffffffffffffffff)
	}
	traces := map[string]TraceSession{
		etw.KernelLoggerSession: {Name: etw.KernelLoggerSession, GUID: etw.KernelTraceControlGUID},
	}
	err := kstreamc.OpenKstream(traces)
	require.Error(t, err)
}

func TestOpenKstreamKsessionNotRunning(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)
	ktraceController := NewKtraceController(config.KstreamConfig{})
	kstreamc := NewConsumer(ktraceController, psnap, hsnap, &config.Config{Filters: &config.Filters{}})
	openTrace = func(ktrace etw.EventTraceLogfile) etw.TraceHandle {
		return etw.TraceHandle(2)
	}
	processTrace = func(handle etw.TraceHandle) error {
		return kerrors.ErrKsessionNotRunning
	}
	traces := map[string]TraceSession{
		etw.KernelLoggerSession: {},
	}
	err := kstreamc.OpenKstream(traces)
	require.NoError(t, err)
	err = <-kstreamc.Errors()
	assert.EqualError(t, err, "kernel session from which you are trying to consume events in real time is not running")
}

func TestProcessKevent(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)
	ktraceController := NewKtraceController(config.KstreamConfig{})
	kstreamc := NewConsumer(ktraceController, psnap, hsnap, &config.Config{Filters: &config.Filters{}})

	psnap.On("Find", mock.Anything).Return(&types.PS{Name: "cmd.exe"})

	openTrace = func(ktrace etw.EventTraceLogfile) etw.TraceHandle {
		return etw.TraceHandle(2)
	}
	processTrace = func(handle etw.TraceHandle) error {
		return nil
	}
	getPropertySize = func(evt *etw.EventRecord, descriptor *tdh.PropertyDataDescriptor) (uint32, error) {
		return uint32(10), nil
	}
	getProperty = func(evt *etw.EventRecord, descriptor *tdh.PropertyDataDescriptor, size uint32, buffer []byte) error {
		return nil
	}

	psnap.On("Write", mock.Anything).Return(nil)

	f, err := os.Open("./_fixtures/snapshots/create-process.gob")
	if err != nil {
		t.Fatal(err)
	}

	dec := gob.NewDecoder(f)
	var evt etw.EventRecord
	err = dec.Decode(&evt)
	if err != nil {
		t.Fatal(err)
	}
	done := make(chan struct{}, 1)

	go func() {
		defer func() {
			done <- struct{}{}
		}()
		kevt := <-kstreamc.Events()

		assert.Equal(t, ktypes.Process, kevt.Category)
		assert.Equal(t, uint32(9828), kevt.Tid)
		assert.Equal(t, uint8(5), kevt.CPU)
		assert.Equal(t, ktypes.CreateProcess, kevt.Type)
		assert.Equal(t, "CreateProcess", kevt.Name)
		assert.Equal(t, "Creates a new process and its primary thread", kevt.Description)

		ts, err := time.Parse("2006-01-02 15:04:05.0000000 -0700 CEST", "2019-04-05 16:10:36.5225778 +0200 CEST")
		require.NoError(t, err)
		assert.Equal(t, ts.Year(), kevt.Timestamp.Year())
		assert.Equal(t, ts.Month(), kevt.Timestamp.Month())
		assert.Equal(t, ts.Day(), kevt.Timestamp.Day())
		assert.Equal(t, ts.Minute(), kevt.Timestamp.Minute())
		assert.Equal(t, ts.Second(), kevt.Timestamp.Second())
		assert.Equal(t, ts.Nanosecond(), kevt.Timestamp.Nanosecond())
		assert.Len(t, kevt.Kparams, 9)

		assert.True(t, kevt.Kparams.Contains(kparams.DTB))
		assert.True(t, kevt.Kparams.Contains(kparams.ProcessName))
	}()

	err = kstreamc.(*kstreamConsumer).processKevent(&evt)
	require.NoError(t, err)

	<-done
}

func TestProcessKeventRaw(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)
	ktraceController := NewKtraceController(config.KstreamConfig{})
	kstreamc := NewConsumer(ktraceController, psnap, hsnap, &config.Config{
		Kstream: config.KstreamConfig{
			RawEventParsing: true,
		},
		Filters: &config.Filters{}},
	)

	psnap.On("Find", mock.Anything).Return(&types.PS{Name: "cmd.exe"})

	openTrace = func(ktrace etw.EventTraceLogfile) etw.TraceHandle {
		return etw.TraceHandle(2)
	}
	processTrace = func(handle etw.TraceHandle) error {
		return nil
	}

	psnap.On("Write", mock.Anything).Return(nil)

	f, err := os.Open("./_fixtures/snapshots/create-process-raw.gob")
	if err != nil {
		t.Fatal(err)
	}

	dec := gob.NewDecoder(f)
	var evt etw.EventRecord
	err = dec.Decode(&evt)
	if err != nil {
		t.Fatal(err)
	}

	buf := []byte{
		0x80, 0xE0, 0x2E, 0x49, 0x06, 0xC1, 0xFF, 0xFF, 0xE8, 0x30, 0x00, 0x00, 0x78, 0x14, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x50, 0x22, 0x91, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xE0, 0x08, 0xE2, 0x1F, 0x0F, 0xA7, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
		0x0F, 0xA7, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x12, 0x00, 0x00, 0x00,
		0x63, 0x6D, 0x64, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x43, 0x00, 0x3A, 0x00, 0x5C, 0x00, 0x57, 0x00,
		0x49, 0x00, 0x4E, 0x00, 0x44, 0x00, 0x4F, 0x00, 0x57, 0x00, 0x53, 0x00, 0x5C, 0x00, 0x73, 0x00,
		0x79, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x33, 0x00, 0x32, 0x00, 0x5C, 0x00,
		0x63, 0x00, 0x6D, 0x00, 0x64, 0x00, 0x2E, 0x00, 0x65, 0x00, 0x78, 0x00, 0x65, 0x00, 0x20, 0x00,
		0x2F, 0x00, 0x63, 0x00, 0x20, 0x00, 0x64, 0x00, 0x69, 0x00, 0x72, 0x00, 0x20, 0x00, 0x2F, 0x00,
		0x2D, 0x00, 0x43, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x57, 0x00, 0x20, 0x00, 0x22, 0x00, 0x5C, 0x00,
		0x5C, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x63, 0x00, 0x3A, 0x00, 0x5C, 0x00, 0x55, 0x00, 0x73, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x64, 0x00, 0x6F, 0x00,
		0x5C, 0x00, 0x41, 0x00, 0x70, 0x00, 0x70, 0x00, 0x44, 0x00, 0x61, 0x00, 0x74, 0x00, 0x61, 0x00,
		0x5C, 0x00, 0x52, 0x00, 0x6F, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00,
		0x5C, 0x00, 0x52, 0x00, 0x61, 0x00, 0x62, 0x00, 0x62, 0x00, 0x69, 0x00, 0x74, 0x00, 0x4D, 0x00,
		0x51, 0x00, 0x5C, 0x00, 0x64, 0x00, 0x62, 0x00, 0x5C, 0x00, 0x72, 0x00, 0x61, 0x00, 0x62, 0x00,
		0x62, 0x00, 0x69, 0x00, 0x74, 0x00, 0x40, 0x00, 0x61, 0x00, 0x72, 0x00, 0x63, 0x00, 0x68, 0x00,
		0x72, 0x00, 0x61, 0x00, 0x62, 0x00, 0x62, 0x00, 0x69, 0x00, 0x74, 0x00, 0x2D, 0x00, 0x6D, 0x00,
		0x6E, 0x00, 0x65, 0x00, 0x73, 0x00, 0x69, 0x00, 0x61, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,
	}
	evt.Buffer = uintptr(unsafe.Pointer(&buf[0]))
	evt.BufferLen = uint16(len(buf))

	done := make(chan struct{}, 1)

	go func() {
		defer func() {
			done <- struct{}{}
		}()
		kevt := <-kstreamc.Events()

		assert.Equal(t, ktypes.Process, kevt.Category)
		assert.Equal(t, uint32(6588), kevt.Tid)
		assert.Equal(t, uint8(0), kevt.CPU)
		assert.Equal(t, ktypes.CreateProcess, kevt.Type)
		assert.Equal(t, "CreateProcess", kevt.Name)

		assert.Len(t, kevt.Kparams, 11)

		assert.True(t, kevt.Kparams.Contains(kparams.DTB))
		assert.True(t, kevt.Kparams.Contains(kparams.ProcessName))

		name, err := kevt.Kparams.GetString(kparams.ProcessName)
		require.NoError(t, err)
		assert.Equal(t, "cmd.exe", name)

		cmdline, err := kevt.Kparams.GetString(kparams.Comm)
		require.NoError(t, err)
		assert.Equal(t, "C:\\WINDOWS\\system32\\cmd.exe /c dir /-C /W \"\\\\?\\c:\\Users\\nedo\\AppData\\Roaming\\RabbitMQ\\db\\rabbit@archrabbit-mnesia\"", cmdline)

		sid, err := kevt.Kparams.GetString(kparams.UserSID)
		require.NoError(t, err)
		assert.Equal(t, "NT AUTHORITY\\SYSTEM", sid)

		pid, err := kevt.Kparams.GetPid()
		require.NoError(t, err)
		assert.Equal(t, uint32(12520), pid)

		ppid, err := kevt.Kparams.GetPpid()
		require.NoError(t, err)
		assert.Equal(t, uint32(5240), ppid)
	}()

	err = kstreamc.(*kstreamConsumer).processKevent(&evt)
	require.NoError(t, err)

	<-done
}

func TestGetParamEmptyBuffer(t *testing.T) {
	_, err := getParam("sip", nil, 16, tdh.NonStructType{InType: tdh.IntypeBinary, OutType: tdh.OutypeIPv6})
	require.Error(t, err)

	_, err = getParam("sip", []byte{}, 16, tdh.NonStructType{InType: tdh.IntypeBinary, OutType: tdh.OutypeIPv6})
	require.Error(t, err)
}

func TestGetParam(t *testing.T) {
	kpar, err := getParam("comm", []byte{99, 0, 109, 0, 100, 0, 92, 0, 102, 0, 105, 0, 98, 0, 114, 0, 97, 0, 116, 0, 117, 0, 115, 0, 92, 0, 102, 0, 105, 0, 98, 0, 114, 0, 97, 0, 116, 0, 117, 0, 115, 0, 46, 0, 101, 0, 120, 0, 101, 0, 32, 0, 32, 0, 0, 0}, 16, tdh.NonStructType{InType: tdh.IntypeUnicodeString})
	require.NoError(t, err)
	assert.Equal(t, kparams.UnicodeString, kpar.Type)
	assert.Equal(t, "cmd\\fibratus\\fibratus.exe  ", kpar.Value)

	kpar, err = getParam("exe", []byte{77, 105, 99, 114, 111, 115, 111, 102, 116, 46, 80, 104, 111, 116, 111, 115, 46, 101, 120, 101, 0}, 21, tdh.NonStructType{InType: tdh.IntypeAnsiString})
	require.NoError(t, err)
	assert.Equal(t, kparams.AnsiString, kpar.Type)
	assert.Equal(t, "Microsoft.Photos.exe", kpar.Value)

	kpar, err = getParam("flag", []byte{127}, 1, tdh.NonStructType{InType: tdh.IntypeInt8})
	require.NoError(t, err)
	assert.Equal(t, kparams.Int8, kpar.Type)
	assert.Equal(t, int8(127), kpar.Value)

	kpar, err = getParam("flag", []byte{255}, 1, tdh.NonStructType{InType: tdh.IntypeUint8})
	require.NoError(t, err)
	assert.Equal(t, kparams.Uint8, kpar.Type)
	assert.Equal(t, uint8(255), kpar.Value)

	kpar, err = getParam("flag", []byte{255}, 1, tdh.NonStructType{InType: tdh.IntypeUint8, OutType: tdh.OutypeHexInt8})
	require.NoError(t, err)
	assert.Equal(t, kparams.HexInt8, kpar.Type)
	assert.Equal(t, kparams.Hex("ff"), kpar.Value)

	kpar, err = getParam("enabled", []byte{1}, 1, tdh.NonStructType{InType: tdh.IntypeBoolean})
	require.NoError(t, err)
	assert.Equal(t, kparams.Bool, kpar.Type)
	assert.Equal(t, true, kpar.Value)

	kpar, err = getParam("enabled", []byte{0}, 1, tdh.NonStructType{InType: tdh.IntypeBoolean})
	require.NoError(t, err)
	assert.Equal(t, kparams.Bool, kpar.Type)
	assert.Equal(t, false, kpar.Value)

	kpar, err = getParam("addr", []byte{255, 169}, 2, tdh.NonStructType{InType: tdh.IntypeUint16, OutType: tdh.OutypeHexInt16})
	require.NoError(t, err)
	assert.Equal(t, kparams.HexInt16, kpar.Type)
	assert.Equal(t, kparams.Hex("a9ff"), kpar.Value)

	kpar, err = getParam("sport", []byte{255, 169}, 2, tdh.NonStructType{InType: tdh.IntypeUint16, OutType: tdh.OutypePort})
	require.NoError(t, err)
	assert.Equal(t, kparams.Port, kpar.Type)
	assert.Equal(t, uint16(65449), kpar.Value)

	kpar, err = getParam("pid", []byte{252, 26, 0, 0}, 4, tdh.NonStructType{InType: tdh.IntypeInt32})
	require.NoError(t, err)
	assert.Equal(t, kparams.Int32, kpar.Type)
	assert.Equal(t, int32(6908), kpar.Value)

	kpar, err = getParam("kproc", []byte{108, 3, 0, 0}, 4, tdh.NonStructType{InType: tdh.IntypeUint32})
	require.NoError(t, err)
	assert.Equal(t, kparams.Uint32, kpar.Type)
	assert.Equal(t, uint32(876), kpar.Value)

	kpar, err = getParam("kproc", []byte{108, 3, 0, 0}, 4, tdh.NonStructType{InType: tdh.IntypeUint32, OutType: tdh.OutypeHexInt32})
	require.NoError(t, err)
	assert.Equal(t, kparams.HexInt32, kpar.Type)
	assert.Equal(t, kparams.Hex("36c"), kpar.Value)

	kpar, err = getParam("dip", []byte{192, 168, 1, 210}, 4, tdh.NonStructType{InType: tdh.IntypeUint32, OutType: tdh.OutypeIPv4})
	require.NoError(t, err)
	assert.Equal(t, kparams.IPv4, kpar.Type)
	assert.Equal(t, net.ParseIP("192.168.1.210"), kpar.Value)

	kpar, err = getParam("syscall.addr", []byte{192, 168, 1, 210, 8, 1, 1, 1}, 8, tdh.NonStructType{InType: tdh.IntypeInt64})
	require.NoError(t, err)
	assert.Equal(t, kparams.Int64, kpar.Type)
	assert.Equal(t, int64(72340206409328832), kpar.Value)

	kpar, err = getParam("syscall.addr", []byte{192, 168, 1, 210, 199, 100, 100, 100}, 8, tdh.NonStructType{InType: tdh.IntypeUint64})
	require.NoError(t, err)
	assert.Equal(t, kparams.Uint64, kpar.Type)
	assert.Equal(t, uint64(7234017710848452800), kpar.Value)

	kpar, err = getParam("syscall.addr", []byte{192, 168, 1, 210, 199, 100, 100, 100}, 8, tdh.NonStructType{InType: tdh.IntypeUint64, OutType: tdh.OutypeHexInt64})
	require.NoError(t, err)
	assert.Equal(t, kparams.HexInt64, kpar.Type)
	assert.Equal(t, kparams.Hex("646464c7d201a8c0"), kpar.Value)

	kpar, err = getParam("currency", []byte{0, 0, 0, 1}, 4, tdh.NonStructType{InType: tdh.IntypeFloat})
	require.NoError(t, err)
	assert.Equal(t, kparams.Float, kpar.Type)
	assert.Equal(t, float32(2.3509887e-38), kpar.Value)

	kpar, err = getParam("currency", []byte{0, 0, 0, 0, 0, 0, 0, 1}, 8, tdh.NonStructType{InType: tdh.IntypeDouble})
	require.NoError(t, err)
	assert.Equal(t, kparams.Double, kpar.Type)
	assert.Equal(t, float64(7.291122019556398e-304), kpar.Value)

	kpar, err = getParam("kproc", []byte{108, 3, 0, 0}, 4, tdh.NonStructType{InType: tdh.IntypeHexInt32})
	require.NoError(t, err)
	assert.Equal(t, kparams.HexInt32, kpar.Type)
	assert.Equal(t, kparams.Hex("36c"), kpar.Value)

	kpar, err = getParam("syscall.addr", []byte{192, 168, 1, 210, 199, 100, 100, 100}, 8, tdh.NonStructType{InType: tdh.IntypeHexInt64})
	require.NoError(t, err)
	assert.Equal(t, kparams.HexInt64, kpar.Type)
	assert.Equal(t, kparams.Hex("646464c7d201a8c0"), kpar.Value)

	kpar, err = getParam("sid", []byte{96, 12, 161, 104, 133, 219, 255, 255, 0, 0, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}, 8, tdh.NonStructType{InType: tdh.IntypeWbemSID})
	require.NoError(t, err)
	assert.Equal(t, kparams.WbemSID, kpar.Type)
	assert.Equal(t, "NT AUTHORITY\\SYSTEM", kpar.Value)

	kpar, err = getParam("sip", []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}, 16, tdh.NonStructType{InType: tdh.IntypeBinary, OutType: tdh.OutypeIPv6})
	require.NoError(t, err)
	assert.Equal(t, kparams.IPv6, kpar.Type)
	assert.Equal(t, net.ParseIP("::1"), kpar.Value)
}

func TestGetParamUnknownType(t *testing.T) {
	kpar, err := getParam("comm", []byte{99, 0, 109, 0, 100, 0, 92, 0, 102, 0, 105, 0, 98, 0, 114, 0, 97, 0, 116, 0, 117, 0, 115, 0, 92, 0, 102, 0, 105, 0, 98, 0, 114, 0, 97, 0, 116, 0, 117, 0, 115, 0, 46, 0, 101, 0, 120, 0, 101, 0, 32, 0, 32, 0, 0, 0}, 16, tdh.NonStructType{InType: tdh.IntypeFiletime})
	require.Error(t, err)
	require.Nil(t, kpar)
}

```

`pkg/network/address.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import "net"

// Address is the comparable type-alias for the IP v4/v6 addresses
type Address [16]byte

// ToIP converts the address to net.IP type.
func (addr Address) ToIP() net.IP {
	return net.IP(addr[:])
}

// ToIPString converts the address to IP string representation.
func (addr Address) ToIPString() string {
	return addr.ToIP().String()
}

// AddressFromIP constructs the address from the IP address.
func AddressFromIP(ip net.IP) Address {
	var addr Address
	copy(addr[:], ip)
	return addr
}

```

`pkg/network/dns.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
	"errors"
	"expvar"
	"net"
	"sync"
	"time"
)

// ErrMaxNamesReached is thrown when the capacity of the names map is reached
var ErrMaxNamesReached = errors.New("dns reverse max names reached")

var (
	totalDNSLookups     = expvar.NewInt("dns.reverse.total.lookups")
	failedDNSLookups    = expvar.NewMap("dns.reverse.failed.lookups")
	expiredDNSNames     = expvar.NewInt("dns.reverse.expired.names")
	totalDNSNames       = expvar.NewInt("dns.reverse.total.names")
	cacheFullDNSLookups = expvar.NewInt("dns.reverse.cache.full.lookups")
)

// maxFailedDNSLookups designates the maximum number of failed DNS lookups
// after which the IP address is blacklisted
const maxFailedDNSLookups = 10

// ReverseDNS performs reverse DNS resolutions and keeps the cache of
// resolved IP to domain mappings.
type ReverseDNS struct {
	mux sync.Mutex
	// ttl specifies the time to live for each cache entry
	ttl time.Duration
	// size determines the maximum size of the domains cache
	size int

	domains map[Address]*dnsNames

	// blacklist contains the IP addresses that fail
	// to resolve after a number of attempts. We want to defend
	// ourselves from excessive reverse DNS lookup calls
	blacklist map[Address]int
	close     chan struct{}
}

type dnsNames struct {
	names      []string
	expiration int64
}

// NewReverseDNS creates a new DNS reverser with the specified size and TTL period.
func NewReverseDNS(size int, ttl, exp time.Duration) *ReverseDNS {
	reverseDNS := &ReverseDNS{
		domains:   make(map[Address]*dnsNames),
		blacklist: make(map[Address]int),
		size:      size,
		ttl:       ttl,
		close:     make(chan struct{}, 1),
	}

	tick := time.NewTicker(exp)
	go func() {
		for {
			select {
			case <-tick.C:
				reverseDNS.Expire()
			case <-reverseDNS.close:
				tick.Stop()
				return
			}
		}
	}()
	return reverseDNS
}

// Add performs a reverse lookup for the given address, returning a list
// of names mapping to that address. It assigns a ttl to the names value
// and puts it in the map. If the names map capacity is reached this method
// returns an error and gives up on adding new entries.
func (r *ReverseDNS) Add(addr Address) ([]string, error) {
	r.mux.Lock()
	defer r.mux.Unlock()

	if len(r.domains) > r.size {
		cacheFullDNSLookups.Add(1)
		return nil, ErrMaxNamesReached
	}

	if r.blacklist[addr] > maxFailedDNSLookups {
		return nil, nil
	}

	if names, ok := r.domains[addr]; ok {
		return names.names, nil
	}

	now := time.Now()
	exp := now.Add(r.ttl).UnixNano()
	names, err := net.LookupAddr(addr.ToIPString())
	if err != nil {
		r.blacklist[addr]++
		failedDNSLookups.Add(addr.ToIPString(), 1)
		return nil, err
	}

	totalDNSLookups.Add(1)
	totalDNSNames.Add(1)

	r.domains[addr] = &dnsNames{names: names, expiration: exp}

	return names, nil
}

// Get returns all the name mappings for the specified address.
func (r *ReverseDNS) Get(addr Address) []string {
	r.mux.Lock()
	defer r.mux.Unlock()

	names, ok := r.domains[addr]
	if !ok {
		return nil
	}

	return names.names
}

// Expire evicts name values that are eligible for expiration.
func (r *ReverseDNS) Expire() {
	deadline := time.Now().UnixNano()
	expired := int64(0)
	r.mux.Lock()

	for addr, val := range r.domains {
		if val.expiration > deadline {
			continue
		}
		expired++
		delete(r.domains, addr)
	}
	r.mux.Unlock()

	expiredDNSNames.Add(expired)
	totalDNSNames.Add(-expired)
}

// Len returns the size of the names map.
func (r *ReverseDNS) Len() int {
	r.mux.Lock()
	defer r.mux.Unlock()
	return len(r.domains)
}

// Close closes the expiration ticker.
func (r *ReverseDNS) Close() {
	r.close <- struct{}{}
}

```

`pkg/network/dns_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
	"time"
)

func TestLookupAddr(t *testing.T) {
	reverseDNS := NewReverseDNS(100, time.Minute, time.Minute)
	names, err := reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))

	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
	assert.Equal(t, reverseDNS.Len(), 1)

	names, err = reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
}

func TestLookupAddrBlacklisted(t *testing.T) {
	reverseDNS := NewReverseDNS(100, time.Minute, time.Minute)
	for i := 0; i < maxFailedDNSLookups+1; i++ {
		_, err := reverseDNS.Add(AddressFromIP(net.ParseIP("1.2.3.1")))
		require.Error(t, err)
	}
	_, err := reverseDNS.Add(AddressFromIP(net.ParseIP("1.2.3.1")))
	require.NoError(t, err)
}

func TestLookupAddrExpiration(t *testing.T) {
	reverseDNS := NewReverseDNS(100, time.Millisecond*5, time.Minute)

	names, err := reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))

	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
	assert.Equal(t, reverseDNS.Len(), 1)

	time.Sleep(time.Millisecond * 10)
	reverseDNS.Expire()
	assert.Equal(t, reverseDNS.Len(), 0)

	names, err = reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
}

func TestLookupAddrTickerExpiration(t *testing.T) {
	reverseDNS := NewReverseDNS(100, time.Millisecond*50, time.Millisecond*80)

	names, err := reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
	assert.True(t, reverseDNS.Len() == 1)

	time.Sleep(time.Millisecond * 125)

	assert.Empty(t, reverseDNS.Get(AddressFromIP(net.ParseIP("8.8.8.8"))))
	assert.True(t, reverseDNS.Len() == 0)
}

```

`pkg/network/types.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

// L4Proto is the type alias for the Layer 4 protocol.
type L4Proto uint8

const (
	// TCP identifies TCP Layer 4 protocol.
	TCP L4Proto = iota + 1
	// UDP identifies UDP Layer 4 protocol.
	UDP
)

// String returns the string representation of the Layer 4 protocol.
func (proto L4Proto) String() string {
	switch proto {
	case TCP:
		return "tcp"
	case UDP:
		return "udp"
	default:
		return "unknown"
	}
}

```

`pkg/outputs/amqp/_fixtures/garagemq/README.md`:

```md
This is the minimal [GarageMQ](https://github.com/valinurovam/garagemq) server merely used for testing the AMQP output.
```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/constants_generated.go`:

```go
// Package amqp for read, write, parse amqp frames
// Autogenerated code. Do not edit.
package amqp

// FrameMethod identifier
const FrameMethod = 1

// FrameHeader identifier
const FrameHeader = 2

// FrameBody identifier
const FrameBody = 3

// FrameHeartbeat identifier
const FrameHeartbeat = 8

// FrameMinSize identifier
const FrameMinSize = 4096

// FrameEnd identifier
const FrameEnd = 206

// ReplySuccess identifier Indicates that the method completed successfully. This reply code is
// reserved for future use - the current protocol design does not use positive
// confirmation and reply codes are sent only in case of an error.
const ReplySuccess = 200

// ContentTooLarge identifier The client attempted to transfer content larger than the server could accept
// at the present time. The client may retry at a later time.
const ContentTooLarge = 311

// NoConsumers identifier When the exchange cannot deliver to a consumer when the immediate flag is
// set. As a result of pending data on the queue or the absence of any
// consumers of the queue.
const NoConsumers = 313

// ConnectionForced identifier An operator intervened to close the connection for some reason. The client
// may retry at some later date.
const ConnectionForced = 320

// InvalidPath identifier The client tried to work with an unknown virtual host.
const InvalidPath = 402

// AccessRefused identifier The client attempted to work with a server entity to which it has no
// access due to security settings.
const AccessRefused = 403

// NotFound identifier The client attempted to work with a server entity that does not exist.
const NotFound = 404

// ResourceLocked identifier The client attempted to work with a server entity to which it has no
// access because another client is working with it.
const ResourceLocked = 405

// PreconditionFailed identifier The client requested a method that was not allowed because some precondition
// failed.
const PreconditionFailed = 406

// FrameError identifier The sender sent a malformed frame that the recipient could not decode.
// This strongly implies a programming error in the sending peer.
const FrameError = 501

// SyntaxError identifier The sender sent a frame that contained illegal values for one or more
// fields. This strongly implies a programming error in the sending peer.
const SyntaxError = 502

// CommandInvalid identifier The client sent an invalid sequence of frames, attempting to perform an
// operation that was considered invalid by the server. This usually implies
// a programming error in the client.
const CommandInvalid = 503

// ChannelError identifier The client attempted to work with a channel that had not been correctly
// opened. This most likely indicates a fault in the client layer.
const ChannelError = 504

// UnexpectedFrame identifier The peer sent a frame that was not expected, usually in the context of
// a content header and body.  This strongly indicates a fault in the peer's
// content processing.
const UnexpectedFrame = 505

// ResourceError identifier The server could not complete the method because it lacked sufficient
// resources. This may be due to the client creating too many of some type
// of entity.
const ResourceError = 506

// NotAllowed identifier The client tried to work with some entity in a manner that is prohibited
// by the server, due to security settings or by some other criteria.
const NotAllowed = 530

// NotImplemented identifier The client tried to use functionality that is not implemented in the
// server.
const NotImplemented = 540

// InternalError identifier The server could not complete the method because of an internal error.
// The server may require intervention by an operator in order to resume
// normal operations.
const InternalError = 541

// ClassConnection identifier
const ClassConnection = 10

// MethodConnectionStart identifier
const MethodConnectionStart = 10

// MethodConnectionStartOk identifier
const MethodConnectionStartOk = 11

// MethodConnectionSecure identifier
const MethodConnectionSecure = 20

// MethodConnectionSecureOk identifier
const MethodConnectionSecureOk = 21

// MethodConnectionTune identifier
const MethodConnectionTune = 30

// MethodConnectionTuneOk identifier
const MethodConnectionTuneOk = 31

// MethodConnectionOpen identifier
const MethodConnectionOpen = 40

// MethodConnectionOpenOk identifier
const MethodConnectionOpenOk = 41

// MethodConnectionClose identifier
const MethodConnectionClose = 50

// MethodConnectionCloseOk identifier
const MethodConnectionCloseOk = 51

// MethodConnectionBlocked identifier
const MethodConnectionBlocked = 60

// MethodConnectionUnblocked identifier
const MethodConnectionUnblocked = 61

// ClassChannel identifier
const ClassChannel = 20

// MethodChannelOpen identifier
const MethodChannelOpen = 10

// MethodChannelOpenOk identifier
const MethodChannelOpenOk = 11

// MethodChannelFlow identifier
const MethodChannelFlow = 20

// MethodChannelFlowOk identifier
const MethodChannelFlowOk = 21

// MethodChannelClose identifier
const MethodChannelClose = 40

// MethodChannelCloseOk identifier
const MethodChannelCloseOk = 41

// ClassExchange identifier
const ClassExchange = 40

// MethodExchangeDeclare identifier
const MethodExchangeDeclare = 10

// MethodExchangeDeclareOk identifier
const MethodExchangeDeclareOk = 11

// MethodExchangeDelete identifier
const MethodExchangeDelete = 20

// MethodExchangeDeleteOk identifier
const MethodExchangeDeleteOk = 21

// MethodExchangeBind identifier
const MethodExchangeBind = 30

// MethodExchangeBindOk identifier
const MethodExchangeBindOk = 31

// MethodExchangeUnbind identifier
const MethodExchangeUnbind = 40

// MethodExchangeUnbindOk identifier
const MethodExchangeUnbindOk = 51

// ClassQueue identifier
const ClassQueue = 50

// MethodQueueDeclare identifier
const MethodQueueDeclare = 10

// MethodQueueDeclareOk identifier
const MethodQueueDeclareOk = 11

// MethodQueueBind identifier
const MethodQueueBind = 20

// MethodQueueBindOk identifier
const MethodQueueBindOk = 21

// MethodQueueUnbind identifier
const MethodQueueUnbind = 50

// MethodQueueUnbindOk identifier
const MethodQueueUnbindOk = 51

// MethodQueuePurge identifier
const MethodQueuePurge = 30

// MethodQueuePurgeOk identifier
const MethodQueuePurgeOk = 31

// MethodQueueDelete identifier
const MethodQueueDelete = 40

// MethodQueueDeleteOk identifier
const MethodQueueDeleteOk = 41

// ClassBasic identifier
const ClassBasic = 60

// MethodBasicQos identifier
const MethodBasicQos = 10

// MethodBasicQosOk identifier
const MethodBasicQosOk = 11

// MethodBasicConsume identifier
const MethodBasicConsume = 20

// MethodBasicConsumeOk identifier
const MethodBasicConsumeOk = 21

// MethodBasicCancel identifier
const MethodBasicCancel = 30

// MethodBasicCancelOk identifier
const MethodBasicCancelOk = 31

// MethodBasicPublish identifier
const MethodBasicPublish = 40

// MethodBasicReturn identifier
const MethodBasicReturn = 50

// MethodBasicDeliver identifier
const MethodBasicDeliver = 60

// MethodBasicGet identifier
const MethodBasicGet = 70

// MethodBasicGetOk identifier
const MethodBasicGetOk = 71

// MethodBasicGetEmpty identifier
const MethodBasicGetEmpty = 72

// MethodBasicAck identifier
const MethodBasicAck = 80

// MethodBasicReject identifier
const MethodBasicReject = 90

// MethodBasicRecoverAsync identifier
const MethodBasicRecoverAsync = 100

// MethodBasicRecover identifier
const MethodBasicRecover = 110

// MethodBasicRecoverOk identifier
const MethodBasicRecoverOk = 111

// MethodBasicNack identifier
const MethodBasicNack = 120

// ClassTx identifier
const ClassTx = 90

// MethodTxSelect identifier
const MethodTxSelect = 10

// MethodTxSelectOk identifier
const MethodTxSelectOk = 11

// MethodTxCommit identifier
const MethodTxCommit = 20

// MethodTxCommitOk identifier
const MethodTxCommitOk = 21

// MethodTxRollback identifier
const MethodTxRollback = 30

// MethodTxRollbackOk identifier
const MethodTxRollbackOk = 31

// ClassConfirm identifier
const ClassConfirm = 85

// MethodConfirmSelect identifier
const MethodConfirmSelect = 10

// MethodConfirmSelectOk identifier
const MethodConfirmSelectOk = 11

// ConstantsNameMap map for mapping error codes into error messages
var ConstantsNameMap = map[uint16]string{

	1: "FRAME_METHOD",

	2: "FRAME_HEADER",

	3: "FRAME_BODY",

	8: "FRAME_HEARTBEAT",

	4096: "FRAME_MIN_SIZE",

	206: "FRAME_END",

	200: "REPLY_SUCCESS",

	311: "CONTENT_TOO_LARGE",

	313: "NO_CONSUMERS",

	320: "CONNECTION_FORCED",

	402: "INVALID_PATH",

	403: "ACCESS_REFUSED",

	404: "NOT_FOUND",

	405: "RESOURCE_LOCKED",

	406: "PRECONDITION_FAILED",

	501: "FRAME_ERROR",

	502: "SYNTAX_ERROR",

	503: "COMMAND_INVALID",

	504: "CHANNEL_ERROR",

	505: "UNEXPECTED_FRAME",

	506: "RESOURCE_ERROR",

	530: "NOT_ALLOWED",

	540: "NOT_IMPLEMENTED",

	541: "INTERNAL_ERROR",
}

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/extended_constants.go`:

```go
package amqp

// NoRoute returns when a 'mandatory' message cannot be delivered to any queue.
// @see https://www.rabbitmq.com/amqp-0-9-1-errata.html#section_17
const NoRoute = 312

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/methods_generated.go`:

```go
// Package amqp for read, write, parse amqp frames
// Autogenerated code. Do not edit.
package amqp

import (
	"fmt"
	"io"
	"time"
)

// Method represents base method interface
type Method interface {
	Name() string
	FrameType() byte
	ClassIdentifier() uint16
	MethodIdentifier() uint16
	Read(reader io.Reader, protoVersion string) (err error)
	Write(writer io.Writer, protoVersion string) (err error)
	Sync() bool
}

// Connection methods

// ConnectionStart This method starts the connection negotiation process by telling the client the
// protocol version that the server proposes, along with a list of security mechanisms
// which the client can use for authentication.
type ConnectionStart struct {
	VersionMajor     byte
	VersionMinor     byte
	ServerProperties *Table
	Mechanisms       []byte
	Locales          []byte
}

// Name returns method name as string, usefully for logging
func (method *ConnectionStart) Name() string {
	return "ConnectionStart"
}

// FrameType returns method frame type
func (method *ConnectionStart) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionStart) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionStart) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ConnectionStart) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionStart) Read(reader io.Reader, protoVersion string) (err error) {

	method.VersionMajor, err = ReadOctet(reader)
	if err != nil {
		return err
	}

	method.VersionMinor, err = ReadOctet(reader)
	if err != nil {
		return err
	}

	method.ServerProperties, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	method.Mechanisms, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	method.Locales, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionStart) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteOctet(writer, method.VersionMajor); err != nil {
		return err
	}

	if err = WriteOctet(writer, method.VersionMinor); err != nil {
		return err
	}

	if err = WriteTable(writer, method.ServerProperties, protoVersion); err != nil {
		return err
	}

	if err = WriteLongstr(writer, method.Mechanisms); err != nil {
		return err
	}

	if err = WriteLongstr(writer, method.Locales); err != nil {
		return err
	}

	return
}

// ConnectionStartOk This method selects a SASL security mechanism.
type ConnectionStartOk struct {
	ClientProperties *Table
	Mechanism        string
	Response         []byte
	Locale           string
}

// Name returns method name as string, usefully for logging
func (method *ConnectionStartOk) Name() string {
	return "ConnectionStartOk"
}

// FrameType returns method frame type
func (method *ConnectionStartOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionStartOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionStartOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ConnectionStartOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionStartOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ClientProperties, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	method.Mechanism, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Response, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	method.Locale, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionStartOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteTable(writer, method.ClientProperties, protoVersion); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Mechanism); err != nil {
		return err
	}

	if err = WriteLongstr(writer, method.Response); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Locale); err != nil {
		return err
	}

	return
}

// ConnectionSecure The SASL protocol works by exchanging challenges and responses until both peers have
// received sufficient information to authenticate each other. This method challenges
// the client to provide more information.
type ConnectionSecure struct {
	Challenge []byte
}

// Name returns method name as string, usefully for logging
func (method *ConnectionSecure) Name() string {
	return "ConnectionSecure"
}

// FrameType returns method frame type
func (method *ConnectionSecure) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionSecure) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionSecure) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *ConnectionSecure) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionSecure) Read(reader io.Reader, protoVersion string) (err error) {

	method.Challenge, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionSecure) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLongstr(writer, method.Challenge); err != nil {
		return err
	}

	return
}

// ConnectionSecureOk This method attempts to authenticate, passing a block of SASL data for the security
// mechanism at the server side.
type ConnectionSecureOk struct {
	Response []byte
}

// Name returns method name as string, usefully for logging
func (method *ConnectionSecureOk) Name() string {
	return "ConnectionSecureOk"
}

// FrameType returns method frame type
func (method *ConnectionSecureOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionSecureOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionSecureOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *ConnectionSecureOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionSecureOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Response, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionSecureOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLongstr(writer, method.Response); err != nil {
		return err
	}

	return
}

// ConnectionTune This method proposes a set of connection configuration values to the client. The
// client can accept and/or adjust these.
type ConnectionTune struct {
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

// Name returns method name as string, usefully for logging
func (method *ConnectionTune) Name() string {
	return "ConnectionTune"
}

// FrameType returns method frame type
func (method *ConnectionTune) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionTune) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionTune) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *ConnectionTune) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionTune) Read(reader io.Reader, protoVersion string) (err error) {

	method.ChannelMax, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.FrameMax, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.Heartbeat, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionTune) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ChannelMax); err != nil {
		return err
	}

	if err = WriteLong(writer, method.FrameMax); err != nil {
		return err
	}

	if err = WriteShort(writer, method.Heartbeat); err != nil {
		return err
	}

	return
}

// ConnectionTuneOk This method sends the client's connection tuning parameters to the server.
// Certain fields are negotiated, others provide capability information.
type ConnectionTuneOk struct {
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

// Name returns method name as string, usefully for logging
func (method *ConnectionTuneOk) Name() string {
	return "ConnectionTuneOk"
}

// FrameType returns method frame type
func (method *ConnectionTuneOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionTuneOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionTuneOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *ConnectionTuneOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionTuneOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ChannelMax, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.FrameMax, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.Heartbeat, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionTuneOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ChannelMax); err != nil {
		return err
	}

	if err = WriteLong(writer, method.FrameMax); err != nil {
		return err
	}

	if err = WriteShort(writer, method.Heartbeat); err != nil {
		return err
	}

	return
}

// ConnectionOpen This method opens a connection to a virtual host, which is a collection of
// resources, and acts to separate multiple application domains within a server.
// The server may apply arbitrary limits per virtual host, such as the number
// of each type of entity that may be used, per connection and/or in total.
type ConnectionOpen struct {
	VirtualHost string
	Reserved1   string
	Reserved2   bool
}

// Name returns method name as string, usefully for logging
func (method *ConnectionOpen) Name() string {
	return "ConnectionOpen"
}

// FrameType returns method frame type
func (method *ConnectionOpen) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionOpen) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionOpen) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *ConnectionOpen) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionOpen) Read(reader io.Reader, protoVersion string) (err error) {

	method.VirtualHost, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Reserved2 = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ConnectionOpen) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.VirtualHost); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	var bits byte

	if method.Reserved2 {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ConnectionOpenOk This method signals to the client that the connection is ready for use.
type ConnectionOpenOk struct {
	Reserved1 string
}

// Name returns method name as string, usefully for logging
func (method *ConnectionOpenOk) Name() string {
	return "ConnectionOpenOk"
}

// FrameType returns method frame type
func (method *ConnectionOpenOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionOpenOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionOpenOk) MethodIdentifier() uint16 {
	return 41
}

// Sync is method should me sent synchronous
func (method *ConnectionOpenOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionOpenOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionOpenOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// ConnectionClose This method indicates that the sender wants to close the connection. This may be
// due to internal conditions (e.g. a forced shut-down) or due to an error handling
// a specific method, i.e. an exception. When a close is due to an exception, the
// sender provides the class and method id of the method which caused the exception.
type ConnectionClose struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

// Name returns method name as string, usefully for logging
func (method *ConnectionClose) Name() string {
	return "ConnectionClose"
}

// FrameType returns method frame type
func (method *ConnectionClose) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionClose) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionClose) MethodIdentifier() uint16 {
	return 50
}

// Sync is method should me sent synchronous
func (method *ConnectionClose) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionClose) Read(reader io.Reader, protoVersion string) (err error) {

	method.ReplyCode, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.ReplyText, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.ClassID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.MethodID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionClose) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ReplyCode); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ReplyText); err != nil {
		return err
	}

	if err = WriteShort(writer, method.ClassID); err != nil {
		return err
	}

	if err = WriteShort(writer, method.MethodID); err != nil {
		return err
	}

	return
}

// ConnectionCloseOk This method confirms a Connection.Close method and tells the recipient that it is
// safe to release resources for the connection and close the socket.
type ConnectionCloseOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ConnectionCloseOk) Name() string {
	return "ConnectionCloseOk"
}

// FrameType returns method frame type
func (method *ConnectionCloseOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionCloseOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionCloseOk) MethodIdentifier() uint16 {
	return 51
}

// Sync is method should me sent synchronous
func (method *ConnectionCloseOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionCloseOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ConnectionCloseOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ConnectionBlocked This method indicates that a connection has been blocked
// and does not accept new publishes.
type ConnectionBlocked struct {
	Reason string
}

// Name returns method name as string, usefully for logging
func (method *ConnectionBlocked) Name() string {
	return "ConnectionBlocked"
}

// FrameType returns method frame type
func (method *ConnectionBlocked) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionBlocked) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionBlocked) MethodIdentifier() uint16 {
	return 60
}

// Sync is method should me sent synchronous
func (method *ConnectionBlocked) Sync() bool {
	return false
}

// Read method from io reader
func (method *ConnectionBlocked) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reason, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionBlocked) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reason); err != nil {
		return err
	}

	return
}

// ConnectionUnblocked This method indicates that a connection has been unblocked
// and now accepts publishes.
type ConnectionUnblocked struct {
}

// Name returns method name as string, usefully for logging
func (method *ConnectionUnblocked) Name() string {
	return "ConnectionUnblocked"
}

// FrameType returns method frame type
func (method *ConnectionUnblocked) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionUnblocked) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionUnblocked) MethodIdentifier() uint16 {
	return 61
}

// Sync is method should me sent synchronous
func (method *ConnectionUnblocked) Sync() bool {
	return false
}

// Read method from io reader
func (method *ConnectionUnblocked) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ConnectionUnblocked) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Channel methods

// ChannelOpen This method opens a channel to the server.
type ChannelOpen struct {
	Reserved1 string
}

// Name returns method name as string, usefully for logging
func (method *ChannelOpen) Name() string {
	return "ChannelOpen"
}

// FrameType returns method frame type
func (method *ChannelOpen) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelOpen) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelOpen) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ChannelOpen) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelOpen) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ChannelOpen) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// ChannelOpenOk This method signals to the client that the channel is ready for use.
type ChannelOpenOk struct {
	Reserved1 []byte
}

// Name returns method name as string, usefully for logging
func (method *ChannelOpenOk) Name() string {
	return "ChannelOpenOk"
}

// FrameType returns method frame type
func (method *ChannelOpenOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelOpenOk) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelOpenOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ChannelOpenOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelOpenOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ChannelOpenOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLongstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// ChannelFlow This method asks the peer to pause or restart the flow of content data sent by
// a consumer. This is a simple flow-control mechanism that a peer can use to avoid
// overflowing its queues or otherwise finding itself receiving more messages than
// it can process. Note that this method is not intended for window control. It does
// not affect contents returned by Basic.Get-Ok methods.
type ChannelFlow struct {
	Active bool
}

// Name returns method name as string, usefully for logging
func (method *ChannelFlow) Name() string {
	return "ChannelFlow"
}

// FrameType returns method frame type
func (method *ChannelFlow) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelFlow) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelFlow) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *ChannelFlow) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelFlow) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Active = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ChannelFlow) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Active {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ChannelFlowOk Confirms to the peer that a flow command was received and processed.
type ChannelFlowOk struct {
	Active bool
}

// Name returns method name as string, usefully for logging
func (method *ChannelFlowOk) Name() string {
	return "ChannelFlowOk"
}

// FrameType returns method frame type
func (method *ChannelFlowOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelFlowOk) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelFlowOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *ChannelFlowOk) Sync() bool {
	return false
}

// Read method from io reader
func (method *ChannelFlowOk) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Active = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ChannelFlowOk) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Active {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ChannelClose This method indicates that the sender wants to close the channel. This may be due to
// internal conditions (e.g. a forced shut-down) or due to an error handling a specific
// method, i.e. an exception. When a close is due to an exception, the sender provides
// the class and method id of the method which caused the exception.
type ChannelClose struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

// Name returns method name as string, usefully for logging
func (method *ChannelClose) Name() string {
	return "ChannelClose"
}

// FrameType returns method frame type
func (method *ChannelClose) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelClose) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelClose) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *ChannelClose) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelClose) Read(reader io.Reader, protoVersion string) (err error) {

	method.ReplyCode, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.ReplyText, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.ClassID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.MethodID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ChannelClose) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ReplyCode); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ReplyText); err != nil {
		return err
	}

	if err = WriteShort(writer, method.ClassID); err != nil {
		return err
	}

	if err = WriteShort(writer, method.MethodID); err != nil {
		return err
	}

	return
}

// ChannelCloseOk This method confirms a Channel.Close method and tells the recipient that it is safe
// to release resources for the channel.
type ChannelCloseOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ChannelCloseOk) Name() string {
	return "ChannelCloseOk"
}

// FrameType returns method frame type
func (method *ChannelCloseOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelCloseOk) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelCloseOk) MethodIdentifier() uint16 {
	return 41
}

// Sync is method should me sent synchronous
func (method *ChannelCloseOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelCloseOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ChannelCloseOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Exchange methods

// ExchangeDeclare This method creates an exchange if it does not already exist, and if the exchange
// exists, verifies that it is of the correct and expected class.
type ExchangeDeclare struct {
	Reserved1  uint16
	Exchange   string
	Type       string
	Passive    bool
	Durable    bool
	AutoDelete bool
	Internal   bool
	NoWait     bool
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDeclare) Name() string {
	return "ExchangeDeclare"
}

// FrameType returns method frame type
func (method *ExchangeDeclare) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDeclare) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDeclare) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ExchangeDeclare) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDeclare) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Type, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Passive = bits&(1<<0) != 0

	method.Durable = bits&(1<<1) != 0

	method.AutoDelete = bits&(1<<2) != 0

	method.Internal = bits&(1<<3) != 0

	method.NoWait = bits&(1<<4) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ExchangeDeclare) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Type); err != nil {
		return err
	}

	var bits byte

	if method.Passive {
		bits |= 1 << 0
	}

	if method.Durable {
		bits |= 1 << 1
	}

	if method.AutoDelete {
		bits |= 1 << 2
	}

	if method.Internal {
		bits |= 1 << 3
	}

	if method.NoWait {
		bits |= 1 << 4
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// ExchangeDeclareOk This method confirms a Declare method and confirms the name of the exchange,
// essential for automatically-named exchanges.
type ExchangeDeclareOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDeclareOk) Name() string {
	return "ExchangeDeclareOk"
}

// FrameType returns method frame type
func (method *ExchangeDeclareOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDeclareOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDeclareOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ExchangeDeclareOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDeclareOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeDeclareOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ExchangeDelete This method deletes an exchange. When an exchange is deleted all queue bindings on
// the exchange are cancelled.
type ExchangeDelete struct {
	Reserved1 uint16
	Exchange  string
	IfUnused  bool
	NoWait    bool
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDelete) Name() string {
	return "ExchangeDelete"
}

// FrameType returns method frame type
func (method *ExchangeDelete) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDelete) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDelete) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *ExchangeDelete) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDelete) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.IfUnused = bits&(1<<0) != 0

	method.NoWait = bits&(1<<1) != 0

	return
}

// Write method from io reader
func (method *ExchangeDelete) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	var bits byte

	if method.IfUnused {
		bits |= 1 << 0
	}

	if method.NoWait {
		bits |= 1 << 1
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ExchangeDeleteOk This method confirms the deletion of an exchange.
type ExchangeDeleteOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDeleteOk) Name() string {
	return "ExchangeDeleteOk"
}

// FrameType returns method frame type
func (method *ExchangeDeleteOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDeleteOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDeleteOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *ExchangeDeleteOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDeleteOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeDeleteOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ExchangeBind This method binds an exchange to an exchange.
type ExchangeBind struct {
	Reserved1   uint16
	Destination string
	Source      string
	RoutingKey  string
	NoWait      bool
	Arguments   *Table
}

// Name returns method name as string, usefully for logging
func (method *ExchangeBind) Name() string {
	return "ExchangeBind"
}

// FrameType returns method frame type
func (method *ExchangeBind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeBind) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeBind) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *ExchangeBind) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeBind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Destination, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Source, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ExchangeBind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Destination); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Source); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// ExchangeBindOk This method confirms that the bind was successful.
type ExchangeBindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeBindOk) Name() string {
	return "ExchangeBindOk"
}

// FrameType returns method frame type
func (method *ExchangeBindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeBindOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeBindOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *ExchangeBindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeBindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeBindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ExchangeUnbind This method unbinds an exchange from an exchange.
type ExchangeUnbind struct {
	Reserved1   uint16
	Destination string
	Source      string
	RoutingKey  string
	NoWait      bool
	Arguments   *Table
}

// Name returns method name as string, usefully for logging
func (method *ExchangeUnbind) Name() string {
	return "ExchangeUnbind"
}

// FrameType returns method frame type
func (method *ExchangeUnbind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeUnbind) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeUnbind) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *ExchangeUnbind) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeUnbind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Destination, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Source, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ExchangeUnbind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Destination); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Source); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// ExchangeUnbindOk This method confirms that the unbind was successful.
type ExchangeUnbindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeUnbindOk) Name() string {
	return "ExchangeUnbindOk"
}

// FrameType returns method frame type
func (method *ExchangeUnbindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeUnbindOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeUnbindOk) MethodIdentifier() uint16 {
	return 51
}

// Sync is method should me sent synchronous
func (method *ExchangeUnbindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeUnbindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeUnbindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Queue methods

// QueueDeclare This method creates or checks a queue. When creating a new queue the client can
// specify various properties that control the durability of the queue and its
// contents, and the level of sharing for the queue.
type QueueDeclare struct {
	Reserved1  uint16
	Queue      string
	Passive    bool
	Durable    bool
	Exclusive  bool
	AutoDelete bool
	NoWait     bool
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *QueueDeclare) Name() string {
	return "QueueDeclare"
}

// FrameType returns method frame type
func (method *QueueDeclare) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDeclare) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDeclare) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *QueueDeclare) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDeclare) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Passive = bits&(1<<0) != 0

	method.Durable = bits&(1<<1) != 0

	method.Exclusive = bits&(1<<2) != 0

	method.AutoDelete = bits&(1<<3) != 0

	method.NoWait = bits&(1<<4) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueDeclare) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.Passive {
		bits |= 1 << 0
	}

	if method.Durable {
		bits |= 1 << 1
	}

	if method.Exclusive {
		bits |= 1 << 2
	}

	if method.AutoDelete {
		bits |= 1 << 3
	}

	if method.NoWait {
		bits |= 1 << 4
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// QueueDeclareOk This method confirms a Declare method and confirms the name of the queue, essential
// for automatically-named queues.
type QueueDeclareOk struct {
	Queue         string
	MessageCount  uint32
	ConsumerCount uint32
}

// Name returns method name as string, usefully for logging
func (method *QueueDeclareOk) Name() string {
	return "QueueDeclareOk"
}

// FrameType returns method frame type
func (method *QueueDeclareOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDeclareOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDeclareOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *QueueDeclareOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDeclareOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.ConsumerCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueDeclareOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	if err = WriteLong(writer, method.ConsumerCount); err != nil {
		return err
	}

	return
}

// QueueBind This method binds a queue to an exchange. Until a queue is bound it will not
// receive any messages. In a classic messaging model, store-and-forward queues
// are bound to a direct exchange and subscription queues are bound to a topic
// exchange.
type QueueBind struct {
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	NoWait     bool
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *QueueBind) Name() string {
	return "QueueBind"
}

// FrameType returns method frame type
func (method *QueueBind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueBind) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueBind) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *QueueBind) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueBind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueBind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// QueueBindOk This method confirms that the bind was successful.
type QueueBindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *QueueBindOk) Name() string {
	return "QueueBindOk"
}

// FrameType returns method frame type
func (method *QueueBindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueBindOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueBindOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *QueueBindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueBindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *QueueBindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// QueueUnbind This method unbinds a queue from an exchange.
type QueueUnbind struct {
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *QueueUnbind) Name() string {
	return "QueueUnbind"
}

// FrameType returns method frame type
func (method *QueueUnbind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueUnbind) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueUnbind) MethodIdentifier() uint16 {
	return 50
}

// Sync is method should me sent synchronous
func (method *QueueUnbind) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueUnbind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueUnbind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// QueueUnbindOk This method confirms that the unbind was successful.
type QueueUnbindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *QueueUnbindOk) Name() string {
	return "QueueUnbindOk"
}

// FrameType returns method frame type
func (method *QueueUnbindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueUnbindOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueUnbindOk) MethodIdentifier() uint16 {
	return 51
}

// Sync is method should me sent synchronous
func (method *QueueUnbindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueUnbindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *QueueUnbindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// QueuePurge This method removes all messages from a queue which are not awaiting
// acknowledgment.
type QueuePurge struct {
	Reserved1 uint16
	Queue     string
	NoWait    bool
}

// Name returns method name as string, usefully for logging
func (method *QueuePurge) Name() string {
	return "QueuePurge"
}

// FrameType returns method frame type
func (method *QueuePurge) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueuePurge) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueuePurge) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *QueuePurge) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueuePurge) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *QueuePurge) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// QueuePurgeOk This method confirms the purge of a queue.
type QueuePurgeOk struct {
	MessageCount uint32
}

// Name returns method name as string, usefully for logging
func (method *QueuePurgeOk) Name() string {
	return "QueuePurgeOk"
}

// FrameType returns method frame type
func (method *QueuePurgeOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueuePurgeOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueuePurgeOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *QueuePurgeOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueuePurgeOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueuePurgeOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	return
}

// QueueDelete This method deletes a queue. When a queue is deleted any pending messages are sent
// to a dead-letter queue if this is defined in the server configuration, and all
// consumers on the queue are cancelled.
type QueueDelete struct {
	Reserved1 uint16
	Queue     string
	IfUnused  bool
	IfEmpty   bool
	NoWait    bool
}

// Name returns method name as string, usefully for logging
func (method *QueueDelete) Name() string {
	return "QueueDelete"
}

// FrameType returns method frame type
func (method *QueueDelete) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDelete) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDelete) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *QueueDelete) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDelete) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.IfUnused = bits&(1<<0) != 0

	method.IfEmpty = bits&(1<<1) != 0

	method.NoWait = bits&(1<<2) != 0

	return
}

// Write method from io reader
func (method *QueueDelete) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.IfUnused {
		bits |= 1 << 0
	}

	if method.IfEmpty {
		bits |= 1 << 1
	}

	if method.NoWait {
		bits |= 1 << 2
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// QueueDeleteOk This method confirms the deletion of a queue.
type QueueDeleteOk struct {
	MessageCount uint32
}

// Name returns method name as string, usefully for logging
func (method *QueueDeleteOk) Name() string {
	return "QueueDeleteOk"
}

// FrameType returns method frame type
func (method *QueueDeleteOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDeleteOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDeleteOk) MethodIdentifier() uint16 {
	return 41
}

// Sync is method should me sent synchronous
func (method *QueueDeleteOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDeleteOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueDeleteOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	return
}

// Basic methods

// BasicPropertyList represents properties for Basic method
type BasicPropertyList struct {
	ContentType     *string
	ContentEncoding *string
	Headers         *Table
	DeliveryMode    *byte
	Priority        *byte
	CorrelationID   *string
	ReplyTo         *string
	Expiration      *string
	MessageID       *string
	Timestamp       *time.Time
	Type            *string
	UserID          *string
	AppID           *string
	Reserved        *string
}

// BasicPropertyList reads properties from io reader
func (pList *BasicPropertyList) Read(reader io.Reader, propertyFlags uint16, protoVersion string) (err error) {

	if propertyFlags&(1<<15) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.ContentType = &value
	}

	if propertyFlags&(1<<14) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.ContentEncoding = &value
	}

	if propertyFlags&(1<<13) != 0 {
		value, err := ReadTable(reader, protoVersion)
		if err != nil {
			return err
		}
		pList.Headers = value
	}

	if propertyFlags&(1<<12) != 0 {
		value, err := ReadOctet(reader)
		if err != nil {
			return err
		}
		pList.DeliveryMode = &value
	}

	if propertyFlags&(1<<11) != 0 {
		value, err := ReadOctet(reader)
		if err != nil {
			return err
		}
		pList.Priority = &value
	}

	if propertyFlags&(1<<10) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.CorrelationID = &value
	}

	if propertyFlags&(1<<9) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.ReplyTo = &value
	}

	if propertyFlags&(1<<8) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.Expiration = &value
	}

	if propertyFlags&(1<<7) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.MessageID = &value
	}

	if propertyFlags&(1<<6) != 0 {
		value, err := ReadTimestamp(reader)
		if err != nil {
			return err
		}
		pList.Timestamp = &value
	}

	if propertyFlags&(1<<5) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.Type = &value
	}

	if propertyFlags&(1<<4) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.UserID = &value
	}

	if propertyFlags&(1<<3) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.AppID = &value
	}

	if propertyFlags&(1<<2) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.Reserved = &value
	}

	return
}

// BasicPropertyList wiretes properties into io writer
func (pList *BasicPropertyList) Write(writer io.Writer, protoVersion string) (propertyFlags uint16, err error) {

	if pList.ContentType != nil {
		propertyFlags |= 1 << 15
		if err = WriteShortstr(writer, *pList.ContentType); err != nil {
			return
		}
	}

	if pList.ContentEncoding != nil {
		propertyFlags |= 1 << 14
		if err = WriteShortstr(writer, *pList.ContentEncoding); err != nil {
			return
		}
	}

	if pList.Headers != nil {
		propertyFlags |= 1 << 13
		if err = WriteTable(writer, pList.Headers, protoVersion); err != nil {
			return
		}
	}

	if pList.DeliveryMode != nil {
		propertyFlags |= 1 << 12
		if err = WriteOctet(writer, *pList.DeliveryMode); err != nil {
			return
		}
	}

	if pList.Priority != nil {
		propertyFlags |= 1 << 11
		if err = WriteOctet(writer, *pList.Priority); err != nil {
			return
		}
	}

	if pList.CorrelationID != nil {
		propertyFlags |= 1 << 10
		if err = WriteShortstr(writer, *pList.CorrelationID); err != nil {
			return
		}
	}

	if pList.ReplyTo != nil {
		propertyFlags |= 1 << 9
		if err = WriteShortstr(writer, *pList.ReplyTo); err != nil {
			return
		}
	}

	if pList.Expiration != nil {
		propertyFlags |= 1 << 8
		if err = WriteShortstr(writer, *pList.Expiration); err != nil {
			return
		}
	}

	if pList.MessageID != nil {
		propertyFlags |= 1 << 7
		if err = WriteShortstr(writer, *pList.MessageID); err != nil {
			return
		}
	}

	if pList.Timestamp != nil {
		propertyFlags |= 1 << 6
		if err = WriteTimestamp(writer, *pList.Timestamp); err != nil {
			return
		}
	}

	if pList.Type != nil {
		propertyFlags |= 1 << 5
		if err = WriteShortstr(writer, *pList.Type); err != nil {
			return
		}
	}

	if pList.UserID != nil {
		propertyFlags |= 1 << 4
		if err = WriteShortstr(writer, *pList.UserID); err != nil {
			return
		}
	}

	if pList.AppID != nil {
		propertyFlags |= 1 << 3
		if err = WriteShortstr(writer, *pList.AppID); err != nil {
			return
		}
	}

	if pList.Reserved != nil {
		propertyFlags |= 1 << 2
		if err = WriteShortstr(writer, *pList.Reserved); err != nil {
			return
		}
	}

	return
}

// BasicQos This method requests a specific quality of service. The QoS can be specified for the
// current channel or for all channels on the connection. The particular properties and
// semantics of a qos method always depend on the content class semantics. Though the
// qos method could in principle apply to both peers, it is currently meaningful only
// for the server.
type BasicQos struct {
	PrefetchSize  uint32
	PrefetchCount uint16
	Global        bool
}

// Name returns method name as string, usefully for logging
func (method *BasicQos) Name() string {
	return "BasicQos"
}

// FrameType returns method frame type
func (method *BasicQos) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicQos) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicQos) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *BasicQos) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicQos) Read(reader io.Reader, protoVersion string) (err error) {

	method.PrefetchSize, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.PrefetchCount, err = ReadShort(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Global = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicQos) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLong(writer, method.PrefetchSize); err != nil {
		return err
	}

	if err = WriteShort(writer, method.PrefetchCount); err != nil {
		return err
	}

	var bits byte

	if method.Global {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicQosOk This method tells the client that the requested QoS levels could be handled by the
// server. The requested QoS applies to all active consumers until a new QoS is
// defined.
type BasicQosOk struct {
}

// Name returns method name as string, usefully for logging
func (method *BasicQosOk) Name() string {
	return "BasicQosOk"
}

// FrameType returns method frame type
func (method *BasicQosOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicQosOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicQosOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *BasicQosOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicQosOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *BasicQosOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// BasicConsume This method asks the server to start a "consumer", which is a transient request for
// messages from a specific queue. Consumers last as long as the channel they were
// declared on, or until the client cancels them.
type BasicConsume struct {
	Reserved1   uint16
	Queue       string
	ConsumerTag string
	NoLocal     bool
	NoAck       bool
	Exclusive   bool
	NoWait      bool
	Arguments   *Table
}

// Name returns method name as string, usefully for logging
func (method *BasicConsume) Name() string {
	return "BasicConsume"
}

// FrameType returns method frame type
func (method *BasicConsume) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicConsume) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicConsume) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *BasicConsume) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicConsume) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoLocal = bits&(1<<0) != 0

	method.NoAck = bits&(1<<1) != 0

	method.Exclusive = bits&(1<<2) != 0

	method.NoWait = bits&(1<<3) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicConsume) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	var bits byte

	if method.NoLocal {
		bits |= 1 << 0
	}

	if method.NoAck {
		bits |= 1 << 1
	}

	if method.Exclusive {
		bits |= 1 << 2
	}

	if method.NoWait {
		bits |= 1 << 3
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// BasicConsumeOk The server provides the client with a consumer tag, which is used by the client
// for methods called on the consumer at a later stage.
type BasicConsumeOk struct {
	ConsumerTag string
}

// Name returns method name as string, usefully for logging
func (method *BasicConsumeOk) Name() string {
	return "BasicConsumeOk"
}

// FrameType returns method frame type
func (method *BasicConsumeOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicConsumeOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicConsumeOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *BasicConsumeOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicConsumeOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicConsumeOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	return
}

// BasicCancel This method cancels a consumer. This does not affect already delivered
// messages, but it does mean the server will not send any more messages for
// that consumer. The client may receive an arbitrary number of messages in
// between sending the cancel method and receiving the cancel-ok reply.
//
// It may also be sent from the server to the client in the event
// of the consumer being unexpectedly cancelled (i.e. cancelled
// for any reason other than the server receiving the
// corresponding basic.cancel from the client). This allows
// clients to be notified of the loss of consumers due to events
// such as queue deletion. Note that as it is not a MUST for
// clients to accept this method from the client, it is advisable
// for the broker to be able to identify those clients that are
// capable of accepting the method, through some means of
// capability negotiation.
type BasicCancel struct {
	ConsumerTag string
	NoWait      bool
}

// Name returns method name as string, usefully for logging
func (method *BasicCancel) Name() string {
	return "BasicCancel"
}

// FrameType returns method frame type
func (method *BasicCancel) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicCancel) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicCancel) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *BasicCancel) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicCancel) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicCancel) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicCancelOk This method confirms that the cancellation was completed.
type BasicCancelOk struct {
	ConsumerTag string
}

// Name returns method name as string, usefully for logging
func (method *BasicCancelOk) Name() string {
	return "BasicCancelOk"
}

// FrameType returns method frame type
func (method *BasicCancelOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicCancelOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicCancelOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *BasicCancelOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicCancelOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicCancelOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	return
}

// BasicPublish This method publishes a message to a specific exchange. The message will be routed
// to queues as defined by the exchange configuration and distributed to any active
// consumers when the transaction, if any, is committed.
type BasicPublish struct {
	Reserved1  uint16
	Exchange   string
	RoutingKey string
	Mandatory  bool
	Immediate  bool
}

// Name returns method name as string, usefully for logging
func (method *BasicPublish) Name() string {
	return "BasicPublish"
}

// FrameType returns method frame type
func (method *BasicPublish) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicPublish) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicPublish) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *BasicPublish) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicPublish) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Mandatory = bits&(1<<0) != 0

	method.Immediate = bits&(1<<1) != 0

	return
}

// Write method from io reader
func (method *BasicPublish) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.Mandatory {
		bits |= 1 << 0
	}

	if method.Immediate {
		bits |= 1 << 1
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicReturn This method returns an undeliverable message that was published with the "immediate"
// flag set, or an unroutable message published with the "mandatory" flag set. The
// reply code and text provide information about the reason that the message was
// undeliverable.
type BasicReturn struct {
	ReplyCode  uint16
	ReplyText  string
	Exchange   string
	RoutingKey string
}

// Name returns method name as string, usefully for logging
func (method *BasicReturn) Name() string {
	return "BasicReturn"
}

// FrameType returns method frame type
func (method *BasicReturn) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicReturn) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicReturn) MethodIdentifier() uint16 {
	return 50
}

// Sync is method should me sent synchronous
func (method *BasicReturn) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicReturn) Read(reader io.Reader, protoVersion string) (err error) {

	method.ReplyCode, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.ReplyText, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicReturn) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ReplyCode); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ReplyText); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	return
}

// BasicDeliver This method delivers a message to the client, via a consumer. In the asynchronous
// message delivery model, the client starts a consumer using the Consume method, then
// the server responds with Deliver methods as and when messages arrive for that
// consumer.
type BasicDeliver struct {
	ConsumerTag string
	DeliveryTag uint64
	Redelivered bool
	Exchange    string
	RoutingKey  string
}

// Name returns method name as string, usefully for logging
func (method *BasicDeliver) Name() string {
	return "BasicDeliver"
}

// FrameType returns method frame type
func (method *BasicDeliver) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicDeliver) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicDeliver) MethodIdentifier() uint16 {
	return 60
}

// Sync is method should me sent synchronous
func (method *BasicDeliver) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicDeliver) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Redelivered = bits&(1<<0) != 0

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicDeliver) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Redelivered {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	return
}

// BasicGet This method provides a direct access to the messages in a queue using a synchronous
// dialogue that is designed for specific types of application where synchronous
// functionality is more important than performance.
type BasicGet struct {
	Reserved1 uint16
	Queue     string
	NoAck     bool
}

// Name returns method name as string, usefully for logging
func (method *BasicGet) Name() string {
	return "BasicGet"
}

// FrameType returns method frame type
func (method *BasicGet) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicGet) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicGet) MethodIdentifier() uint16 {
	return 70
}

// Sync is method should me sent synchronous
func (method *BasicGet) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicGet) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoAck = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicGet) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.NoAck {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicGetOk This method delivers a message to the client following a get method. A message
// delivered by 'get-ok' must be acknowledged unless the no-ack option was set in the
// get method.
type BasicGetOk struct {
	DeliveryTag  uint64
	Redelivered  bool
	Exchange     string
	RoutingKey   string
	MessageCount uint32
}

// Name returns method name as string, usefully for logging
func (method *BasicGetOk) Name() string {
	return "BasicGetOk"
}

// FrameType returns method frame type
func (method *BasicGetOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicGetOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicGetOk) MethodIdentifier() uint16 {
	return 71
}

// Sync is method should me sent synchronous
func (method *BasicGetOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicGetOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Redelivered = bits&(1<<0) != 0

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicGetOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Redelivered {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	return
}

// BasicGetEmpty This method tells the client that the queue has no messages available for the
// client.
type BasicGetEmpty struct {
	Reserved1 string
}

// Name returns method name as string, usefully for logging
func (method *BasicGetEmpty) Name() string {
	return "BasicGetEmpty"
}

// FrameType returns method frame type
func (method *BasicGetEmpty) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicGetEmpty) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicGetEmpty) MethodIdentifier() uint16 {
	return 72
}

// Sync is method should me sent synchronous
func (method *BasicGetEmpty) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicGetEmpty) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicGetEmpty) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// BasicAck When sent by the client, this method acknowledges one or more
// messages delivered via the Deliver or Get-Ok methods.
//
// When sent by server, this method acknowledges one or more
// messages published with the Publish method on a channel in
// confirm mode.
//
// The acknowledgement can be for a single message or a set of
// messages up to and including a specific message.
type BasicAck struct {
	DeliveryTag uint64
	Multiple    bool
}

// Name returns method name as string, usefully for logging
func (method *BasicAck) Name() string {
	return "BasicAck"
}

// FrameType returns method frame type
func (method *BasicAck) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicAck) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicAck) MethodIdentifier() uint16 {
	return 80
}

// Sync is method should me sent synchronous
func (method *BasicAck) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicAck) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Multiple = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicAck) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Multiple {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicReject This method allows a client to reject a message. It can be used to interrupt and
// cancel large incoming messages, or return untreatable messages to their original
// queue.
type BasicReject struct {
	DeliveryTag uint64
	Requeue     bool
}

// Name returns method name as string, usefully for logging
func (method *BasicReject) Name() string {
	return "BasicReject"
}

// FrameType returns method frame type
func (method *BasicReject) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicReject) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicReject) MethodIdentifier() uint16 {
	return 90
}

// Sync is method should me sent synchronous
func (method *BasicReject) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicReject) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Requeue = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicReject) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Requeue {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicRecoverAsync This method asks the server to redeliver all unacknowledged messages on a
// specified channel. Zero or more messages may be redelivered.  This method
// is deprecated in favour of the synchronous Recover/Recover-Ok.
type BasicRecoverAsync struct {
	Requeue bool
}

// Name returns method name as string, usefully for logging
func (method *BasicRecoverAsync) Name() string {
	return "BasicRecoverAsync"
}

// FrameType returns method frame type
func (method *BasicRecoverAsync) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicRecoverAsync) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicRecoverAsync) MethodIdentifier() uint16 {
	return 100
}

// Sync is method should me sent synchronous
func (method *BasicRecoverAsync) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicRecoverAsync) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Requeue = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicRecoverAsync) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Requeue {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicRecover This method asks the server to redeliver all unacknowledged messages on a
// specified channel. Zero or more messages may be redelivered.  This method
// replaces the asynchronous Recover.
type BasicRecover struct {
	Requeue bool
}

// Name returns method name as string, usefully for logging
func (method *BasicRecover) Name() string {
	return "BasicRecover"
}

// FrameType returns method frame type
func (method *BasicRecover) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicRecover) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicRecover) MethodIdentifier() uint16 {
	return 110
}

// Sync is method should me sent synchronous
func (method *BasicRecover) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicRecover) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Requeue = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicRecover) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Requeue {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicRecoverOk This method acknowledges a Basic.Recover method.
type BasicRecoverOk struct {
}

// Name returns method name as string, usefully for logging
func (method *BasicRecoverOk) Name() string {
	return "BasicRecoverOk"
}

// FrameType returns method frame type
func (method *BasicRecoverOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicRecoverOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicRecoverOk) MethodIdentifier() uint16 {
	return 111
}

// Sync is method should me sent synchronous
func (method *BasicRecoverOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicRecoverOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *BasicRecoverOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// BasicNack This method allows a client to reject one or more incoming messages. It can be
// used to interrupt and cancel large incoming messages, or return untreatable
// messages to their original queue.
//
// This method is also used by the server to inform publishers on channels in
// confirm mode of unhandled messages.  If a publisher receives this method, it
// probably needs to republish the offending messages.
type BasicNack struct {
	DeliveryTag uint64
	Multiple    bool
	Requeue     bool
}

// Name returns method name as string, usefully for logging
func (method *BasicNack) Name() string {
	return "BasicNack"
}

// FrameType returns method frame type
func (method *BasicNack) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicNack) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicNack) MethodIdentifier() uint16 {
	return 120
}

// Sync is method should me sent synchronous
func (method *BasicNack) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicNack) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Multiple = bits&(1<<0) != 0

	method.Requeue = bits&(1<<1) != 0

	return
}

// Write method from io reader
func (method *BasicNack) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Multiple {
		bits |= 1 << 0
	}

	if method.Requeue {
		bits |= 1 << 1
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// Tx methods

// TxSelect This method sets the channel to use standard transactions. The client must use this
// method at least once on a channel before using the Commit or Rollback methods.
type TxSelect struct {
}

// Name returns method name as string, usefully for logging
func (method *TxSelect) Name() string {
	return "TxSelect"
}

// FrameType returns method frame type
func (method *TxSelect) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxSelect) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxSelect) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *TxSelect) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxSelect) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxSelect) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxSelectOk This method confirms to the client that the channel was successfully set to use
// standard transactions.
type TxSelectOk struct {
}

// Name returns method name as string, usefully for logging
func (method *TxSelectOk) Name() string {
	return "TxSelectOk"
}

// FrameType returns method frame type
func (method *TxSelectOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxSelectOk) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxSelectOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *TxSelectOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxSelectOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxSelectOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxCommit This method commits all message publications and acknowledgments performed in
// the current transaction.  A new transaction starts immediately after a commit.
type TxCommit struct {
}

// Name returns method name as string, usefully for logging
func (method *TxCommit) Name() string {
	return "TxCommit"
}

// FrameType returns method frame type
func (method *TxCommit) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxCommit) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxCommit) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *TxCommit) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxCommit) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxCommit) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxCommitOk This method confirms to the client that the commit succeeded. Note that if a commit
// fails, the server raises a channel exception.
type TxCommitOk struct {
}

// Name returns method name as string, usefully for logging
func (method *TxCommitOk) Name() string {
	return "TxCommitOk"
}

// FrameType returns method frame type
func (method *TxCommitOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxCommitOk) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxCommitOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *TxCommitOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxCommitOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxCommitOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxRollback This method abandons all message publications and acknowledgments performed in
// the current transaction. A new transaction starts immediately after a rollback.
// Note that unacked messages will not be automatically redelivered by rollback;
// if that is required an explicit recover call should be issued.
type TxRollback struct {
}

// Name returns method name as string, usefully for logging
func (method *TxRollback) Name() string {
	return "TxRollback"
}

// FrameType returns method frame type
func (method *TxRollback) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxRollback) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxRollback) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *TxRollback) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxRollback) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxRollback) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxRollbackOk This method confirms to the client that the rollback succeeded. Note that if an
// rollback fails, the server raises a channel exception.
type TxRollbackOk struct {
}

// Name returns method name as string, usefully for logging
func (method *TxRollbackOk) Name() string {
	return "TxRollbackOk"
}

// FrameType returns method frame type
func (method *TxRollbackOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxRollbackOk) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxRollbackOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *TxRollbackOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxRollbackOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxRollbackOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Confirm methods

// ConfirmSelect This method sets the channel to use publisher acknowledgements.
// The client can only use this method on a non-transactional
// channel.
type ConfirmSelect struct {
	Nowait bool
}

// Name returns method name as string, usefully for logging
func (method *ConfirmSelect) Name() string {
	return "ConfirmSelect"
}

// FrameType returns method frame type
func (method *ConfirmSelect) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConfirmSelect) ClassIdentifier() uint16 {
	return 85
}

// MethodIdentifier returns method methodID
func (method *ConfirmSelect) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ConfirmSelect) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConfirmSelect) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Nowait = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ConfirmSelect) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Nowait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ConfirmSelectOk This method confirms to the client that the channel was successfully
// set to use publisher acknowledgements.
type ConfirmSelectOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ConfirmSelectOk) Name() string {
	return "ConfirmSelectOk"
}

// FrameType returns method frame type
func (method *ConfirmSelectOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConfirmSelectOk) ClassIdentifier() uint16 {
	return 85
}

// MethodIdentifier returns method methodID
func (method *ConfirmSelectOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ConfirmSelectOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConfirmSelectOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ConfirmSelectOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

/*
ReadMethod reads method from frame's payload

Method frames carry the high-level protocol commands (which we call "methods").
One method frame carries one command.  The method frame payload has this format:

  0          2           4
  +----------+-----------+-------------- - -
  | class-id | method-id | arguments...
  +----------+-----------+-------------- - -
     short      short    ...

*/
func ReadMethod(reader io.Reader, protoVersion string) (Method, error) {
	classID, err := ReadShort(reader)
	if err != nil {
		return nil, err
	}

	methodID, err := ReadShort(reader)
	if err != nil {
		return nil, err
	}
	switch classID {

	case 10:
		switch methodID {

		case 10:
			var method = &ConnectionStart{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ConnectionStartOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &ConnectionSecure{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &ConnectionSecureOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &ConnectionTune{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &ConnectionTuneOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &ConnectionOpen{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 41:
			var method = &ConnectionOpenOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 50:
			var method = &ConnectionClose{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 51:
			var method = &ConnectionCloseOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 60:
			var method = &ConnectionBlocked{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 61:
			var method = &ConnectionUnblocked{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 20:
		switch methodID {

		case 10:
			var method = &ChannelOpen{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ChannelOpenOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &ChannelFlow{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &ChannelFlowOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &ChannelClose{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 41:
			var method = &ChannelCloseOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 40:
		switch methodID {

		case 10:
			var method = &ExchangeDeclare{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ExchangeDeclareOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &ExchangeDelete{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &ExchangeDeleteOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &ExchangeBind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &ExchangeBindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &ExchangeUnbind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 51:
			var method = &ExchangeUnbindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 50:
		switch methodID {

		case 10:
			var method = &QueueDeclare{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &QueueDeclareOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &QueueBind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &QueueBindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 50:
			var method = &QueueUnbind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 51:
			var method = &QueueUnbindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &QueuePurge{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &QueuePurgeOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &QueueDelete{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 41:
			var method = &QueueDeleteOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 60:
		switch methodID {

		case 10:
			var method = &BasicQos{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &BasicQosOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &BasicConsume{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &BasicConsumeOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &BasicCancel{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &BasicCancelOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &BasicPublish{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 50:
			var method = &BasicReturn{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 60:
			var method = &BasicDeliver{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 70:
			var method = &BasicGet{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 71:
			var method = &BasicGetOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 72:
			var method = &BasicGetEmpty{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 80:
			var method = &BasicAck{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 90:
			var method = &BasicReject{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 100:
			var method = &BasicRecoverAsync{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 110:
			var method = &BasicRecover{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 111:
			var method = &BasicRecoverOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 120:
			var method = &BasicNack{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 90:
		switch methodID {

		case 10:
			var method = &TxSelect{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &TxSelectOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &TxCommit{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &TxCommitOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &TxRollback{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &TxRollbackOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 85:
		switch methodID {

		case 10:
			var method = &ConfirmSelect{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ConfirmSelectOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	}

	return nil, fmt.Errorf("unknown classID and methodID: [%d. %d]", classID, methodID)
}

// WriteMethod writes method into frame's payload
func WriteMethod(writer io.Writer, method Method, protoVersion string) (err error) {
	if err = WriteShort(writer, method.ClassIdentifier()); err != nil {
		return err
	}
	if err = WriteShort(writer, method.MethodIdentifier()); err != nil {
		return err
	}

	if err = method.Write(writer, protoVersion); err != nil {
		return err
	}

	return
}

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/readers_writers.go`:

```go
package amqp

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/pool"
	"io"
	"time"
)

var emptyBufferPool = pool.NewBufferPool(0)

// 14 bytes for class-id | weight | body size | property flags
var headerBufferPool = pool.NewBufferPool(14)

// AmqpHeader standard AMQP header
var AmqpHeader = []byte{'A', 'M', 'Q', 'P', 0, 0, 9, 1}

// supported protocol identifiers
const (
	Proto091    = "amqp-0-9-1"
	ProtoRabbit = "amqp-rabbit"
)

func writeSlice(wr io.Writer, data []byte) error {
	_, err := wr.Write(data[:])
	return err
}

/*
ReadFrame reads and parses raw data from conn reader and returns amqp frame

@spec-note
All frames consist of a header (7 octets), a payload of arbitrary size, and a
'frame-end' octet that detects malformed frames:

  0      1         3             7                  size+7 size+8
  +------+---------+-------------+  +------------+  +-----------+
  | type | channel |     size    |  |  payload   |  | frame-end |
  +------+---------+-------------+  +------------+  +-----------+
   octet   short         long         size octets       octet

To read a frame, we:
 1. Read the header and check the frame type and channel.
 2. Depending on the frame size, we read the payload
 3. Read the frame-end octet.
*/
func ReadFrame(r io.Reader) (frame *Frame, err error) {
	// It does not matter that we call read methods 3 time
	// Because net.TCPConn connection buffered by bufio.NewReader
	frame = &Frame{}
	if frame.Type, err = ReadOctet(r); err != nil {
		return nil, err
	}
	if frame.ChannelID, err = ReadShort(r); err != nil {
		return nil, err
	}
	var payloadSize uint32
	if payloadSize, err = ReadLong(r); err != nil {
		return nil, err
	}

	var payload = make([]byte, payloadSize+1)
	if _, err := io.ReadFull(r, payload); err != nil {
		return nil, err
	}
	frame.Payload = payload[0:payloadSize]

	// check frame end
	if payload[payloadSize] != FrameEnd {
		return nil, fmt.Errorf(
			"the frame-end octet MUST always be the hexadecimal value 'xCE', %x given",
			payload[payloadSize])
	}

	return frame, nil
}

// WriteFrame pack amqp Frame as bytes and write to conn writer
func WriteFrame(wr io.Writer, frame *Frame) (err error) {
	if err = WriteOctet(wr, frame.Type); err != nil {
		return err
	}
	if err = WriteShort(wr, frame.ChannelID); err != nil {
		return err
	}

	// size + payload
	if err = WriteLongstr(wr, frame.Payload); err != nil {
		return err
	}
	// frame end
	if err = WriteOctet(wr, FrameEnd); err != nil {
		return err
	}

	return nil
}

// ReadOctet reads octet (byte)
func ReadOctet(r io.Reader) (data byte, err error) {
	var b [1]byte
	if _, err = io.ReadFull(r, b[:]); err != nil {
		return
	}
	data = b[0]
	return
}

// WriteOctet writes octet (byte)
func WriteOctet(wr io.Writer, data byte) error {
	var b [1]byte
	b[0] = data
	return writeSlice(wr, b[:])
}

// ReadShort reads 2 bytes
func ReadShort(r io.Reader) (data uint16, err error) {
	err = binary.Read(r, binary.BigEndian, &data)
	return
}

// WriteShort writes 2 bytes
func WriteShort(wr io.Writer, data uint16) error {
	var b [2]byte
	binary.BigEndian.PutUint16(b[:], data)
	return writeSlice(wr, b[:])
}

// ReadLong reads 4 bytes
func ReadLong(r io.Reader) (data uint32, err error) {
	err = binary.Read(r, binary.BigEndian, &data)
	return
}

// WriteLong writes 4 bytes
func WriteLong(wr io.Writer, data uint32) error {
	var b [4]byte
	binary.BigEndian.PutUint32(b[:], data)
	return writeSlice(wr, b[:])
}

// ReadLonglong reads 8 bytes
func ReadLonglong(r io.Reader) (data uint64, err error) {
	err = binary.Read(r, binary.BigEndian, &data)
	return
}

// WriteLonglong writes 8 bytes
func WriteLonglong(wr io.Writer, data uint64) error {
	var b [8]byte
	binary.BigEndian.PutUint64(b[:], data)
	return writeSlice(wr, b[:])
}

// ReadTimestamp reads timestamp
// amqp presents timestamp as 8byte int
func ReadTimestamp(r io.Reader) (data time.Time, err error) {
	var seconds uint64
	if seconds, err = ReadLonglong(r); err != nil {
		return
	}
	return time.Unix(int64(seconds), 0), nil
}

// WriteTimestamp writes timestamp
func WriteTimestamp(wr io.Writer, data time.Time) error {
	return WriteLonglong(wr, uint64(data.Unix()))
}

// ReadShortstr reads string
func ReadShortstr(r io.Reader) (data string, err error) {
	var length byte

	length, err = ReadOctet(r)
	if err != nil {
		return "", err
	}

	strBytes := make([]byte, length)

	_, err = io.ReadFull(r, strBytes)
	if err != nil {
		return "", err
	}
	data = string(strBytes)
	return
}

// WriteShortstr writes string
func WriteShortstr(wr io.Writer, data string) error {
	if err := WriteOctet(wr, byte(len(data))); err != nil {
		return err
	}
	if _, err := wr.Write([]byte(data)); err != nil {
		return err
	}

	return nil
}

// ReadLongstr reads long string
// Long string is just array of bytes
func ReadLongstr(r io.Reader) (data []byte, err error) {
	var length uint32

	length, err = ReadLong(r)
	if err != nil {
		return nil, err
	}

	data = make([]byte, length)

	_, err = io.ReadFull(r, data)
	if err != nil {
		return nil, err
	}
	return
}

// WriteLongstr writes long string
func WriteLongstr(wr io.Writer, data []byte) error {
	err := WriteLong(wr, uint32(len(data)))
	if err != nil {
		return err
	}
	_, err = wr.Write(data)
	if err != nil {
		return err
	}
	return nil
}

// ReadTable reads amqp table
// Standard amqp table and rabbitmq table are little different
// So we have second argument protoVersion to handle that issue
func ReadTable(r io.Reader, protoVersion string) (data *Table, err error) {
	tmpData := Table{}
	tableData, err := ReadLongstr(r)
	if err != nil {
		return nil, err
	}

	tableReader := bytes.NewReader(tableData)
	for tableReader.Len() > 0 {
		var key string
		var value interface{}
		if key, err = ReadShortstr(tableReader); err != nil {
			return nil, errors.New("Unable to read key from table: " + err.Error())
		}

		if value, err = readV(tableReader, protoVersion); err != nil {
			return nil, errors.New("Unable to read value from table: " + err.Error())
		}

		tmpData[key] = value
	}

	return &tmpData, nil
}

func readV(r io.Reader, protoVersion string) (data interface{}, err error) {
	switch protoVersion {
	case Proto091:
		return readValue091(r)
	case ProtoRabbit:
		return readValueRabbit(r)
	}

	return nil, fmt.Errorf("unknown proto version [%s]", protoVersion)
}

/*
Standard amqp-0-9-1 table fields

't' bool			boolean
'b' int8			short-short-int
'B' uint8			short-short-uint
'U' int16			short-int
'u' uint16			short-uint
'I' int32			long-int
'i' uint32			long-uint
'L' int64			long-long-int
'l' uint64			long-long-uint
'f' float			float
'd' double			double
'D' Decimal			decimal-value
's' string			short-string
'S'	[]byte			long-string
'A' []interface{} 	field-array
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
*/
func readValue091(r io.Reader) (data interface{}, err error) {
	vType, err := ReadOctet(r)
	if err != nil {
		return nil, err
	}

	switch vType {
	case 't':
		var rData byte
		rData, err = ReadOctet(r)
		if err != nil {
			return nil, err
		}
		return rData != 0, nil
	case 'b':
		var rData int8
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'B':
		var rData uint8
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'U':
		var rData int16
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'u':
		var rData uint16
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'I':
		var rData int32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'i':
		var rData uint32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'L':
		var rData int64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'l':
		var rData uint64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'f':
		var rData float32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'd':
		var rData float64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'D':
		var rData = Decimal{0, 0}

		if err = binary.Read(r, binary.BigEndian, &rData.Scale); err != nil {
			return nil, err
		}
		if err = binary.Read(r, binary.BigEndian, &rData.Value); err != nil {
			return nil, err
		}
		return rData, nil
	case 's':
		var rData string
		if rData, err = ReadShortstr(r); err == nil {
			return nil, err
		}

		return rData, nil
	case 'S':
		var rData []byte
		if rData, err = ReadLongstr(r); err == nil {
			return nil, err
		}

		return rData, nil
	case 'T':
		var rData time.Time
		if rData, err = ReadTimestamp(r); err == nil {
			return nil, err
		}

		return rData, nil
	case 'A':
		var rData []interface{}
		if rData, err = readArray(r, Proto091); err == nil {
			return nil, err
		}
		return rData, nil
	case 'F':
		var rData *Table
		if rData, err = ReadTable(r, Proto091); err == nil {
			return nil, err
		}
		return rData, nil
	case 'V':
		return nil, nil
	}

	return nil, fmt.Errorf("unsupported type %c (%d) by %s protocol", vType, vType, Proto091)
}

/*
Rabbitmq table fields

't' bool			boolean
'b' int8			short-short-int
's'	int16			short-int
'I' int32			long-int
'l' int64			long-long-int
'f' float			float
'd' double			double
'D' Decimal			decimal-value
'S'	[]byte			long-string
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
'x' []interface{} 	field-array
*/
func readValueRabbit(r io.Reader) (data interface{}, err error) {
	vType, err := ReadOctet(r)
	if err != nil {
		return nil, err
	}

	switch vType {
	case 't':
		var rData byte
		rData, err = ReadOctet(r)
		if err != nil {
			return nil, err
		}
		return rData != 0, nil
	case 'b':
		var rData int8
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 's':
		var rData int16
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'I':
		var rData int32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'l':
		var rData int64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'f':
		var rData float32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'd':
		var rData float64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'D':
		var rData = Decimal{0, 0}

		if err = binary.Read(r, binary.BigEndian, &rData.Scale); err != nil {
			return nil, err
		}
		if err = binary.Read(r, binary.BigEndian, &rData.Value); err != nil {
			return nil, err
		}
		return rData, nil
	case 'S':
		var rData []byte
		if rData, err = ReadLongstr(r); err != nil {
			return nil, err
		}

		return string(rData), nil
	case 'T':
		var rData time.Time
		if rData, err = ReadTimestamp(r); err != nil {
			return nil, err
		}

		return rData, nil
	case 'x':
		var rData []interface{}
		if rData, err = readArray(r, ProtoRabbit); err != nil {
			return nil, err
		}
		return rData, nil
	case 'F':
		var rData *Table
		if rData, err = ReadTable(r, ProtoRabbit); err != nil {
			return nil, err
		}
		return rData, nil
	case 'V':
		return nil, nil
	}

	return nil, fmt.Errorf("unsupported type %c (%d) by %s protocol", vType, vType, ProtoRabbit)
}

// WriteTable writes amqp table
// Standard amqp table and rabbitmq table are little different
// So we have second argument protoVersion to handle that issue
func WriteTable(writer io.Writer, table *Table, protoVersion string) (err error) {
	var buf = emptyBufferPool.Get()
	defer emptyBufferPool.Put(buf)
	for key, v := range *table {
		if err := WriteShortstr(buf, key); err != nil {
			return err
		}
		if err := writeV(buf, v, protoVersion); err != nil {
			return err
		}
	}
	return WriteLongstr(writer, buf.Bytes())
}

func writeV(writer io.Writer, v interface{}, protoVersion string) (err error) {
	switch protoVersion {
	case Proto091:
		return writeValue091(writer, v)
	case ProtoRabbit:
		return writeValueRabbit(writer, v)
	}

	return fmt.Errorf("unknown proto version [%s]", protoVersion)
}

/*
Standard amqp-0-9-1 table fields

't' bool			boolean
'b' int8			short-short-int
'B' uint8			short-short-uint
'U' int16			short-int
'u' uint16			short-uint
'I' int32			long-int
'i' uint32			long-uint
'L' int64			long-long-int
'l' uint64			long-long-uint
'f' float			float
'd' double			double
'D' Decimal			decimal-value
's' string			short-string
'S'	[]byte			long-string
'A' []interface{} 	field-array
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
*/
func writeValue091(writer io.Writer, v interface{}) (err error) {
	switch value := v.(type) {
	case bool:
		if err = WriteOctet(writer, byte('t')); err == nil {
			if value {
				err = binary.Write(writer, binary.BigEndian, uint8(1))
			} else {
				err = binary.Write(writer, binary.BigEndian, uint8(0))
			}
		}
	case int8:
		if err = WriteOctet(writer, byte('b')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint8:
		if err = WriteOctet(writer, byte('B')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case int16:
		if err = WriteOctet(writer, byte('U')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint16:
		if err = binary.Write(writer, binary.BigEndian, byte('u')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case int32:
		if err = binary.Write(writer, binary.BigEndian, byte('I')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint32:
		if err = binary.Write(writer, binary.BigEndian, byte('i')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case int64:
		if err = binary.Write(writer, binary.BigEndian, byte('L')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint64:
		if err = binary.Write(writer, binary.BigEndian, byte('l')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case float32:
		if err = binary.Write(writer, binary.BigEndian, byte('f')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case float64:
		if err = binary.Write(writer, binary.BigEndian, byte('d')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case Decimal:
		if err = binary.Write(writer, binary.BigEndian, byte('D')); err == nil {
			if err = binary.Write(writer, binary.BigEndian, byte(value.Scale)); err == nil {
				err = binary.Write(writer, binary.BigEndian, uint32(value.Value))
			}
		}
	case string:
		if err = WriteOctet(writer, byte('s')); err == nil {
			err = WriteShortstr(writer, value)
		}
	case []byte:
		if err = WriteOctet(writer, byte('S')); err == nil {
			err = WriteLongstr(writer, value)
		}
	case time.Time:
		if err = WriteOctet(writer, byte('T')); err == nil {
			err = WriteTimestamp(writer, value)
		}
	case []interface{}:
		if err = WriteOctet(writer, byte('A')); err == nil {
			err = writeArray(writer, value, Proto091)
		}

	case Table:
		if err = WriteOctet(writer, byte('F')); err == nil {
			err = WriteTable(writer, &value, Proto091)
		}
	case nil:
		err = binary.Write(writer, binary.BigEndian, byte('V'))
	default:
		err = fmt.Errorf("unsupported type by %s protocol", Proto091)
	}

	return
}

/*
Rabbitmq table fields

't' bool			boolean
'b' int8			short-short-int
's'	int16			short-int
'I' int32			long-int
'l' int64			long-long-int
'f' float			float
'd' double			double
'D' Decimal			decimal-value
'S'	[]byte			long-string
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
'x' []interface{} 	field-array
*/
func writeValueRabbit(writer io.Writer, v interface{}) (err error) {
	switch value := v.(type) {
	case bool:
		if err = WriteOctet(writer, byte('t')); err == nil {
			if value {
				err = binary.Write(writer, binary.BigEndian, uint8(1))
			} else {
				err = binary.Write(writer, binary.BigEndian, uint8(0))
			}
		}
	case int8:
		if err = WriteOctet(writer, byte('b')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint8:
		if err = WriteOctet(writer, byte('b')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int8(value))
		}
	case int16:
		if err = WriteOctet(writer, byte('s')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint16:
		if err = binary.Write(writer, binary.BigEndian, byte('s')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int16(value))
		}
	case int32:
		if err = binary.Write(writer, binary.BigEndian, byte('I')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint32:
		if err = binary.Write(writer, binary.BigEndian, byte('I')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int32(value))
		}
	case int64:
		if err = binary.Write(writer, binary.BigEndian, byte('l')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint64:
		if err = binary.Write(writer, binary.BigEndian, byte('l')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int64(value))
		}
	case float32:
		if err = binary.Write(writer, binary.BigEndian, byte('f')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case float64:
		if err = binary.Write(writer, binary.BigEndian, byte('d')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case Decimal:
		if err = binary.Write(writer, binary.BigEndian, byte('D')); err == nil {
			if err = binary.Write(writer, binary.BigEndian, byte(value.Scale)); err == nil {
				err = binary.Write(writer, binary.BigEndian, uint32(value.Value))
			}
		}
	case []byte:
		if err = WriteOctet(writer, byte('S')); err == nil {
			err = WriteLongstr(writer, value)
		}
	case string:
		if err = WriteOctet(writer, byte('S')); err == nil {
			err = WriteLongstr(writer, []byte(value))
		}
	case time.Time:
		if err = WriteOctet(writer, byte('T')); err == nil {
			err = WriteTimestamp(writer, value)
		}
	case []interface{}:
		if err = WriteOctet(writer, byte('x')); err == nil {
			err = writeArray(writer, value, ProtoRabbit)
		}
	case Table:
		if err = WriteOctet(writer, byte('F')); err == nil {
			err = WriteTable(writer, &value, ProtoRabbit)
		}
	case nil:
		err = binary.Write(writer, binary.BigEndian, byte('V'))
	default:
		err = fmt.Errorf("unsupported type by %s protocol", Proto091)
	}

	return
}

func writeArray(writer io.Writer, array []interface{}, protoVersion string) error {
	var buf = emptyBufferPool.Get()
	defer emptyBufferPool.Put(buf)

	for _, v := range array {
		if err := writeV(buf, v, protoVersion); err != nil {
			return err
		}
	}
	return WriteLongstr(writer, buf.Bytes())
}

func readArray(r io.Reader, protoVersion string) (data []interface{}, err error) {
	data = make([]interface{}, 0)
	var arrayData []byte
	if arrayData, err = ReadLongstr(r); err != nil {
		return nil, err
	}

	arrayBuffer := bytes.NewBuffer(arrayData)
	for arrayBuffer.Len() > 0 {
		var itemV interface{}
		if itemV, err = readV(arrayBuffer, protoVersion); err != nil {
			return nil, err
		}

		data = append(data, itemV)
	}

	return data, nil
}

/*
ReadContentHeader reads amqp content header

Certain methods (such as Basic.Publish, Basic.Deliver, etc.) are formally
defined as carrying content.  When a peer sends such a method frame, it always
follows it with a content header and zero or more content body frames.

A content header frame has this format:

    0          2        4           12               14
    +----------+--------+-----------+----------------+------------- - -
    | class-id | weight | body size | property flags | property list...
    +----------+--------+-----------+----------------+------------- - -
      short     short    long long       short        remainder...
*/
func ReadContentHeader(r io.Reader, protoVersion string) (*ContentHeader, error) {
	var err error
	// 14 bytes for class-id | weight | body size | property flags
	headerBuf := headerBufferPool.Get()
	defer headerBufferPool.Put(headerBuf)

	var header [14]byte
	if _, err = io.ReadFull(r, header[:]); err != nil {
		return nil, err
	}
	if _, err = headerBuf.Write(header[:]); err != nil {
		return nil, err
	}

	contentHeader := &ContentHeader{}

	if contentHeader.ClassID, err = ReadShort(headerBuf); err != nil {
		return nil, err
	}
	if contentHeader.Weight, err = ReadShort(headerBuf); err != nil {
		return nil, err
	}
	if contentHeader.BodySize, err = ReadLonglong(headerBuf); err != nil {
		return nil, err
	}
	if contentHeader.propertyFlags, err = ReadShort(headerBuf); err != nil {
		return nil, err
	}

	contentHeader.PropertyList = &BasicPropertyList{}
	if err = contentHeader.PropertyList.Read(r, contentHeader.propertyFlags, protoVersion); err != nil {
		return nil, err
	}

	return contentHeader, nil
}

// WriteContentHeader writes amqp content header
func WriteContentHeader(writer io.Writer, header *ContentHeader, protoVersion string) (err error) {
	if err = WriteShort(writer, header.ClassID); err != nil {
		return err
	}
	if err = WriteShort(writer, header.Weight); err != nil {
		return err
	}
	if err = WriteLonglong(writer, header.BodySize); err != nil {
		return err
	}

	var propertyBuf = emptyBufferPool.Get()
	defer emptyBufferPool.Put(propertyBuf)

	properyFlags, err := header.PropertyList.Write(propertyBuf, protoVersion)
	if err != nil {
		return err
	}

	header.propertyFlags = properyFlags
	if err = WriteShort(writer, header.propertyFlags); err != nil {
		return err
	}
	if _, err = writer.Write(propertyBuf.Bytes()); err != nil {
		return err
	}

	return
}

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/types.go`:

```go
package amqp

import (
	"bytes"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/pool"
	"sync/atomic"
	"time"
)

var emptyMessageBufferPool = pool.NewBufferPool(0)

// Table - simple amqp-table implementation
type Table map[string]interface{}

// Decimal represents amqp-decimal data
type Decimal struct {
	Scale uint8
	Value int32
}

// Frame is raw frame
type Frame struct {
	ChannelID  uint16
	Type       byte
	CloseAfter bool
	Sync       bool
	Payload    []byte
}

// ContentHeader represents amqp-message content-header
type ContentHeader struct {
	BodySize      uint64
	ClassID       uint16
	Weight        uint16
	propertyFlags uint16
	PropertyList  *BasicPropertyList
}

// ConfirmMeta store information for check confirms and send confirm-acks
type ConfirmMeta struct {
	ChanID           uint16
	ConnID           uint64
	DeliveryTag      uint64
	ExpectedConfirms int
	ActualConfirms   int
}

// CanConfirm returns is message can be confirmed
func (meta *ConfirmMeta) CanConfirm() bool {
	return meta.ActualConfirms == meta.ExpectedConfirms
}

// Message represents amqp-message and meta-data
type Message struct {
	ID            uint64
	BodySize      uint64
	DeliveryCount uint32
	Mandatory     bool
	Immediate     bool
	Exchange      string
	RoutingKey    string
	ConfirmMeta   *ConfirmMeta
	Header        *ContentHeader
	Body          []*Frame
}

// when server restart we can't start again count messages from 0
var msgID = uint64(time.Now().UnixNano())

// NewMessage returns new message instance
func NewMessage(method *BasicPublish) *Message {
	return &Message{
		Exchange:      method.Exchange,
		RoutingKey:    method.RoutingKey,
		Mandatory:     method.Mandatory,
		Immediate:     method.Immediate,
		BodySize:      0,
		DeliveryCount: 0,
	}
}

// IsPersistent check if message should be persisted
func (m *Message) IsPersistent() bool {
	deliveryMode := m.Header.PropertyList.DeliveryMode
	return deliveryMode != nil && *deliveryMode == 2
}

// GenerateSeq returns next message ID
func (m *Message) GenerateSeq() {
	if m.ID == 0 {
		m.ID = atomic.AddUint64(&msgID, 1)
	}
}

// Append appends new body-frame into message and increase bodySize
func (m *Message) Append(body *Frame) {
	m.Body = append(m.Body, body)
	m.BodySize += uint64(len(body.Payload))
}

// Marshal converts message into bytes to store into db
func (m *Message) Marshal(protoVersion string) (data []byte, err error) {
	buffer := emptyMessageBufferPool.Get()
	defer emptyMessageBufferPool.Put(buffer)

	if err = WriteLonglong(buffer, m.ID); err != nil {
		return nil, err
	}

	if err = WriteContentHeader(buffer, m.Header, protoVersion); err != nil {
		return nil, err
	}
	if err = WriteShortstr(buffer, m.Exchange); err != nil {
		return nil, err
	}
	if err = WriteShortstr(buffer, m.RoutingKey); err != nil {
		return nil, err
	}

	for _, frame := range m.Body {
		if err = WriteFrame(buffer, frame); err != nil {
			return nil, err
		}
	}

	data = make([]byte, buffer.Len())
	copy(data, buffer.Bytes())
	return
}

// Unmarshal restore message entity from bytes
func (m *Message) Unmarshal(buffer []byte, protoVersion string) (err error) {
	reader := bytes.NewReader(buffer)
	if m.ID, err = ReadLonglong(reader); err != nil {
		return err
	}

	if m.Header, err = ReadContentHeader(reader, protoVersion); err != nil {
		return err
	}
	if m.Exchange, err = ReadShortstr(reader); err != nil {
		return err
	}
	if m.RoutingKey, err = ReadShortstr(reader); err != nil {
		return err
	}

	for m.BodySize < m.Header.BodySize {
		body, errFrame := ReadFrame(reader)
		if errFrame != nil {
			return errFrame
		}
		m.Append(body)
	}

	return nil
}

// Constants to detect connection or channel error thrown
const (
	ErrorOnConnection = iota
	ErrorOnChannel
)

// Error represents AMQP-error data
type Error struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
	ErrorType int
}

// NewConnectionError returns new connection error. If caused - connection should be closed
func NewConnectionError(code uint16, text string, classID uint16, methodID uint16) *Error {
	err := &Error{
		ReplyCode: code,
		ReplyText: ConstantsNameMap[code] + " - " + text,
		ClassID:   classID,
		MethodID:  methodID,
		ErrorType: ErrorOnConnection,
	}

	return err
}

// NewChannelError returns new channel error& If caused - channel should be closed
func NewChannelError(code uint16, text string, classID uint16, methodID uint16) *Error {
	err := &Error{
		ReplyCode: code,
		ReplyText: ConstantsNameMap[code] + " - " + text,
		ClassID:   classID,
		MethodID:  methodID,
		ErrorType: ErrorOnChannel,
	}

	return err
}

```

`pkg/outputs/amqp/_fixtures/garagemq/auth/auth.go`:

```go
package auth

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"errors"
)

// SaslPlain method
const SaslPlain = "PLAIN"

// SaslData represents standard SASL properties
type SaslData struct {
	Identity string
	Username string
	Password string
}

// ParsePlain check and parse SASL-raw data and return SaslData structure
func ParsePlain(response []byte) (SaslData, error) {
	parts := bytes.Split(response, []byte{0})
	if len(parts) != 3 {
		return SaslData{}, errors.New("Unable to parse PLAIN SALS response")
	}

	saslData := SaslData{}
	saslData.Identity = string(parts[0])
	saslData.Username = string(parts[1])
	saslData.Password = string(parts[2])

	return saslData, nil
}

// HashPassword hash raw password and return hash for check
func HashPassword(password string, isMd5 bool) (string, error) {
	h := md5.New()
	h.Write([]byte(password))
	return hex.EncodeToString(h.Sum(nil)), nil
}

// CheckPasswordHash check given password and hash
func CheckPasswordHash(password, hash string, isMd5 bool) bool {

	h := md5.New()
	// digest.Write never return any error, so skip error ckeck
	h.Write([]byte(password))

	return hash == hex.EncodeToString(h.Sum(nil))

}

```

`pkg/outputs/amqp/_fixtures/garagemq/binding/binding.go`:

```go
package binding

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"reflect"
	"regexp"
	"strings"
)

// MatchType is the x-match attribute in a binding argument table
type MatchType int

const (
	// MatchAll requires all registered arguments to match for routing
	MatchAll MatchType = iota
	// MatchAny requires any registered arguments to match for routing
	MatchAny
)

// Binding represents AMQP-binding
type Binding struct {
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *amqp.Table
	regexp     *regexp.Regexp
	topic      bool
	MatchType  MatchType
}

// NewBinding returns new instance of Binding
func NewBinding(queue string, exchange string, routingKey string, arguments *amqp.Table, topic bool) (*Binding, error) {
	binding := &Binding{
		Queue:      queue,
		Exchange:   exchange,
		RoutingKey: routingKey,
		Arguments:  arguments,
		topic:      topic,
	}

	if topic {
		var err error
		if binding.regexp, err = buildRegexp(routingKey); err != nil {
			return nil, fmt.Errorf("bad topic routing key %s -- %s",
				routingKey,
				err.Error())
		}
	}

	if arguments == nil {
		return binding, nil
	}

	// @spec-note AMQP 0.9.1
	//
	// Any field starting with 'x-' other than 'x-match' is
	// reserved for future use and will be ignored.
	//
	// * 'all' implies that all the other pairs must match the headers
	// property of a message for that message to be routed (i.e. and AND match)
	// * 'any' implies that the message should be routed if any of the
	// fields in the headers property match one of the fields in the
	// arguments table (i.e. an OR match)
	//
	// We arbitrarily choose `all` as the default if none was provided
	// at binding time.
	xmatch, ok := (*arguments)["x-match"]
	if ok {
		if xmatch == "all" {
			binding.MatchType = MatchAll
		} else if xmatch == "any" {
			binding.MatchType = MatchAny
		} else {
			return nil, fmt.Errorf("Invalid x-match field value %s, expected all or any",
				xmatch)
		}
	} else {
		binding.MatchType = MatchAll
	}

	return binding, nil
}

// @todo may be better will be trie or dfa than regexp
// @see http://www.rabbitmq.com/blog/2010/09/14/very-fast-and-scalable-topic-routing-part-1/
// @see http://www.rabbitmq.com/blog/2011/03/28/very-fast-and-scalable-topic-routing-part-2/
//
// buildRegexp generate regexp from topic-match string
func buildRegexp(routingKey string) (*regexp.Regexp, error) {
	routingKey = strings.TrimSpace(routingKey)
	routingParts := strings.Split(routingKey, ".")

	for idx, routingPart := range routingParts {
		if routingPart == "*" {
			routingParts[idx] = "*"
		} else if routingPart == "#" {
			routingParts[idx] = "#"
		} else {
			routingParts[idx] = regexp.QuoteMeta(routingPart)
		}
	}

	routingKey = strings.Join(routingParts, "\\.")
	routingKey = strings.Replace(routingKey, "*", `([^\.]+)`, -1)

	for strings.HasPrefix(routingKey, "#\\.") {
		routingKey = strings.TrimPrefix(routingKey, "#\\.")
		if strings.HasPrefix(routingKey, "#\\.") {
			continue
		}
		routingKey = `(.*\.?)+` + routingKey
	}

	for strings.HasSuffix(routingKey, "\\.#") {
		routingKey = strings.TrimSuffix(routingKey, "\\.#")
		if strings.HasSuffix(routingKey, "\\.#") {
			continue
		}
		routingKey = routingKey + `(.*\.?)+`
	}
	routingKey = strings.Replace(routingKey, "\\.#\\.", `(.*\.?)+`, -1)
	routingKey = strings.Replace(routingKey, "#", `(.*\.?)+`, -1)
	pattern := "^" + routingKey + "$"

	return regexp.Compile(pattern)
}

// MatchDirect check is message can be routed from direct-exchange to queue
// with compare exchange and routing key
func (b *Binding) MatchDirect(exchange string, routingKey string) bool {
	return b.Exchange == exchange && b.RoutingKey == routingKey
}

// MatchFanout check is message can be routed from fanout-exchange to queue
// with compare only exchange
func (b *Binding) MatchFanout(exchange string) bool {
	return b.Exchange == exchange
}

// MatchTopic check is message can be routed from topic-exchange to queue
// with compare exchange and match topic-pattern with routing key
func (b *Binding) MatchTopic(exchange string, routingKey string) bool {
	return b.Exchange == exchange && b.regexp.MatchString(routingKey)
}

// MatchHeader checks whether the message can be routed on `b` for a
// header exchange type.
func (b *Binding) MatchHeader(exchange string, headers *amqp.Table) bool {
	if b.Exchange != exchange {
		return false
	}

	// If no arguments were declared by the exchange,
	// consider it is an always true route.
	if b.Arguments == nil {
		return true
	}

	if headers == nil {
		return false
	}

	bindingArgTable := *b.Arguments
	cliHeaders := *headers

	matchType := b.MatchType

	// Fallback solution for the x-match any case, and no other
	// argument in the table
	//
	// If no match is found in the loop, and arguments other than
	// x-match were specified, it should not return a positive
	// value in the end.
	hasNonXArgs := false

	for key, value := range bindingArgTable {
		// Any field starting with 'x-' shall be ignored
		if strings.HasPrefix(key, "x-") {
			continue
		}

		hasNonXArgs = true

		val, ok := cliHeaders[key]

		if !ok {
			if matchType == MatchAll {
				return false
			}
			continue
		}

		// @spec-note AMQP 0.9.1
		//
		// A message queue is bound to the exchange with a table of
		// arguments containing the headers to be matched for that
		// binding and optionally the values they should hold
		if value == nil {
			if matchType == MatchAny {
				return true
			}
			continue
		}

		if value == val {
			if matchType == MatchAny {
				return true
			}
			continue
		}

		if matchType == MatchAll {
			return false
		}
	}

	return matchType == MatchAll ||
		!hasNonXArgs && matchType == MatchAny
}

// GetExchange returns binding's exchange
func (b *Binding) GetExchange() string {
	return b.Exchange
}

// GetRoutingKey returns binding's routing key
func (b *Binding) GetRoutingKey() string {
	return b.RoutingKey
}

// GetQueue returns binding's queue
func (b *Binding) GetQueue() string {
	return b.Queue
}

// Equal returns is given binding equal to current
// with compare exchange, routing key and queue
func (b *Binding) Equal(bind *Binding) bool {
	return b.Exchange == bind.GetExchange() &&
		b.Queue == bind.GetQueue() &&
		b.RoutingKey == bind.GetRoutingKey() &&
		reflect.DeepEqual(b.Arguments, bind.Arguments)
}

// GetName generate binding name by concatenating its params
func (b *Binding) GetName() string {
	return strings.Join(
		[]string{b.Queue, b.Exchange, b.RoutingKey},
		"_",
	)
}

// Marshal returns raw representation of binding to store into storage
func (b *Binding) Marshal(protoVersion string) (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	if err = amqp.WriteShortstr(buf, b.Queue); err != nil {
		return nil, err
	}
	if err = amqp.WriteShortstr(buf, b.Exchange); err != nil {
		return nil, err
	}
	if err = amqp.WriteShortstr(buf, b.RoutingKey); err != nil {
		return nil, err
	}
	// Since marshalling is used for storage only, we can
	// simplify the Marshal/Unmarshal of arguments by
	// writing them in Rabbit format, and reading them as such
	if err = amqp.WriteTable(buf, b.Arguments, protoVersion); err != nil {
		return nil, err
	}
	var topic byte
	if b.topic {
		topic = 1
	}
	if err = amqp.WriteOctet(buf, topic); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Unmarshal returns binding from storage raw bytes data
func (b *Binding) Unmarshal(data []byte, protoVersion string) (err error) {
	buf := bytes.NewReader(data)
	if b.Queue, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if b.Exchange, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if b.RoutingKey, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if b.Arguments, err = amqp.ReadTable(buf, protoVersion); err != nil {
		return err
	}
	var topic byte
	if topic, err = amqp.ReadOctet(buf); err != nil {
		return err
	}
	b.topic = topic == 1

	if b.topic {
		if b.regexp, err = buildRegexp(b.RoutingKey); err != nil {
			return err
		}
	}

	return
}

```

`pkg/outputs/amqp/_fixtures/garagemq/config/config.go`:

```go
package config

import (
	"io/ioutil"

	"gopkg.in/yaml.v3"
)

// Config represents server changeable se
type Config struct {
	Proto      string
	Users      []User
	TCP        TCPConfig
	Queue      Queue
	Db         Db
	Vhost      Vhost
	Security   Security
	Connection Connection
	Admin      AdminConfig
}

// User for auth check
type User struct {
	Username string
	Password string
}

// TCPConfig represents properties for tune network connections
type TCPConfig struct {
	IP           string `yaml:"ip"`
	Port         string
	Nodelay      bool
	ReadBufSize  int `yaml:"readBufSize"`
	WriteBufSize int `yaml:"writeBufSize"`
}

// AdminConfig represents properties for admin server
type AdminConfig struct {
	IP   string `yaml:"ip"`
	Port string
}

// Queue settings
type Queue struct {
	ShardSize        int    `yaml:"shardSize"`
	MaxMessagesInRAM uint64 `yaml:"maxMessagesInRam"`
}

// Db settings, such as path to load/save and engine
type Db struct {
	DefaultPath string `yaml:"defaultPath"`
	Engine      string `yaml:"engine"`
}

// Vhost settings
type Vhost struct {
	DefaultPath string `yaml:"defaultPath"`
}

// Security settings
type Security struct {
	PasswordCheck string `yaml:"passwordCheck"`
}

// Connection settings for AMQP-connection
type Connection struct {
	ChannelsMax  uint16 `yaml:"channelsMax"`
	FrameMaxSize uint32 `yaml:"frameMaxSize"`
}

// CreateFromFile creates config from file
func CreateFromFile(path string) (*Config, error) {
	cfg := &Config{}
	file, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	err = yaml.Unmarshal(file, &cfg)
	if err != nil {
		return nil, err
	}

	return cfg, nil
}

// CreateDefault creates config from default values
func CreateDefault() (*Config, error) {
	return Default(), nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/config/default.go`:

```go
package config

const (
	dbBuntDB = "buntdb"
	dbBadger = "badger"
)

func Default() *Config {
	return &Config{
		Proto: "amqp-rabbit",
		Users: []User{
			{
				Username: "guest",
				Password: "084e0343a0486ff05530df6c705c8bb4", // guest md5 hash
			},
		},
		TCP: TCPConfig{
			IP:           "0.0.0.0",
			Port:         "5672",
			Nodelay:      false,
			ReadBufSize:  128 << 10, // 128Kb
			WriteBufSize: 128 << 10, // 128Kb
		},
		Admin: AdminConfig{
			IP:   "0.0.0.0",
			Port: "15672",
		},
		Queue: Queue{
			ShardSize:        8 << 10,      // 8k
			MaxMessagesInRAM: 10 * 8 << 10, // 10 buckets
		},
		Db: Db{
			DefaultPath: "db",
			Engine:      dbBadger,
		},
		Vhost: Vhost{
			DefaultPath: "/",
		},
		Security: Security{
			PasswordCheck: "md5",
		},
		Connection: Connection{
			ChannelsMax:  4096,
			FrameMaxSize: 65536,
		},
	}
}

```

`pkg/outputs/amqp/_fixtures/garagemq/consumer/consumer.go`:

```go
package consumer

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/interfaces"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
	"sync"
	"sync/atomic"
	"time"
)

const (
	started = iota
	stopped
	paused
)

var cid uint64

// Consumer implements AMQP consumer
type Consumer struct {
	ID          uint64
	Queue       string
	ConsumerTag string
	noAck       bool
	channel     interfaces.Channel
	queue       *queue.Queue
	statusLock  sync.RWMutex
	status      int
	qos         []*qos.AmqpQos
	consume     chan struct{}
}

// NewConsumer returns new instance of Consumer
func NewConsumer(queueName string, consumerTag string, noAck bool, channel interfaces.Channel, queue *queue.Queue, qos []*qos.AmqpQos) *Consumer {
	id := atomic.AddUint64(&cid, 1)
	if consumerTag == "" {
		consumerTag = generateTag(id)
	}
	return &Consumer{
		ID:          id,
		Queue:       queueName,
		ConsumerTag: consumerTag,
		noAck:       noAck,
		channel:     channel,
		queue:       queue,
		qos:         qos,
		consume:     make(chan struct{}, 1),
	}
}

func generateTag(id uint64) string {
	return fmt.Sprintf("%d_%d", time.Now().Unix(), id)
}

// Start starting consumer to fetch messages from queue
func (consumer *Consumer) Start() {
	consumer.statusLock.Lock()
	consumer.status = started
	consumer.statusLock.Unlock()
	go consumer.startConsume()
	consumer.Consume()
}

// startConsume waiting a signal from consume channel and try to pop message from queue
// if not set noAck consumer pop message with qos rules and add message to unacked message queue
func (consumer *Consumer) startConsume() {
	for range consumer.consume {
		consumer.retrieveAndSendMessage()
	}
}

func (consumer *Consumer) retrieveAndSendMessage() {
	var message *amqp.Message
	consumer.statusLock.RLock()
	defer consumer.statusLock.RUnlock()
	if consumer.status == stopped {
		return
	}

	if consumer.noAck {
		message = consumer.queue.Pop()
	} else {
		message = consumer.queue.PopQos(consumer.qos)
	}

	if message == nil {
		return
	}

	dTag := consumer.channel.NextDeliveryTag()
	if !consumer.noAck {
		consumer.channel.AddUnackedMessage(dTag, consumer.ConsumerTag, consumer.queue.GetName(), message)
	}

	consumer.channel.SendContent(&amqp.BasicDeliver{
		ConsumerTag: consumer.ConsumerTag,
		DeliveryTag: dTag,
		Redelivered: message.DeliveryCount > 1,
		Exchange:    message.Exchange,
		RoutingKey:  message.RoutingKey,
	}, message)

	consumer.consumeMsg()

	return
}

// Pause pause consumer, used by channel.flow change
func (consumer *Consumer) Pause() {
	consumer.statusLock.Lock()
	defer consumer.statusLock.Unlock()
	consumer.status = paused
}

// UnPause unpause consumer, used by channel.flow change
func (consumer *Consumer) UnPause() {
	consumer.statusLock.Lock()
	defer consumer.statusLock.Unlock()
	consumer.status = started
}

// Consume send signal into consumer channel, than consumer can try to pop message from queue
func (consumer *Consumer) Consume() bool {
	consumer.statusLock.RLock()
	defer consumer.statusLock.RUnlock()

	return consumer.consumeMsg()
}

func (consumer *Consumer) consumeMsg() bool {
	if consumer.status == stopped || consumer.status == paused {
		return false
	}

	select {
	case consumer.consume <- struct{}{}:
		return true
	default:
		return false
	}
}

// Stop stops consumer and remove it from queue consumers list
func (consumer *Consumer) Stop() {
	consumer.statusLock.Lock()
	if consumer.status == stopped {
		consumer.statusLock.Unlock()
		return
	}
	consumer.status = stopped
	consumer.statusLock.Unlock()
	consumer.queue.RemoveConsumer(consumer.ConsumerTag)
	close(consumer.consume)
}

// Cancel stops consumer and send basic.cancel method to the client
func (consumer *Consumer) Cancel() {
	consumer.Stop()
	consumer.channel.SendMethod(&amqp.BasicCancel{ConsumerTag: consumer.ConsumerTag, NoWait: true})
}

// Tag returns consumer tag
func (consumer *Consumer) Tag() string {
	return consumer.ConsumerTag
}

// Qos returns consumer qos rules
func (consumer *Consumer) Qos() []*qos.AmqpQos {
	return consumer.qos
}

```

`pkg/outputs/amqp/_fixtures/garagemq/exchange/exchange.go`:

```go
package exchange

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/binding"
	"sync"
)

// available exchange types
const (
	ExTypeDirect = iota + 1
	ExTypeFanout
	ExTypeTopic
	ExTypeHeaders
)

var exchangeTypeIDAliasMap = map[byte]string{
	ExTypeDirect:  "direct",
	ExTypeFanout:  "fanout",
	ExTypeTopic:   "topic",
	ExTypeHeaders: "headers",
}

var exchangeTypeAliasIDMap = map[string]byte{
	"direct":  ExTypeDirect,
	"fanout":  ExTypeFanout,
	"topic":   ExTypeTopic,
	"headers": ExTypeHeaders,
}

// MetricsState implements exchange's metrics state
type MetricsState struct {
}

// Exchange implements AMQP-exchange
type Exchange struct {
	Name       string
	exType     byte
	durable    bool
	autoDelete bool
	internal   bool
	system     bool
	bindLock   sync.Mutex
	bindings   []*binding.Binding
}

// NewExchange returns new instance of Exchange
func NewExchange(name string, exType byte, durable bool, autoDelete bool, internal bool, system bool) *Exchange {
	return &Exchange{
		Name:       name,
		exType:     exType,
		durable:    durable,
		autoDelete: autoDelete,
		internal:   internal,
		system:     system,
	}
}

// GetExchangeTypeAlias returns exchange type alias by id
func GetExchangeTypeAlias(id byte) (alias string, err error) {
	if alias, ok := exchangeTypeIDAliasMap[id]; ok {
		return alias, nil
	}
	return "", fmt.Errorf("undefined exchange type '%d'", id)
}

// GetExchangeTypeID returns exchange type id by alias
func GetExchangeTypeID(alias string) (id byte, err error) {
	if id, ok := exchangeTypeAliasIDMap[alias]; ok {
		return id, nil
	}
	return 0, fmt.Errorf("undefined exchange alias '%s'", alias)
}

// GetTypeAlias returns exchange type alias by id
func (ex *Exchange) GetTypeAlias() string {
	alias, _ := GetExchangeTypeAlias(ex.exType)

	return alias
}

// AppendBinding check and append binding
// method check if binding already exists and ignore it
func (ex *Exchange) AppendBinding(newBind *binding.Binding) {
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()

	// @spec-note
	// A server MUST allow ignore duplicate bindings ­ that is, two or more bind methods for a specific queue,
	// with identical arguments ­ without treating these as an error.
	for _, bind := range ex.bindings {
		if bind.Equal(newBind) {
			return
		}
	}
	ex.bindings = append(ex.bindings, newBind)
}

// RemoveBinding remove binding
func (ex *Exchange) RemoveBinding(rmBind *binding.Binding) {
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()
	for i, bind := range ex.bindings {
		if bind.Equal(rmBind) {
			ex.bindings = append(ex.bindings[:i], ex.bindings[i+1:]...)
			return
		}
	}
}

// RemoveQueueBindings remove bindings for queue and return removed bindings
func (ex *Exchange) RemoveQueueBindings(queueName string) []*binding.Binding {
	var newBindings []*binding.Binding
	var removedBindings []*binding.Binding
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()
	for _, bind := range ex.bindings {
		if bind.GetQueue() != queueName {
			newBindings = append(newBindings, bind)
		} else {
			removedBindings = append(removedBindings, bind)
		}
	}

	ex.bindings = newBindings
	return removedBindings
}

// GetMatchedQueues returns queues matched for message routing key
func (ex *Exchange) GetMatchedQueues(message *amqp.Message) (matchedQueues map[string]bool) {
	// @spec-note
	// The server MUST implement these standard exchange types: fanout, direct.
	// The server SHOULD implement these standard exchange types: topic, headers.

	// TODO implement "headers" exchange
	matchedQueues = make(map[string]bool)
	switch ex.exType {
	case ExTypeDirect:
		for _, bind := range ex.bindings {
			if bind.MatchDirect(message.Exchange, message.RoutingKey) {
				matchedQueues[bind.GetQueue()] = true
				return
			}
		}
	case ExTypeFanout:
		for _, bind := range ex.bindings {
			if bind.MatchFanout(message.Exchange) {
				matchedQueues[bind.GetQueue()] = true
			}
		}
	case ExTypeTopic:
		for _, bind := range ex.bindings {
			if bind.MatchTopic(message.Exchange, message.RoutingKey) {
				matchedQueues[bind.GetQueue()] = true
			}
		}
	case ExTypeHeaders:
		if message.Header == nil {
			return
		}
		props := message.Header.PropertyList
		if props == nil {
			return
		}
		header := props.Headers
		for _, bind := range ex.bindings {
			if bind.MatchHeader(message.Exchange, header) {
				matchedQueues[bind.GetQueue()] = true
			}
		}
	}
	return
}

// EqualWithErr returns is given exchange equal to current
func (ex *Exchange) EqualWithErr(exB *Exchange) error {
	errTemplate := "inequivalent arg '%s' for exchange '%s': received '%s' but current is '%s'"
	if ex.exType != exB.ExType() {
		aliasA, err := GetExchangeTypeAlias(ex.exType)
		if err != nil {
			return err
		}
		aliasB, err := GetExchangeTypeAlias(exB.ExType())
		if err != nil {
			return err
		}
		return fmt.Errorf(
			errTemplate,
			"type",
			ex.Name,
			aliasB,
			aliasA,
		)
	}
	if ex.durable != exB.IsDurable() {
		return fmt.Errorf(errTemplate, "durable", ex.Name, exB.IsDurable(), ex.durable)
	}
	if ex.autoDelete != exB.IsAutoDelete() {
		return fmt.Errorf(errTemplate, "autoDelete", ex.Name, exB.IsAutoDelete(), ex.autoDelete)
	}
	if ex.internal != exB.IsInternal() {
		return fmt.Errorf(errTemplate, "internal", ex.Name, exB.IsInternal(), ex.internal)
	}
	return nil
}

// GetBindings returns exchange's bindings
func (ex *Exchange) GetBindings() []*binding.Binding {
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()
	return ex.bindings
}

// IsDurable returns is exchange durable
func (ex *Exchange) IsDurable() bool {
	return ex.durable
}

// IsSystem returns is exchange system
func (ex *Exchange) IsSystem() bool {
	return ex.system
}

// IsAutoDelete returns should be exchange deleted when all queues have finished using it
func (ex *Exchange) IsAutoDelete() bool {
	return ex.autoDelete
}

// IsInternal returns that the exchange may not be used directly by publishers,
// but only when bound to other exchanges
func (ex *Exchange) IsInternal() bool {
	return ex.internal
}

// Marshal returns raw representation of exchange to store into storage
func (ex *Exchange) Marshal(protoVersion string) (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	if err = amqp.WriteShortstr(buf, ex.Name); err != nil {
		return nil, err
	}
	if err = amqp.WriteOctet(buf, ex.exType); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Unmarshal returns exchange from storage raw bytes data
func (ex *Exchange) Unmarshal(data []byte) (err error) {
	buf := bytes.NewReader(data)
	if ex.Name, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if ex.exType, err = amqp.ReadOctet(buf); err != nil {
		return err
	}
	ex.durable = true
	return
}

// GetName returns exchange name
func (ex *Exchange) GetName() string {
	return ex.Name
}

// ExType returns exchange type
func (ex *Exchange) ExType() byte {
	return ex.exType
}

```

`pkg/outputs/amqp/_fixtures/garagemq/interfaces/interfaces.go`:

```go
package interfaces

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
)

// Channel represents base channel public interface
type Channel interface {
	SendContent(method amqp.Method, message *amqp.Message)
	SendMethod(method amqp.Method)
	NextDeliveryTag() uint64
	AddUnackedMessage(dTag uint64, cTag string, queue string, message *amqp.Message)
}

// Consumer represents base consumer public interface
type Consumer interface {
	Consume() bool
	Tag() string
	Cancel()
}

// OpSet identifier for set data into storeage
const OpSet = 1

// OpDel identifier for delete data from storage
const OpDel = 2

// Operation represents structure to set/del from storage
type Operation struct {
	Key   string
	Value []byte
	Op    byte
}

// DbStorage represent base db storage interface
type DbStorage interface {
	Set(key string, value []byte) (err error)
	Del(key string) (err error)
	Get(key string) (value []byte, err error)
	Iterate(fn func(key []byte, value []byte))
	IterateByPrefix(prefix []byte, limit uint64, fn func(key []byte, value []byte)) uint64
	IterateByPrefixFrom(prefix []byte, from []byte, limit uint64, fn func(key []byte, value []byte)) uint64
	DeleteByPrefix(prefix []byte)
	KeysByPrefixCount(prefix []byte) uint64
	ProcessBatch(batch []*Operation) (err error)
	Close() error
}

// MsgStorage represent interface for messages storage
type MsgStorage interface {
	Del(message *amqp.Message, queue string) error
	PurgeQueue(queue string)
	Add(message *amqp.Message, queue string) error
	Update(message *amqp.Message, queue string) error
	IterateByQueueFromMsgID(queue string, msgID uint64, limit uint64, fn func(message *amqp.Message)) uint64
	GetQueueLength(queue string) uint64
}

```

`pkg/outputs/amqp/_fixtures/garagemq/pool/pool.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pool

import (
	"bytes"
	"sync"
)

// BufferPool represents a thread safe buffer pool
type BufferPool struct {
	sync.Pool
}

// NewBufferPool returns a new BufferPool
func NewBufferPool(bufferSize int) *BufferPool {
	return &BufferPool{
		sync.Pool{
			New: func() interface{} {
				return bytes.NewBuffer(make([]byte, 0, bufferSize))
			},
		},
	}
}

// Get gets a Buffer from the pool
func (bp *BufferPool) Get() *bytes.Buffer {
	return bp.Pool.Get().(*bytes.Buffer)
}

// Put returns the given Buffer to the pool.
func (bp *BufferPool) Put(b *bytes.Buffer) {
	b.Reset()
	bp.Pool.Put(b)
}

```

`pkg/outputs/amqp/_fixtures/garagemq/qos/qos.go`:

```go
package qos

import "sync"

// AmqpQos represents qos system
type AmqpQos struct {
	sync.Mutex
	prefetchCount uint16
	currentCount  uint16
	prefetchSize  uint32
	currentSize   uint32
}

// NewAmqpQos returns new instance of AmqpQos
func NewAmqpQos(prefetchCount uint16, prefetchSize uint32) *AmqpQos {
	return &AmqpQos{
		prefetchCount: prefetchCount,
		prefetchSize:  prefetchSize,
		currentCount:  0,
		currentSize:   0,
	}
}

// PrefetchCount returns prefetchCount
func (qos *AmqpQos) PrefetchCount() uint16 {
	return qos.prefetchCount
}

// PrefetchSize returns prefetchSize
func (qos *AmqpQos) PrefetchSize() uint32 {
	return qos.prefetchSize
}

// Update set new prefetchCount and prefetchSize
func (qos *AmqpQos) Update(prefetchCount uint16, prefetchSize uint32) {
	qos.prefetchCount = prefetchCount
	qos.prefetchSize = prefetchSize
}

// IsActive check is qos rules are active
// both prefetchSize and prefetchCount must be 0
func (qos *AmqpQos) IsActive() bool {
	return qos.prefetchCount != 0 || qos.prefetchSize != 0
}

// Inc increment current count and size
// Returns true if increment success
// Returns false if after increment size or count will be more than prefetchCount or prefetchSize
func (qos *AmqpQos) Inc(count uint16, size uint32) bool {
	qos.Lock()
	defer qos.Unlock()

	newCount := qos.currentCount + count
	newSize := qos.currentSize + size

	if (qos.prefetchCount == 0 || newCount <= qos.prefetchCount) && (qos.prefetchSize == 0 || newSize <= qos.prefetchSize) {
		qos.currentCount = newCount
		qos.currentSize = newSize
		return true
	}

	return false
}

// Dec decrement current count and size
func (qos *AmqpQos) Dec(count uint16, size uint32) {
	qos.Lock()
	defer qos.Unlock()

	if qos.currentCount < count {
		qos.currentCount = 0
	} else {
		qos.currentCount = qos.currentCount - count
	}

	if qos.currentSize < size {
		qos.currentSize = 0
	} else {
		qos.currentSize = qos.currentSize - size
	}
}

// Release reset current count and size
func (qos *AmqpQos) Release() {
	qos.Lock()
	defer qos.Unlock()
	qos.currentCount = 0
	qos.currentSize = 0
}

// Copy safe copy current qos instance to new one
func (qos *AmqpQos) Copy() *AmqpQos {
	qos.Lock()
	defer qos.Unlock()
	return &AmqpQos{
		prefetchCount: qos.prefetchCount,
		prefetchSize:  qos.prefetchSize,
		currentCount:  qos.currentCount,
		currentSize:   qos.currentSize,
	}
}

```

`pkg/outputs/amqp/_fixtures/garagemq/queue/queue.go`:

```go
package queue

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/interfaces"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/safequeue"
	"sync"
	"sync/atomic"
)

// Queue is an implementation of the AMQP-queue entity
type Queue struct {
	safequeue.SafeQueue
	name        string
	connID      uint64
	exclusive   bool
	autoDelete  bool
	durable     bool
	cmrLock     sync.RWMutex
	consumers   []interfaces.Consumer
	consumeExcl bool
	call        chan struct{}
	wasConsumed bool
	shardSize   int
	actLock     sync.RWMutex
	active      bool
	// persistent storage
	// transient storage
	currentConsumer int
	autoDeleteQueue chan string
	queueLength     int64

	// lock for sync load swapped-messages from disk
	loadSwapLock           sync.Mutex
	maxMessagesInRAM       uint64
	lastStoredMsgID        uint64
	lastMemMsgID           uint64
	swappedToDisk          bool
	maybeLoadFromStorageCh chan struct{}
	wg                     *sync.WaitGroup
}

// NewQueue returns new instance of Queue
func NewQueue(name string, connID uint64, exclusive bool, autoDelete bool, durable bool, config config.Queue, msgStorageP interfaces.MsgStorage, msgStorageT interfaces.MsgStorage, autoDeleteQueue chan string) *Queue {
	return &Queue{
		SafeQueue:              *safequeue.NewSafeQueue(config.ShardSize),
		name:                   name,
		connID:                 connID,
		exclusive:              exclusive,
		autoDelete:             autoDelete,
		durable:                durable,
		call:                   make(chan struct{}, 1),
		maybeLoadFromStorageCh: make(chan struct{}, 1),
		wasConsumed:            false,
		active:                 false,
		shardSize:              1,
		maxMessagesInRAM:       1500,
		currentConsumer:        0,
		autoDeleteQueue:        autoDeleteQueue,
		swappedToDisk:          false,
		wg:                     &sync.WaitGroup{},
	}

}

// Start starts base queue loop to send events to consumers
// Current consumer to handle message from queue selected by round robin
func (queue *Queue) Start() error {
	queue.actLock.Lock()
	defer queue.actLock.Unlock()

	if queue.active {
		return nil
	}

	queue.active = true
	queue.wg.Add(1)
	go func() {
		defer queue.wg.Done()
		for range queue.call {
			func() {
				queue.cmrLock.RLock()
				defer queue.cmrLock.RUnlock()
				cmrCount := len(queue.consumers)
				for i := 0; i < cmrCount; i++ {
					if !queue.active {
						return
					}
					queue.currentConsumer = (queue.currentConsumer + 1) % cmrCount
					cmr := queue.consumers[queue.currentConsumer]
					if cmr.Consume() {
						return
					}
				}
			}()
		}
	}()

	queue.wg.Add(1)
	go func() {
		defer queue.wg.Done()
		for range queue.maybeLoadFromStorageCh {
			queue.mayBeLoadFromStorage()
		}
	}()

	return nil
}

// Stop stops main queue loop
// After stop no one can send or receive messages from queue
func (queue *Queue) Stop() error {
	queue.actLock.Lock()
	defer queue.actLock.Unlock()

	queue.active = false
	close(queue.maybeLoadFromStorageCh)
	close(queue.call)
	queue.wg.Wait()
	return nil
}

// GetName returns queue name
func (queue *Queue) GetName() string {
	return queue.name
}

// Push append message into queue tail and put it into message storage
// if queue is durable and message's persistent flag is true
func (queue *Queue) Push(message *amqp.Message) {
	queue.actLock.Lock()
	defer queue.actLock.Unlock()

	if !queue.active {
		return
	}

	atomic.AddInt64(&queue.queueLength, 1)

	message.GenerateSeq()

	persisted := false
	if queue.durable && message.IsPersistent() {
		persisted = true
	} else {
		if queue.SafeQueue.Length() > queue.maxMessagesInRAM || queue.swappedToDisk {
			persisted = true
		}

		if message.ConfirmMeta != nil {
			message.ConfirmMeta.ActualConfirms++
		}
	}

	if persisted && !queue.swappedToDisk && queue.SafeQueue.Length() > queue.maxMessagesInRAM {
		queue.swappedToDisk = true
		queue.lastStoredMsgID = message.ID
	}

	if queue.SafeQueue.Length() <= queue.maxMessagesInRAM && !queue.swappedToDisk {
		queue.SafeQueue.Push(message)
		queue.lastMemMsgID = message.ID
	}

	queue.callConsumers()
}

// Pop returns message from queue head without QOS check
func (queue *Queue) Pop() *amqp.Message {
	return queue.PopQos([]*qos.AmqpQos{})
}

// PopQos returns message from queue head with QOS check
func (queue *Queue) PopQos(qosList []*qos.AmqpQos) *amqp.Message {
	queue.actLock.RLock()
	if !queue.active {
		queue.actLock.RUnlock()
		return nil
	}
	queue.actLock.RUnlock()

	select {
	case queue.maybeLoadFromStorageCh <- struct{}{}:
	default:
	}

	queue.SafeQueue.Lock()
	var message *amqp.Message
	if message = queue.SafeQueue.HeadItem(); message != nil {
		allowed := true
		for _, q := range qosList {
			if !q.IsActive() {
				continue
			}
			if !q.Inc(1, uint32(message.BodySize)) {
				allowed = false
				break
			}
		}

		if allowed {
			queue.SafeQueue.DirtyPop()
			atomic.AddInt64(&queue.queueLength, -1)
		} else {
			message = nil
		}
	}
	queue.SafeQueue.Unlock()

	return message
}

func (queue *Queue) mayBeLoadFromStorage() {
	swappedToPersistent := true
	swappedToTransient := true

	currentLength := queue.SafeQueue.Length()
	needle := queue.maxMessagesInRAM - currentLength

	if currentLength >= queue.maxMessagesInRAM/2 || needle <= 0 || !queue.swappedToDisk {
		return
	}

	pMessages := make([]*amqp.Message, 0, needle)
	tMessages := make([]*amqp.Message, 0, needle)

	lastMemMsgID := queue.lastMemMsgID

	var wg sync.WaitGroup
	// 2 - search for transient and persistent
	wg.Add(2)

	go func() {
		wg.Done()
	}()

	go func() {
		wg.Done()
	}()

	wg.Wait()

	sortedMessages := queue.mergeSortedMessageSlices(pMessages, tMessages)
	sortedMessageslength := uint64(len(sortedMessages))

	var pos uint64
	if sortedMessageslength <= needle {
		pos = sortedMessageslength
	} else {
		pos = needle
	}

	for _, message := range sortedMessages[0:pos] {
		if message.ID == lastMemMsgID {
			continue
		}
		queue.SafeQueue.Push(message)
		queue.lastMemMsgID = message.ID
		queue.lastStoredMsgID = message.ID
		queue.callConsumers()
	}

	queue.swappedToDisk = swappedToPersistent || swappedToTransient
}

func (queue *Queue) mergeSortedMessageSlices(A, B []*amqp.Message) []*amqp.Message {
	result := make([]*amqp.Message, len(A)+len(B))

	idxA, idxB := 0, 0

	for i := 0; i < len(result); i++ {
		if idxA >= len(A) {
			result[i] = B[idxB]
			idxB++
			continue
		} else if idxB >= len(B) {
			result[i] = A[idxA]
			idxA++
			continue
		}

		if A[idxA].ID < B[idxB].ID {
			result[i] = A[idxA]
			idxA++
		} else {
			result[i] = B[idxB]
			idxB++
		}
	}

	return result
}

// AckMsg accept ack event for message
func (queue *Queue) AckMsg(message *amqp.Message) {
	queue.actLock.RLock()
	if !queue.active {
		queue.actLock.RUnlock()
		return
	}
	queue.actLock.RUnlock()

	if queue.durable && message.IsPersistent() {
		// TODO handle error
	}

}

// Requeue add message into queue head
func (queue *Queue) Requeue(message *amqp.Message) {
	queue.actLock.RLock()
	if !queue.active {
		queue.actLock.RUnlock()
		return
	}
	queue.actLock.RUnlock()

	message.DeliveryCount++
	queue.SafeQueue.PushHead(message)
	if queue.durable && message.IsPersistent() {
		// TODO handle error
	}

	atomic.AddInt64(&queue.queueLength, 1)

	queue.callConsumers()
}

// Purge clean queue and message storage for durable queues
func (queue *Queue) Purge() (length uint64) {
	queue.SafeQueue.Lock()
	defer queue.SafeQueue.Unlock()
	length = uint64(atomic.LoadInt64(&queue.queueLength))
	queue.SafeQueue.DirtyPurge()

	if queue.durable {
	}

	atomic.StoreInt64(&queue.queueLength, 0)
	return
}

// Delete cancel consumers and delete its messages from storage
func (queue *Queue) Delete(ifUnused bool, ifEmpty bool) (uint64, error) {
	queue.actLock.Lock()
	queue.cmrLock.Lock()
	queue.SafeQueue.Lock()
	defer queue.actLock.Unlock()
	defer queue.cmrLock.Unlock()
	defer queue.SafeQueue.Unlock()

	queue.active = false

	if ifUnused && len(queue.consumers) != 0 {
		return 0, errors.New("queue has consumers")
	}

	if ifEmpty && queue.SafeQueue.DirtyLength() != 0 {
		return 0, errors.New("queue has messages")
	}

	queue.cancelConsumers()
	length := uint64(atomic.LoadInt64(&queue.queueLength))

	if queue.durable {
	}

	return length, nil
}

// AddConsumer add consumer to consumer messages with exclusive check
func (queue *Queue) AddConsumer(consumer interfaces.Consumer, exclusive bool) error {
	queue.cmrLock.Lock()
	defer queue.cmrLock.Unlock()

	if !queue.active {
		return fmt.Errorf("queue is not active")
	}
	queue.wasConsumed = true

	if len(queue.consumers) != 0 && (queue.consumeExcl || exclusive) {
		return fmt.Errorf("queue is busy by %d consumers", len(queue.consumers))
	}

	if exclusive {
		queue.consumeExcl = true
	}

	queue.consumers = append(queue.consumers, consumer)

	queue.callConsumers()
	return nil
}

// RemoveConsumer remove consumer
// If it was last consumer and queue is auto-delete - queue will be removed
func (queue *Queue) RemoveConsumer(cTag string) {
	queue.cmrLock.Lock()
	defer queue.cmrLock.Unlock()

	for i, cmr := range queue.consumers {
		if cmr.Tag() == cTag {
			queue.consumers = append(queue.consumers[:i], queue.consumers[i+1:]...)
			break
		}
	}
	cmrCount := len(queue.consumers)
	if cmrCount == 0 {
		queue.currentConsumer = 0
		queue.consumeExcl = false
	} else {
		queue.currentConsumer = (queue.currentConsumer + 1) % cmrCount
	}

	if cmrCount == 0 && queue.wasConsumed && queue.autoDelete {
		queue.autoDeleteQueue <- queue.name
	}
}

// Send event to call next consumer, that it can receive next message
func (queue *Queue) callConsumers() {
	if !queue.active {
		return
	}
	select {
	case queue.call <- struct{}{}:
	default:
	}
}

func (queue *Queue) cancelConsumers() {
	for _, cmr := range queue.consumers {
		cmr.Cancel()
	}
}

// Length returns queue length
func (queue *Queue) Length() uint64 {
	return uint64(atomic.LoadInt64(&queue.queueLength))
}

// ConsumersCount returns consumers count
func (queue *Queue) ConsumersCount() int {
	queue.cmrLock.RLock()
	defer queue.cmrLock.RUnlock()
	return len(queue.consumers)
}

// EqualWithErr returns is given queue equal to current
func (queue *Queue) EqualWithErr(qB *Queue) error {
	errTemplate := "inequivalent arg '%s' for queue '%s': received '%t' but current is '%t'"
	if queue.durable != qB.IsDurable() {
		return fmt.Errorf(errTemplate, "durable", queue.name, qB.IsDurable(), queue.durable)
	}
	if queue.autoDelete != qB.autoDelete {
		return fmt.Errorf(errTemplate, "autoDelete", queue.name, qB.autoDelete, queue.autoDelete)
	}
	if queue.exclusive != qB.IsExclusive() {
		return fmt.Errorf(errTemplate, "exclusive", queue.name, qB.IsExclusive(), queue.exclusive)
	}
	return nil
}

// Marshal returns raw representation of queue to store into storage
func (queue *Queue) Marshal(protoVersion string) (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	if err = amqp.WriteShortstr(buf, queue.name); err != nil {
		return nil, err
	}

	var autoDelete byte
	if queue.autoDelete {
		autoDelete = 1
	} else {
		autoDelete = 0
	}

	if err = amqp.WriteOctet(buf, autoDelete); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Unmarshal returns queue from storage raw bytes data
func (queue *Queue) Unmarshal(data []byte, protoVersion string) (err error) {
	buf := bytes.NewReader(data)
	if queue.name, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}

	var autoDelete byte

	if autoDelete, err = amqp.ReadOctet(buf); err != nil {
		return err
	}
	queue.autoDelete = autoDelete > 0
	queue.durable = true
	return
}

// IsDurable returns is queue durable
func (queue *Queue) IsDurable() bool {
	return queue.durable
}

// IsExclusive returns is queue exclusive
func (queue *Queue) IsExclusive() bool {
	return queue.exclusive
}

// IsAutoDelete returns is queue should be deleted automatically
func (queue *Queue) IsAutoDelete() bool {
	return queue.autoDelete
}

// ConnID returns ID of connection that create this queue
func (queue *Queue) ConnID() uint64 {
	return queue.connID
}

// IsActive returns is queue's main loop is active
func (queue *Queue) IsActive() bool {
	return queue.active
}

```

`pkg/outputs/amqp/_fixtures/garagemq/safequeue/safequeue.go`:

```go
package safequeue

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"sync"
)

// We change item's type from {}interface to *amqp.Message, cause we know that we use safequeue only in AMQP context
// TODO Move safe queue into amqp package

// SafeQueue represents simple FIFO queue
// TODO Is that implementation faster? test simple slice queue
type SafeQueue struct {
	sync.RWMutex
	shards    [][]*amqp.Message
	shardSize int
	tailIdx   int
	tail      []*amqp.Message
	tailPos   int
	headIdx   int
	head      []*amqp.Message
	headPos   int
	length    uint64
}

// NewSafeQueue returns new instance of queue
func NewSafeQueue(shardSize int) *SafeQueue {
	queue := &SafeQueue{
		shardSize: shardSize,
		shards:    [][]*amqp.Message{make([]*amqp.Message, shardSize)},
	}

	queue.tailIdx = 0
	queue.tail = queue.shards[queue.tailIdx]
	queue.headIdx = 0
	queue.head = queue.shards[queue.headIdx]
	return queue
}

// Push adds message into queue tail
func (queue *SafeQueue) Push(item *amqp.Message) {
	queue.Lock()
	defer queue.Unlock()

	queue.tail[queue.tailPos] = item
	queue.tailPos++
	queue.length++

	if queue.tailPos == queue.shardSize {
		queue.tailPos = 0
		queue.tailIdx = len(queue.shards)

		buffer := make([][]*amqp.Message, len(queue.shards)+1)
		buffer[queue.tailIdx] = make([]*amqp.Message, queue.shardSize)
		copy(buffer, queue.shards)

		queue.shards = buffer
		queue.tail = queue.shards[queue.tailIdx]
	}
}

// PushHead adds message into queue head
func (queue *SafeQueue) PushHead(item *amqp.Message) {
	queue.Lock()
	defer queue.Unlock()

	if queue.headPos == 0 {
		buffer := make([][]*amqp.Message, len(queue.shards)+1)
		copy(buffer[1:], queue.shards)
		buffer[queue.headIdx] = make([]*amqp.Message, queue.shardSize)

		queue.shards = buffer
		queue.tailIdx++
		queue.headPos = queue.shardSize
		queue.tail = queue.shards[queue.tailIdx]
		queue.head = queue.shards[queue.headIdx]
	}
	queue.length++
	queue.headPos--
	queue.head[queue.headPos] = item
}

// Pop retrieves message from head
func (queue *SafeQueue) Pop() (item *amqp.Message) {
	queue.Lock()
	item = queue.DirtyPop()
	queue.Unlock()
	return
}

// DirtyPop retrieves message from head
// This method is not thread safe
func (queue *SafeQueue) DirtyPop() (item *amqp.Message) {
	item, queue.head[queue.headPos] = queue.head[queue.headPos], nil
	if item == nil {
		return item
	}
	queue.headPos++
	queue.length--
	if queue.headPos == queue.shardSize {
		buffer := make([][]*amqp.Message, len(queue.shards)-1)
		copy(buffer, queue.shards[queue.headIdx+1:])

		queue.shards = buffer

		queue.headPos = 0
		queue.tailIdx--
		queue.head = queue.shards[queue.headIdx]
	}
	return
}

// Length returns queue length
func (queue *SafeQueue) Length() uint64 {
	queue.RLock()
	defer queue.RUnlock()
	return queue.length
}

// DirtyLength returns queue length
// This method is not thread safe
func (queue *SafeQueue) DirtyLength() uint64 {
	return queue.length
}

// HeadItem returns current head message
// This method is not thread safe
func (queue *SafeQueue) HeadItem() (res *amqp.Message) {
	return queue.head[queue.headPos]
}

// DirtyPurge clear queue
// This method is not thread safe
func (queue *SafeQueue) DirtyPurge() {
	queue.shards = [][]*amqp.Message{make([]*amqp.Message, queue.shardSize)}
	queue.tailIdx = 0
	queue.tail = queue.shards[queue.tailIdx]
	queue.headIdx = 0
	queue.head = queue.shards[queue.headIdx]
	queue.length = 0
}

// Purge clear queue
func (queue *SafeQueue) Purge() {
	queue.Lock()
	defer queue.Unlock()
	queue.DirtyPurge()
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/basicMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/consumer"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
)

func (channel *Channel) basicRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.BasicQos:
		return channel.basicQos(method)
	case *amqp.BasicPublish:
		return channel.basicPublish(method)
	case *amqp.BasicConsume:
		return channel.basicConsume(method)
	case *amqp.BasicAck:
		return channel.basicAck(method)
	case *amqp.BasicNack:
		return channel.basicNack(method)
	case *amqp.BasicReject:
		return channel.basicReject(method)
	case *amqp.BasicCancel:
		return channel.basicCancel(method)
	case *amqp.BasicGet:
		return channel.basicGet(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route basic method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) basicQos(method *amqp.BasicQos) (err *amqp.Error) {
	channel.updateQos(method.PrefetchCount, method.PrefetchSize, method.Global)
	channel.SendMethod(&amqp.BasicQosOk{})

	return nil
}

func (channel *Channel) basicAck(method *amqp.BasicAck) (err *amqp.Error) {
	return channel.handleAck(method)
}

func (channel *Channel) basicNack(method *amqp.BasicNack) (err *amqp.Error) {
	return channel.handleReject(method.DeliveryTag, method.Multiple, method.Requeue, method)
}

func (channel *Channel) basicReject(method *amqp.BasicReject) (err *amqp.Error) {
	return channel.handleReject(method.DeliveryTag, false, method.Requeue, method)
}

func (channel *Channel) basicPublish(method *amqp.BasicPublish) (err *amqp.Error) {
	if method.Immediate {
		return amqp.NewChannelError(amqp.NotImplemented, "Immediate = true", method.ClassIdentifier(), method.MethodIdentifier())
	}

	if _, err = channel.getExchangeWithError(method.Exchange, method); err != nil {
		return err
	}

	channel.currentMessage = amqp.NewMessage(method)
	if channel.confirmMode {
		channel.currentMessage.ConfirmMeta = &amqp.ConfirmMeta{
			ChanID:      channel.id,
			ConnID:      channel.conn.id,
			DeliveryTag: channel.nextConfirmDeliveryTag(),
		}
	}
	return nil
}

func (channel *Channel) basicConsume(method *amqp.BasicConsume) (err *amqp.Error) {
	var cmr *consumer.Consumer
	if cmr, err = channel.addConsumer(method); err != nil {
		return err
	}

	if !method.NoWait {
		channel.SendMethod(&amqp.BasicConsumeOk{ConsumerTag: cmr.Tag()})
	}

	cmr.Start()

	return nil
}

func (channel *Channel) basicCancel(method *amqp.BasicCancel) (err *amqp.Error) {
	if _, ok := channel.consumers[method.ConsumerTag]; !ok {
		return amqp.NewChannelError(amqp.NotFound, "Consumer not found", method.ClassIdentifier(), method.MethodIdentifier())
	}
	channel.removeConsumer(method.ConsumerTag)
	channel.SendMethod(&amqp.BasicCancelOk{ConsumerTag: method.ConsumerTag})
	return nil
}

func (channel *Channel) basicGet(method *amqp.BasicGet) (err *amqp.Error) {
	var qu *queue.Queue
	var message *amqp.Message
	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if method.NoAck {
		message = qu.Pop()
	} else {
		message = qu.PopQos([]*qos.AmqpQos{channel.qos, channel.conn.qos})
	}

	// how to handle if queue is not empty, but qos triggered and message is nil
	if message == nil {
		channel.SendMethod(&amqp.BasicGetEmpty{})
		return nil
	}

	dTag := channel.NextDeliveryTag()
	if !method.NoAck {
		channel.AddUnackedMessage(dTag, "", qu.GetName(), message)
	} else {
	}

	channel.SendContent(&amqp.BasicGetOk{
		DeliveryTag:  dTag,
		Redelivered:  false,
		Exchange:     message.Exchange,
		RoutingKey:   message.RoutingKey,
		MessageCount: 1,
	}, message)

	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/channel.go`:

```go
package server

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/consumer"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/pool"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
	"sort"
	"sync"
	"sync/atomic"
	"time"

	"github.com/sirupsen/logrus"
	log "github.com/sirupsen/logrus"
)

const (
	channelNew = iota
	channelOpen
	channelClosing
	channelClosed
	channelDelete
)

// Channel is an implementation of the AMQP-channel entity
// Within a single socket connection, there can be multiple
// independent threads of control, called "channels"
type Channel struct {
	active             bool
	confirmMode        bool
	id                 uint16
	conn               *Connection
	server             *Server
	incoming           chan *amqp.Frame
	outgoing           chan *amqp.Frame
	logger             *log.Entry
	status             int
	protoVersion       string
	currentMessage     *amqp.Message
	cmrLock            sync.RWMutex
	consumers          map[string]*consumer.Consumer
	qos                *qos.AmqpQos
	consumerQos        *qos.AmqpQos
	deliveryTag        uint64
	confirmDeliveryTag uint64
	confirmLock        sync.Mutex
	confirmQueue       []*amqp.ConfirmMeta
	ackLock            sync.Mutex
	ackStore           map[uint64]*UnackedMessage
	statusLock         sync.Mutex

	bufferPool *pool.BufferPool

	closeCh chan bool
}

// UnackedMessage represents the unacknowledged message
type UnackedMessage struct {
	cTag  string
	msg   *amqp.Message
	queue string
}

// NewChannel returns new instance of Channel
func NewChannel(id uint16, conn *Connection) *Channel {
	channel := &Channel{
		active: true,
		id:     id,
		conn:   conn,
		server: conn.server,
		// for incoming channel much capacity is good for performance
		// but it is difficult to implement processing already queued frames on shutdown or connection close
		incoming:     make(chan *amqp.Frame, 128),
		outgoing:     conn.outgoing,
		status:       channelNew,
		protoVersion: conn.server.protoVersion,
		consumers:    make(map[string]*consumer.Consumer),
		qos:          qos.NewAmqpQos(0, 0),
		consumerQos:  qos.NewAmqpQos(0, 0),
		ackStore:     make(map[uint64]*UnackedMessage),
		confirmQueue: make([]*amqp.ConfirmMeta, 0),
		closeCh:      make(chan bool),
		bufferPool:   pool.NewBufferPool(0),
	}

	channel.logger = log.WithFields(log.Fields{
		"connectionId": conn.id,
		"channelId":    id,
	})

	return channel
}

func (channel *Channel) start() {
	if channel.id == 0 {
		go channel.connectionStart()
	}

	go channel.handleIncoming()
}

func (channel *Channel) handleIncoming() {
	buffer := bytes.NewReader([]byte{})

	// TODO
	// @spec-note
	// After sending channel.close, any received methods except Close and Close­OK MUST be discarded.
	// The response to receiving a Close after sending Close must be to send Close­Ok.
	for {
		select {
		case <-channel.closeCh:
			channel.close()
			return
		case frame := <-channel.incoming:
			if frame == nil {
				// channel.incoming closed by connection
				return
			}

			switch frame.Type {
			case amqp.FrameMethod:
				buffer.Reset(frame.Payload)
				method, err := amqp.ReadMethod(buffer, channel.protoVersion)
				channel.logger.Debug("Incoming method <- " + method.Name())
				if err != nil {
					channel.logger.WithError(err).Error("Error on handling frame")
					channel.sendError(amqp.NewConnectionError(amqp.FrameError, err.Error(), 0, 0))
				}

				if err := channel.handleMethod(method); err != nil {
					channel.sendError(err)
				}
			case amqp.FrameHeader:
				if err := channel.handleContentHeader(frame); err != nil {
					channel.sendError(err)
				}
			case amqp.FrameBody:
				if err := channel.handleContentBody(frame); err != nil {
					channel.sendError(err)
				}
			}
		}
	}
}

func (channel *Channel) sendError(err *amqp.Error) {
	channel.logger.Error(err)
	switch err.ErrorType {
	case amqp.ErrorOnChannel:
		channel.status = channelClosing
		channel.SendMethod(&amqp.ChannelClose{
			ReplyCode: err.ReplyCode,
			ReplyText: err.ReplyText,
			ClassID:   err.ClassID,
			MethodID:  err.MethodID,
		})
	case amqp.ErrorOnConnection:
		ch := channel.conn.getChannel(0)
		if ch != nil {
			ch.SendMethod(&amqp.ConnectionClose{
				ReplyCode: err.ReplyCode,
				ReplyText: err.ReplyText,
				ClassID:   err.ClassID,
				MethodID:  err.MethodID,
			})
		}
	}
}

func (channel *Channel) handleMethod(method amqp.Method) *amqp.Error {
	switch method.ClassIdentifier() {
	case amqp.ClassConnection:
		return channel.connectionRoute(method)
	case amqp.ClassChannel:
		return channel.channelRoute(method)
	case amqp.ClassBasic:
		return channel.basicRoute(method)
	case amqp.ClassExchange:
		return channel.exchangeRoute(method)
	case amqp.ClassQueue:
		return channel.queueRoute(method)
	case amqp.ClassConfirm:
		return channel.confirmRoute(method)
	}

	return nil
}

func (channel *Channel) handleContentHeader(headerFrame *amqp.Frame) *amqp.Error {
	reader := bytes.NewReader(headerFrame.Payload)
	var err error
	if channel.currentMessage == nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content header frame", 0, 0)
	}

	if channel.currentMessage.Header != nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content header frame - header already exists", 0, 0)
	}

	if channel.currentMessage.Header, err = amqp.ReadContentHeader(reader, channel.protoVersion); err != nil {
		return amqp.NewConnectionError(amqp.FrameError, "error on parsing content header frame", 0, 0)
	}

	return nil
}

func (channel *Channel) handleContentBody(bodyFrame *amqp.Frame) *amqp.Error {
	if channel.currentMessage == nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content body frame", 0, 0)
	}

	if channel.currentMessage.Header == nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content body frame - no header yet", 0, 0)
	}

	channel.currentMessage.Append(bodyFrame)

	if channel.currentMessage.BodySize < channel.currentMessage.Header.BodySize {
		return nil
	}

	vhost := channel.conn.GetVirtualHost()
	message := channel.currentMessage
	ex := vhost.GetExchange(message.Exchange)
	if ex == nil {
		channel.SendContent(
			&amqp.BasicReturn{ReplyCode: amqp.NoRoute, ReplyText: "No route", Exchange: message.Exchange, RoutingKey: message.RoutingKey},
			message,
		)

		channel.addConfirm(message.ConfirmMeta)

		return nil
	}
	matchedQueues := ex.GetMatchedQueues(message)

	if len(matchedQueues) == 0 {
		if message.Mandatory {
			channel.SendContent(
				&amqp.BasicReturn{ReplyCode: amqp.NoRoute, ReplyText: "No route", Exchange: message.Exchange, RoutingKey: message.RoutingKey},
				message,
			)
		}

		channel.addConfirm(message.ConfirmMeta)

		return nil
	}

	if channel.confirmMode {
		message.ConfirmMeta.ExpectedConfirms = len(matchedQueues)
	}

	for queueName := range matchedQueues {
		qu := channel.conn.GetVirtualHost().GetQueue(queueName)
		if qu == nil {
			if message.Mandatory {
				channel.SendContent(
					&amqp.BasicReturn{ReplyCode: amqp.NoRoute, ReplyText: "No route", Exchange: message.Exchange, RoutingKey: message.RoutingKey},
					message,
				)
			}

			channel.addConfirm(message.ConfirmMeta)

			return nil
		}

		qu.Push(message)

		if channel.confirmMode && message.ConfirmMeta.CanConfirm() && !message.IsPersistent() {
			channel.addConfirm(message.ConfirmMeta)
		}
	}
	return nil
}

// SendMethod send method to client
// Method will be packed into frame and send to outgoing channel
func (channel *Channel) SendMethod(method amqp.Method) {
	var rawMethod = channel.bufferPool.Get()
	if err := amqp.WriteMethod(rawMethod, method, channel.server.protoVersion); err != nil {
		logrus.WithError(err).Error("Error")
	}

	closeAfter := method.ClassIdentifier() == amqp.ClassConnection && method.MethodIdentifier() == amqp.MethodConnectionCloseOk

	channel.logger.Debug("Outgoing -> " + method.Name())

	payload := make([]byte, rawMethod.Len())
	copy(payload, rawMethod.Bytes())
	channel.bufferPool.Put(rawMethod)

	channel.sendOutgoing(&amqp.Frame{Type: byte(amqp.FrameMethod), ChannelID: channel.id, Payload: payload, CloseAfter: closeAfter, Sync: method.Sync()})
}

func (channel *Channel) sendOutgoing(frame *amqp.Frame) {
	select {
	case <-channel.conn.ctx.Done():
		if channel.id == 0 {
			close(channel.outgoing)
		}
	case channel.outgoing <- frame:
	}
}

// SendContent send message to consumers or returns to publishers
func (channel *Channel) SendContent(method amqp.Method, message *amqp.Message) {
	channel.SendMethod(method)

	var rawHeader = channel.bufferPool.Get()
	amqp.WriteContentHeader(rawHeader, message.Header, channel.server.protoVersion)

	payload := make([]byte, rawHeader.Len())
	copy(payload, rawHeader.Bytes())
	channel.bufferPool.Put(rawHeader)

	channel.sendOutgoing(&amqp.Frame{Type: byte(amqp.FrameHeader), ChannelID: channel.id, Payload: payload, CloseAfter: false})

	for _, payload := range message.Body {
		payload.ChannelID = channel.id
		channel.sendOutgoing(payload)
	}

	switch method.(type) {
	case *amqp.BasicDeliver:
	}
}

func (channel *Channel) addConfirm(meta *amqp.ConfirmMeta) {
	if !channel.confirmMode {
		return
	}
	channel.confirmLock.Lock()
	defer channel.confirmLock.Unlock()
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()

	if channel.status == channelClosed {
		return
	}
	channel.confirmQueue = append(channel.confirmQueue, meta)
}

func (channel *Channel) sendConfirms() {
	tick := time.Tick(20 * time.Millisecond)
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()
	for range tick {
		if channel.status == channelClosed {
			return
		}
		channel.confirmLock.Lock()
		currentConfirms := channel.confirmQueue
		channel.confirmQueue = make([]*amqp.ConfirmMeta, 0)
		channel.confirmLock.Unlock()

		for _, confirm := range currentConfirms {
			channel.SendMethod(&amqp.BasicAck{
				DeliveryTag: confirm.DeliveryTag,
				Multiple:    false,
			})
		}
	}
}

func (channel *Channel) addConsumer(method *amqp.BasicConsume) (cmr *consumer.Consumer, err *amqp.Error) {
	channel.cmrLock.Lock()
	defer channel.cmrLock.Unlock()

	var qu *queue.Queue
	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return nil, err
	}

	var consumerQos []*qos.AmqpQos
	if channel.server.protoVersion == amqp.Proto091 {
		consumerQos = []*qos.AmqpQos{channel.qos, channel.conn.qos}
	} else {
		cmrQos := channel.consumerQos.Copy()
		consumerQos = []*qos.AmqpQos{channel.qos, cmrQos}
	}

	cmr = consumer.NewConsumer(method.Queue, method.ConsumerTag, method.NoAck, channel, qu, consumerQos)
	if _, ok := channel.consumers[cmr.Tag()]; ok {
		return nil, amqp.NewChannelError(amqp.NotAllowed, fmt.Sprintf("Consumer with tag '%s' already exists", cmr.Tag()), method.ClassIdentifier(), method.MethodIdentifier())
	}

	if quErr := qu.AddConsumer(cmr, method.Exclusive); quErr != nil {
		return nil, amqp.NewChannelError(amqp.AccessRefused, quErr.Error(), method.ClassIdentifier(), method.MethodIdentifier())
	}
	channel.consumers[cmr.Tag()] = cmr

	return cmr, nil
}

func (channel *Channel) removeConsumer(cTag string) {
	channel.cmrLock.Lock()
	defer channel.cmrLock.Unlock()
	if cmr, ok := channel.consumers[cTag]; ok {
		cmr.Stop()
		delete(channel.consumers, cmr.Tag())
	}
}

func (channel *Channel) close() {
	channel.cmrLock.Lock()
	for _, cmr := range channel.consumers {
		cmr.Stop()
		delete(channel.consumers, cmr.Tag())
		channel.logger.WithFields(log.Fields{
			"consumerTag": cmr.Tag(),
		}).Info("Consumer stopped")
	}
	channel.cmrLock.Unlock()
	if channel.id > 0 {
		channel.handleReject(0, true, true, &amqp.BasicNack{})
	}
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()
	channel.status = channelClosed
	channel.logger.Info("Channel closed")
}

func (channel *Channel) delete() {
	channel.closeCh <- true
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()
	channel.status = channelDelete
}

func (channel *Channel) updateQos(prefetchCount uint16, prefetchSize uint32, global bool) {
	if channel.server.protoVersion == amqp.Proto091 {
		if global {
			channel.conn.qos.Update(prefetchCount, prefetchSize)
		} else {
			channel.qos.Update(prefetchCount, prefetchSize)
		}
	} else {
		if global {
			channel.qos.Update(prefetchCount, prefetchSize)
		} else {
			channel.consumerQos.Update(prefetchCount, prefetchSize)
		}
	}
}

func (channel *Channel) GetQos() *qos.AmqpQos {
	return channel.qos
}

// NextDeliveryTag returns next delivery tag for current channel
func (channel *Channel) NextDeliveryTag() uint64 {
	return atomic.AddUint64(&channel.deliveryTag, 1)
}

func (channel *Channel) nextConfirmDeliveryTag() uint64 {
	return atomic.AddUint64(&channel.confirmDeliveryTag, 1)
}

// AddUnackedMessage add message to unacked queue
func (channel *Channel) AddUnackedMessage(dTag uint64, cTag string, queue string, message *amqp.Message) {
	channel.ackLock.Lock()
	defer channel.ackLock.Unlock()
	channel.ackStore[dTag] = &UnackedMessage{
		cTag:  cTag,
		msg:   message,
		queue: queue,
	}
}

func (channel *Channel) handleAck(method *amqp.BasicAck) *amqp.Error {
	channel.ackLock.Lock()
	defer channel.ackLock.Unlock()
	var uMsg *UnackedMessage
	var msgFound bool

	if method.Multiple {
		for tag, uMsg := range channel.ackStore {
			if method.DeliveryTag == 0 || tag <= method.DeliveryTag {
				channel.ackMsg(uMsg, tag)
			}
		}

		return nil
	}

	if uMsg, msgFound = channel.ackStore[method.DeliveryTag]; !msgFound {
		return amqp.NewChannelError(amqp.PreconditionFailed, fmt.Sprintf("Delivery tag [%d] not found", method.DeliveryTag), method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.ackMsg(uMsg, method.DeliveryTag)

	return nil
}

func (channel *Channel) ackMsg(unackedMessage *UnackedMessage, deliveryTag uint64) {
	delete(channel.ackStore, deliveryTag)
	q := channel.conn.GetVirtualHost().GetQueue(unackedMessage.queue)
	if q != nil {
		q.AckMsg(unackedMessage.msg)
	}

	channel.decQosAndConsumerNext(unackedMessage)
}

func (channel *Channel) handleReject(deliveryTag uint64, multiple bool, requeue bool, method amqp.Method) *amqp.Error {
	channel.ackLock.Lock()
	defer channel.ackLock.Unlock()
	var uMsg *UnackedMessage
	var msgFound bool

	if multiple {
		deliveryTags := make([]uint64, 0)
		for dTag := range channel.ackStore {
			deliveryTags = append(deliveryTags, dTag)
		}
		sort.Slice(
			deliveryTags,
			func(i, j int) bool {
				return deliveryTags[i] > deliveryTags[j]
			},
		)
		for _, tag := range deliveryTags {
			if deliveryTag == 0 || tag <= deliveryTag {
				channel.rejectMsg(channel.ackStore[tag], tag, requeue)
			}
		}

		return nil
	}

	if uMsg, msgFound = channel.ackStore[deliveryTag]; !msgFound {
		return amqp.NewChannelError(amqp.PreconditionFailed, fmt.Sprintf("Delivery tag [%d] not found", deliveryTag), method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.rejectMsg(uMsg, deliveryTag, requeue)

	return nil
}

func (channel *Channel) rejectMsg(unackedMessage *UnackedMessage, deliveryTag uint64, requeue bool) {
	delete(channel.ackStore, deliveryTag)
	qu := channel.conn.GetVirtualHost().GetQueue(unackedMessage.queue)

	if qu != nil {
		if requeue {
			qu.Requeue(unackedMessage.msg)
		} else {
			qu.AckMsg(unackedMessage.msg)
		}
	} else {
		// TODO When a queue is deleted any pending messages are sent to a dead­letter
	}

	channel.decQosAndConsumerNext(unackedMessage)
}

func (channel *Channel) decQosAndConsumerNext(unackedMessage *UnackedMessage) {
	channel.cmrLock.RLock()
	if cmr, ok := channel.consumers[unackedMessage.cTag]; ok {
		cmr.Consume()

		for _, amqpQos := range cmr.Qos() {
			amqpQos.Dec(1, uint32(unackedMessage.msg.BodySize))
		}
	} else {
		channel.qos.Dec(1, uint32(unackedMessage.msg.BodySize))
		channel.conn.qos.Dec(1, uint32(unackedMessage.msg.BodySize))
	}
	channel.cmrLock.RUnlock()
}

func (channel *Channel) getExchangeWithError(exchangeName string, method amqp.Method) (ex *exchange.Exchange, err *amqp.Error) {
	ex = channel.conn.GetVirtualHost().GetExchange(exchangeName)
	if ex == nil {
		return nil, amqp.NewChannelError(
			amqp.NotFound,
			fmt.Sprintf("exchange '%s' not found", exchangeName),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}
	return ex, nil
}

func (channel *Channel) getQueueWithError(queueName string, method amqp.Method) (queue *queue.Queue, err *amqp.Error) {
	qu := channel.conn.GetVirtualHost().GetQueue(queueName)
	if qu == nil || !qu.IsActive() {
		return nil, amqp.NewChannelError(
			amqp.NotFound,
			fmt.Sprintf("queue '%s' not found", queueName),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}
	return qu, nil
}

func (channel *Channel) checkQueueLockWithError(qu *queue.Queue, method amqp.Method) *amqp.Error {
	if qu == nil {
		return nil
	}
	if qu.IsExclusive() && qu.ConnID() != channel.conn.id {
		return amqp.NewChannelError(
			amqp.ResourceLocked,
			fmt.Sprintf("queue '%s' is locked to another connection", qu.GetName()),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	return nil
}

func (channel *Channel) isActive() bool {
	return channel.active
}

func (channel *Channel) changeFlow(active bool) {
	if channel.active == active {
		return
	}
	channel.active = active

	channel.cmrLock.RLock()
	if channel.active {
		for _, cmr := range channel.consumers {
			cmr.UnPause()
			cmr.Consume()
		}
	} else {
		for _, cmr := range channel.consumers {
			cmr.Pause()
		}
	}
	channel.cmrLock.RUnlock()
}

// GetConsumersCount returns consumers count on channel
func (channel *Channel) GetConsumersCount() int {
	return len(channel.consumers)
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/channelMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
)

func (channel *Channel) channelRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ChannelOpen:
		return channel.channelOpen(method)
	case *amqp.ChannelClose:
		return channel.channelClose(method)
	case *amqp.ChannelCloseOk:
		return channel.channelCloseOk(method)
	case *amqp.ChannelFlow:
		return channel.channelFlow(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route channel method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) channelOpen(method *amqp.ChannelOpen) (err *amqp.Error) {
	// @spec-note
	// The client MUST NOT use this method on an already­opened channel.
	if channel.status == channelOpen {
		return amqp.NewConnectionError(amqp.ChannelError, "channel already open", method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.SendMethod(&amqp.ChannelOpenOk{})
	channel.status = channelOpen

	return nil
}

func (channel *Channel) channelClose(method *amqp.ChannelClose) (err *amqp.Error) {
	channel.status = channelClosed
	channel.SendMethod(&amqp.ChannelCloseOk{})
	channel.close()
	return nil
}

func (channel *Channel) channelCloseOk(method *amqp.ChannelCloseOk) (err *amqp.Error) {
	channel.status = channelClosed
	return nil
}

func (channel *Channel) channelFlow(method *amqp.ChannelFlow) (err *amqp.Error) {
	channel.changeFlow(method.Active)
	channel.SendMethod(&amqp.ChannelFlowOk{Active: method.Active})
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/confirmMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
)

func (channel *Channel) confirmRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ConfirmSelect:
		return channel.confirmSelect(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route channel method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) confirmSelect(method *amqp.ConfirmSelect) (err *amqp.Error) {
	channel.confirmMode = true
	go channel.sendConfirms()
	if !method.Nowait {
		channel.SendMethod(&amqp.ConfirmSelectOk{})
	}
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/connection.go`:

```go
package server

import (
	"bufio"
	"bytes"
	"context"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"net"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	log "github.com/sirupsen/logrus"
)

// connection status list
const (
	ConnStart = iota
	ConnStartOK
	ConnSecure
	ConnSecureOK
	ConnTune
	ConnTuneOK
	ConnOpen
	ConnOpenOK
	ConnCloseOK
	ConnClosed
)

// From https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_writer.erl
// When the amount of protocol method data buffered exceeds
// this threshold, a socket flush is performed.
//
// This magic number is the tcp-over-ethernet MSS (1460) minus the
// minimum size of a AMQP 0-9-1 basic.deliver method frame (24) plus basic
// content header (22). The idea is that we want to flush just before
// exceeding the MSS.
const flushThreshold = 1414

// Connection represents AMQP-connection
type Connection struct {
	id               uint64
	server           *Server
	netConn          *net.TCPConn
	logger           *log.Entry
	channelsLock     sync.RWMutex
	channels         map[uint16]*Channel
	outgoing         chan *amqp.Frame
	clientProperties *amqp.Table
	maxChannels      uint16
	maxFrameSize     uint32
	statusLock       sync.RWMutex
	status           int
	qos              *qos.AmqpQos
	virtualHost      *VirtualHost
	vhostName        string
	closeCh          chan bool
	userName         string

	wg        *sync.WaitGroup
	ctx       context.Context
	cancelCtx context.CancelFunc

	heartbeatInterval uint16
	heartbeatTimeout  uint16
	heartbeatTimer    *time.Ticker

	connLock sync.Mutex

	lastOutgoingTS chan time.Time
}

// NewConnection returns new instance of amqp Connection
func NewConnection(server *Server, netConn *net.TCPConn) (connection *Connection) {
	connection = &Connection{
		id:                atomic.AddUint64(&server.connSeq, 1),
		server:            server,
		netConn:           netConn,
		channels:          make(map[uint16]*Channel),
		outgoing:          make(chan *amqp.Frame, 128),
		maxChannels:       server.config.Connection.ChannelsMax,
		maxFrameSize:      server.config.Connection.FrameMaxSize,
		qos:               qos.NewAmqpQos(0, 0),
		closeCh:           make(chan bool, 2),
		wg:                &sync.WaitGroup{},
		lastOutgoingTS:    make(chan time.Time),
		heartbeatInterval: 10,
	}

	connection.logger = log.WithFields(log.Fields{
		"connectionId": connection.id,
	})

	return
}

func (conn *Connection) close() {
	conn.statusLock.Lock()
	if conn.status == ConnClosed {
		conn.statusLock.Unlock()
		return
	}

	if conn.heartbeatTimer != nil {
		conn.heartbeatTimer.Stop()
	}

	conn.status = ConnClosed
	conn.statusLock.Unlock()

	// @todo should we chech for errors here? And what should we do if error occur
	_ = conn.netConn.Close()

	if conn.cancelCtx != nil {
		conn.cancelCtx()
	}

	conn.wg.Wait()

	// channel0 should we be closed at the end
	channelIds := make([]int, 0)
	conn.channelsLock.Lock()
	for chID := range conn.channels {
		channelIds = append(channelIds, int(chID))
	}
	sort.Sort(sort.Reverse(sort.IntSlice(channelIds)))
	for _, chID := range channelIds {
		channel := conn.channels[uint16(chID)]
		channel.delete()
		delete(conn.channels, uint16(chID))
	}
	conn.channelsLock.Unlock()
	conn.clearQueues()

	conn.logger.WithFields(log.Fields{
		"vhost": conn.vhostName,
		"from":  conn.netConn.RemoteAddr(),
	}).Info("Connection closed")
	conn.server.removeConnection(conn.id)

	conn.closeCh <- true
}

func (conn *Connection) getChannel(id uint16) *Channel {
	conn.channelsLock.Lock()
	channel := conn.channels[id]
	conn.channelsLock.Unlock()
	return channel
}

func (conn *Connection) safeClose(wg *sync.WaitGroup) {
	defer wg.Done()

	ch := conn.getChannel(0)
	if ch == nil {
		return
	}
	ch.SendMethod(&amqp.ConnectionClose{
		ReplyCode: amqp.ConnectionForced,
		ReplyText: "Server shutdown",
		ClassID:   0,
		MethodID:  0,
	})

	// let clients proper handle connection closing in 10 sec
	timeOut := time.After(10 * time.Second)

	select {
	case <-timeOut:
		conn.close()
		return
	case <-conn.closeCh:
		return
	}
}

func (conn *Connection) clearQueues() {
	virtualHost := conn.GetVirtualHost()
	if virtualHost == nil {
		// it is possible when conn close before open, for example login failure
		return
	}
	for _, queue := range virtualHost.GetQueues() {
		if queue.IsExclusive() && queue.ConnID() == conn.id {
			virtualHost.DeleteQueue(queue.GetName(), false, false)
		}
	}
}

func (conn *Connection) handleConnection() {
	buf := make([]byte, 8)
	_, err := conn.netConn.Read(buf)
	if err != nil {
		conn.logger.WithError(err).WithFields(log.Fields{
			"read buffer": buf,
		}).Error("Error on read protocol header")
		conn.close()
		return
	}

	// @spec-note
	// If the server cannot support the protocol specified in the protocol header,
	// it MUST respond with a valid protocol header and then close the socket connection.
	// The client MUST start a new connection by sending a protocol header
	if !bytes.Equal(buf, amqp.AmqpHeader) {
		conn.logger.WithFields(log.Fields{
			"given":     buf,
			"supported": amqp.AmqpHeader,
		}).Warn("Unsupported protocol")
		_, _ = conn.netConn.Write(amqp.AmqpHeader)
		conn.close()
		return
	}

	conn.ctx, conn.cancelCtx = context.WithCancel(context.Background())

	channel := NewChannel(0, conn)
	conn.channelsLock.Lock()
	conn.channels[channel.id] = channel
	conn.channelsLock.Unlock()

	channel.start()
	conn.wg.Add(1)
	go conn.handleOutgoing()
	conn.wg.Add(1)
	go conn.handleIncoming()
}

func (conn *Connection) handleOutgoing() {
	defer func() {
		close(conn.lastOutgoingTS)
		conn.wg.Done()
		conn.close()
	}()

	var err error
	buffer := bufio.NewWriterSize(conn.netConn, 128<<10)
	for {
		select {
		case <-conn.ctx.Done():
			return
		case frame := <-conn.outgoing:
			if frame == nil {
				return
			}

			if err = amqp.WriteFrame(buffer, frame); err != nil && !conn.isClosedError(err) {
				conn.logger.WithError(err).Warn("writing frame")
				return
			}

			if frame.CloseAfter {
				if err = buffer.Flush(); err != nil && !conn.isClosedError(err) {
					conn.logger.WithError(err).Warn("writing frame")
				}
				return
			}

			if frame.Sync {
				if err = buffer.Flush(); err != nil && !conn.isClosedError(err) {
					conn.logger.WithError(err).Warn("writing frame")
					return
				}
			} else {
				if err = conn.mayBeFlushBuffer(buffer); err != nil && !conn.isClosedError(err) {
					conn.logger.WithError(err).Warn("writing frame")
					return
				}
			}

			select {
			case conn.lastOutgoingTS <- time.Now():
			default:
			}
		}
	}
}

func (conn *Connection) mayBeFlushBuffer(buffer *bufio.Writer) (err error) {
	if buffer.Buffered() >= flushThreshold {
		if err = buffer.Flush(); err != nil {
			return err
		}
	}

	if len(conn.outgoing) == 0 {
		// outgoing channel is buffered and we can check is here more messages for store into buffer
		// if nothing to store into buffer - we flush
		if err = buffer.Flush(); err != nil {
			return err
		}
	}
	return
}

func (conn *Connection) handleIncoming() {
	defer func() {
		conn.wg.Done()
		conn.close()
	}()

	buffer := bufio.NewReaderSize(conn.netConn, 128<<10)

	for {
		// TODO
		// @spec-note
		// After sending connection.close , any received methods except Close and Close­OK MUST be discarded.
		// The response to receiving a Close after sending Close must be to send Close­Ok.
		frame, err := amqp.ReadFrame(buffer)
		if err != nil {
			if err.Error() != "EOF" && !conn.isClosedError(err) {
				conn.logger.WithError(err).Warn("reading frame")
			}
			return
		}
		conn.statusLock.Lock()
		if conn.status < ConnOpen && frame.ChannelID != 0 {
			conn.statusLock.Unlock()
			conn.logger.WithError(err).Error("Frame not allowed for unopened connection")
			return
		}
		conn.statusLock.Unlock()

		conn.channelsLock.RLock()
		channel, ok := conn.channels[frame.ChannelID]
		conn.channelsLock.RUnlock()

		if !ok {
			channel = NewChannel(frame.ChannelID, conn)

			conn.channelsLock.Lock()
			conn.channels[frame.ChannelID] = channel
			conn.channelsLock.Unlock()

			channel.start()
		}

		if conn.heartbeatTimeout > 0 {
			if err = conn.netConn.SetReadDeadline(time.Now().Add(time.Duration(conn.heartbeatTimeout) * time.Second)); err != nil {
				conn.logger.WithError(err).Warn("reading frame")
				return
			}
		}

		if frame.Type == amqp.FrameHeartbeat && frame.ChannelID != 0 {
			return
		}

		select {
		case <-conn.ctx.Done():
			close(channel.incoming)
			return
		case channel.incoming <- frame:
		}
	}
}

func (conn *Connection) heartBeater() {
	interval := time.Duration(conn.heartbeatInterval) * time.Second
	conn.heartbeatTimer = time.NewTicker(interval)

	var (
		ok     bool
		lastTs = time.Now()
	)

	heartbeatFrame := &amqp.Frame{Type: byte(amqp.FrameHeartbeat), ChannelID: 0, Payload: []byte{}, CloseAfter: false, Sync: true}

	go func() {
		for {
			select {
			case lastTs, ok = <-conn.lastOutgoingTS:
				if !ok {
					return
				}
			}
		}

	}()

	for tickTime := range conn.heartbeatTimer.C {
		if tickTime.Sub(lastTs) >= interval-time.Second {
			conn.outgoing <- heartbeatFrame
		}
	}
}

func (conn *Connection) isClosedError(err error) bool {
	// See: https://github.com/golang/go/issues/4373
	return err != nil && strings.Contains(err.Error(), "use of closed network connection")
}

func (conn *Connection) GetVirtualHost() *VirtualHost {
	return conn.virtualHost
}

func (conn *Connection) GetRemoteAddr() net.Addr {
	return conn.netConn.RemoteAddr()
}

func (conn *Connection) GetChannels() map[uint16]*Channel {
	return conn.channels
}

func (conn *Connection) GetID() uint64 {
	return conn.id
}

func (conn *Connection) GetUsername() string {
	return conn.userName
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/connectionMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/auth"
	"os"
	"runtime"
)

func (channel *Channel) connectionRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ConnectionStartOk:
		return channel.connectionStartOk(method)
	case *amqp.ConnectionTuneOk:
		return channel.connectionTuneOk(method)
	case *amqp.ConnectionOpen:
		return channel.connectionOpen(method)
	case *amqp.ConnectionClose:
		return channel.connectionClose(method)
	case *amqp.ConnectionCloseOk:
		return channel.connectionCloseOk(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route connection method", method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) connectionStart() {
	var capabilities = amqp.Table{}
	capabilities["publisher_confirms"] = true
	capabilities["exchange_exchange_bindings"] = false
	capabilities["basic.nack"] = true
	capabilities["consumer_cancel_notify"] = true
	capabilities["connection.blocked"] = false
	capabilities["consumer_priorities"] = false
	capabilities["authentication_failure_close"] = true
	capabilities["per_consumer_qos"] = true

	var serverProps = amqp.Table{}
	serverProps["product"] = "garagemq"
	serverProps["version"] = "0.1"
	serverProps["copyright"] = "Alexander Valinurov, 2018"
	serverProps["platform"] = runtime.GOARCH
	serverProps["capabilities"] = capabilities
	host, err := os.Hostname()
	if err != nil {
		serverProps["host"] = "UnknownHostError"
	} else {
		serverProps["host"] = host
	}

	var method = amqp.ConnectionStart{VersionMajor: 0, VersionMinor: 9, ServerProperties: &serverProps, Mechanisms: []byte("PLAIN"), Locales: []byte("en_US")}
	channel.SendMethod(&method)

	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnStart
}

func (channel *Channel) connectionStartOk(method *amqp.ConnectionStartOk) *amqp.Error {
	channel.conn.status = ConnStartOK

	var saslData auth.SaslData
	var err error
	if saslData, err = auth.ParsePlain(method.Response); err != nil {
		return amqp.NewConnectionError(amqp.NotAllowed, "login failure", method.ClassIdentifier(), method.MethodIdentifier())
	}

	if method.Mechanism != auth.SaslPlain {
		channel.conn.close()
	}

	if !channel.server.checkAuth(saslData) {
		return amqp.NewConnectionError(amqp.NotAllowed, "login failure", method.ClassIdentifier(), method.MethodIdentifier())
	}
	channel.conn.userName = saslData.Username
	channel.conn.clientProperties = method.ClientProperties

	// @todo Send HeartBeat 0 cause not supported yet
	channel.SendMethod(&amqp.ConnectionTune{
		ChannelMax: channel.conn.maxChannels,
		FrameMax:   channel.conn.maxFrameSize,
		Heartbeat:  channel.conn.heartbeatInterval,
	})
	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnTune

	return nil
}

func (channel *Channel) connectionTuneOk(method *amqp.ConnectionTuneOk) *amqp.Error {
	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnTuneOK

	if method.ChannelMax > channel.conn.maxChannels || method.FrameMax > channel.conn.maxFrameSize {
		channel.conn.close()
		return nil
	}

	channel.conn.maxChannels = method.ChannelMax
	channel.conn.maxFrameSize = method.FrameMax

	if method.Heartbeat > 0 {
		if method.Heartbeat < channel.conn.heartbeatInterval {
			channel.conn.heartbeatInterval = method.Heartbeat
		}
		channel.conn.heartbeatTimeout = channel.conn.heartbeatInterval * 3
		go channel.conn.heartBeater()
	}

	return nil
}

func (channel *Channel) connectionOpen(method *amqp.ConnectionOpen) *amqp.Error {
	channel.conn.status = ConnOpen
	var vhostFound bool
	if channel.conn.virtualHost, vhostFound = channel.server.vhosts[method.VirtualHost]; !vhostFound {
		return amqp.NewConnectionError(amqp.InvalidPath, "virtualHost '"+method.VirtualHost+"' does not exist", method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.conn.vhostName = method.VirtualHost

	channel.SendMethod(&amqp.ConnectionOpenOk{})
	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnOpenOK

	channel.logger.Info("AMQP connection open")
	return nil
}

func (channel *Channel) connectionClose(method *amqp.ConnectionClose) *amqp.Error {
	channel.logger.Infof("Connection closed by client, reason - [%d] %s", method.ReplyCode, method.ReplyText)
	channel.SendMethod(&amqp.ConnectionCloseOk{})
	return nil
}

func (channel *Channel) connectionCloseOk(method *amqp.ConnectionCloseOk) *amqp.Error {
	go channel.conn.close()
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/exchangeMethods.go`:

```go
package server

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"strings"
)

func (channel *Channel) exchangeRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ExchangeDeclare:
		return channel.exchangeDeclare(method)
	case *amqp.ExchangeDelete:
		return channel.exchangeDelete(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route queue method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) exchangeDeclare(method *amqp.ExchangeDeclare) *amqp.Error {
	exTypeId, err := exchange.GetExchangeTypeID(method.Type)
	if err != nil {
		return amqp.NewChannelError(amqp.NotImplemented, err.Error(), method.ClassIdentifier(), method.MethodIdentifier())
	}

	if method.Exchange == "" {
		return amqp.NewChannelError(
			amqp.CommandInvalid,
			"exchange name is required",
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	existingExchange := channel.conn.GetVirtualHost().GetExchange(method.Exchange)
	if method.Passive {
		if method.NoWait {
			return nil
		}

		if existingExchange == nil {
			return amqp.NewChannelError(
				amqp.NotFound,
				fmt.Sprintf("exchange '%s' not found", method.Exchange),
				method.ClassIdentifier(),
				method.MethodIdentifier(),
			)
		}

		channel.SendMethod(&amqp.ExchangeDeclareOk{})

		return nil
	}

	if strings.HasPrefix(method.Exchange, "amq.") {
		return amqp.NewChannelError(
			amqp.AccessRefused,
			fmt.Sprintf("exchange name '%s' contains reserved prefix 'amq.*'", method.Exchange),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	newExchange := exchange.NewExchange(
		method.Exchange,
		exTypeId,
		method.Durable,
		method.AutoDelete,
		method.Internal,
		false,
	)

	if existingExchange != nil {
		if err := existingExchange.EqualWithErr(newExchange); err != nil {
			return amqp.NewChannelError(
				amqp.PreconditionFailed,
				err.Error(),
				method.ClassIdentifier(),
				method.MethodIdentifier(),
			)
		}
		channel.SendMethod(&amqp.ExchangeDeclareOk{})
		return nil
	}

	channel.conn.GetVirtualHost().AppendExchange(newExchange)
	if !method.NoWait {
		channel.SendMethod(&amqp.ExchangeDeclareOk{})
	}

	return nil
}

func (channel *Channel) exchangeDelete(method *amqp.ExchangeDelete) *amqp.Error {
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/queueMethods.go`:

```go
package server

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/binding"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
)

func (channel *Channel) queueRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.QueueDeclare:
		return channel.queueDeclare(method)
	case *amqp.QueueBind:
		return channel.queueBind(method)
	case *amqp.QueueUnbind:
		return channel.queueUnbind(method)
	case *amqp.QueuePurge:
		return channel.queuePurge(method)
	case *amqp.QueueDelete:
		return channel.queueDelete(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route queue method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) queueDeclare(method *amqp.QueueDeclare) *amqp.Error {
	var existingQueue *queue.Queue
	var notFoundErr, exclusiveErr *amqp.Error

	if method.Queue == "" {
		return amqp.NewChannelError(
			amqp.CommandInvalid,
			"queue name is required",
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	existingQueue, notFoundErr = channel.getQueueWithError(method.Queue, method)
	exclusiveErr = channel.checkQueueLockWithError(existingQueue, method)

	if method.Passive {
		if method.NoWait {
			return nil
		}

		if existingQueue == nil {
			return notFoundErr
		}

		if exclusiveErr != nil {
			return exclusiveErr
		}

		channel.SendMethod(&amqp.QueueDeclareOk{
			Queue:         method.Queue,
			MessageCount:  uint32(existingQueue.Length()),
			ConsumerCount: uint32(existingQueue.ConsumersCount()),
		})

		return nil
	}

	newQueue := channel.conn.GetVirtualHost().NewQueue(
		method.Queue,
		channel.conn.id,
		method.Exclusive,
		method.AutoDelete,
		method.Durable,
		channel.server.config.Queue.ShardSize,
	)

	if existingQueue != nil {
		if exclusiveErr != nil {
			return exclusiveErr
		}

		if err := existingQueue.EqualWithErr(newQueue); err != nil {
			return amqp.NewChannelError(
				amqp.PreconditionFailed,
				err.Error(),
				method.ClassIdentifier(),
				method.MethodIdentifier(),
			)
		}

		channel.SendMethod(&amqp.QueueDeclareOk{
			Queue:         method.Queue,
			MessageCount:  uint32(existingQueue.Length()),
			ConsumerCount: uint32(existingQueue.ConsumersCount()),
		})
		return nil
	}

	newQueue.Start()
	err := channel.conn.GetVirtualHost().AppendQueue(newQueue)
	if err != nil {
		return amqp.NewChannelError(
			amqp.PreconditionFailed,
			err.Error(),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}
	channel.SendMethod(&amqp.QueueDeclareOk{
		Queue:         method.Queue,
		MessageCount:  0,
		ConsumerCount: 0,
	})

	return nil
}

func (channel *Channel) queueBind(method *amqp.QueueBind) *amqp.Error {
	var ex *exchange.Exchange
	var qu *queue.Queue
	var err *amqp.Error

	if ex, err = channel.getExchangeWithError(method.Exchange, method); err != nil {
		return err
	}

	// @spec-note
	// The server MUST NOT allow clients to access the default exchange except by specifying an empty exchange name in the Queue.Bind and content Publish methods.
	if ex.GetName() == exDefaultName {
		return amqp.NewChannelError(
			amqp.AccessRefused,
			fmt.Sprintf("operation not permitted on the default exchange"),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	bind, bindErr := binding.NewBinding(method.Queue, method.Exchange,
		method.RoutingKey, method.Arguments, ex.ExType() == exchange.ExTypeTopic)
	if bindErr != nil {
		return amqp.NewChannelError(
			amqp.PreconditionFailed,
			bindErr.Error(),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)

	}

	ex.AppendBinding(bind)

	// @spec-note
	// Bindings of durable queues to durable exchanges are automatically durable and the server MUST restore such bindings after a server restart.
	if ex.IsDurable() && qu.IsDurable() {
		channel.conn.GetVirtualHost().PersistBinding(bind)
	}

	if !method.NoWait {
		channel.SendMethod(&amqp.QueueBindOk{})
	}

	return nil
}

func (channel *Channel) queueUnbind(method *amqp.QueueUnbind) *amqp.Error {
	var ex *exchange.Exchange
	var qu *queue.Queue
	var err *amqp.Error

	if ex, err = channel.getExchangeWithError(method.Exchange, method); err != nil {
		return err
	}

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	bind, bindErr := binding.NewBinding(method.Queue, method.Exchange, method.RoutingKey, method.Arguments, ex.ExType() == exchange.ExTypeTopic)

	if bindErr != nil {
		return amqp.NewConnectionError(
			amqp.PreconditionFailed,
			bindErr.Error(),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	ex.RemoveBinding(bind)
	channel.conn.GetVirtualHost().RemoveBindings([]*binding.Binding{bind})
	channel.SendMethod(&amqp.QueueUnbindOk{})

	return nil
}

func (channel *Channel) queuePurge(method *amqp.QueuePurge) *amqp.Error {
	var qu *queue.Queue
	var err *amqp.Error

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	msgCnt := qu.Purge()
	if !method.NoWait {
		channel.SendMethod(&amqp.QueuePurgeOk{MessageCount: uint32(msgCnt)})
	}
	return nil
}

func (channel *Channel) queueDelete(method *amqp.QueueDelete) *amqp.Error {
	var qu *queue.Queue
	var err *amqp.Error

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	var length, errDel = channel.conn.GetVirtualHost().DeleteQueue(method.Queue, method.IfUnused, method.IfEmpty)
	if errDel != nil {
		return amqp.NewChannelError(amqp.PreconditionFailed, errDel.Error(), method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.SendMethod(&amqp.QueueDeleteOk{MessageCount: uint32(length)})
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/server.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/auth"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"

	log "github.com/sirupsen/logrus"
)

type ServerState int

// server state statuses
const (
	Stopped ServerState = iota
	Running
	Stopping
)

// Server implements AMQP server
type Server struct {
	host         string
	port         string
	protoVersion string
	listener     *net.TCPListener
	connSeq      uint64
	connLock     sync.Mutex
	statusLock   sync.Mutex
	connections  map[uint64]*Connection
	config       *config.Config
	users        map[string]string
	vhostsLock   sync.Mutex
	vhosts       map[string]*VirtualHost
	status       ServerState
}

// NewServer returns new instance of AMQP Server
func NewServer(host string, port string, protoVersion string, config *config.Config) (server *Server) {
	server = &Server{
		host:         host,
		port:         port,
		connections:  make(map[uint64]*Connection),
		protoVersion: protoVersion,
		config:       config,
		users:        make(map[string]string),
		vhosts:       make(map[string]*VirtualHost),
		connSeq:      0,
	}

	return
}

// Start start main server loop
func (srv *Server) Start() {
	log.WithFields(log.Fields{
		"pid": os.Getpid(),
	}).Info("Server starting")

	go srv.hookSignals()

	srv.initUsers()
	srv.initDefaultVirtualHosts()

	go srv.listen()
	srv.statusLock.Lock()
	srv.status = Running
	srv.statusLock.Unlock()
	select {}
}

// Stop stop server and all vhosts
func (srv *Server) Stop() {
	srv.vhostsLock.Lock()
	defer srv.vhostsLock.Unlock()
	srv.statusLock.Lock()
	srv.status = Stopping
	srv.statusLock.Unlock()

	// stop accept new connections
	srv.listener.Close()

	var wg sync.WaitGroup
	srv.connLock.Lock()
	for _, conn := range srv.connections {
		wg.Add(1)
		go conn.safeClose(&wg)
	}
	srv.connLock.Unlock()
	wg.Wait()
	log.Info("All connections safe closed")

	// stop exchanges and queues
	for _, virtualHost := range srv.vhosts {
		virtualHost.Stop()
	}
	srv.statusLock.Lock()
	srv.status = Stopped
	srv.statusLock.Unlock()
}

func (srv *Server) getVhost(name string) *VirtualHost {
	srv.vhostsLock.Lock()
	defer srv.vhostsLock.Unlock()

	return srv.vhosts[name]
}

func (srv *Server) listen() {
	address := srv.host + ":" + srv.port
	tcpAddr, err := net.ResolveTCPAddr("tcp4", address)
	srv.listener, err = net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.WithError(err).WithFields(log.Fields{
			"address": address,
		}).Error("Error on listener start")
		os.Exit(1)
	}

	log.WithFields(log.Fields{
		"address": address,
	}).Info("Server started")

	for {
		conn, err := srv.listener.AcceptTCP()
		if err != nil {
			srv.statusLock.Lock()
			if srv.status != Running {
				srv.statusLock.Unlock()
				return
			}
			srv.statusLock.Unlock()
			srv.stopWithError(err, "accepting connection")
		}
		log.WithFields(log.Fields{
			"from": conn.RemoteAddr().String(),
			"to":   conn.LocalAddr().String(),
		}).Info("accepting connection")

		conn.SetReadBuffer(srv.config.TCP.ReadBufSize)
		conn.SetWriteBuffer(srv.config.TCP.WriteBufSize)
		conn.SetNoDelay(srv.config.TCP.Nodelay)

		srv.acceptConnection(conn)
	}
}

func (srv *Server) stopWithError(err error, msg string) {
	log.WithError(err).Error(msg)
	srv.Stop()
	os.Exit(1)
}

func (srv *Server) acceptConnection(conn *net.TCPConn) {
	srv.connLock.Lock()
	defer srv.connLock.Unlock()

	connection := NewConnection(srv, conn)
	srv.connections[connection.id] = connection
	go connection.handleConnection()
}

func (srv *Server) removeConnection(connID uint64) {
	srv.connLock.Lock()
	defer srv.connLock.Unlock()

	delete(srv.connections, connID)
}

func (srv *Server) checkAuth(saslData auth.SaslData) bool {
	for userName, passwordHash := range srv.users {
		if userName != saslData.Username {
			continue
		}

		return auth.CheckPasswordHash(
			saslData.Password,
			passwordHash,
			srv.config.Security.PasswordCheck == "md5",
		)
	}
	return false
}

func (srv *Server) initUsers() {
	for _, user := range srv.config.Users {
		srv.users[user.Username] = user.Password
	}
}

func (srv *Server) initDefaultVirtualHosts() {
	log.WithFields(log.Fields{
		"vhost": srv.config.Vhost.DefaultPath,
	}).Info("Initialize default vhost")

	log.Info("Initialize host message msgStorage")

	srv.vhostsLock.Lock()
	defer srv.vhostsLock.Unlock()
	srv.vhosts[srv.config.Vhost.DefaultPath] = NewVhost(srv.config.Vhost.DefaultPath, true, srv)
}

func (srv *Server) onSignal(sig os.Signal) {
	switch sig {
	case syscall.SIGTERM, syscall.SIGINT:
		srv.Stop()
		os.Exit(0)
	}
}

// Special method for calling in tests without os.Exit(0)
func (srv *Server) testOnSignal(sig os.Signal) {
	switch sig {
	case syscall.SIGTERM, syscall.SIGINT:
		srv.Stop()
	}
}

func (srv *Server) hookSignals() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		for sig := range c {
			log.Infof("Received [%d:%s] signal from OS", sig, sig.String())
			srv.onSignal(sig)
		}
	}()
}

func (srv *Server) getConfirmChannel(meta *amqp.ConfirmMeta) *Channel {
	srv.connLock.Lock()
	defer srv.connLock.Unlock()
	conn := srv.connections[meta.ConnID]
	if conn == nil {
		return nil
	}

	return conn.getChannel(meta.ChanID)
}

func (srv *Server) GetVhost(name string) *VirtualHost {
	return srv.getVhost(name)
}

func (srv *Server) GetVhosts() map[string]*VirtualHost {
	return srv.vhosts
}

func (srv *Server) GetConnections() map[uint64]*Connection {
	return srv.connections
}

func (srv *Server) GetProtoVersion() string {
	return srv.protoVersion
}

func (srv *Server) GetStatus() ServerState {
	return srv.status
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/vhost.go`:

```go
package server

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/binding"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
	"sync"

	log "github.com/sirupsen/logrus"
)

const exDefaultName = ""

// VirtualHost represents AMQP virtual host
// Each virtual host is "parent" for its queues and exchanges
type VirtualHost struct {
	name            string
	system          bool
	exLock          sync.RWMutex
	exchanges       map[string]*exchange.Exchange
	quLock          sync.RWMutex
	queues          map[string]*queue.Queue
	srv             *Server
	srvConfig       *config.Config
	logger          *log.Entry
	autoDeleteQueue chan string
}

// NewVhost returns instance of VirtualHost
// When instantiating virtual host we
// 1) init system exchanges
// 2) load durable exchanges, queues and bindings from server storage
// 3) load persisted messages from message store into all initiated queues
// 4) run confirm loop
// Only after that vhost is in state running msgStoragePersistent, msgStorageTransient
func NewVhost(name string, system bool, srv *Server) *VirtualHost {
	vhost := &VirtualHost{
		name:            name,
		system:          system,
		exchanges:       make(map[string]*exchange.Exchange),
		queues:          make(map[string]*queue.Queue),
		srvConfig:       srv.config,
		srv:             srv,
		autoDeleteQueue: make(chan string, 1),
	}

	vhost.logger = log.WithFields(log.Fields{
		"vhost": name,
	})

	vhost.initSystemExchanges()
	vhost.loadExchanges()
	vhost.loadQueues()
	vhost.loadBindings()

	vhost.logger.Info("Load messages into queues")

	vhost.loadMessagesIntoQueues()
	for _, q := range vhost.GetQueues() {
		q.Start()
		vhost.logger.WithFields(log.Fields{
			"name":   q.GetName(),
			"length": q.Length(),
		}).Info("Messages loaded into queue")
	}

	go vhost.handleConfirms()
	go vhost.handleAutoDeleteQueue()

	return vhost
}

func (vhost *VirtualHost) handleAutoDeleteQueue() {
	for queueName := range vhost.autoDeleteQueue {
		//time.Sleep(5 * time.Second)
		vhost.DeleteQueue(queueName, false, false)
	}
}

func (vhost *VirtualHost) handleConfirms() {

}

func (vhost *VirtualHost) initSystemExchanges() {
	// @spec-note
	// The server MUST, in each virtual host, pre­declare an exchange instance for each standard exchange type that it
	// implements, where the name of the exchange instance, if defined, is "amq." followed by the exchange type name.

	// The server MUST, in each virtual host, pre­declare at least two direct exchange instances: one named "amq.direct",
	// the other with no public name that serves as a default exchange for Publish methods.

	// The server MUST pre­declare a direct exchange with no public name to act as the default exchange for content Publish methods and for default queue bindings.

	vhost.logger.Info("Initialize host default exchanges...")
	for _, exType := range []byte{
		exchange.ExTypeDirect,
		exchange.ExTypeFanout,
		exchange.ExTypeTopic,
	} {
		exTypeAlias, _ := exchange.GetExchangeTypeAlias(exType)
		exName := "amq." + exTypeAlias
		vhost.AppendExchange(exchange.NewExchange(exName, exType, true, false, false, true))
	}

	// Special case for exchange.ExTypeHeaders
	//
	// AMQP specifies that the default exchange for headers shall be called
	// amq.match, but RabbitMQ declares it as amq.header
	//
	// To be compatible, we change its name depending on protoVersion
	protoVer := vhost.srv.protoVersion

	exTypeAlias, _ := exchange.GetExchangeTypeAlias(exchange.ExTypeHeaders)
	exName := "amq." + exTypeAlias

	if protoVer == amqp.ProtoRabbit {
		exName = "amq.header"
	}
	vhost.AppendExchange(exchange.NewExchange(exName, exchange.ExTypeHeaders, true, false, false, true))

	systemExchange := exchange.NewExchange(exDefaultName, exchange.ExTypeDirect, true, false, false, true)
	vhost.AppendExchange(systemExchange)
}

// GetQueue returns queue by name or nil if not exists
func (vhost *VirtualHost) GetQueue(name string) *queue.Queue {
	vhost.quLock.RLock()
	defer vhost.quLock.RUnlock()
	return vhost.getQueue(name)
}

// GetQueues return all vhost's queues
func (vhost *VirtualHost) GetQueues() map[string]*queue.Queue {
	vhost.quLock.RLock()
	defer vhost.quLock.RUnlock()
	return vhost.queues
}

func (vhost *VirtualHost) getQueue(name string) *queue.Queue {
	return vhost.queues[name]
}

// GetExchange returns exchange by name or nil if not exists
func (vhost *VirtualHost) GetExchange(name string) *exchange.Exchange {
	vhost.exLock.RLock()
	defer vhost.exLock.RUnlock()
	return vhost.getExchange(name)
}

func (vhost *VirtualHost) getExchange(name string) *exchange.Exchange {
	return vhost.exchanges[name]
}

func (vhost *VirtualHost) GetExchanges() map[string]*exchange.Exchange {
	return vhost.exchanges
}

// GetDefaultExchange returns default exchange
func (vhost *VirtualHost) GetDefaultExchange() *exchange.Exchange {
	return vhost.exchanges[exDefaultName]
}

// AppendExchange append new exchange and persist if it is durable
func (vhost *VirtualHost) AppendExchange(ex *exchange.Exchange) {
	vhost.exLock.Lock()
	defer vhost.exLock.Unlock()
	exTypeAlias, _ := exchange.GetExchangeTypeAlias(ex.ExType())
	vhost.logger.WithFields(log.Fields{
		"name": ex.GetName(),
		"type": exTypeAlias,
	}).Info("Append exchange")
	vhost.exchanges[ex.GetName()] = ex

}

// NewQueue returns new instance of queue by params
// we can't use just queue.NewQueue, cause we need to set msgStorage to queue
func (vhost *VirtualHost) NewQueue(name string, connID uint64, exclusive bool, autoDelete bool, durable bool, shardSize int) *queue.Queue {
	return queue.NewQueue(
		name,
		connID,
		exclusive,
		autoDelete,
		durable,
		vhost.srvConfig.Queue,
		nil,
		nil,
		vhost.autoDeleteQueue,
	)
}

// AppendQueue append new queue and persist if it is durable and
// bindings into default exchange
func (vhost *VirtualHost) AppendQueue(qu *queue.Queue) error {
	vhost.quLock.Lock()
	defer vhost.quLock.Unlock()
	vhost.logger.WithFields(log.Fields{
		"queueName": qu.GetName(),
	}).Info("Append queue")

	vhost.queues[qu.GetName()] = qu

	// @spec-note
	// The server MUST create a default binding for a newly­declared queue to the default exchange,
	// which is an exchange of type 'direct' and use the queue name as the routing key.
	ex := vhost.GetDefaultExchange()
	bind, bindErr := binding.NewBinding(qu.GetName(), exDefaultName,
		qu.GetName(), &amqp.Table{}, false)
	if bindErr != nil {
		// Should not happen since the only error paths are on `topic` and
		// `headers`
		return bindErr
	}

	ex.AppendBinding(bind)

	if qu.IsDurable() {

	}

	return nil
}

// PersistBinding store binding into server storage
func (vhost *VirtualHost) PersistBinding(binding *binding.Binding) {
}

// RemoveBindings remove given bindings from server storage
func (vhost *VirtualHost) RemoveBindings(bindings []*binding.Binding) {
}

func (vhost *VirtualHost) loadQueues() {
}

func (vhost *VirtualHost) loadMessagesIntoQueues() {
	var wg sync.WaitGroup
	for queueName, q := range vhost.queues {
		wg.Add(1)
		go func(queueName string, queue *queue.Queue) {
			wg.Done()
		}(queueName, q)
	}
	wg.Wait()
}

func (vhost *VirtualHost) loadExchanges() {
}

func (vhost *VirtualHost) loadBindings() {
}

// DeleteQueue delete queue from virtual host and all bindings to that queue
// Also queue will be removed from server storage
func (vhost *VirtualHost) DeleteQueue(queueName string, ifUnused bool, ifEmpty bool) (uint64, error) {
	vhost.quLock.Lock()
	defer vhost.quLock.Unlock()

	qu := vhost.getQueue(queueName)
	if qu == nil {
		return 0, errors.New("not found")
	}

	var length, err = qu.Delete(ifUnused, ifEmpty)
	if err != nil {
		return 0, err
	}

	qu.Stop()

	for _, ex := range vhost.exchanges {
		removedBindings := ex.RemoveQueueBindings(queueName)
		vhost.RemoveBindings(removedBindings)
	}
	delete(vhost.queues, queueName)

	return length, nil
}

// Stop properly stop virtual host
// TODO: properly stop confirm loop
func (vhost *VirtualHost) Stop() error {
	vhost.quLock.Lock()
	vhost.exLock.Lock()
	defer vhost.quLock.Unlock()
	defer vhost.exLock.Unlock()
	vhost.logger.Info("Stop virtual host")
	for _, qu := range vhost.queues {
		qu.Stop()
		vhost.logger.WithFields(log.Fields{
			"queueName": qu.GetName(),
		}).Info("Queue stopped")
	}

	vhost.logger.Info("Storage closed")
	close(vhost.autoDeleteQueue)
	return nil
}

func (vhost *VirtualHost) GetName() string {
	return vhost.name
}

```

`pkg/outputs/amqp/amqp.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"expvar"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

var (
	// amqpErrors counts AMQP delivery errors
	amqpErrors = expvar.NewInt("output.amqp.publish.errors")
	// amqpMessages counts the total number of published messages
	amqpMessages = expvar.NewInt("output.amqp.publish.messages")
)

type rabbitmq struct {
	client *client
}

func init() {
	outputs.Register(outputs.AMQP, initAMQP)
}

func initAMQP(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.AMQP, config.Output))
	}

	q := &rabbitmq{client: newClient(cfg)}

	return outputs.Success(q), nil
}

func (q *rabbitmq) Connect() error {
	err := q.client.connect(true)
	if err != nil {
		return err
	}
	return q.client.declareExchange()
}

func (q *rabbitmq) Close() error {
	if q.client == nil {
		return nil
	}
	return q.client.close()
}

func (q *rabbitmq) Publish(batch *kevent.Batch) error {
	body := batch.MarshalJSON()
	defer batch.Release()

	err := q.client.publish(body)
	if err != nil {
		amqpErrors.Add(1)
		return err
	}

	amqpMessages.Add(1)

	return nil
}

```

`pkg/outputs/amqp/amqp_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/phayes/freeport"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	broker "github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/server"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/streadway/amqp"
	"github.com/stretchr/testify/require"
)

func TestPublishAmqpOutput(t *testing.T) {
	// deadlock occurs somewhere in the garagemq code
	// when tests are executed in the CI platform.
	// Reenable test once we fix the issue
	t.SkipNow()
	port, err := freeport.GetFreePort()
	require.NoError(t, err)
	amqpBroker := broker.NewServer("127.0.0.1", fmt.Sprintf("%d", port), "amqp-rabbit", config.Default())

	done := make(chan struct{})

	go func() {
		amqpBroker.Start()
	}()
	defer amqpBroker.Stop()

	q := rabbitmq{client: newClient(Config{
		URL:          amqpURL(port),
		Exchange:     "fibratus",
		ExchangeType: "topic",
		RoutingKey:   "fibratus",
	})}

	time.AfterFunc(time.Second*4, func() { done <- struct{}{} })

	require.NoError(t, q.Connect())
	defer q.Close()

	err = consumeKevents(t, amqpURL(port), done)
	require.NoError(t, err)

	err = q.Publish(getBatch())
	require.NoError(t, err)

	<-done
}

func TestHealthcheck(t *testing.T) {
	// deadlock occurs somewhere in the garagemq code
	// when tests are executed in the CI platform.
	// Reenable test once we fix the issue
	t.SkipNow()
	port, err := freeport.GetFreePort()
	require.NoError(t, err)
	amqpBroker := broker.NewServer("127.0.0.1", fmt.Sprintf("%d", port), "amqp-rabbit", config.Default())

	go func() {
		amqpBroker.Start()
	}()

	q := rabbitmq{client: newClient(Config{
		URL:          amqpURL(port),
		Exchange:     "fibratus",
		ExchangeType: "topic",
		RoutingKey:   "fibratus",
		Timeout:      time.Second,
	})}
	require.NoError(t, q.Connect())
	defer q.Close()

	time.Sleep(time.Millisecond * 400)

	amqpBroker.Stop()

	err = q.Publish(getBatch())
	require.Error(t, err)

	time.Sleep(time.Millisecond * 100)

	go func() {
		amqpBroker.Start()
	}()

	time.Sleep(time.Millisecond * 2000)
	require.NoError(t, q.client.declareExchange())
	err = q.Publish(getBatch())
	require.NoError(t, err)
}

//nolint:unused
func consumeKevents(t *testing.T, amqpURI string, done chan struct{}) error {
	conn, err := amqp.Dial(amqpURI)
	if err != nil {
		return err
	}

	channel, err := conn.Channel()
	if err != nil {
		return err
	}
	queue, err := channel.QueueDeclare(
		"fibratus", // name of the queue
		true,       // durable
		false,      // delete when unused
		false,      // exclusive
		false,      // noWait
		nil,        // arguments
	)
	if err != nil {
		return err
	}
	if err = channel.QueueBind(
		queue.Name, // name of the queue
		"fibratus", // bindingKey
		"fibratus", // sourceExchange
		false,      // noWait
		nil,        // arguments
	); err != nil {
		return err
	}
	deliveries, err := channel.Consume(
		queue.Name,         // name
		"kevents-consumer", // consumerTag,
		false,              // noAck
		false,              // exclusive
		false,              // noLocal
		false,              // noWait
		nil,                // arguments
	)
	require.NoError(t, err)

	go func() {
		for d := range deliveries {
			body := d.Body
			if len(body) == 0 {
				done <- struct{}{}
				t.Error("got empty AMQP message")
			}
			var kevents []*kevent.Kevent
			err := json.Unmarshal(body, &kevents)
			if err != nil {
				done <- struct{}{}
				t.Error(err)
			}
			if len(kevents) != 3 {
				done <- struct{}{}
				t.Errorf("expected 3 events in body but got %d", len(kevents))
			}
			err = d.Ack(false)
			if err != nil {
				t.Error(err)
			}
			done <- struct{}{}
		}
	}()

	return nil
}

//nolint:unused
func amqpURL(port int) string {
	return fmt.Sprintf("amqp://localhost:%d", port)
}

//nolint:unused
func getBatch() *kevent.Batch {
	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt1 := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt2 := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	return kevent.NewBatch(kevt, kevt1, kevt2)
}

```

`pkg/outputs/amqp/client.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/tls"
	log "github.com/sirupsen/logrus"
	"github.com/streadway/amqp"
	"net"
	"sync"
	"time"
)

var (
	connectionFailures = expvar.NewInt("output.amqp.connection.failures")
	channelFailures    = expvar.NewInt("output.amqp.channel.failures")
)

// client encapsulates the AMQP connection/channel and deals with configuring, establishing the connection
// and publishing messages to the exchange.
type client struct {
	conn     *amqp.Connection
	connLock sync.Mutex

	channel *amqp.Channel
	config  Config
	quit    chan struct{}
}

// newClient creates a new AMQP client and setups the connection/channel.
func newClient(config Config) *client {
	return &client{config: config, quit: make(chan struct{})}
}

// connect opens a connection to the AMQP broker honoring the preferences that were passed in the config.
func (c *client) connect(healthcheck bool) error {
	amqpConfig := amqp.Config{
		Vhost: c.config.Vhost,
		Dial: func(network, addr string) (net.Conn, error) {
			return net.DialTimeout(network, addr, c.config.Timeout)
		},
		SASL: c.config.auth(),
	}
	tlsConfig, err := tls.MakeConfig(c.config.TLSCert, c.config.TLSKey, c.config.TLSCA, c.config.TLSInsecureSkipVerify)
	if err != nil {
		return fmt.Errorf("invalid TLS config: %v", err)
	}
	amqpConfig.TLSClientConfig = tlsConfig

	c.connLock.Lock()
	defer c.connLock.Unlock()
	c.conn, err = amqp.DialConfig(c.config.URL, amqpConfig)
	if err != nil {
		return err
	}
	c.channel, err = c.conn.Channel()
	if err != nil {
		return fmt.Errorf("unable to open AMQP channel: %v", err)
	}

	log.Infof("established connection to AMQP broker on %s", c.config.URL)

	if healthcheck {
		go c.doHealthcheck()
	}

	return nil
}

// declareExchange creates the exchange in the broker where messages are published.
func (c *client) declareExchange() error {
	c.connLock.Lock()
	defer c.connLock.Unlock()
	var err error
	if c.config.Passive {
		err = c.channel.ExchangeDeclarePassive(
			c.config.Exchange,
			c.config.ExchangeType,
			c.config.Durable,
			false,
			false,
			false,
			nil,
		)
	} else {
		err = c.channel.ExchangeDeclare(
			c.config.Exchange,
			c.config.ExchangeType,
			c.config.Durable,
			false,
			false,
			false,
			nil,
		)
	}
	if err != nil {
		return fmt.Errorf("unable to declare %s exchange: %v", c.config.Exchange, err)
	}
	return nil
}

// publish sends the byte stream to the exchange.
func (c *client) publish(body []byte) error {
	return c.channel.Publish(c.config.Exchange, c.config.RoutingKey, false, false, c.msg(body))
}

func (c *client) msg(body []byte) amqp.Publishing {
	return amqp.Publishing{
		Body:         body,
		ContentType:  "text/json",
		Headers:      c.config.amqpHeaders(),
		DeliveryMode: c.config.deliveryMode(),
	}
}

// healthcheck monitors the state of the AMQP connection and its corresponding channel. Since AMQP channel is
// shutdown if an error occurs on it, we'll have to handle this situation properly and try to reopen the channel.
// Similarly if the connection is lost, the reconnect loop kicks in and tries to reconcile the connection state.
func (c *client) doHealthcheck() {
	notify := c.conn.NotifyClose(make(chan *amqp.Error))
	cnotify := c.channel.NotifyClose(make(chan *amqp.Error))
	go func() {
		for {
			select {
			case err := <-cnotify:
				if err != nil {
					channelFailures.Add(1)
					log.Warnf("channel error: %v. Trying to reopen...", err)
					c.connLock.Lock()
					if c.conn != nil && !c.conn.IsClosed() {
						for {
							var err error
							c.channel, err = c.conn.Channel()
							if err == nil {
								log.Info("channel reopened")
								cnotify = c.channel.NotifyClose(make(chan *amqp.Error))
								break
							}
							// sleep a bit before retrying
							time.Sleep(time.Millisecond * 500)
						}
					}
					c.connLock.Unlock()
				}
			case <-c.quit:
				return
			}
		}
	}()

	for {
		select {
		case err := <-notify:
			if err != nil {
				for {
					connectionFailures.Add(1)
					log.Warnf("connection error: %v. Trying to reconnect...", err)
					e := c.connect(false)
					if e == nil {
						log.Info("connection recovered")
						c.connLock.Lock()
						notify = c.conn.NotifyClose(make(chan *amqp.Error))
						c.connLock.Unlock()
						break
					}
				}
			}
		case <-c.quit:
			return
		}
	}
}

// close tears down the underlying AMQP connection.
func (c *client) close() error {
	if c.conn == nil {
		return nil
	}
	close(c.quit)
	c.connLock.Lock()
	defer c.connLock.Unlock()
	err := c.conn.Close()
	if err != nil && err != amqp.ErrClosed {
		return err
	}
	return nil
}

```

`pkg/outputs/amqp/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/spf13/pflag"
	"github.com/streadway/amqp"
	"time"
)

const (
	amqpURI          = "output.amqp.url"
	amqpTimeout      = "output.amqp.timeout"
	amqpVhost        = "output.amqp.vhost"
	amqpExchange     = "output.amqp.exchange"
	amqpRoutingKey   = "output.amqp.routing-key"
	amqpExchangeType = "output.amqp.exchange-type"
	amqpEnabled      = "output.amqp.enabled"
	amqpPassive      = "output.amqp.passive"
	amqpDurable      = "output.amqp.durable"
	amqpDeliveryMode = "output.amqp.delivery-mode"
	amqpUsername     = "output.amqp.username"
	amqpPassword     = "output.amqp.password"
)

// Config contains the tweaks that influence the behaviour of the AMQP output.
type Config struct {
	outputs.TLSConfig
	// Enabled indicates if the AMQP output is enabled
	Enabled bool `mapstructure:"enabled"`
	// URL represents the AMQP connection string.
	URL string `mapstructure:"url"`
	// Timeout specifies the AMQP connection timeout.
	Timeout time.Duration `mapstructure:"timeout"`
	// Exchange is the AMQP exchange for publishing events.
	Exchange string `mapstructure:"exchange"`
	// ExchangeType is the AMQP exchange type.
	ExchangeType string `mapstructure:"exchange-type"`
	// Passive indicates that the server checks whether the exchange already exists and raises an error if it doesn't exist.
	Passive bool `mapstructure:"passive"`
	// Durable indicates that the exchange is marked as durable. Durable exchanges can survive server restarts.
	Durable bool `mapstructure:"durable"`
	// DeliveryMode determines if a published message is persistent or transient.
	DeliveryMode string `mapstructure:"delivery-mode"`
	// RoutingKey represents the static routing key to link exchanges with queues.
	RoutingKey string `mapstructure:"routing-key"`
	// Username is the username for the plain authentication method.
	Username string `mapstructure:"username"`
	// Password is the password for the plain authentication method.
	Password string `mapstructure:"password"`
	// Vhost represents the virtual host name.
	Vhost string `mapstructure:"vhost"`
	// Headers contains a list of headers that are added to AMQP message
	Headers map[string]string `mapstructure:"headers"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(amqpURI, "amqp://localhost:5672", "Represents the AMQP broker address")
	flags.Duration(amqpTimeout, time.Second*5, "Specifies the AMQP connection timeout")
	flags.String(amqpVhost, "/", "The virtual host that provides logical grouping and separation of broker's resources")
	flags.String(amqpExchange, "fibratus", "Specifies the target exchange name")
	flags.String(amqpExchangeType, "topic", "Defines the AMQP exchange type")
	flags.String(amqpRoutingKey, "fibratus", "Specifies the routing key")
	flags.Bool(amqpDurable, false, "Indicates if the exchange is marked as durable. Durable exchanges can survive server restarts.")
	flags.Bool(amqpPassive, false, "Indicates if the server checks whether the exchange already exists and raises an error if it doesn't exist.")
	flags.Bool(amqpEnabled, false, "Indicates if the AMQP output is enabled")
	flags.String(amqpDeliveryMode, "transient", "Determines if a published message is persistent or transient")
	flags.String(amqpUsername, "", "The username for the plain authentication method")
	flags.String(amqpPassword, "", "The password for the plain authentication method")
	outputs.AddTLSFlags(flags, outputs.AMQP)
}

func (c Config) amqpHeaders() amqp.Table {
	headers := make(amqp.Table)
	for k, v := range c.Headers {
		headers[k] = v
	}
	return headers
}

func (c Config) deliveryMode() uint8 {
	switch c.DeliveryMode {
	case "transient":
		return amqp.Transient
	case "persistent":
		return amqp.Persistent
	default:
		return amqp.Transient
	}
}

func (c Config) auth() []amqp.Authentication {
	if c.Username == "" && c.Password == "" {
		return nil
	}
	return []amqp.Authentication{
		&amqp.PlainAuth{
			Username: c.Username,
			Password: c.Password,
		},
	}
}

```

`pkg/outputs/client.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
)

// Client represents the minimal interface all output implementors have to satisfy.
type Client interface {
	Close() error
	Publish(*kevent.Batch) error
	Connect() error
}

```

`pkg/outputs/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

import (
	"fmt"
	"github.com/spf13/pflag"
)

// Config contains the output configuration.
type Config struct {
	Type   Type
	Output interface{}
}

// TLSConfig stores the client TLS parameters.
type TLSConfig struct {
	// TLSCA represents the path of the certificate file that is associated with the Certification Authority (CA).
	TLSCA string `mapstructure:"tls-ca"`
	// TLSCert is the path to the certificate file.
	TLSCert string `mapstructure:"tls-cert"`
	// TLSKey represents the path to the public/private key file.
	TLSKey string `mapstructure:"tls-key"`
	// TLSInsecureSkipVerify skips the chain and host verification.
	TLSInsecureSkipVerify bool `mapstructure:"tls-insecure-skip-verify"`
}

// AddTLSFlags register the TLS flags for the specified output type.
func AddTLSFlags(flags *pflag.FlagSet, typ Type) {
	flags.String(tlsForOutput("tls-ca", typ), "", "Represents the path of the certificate file that is associated with the Certification Authority (CA)")
	flags.String(tlsForOutput("tls-cert", typ), "", "Path to certificate file")
	flags.String(tlsForOutput("tls-key", typ), "", "Path to the public/private key file")
	flags.Bool(tlsForOutput("tls-insecure-skip-verify", typ), false, "Indicates if the chain and host verification stage is skipped")
}

func tlsForOutput(name string, typ Type) string { return fmt.Sprintf("output.%s.%s", typ, name) }

```

`pkg/outputs/console/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package console

import "github.com/spf13/pflag"

const (
	frmt             = "output.console.format"
	tmpl             = "output.console.template"
	paramKVDelimiter = "output.console.kv-delimiter"
	enabled          = "output.console.enabled"
)

// Config contains the tweaks that influence the behaviour of the console output.
type Config struct {
	Format           string `mapstructure:"format"`
	Template         string `mapstructure:"template"`
	ParamKVDelimiter string `mapstructure:"kv-delimiter"`
	Enabled          bool   `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(frmt, string(pretty), "Specifies the output format. Choose between pretty|json")
	flags.String(paramKVDelimiter, "", "The delimiter symbol for the kparams key/value pairs")
	flags.String(tmpl, "", "Event formatting template")
	flags.Bool(enabled, true, "Indicates if the console output is enabled")
}

```

`pkg/outputs/console/console.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package console

import (
	"bufio"
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"os"
)

var (
	consoleErrors = expvar.NewInt("output.console.errors")
)

type format string

const (
	pretty format = "pretty"
	json   format = "json"
	// template represents the default template used in pretty rendering mode
	template = "{{ .Seq }} {{ .Timestamp }} - {{ .CPU }} {{ .Process }} ({{ .Pid }}) - {{ .Type }} ({{ .Kparams }})"
)

type console struct {
	writer    *bufio.Writer
	formatter *kevent.Formatter
	format    format
}

func init() {
	outputs.Register(outputs.Console, initConsole)
}

func initConsole(config outputs.Config) (outputs.OutputGroup, error) {
	stdout := os.Stdout
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.Console, config.Output))
	}
	tmpl := cfg.Template
	if tmpl == "" {
		tmpl = template
	}
	formatter, err := kevent.NewFormatter(tmpl)
	if err != nil {
		return outputs.Fail(err)
	}
	if cfg.ParamKVDelimiter != "" {
		kevent.ParamKVDelimiter = cfg.ParamKVDelimiter
	}

	c := &console{
		writer:    bufio.NewWriterSize(stdout, 8*1024),
		formatter: formatter,
		format:    format(cfg.Format),
	}
	return outputs.Success(c), nil
}

func (c *console) Close() error   { return c.writer.Flush() }
func (c *console) Connect() error { return nil }
func (c *console) Publish(batch *kevent.Batch) error {
	defer batch.Release()

	for _, kevt := range batch.Events {
		var buf []byte
		switch c.format {
		case json:
			buf = kevt.MarshalJSON()
		case pretty:
			buf = c.formatter.Format(kevt)
		default:
			return nil
		}

		if err := c.write(buf); err != nil {
			consoleErrors.Add(1)
			continue
		}
		if err := c.write(nl); err != nil {
			consoleErrors.Add(1)
			continue
		}
	}

	if err := c.writer.Flush(); err != nil {
		consoleErrors.Add(1)
		return err
	}

	return nil
}

var nl = []byte("\n")

func (c *console) write(buf []byte) error {
	written := 0
	for written < len(buf) {
		n, err := c.writer.Write(buf[written:])
		if err != nil {
			return err
		}
		written += n
	}
	return nil
}

```

`pkg/outputs/elasticsearch/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/spf13/pflag"
	"time"
)

const (
	esEnabled             = "output.elasticsearch.enabled"
	esServers             = "output.elasticsearch.servers"
	esTimeout             = "output.elasticsearch.timeout"
	esFlushPeriod         = "output.elasticsearch.flush-period"
	esHealthcheck         = "output.elasticsearch.healthcheck"
	esBulkWorkers         = "output.elasticsearch.bulk-workers"
	esHealthcheckInterval = "output.elasticsearch.healthcheck-interval"
	esHealthcheckTimeout  = "output.elasticsearch.healthcheck-timeout"
	esUsername            = "output.elasticsearch.username"
	esPassword            = "output.elasticsearch.password"
	esSniff               = "output.elasticsearch.sniff"
	esTraceLog            = "output.elasticsearch.trace-log"
	esIndexName           = "output.elasticsearch.index-name"
	esTemplateName        = "output.elasticsearch.template-name"
	esTemplateConfig      = "output.elasticsearch.template-config"
	esGzipCompression     = "output.elasticsearch.gzip-compression"
)

// Config contains the options for tweaking the output behaviour.
type Config struct {
	outputs.TLSConfig
	// Enabled determines whether ES output is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Servers contains a comma separated list of Elasticsearch instances that comprise the cluster.
	Servers []string `mapstructure:"servers"`
	// Timeout specifies the connection timeout.
	Timeout time.Duration `mapstructure:"timeout"`
	// FlushPeriod specifies when to flush the bulk at the end of the given interval.
	FlushPeriod time.Duration `mapstructure:"flush-period"`
	// BulkWorkers represents the number of workers that commit docs to Elasticserach.
	BulkWorkers int `mapstructure:"bulk-workers"`
	// Healthcheck enables/disables nodes health checking.
	Healthcheck bool `mapstructure:"healthcheck"`
	// HealthCheckInterval specifies the interval for checking if the Elasticsearch nodes are available.
	HealthCheckInterval time.Duration `mapstructure:"healthcheck-interval"`
	// HealthCheckTimeout sets the timeout for periodic health checks.
	HealthCheckTimeout time.Duration `mapstructure:"healthcheck-timeout"`
	// Username is the user name for the basic HTTP authentication.
	Username string `mapstructure:"username"`
	// Password is the password for the basic HTTP authentication.
	Password string `mapstructure:"password"`
	// Sniff enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list of available Elasticsearch nodes.
	Sniff bool `mapstructure:"sniff"`
	// TraceLog determines if the Elasticsearch trace log is enabled. Useful for troubleshooting.
	TraceLog bool `mapstructure:"tracelog"`
	// IndexName represents the target index for kernel events. It allows time specifiers to create indices per time frame.
	IndexName string `mapstructure:"index-name"`
	// TemplateName specifies the name of the index template.
	TemplateName string `mapstructure:"template-name"`
	// TemplateConfig contains the full JSON body of the index template.
	TemplateConfig string `mapstructure:"template-config"`
	// GzipCompression specifies if gzip compression is enabled.
	GzipCompression bool `mapstructure:"gzip-compression"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(esEnabled, false, "Determines whether ES output is enabled")
	flags.StringSlice(esServers, []string{"http://127.0.0.1:9200"}, "Contains a comma separated list of Elasticsearch instances that comprise the cluster")
	flags.Duration(esTimeout, time.Second*5, "Specifies the output connection timeout")
	flags.Duration(esFlushPeriod, time.Second, "Specifies when to flush the bulk at the end of the given interval")
	flags.Int(esBulkWorkers, 1, "Represents the number of workers that commit docs to Elasticsearch")
	flags.Bool(esHealthcheck, true, "Enables/disables nodes health checking")
	flags.Duration(esHealthcheckInterval, time.Second*10, "Specifies the interval for checking if the Elasticsearch nodes are available")
	flags.Duration(esHealthcheckTimeout, time.Second*5, "Specifies the timeout for periodic health checks")
	flags.String(esUsername, "", "Identifies the user name for the basic HTTP authentication")
	flags.String(esPassword, "", "Specifies the password for the basic HTTP authentication")
	flags.Bool(esSniff, false, "Enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list of available Elasticsearch nodes")
	flags.Bool(esTraceLog, false, "Determines if the Elasticsearch trace log is enabled. Useful for troubleshooting")
	flags.String(esTemplateName, "fibratus", "Specifies the name of the index template")
	flags.String(esIndexName, "fibratus", "Represents the target index for kernel events. It allows time specifiers to create indices per time frame")
	flags.String(esTemplateConfig, "", "Contains the full JSON body of the index template")
	flags.Bool(esGzipCompression, false, "Specifies if gzip compression is enabled")
}

```

`pkg/outputs/elasticsearch/elasticsearch.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"context"
	"encoding/json"
	"expvar"
	"fmt"
	"github.com/hashicorp/go-version"
	"github.com/olivere/elastic/v7"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/util/tls"
	log "github.com/sirupsen/logrus"
	"net/http"
)

// minElasticVersion is the minimal supported Elasticsearch version
var minElasticVersion, _ = version.NewVersion("5.5")

var (
	// totalBulkedDocs contains the number of total bulked docs
	totalBulkedDocs = expvar.NewInt("elasticsearch.total.bulked.docs")
	// committedDocs counts the number of docs commited to Elasticsearch
	committedDocs = expvar.NewInt("elasticsearch.committed.docs")
	// failedDocs counts the number of docs that failed to commit to Elasticsearch
	failedDocs = expvar.NewInt("elasticsearch.failed.docs")
)

type elasticsearch struct {
	client        *elastic.Client
	bulkProcessor *elastic.BulkProcessor
	config        Config
	index         index
}

type logger struct{}

func (l logger) Printf(format string, v ...interface{}) {
	log.Infof(format, v...)
}

func init() {
	outputs.Register(outputs.Elasticsearch, initElastic)
}

func initElastic(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.Elasticsearch, config.Output))
	}

	es := &elasticsearch{config: cfg, index: index{config: cfg}}

	return outputs.Success(es), nil
}

func (e *elasticsearch) Connect() error {
	var opts []elastic.ClientOptionFunc
	var client *elastic.Client
	var err error

	// setup a new HTTP client with optional TLS transport
	tlsConfig, err := tls.MakeConfig(e.config.TLSCert, e.config.TLSKey, e.config.TLSCA, e.config.TLSInsecureSkipVerify)
	if err != nil {
		return fmt.Errorf("invalid TLS config: %v", err)
	}
	httpClient := &http.Client{
		Timeout:   e.config.Timeout,
		Transport: &http.Transport{TLSClientConfig: tlsConfig},
	}

	opts = append(
		opts,
		elastic.SetSniff(e.config.Sniff),
		elastic.SetHttpClient(httpClient),
		elastic.SetURL(e.config.Servers...),
		elastic.SetGzip(e.config.GzipCompression),
		elastic.SetHealthcheck(e.config.Healthcheck),
		elastic.SetHealthcheckTimeout(e.config.HealthCheckTimeout),
		elastic.SetHealthcheckInterval(e.config.HealthCheckInterval),
	)

	if e.config.Username != "" && e.config.Password != "" {
		opts = append(
			opts,
			elastic.SetBasicAuth(e.config.Username, e.config.Password),
		)
	}
	if e.config.TraceLog {
		opts = append(opts, elastic.SetTraceLog(&logger{}))
	}

	client, err = elastic.NewClient(opts...)
	if err != nil {
		return err
	}

	ver, err := client.ElasticsearchVersion(e.config.Servers[0])
	if err != nil {
		return fmt.Errorf("unable to fetch Elasticsearch version: %v", err)
	}

	v, err := version.NewVersion(ver)
	if err != nil {
		return fmt.Errorf("unable to parse Elasticsearch version %s: %v", ver, err)
	}
	if v.LessThan(minElasticVersion) {
		return fmt.Errorf("required at least Elasticsearch %s but found version %s", minElasticVersion.String(), ver)
	}

	e.client = client
	e.index.client = client

	bulkProcessor, err := client.BulkProcessor().
		After(func(executionId int64, requests []elastic.BulkableRequest, response *elastic.BulkResponse, err error) {
			if err != nil {
				log.Errorf("failed to execute bulk: %s", err)
				return
			}

			if response.Errors {
				log.Errorf("failed to insert %d documents", len(response.Failed()))
				for i, fail := range response.Failed() {
					failedDocs.Add(1)
					log.Errorf("failed to insert document %d: %v", i, fail.Error)
				}
				return
			}
			committedDocs.Add(int64(len(requests)))
		}).
		FlushInterval(e.config.FlushPeriod).
		Workers(e.config.BulkWorkers).
		Do(context.Background())
	if err != nil {
		return fmt.Errorf("couldn't create Elasticsearch bulk processor: %v", err)
	}

	err = e.index.putTemplate()
	if err != nil {
		return err
	}

	err = bulkProcessor.Start(context.Background())
	if err != nil {
		return err
	}

	e.bulkProcessor = bulkProcessor

	log.Infof("established connection to Elasticsearch server(s): %v", e.config.Servers)

	return nil
}

func (e *elasticsearch) Publish(batch *kevent.Batch) error {
	for _, kevt := range batch.Events {
		indexName := e.index.getName(kevt)
		// create the bulk index request for each event in the batch.
		// We already have a valid JSON body, so just pass the raw
		// JSON message as request document
		e.bulkProcessor.Add(newBulkIndexRequest(indexName, kevt))
		totalBulkedDocs.Add(1)
	}
	batch.Release()

	return nil
}

func newBulkIndexRequest(indexName string, kevt *kevent.Kevent) *elastic.BulkIndexRequest {
	kjson := kevt.MarshalJSON()
	return elastic.NewBulkIndexRequest().Index(indexName).Doc(json.RawMessage(kjson))
}

func (e *elasticsearch) Close() error {
	if e.bulkProcessor != nil {
		// commit outstanding requests before shutdown
		if err := e.bulkProcessor.Flush(); err != nil {
			return err
		}
		return e.bulkProcessor.Close()
	}
	return nil
}

```

`pkg/outputs/elasticsearch/elasticsearch_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/olivere/elastic/v7"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestElasticsearchConnect(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ping := elastic.PingResult{
			Name: "es",
		}
		ping.Version.Number = "5.5.2"
		resp, err := json.Marshal(&ping)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}

		_, err = w.Write(resp)
		if err != nil {
			t.Fatal(err)
		}
	}))
	defer srv.Close()

	es := &elasticsearch{config: Config{Servers: []string{srv.URL}, Healthcheck: false}}

	require.NoError(t, es.Connect())
}

func TestElasticsearchConnectUnsupportedVersion(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ping := elastic.PingResult{
			Name: "es",
		}
		ping.Version.Number = "2.4.6"
		resp, err := json.Marshal(&ping)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}

		_, err = w.Write(resp)
		if err != nil {
			t.Fatal(err)
		}
	}))
	defer srv.Close()

	es := &elasticsearch{config: Config{Servers: []string{srv.URL}, Healthcheck: false}}

	require.Error(t, es.Connect())
}

func TestElasticsearchPublish(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "_bulk") {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			defer r.Body.Close()
			// check we have the correct index name
			assert.True(t, bytes.Contains(body, []byte("fibratus-2018-03")))
			// check kevent name is present
			assert.True(t, bytes.Contains(body, []byte("CreateFile")))

			// create the bulk response
			response := elastic.BulkResponse{
				Took:   1,
				Errors: false,
				Items:  []map[string]*elastic.BulkResponseItem{},
			}
			resp, err := json.Marshal(&response)
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
			}

			_, err = w.Write(resp)
			if err != nil {
				t.Fatal(err)
			}
		} else {
			ping := elastic.PingResult{
				Name: "es",
			}
			ping.Version.Number = "5.5.2"
			resp, err := json.Marshal(&ping)
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
			}

			_, err = w.Write(resp)
			if err != nil {
				t.Fatal(err)
			}
		}
	}))
	defer srv.Close()

	kevent.SerializeHandles = true

	cfg := Config{
		Servers:      []string{srv.URL},
		Healthcheck:  false,
		FlushPeriod:  time.Millisecond * 250,
		IndexName:    "fibratus-%Y-%d",
		TemplateName: "fibratus",
	}

	es := &elasticsearch{
		config: cfg,
		index:  index{config: cfg},
	}

	require.NoError(t, es.Connect())

	require.NoError(t, es.Publish(getBatch()))

	time.Sleep(time.Millisecond * 450)

	assert.Equal(t, int64(3), committedDocs.Value())
	assert.Equal(t, int64(0), failedDocs.Value())
}

func getBatch() *kevent.Batch {
	ts, _ := time.Parse(time.RFC3339, "2018-05-03T15:04:05.323Z")

	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   ts,
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt1 := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   ts,
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt2 := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   ts,
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	return kevent.NewBatch(kevt, kevt1, kevt2)
}

```

`pkg/outputs/elasticsearch/index.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"bytes"
	"context"
	"fmt"
	"github.com/olivere/elastic/v7"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"html/template"
	"strings"
	"time"
)

type index struct {
	config Config
	client *elastic.Client
}

// putTemplate creates the index template.
func (i index) putTemplate() error {
	if i.config.TemplateName == "" {
		return nil
	}
	// get the index pattern for the template
	indexPattern := i.config.IndexName
	if strings.Contains(indexPattern, "%") {
		indexPattern = indexPattern[0:strings.Index(indexPattern, "%")]
	}

	var b bytes.Buffer
	if i.config.TemplateConfig != "" {
		b.WriteString(i.config.TemplateConfig)
	} else {
		// expand the Go template
		tmpl := template.Must(template.New("template").Parse(indexTemplate))
		err := tmpl.Execute(&b, templateInfo{IndexPattern: indexPattern + "*"})
		if err != nil {
			return err
		}
	}

	ctx := context.Background()

	exists, err := i.client.IndexTemplateExists(i.config.TemplateName).Do(ctx)
	if err != nil {
		return fmt.Errorf("unable to check the existence of the %q template: %v", i.config.TemplateName, err)
	}
	if exists {
		return nil
	}
	// create index template
	_, err = i.client.IndexPutTemplate(i.config.TemplateName).BodyJson(b.String()).Do(ctx)
	if err != nil {
		return fmt.Errorf("unable to create index for the %q template: %v", i.config.TemplateName, err)
	}

	return nil
}

// getName creates an index name by replacing specifiers to create time frame indices. If no time specifiers are
// used this method returns a fixed index name.
func (i index) getName(kevt *kevent.Kevent) string {
	indexName := i.config.IndexName
	if !strings.Contains(indexName, "%") {
		return indexName
	}
	return i.replace(kevt.Timestamp)
}

func (i index) replace(timestamp time.Time) string {
	return strings.NewReplacer(
		"%Y", timestamp.UTC().Format("2006"),
		"%y", timestamp.UTC().Format("06"),
		"%m", timestamp.UTC().Format("01"),
		"%d", timestamp.UTC().Format("02"),
		"%H", timestamp.UTC().Format("15")).Replace(i.config.IndexName)
}

```

`pkg/outputs/elasticsearch/index_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestProduceIndexName(t *testing.T) {
	i := index{config: Config{IndexName: "fibratus-%Y-%m"}}

	ts, _ := time.Parse(time.RFC3339, "2011-05-03T15:04:05.323Z")

	indexName := i.getName(&kevent.Kevent{Timestamp: ts})
	assert.Equal(t, "fibratus-2011-05", indexName)

	i = index{config: Config{IndexName: "fibratus-%y-%d"}}

	indexName = i.getName(&kevent.Kevent{Timestamp: ts})
	assert.Equal(t, "fibratus-11-03", indexName)

	i = index{config: Config{IndexName: "fibratus-%d-%H"}}

	indexName = i.getName(&kevent.Kevent{Timestamp: ts})
	assert.Equal(t, "fibratus-03-15", indexName)

	i = index{config: Config{IndexName: "fibratus-events"}}

	indexName = i.getName(&kevent.Kevent{Timestamp: ts})
	assert.Equal(t, "fibratus-events", indexName)
}

```

`pkg/outputs/elasticsearch/template.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

type templateInfo struct {
	IndexPattern string
}

const indexTemplate = `
{
	"index_patterns": [ "{{ .IndexPattern }}" ],
	"settings": {
		"index": {
			"refresh_interval": "5s",
			"number_of_shards": 1,
			"number_of_replicas": 1
		}
	},
	"mappings": {
		"properties": {
			"seq": { "type": "long" },
			"pid": { "type": "long" },
			"tid": { "type": "long" },
			"cpu": { "type": "short" },

			"name": { "type": "keyword" },
			"category": { "type": "keyword" },
			"description": { "type": "text" },
			"host": { "type": "keyword" },

			"timestamp": { "type": "date" },

			"kparams": { 
				"type": "nested",
			    "properties": {
					"dip": { "type": "ip" },
					"sip": { "type": "ip" }
				}
			},
			
			"ps": {
				"type": "nested",
			    "properties": {
					"pid": { "type": "long" },
					"ppid": { "type": "long" },
					"name": { "type": "keyword" },
					"comm": { "type": "text" },
					"exe": { "type": "text" },
					"cwd": { "type": "text" },
					"sid": { "type": "keyword" },
					"sessionid": { "type": "short" },
					"handles": {
						"type": "nested",
						"properties": {
							"name": { "type": "text" },
							"type": { "type": "text" },
							"id": 	{ "type": "long" },
							"object": { "type": "keyword" }
						}
					}
				}
			}
			
		}
	}
}
`

```

`pkg/outputs/eventlog/api.go`:

```go
/*
 * Copyright 2012 The Go Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 *
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"bytes"
	"errors"
	"fmt"
	"syscall"

	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
)

const addKeyName = `SYSTEM\CurrentControlSet\Services\EventLog\Application`

const categoryCount = 8

// ErrKeyExists signals that the registry key already exists
var ErrKeyExists = fmt.Errorf("%s\\%s already exists", addKeyName, source)

// Eventlog provides access to the system log.
type Eventlog struct {
	Handle windows.Handle
}

// Open retrieves a handle to the specified event log.
func Open(source string) (*Eventlog, error) {
	return OpenRemote("", source)
}

// OpenRemote does the same as Open, but on different computer host.
func OpenRemote(host, source string) (*Eventlog, error) {
	if source == "" {
		return nil, errors.New("specify event log source")
	}
	var serverName *uint16
	if host != "" {
		var err error
		serverName, err = syscall.UTF16PtrFromString(host)
		if err != nil {
			return nil, err
		}
	}
	sourceName, err := syscall.UTF16PtrFromString(source)
	if err != nil {
		return nil, err
	}
	h, err := windows.RegisterEventSource(serverName, sourceName)
	if err != nil {
		return nil, err
	}
	return &Eventlog{Handle: h}, nil
}

// Install modifies PC registry to allow logging with an event source src.
// It adds all required keys and values to the event log registry key.
// Install uses msgFile as the event message file. If useExpandKey is true,
// the event message file is installed as REG_EXPAND_SZ value,
// otherwise as REG_SZ. Use bitwise of log.Error, log.Warning and
// log.Info to specify events supported by the new event source.
func Install(src, msgFile string, useExpandKey bool, eventsSupported uint32) error {
	appkey, err := registry.OpenKey(registry.LOCAL_MACHINE, addKeyName, registry.CREATE_SUB_KEY)
	if err != nil {
		return err
	}
	defer appkey.Close()

	sk, alreadyExist, err := registry.CreateKey(appkey, src, registry.SET_VALUE)
	if err != nil {
		return err
	}
	defer sk.Close()
	if alreadyExist {
		return ErrKeyExists
	}

	err = sk.SetDWordValue("CustomSource", 1)
	if err != nil {
		return err
	}
	if useExpandKey {
		err = sk.SetExpandStringValue("EventMessageFile", msgFile)
	} else {
		err = sk.SetStringValue("EventMessageFile", msgFile)
	}
	if err != nil {
		return err
	}
	if useExpandKey {
		err = sk.SetExpandStringValue("CategoryMessageFile", msgFile)
	} else {
		err = sk.SetStringValue("CategoryMessageFile", msgFile)
	}
	if err != nil {
		return err
	}
	err = sk.SetDWordValue("TypesSupported", eventsSupported)
	if err != nil {
		return err
	}
	err = sk.SetDWordValue("CategoryCount", categoryCount)
	if err != nil {
		return err
	}
	return nil
}

// Close closes event log.
func (l *Eventlog) Close() error {
	return windows.DeregisterEventSource(l.Handle)
}

func (l *Eventlog) report(etype uint16, eid uint32, category uint16, msg []byte) error {
	lines := bytes.Split(msg, []byte("\n"))
	ss := make([]*uint16, len(lines))
	for i, line := range lines {
		// line breaks
		if len(line) == 0 {
			line = []byte("\n")
		}
		s, err := syscall.UTF16PtrFromString(string(line))
		if err != nil {
			continue
		}
		ss[i] = s
	}
	return windows.ReportEvent(l.Handle, etype, category, eid, 0, uint16(len(ss)), 0, &ss[0], nil)
}

// Info writes an information event msg with event id eid to the end of event log.
func (l *Eventlog) Info(eid uint32, category uint16, msg []byte) error {
	return l.report(uint16(Info), eid, category, msg)
}

// Warning writes an warning event msg with event id eid to the end of event log.
func (l *Eventlog) Warning(eid uint32, category uint16, msg []byte) error {
	return l.report(uint16(Warn), eid, category, msg)
}

// Error writes an error event msg with event id eid to the end of event log.
func (l *Eventlog) Error(eid uint32, category uint16, msg []byte) error {
	return l.report(uint16(Erro), eid, category, msg)
}

```

`pkg/outputs/eventlog/config.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"fmt"
	"text/template"

	"github.com/spf13/pflag"
)

const (
	enabled    = "output.eventlog.enabled"
	level      = "output.eventlog.level"
	remoteHost = "output.eventlog.remote-host"
	tmpl       = "output.eventlog.template"
)

// Level is the type definition for the eventlog log level
type Level uint16

const (
	// Info represents the info log level
	Info Level = 4
	// Warn represents the warning info level
	Warn Level = 2
	// Erro represents the error log level
	Erro Level = 1
)

func levelFromString(s string) Level {
	switch s {
	case "info", "INFO":
		return Info
	case "warn", "warning", "WARN", "WARNING":
		return Warn
	case "erro", "error", "ERRO", "ERROR":
		return Erro
	default:
		panic(fmt.Sprintf("unrecognized evtlog level: %s", s))
	}
}

// Config contains configuration properties for fine-tuning the eventlog output.
type Config struct {
	// Enabled determines whether the eventlog output is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Level specifies the eventlog log level.
	Level string `mapstructure:"level"`
	// RemoteHost is the address of the remote eventlog intake.
	RemoteHost string `mapstructure:"remote-host"`
	// Template specifies the Go template for rendering the eventlog message.
	Template string `mapstructure:"template"`
}

func (c Config) parseTemplate() (*template.Template, error) {
	if c.Template == "" {
		// use built-in template
		return template.New("evtlog").Parse(Template)
	}
	return template.New("evtlog").Parse(c.Template)
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(tmpl, "", "Go template for rendering the eventlog message")
	flags.String(level, "info", "Specifies the eventlog level")
	flags.String(remoteHost, "", "Address of the remote eventlog intake")
	flags.Bool(enabled, false, "Indicates if the eventlog output is enabled")
}

```

`pkg/outputs/eventlog/eventlog.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"errors"
	"text/template"

	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

const (
	// source under which eventlog events are reported
	source = "Fibratus"
	// levels designates the supported eventlog levels
	levels = uint32(Info | Warn | Erro)
	// msgFile specifies the location of the eventlog message DLL
	msgFile = "%ProgramFiles%\\Fibratus\\fibratus.dll"
	// unknownEventID represents the unknown event identifier
	unknownEventID = 0
)

// ErrUnknownEventID represents the error for signaling unknown event identifiers. This error
// is raised when we can't get a valid mapping for the existing kernel event type.
var ErrUnknownEventID = errors.New("unknown event id found")

type evtlog struct {
	evtlog *Eventlog // eventlog writer
	config Config
	tmpl   *template.Template
}

func init() {
	outputs.Register(outputs.Eventlog, initEventlog)
}

func initEventlog(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.Eventlog, config.Output))
	}
	err := Install(source, msgFile, false, levels)
	if err != nil {
		// ignore error if the key already exists
		if !errors.Is(err, ErrKeyExists) {
			return outputs.Fail(err)
		}
	}
	evtlog := &evtlog{
		config: cfg,
	}
	evtlog.tmpl, err = cfg.parseTemplate()
	if err != nil {
		return outputs.Fail(err)
	}
	return outputs.Success(evtlog), nil
}

func (e *evtlog) Connect() error {
	var (
		evl *Eventlog
		err error
	)
	if e.config.RemoteHost != "" {
		evl, err = OpenRemote(e.config.RemoteHost, source)
	} else {
		evl, err = Open(source)
	}
	if err != nil {
		return err
	}
	e.evtlog = evl
	return nil
}

func (e *evtlog) Close() error {
	if e.evtlog != nil {
		return e.evtlog.Close()
	}
	return nil
}

func (e *evtlog) Publish(batch *kevent.Batch) error {
	defer batch.Release()

	for _, kevt := range batch.Events {
		if err := e.publish(kevt); err != nil {
			return err
		}
	}

	return nil
}

func (e *evtlog) publish(kevt *kevent.Kevent) error {
	buf, err := e.renderTemplate(kevt)
	if err != nil {
		return err
	}
	eventID := ktypeToEventID(kevt)
	if eventID == unknownEventID {
		return ErrUnknownEventID
	}
	err = e.log(eventID, categoryID(kevt), buf)
	if err != nil {
		return err
	}
	return nil
}

func (e *evtlog) log(eventID uint32, categoryID uint16, buf []byte) error {
	switch levelFromString(e.config.Level) {
	case Info:
		return e.evtlog.Info(eventID, categoryID, buf)
	case Warn:
		return e.evtlog.Warning(eventID, categoryID, buf)
	case Erro:
		return e.evtlog.Error(eventID, categoryID, buf)
	default:
		panic("unknown eventlog level")
	}
}

// kcatToCategoryID maps category name to eventlog identifier.
func categoryID(kevt *kevent.Kevent) uint16 {
	switch kevt.Category {
	case ktypes.Registry:
		return 1
	case ktypes.File:
		return 2
	case ktypes.Net:
		return 3
	case ktypes.Process:
		return 4
	case ktypes.Thread:
		return 5
	case ktypes.Image:
		return 6
	case ktypes.Handle:
		return 7
	case ktypes.Other:
		return 8
	default:
		return 0
	}
}

// ktypeToEventID returns the event ID from the event type.
func ktypeToEventID(kevt *kevent.Kevent) uint32 {
	switch kevt.Type {
	case ktypes.CreateProcess:
		return 15
	case ktypes.TerminateProcess:
		return 16
	case ktypes.OpenProcess:
		return 17
	case ktypes.LoadImage:
		return 18
	case ktypes.Connect:
		return 19
	case ktypes.CreateFile:
		return 20
	case ktypes.RegDeleteKey:
		return 21
	case ktypes.RegDeleteValue:
		return 22
	case ktypes.RegCreateKey:
		return 23
	case ktypes.RegSetValue:
		return 24
	case ktypes.CreateHandle:
		return 25
	case ktypes.DeleteFile:
		return 26
	case ktypes.CreateThread:
		return 27
	case ktypes.TerminateThread:
		return 28
	case ktypes.OpenThread:
		return 29
	case ktypes.UnloadImage:
		return 30
	case ktypes.WriteFile:
		return 31
	case ktypes.ReadFile:
		return 32
	case ktypes.RenameFile:
		return 33
	case ktypes.CloseFile:
		return 34
	case ktypes.SetFileInformation:
		return 35
	case ktypes.EnumDirectory:
		return 36
	case ktypes.RegOpenKey:
		return 37
	case ktypes.RegQueryKey:
		return 38
	case ktypes.RegQueryValue:
		return 39
	case ktypes.Accept:
		return 40
	case ktypes.Send:
		return 41
	case ktypes.Recv:
		return 42
	case ktypes.Disconnect:
		return 43
	case ktypes.Reconnect:
		return 44
	case ktypes.Retransmit:
		return 45
	case ktypes.CloseHandle:
		return 46
	}
	return unknownEventID
}

```

`pkg/outputs/eventlog/eventlog_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"errors"
	"testing"
	"time"

	"golang.org/x/sys/windows/svc/eventlog"

	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/require"
)

func TestEvtlogPublish(t *testing.T) {
	c := Config{
		Level: "INFO",
	}
	tmpl, err := c.parseTemplate()
	require.NoError(t, err)
	el := &evtlog{
		config: c,
		tmpl:   tmpl,
	}
	err = eventlog.InstallAsEventCreate(source, levels)
	if err != nil && !errors.Is(err, ErrKeyExists) {
		require.NoError(t, err)
	}
	require.NoError(t, el.Connect())
	require.NoError(t, el.Publish(getBatch()))
}

func getBatch() *kevent.Batch {
	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Modules: []pstypes.Module{
				{Name: "kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: kparams.Hex("fff23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
				{Name: "user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: kparams.Hex("fef23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pe.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pe.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	return kevent.NewBatch(kevt)
}

```

`pkg/outputs/eventlog/mc/fibratus.mc`:

```mc
;//************** Event categories ************
MessageId=1
SymbolicName=Registry
Language=English
Registry
.
MessageId=2
SymbolicName=File
Language=English
File
.
MessageId=3
SymbolicName=Network
Language=English
Network
.
MessageId=4
SymbolicName=Process
Language=English
Process
.
MessageId=5
SymbolicName=Thread
Language=English
Thread
.
MessageId=6
SymbolicName=Image
Language=English
Image
.
MessageId=7
SymbolicName=Handle
Language=English
Handle
.
MessageId=8
SymbolicName=Other
Language=English
Other
.

;//*********** Event types **************
MessageId=15
SymbolicName=CreateProcess
Language=English
CreateProcess creates a new process and its primary thread.
.
MessageId=16
SymbolicName=TerminateProcess
Language=English
TerminateProcess terminates the process and all of its threads.
.
MessageId=17
SymbolicName=OpenProcess
Language=English
OpenProcess opens the process handle.
.
MessageId=18
SymbolicName=LoadImage
Language=English
LoadImage loads the module into the address space of the calling process.
.
MessageId=19
SymbolicName=Connect
Language=English
Connect establishes a connection to the socket.
.
MessageId=20
SymbolicName=CreateFile
Language=English
CreateFile creates or opens a file or I/O device.
.
MessageId=21
SymbolicName=RegDeleteKey
Language=English
RegDeleteKey removes the registry key.
.
MessageId=22
SymbolicName=RegDeleteValue
Language=English
RegDeleteValue removes the registry value.
.
MessageId=23
SymbolicName=RegCreateKey
Language=English
RegCreateKey creates a registry key or opens it if the key already exists.
.
MessageId=24
SymbolicName=RegSetValue
Language=English
RegSetValue sets the data for the value of a registry key.
.
MessageId=25
SymbolicName=CreateHandle
Language=English
CreateHandle creates a new handle object.
.
MessageId=26
SymbolicName=DeleteFile
Language=English
DeleteFile removes the file from the file system.
.
MessageId=27
SymbolicName=CreateThread
Language=English
CreateThread creates a local/remote thread to execute within the virtual address space of the process.
.
MessageId=28
SymbolicName=TerminateThread
Language=English
TerminateThread terminates a thread within the process.
.
MessageId=29
SymbolicName=OpenThread
Language=English
OpenThread opens the thread handle.
.
MessageId=30
SymbolicName=UnloadImage
Language=English
UnloadImage unloads the module from the address space of the calling process.
.
MessageId=31
SymbolicName=WriteFile
Language=English
WriteFile writes data to the file or I/O device.
.
MessageId=32
SymbolicName=ReadFile
Language=English
ReadFile reads data from the file or I/O device.
.
MessageId=33
SymbolicName=RenameFile
Language=English
RenameFile changes the file name.
.
MessageId=34
SymbolicName=CloseFile
Language=English
CloseFile closes the file handle.
.
MessageId=35
SymbolicName=SetFileInformation
Language=English
SetFileInformation sets the file meta information.
.
MessageId=36
SymbolicName=EnumDirectory
Language=English
EnumDirectory enumerates a directory or dispatches a directory change notification to registered listeners.
.
MessageId=37
SymbolicName=RegOpenKey
Language=English
RegOpenKey opens the registry key.
.
MessageId=38
SymbolicName=RegQueryKey
Language=English
RegQueryKey enumerates subkeys of the parent key.
.
MessageId=39
SymbolicName=RegQueryValue
Language=English
RegQueryValue reads the data for the value of a registry key.
.
MessageId=40
SymbolicName=Accept
Language=English
Accept accepts the connection request from the socket queue.
.
MessageId=41
SymbolicName=Send
Language=English
Send sends data over the wire.
.
MessageId=42
SymbolicName=Recv
Language=English
Recv receives data from the socket.
.
MessageId=43
SymbolicName=Disconnect
Language=English
Disconnect terminates data reception on the socket.
.
MessageId=44
SymbolicName=Reconnect
Language=English
Reconnect reconnects to the socket.
.
MessageId=45
SymbolicName=Retransmit
Language=English
Retransmit retransmits unacknowledged TCP
.
MessageId=46
SymbolicName=Retransmit
Language=English
CloseHandle closes the handle object.
.

```

`pkg/outputs/eventlog/template.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"bytes"
	"fmt"

	"github.com/rabbitstack/fibratus/pkg/kevent"
)

// Template is the default Go template used for producing the eventlog messages.
var Template = `Name:  		{{ .Kevt.Name }}
Sequence: 		{{ .Kevt.Seq }}
Process ID:		{{ .Kevt.PID }}
Thread ID: 		{{ .Kevt.Tid }}
Cpu: 			{{ .Kevt.CPU }}
Params:			{{ .Kevt.Kparams }}
Category: 		{{ .Kevt.Category }}

{{- if .Kevt.PS }}

Process:		{{ .Kevt.PS.Name }}
Exe:			{{ .Kevt.PS.Exe }}
Pid:  			{{ .Kevt.PS.PID }}
Ppid: 			{{ .Kevt.PS.Ppid }}
Cmdline:		{{ .Kevt.PS.Comm }}
Cwd:			{{ .Kevt.PS.Cwd }}
SID:			{{ .Kevt.PS.SID }}
Session ID:		{{ .Kevt.PS.SessionID }}
{{ if and (.SerializeEnvs) (.Kevt.PS.Envs) }}
Env:
			{{- with .Kevt.PS.Envs }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeThreads }}
Threads:
			{{- with .Kevt.PS.Threads }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeImages }}
Modules:
			{{- with .Kevt.PS.Modules }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if and (.SerializeHandles) (.Kevt.PS.Handles) }}
Handles:
			{{- with .Kevt.PS.Handles }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}

{{ if and (.SerializePE) (.Kevt.PS.PE) }}
Entrypoint:  		{{ .Kevt.PS.PE.EntryPoint }}
Image base: 		{{ .Kevt.PS.PE.ImageBase }}
Build date:  		{{ .Kevt.PS.PE.LinkTime }}

Number of symbols: 	{{ .Kevt.PS.PE.NumberOfSymbols }}
Number of sections: {{ .Kevt.PS.PE.NumberOfSections }}

Sections:
			{{- with .Kevt.PS.PE.Sections }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ if .Kevt.PS.PE.Symbols }}
Symbols:
			{{- with .Kevt.PS.PE.Symbols }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Kevt.PS.PE.Imports }}
Imports:
			{{- with .Kevt.PS.PE.Imports }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Kevt.PS.PE.VersionResources }}
Resources:
			{{- with .Kevt.PS.PE.VersionResources }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
			{{ end }}
{{ end }}
{{- end }}
`

func (e *evtlog) renderTemplate(kevt *kevent.Kevent) ([]byte, error) {
	var writer bytes.Buffer
	data := struct {
		Kevt             *kevent.Kevent
		SerializeHandles bool
		SerializeThreads bool
		SerializeImages  bool
		SerializeEnvs    bool
		SerializePE      bool
	}{
		kevt,
		kevent.SerializeHandles,
		kevent.SerializeThreads,
		kevent.SerializeImages,
		kevent.SerializeEnvs,
		kevent.SerializePE,
	}
	err := e.tmpl.Execute(&writer, data)
	if err != nil {
		return nil, fmt.Errorf("unable to render eventlog template: %v", err)
	}
	return writer.Bytes(), nil
}

```

`pkg/outputs/http/client.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/rabbitstack/fibratus/pkg/util/tls"
)

// newHTTPClient builds a fresh stdlib HTTP client. The HTTP proxy and TLS config is set
// accordingly if enabled in the HTTP output preferences.
func newHTTPClient(config Config) (*http.Client, error) {
	tlsConfig, err := tls.MakeConfig(config.TLSCert, config.TLSKey, config.TLSCA, config.TLSInsecureSkipVerify)
	if err != nil {
		return nil, fmt.Errorf("invalid TLS config: %v", err)
	}

	proxy := http.ProxyFromEnvironment
	if config.ProxyURL != "" {
		address, err := url.Parse(config.ProxyURL)
		if err != nil {
			return nil, fmt.Errorf("invalid HTTP proxy url %q: %w", config.ProxyURL, err)
		}
		if config.ProxyUsername != "" && config.ProxyPassword != "" {
			proxy = http.ProxyURL(&url.URL{
				Scheme: address.Scheme,
				User:   url.UserPassword(config.ProxyUsername, config.ProxyPassword),
				Host:   config.ProxyURL,
			})
		} else {
			proxy = http.ProxyURL(address)
		}
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
		Proxy:           proxy,
	}
	httpClient := &http.Client{
		Transport: transport,
		Timeout:   config.Timeout,
	}

	return httpClient, nil
}

```

`pkg/outputs/http/config.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"time"

	"github.com/spf13/pflag"

	"github.com/rabbitstack/fibratus/pkg/outputs"
)

const (
	httpEnabled       = "output.http.enabled"
	httpTimeout       = "output.http.timeout"
	httpProxyURL      = "output.http.proxy-url"
	httpProxyUsername = "output.http.proxy-username"
	httpProxyPassword = "output.http.proxy-password"
	httpMethod        = "output.http.method"
	httpUsername      = "output.http.username"
	httpPassword      = "output.http.password"
	httpEndpoints     = "output.http.endpoints"
	httpEnableGzip    = "output.http.enable-gzip"
	httpSerializer    = "output.http.serializer"
)

// Config contains the options for tweaking the HTTP output behaviour.
type Config struct {
	outputs.TLSConfig
	// Enabled determines whether HTTP output is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Endpoints contains a collection of URLs to which the events are sent.
	Endpoints []string `mapstructure:"endpoints"`
	// Timeout represents the timeout for the HTTP requests.
	Timeout time.Duration `mapstructure:"timeout"`
	// ProxyURL specifies the HTTP proxy URL.
	ProxyURL string `mapstructure:"proxy-url"`
	// ProxyUsername is the username for proxy authentication.
	ProxyUsername string `mapstructure:"proxy-username"`
	// ProxyPassword is the password for proxy authentication.
	ProxyPassword string `mapstructure:"proxy-password"`
	// Method determines the HTTP verb in the requests.
	Method string `mapstructure:"method"`
	// Username is the username for the basic HTTP authentication.
	Username string `mapstructure:"username"`
	// Password is the password for the basic HTTP authentication.
	Password string `mapstructure:"password"`
	// Headers contains a list of additional headers in the HTTP request
	Headers map[string]string `mapstructure:"headers"`
	// EnableGzip specifies whether the gzip compression is enabled.
	EnableGzip bool `mapstructure:"enable-gzip"`
	// Serializer indicates the serializer for the HTTP request body.
	Serializer outputs.Serializer `mapstructure:"serializer"`
}

// AddFlags registers persistent flags for the HTTP output.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(httpEnabled, false, "Determines whether the HTTP output is enabled")
	flags.Duration(httpTimeout, time.Second*5, "Represents the timeout for the HTTP requests")
	flags.StringSlice(httpEndpoints, []string{}, "A comma-separated list of endpoints to which the events are sent. Must contain the HTTP/S protocol schema")
	flags.String(httpProxyURL, "", "Specifies the HTTP proxy URL. It overrides the HTTP proxy URL as indicated by the environment variables")
	flags.String(httpProxyUsername, "", "The username for HTTP proxy authentication")
	flags.String(httpProxyPassword, "", "The password for HTTP proxy authentication")
	flags.String(httpMethod, "POST", "Determines the HTTP verb to use in requests")
	flags.String(httpUsername, "", "Username for the basic HTTP authentication")
	flags.String(httpPassword, "", "Password for the basic HTTP authentication")
	flags.Bool(httpEnableGzip, false, "Indicates whether the gzip compression is enabled")
	flags.String(httpSerializer, string(outputs.JSON), "Indicates the event serializer type")
	outputs.AddTLSFlags(flags, outputs.HTTP)
}

```

`pkg/outputs/http/http.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"bytes"
	"compress/gzip"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"

	"github.com/rabbitstack/fibratus/pkg/util/version"

	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

// userAgentHeader represents the value of the User-Agent header
var userAgentHeader = version.ProductToken()

// defaultContentType represents the default content type for HTTP requests
const defaultContentType = "application/json"

type _http struct {
	client *http.Client
	config Config
	url    string
}

func init() {
	outputs.Register(outputs.HTTP, initHTTP)
}

func initHTTP(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.HTTP, config.Output))
	}

	clients := make([]outputs.Client, len(cfg.Endpoints))
	for i, endpoint := range cfg.Endpoints {
		_, err := url.Parse(endpoint)
		if err != nil {
			return outputs.Fail(err)
		}
		client, err := newHTTPClient(cfg)
		if err != nil {
			return outputs.Fail(err)
		}

		clients[i] = &_http{
			client: client,
			config: cfg,
			url:    endpoint,
		}
	}

	return outputs.Success(clients...), nil
}

func (h *_http) Connect() error { return nil }
func (h *_http) Close() error   { return nil }

func (h *_http) Publish(batch *kevent.Batch) error {
	var buf []byte
	defer batch.Release()
	switch h.config.Serializer {
	case outputs.JSON:
		buf = batch.MarshalJSON()
	}

	if h.config.EnableGzip {
		var bb bytes.Buffer
		gz := gzip.NewWriter(&bb)
		if _, err := gz.Write(buf); err != nil {
			return err
		}
		if err := gz.Close(); err != nil {
			return err
		}
		buf = bb.Bytes()
	}

	ctx, cancel := context.WithTimeout(context.Background(), h.config.Timeout)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, h.config.Method, h.url, bytes.NewBuffer(buf))
	if err != nil {
		return err
	}

	h.setHeaders(req)
	h.setBasicAuth(req)

	resp, err := h.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		return fmt.Errorf("http request failed with %d status code: %v", resp.StatusCode, string(body))
	}

	return nil
}

// setBasicAuth sets the request's Authorization header to use HTTP
// Basic Authentication with the provided username and password.
func (h *_http) setBasicAuth(req *http.Request) {
	if h.config.Username != "" && h.config.Password != "" {
		req.SetBasicAuth(h.config.Username, h.config.Password)
	}
}

// setHeaders populates required and optional request headers.
func (h *_http) setHeaders(req *http.Request) {
	req.Header.Set("User-Agent", userAgentHeader)
	req.Header.Set("Content-Type", defaultContentType)
	if h.config.EnableGzip {
		req.Header.Set("Content-Encoding", "gzip")
	}
	for k, v := range h.config.Headers {
		req.Header.Set(k, v)
	}
}

```

`pkg/outputs/http/http_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"compress/gzip"
	"encoding/json"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	shandle "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/require"
)

func TestHttpPublish(t *testing.T) {
	l, err := net.Listen("tcp", "127.0.0.1:8081")
	if err != nil {
		log.Fatal(err)
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/intake", func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		var kevents []*kevent.Kevent
		if err := json.Unmarshal(body, &kevents); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		assert.Equal(t, 3, len(kevents))
		assert.Equal(t, "aaabbbaaa", r.Header.Get("API-Key"))
		assert.Equal(t, "fibratus/", r.Header.Get("User-Agent"))
		assert.Equal(t, "1.1", r.Header.Get("Version"))
		assert.Equal(t, "Basic dXNlcjpwYXNz", r.Header.Get("Authorization"))
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewUnstartedServer(mux)

	srv.Listener.Close()
	srv.Listener = l

	srv.Start()
	defer srv.Close()

	c := Config{
		Timeout: time.Second * 3,
		Headers: map[string]string{
			"API-Key": "aaabbbaaa",
			"Version": "1.1",
		},
		Username:   "user",
		Password:   "pass",
		Serializer: outputs.JSON,
	}

	httpClient, err := newHTTPClient(c)
	require.NoError(t, err)

	h := _http{config: c, client: httpClient, url: "http://127.0.0.1:8081/intake"}

	err = h.Publish(getBatch())
	require.NoError(t, err)
}

func TestHttpGzipPublish(t *testing.T) {
	l, err := net.Listen("tcp", "127.0.0.1:8081")
	if err != nil {
		log.Fatal(err)
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/intake", func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "gzip", r.Header.Get("Content-Encoding"))
		gr, err := gzip.NewReader(r.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		body, err := ioutil.ReadAll(gr)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		var kevents []*kevent.Kevent
		if err := json.Unmarshal(body, &kevents); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		assert.Equal(t, 3, len(kevents))
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewUnstartedServer(mux)

	srv.Listener.Close()
	srv.Listener = l

	srv.Start()
	defer srv.Close()

	c := Config{
		Timeout:    time.Second * 3,
		EnableGzip: true,
		Serializer: outputs.JSON,
	}

	httpClient, err := newHTTPClient(c)
	require.NoError(t, err)

	h := _http{config: c, client: httpClient, url: "http://127.0.0.1:8081/intake"}

	err = h.Publish(getBatch())
	require.NoError(t, err)
}

func getBatch() *kevent.Batch {
	kevt := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt1 := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	kevt2 := &kevent.Kevent{
		Type:        ktypes.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    ktypes.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Kparams: kevent.Kparams{
			kparams.FileObject:    {Name: kparams.FileObject, Type: kparams.Uint64, Value: uint64(12456738026482168384)},
			kparams.FileName:      {Name: kparams.FileName, Type: kparams.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			kparams.FileType:      {Name: kparams.FileType, Type: kparams.AnsiString, Value: "file"},
			kparams.FileOperation: {Name: kparams.FileOperation, Type: kparams.AnsiString, Value: "open"},
			kparams.BasePrio:      {Name: kparams.BasePrio, Type: kparams.Int8, Value: int8(2)},
			kparams.PagePrio:      {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(2)},
		},
		Metadata: map[kevent.MetadataKey]string{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
				3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			},
			Handles: []htypes.Handle{
				{Num: shandle.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  shandle.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  shandle.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	return kevent.NewBatch(kevt, kevt1, kevt2)
}

```

`pkg/outputs/null/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package null

// Config contains preferences for the null output.
type Config struct{}

```

`pkg/outputs/null/null.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package null

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

var blackholeEventsCount = expvar.NewInt("output.null.blackhole.events")

// null output devours kernel events the same way a black hole swallows the light
type null struct{}

func init() {
	outputs.Register(outputs.Null, initNull)
}

func initNull(config outputs.Config) (outputs.OutputGroup, error) {
	return outputs.Success(&null{}), nil
}

func (null) Close() error   { return nil }
func (null) Connect() error { return nil }
func (null) Publish(batch *kevent.Batch) error {
	blackholeEventsCount.Add(batch.Len())
	batch.Release()
	return nil
}

```

`pkg/outputs/outputs.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

import (
	"fmt"
	"reflect"
	"strings"
)

var (
	outputs = map[Type]Factory{}
	// ErrInvalidConfig signals an invalid configuration input
	ErrInvalidConfig = func(name Type, c interface{}) error {
		return fmt.Errorf("invalid config for %q output. Got type %v instead of %s.Config", name, reflect.TypeOf(c), strings.ToLower(name.String()))
	}
)

// Factory serves for constructing different output implementations from configuration.
type Factory func(config Config) (OutputGroup, error)

// Type is the alias for the output type.
type Type uint8

const (
	// Console represents the default terminal output.
	Console Type = iota
	// AMQP denotes the AMQP output.
	AMQP
	// Elasticsearch denotes the Elasticsearch output.
	Elasticsearch
	// HTTP denotes the HTTP output.
	HTTP
	// Eventlog denotes the eventlog output.
	Eventlog
	// Null is the null output.
	Null
	// Unknown is an undefined output type.
	Unknown
)

// String returns the string representation of the output type.
func (t Type) String() string {
	switch t {
	case Console:
		return "console"
	case AMQP:
		return "amqp"
	case Elasticsearch:
		return "elasticsearch"
	case HTTP:
		return "http"
	case Eventlog:
		return "eventlog"
	case Null:
		return "null"
	default:
		return "unknown"
	}
}

// TypeFromString parses output type from input string.
func TypeFromString(s string) Type {
	switch s {
	case "console":
		return Console
	case "amqp":
		return AMQP
	case "elasticsearch":
		return Elasticsearch
	case "http":
		return HTTP
	case "eventlog":
		return Eventlog
	case "null":
		return Null
	default:
		return Unknown
	}
}

// OutputGroup is a collection of outputs that can be configured in a load-balanced fashion.
type OutputGroup struct {
	// Clients is the list of clients to which events are forwarded.
	Clients []Client
}

// Success builds the output group from the provided clients.
func Success(clients ...Client) OutputGroup {
	return OutputGroup{Clients: clients}
}

// Fail returns an empty output group and an error signaling the failure that caused the output group initialization.
func Fail(err error) (OutputGroup, error) {
	return OutputGroup{}, err
}

// Register registers a new output implementation. Note this function should be only called once per output.
func Register(typ Type, factory Factory) {
	if _, ok := outputs[typ]; ok {
		panic(fmt.Sprintf("output %q is already registered", typ))
	}
	outputs[typ] = factory
}

// FindFactory locates the output factory.
func FindFactory(typ Type) Factory {
	return outputs[typ]
}

// Load loads the specified output from configuration. The output must have been registered previously.
func Load(typ Type, config Config) (OutputGroup, error) {
	factory := FindFactory(typ)
	if factory == nil {
		return OutputGroup{}, fmt.Errorf("output %q not availaible in the factory", typ)
	}
	return factory(config)
}

```

`pkg/outputs/serializer.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

// Serializer is the type definition for the output serializers.
type Serializer string

const (
	// JSON represents the JSON serializer type.
	JSON Serializer = "json"
)

```

`pkg/pe/config.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"path/filepath"
	"strings"
)

const (
	enabled        = "pe.enabled"
	readResources  = "pe.read-resources"
	readSymbols    = "pe.read-symbols"
	readSections   = "pe.read-sections"
	excludedImages = "pe.excluded-images"
)

// Config stores the preferences that dictate the behaviour of the PE reader.
type Config struct {
	Enabled        bool     `json:"pe.enabled" yaml:"pe.enabled"`
	ReadResources  bool     `json:"pe.read-resources" yaml:"pe.read-resources"`
	ReadSymbols    bool     `json:"pe.read-symbols" yaml:"pe.read-symbols"`
	ReadSections   bool     `json:"pe.read-sections" yaml:"pe.read-sections"`
	ExcludedImages []string `json:"pe.excluded-images" yaml:"pe.excluded-images"`
}

// InitFromViper initializes PE config from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Enabled = v.GetBool(enabled)
	c.ReadResources = v.GetBool(readResources)
	c.ReadSymbols = v.GetBool(readSymbols)
	c.ReadSections = v.GetBool(readSections)
	c.ExcludedImages = v.GetStringSlice(excludedImages)
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Specifies if PE metadata is fetched from the process' image file")
	flags.Bool(readResources, false, "Determines if resources are read from the PE resource directory")
	flags.Bool(readSymbols, false, "Indicates if symbols are read from the PE")
	flags.Bool(readSections, false, "Indicates if full section inspection is allowed")
	flags.StringSlice(excludedImages, []string{}, "Contains a list of comma-separated images names that are excluded from PE parsing")
}

// ShouldSkipProcess determines whether the specified filename name is ignored by PE reader.
func (c Config) shouldSkipImage(filename string) bool {
	for _, img := range c.ExcludedImages {
		if strings.EqualFold(img, filepath.Base(filename)) {
			return true
		}
	}
	return false
}

```

`pkg/pe/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package pe contains different facilities for dealing with Portable Executable specifics and digging out valuable insights
// from it.
package pe

```

`pkg/pe/entropy.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import "math"

// entropy calculates the entropy of the PE section's data. This function relies
// on Shannon Entropy formula to calculate the entropy. High entropy scores mean
// that there is a high variety of frequency over data located in sections.
func entropy(data []byte) float64 {
	entropy := 0.0
	frq := make(map[byte]int, len(data))

	// get the frequency of each rune
	for _, i := range data {
		frq[i]++
	}

	for _, value := range frq {
		k := float64(value) / float64(len(data))
		entropy -= k * math.Log2(k)
	}

	return entropy
}

```

`pkg/pe/marshaller.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"math"
	"time"
	"unsafe"
)

// Marshal dumps the PE metadata to binary stream.
func (pe *PE) Marshal() []byte {
	b := make([]byte, 0)

	// number of sections/symbols
	b = append(b, bytes.WriteUint16(pe.NumberOfSections)...)
	b = append(b, bytes.WriteUint32(pe.NumberOfSymbols)...)

	// image base
	b = append(b, bytes.WriteUint16(uint16(len(pe.ImageBase)))...)
	b = append(b, pe.ImageBase...)

	// entry point
	b = append(b, bytes.WriteUint16(uint16(len(pe.EntryPoint)))...)
	b = append(b, pe.EntryPoint...)

	// link time
	linkTime := make([]byte, 0)
	linkTime = pe.LinkTime.AppendFormat(linkTime, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(linkTime)))...)
	b = append(b, linkTime...)

	// sections
	b = append(b, bytes.WriteUint16(uint16(len(pe.Sections)))...)
	for _, sec := range pe.Sections {
		// size
		b = append(b, bytes.WriteUint32(sec.Size)...)
		// entropy
		b = append(b, bytes.WriteUint64(math.Float64bits(sec.Entropy))...)
		// name
		b = append(b, bytes.WriteUint16(uint16(len(sec.Name)))...)
		b = append(b, sec.Name...)
		// md5
		b = append(b, bytes.WriteUint16(uint16(len(sec.Md5)))...)
		b = append(b, sec.Md5...)
	}

	// symbols
	b = append(b, bytes.WriteUint16(uint16(len(pe.Symbols)))...)
	for _, sym := range pe.Symbols {
		b = append(b, bytes.WriteUint16(uint16(len(sym)))...)
		b = append(b, sym...)
	}

	// imports
	b = append(b, bytes.WriteUint16(uint16(len(pe.Imports)))...)
	for _, imp := range pe.Imports {
		b = append(b, bytes.WriteUint16(uint16(len(imp)))...)
		b = append(b, imp...)
	}

	// version resources
	b = append(b, bytes.WriteUint16(uint16(len(pe.VersionResources)))...)
	for k, v := range pe.VersionResources {
		b = append(b, bytes.WriteUint16(uint16(len(k)))...)
		b = append(b, k...)
		b = append(b, bytes.WriteUint16(uint16(len(v)))...)
		b = append(b, v...)
	}

	return b
}

// Unmarshal recovers the PE metadata from the byte stream.
func (pe *PE) Unmarshal(b []byte) error {
	if len(b) < 6 {
		return fmt.Errorf("expected at least 6 bytes but got %d bytes", len(b))
	}

	pe.NumberOfSections = bytes.ReadUint16(b[0:])
	pe.NumberOfSymbols = bytes.ReadUint32(b[2:])

	// image base
	l := bytes.ReadUint16(b[6:])
	buf := b[8:]
	offset := uint32(l)
	pe.ImageBase = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// entry point
	l = bytes.ReadUint16(b[8+offset:])
	buf = b[10+offset:]
	offset += uint32(l)
	pe.EntryPoint = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// link time
	l = bytes.ReadUint16(b[10+offset:])
	buf = b[12+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		pe.LinkTime, _ = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
	}

	// read sections
	nsections := bytes.ReadUint16(b[12+offset:])
	var soffset uint32

	for nsec := 0; nsec < int(nsections); nsec++ {
		// section size
		size := bytes.ReadUint32(b[14+offset+soffset:])
		// entropy
		entropy := bytes.ReadUint64(b[18+offset+soffset:])

		// section name
		l := bytes.ReadUint16(b[26+offset+soffset:])
		buf := b[28+offset+soffset:]
		soffset += uint32(l)
		name := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

		// section md5 hash
		l = bytes.ReadUint16(b[28+offset+soffset:])
		buf = b[30+offset+soffset:]
		soffset += uint32(l)
		md5 := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

		pe.Sections = append(pe.Sections,
			Sec{
				Name:    name,
				Size:    size,
				Entropy: math.Float64frombits(entropy),
				Md5:     md5,
			},
		)

		// increment the offset by summing the byte length of the size + entropy, and the section name length + md5 length encoded as uint16 values
		soffset += 4 + 8 + 2 + 2
	}

	offset += soffset

	// read symbols
	nsyms := bytes.ReadUint16(b[14+offset:])
	var syoffset uint32

	for nsym := 0; nsym < int(nsyms); nsym++ {
		l := bytes.ReadUint16(b[16+offset+syoffset:])
		buf := b[18+offset+syoffset:]
		pe.Symbols = append(pe.Symbols, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		syoffset += uint32(l + 2)
	}
	offset += syoffset

	// read imports
	nimports := bytes.ReadUint16(b[16+offset:])
	var ioffset uint32

	for nimp := 0; nimp < int(nimports); nimp++ {
		l := bytes.ReadUint16(b[18+offset+ioffset:])
		buf := b[20+offset+ioffset:]
		pe.Imports = append(pe.Imports, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		ioffset += uint32(l + 2)
	}

	offset += ioffset

	// read version resources
	nresources := bytes.ReadUint16(b[18+offset:])
	var roffset uint32

	for nres := 0; nres < int(nresources); nres++ {
		// read key
		klen := bytes.ReadUint16(b[20+offset+roffset:])
		buf := b[22+offset+roffset:]
		key := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:klen:klen])
		// read value
		vlen := bytes.ReadUint16(b[22+offset+uint32(klen)+roffset:])
		buf = b[24+offset+uint32(klen)+roffset:]
		if vlen == 0 {
			roffset += uint32(klen) + 4
			continue
		}
		value := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:vlen:vlen])
		// increment the offset by the length of the key + length value + size of uint16 * 2
		// that corresponds to byte patterns storing the lengths of the keys/values
		roffset += uint32(klen) + uint32(vlen) + 4
		if key != "" {
			pe.VersionResources[key] = value
		}
	}

	return nil
}

// NewFromKcap restores the PE metadata from the byte stream.
func NewFromKcap(b []byte) (*PE, error) {
	pe := &PE{
		Sections:         make([]Sec, 0),
		Symbols:          make([]string, 0),
		Imports:          make([]string, 0),
		VersionResources: make(map[string]string),
	}
	if err := pe.Unmarshal(b); err != nil {
		return nil, err
	}
	return pe, nil
}

```

`pkg/pe/marshaller_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestMetadataMarshal(t *testing.T) {
	now := time.Now()

	pe := &PE{
		NumberOfSections: 7,
		NumberOfSymbols:  10,
		EntryPoint:       "20110",
		ImageBase:        "140000000",
		LinkTime:         now,
		Sections: []Sec{
			{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
			{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
		},
		Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
		Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
		VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
	}

	b := pe.Marshal()

	newPE := &PE{VersionResources: make(map[string]string)}
	err := newPE.Unmarshal(b)
	require.NoError(t, err)

	assert.Equal(t, uint16(7), newPE.NumberOfSections)
	assert.Equal(t, uint32(10), newPE.NumberOfSymbols)
	assert.Equal(t, "20110", newPE.EntryPoint)
	assert.Equal(t, "140000000", newPE.ImageBase)

	assert.Equal(t, now.Day(), newPE.LinkTime.Day())
	assert.Equal(t, now.Minute(), newPE.LinkTime.Minute())

	assert.Len(t, newPE.Sections, 2)

	textSection := newPE.Sections[0]
	assert.Equal(t, ".text", textSection.Name)
	assert.Equal(t, uint32(132608), textSection.Size)
	assert.Equal(t, 6.368381, textSection.Entropy)
	assert.Equal(t, "db23dce3911a42e987041d98abd4f7cd", textSection.Md5)

	assert.Len(t, newPE.Symbols, 5)
	assert.Contains(t, newPE.Symbols, "SelectObject")
	assert.Contains(t, newPE.Symbols, "TextOutW")

	assert.Len(t, newPE.Imports, 4)
	assert.Contains(t, newPE.Imports, "GDI32.dll")
	assert.Contains(t, newPE.Imports, "msvcrt.dll")

	assert.Len(t, newPE.VersionResources, 3)
	assert.Contains(t, newPE.VersionResources, "CompanyName")
	assert.Contains(t, newPE.VersionResources, "FileVersion")

	assert.Equal(t, "10.0.18362.693", newPE.VersionResources["FileVersion"])
	assert.Equal(t, "Microsoft Corporation", newPE.VersionResources["CompanyName"])
	assert.Equal(t, "Notepad", newPE.VersionResources["FileDescription"])
}

```

`pkg/pe/reader.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"bytes"
	"debug/pe"
	"expvar"
	"io"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	log "github.com/sirupsen/logrus"
	"golang.org/x/text/encoding/unicode"
)

var (
	peSkippedImages  = expvar.NewInt("pe.skipped.images")
	peReaderTimeouts = expvar.NewInt("pe.reader.timeouts")
)

// Reader is the interface for PE (Portable Executable) format metadata parsing. The stdlib debug/pe package underpins
// the core functionality of the reader, but additionally, it provides numerous methods for reading resources, strings,
// IAT directories and other information that is not offered by the standard library package.
type Reader interface {
	// Read is the main method that reads the PE metadata for the specified image file.
	Read(filename string) (*PE, error)
	// FindSectionByRVA gets the section containing the given address.
	FindSectionByRVA(rva uint32) (*pe.Section, error)
	// FindOffsetByRVA returns the file offset that maps to the given RVA.
	FindOffsetByRVA(rva uint32) (int64, error)
}

type reader struct {
	f        *os.File
	sections []*pe.Section
	oh       interface{}
	config   Config
}

// NewReader builds a new instance of the PE reader.
func NewReader(config Config) Reader {
	return &reader{config: config}
}

func (r *reader) Read(filename string) (*PE, error) {
	if !r.config.Enabled {
		return nil, nil
	}
	if r.config.shouldSkipImage(filename) {
		peSkippedImages.Add(1)
		return nil, nil
	}
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	r.f = f
	defer r.f.Close()
	pefile, err := pe.NewFile(f)
	if err != nil {
		return nil, err
	}
	r.sections = pefile.Sections
	r.oh = pefile.OptionalHeader

	// link time in PE header is represented as the number of seconds since January 1, 1970
	linkTime := time.Date(1970, 1, 1, 0, 0, 0, 0, time.UTC).Add(time.Second * time.Duration(pefile.TimeDateStamp))

	p := &PE{
		NumberOfSections: pefile.NumberOfSections,
		NumberOfSymbols:  pefile.NumberOfSymbols,
		LinkTime:         linkTime,
		Sections:         r.readSections(pefile),
		Symbols:          make([]string, 0),
		Imports:          make([]string, 0),
		VersionResources: make(map[string]string),
	}

	var resDir pe.DataDirectory
	switch hdr := r.oh.(type) {
	case *pe.OptionalHeader32:
		resDir = hdr.DataDirectory[pe.IMAGE_DIRECTORY_ENTRY_RESOURCE]
		p.ImageBase = uintToHex(uint64(hdr.ImageBase))
		p.EntryPoint = uintToHex(uint64(hdr.AddressOfEntryPoint))
	case *pe.OptionalHeader64:
		resDir = hdr.DataDirectory[pe.IMAGE_DIRECTORY_ENTRY_RESOURCE]
		p.ImageBase = uintToHex(hdr.ImageBase)
		p.EntryPoint = uintToHex(uint64(hdr.AddressOfEntryPoint))
	}

	var wg sync.WaitGroup

	if r.config.ReadResources {
		wg.Add(1)
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			p.VersionResources, err = r.readResources(resDir.VirtualAddress)
			if err != nil {
				log.Warnf("fail to read %q PE resources: %v", filename, err)
			}
		}(&wg)
	}

	if r.config.ReadSymbols {
		wg.Add(1)
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			symbols, err := pefile.ImportedSymbols()
			if err != nil {
				log.Warnf("fail to read %q symbols: %v", filename, err)
				return
			}
			// each symbol is anchored to its source library so we
			// can dig out the imports from the symbol name
			for _, sym := range symbols {
				fields := strings.SplitN(sym, ":", 2)
				if len(fields) != 2 {
					continue
				}
				symbol, lib := fields[0], fields[1]
				p.addImport(lib)
				p.addSymbol(symbol)
			}
		}(&wg)
	}

	// ensure this method terminates in a timely manner
	done := make(chan struct{})

	go func() {
		wg.Wait()
		done <- struct{}{}
	}()

	select {
	case <-done:
		return p, nil
	case <-time.After(time.Second):
		log.Warn("wait timeout reached during PE metadata parsing")
		peReaderTimeouts.Add(1)
		return p, nil
	}
}

// readUTF16String reads an UTF16 string at the specified RVA.
func (r *reader) readUTF16String(rva uint32) (string, error) {
	data := make([]byte, 1024)
	offset, err := r.FindOffsetByRVA(rva)
	if err != nil {
		return "", err
	}
	n, err := r.f.ReadAt(data, offset)
	if err != nil {
		if err == io.EOF {
			return "", nil
		}
		return "", err
	}
	idx := bytes.Index(data[:n], []byte{0, 0})
	if idx < 0 {
		idx = n - 1
	}
	decoder := unicode.UTF16(unicode.LittleEndian, unicode.UseBOM).NewDecoder()
	utf8, err := decoder.Bytes(data[0 : idx+1])
	if err != nil {
		return "", err
	}
	return string(utf8), nil
}

func dwordAlign(offset, base int64) int64 {
	return ((offset + base + 3) & 0xfffffffc) - (base & 0xfffffffc)
}

func uintToHex(v uint64) string { return strconv.FormatUint(v, 16) }

```

`pkg/pe/reader_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestReader(t *testing.T) {
	c := Config{
		Enabled:       true,
		ReadResources: true,
		ReadSymbols:   true,
		ReadSections:  true,
	}
	r := NewReader(c)
	notepad := filepath.Join(os.Getenv("windir"), "notepad.exe")

	pe, err := r.Read(notepad)
	require.NoError(t, err)
	require.NotNil(t, pe)

	require.True(t, pe.NumberOfSections > 0)
	require.True(t, len(pe.Symbols) > 0)
	require.True(t, len(pe.Imports) > 0)
	require.True(t, len(pe.Sections) > 0)

	require.NotEmpty(t, pe.EntryPoint)
	require.NotEmpty(t, pe.ImageBase)
	assert.Contains(t, pe.Symbols, "GetProcAddress")
	assert.Contains(t, pe.Imports, "GDI32.dll")

	assert.Contains(t, pe.VersionResources, "CompanyName")
	assert.Equal(t, "Microsoft Corporation", pe.VersionResources["CompanyName"])
}

```

`pkg/pe/resource/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package resource

import (
	"encoding/binary"
)

// ID is the type for identifying resource types
type ID uint32

const (
	// Version defines version resources
	Version ID = 16
)

// String yields a human-readable resource type name.
func (id ID) String() string {
	switch id {
	case Version:
		return "RT_VERSION"
	default:
		return ""
	}
}

// Directory represents the layout of the resource directory.
type Directory struct {
	Characteristics    uint32
	Timestamp          uint32
	Major              uint16
	Minor              uint16
	NumberNamedEntries uint16
	NumberIDEntries    uint16
}

// Size returns the size in bytes of the resource directory.
func (d Directory) Size() int { return binary.Size(d) }

// DirectoryEntry defines the entry in the directory table.
type DirectoryEntry struct {
	Name         uint32
	OffsetToData uint32
}

// Size returns the size in bytes of the resource entry.
func (e DirectoryEntry) Size() int { return binary.Size(e) }

// ID returns the type of the resource.
func (e DirectoryEntry) ID() ID {
	if !e.IsString() {
		return ID(e.Name)
	}
	return ID(e.Name & 0x0000FFF)
}

// IsString determines if this resource contains string data.
func (e DirectoryEntry) IsString() bool { return ((e.Name & 0x80000000) >> 31) > 0 }

// IsDir indicates if this resource entry is a directory instead of resource final data.
func (e DirectoryEntry) IsDir() bool { return ((e.OffsetToData & 0x80000000) >> 31) > 0 }

// DirOffset returns the offset into the resource directory.
func (e DirectoryEntry) DirOffset() uint32 { return e.OffsetToData & 0x7FFFFFFF }

// DataEntry stores the offset to the resource data.
type DataEntry struct {
	OffsetToData uint32
	DataSize     uint32
	CodePage     uint32
	Reserved     uint32
}

// Size returns the size in bytes of the resource data.
func (e DataEntry) Size() int { return binary.Size(e) }

// VersionInfo contains information about version entries.
type VersionInfo struct {
	Length      uint16
	ValueLength uint16
	Type        uint16
}

// Size returns the size of this structure.
func (v VersionInfo) Size() int { return binary.Size(v) }

// FixedFileinfo stores attributes that describe the FixedFileInformation entries.
type FixedFileinfo struct {
	Signature        uint32
	StructVer        uint32
	FileVersionMS    uint32
	FileVersionLS    uint32
	ProductVersionMS uint32
	ProductVersionLS uint32
	FileFlagMask     uint32
	FileFlags        uint32
	FileOS           uint32
	FileType         uint32
	FileSubtype      uint32
	FileDateMS       uint32
	FileDateLS       uint32
}

// Size returns the size of this structure in bytes.
func (f FixedFileinfo) Size() int { return binary.Size(f) }

// StringFileInfo contains information about string file info entries.
type StringFileInfo struct {
	Length      uint16
	ValueLength uint16
	Type        uint16
}

// Size returns the size of this structure in bytes.
func (s StringFileInfo) Size() int { return binary.Size(s) }

// Skip decides whether to ignore processing the StringFileInfo entries.
func (s StringFileInfo) Skip() bool { return (s.Type != 0 && s.Type != 1) && s.ValueLength != 0 }

// StringTable contains information about string table entries.
type StringTable struct {
	Length      uint16
	ValueLength uint16
	Type        uint16
}

// Size returns the size of this structure in bytes.
func (s StringTable) Size() int { return binary.Size(s) }

// String contains information about string entries.
type String struct {
	Length      uint16
	ValueLength uint16
	Type        uint16
}

// Size returns the size of this structure.
func (s String) Size() int { return binary.Size(s) }

```

`pkg/pe/resources.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"encoding/binary"
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/pe/resource"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"io"
	"strings"
)

const (
	seekStart = 0
	// maxAllowedResourceEntries determines the maximum number of directory entries we are allowed to process
	maxAllowedResourceEntries = 4096
)

var (
	maxResourceEntriesExceeded = expvar.NewInt("pe.max.resource.entries.exceeded")
	failedResourceEntryReads   = expvar.NewInt("pe.failed.resource.entry.reads")

	errMalformedDir         = errors.New("malformed directory")
	errMaxAllowedDirEntries = func(nbEntries int) error {
		return fmt.Errorf("the directory contains %d entries. Max allowed entries %d", nbEntries, maxAllowedResourceEntries)
	}
)

// rdir represents the resource directory with its entries
type rdir struct {
	directory resource.Directory
	entries   []rdirEntry
}

type rdirEntry struct {
	id    resource.ID
	level uint16
	entry resource.DirectoryEntry
	data  resource.DataEntry
	dir   *rdir
}

// readResources a plenty of logic in this code is inspired by pefile tool. The native stdlib package doesn't offer
// any kind of introspection on PE resources, so this function takes care of parsing the resource directory and extracting
// the version resources from it.
func (r *reader) readResources(rva uint32) (map[string]string, error) {
	var vers map[string]string
	dir, err := r.readResourcesDirectory(rva, 0, 0, nil)
	if err != nil {
		return nil, err
	}

	for _, entry := range dir.entries {
		if entry.dir == nil {
			continue
		}
		if entry.level == 0 {
			switch entry.id {
			case resource.Version:
				// read version information resources
				vers, err = r.readVersionInfo(entry.dir)
				if err != nil {
					continue
				}
			}
		}
	}

	return vers, nil
}

func (r *reader) readResourcesDirectory(rva uint32, baseRVA uint32, level uint16, dirs []uint32) (*rdir, error) {
	if dirs == nil {
		dirs = []uint32{rva}
	}
	if baseRVA == 0 {
		baseRVA = rva
	}
	sr := io.NewSectionReader(r.f, 0, 1<<63-1)
	offset, err := r.FindOffsetByRVA(rva)
	if err != nil {
		return nil, fmt.Errorf("couldn't read resources directory: %v", err)
	}
	// try to read the resource directory structure that is basically
	// a header of the table preceding the actual resource entries
	if _, err := sr.Seek(offset, seekStart); err != nil {
		return nil, err
	}
	var dir resource.Directory
	if err := binary.Read(sr, binary.LittleEndian, &dir); err != nil {
		return nil, err
	}

	nbEntries := int(dir.NumberIDEntries + dir.NumberNamedEntries)
	dirents := make([]rdirEntry, nbEntries)

	// we have to protect us against reading a huge number of entries
	if nbEntries > maxAllowedResourceEntries {
		maxResourceEntriesExceeded.Add(1)
		return nil, errMaxAllowedDirEntries(nbEntries)
	}
	// advance the RVA to the position following the directory table
	// header that points the the first entry in the table of entries
	rva += uint32(dir.Size())

loop:
	for i := 0; i < nbEntries; i++ {
		res, err := r.readResourceEntry(sr, rva)
		if err != nil {
			failedResourceEntryReads.Add(1)
			continue
		}
		// the entry is a directory so we have to parse it recursively
		if res.IsDir() {
			// The following comment is from pefile.py
			//
			// OC Patch:
			//
			// One trick malware can do is to recursively reference
			// the next directory. This causes hilarity to ensue when
			// trying to parse everything correctly.
			// If the original RVA given to this function is equal to
			// the next one to parse, we assume that it's a trick.
			for _, dir := range dirs {
				if baseRVA+res.DirOffset() == dir {
					break loop
				}
			}
			dirs = append(dirs, baseRVA+res.DirOffset())
			dir, err := r.readResourcesDirectory(baseRVA+res.DirOffset(), baseRVA, level+1, dirs)
			if err != nil {
				break
			}
			if dir == nil {
				break
			}
			dirents[i] = rdirEntry{
				id:    res.ID(),
				entry: res,
				dir:   dir,
				level: level,
			}
		} else {
			// if we reached the actual directory data, let's read the structure that
			// contains the offset and size of the resource's data
			data, err := r.readResourceData(sr, baseRVA+res.DirOffset())
			if err != nil {
				break
			}
			dirents[i] = rdirEntry{
				id:    res.ID(),
				entry: res,
				data:  data,
				level: level,
			}
		}
		// increment the RVA to the next directory entry
		rva += uint32(res.Size())
	}

	return &rdir{directory: dir, entries: dirents}, nil
}

func (r *reader) readResourceEntry(sr *io.SectionReader, rva uint32) (resource.DirectoryEntry, error) {
	offset, err := r.FindOffsetByRVA(rva)
	if err != nil {
		return resource.DirectoryEntry{}, err
	}
	if _, err := sr.Seek(offset, seekStart); err != nil {
		return resource.DirectoryEntry{}, err
	}
	var entry resource.DirectoryEntry
	if err := binary.Read(sr, binary.LittleEndian, &entry); err != nil {
		return resource.DirectoryEntry{}, fmt.Errorf("invalid directory entry at RVA 0x%x: %v", rva, err)
	}
	return entry, nil
}

func (r *reader) readResourceData(sr *io.SectionReader, rva uint32) (resource.DataEntry, error) {
	offset, err := r.FindOffsetByRVA(rva)
	if err != nil {
		return resource.DataEntry{}, err
	}
	if _, err := sr.Seek(offset, seekStart); err != nil {
		return resource.DataEntry{}, err
	}
	var dataEntry resource.DataEntry
	if err := binary.Read(sr, binary.LittleEndian, &dataEntry); err != nil {
		return resource.DataEntry{}, fmt.Errorf("invalid resource data at RVA 0x%x: %v", rva, err)
	}
	return dataEntry, nil
}

func (r *reader) readVersionInfo(vsDir *rdir) (map[string]string, error) {
	if vsDir == nil || len(vsDir.entries) == 0 {
		return nil, errMalformedDir
	}
	dir := vsDir.entries[0].dir
	if dir == nil {
		return nil, errMalformedDir
	}

	errs := make([]error, 0)
	vers := make(map[string]string)
	vdents := dir.entries
	sr := io.NewSectionReader(r.f, 0, 1<<63-1)

	for _, ve := range vdents {
		offsetToData := ve.data.OffsetToData
		startOffset, err := r.FindOffsetByRVA(offsetToData)
		if err != nil {
			return nil, err
		}
		// read the version info structure and the VS_VERSION_INFO string
		versionInfo, versionString, err := r.parseVersionInfo(sr, startOffset, offsetToData)
		if err != nil {
			errs = append(errs, err)
			continue
		}
		// if we've able to correctly parse the VS_VERSION_INFO string, the next step
		// is to process the fixed version information by getting the offset of the struct
		fixedFileinfoOffset := dwordAlign(int64(versionInfo.Size()+(2*len(versionString))+1), int64(offsetToData))
		fixedFileinfo, err := r.parseFixedFileinfoStruct(sr, fixedFileinfoOffset)
		if err != nil {
			errs = append(errs, err)
			continue
		}
		// now the real work begins. To reach version keys/values, we first have to parse all
		// of the StringFileInfo and VarFileInfo structures until we get to string table whose
		// entries store the data we're after
		stringFileinfoOffset := dwordAlign(fixedFileinfoOffset+int64(fixedFileinfo.Size()), int64(offsetToData))
		for {
			// process StringFileInfo/VarFileInfo structures. The file info string determines whether we
			// should process StringFileInfo or VarFileInfo items
			stringFileinfo, fileInfoString, err := r.parseStringFileinfo(
				sr,
				startOffset+stringFileinfoOffset,
				uint32(int64(offsetToData)+stringFileinfoOffset)+uint32(versionInfo.Size()),
			)
			if err != nil {
				errs = append(errs, err)
				break
			}

			switch {
			case strings.HasPrefix(fileInfoString, "StringFileInfo"):
				if stringFileinfo.Skip() {
					continue
				}
				stringTableOffset := dwordAlign(stringFileinfoOffset+int64(stringFileinfo.Size()+2*(len(fileInfoString)+1)), int64(offsetToData))
				// now we can start processing all the StringTable entries that contain the k/v pairs
				for {
					stringTable, langID, err := r.parseStringTable(
						sr,
						startOffset+stringTableOffset,
						offsetToData+uint32(stringTableOffset),
					)
					if err != nil {
						errs = append(errs, err)
						break
					}
					// now we can process all the entries in the string table and populate the result map
					entryOffset := dwordAlign(stringTableOffset+int64(stringTable.Size()+(2*len(langID)+1)), int64(offsetToData))
					for entryOffset < stringTableOffset+int64(stringTable.Length) {
						if _, err := sr.Seek(startOffset+entryOffset, 0); err != nil {
							break
						}
						var str resource.String
						if err := binary.Read(sr, binary.LittleEndian, &str); err != nil {
							break
						}

						key, err := r.readUTF16String(offsetToData + uint32(entryOffset) + uint32(str.Size()))
						if err != nil {
							break
						}
						valueOffset := dwordAlign(int64(2*(len(key)+1))+entryOffset+int64(str.Size()), int64(offsetToData))
						value, err := r.readUTF16String(offsetToData + uint32(valueOffset))
						if err != nil {
							// couldn't read the value but still index the key
							vers[key] = ""
							break
						}
						vers[key] = value
						if str.Length == 0 {
							entryOffset = stringTableOffset + int64(stringTable.Length)
						} else {
							entryOffset = dwordAlign(int64(str.Length)+entryOffset, int64(offsetToData))
						}
					}

					// these checks breaks on the entries that could lead to infinite loops
					newStringtableOffset := dwordAlign(int64(stringTable.Length)+stringTableOffset, int64(offsetToData))
					if newStringtableOffset == stringTableOffset {
						break
					}

					stringTableOffset = newStringtableOffset
					if stringTableOffset >= int64(stringFileinfo.Length) {
						break
					}
				}
			case strings.HasPrefix(fileInfoString, "VarFileInfo"):
				break
			default:
				errs = append(errs, fmt.Errorf("unknown StringFileInfo string: %s", fileInfoString))
				//nolint:gosimple
				break
			}
			// increment and align the string file info offset. Use the offset to check if we've
			// consumed all the StringFileInfo and VarFileinfo items so we can break the loops
			stringFileinfoOffset = dwordAlign(int64(stringFileinfo.Length)+stringFileinfoOffset, int64(offsetToData))
			if stringFileinfo.Length == 0 || stringFileinfoOffset >= int64(versionInfo.Length) {
				break
			}
		}
	}

	if len(vers) == 0 && len(errs) > 0 {
		return nil, multierror.Wrap(errs...)
	}

	return vers, nil
}

func (r *reader) parseVersionInfo(sr *io.SectionReader, startOffset int64, rva uint32) (resource.VersionInfo, string, error) {
	if _, err := sr.Seek(startOffset, seekStart); err != nil {
		return resource.VersionInfo{}, "", err
	}
	var versionInfo resource.VersionInfo
	if err := binary.Read(sr, binary.LittleEndian, &versionInfo); err != nil {
		return resource.VersionInfo{}, "", err
	}
	versionString, err := r.readUTF16String(rva + uint32(versionInfo.Size()))
	if err != nil || versionString != "VS_VERSION_INFO" {
		return resource.VersionInfo{}, "", fmt.Errorf("invalid VS_VERSION_INFO block: %s", versionString)
	}
	return versionInfo, versionString, nil
}

func (r *reader) parseFixedFileinfoStruct(sr *io.SectionReader, offset int64) (resource.FixedFileinfo, error) {
	if _, err := sr.Seek(offset, seekStart); err != nil {
		return resource.FixedFileinfo{}, err
	}
	var fixedFileinfo resource.FixedFileinfo
	if err := binary.Read(sr, binary.LittleEndian, &fixedFileinfo); err != nil {
		return resource.FixedFileinfo{}, err
	}
	return fixedFileinfo, nil
}

func (r *reader) parseStringFileinfo(sr *io.SectionReader, offset int64, rva uint32) (resource.StringFileInfo, string, error) {
	var stringFileinfo resource.StringFileInfo
	if _, err := sr.Seek(offset, seekStart); err != nil {
		return resource.StringFileInfo{}, "", err
	}
	if err := binary.Read(sr, binary.LittleEndian, &stringFileinfo); err != nil {
		return resource.StringFileInfo{}, "", fmt.Errorf("couldn't parse StringFileInfo/VarFileInfo structure: %v", err)
	}
	str, err := r.readUTF16String(rva)
	if err != nil {
		return resource.StringFileInfo{}, "", fmt.Errorf("couldn't read StringFileInfo unicode string at RVA 0x%x: %v", rva, err)
	}
	return stringFileinfo, str, nil
}

func (r *reader) parseStringTable(sr *io.SectionReader, offset int64, rva uint32) (resource.StringTable, string, error) {
	if _, err := sr.Seek(offset, seekStart); err != nil {
		return resource.StringTable{}, "", err
	}
	var stringTable resource.StringTable
	if err := binary.Read(sr, binary.LittleEndian, &stringTable); err != nil {
		return resource.StringTable{}, "", fmt.Errorf("couldn't parse StringTable structure: %v", err)
	}
	langID, err := r.readUTF16String(rva + uint32(stringTable.Size()))
	if err != nil {
		return resource.StringTable{}, "", fmt.Errorf("couldn't read StringTable unicode string at RVA 0x%x: %v", rva+uint32(stringTable.Size()), err)
	}
	return stringTable, langID, nil
}

```

`pkg/pe/resources_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

```

`pkg/pe/section.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"context"
	"crypto/md5"
	"debug/pe"
	"encoding/hex"
	"fmt"
	"os"
	"sync"
	"time"
)

// Sec contains the section attributes.
type Sec struct {
	Name    string
	Size    uint32
	Entropy float64
	Md5     string
}

// String returns the stirng representation of the section.
func (s Sec) String() string {
	return fmt.Sprintf("Name: %s, Size: %d, Entropy: %f, Md5: %s", s.Name, s.Size, s.Entropy, s.Md5)
}

func (r *reader) FindOffsetByRVA(rva uint32) (int64, error) {
	sec, err := r.FindSectionByRVA(rva)
	if err != nil {
		return 0, err
	}
	offset := int64(rva - r.fixSectionAlignment(sec.VirtualAddress) + r.fixFileAlignment(sec.Offset))
	return offset, nil
}

func (r *reader) FindSectionByRVA(rva uint32) (*pe.Section, error) {
	for _, s := range r.sections {
		if r.containsRVA(s, rva) {
			return s, nil
		}
	}
	return nil, fmt.Errorf("couldn't find section at RVA 0x%x", rva)
}

func (r *reader) readSections(pefile *pe.File) []Sec {
	secs := pefile.Sections
	sections := make([]Sec, 0, len(secs))
	var wg sync.WaitGroup

	if r.config.ReadSections {
		wg.Add(len(secs))
	}
	for i := 0; i < len(secs); i++ {
		s := secs[i]
		if s == nil {
			continue
		}

		sec := Sec{
			Name: s.Name,
			Size: s.Size,
		}

		if r.config.ReadSections {
			ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*250)
			go func(cancel context.CancelFunc) {
				defer cancel()
				data, err := s.Data()
				if err != nil {
					return
				}
				sum := md5.Sum(data)
				sec.Md5 = hex.EncodeToString(sum[:])
				//sec.Entropy = entropy(data)
				sections = append(sections, sec)
			}(cancel)

			<-ctx.Done()
			wg.Done()
		} else {
			sections = append(sections, sec)
		}
	}

	if r.config.ReadSections {
		wg.Wait()
	}

	return sections
}

// containsRVA determines whether the section contains the address provided by checking the boundaries
// of the section address intervals.
func (r *reader) containsRVA(sec *pe.Section, rva uint32) bool {
	va := r.fixSectionAlignment(sec.VirtualAddress)
	if va <= rva && rva < va+sec.Size {
		return true
	}
	return false
}

// fixSecAlignment ensures the alignment of the section is greater or equal to the file alignment.
func (r *reader) fixSectionAlignment(rva uint32) uint32 {
	var fa uint32
	var sa uint32
	switch hdr := r.oh.(type) {
	case *pe.OptionalHeader32:
		fa = hdr.FileAlignment
		sa = hdr.SectionAlignment
	case *pe.OptionalHeader64:
		fa = hdr.FileAlignment
		sa = hdr.SectionAlignment
	}
	if int(sa) < os.Getpagesize() {
		sa = fa
	}
	if sa > 0 && (rva%fa) != 0 {
		return sa * (rva / sa)
	}
	return rva
}

// fixFileAlignment adjusts section file alignment.
func (r *reader) fixFileAlignment(rva uint32) uint32 {
	var fa uint32
	switch hdr := r.oh.(type) {
	case *pe.OptionalHeader32:
		fa = hdr.FileAlignment
	case *pe.OptionalHeader64:
		fa = hdr.FileAlignment
	}
	if fa < 0x200 {
		return rva
	}
	return (rva / 0x200) * 0x200
}

```

`pkg/pe/section_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

```

`pkg/pe/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"fmt"
	"time"
)

const (
	// Company represents the company name string file info entry in the resources table
	Company = "CompanyName"
	// FileDescription represents the file description entry in the resources table
	FileDescription = "FileDescription"
	// FileVersion represents the file version entry in the resources table
	FileVersion = "FileVersion"
	// OriginalFilename the name of the original executable in the resources table
	OriginalFilename = "OriginalFilename"
	// LegalCopyright represents the copyright notice in the resources directory table
	LegalCopyright = "LegalCopyright"
	// ProductName is the product name entry in the resources table
	ProductName = "ProductName"
	// ProductVersion is the product version entry in the resources table
	ProductVersion = "ProductVersion"
)

// PE contains various headers that identifies the format and characteristics of the executable files.
type PE struct {
	// NumberOfSections designates the total number of sections found withing the binary.
	NumberOfSections uint16 `json:"nsections"`
	// NumberOfSymbols represents the total number of symbols.
	NumberOfSymbols uint32 `json:"nsymbols"`
	// ImageBase designates the base address of the process' image.
	ImageBase string `json:"image_base"`
	// Entrypoint is the address of the entry point function.
	EntryPoint string `json:"entry_point"`
	// LinkTime represents the time that the image was created by the linker.
	LinkTime time.Time `json:"link_time"`
	// Sections contains all distinct sections and their metadata.
	Sections []Sec `json:"sections"`
	// Symbols contains the list of imported symbols.
	Symbols []string `json:"symbols"`
	// Imports contains the imported libraries.
	Imports []string `json:"imports"`
	// VersionResources holds the version resources
	VersionResources map[string]string `json:"resources"`
}

// String returns the string representation of the PE metadata.
func (pe PE) String() string {
	return fmt.Sprintf(`
		 Number of sections: %d
		 Number of symbols: %d
		 Image base: %s
		 Entrypoint: %s
		 Link time: %v
		 Sections: %v
		 Symbols: %v
		 Imports: %v
         Version resources: %v
		`,
		pe.NumberOfSections,
		pe.NumberOfSymbols,
		pe.ImageBase,
		pe.EntryPoint,
		pe.LinkTime,
		pe.Sections,
		pe.Symbols,
		pe.Imports,
		pe.VersionResources,
	)
}

// Section returns the section with specified name.
func (pe *PE) Section(s string) *Sec {
	for _, sec := range pe.Sections {
		if sec.Name == s {
			return &sec
		}
	}
	return nil
}

func (pe *PE) addImport(i string) {
	for _, imp := range pe.Imports {
		if imp == i {
			return
		}
	}
	pe.Imports = append(pe.Imports, i)
}

func (pe *PE) addSymbol(s string) {
	pe.Symbols = append(pe.Symbols, s)
}

```

`pkg/ps/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package ps contains process's state snapshotter implementation.
package ps

```

`pkg/ps/peb.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"strings"
	"syscall"
	"unicode/utf16"
	"unsafe"
)

const (
	maxEnvSize = 4096
)

// PEB contains various process's metadata from the Process Environment Block (PEB). PEB is an opaque data structure
// that contains information that apply across a whole process, including global context, startup parameters, data structures
// for the program image loader, the program image base address, and synchronization objects used to provide mutual exclusion
// for process-wide data structures. Although it is not encouraged to access this structure due to its unstable nature, some
// process's information like command line or environments strings are only available through Process Environment Block fields.
type PEB struct {
	peb        *process.PEB
	handle     handle.Handle
	procParams *process.RTLUserProcessParameters
}

// ReadPEB queries the process's basic information class structures and copies the PEB into
// the current process's address space. Returns the reference to the PEB of the process that is being queried.
func ReadPEB(handle handle.Handle) (*PEB, error) {
	buf := make([]byte, unsafe.Sizeof(process.BasicInformation{}))
	_, err := process.QueryInfo(handle, process.BasicInformationClass, buf)
	if err != nil {
		return nil, fmt.Errorf("couldn't query process information: %v", err)
	}
	info := (*process.BasicInformation)(unsafe.Pointer(&buf[0]))
	// read the PEB to get the process parameters. Because the PEB structure resides
	// in the address space of another process we must read the memory block in order
	// to access the structure's fields.
	peb, err := process.ReadMemory(handle, unsafe.Pointer(info.PEB), unsafe.Sizeof(process.PEB{}))
	if err != nil {
		return nil, fmt.Errorf("coulnd't read PEB: %v", err)
	}
	return &PEB{peb: (*process.PEB)(unsafe.Pointer(&peb[0])), handle: handle}, nil
}

// GetImage inspects the process image name by reading the memory buffer in the PEB.
func (p PEB) GetImage() string {
	params, err := p.readProcessParams()
	if err != nil {
		return ""
	}
	image, err := process.ReadMemoryUnicode(p.handle, unsafe.Pointer(params.ImagePathName.Buffer), uintptr(params.ImagePathName.Length))
	if err != nil {
		return ""
	}
	return syscall.UTF16ToString(image)
}

// GetCommandLine inspects the process command line arguments by reading the memory buffer in the PEB.
func (p PEB) GetCommandLine() string {
	params, err := p.readProcessParams()
	if err != nil {
		return ""
	}
	comm, err := process.ReadMemoryUnicode(p.handle, unsafe.Pointer(params.CommandLine.Buffer), uintptr(params.CommandLine.Length))
	if err != nil {
		return ""
	}
	return syscall.UTF16ToString(comm)
}

// GetCurrentWorkingDirectory reads the current working directory from the PEB.
func (p PEB) GetCurrentWorkingDirectory() string {
	params, err := p.readProcessParams()
	if err != nil {
		return ""
	}
	cwd, err := process.ReadMemoryUnicode(p.handle, unsafe.Pointer(params.CurrentDirectory.DosPath.Buffer), uintptr(params.CurrentDirectory.DosPath.Length))
	if err != nil {
		return ""
	}
	return syscall.UTF16ToString(cwd)
}

// GetEnvs returns the map of environment variables that were mapped into the process PEB.
func (p PEB) GetEnvs() map[string]string {
	params, err := p.readProcessParams()
	if err != nil {
		return nil
	}
	// we can read the whole memory region starting from the env address
	// and speculate the size of the env block, but we just use a fixed
	// buffer size
	s, err := process.ReadMemoryUnicode(p.handle, unsafe.Pointer(params.Environment), uintptr(maxEnvSize))
	if err != nil {
		return nil
	}
	envs := make(map[string]string)
	start, end := 0, 0
	for i, r := range s {
		// each env variable key/value pair terminates with the NUL character
		if r == 0 {
			end = i
		}
		if end > start {
			// the next token starts with a NUL character
			// which means we have consumed all env variables
			if s[start] == 0 {
				break
			}
			env := string(utf16.Decode(s[start:end]))
			if kv := strings.Split(env, "="); len(kv) == 2 {
				envs[kv[0]] = kv[1]
			}
			start = end + 1
		}
	}
	return envs
}

// readProcessParams reads the `RtlUserProcessParameters` struct
// which contains the command line and the image name of the process
func (p *PEB) readProcessParams() (*process.RTLUserProcessParameters, error) {
	if p.procParams != nil {
		return p.procParams, nil
	}
	b, err := process.ReadMemory(p.handle, unsafe.Pointer(p.peb.ProcessParameters), unsafe.Sizeof(process.RTLUserProcessParameters{}))
	if err != nil {
		return nil, fmt.Errorf("couldn't read process's parameters from PEB: %v", err)
	}
	p.procParams = (*process.RTLUserProcessParameters)(unsafe.Pointer(&b[0]))
	return p.procParams, nil
}

```

`pkg/ps/peb_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
)

func TestPEBGetCurrentWorkingDirectory(t *testing.T) {
	flags := process.QueryInformation | process.VMRead
	handle, err := process.Open(flags, false, uint32(os.Getpid()))
	if err != nil {
		t.Fatal(err)
	}
	peb, err := ReadPEB(handle)
	require.NoError(t, err)

	cwd := peb.GetCurrentWorkingDirectory()
	require.NotEmpty(t, cwd)
	assert.Equal(t, "ps", filepath.Base(cwd))
}

```

`pkg/ps/snapshotter.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
)

// Snapshotter is the interface that exposes a set of methods all process snapshotters have to satisfy. It stores the state
// of all running processes in the system including its threads, dynamically referenced libraries, handles/file descriptors and other
// metadata.
type Snapshotter interface {
	// Write appends a new process state to the snapshotter. It takes as an input the inbound kernel event to fetch
	// the basic data, but also enriches the process' state with extra metadata such as process' env variables, PE
	// metadata for Windows binaries and so on.
	Write(kevt *kevent.Kevent) error
	// WriteFromKcap appends a new process state to the snapshotter from the captured kernel event.
	WriteFromKcap(kevt *kevent.Kevent) error
	// Remove deletes process's state from the snapshotter.
	Remove(kevt *kevent.Kevent) error
	// Find attempts to retrieve process' state for the specified process identifier.
	Find(pid uint32) *pstypes.PS
	// Size returns the total number of process state items.
	Size() uint32
	// Close closes process snapshotter and disposes all allocated resources.
	Close() error
}

```

`pkg/ps/snapshotter_mock.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/rabbitstack/fibratus/pkg/kevent"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/mock"
)

// SnapshotterMock is the process snapshotter mock used in tests.
type SnapshotterMock struct {
	mock.Mock
}

// Write method
func (s *SnapshotterMock) Write(kevt *kevent.Kevent) error { return nil }

// Remove method
func (s *SnapshotterMock) Remove(kevt *kevent.Kevent) error { return nil }

// Find method
func (s *SnapshotterMock) Find(pid uint32) *pstypes.PS {
	args := s.Called(pid)
	return args.Get(0).(*pstypes.PS)
}

// Size method
func (s *SnapshotterMock) Size() uint32 { args := s.Called(); return uint32(args.Int(0)) }

// Close method
func (s *SnapshotterMock) Close() error { return nil }

// GetSnapshot method
func (s *SnapshotterMock) GetSnapshot() []*pstypes.PS {
	args := s.Called()
	return args.Get(0).([]*pstypes.PS)
}

// WriteFromKcap method
func (s *SnapshotterMock) WriteFromKcap(kevt *kevent.Kevent) error { return nil }

```

`pkg/ps/snapshotter_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"expvar"
	"os"
	"path/filepath"
	"strconv"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	hndl "github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	t "github.com/rabbitstack/fibratus/pkg/syscall/thread"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	log "github.com/sirupsen/logrus"
)

var (
	// reapPeriod specifies the interval for triggering the house keeping of dead processes
	reapPeriod = time.Minute * 2

	processLookupFailureCount = expvar.NewMap("process.lookup.failure.count")
	reapedProcesses           = expvar.NewInt("process.reaped")
	processCount              = expvar.NewInt("process.count")
	threadCount               = expvar.NewInt("process.thread.count")
	moduleCount               = expvar.NewInt("process.module.count")
	pebReadErrors             = expvar.NewInt("process.peb.read.errors")
)

type snapshotter struct {
	mu         sync.RWMutex
	procs      map[uint32]*pstypes.PS
	quit       chan struct{}
	config     *config.Config
	handleSnap handle.Snapshotter
	peReader   pe.Reader
	capture    bool
}

// NewSnapshotter returns a new instance of the process snapshotter.
func NewSnapshotter(handleSnap handle.Snapshotter, config *config.Config) Snapshotter {
	s := &snapshotter{
		procs:      make(map[uint32]*pstypes.PS),
		quit:       make(chan struct{}),
		config:     config,
		handleSnap: handleSnap,
		peReader:   pe.NewReader(config.PE),
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	s.handleSnap.RegisterCreateCallback(s.onHandleCreated)
	s.handleSnap.RegisterDestroyCallback(s.onHandleDestroyed)

	go s.gcDeadProcesses()

	return s
}

// NewSnapshotterFromKcap restores the snapshotter state from the kcap file.
func NewSnapshotterFromKcap(handleSnap handle.Snapshotter, config *config.Config) Snapshotter {
	s := &snapshotter{
		procs:      make(map[uint32]*pstypes.PS),
		quit:       make(chan struct{}),
		config:     config,
		handleSnap: handleSnap,
		peReader:   pe.NewReader(config.PE),
		capture:    true,
	}

	s.handleSnap.RegisterCreateCallback(s.onHandleCreated)
	s.handleSnap.RegisterDestroyCallback(s.onHandleDestroyed)

	return s
}

func (s *snapshotter) WriteFromKcap(kevt *kevent.Kevent) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	switch kevt.Type {
	case ktypes.CreateProcess, ktypes.EnumProcess:
		ps := kevt.PS
		if ps == nil {
			return nil
		}
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		if kevt.Type == ktypes.EnumProcess {
			// invalid process
			if ps.PID == ps.Ppid {
				return nil
			}
			s.procs[pid] = ps
		} else {
			s.procs[pid] = pstypes.FromKevent(unwrapParams(pid, kevt))
		}
		ppid, err := kevt.Kparams.GetPpid()
		if err != nil {
			return err
		}
		ps.Parent = s.procs[ppid]
	case ktypes.CreateThread, ktypes.EnumThread:
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		threadCount.Add(1)
		thread := pstypes.ThreadFromKevent(unwrapThreadParams(pid, kevt))
		if ps, ok := s.procs[pid]; ok {
			ps.AddThread(thread)
			ps.Parent = s.procs[ps.Ppid]
		}
	case ktypes.LoadImage, ktypes.EnumImage:
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		moduleCount.Add(1)
		ps, ok := s.procs[pid]
		if !ok {
			return nil
		}
		ps.AddModule(pstypes.ImageFromKevent(unwrapImageParams(kevt)))
	}
	return nil
}

func (s *snapshotter) Write(kevt *kevent.Kevent) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	switch kevt.Type {
	case ktypes.CreateProcess, ktypes.EnumProcess:
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		// discard writing the snapshot state if the pid is
		// already present. This usually happens when we alter
		// the tracing session to induce the arrival of rundown events
		// by calling into the `etw.SetTraceInformation` Windows API
		// function twice in a row.
		// For more pointers check `kstream/controller_windows.go`
		// and the `etw.SetTraceInformation` API function
		if _, ok := s.procs[pid]; ok {
			return nil
		}
		processCount.Add(1)

		// ETW can sometimes report invalid process id, so we try
		// to obtain the process id from its thread identifier
		if kevt.Type == ktypes.CreateProcess && pid == winerrno.InvalidPID {
			pid = pidFromThreadID(kevt.Tid)
		}

		ps := pstypes.FromKevent(unwrapParams(pid, kevt))

		// enumerate process handles
		ps.Handles, err = s.handleSnap.FindHandles(pid)
		if err != nil {
			log.Warnf("couldn't enumerate handles for pid (%d): %v", pid, err)
		}
		ps.Parent = s.procs[ps.Ppid]

		// inspect PE metadata and attach corresponding headers
		s.readPE(ps)

		// adjust the process that is producing the event. For
		// `CreateProcess` events the process context is scoped
		// to the parent/creator process. Otherwise, it is a regular
		// enumeration event that doesn't require consulting the
		// process in the snapshot state
		if kevt.Type == ktypes.CreateProcess {
			kevt.PS = s.procs[kevt.PID]
		} else {
			kevt.PS = ps
		}
		// try to enum process's env variables and the cwd
		flags := process.QueryInformation | process.VMRead
		h, err := process.Open(flags, false, pid)
		if err != nil {
			s.procs[pid] = ps
			return nil
		}
		defer h.Close()

		peb, err := ReadPEB(h)
		if err != nil {
			pebReadErrors.Add(1)
			s.procs[pid] = ps
			return nil
		}

		ps.Envs = peb.GetEnvs()
		ps.Cwd = peb.GetCurrentWorkingDirectory()

		if kevt.Type != ktypes.CreateProcess {
			kevt.PS = ps
		}

		s.procs[pid] = ps
	case ktypes.CreateThread, ktypes.EnumThread:
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		threadCount.Add(1)
		if pid == winerrno.InvalidPID {
			threadID, _ := kevt.Kparams.GetTid()
			pid = pidFromThreadID(threadID)
		}
		// thread can be associated with the process
		// as it already exists in the map
		thread := pstypes.ThreadFromKevent(unwrapThreadParams(pid, kevt))
		if ps, ok := s.procs[pid]; ok {
			// append additional params
			kevt.Kparams.Append(kparams.Exe, kparams.UnicodeString, ps.Exe)
			ps.AddThread(thread)
			return nil
		}

		// search for missing process and attempt to get its info
		ps := s.findProcess(pid, thread)

		// enumerate process handles
		ps.Handles, err = s.handleSnap.FindHandles(pid)
		if err != nil {
			log.Warnf("couldn't enumerate handles for pid (%d): %v", pid, err)
		}
		ps.Parent = s.procs[ps.Ppid]

		s.procs[pid] = ps
	case ktypes.LoadImage, ktypes.EnumImage:
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		moduleCount.Add(1)
		ps, ok := s.procs[pid]
		if !ok {
			return nil
		}
		ps.AddModule(pstypes.ImageFromKevent(unwrapImageParams(kevt)))
	}
	return nil
}

func (s *snapshotter) Close() error {
	s.quit <- struct{}{}
	return nil
}

// gcDeadProcesses periodically scans the map of the snapshot's processes and removes
// any terminated processes from it. This guarantees that any leftovers are cleaned-up
// in case we miss process' terminate events.
func (s *snapshotter) gcDeadProcesses() {
	tick := time.NewTicker(reapPeriod)
	for {
		select {
		case <-tick.C:
			s.mu.Lock()
			ss := len(s.procs)
			log.Debugf("scanning for dead processes on the snapshot of %d items", ss)

			for pid := range s.procs {
				h, err := process.Open(process.QueryLimitedInformation, false, pid)
				if err != nil {
					continue
				}
				if !process.IsAlive(h) {
					delete(s.procs, pid)
				}
				h.Close()
			}

			if ss > len(s.procs) {
				reaped := ss - len(s.procs)
				reapedProcesses.Add(int64(reaped))
				log.Debugf("%d dead process(es) reaped", reaped)
			}
			s.mu.Unlock()
		case <-s.quit:
			tick.Stop()
		}
	}
}

func pidFromThreadID(tid uint32) uint32 {
	h, err := t.Open(t.QueryLimitedInformation, false, tid)
	if err != nil {
		return winerrno.InvalidPID
	}
	defer h.Close()
	pid, err := process.GetPIDFromThread(h)
	if err != nil {
		return winerrno.InvalidPID
	}
	return pid
}

func ntoskrnl() string { return filepath.Join(os.Getenv("SystemRoot"), "ntoskrnl.exe") }

func fromPEB(pid, ppid uint32, peb *PEB, thread pstypes.Thread) *pstypes.PS {
	return pstypes.NewPS(
		pid,
		ppid,
		peb.GetImage(),
		peb.GetCurrentWorkingDirectory(),
		peb.GetCommandLine(),
		thread,
		peb.GetEnvs(),
	)
}

func (s *snapshotter) findProcess(pid uint32, thread pstypes.Thread) *pstypes.PS {
	// several system protected processes don't allow for getting their handles
	// even if SeDebugPrivilege is present in the process' token, so we'll handle
	// them manually
	switch pid {
	case 0:
		return pstypes.NewPS(pid, pid, "idle", "", "idle", thread, nil)
	case 4:
		return pstypes.NewPS(pid, 0, "System", "", ntoskrnl(), thread, nil)
	}
	flags := process.QueryInformation | process.VMRead
	h, err := process.Open(flags, false, pid)
	if err != nil {
		// the access to protected / system process can't be achieved through
		// `VMRead` or `QueryInformation` flags.
		// Try to acquire the process handle again but with restricted access rights,
		// so we can get the process image file name
		h, err = process.Open(
			process.QueryLimitedInformation,
			false,
			pid,
		)
		if err != nil {
			return pstypes.NewPS(pid, pid, "", "", "", thread, nil)
		}
	}
	defer h.Close()

	// read process's metadata from the PEB
	peb, err := ReadPEB(h)
	if err != nil {
		pebReadErrors.Add(1)
		// couldn't query process basic info or read the PEB,
		// so at least try to obtain the full process's image name
		image, err := process.QueryFullImageName(h)
		if err != nil {
			return pstypes.NewPS(pid, pid, "", "", "", thread, nil)
		}
		return pstypes.NewPS(pid, pid, image, "", image, thread, nil)
	}
	return fromPEB(pid, process.GetParentPID(h), peb, thread)
}

func (s *snapshotter) readPE(ps *pstypes.PS) {
	// skip imageless processes such as Idle, System or Registry
	pid := ps.PID
	if pid == 0 || pid == 4 || pid == 72 || pid == 128 {
		return
	}
	p, err := s.peReader.Read(ps.Exe)
	if err != nil {
		log.Warnf("fail to inspect PE metadata for process %s (%d): %v", ps.Name, ps.PID, err)
		return
	}

	if p == nil {
		return
	}

	ps.PE = p
	s.procs[pid] = ps
}

func (s *snapshotter) onHandleCreated(pid uint32, handle htypes.Handle) {
	s.mu.RLock()
	ps, ok := s.procs[pid]
	s.mu.RUnlock()
	if ok {
		s.mu.Lock()
		defer s.mu.Unlock()
		ps.AddHandle(handle)
		s.procs[pid] = ps
	}
}

func (s *snapshotter) onHandleDestroyed(pid uint32, num hndl.Handle) {
	s.mu.RLock()
	ps, ok := s.procs[pid]
	s.mu.RUnlock()
	if ok {
		s.mu.Lock()
		defer s.mu.Unlock()
		ps.RemoveHandle(num)
		s.procs[pid] = ps
	}
}

func (s *snapshotter) Remove(kevt *kevent.Kevent) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	pid, err := kevt.Kparams.GetPid()
	if err != nil {
		return err
	}
	switch kevt.Type {
	case ktypes.TerminateProcess:
		if _, ok := s.procs[pid]; ok {
			delete(s.procs, pid)
			processCount.Add(-1)
			return nil
		}
	case ktypes.TerminateThread:
		if ps, ok := s.procs[pid]; ok {
			tid, err := kevt.Kparams.GetTid()
			if err != nil {
				return err
			}
			ps.RemoveThread(tid)
			threadCount.Add(-1)
		}
	case ktypes.UnloadImage:
		pid, err := kevt.Kparams.GetPid()
		if err != nil {
			return err
		}
		if ps, ok := s.procs[pid]; ok {
			name, _ := kevt.Kparams.GetString(kparams.ImageFilename)
			ps.RemoveModule(name)
			moduleCount.Add(-1)
		}
	}
	return nil
}

func (s *snapshotter) Find(pid uint32) *pstypes.PS {
	s.mu.RLock()
	ps, ok := s.procs[pid]
	s.mu.RUnlock()
	if ok {
		return ps
	}
	if s.capture {
		return nil
	}
	processLookupFailureCount.Add(strconv.Itoa(int(pid)), 1)

	// allocate missing process's state and fill in metadata/handles
	thread := pstypes.Thread{}
	ps = s.findProcess(pid, thread)

	s.readPE(ps)

	// enumerate process handles
	var err error
	ps.Handles, err = s.handleSnap.FindHandles(pid)
	if err != nil {
		log.Warnf("couldn't enumerate handles for pid (%d): %v", pid, err)
	}

	s.mu.Lock()
	defer s.mu.Unlock()
	s.procs[pid] = ps

	return ps
}

func (s *snapshotter) Size() uint32 {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return uint32(len(s.procs))
}

func unwrapParams(pid uint32, kevt *kevent.Kevent) (uint32, uint32, string, string, string, string, uint8) {
	ppid, _ := kevt.Kparams.GetPpid()
	name, _ := kevt.Kparams.GetString(kparams.ProcessName)
	comm, _ := kevt.Kparams.GetString(kparams.Comm)
	exe, _ := kevt.Kparams.GetString(kparams.Exe)
	sid, _ := kevt.Kparams.GetString(kparams.UserSID)
	sessionID, _ := kevt.Kparams.GetUint32(kparams.SessionID)

	return pid, ppid, name, comm, exe, sid, uint8(sessionID)
}

func unwrapThreadParams(pid uint32, kevt *kevent.Kevent) (uint32, uint32, kparams.Hex, kparams.Hex, kparams.Hex, kparams.Hex, uint8, uint8, uint8, kparams.Hex) {
	tid, _ := kevt.Kparams.GetTid()
	ustackBase, _ := kevt.Kparams.GetHex(kparams.UstackBase)
	ustackLimit, _ := kevt.Kparams.GetHex(kparams.UstackLimit)
	kstackBase, _ := kevt.Kparams.GetHex(kparams.KstackBase)
	kstackLimit, _ := kevt.Kparams.GetHex(kparams.KstackLimit)
	ioPrio, _ := kevt.Kparams.GetUint8(kparams.IOPrio)
	basePrio, _ := kevt.Kparams.GetUint8(kparams.BasePrio)
	pagePrio, _ := kevt.Kparams.GetUint8(kparams.PagePrio)
	entrypoint, _ := kevt.Kparams.GetHex(kparams.ThreadEntrypoint)

	return pid, tid, ustackBase, ustackLimit, kstackBase, kstackLimit, ioPrio, basePrio, pagePrio, entrypoint
}

func unwrapImageParams(kevt *kevent.Kevent) (uint32, uint32, string, kparams.Hex, kparams.Hex) {
	size, _ := kevt.Kparams.GetUint32(kparams.ImageSize)
	checksum, _ := kevt.Kparams.GetUint32(kparams.ImageCheckSum)
	name, _ := kevt.Kparams.GetString(kparams.ImageFilename)
	baseAddress, _ := kevt.Kparams.GetHex(kparams.ImageBase)
	defaultBaseAddress, _ := kevt.Kparams.GetHex(kparams.ImageDefaultBase)

	return size, checksum, name, baseAddress, defaultBaseAddress
}

```

`pkg/ps/snapshotter_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"os"
	"path/filepath"
	"syscall"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSnapshotterWrite(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	pid := uint32(os.Getpid())
	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: pid},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	err := psnap.Write(kevt)
	require.NoError(t, err)

	ps := psnap.Find(pid)
	require.NotNil(t, ps)

	assert.Equal(t, pid, ps.PID)
	assert.Equal(t, uint32(8390), ps.Ppid)
	assert.Equal(t, "spotify.exe", ps.Name)
	assert.Equal(t, `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`, ps.Comm)
	assert.Equal(t, `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`, ps.Exe)
	assert.Equal(t, `admin\SYSTEM`, ps.SID)
	assert.Len(t, ps.Args, 14)
	assert.Equal(t, "--type=crashpad-handler", ps.Args[1])
	assert.Equal(t, "ps", filepath.Base(ps.Cwd))
	assert.True(t, len(ps.Envs) > 0)

	kevt = &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(1232)},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: pid},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	err = psnap.Write(kevt)
	require.NoError(t, err)

	ps = psnap.Find(1232)
	require.NotNil(t, ps)
	require.NotNil(t, ps.Parent)
	assert.Equal(t, `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`, ps.Parent.Exe)
}

func TestSnapshotterWriteKeventProcess(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type: ktypes.EnumProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(1200)},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	err := psnap.Write(kevt)
	require.NoError(t, err)
	require.NotNil(t, psnap.Find(1200))

	assert.Equal(t, uint32(1200), kevt.PS.PID)

	kevt = &kevent.Kevent{
		Type: ktypes.CreateProcess,
		PID:  1200,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(1232)},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: 1200},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify-client.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	err = psnap.Write(kevt)
	require.NoError(t, err)

	assert.Equal(t, uint32(1200), kevt.PS.PID)
	assert.Equal(t, "spotify.exe", kevt.PS.Name)
	require.NotNil(t, psnap.Find(1232))
}

func TestSnapshotterWriteNoPIDInParams(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	require.Error(t, psnap.Write(kevt))
}

func TestSnapshotterWriteThread(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(6599)},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}
	require.NoError(t, psnap.Write(kevt))

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateThread,
		Kparams: kevent.Kparams{
			kparams.ProcessID:        {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(6599)},
			kparams.ThreadID:         {Name: kparams.ThreadID, Type: kparams.TID, Value: uint32(3453)},
			kparams.BasePrio:         {Name: kparams.BasePrio, Type: kparams.Uint8, Value: uint8(13)},
			kparams.ThreadEntrypoint: {Name: kparams.ThreadEntrypoint, Type: kparams.HexInt64, Value: kparams.Hex("0x7ffe2557ff80")},
			kparams.IOPrio:           {Name: kparams.IOPrio, Type: kparams.Uint8, Value: uint8(2)},
			kparams.KstackBase:       {Name: kparams.KstackBase, Type: kparams.HexInt64, Value: kparams.Hex("0xffffc307810d6000")},
			kparams.KstackLimit:      {Name: kparams.KstackLimit, Type: kparams.HexInt64, Value: kparams.Hex("0xffffc307810cf000")},
			kparams.PagePrio:         {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(5)},
			kparams.UstackBase:       {Name: kparams.UstackBase, Type: kparams.HexInt64, Value: kparams.Hex("0x5260000")},
			kparams.UstackLimit:      {Name: kparams.UstackLimit, Type: kparams.HexInt64, Value: kparams.Hex("0x525f000")},
		},
	}

	require.NoError(t, psnap.Write(kevt1))

	ps := psnap.Find(uint32(6599))
	require.NotNil(t, ps)

	require.Len(t, ps.Threads, 1)

	thread := ps.Threads[3453]

	assert.Equal(t, uint32(3453), thread.Tid)
	assert.Equal(t, uint32(6599), thread.Pid)
	assert.Equal(t, uint8(13), thread.BasePrio)
	assert.Equal(t, kparams.Hex("0x7ffe2557ff80"), thread.Entrypoint)
	assert.Equal(t, uint8(2), thread.IOPrio)
	assert.Equal(t, uint8(5), thread.PagePrio)
	assert.Equal(t, kparams.Hex("0xffffc307810d6000"), thread.KstackBase)
	assert.Equal(t, kparams.Hex("0xffffc307810cf000"), thread.KstackLimit)
	assert.Equal(t, kparams.Hex("0x5260000"), thread.UstackBase)
	assert.Equal(t, kparams.Hex("0x525f000"), thread.UstackLimit)
}

func TestSnapshotterWriteThreadPIDInParams(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type: ktypes.CreateThread,
		Kparams: kevent.Kparams{
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ThreadID:        {Name: kparams.ThreadID, Type: kparams.TID, Value: uint32(3453)},
		},
	}

	require.Error(t, psnap.Write(kevt))
}

func TestSnapshotterWritePSThreadMissingProc(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	pid := uint32(os.Getpid())
	kevt := &kevent.Kevent{
		Type:    ktypes.CreateThread,
		Kparams: kevent.Kparams{kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.PID, Value: pid}},
	}

	err := psnap.Write(kevt)
	require.NoError(t, err)

	ps := psnap.Find(pid)
	require.NotNil(t, ps)
	assert.Equal(t, pid, ps.PID)
	assert.Contains(t, ps.Name, "ps")
	assert.True(t, len(ps.Envs) > 0)
}

func TestSnapshotterWritePSThreadMissingProcIdle(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type:    ktypes.CreateThread,
		Kparams: kevent.Kparams{kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(0)}},
	}

	err := psnap.Write(kevt)
	require.NoError(t, err)
}

func TestSnapshotterWritePSThreadMissingProtectedProc(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type:    ktypes.CreateThread,
		Kparams: kevent.Kparams{kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(0)}},
	}

	err := psnap.Write(kevt)
	require.NoError(t, err)
}

func init() {
	reapPeriod = time.Millisecond * 45
}

func TestReapDeadProcesses(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	var si syscall.StartupInfo
	var pi syscall.ProcessInformation

	argv, err := syscall.UTF16PtrFromString(filepath.Join(os.Getenv("windir"), "notepad.exe"))
	require.NoError(t, err)

	err = syscall.CreateProcess(
		nil,
		argv,
		nil,
		nil,
		true,
		0,
		nil,
		nil,
		&si,
		&pi)

	require.NoError(t, err)

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: pi.ProcessId},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "calc.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `c:\\windows\\system32\\calc.exe`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `c:\\windows\\system32\\calc.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	require.NoError(t, psnap.Write(kevt))

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(os.Getpid())},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}
	require.NoError(t, psnap.Write(kevt1))

	require.True(t, psnap.Size() > 1)
	require.NoError(t, syscall.TerminateProcess(pi.Process, uint32(257)))
	time.Sleep(time.Millisecond * 100)

	require.True(t, psnap.Size() == 1)
}

func TestRemove(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	pid := uint32(os.Getpid())
	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: pid},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	err := psnap.Write(kevt)
	require.NoError(t, err)

	require.True(t, psnap.Size() > 0)

	err = psnap.Remove(&kevent.Kevent{
		Type: ktypes.TerminateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.PID, Value: pid},
		},
	})
	require.NoError(t, err)
	require.True(t, psnap.Size() == 0)
}

func TestRemoveNoPidInParams(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}

	err := psnap.Write(kevt)
	require.Error(t, err)
	require.True(t, psnap.Size() == 0)
}

func TestRemoveThread(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Kparams: kevent.Kparams{
			kparams.ProcessID:       {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(6599)},
			kparams.ProcessParentID: {Name: kparams.ProcessParentID, Type: kparams.PID, Value: uint32(8390)},
			kparams.ProcessName:     {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "spotify.exe"},
			kparams.Comm:            {Name: kparams.Comm, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			kparams.Exe:             {Name: kparams.Exe, Type: kparams.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
			kparams.UserSID:         {Name: kparams.UserSID, Type: kparams.UnicodeString, Value: `admin\SYSTEM`},
		},
	}
	require.NoError(t, psnap.Write(kevt))

	kevt1 := &kevent.Kevent{
		Type: ktypes.CreateThread,
		Kparams: kevent.Kparams{
			kparams.ProcessID:        {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(6599)},
			kparams.ThreadID:         {Name: kparams.ThreadID, Type: kparams.TID, Value: uint32(3453)},
			kparams.BasePrio:         {Name: kparams.BasePrio, Type: kparams.Uint8, Value: uint8(13)},
			kparams.ThreadEntrypoint: {Name: kparams.ThreadEntrypoint, Type: kparams.HexInt64, Value: kparams.Hex("0x7ffe2557ff80")},
			kparams.IOPrio:           {Name: kparams.IOPrio, Type: kparams.Uint8, Value: uint8(2)},
			kparams.KstackBase:       {Name: kparams.KstackBase, Type: kparams.HexInt64, Value: kparams.Hex("0xffffc307810d6000")},
			kparams.KstackLimit:      {Name: kparams.KstackLimit, Type: kparams.HexInt64, Value: kparams.Hex("0xffffc307810cf000")},
			kparams.PagePrio:         {Name: kparams.PagePrio, Type: kparams.Uint8, Value: uint8(5)},
			kparams.UstackBase:       {Name: kparams.UstackBase, Type: kparams.HexInt64, Value: kparams.Hex("0x5260000")},
			kparams.UstackLimit:      {Name: kparams.UstackLimit, Type: kparams.HexInt64, Value: kparams.Hex("0x525f000")},
		},
	}

	require.NoError(t, psnap.Write(kevt1))

	ps := psnap.Find(uint32(6599))
	require.NotNil(t, ps)
	require.Len(t, ps.Threads, 1)

	err := psnap.Remove(&kevent.Kevent{
		Type: ktypes.TerminateThread,
		Kparams: kevent.Kparams{
			kparams.ProcessID: {Name: kparams.ProcessID, Type: kparams.PID, Value: uint32(6599)},
			kparams.ThreadID:  {Name: kparams.ThreadID, Type: kparams.TID, Value: uint32(3453)},
		},
	})
	require.NoError(t, err)
	require.Len(t, ps.Threads, 0)
}

```

`pkg/ps/types/marshaller_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kcap/section"
	kcapver "github.com/rabbitstack/fibratus/pkg/kcap/version"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"unsafe"
)

// Marshal produces a byte stream of the process state for writing to the capture file.
func (ps *PS) Marshal() []byte {
	b := make([]byte, 0)

	// write pid and ppid
	b = append(b, bytes.WriteUint32(ps.PID)...)
	b = append(b, bytes.WriteUint32(ps.Ppid)...)

	// write process name
	b = append(b, bytes.WriteUint16(uint16(len(ps.Name)))...)
	b = append(b, ps.Name...)
	// write process command line
	b = append(b, bytes.WriteUint16(uint16(len(ps.Comm)))...)
	b = append(b, ps.Comm...)
	// write full executable path
	b = append(b, bytes.WriteUint16(uint16(len(ps.Exe)))...)
	b = append(b, ps.Exe...)
	// write current working directory
	b = append(b, bytes.WriteUint16(uint16(len(ps.Cwd)))...)
	b = append(b, ps.Cwd...)
	// write SID
	b = append(b, bytes.WriteUint16(uint16(len(ps.SID)))...)
	b = append(b, ps.SID...)

	// write args
	b = append(b, bytes.WriteUint16(uint16(len(ps.Args)))...)
	for _, arg := range ps.Args {
		b = append(b, bytes.WriteUint16(uint16(len(arg)))...)
		b = append(b, arg...)
	}

	// write session ID
	b = append(b, ps.SessionID)

	// write env vars block
	b = append(b, bytes.WriteUint16(uint16(len(ps.Envs)))...)
	for k, v := range ps.Envs {
		b = append(b, bytes.WriteUint16(uint16(len(k)))...)
		b = append(b, k...)
		b = append(b, bytes.WriteUint16(uint16(len(v)))...)
		b = append(b, v...)
	}

	// write handles
	sec := section.New(section.Handle, kcapver.HandleSecV1, uint32(len(ps.Handles)), 0)
	b = append(b, sec[:]...)
	for _, handle := range ps.Handles {
		buf := handle.Marshal()
		b = append(b, bytes.WriteUint16(handle.Offset())...)
		b = append(b, buf...)
	}

	// write the PE metadata
	if ps.PE != nil {
		buf := ps.PE.Marshal()
		sec := section.New(section.PE, kcapver.PESecV1, 0, uint32(len(buf)))
		b = append(b, sec[:]...)
		b = append(b, buf...)
	} else {
		sec := section.New(section.PE, kcapver.PESecV1, 0, 0)
		b = append(b, sec[:]...)
	}

	return b
}

// Unmarshal recovers the process' state from the capture file.
func (ps *PS) Unmarshal(b []byte) error {
	if len(b) < 8 {
		return fmt.Errorf("expected at least 8 bytes but got %d bytes", len(b))
	}
	var offset uint32

	// read pid/ppid
	ps.PID = bytes.ReadUint32(b[0:])
	ps.Ppid = bytes.ReadUint32(b[4:])

	// read process image name
	l := bytes.ReadUint16(b[8:])
	buf := b[10:]
	offset = uint32(l)
	ps.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read process cmdline
	l = bytes.ReadUint16(b[10+offset:])
	buf = b[12+offset:]
	offset += uint32(l)
	ps.Comm = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read full image path
	l = bytes.ReadUint16(b[12+offset:])
	buf = b[14+offset:]
	offset += uint32(l)
	ps.Exe = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read current working directory
	l = bytes.ReadUint16(b[14+offset:])
	buf = b[16+offset:]
	offset += uint32(l)
	ps.Cwd = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read the SID
	l = bytes.ReadUint16(b[16+offset:])
	buf = b[18+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		ps.SID = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}

	// read args
	nargs := bytes.ReadUint16(b[18+offset:])
	var aoffset uint16
	for i := 0; i < int(nargs); i++ {
		l := bytes.ReadUint16(b[20+offset+uint32(aoffset):])
		buf = b[22+offset+uint32(aoffset):]
		ps.Args = append(ps.Args, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		aoffset += 2 + l
	}

	offset += uint32(aoffset)
	// read session ID
	ps.SessionID = b[20+offset]

	// read env vars
	nvars := bytes.ReadUint16(b[21+offset:])
	var eoffset uint16
	for i := 0; i < int(nvars); i++ {
		klen := bytes.ReadUint16(b[23+offset+uint32(eoffset):])
		buf = b[25+offset+uint32(eoffset):]
		key := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:klen:klen])
		vlen := bytes.ReadUint16(b[25+offset+uint32(eoffset)+uint32(klen):])
		buf = b[27+offset+uint32(eoffset)+uint32(klen):]
		value := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:vlen:vlen])
		ps.Envs[key] = value
		eoffset += klen + vlen + 2 + 2
	}

	offset += uint32(eoffset)

	// read handles
	sec := section.Read(b[23+offset:])
	offset += 10 // 10 is for the section size in bytes
	var hoffset uint32
	if sec.Len() == 0 {
		goto readpe
	}

	for i := 0; i < int(sec.Len()); i++ {
		// read handle length
		l := uint32(bytes.ReadUint16(b[23+offset+hoffset:]))

		off := 25 + hoffset + offset

		handle, err := htypes.NewFromKcap(b[off : off+l])
		if err != nil {
			return err
		}
		ps.Handles = append(ps.Handles, handle)
		hoffset += l + 2
	}

readpe:
	offset += hoffset
	// read PE metadata
	sec = section.Read(b[23+offset:])
	if sec.Size() == 0 {
		return nil
	}
	var err error
	ps.PE, err = pe.NewFromKcap(b[33+offset:])
	if err != nil {
		return err
	}

	return nil
}

// Marshal transforms the thread state to byte stream for persisting to capture files.
func (t *Thread) Marshal() []byte {
	b := make([]byte, 0)

	// write thread/process ID
	b = append(b, bytes.WriteUint32(t.Tid)...)
	b = append(b, bytes.WriteUint32(t.Pid)...)

	// write priority fields
	b = append(b, t.IOPrio)
	b = append(b, t.BasePrio)
	b = append(b, t.PagePrio)

	// write stack/kernel/entrypoint addresses
	b = append(b, bytes.WriteUint16(uint16(len(t.UstackBase)))...)
	b = append(b, t.UstackBase...)
	b = append(b, bytes.WriteUint16(uint16(len(t.UstackLimit)))...)
	b = append(b, t.UstackLimit...)
	b = append(b, bytes.WriteUint16(uint16(len(t.KstackBase)))...)
	b = append(b, t.KstackBase...)
	b = append(b, bytes.WriteUint16(uint16(len(t.KstackLimit)))...)
	b = append(b, t.KstackLimit...)
	b = append(b, bytes.WriteUint16(uint16(len(t.Entrypoint)))...)
	b = append(b, t.Entrypoint...)

	return b
}

// Marshal produces a module byte stream state suitable for writing to capture files.
func (m *Module) Marshal() []byte {
	b := make([]byte, 0)

	// write size and checksum
	b = append(b, bytes.WriteUint32(m.Size)...)
	b = append(b, bytes.WriteUint32(m.Checksum)...)

	// write image name
	b = append(b, bytes.WriteUint16(uint16(len(m.Name)))...)
	b = append(b, m.Name...)

	// write addresses
	b = append(b, bytes.WriteUint16(uint16(len(m.BaseAddress)))...)
	b = append(b, m.BaseAddress...)
	b = append(b, bytes.WriteUint16(uint16(len(m.DefaultBaseAddress)))...)
	b = append(b, m.DefaultBaseAddress...)

	return b
}

// Unmarshal restores thead state from the byte slice.
func (t *Thread) Unmarshal(b []byte) (uint16, error) {
	if len(b) < 11 {
		return 0, fmt.Errorf("expected at least 11 bytes but got %d", len(b))
	}

	// read tid and pid
	t.Tid = bytes.ReadUint32(b[0:])
	t.Pid = bytes.ReadUint32(b[4:])

	// read priorities
	t.IOPrio = b[8]
	t.BasePrio = b[9]
	t.PagePrio = b[10]

	// read user space stack base address
	l := bytes.ReadUint16(b[11:])
	buf := b[13:]
	offset := l
	t.UstackBase = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	// read user space stack limit
	l = bytes.ReadUint16(b[13+offset:])
	buf = b[15+offset:]
	offset += l
	t.UstackLimit = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	// read kernel space stack base address
	l = bytes.ReadUint16(b[15+offset:])
	buf = b[17+offset:]
	offset += l
	t.KstackBase = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	// read kernel space stack limit
	l = bytes.ReadUint16(b[17+offset:])
	buf = b[19+offset:]
	offset += l
	t.KstackLimit = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	// read entry point address
	l = bytes.ReadUint16(b[19+offset:])
	buf = b[21+offset:]
	offset += l
	t.Entrypoint = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	return offset + 21, nil
}

// Unmarshal  reconstructs module state from the byte stream.
func (m *Module) Unmarshal(b []byte) (uint16, error) {
	if len(b) < 11 {
		return 0, fmt.Errorf("expected at least 11 bytes but got %d", len(b))
	}

	// read size
	m.Size = bytes.ReadUint32(b[0:])
	// read checksum
	m.Checksum = bytes.ReadUint32(b[4:])

	// read module full path
	length := bytes.ReadUint16(b[8:])
	buf := b[10:]
	offset := length
	m.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:length:length])

	// read addresses
	length = bytes.ReadUint16(b[10+offset:])
	buf = b[12+offset:]
	offset += length
	m.BaseAddress = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:length:length]))

	length = bytes.ReadUint16(b[12+offset:])
	buf = b[14+offset:]
	offset += length
	m.DefaultBaseAddress = kparams.Hex(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:length:length]))

	return offset + 14, nil
}

```

`pkg/ps/types/marshaller_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestPSMarshaler(t *testing.T) {
	ps := &PS{
		PID:       2436,
		Ppid:      6304,
		Name:      "firefox.exe",
		Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
		Comm:      `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
		Cwd:       `C:\Program Files\Mozilla Firefox\`,
		SID:       "archrabbit\\SYSTEM",
		Args:      []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
		SessionID: 4,
		Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
		Handles: []htypes.Handle{
			{Num: handle.Handle(0xffffd105e9baaf70),
				Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
				Type:   "Key",
				Object: 777488883434455544,
				Pid:    uint32(1023),
			},
			{
				Num:  handle.Handle(0xffffd105e9adaf70),
				Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
				Type: "ALPC Port",
				Pid:  uint32(1023),
				MD: &htypes.AlpcPortInfo{
					Seqno:   1,
					Context: 0x0,
					Flags:   0x0,
				},
				Object: 457488883434455544,
			},
			{
				Num:  handle.Handle(0xeaffd105e9adaf30),
				Name: `C:\Users\bunny`,
				Type: "File",
				Pid:  uint32(1023),
				MD: &htypes.FileInfo{
					IsDirectory: true,
				},
				Object: 357488883434455544,
			},
		},
	}

	b := ps.Marshal()
	clone, err := NewFromKcap(b)
	require.NoError(t, err)

	assert.Equal(t, uint32(2436), clone.PID)
	assert.Equal(t, uint32(6304), clone.Ppid)
	assert.Equal(t, "firefox.exe", clone.Name)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\firefox.exe`, clone.Exe)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`, clone.Comm)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\`, clone.Cwd)
	assert.Equal(t, "archrabbit\\SYSTEM", clone.SID)
	assert.Equal(t, []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"}, clone.Args)
	assert.Equal(t, uint8(4), clone.SessionID)
	assert.Equal(t, map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"}, clone.Envs)

	require.Len(t, clone.Handles, 3)

	alpc := clone.Handles[1]
	assert.Equal(t, "ALPC Port", alpc.Type)
	assert.Equal(t, `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`, alpc.Name)
	assert.IsType(t, &htypes.AlpcPortInfo{}, alpc.MD)

	md := alpc.MD.(*htypes.AlpcPortInfo)
	assert.Equal(t, uint32(1), md.Seqno)
}

```

`pkg/ps/types/types.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

// Visitor is the type definition for the function that is
// invoked on each ancestor visit walk.
type Visitor func(*PS)

// Walk recursively visits all ancestors of the given process
// and invokes the visitor function on each parent process.
func Walk(v Visitor, ps *PS) {
	if ps == nil {
		return
	}
	if ps.Parent == nil {
		return
	}
	v(ps.Parent)
	if ps.Parent != nil {
		Walk(v, ps.Parent)
	}
}

```

`pkg/ps/types/types_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	"path/filepath"
	"strings"
	"sync"

	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/pe"
	hndl "github.com/rabbitstack/fibratus/pkg/syscall/handle"
)

// PS encapsulates process' state such as allocated resources and other metadata.
type PS struct {
	mu sync.RWMutex
	// PID is the identifier of this process. This value is valid from the time a process is created until it is terminated.
	PID uint32 `json:"pid"`
	// Ppipd represents the parent of this process. Process identifier numbers are reused, so they only identify a process
	// for the lifetime of that process. It is possible that the process identified by `Ppid` is terminated,
	// so `Ppid` may not refer to a running process. It is also possible that `Ppid` incorrectly refers
	// to a process that reuses a process identifier.
	Ppid uint32 `json:"ppid"`
	// Name is the process' image name including file extension (e.g. cmd.exe)
	Name string `json:"name"`
	// Comm is the full process' command line (e.g. C:\Windows\system32\cmd.exe /cdir /-C /W)
	Comm string `json:"comm"`
	// Exe is the full name of the process' executable (e.g. C:\Windows\system32\cmd.exe)
	Exe string `json:"exe"`
	// Cwd designates the current working directory of the process.
	Cwd string `json:"cwd"`
	// SID is the security identifier under which this process is run.
	SID string `json:"sid"`
	// Args contains process' command line arguments (e.g. /cdir, /-C, /W)
	Args []string `json:"args"`
	// SessionID is the unique identifier for the current session.
	SessionID uint8 `json:"session"`
	// Envs contains process' environment variables indexed by env variable name.
	Envs map[string]string `json:"envs"`
	// Threads contains all the threads running in the address space of this process.
	Threads map[uint32]Thread `json:"-"`
	// Modules contains all the modules loaded by the process.
	Modules []Module `json:"modules"`
	// Handles represents the collection of handles allocated by the process.
	Handles htypes.Handles `json:"handles"`
	// PE stores the PE (Portable Executable) metadata.
	PE *pe.PE `json:"pe"`
	// Parent represents the reference to the parent process.
	Parent *PS `json:"parent"`
}

// String returns a string representation of the process' state.
func (ps *PS) String() string {
	return fmt.Sprintf(`
		Pid:  %d
		Ppid: %d
		Name: %s
		Comm: %s
		Exe:  %s
		Cwd:  %s
		SID:  %s
		Args: %s
		Session ID: %d
		Envs: %s
		`,
		ps.PID,
		ps.Ppid,
		ps.Name,
		ps.Comm,
		ps.Exe,
		ps.Cwd,
		ps.SID,
		ps.Args,
		ps.SessionID,
		ps.Envs,
	)
}

// Thread stores several metadata about a thread that's executing in process's address space.
type Thread struct {
	// Tid is the unique identifier of thread inside the process.
	Tid uint32
	// Pid is the identifier of the process to which this thread pertains.
	Pid uint32
	// IOPrio represents an I/O priority hint for scheduling I/O operations generated by the thread.
	IOPrio uint8
	// BasePrio is the scheduler priority of the thread.
	BasePrio uint8
	// PagePrio is a memory page priority hint for memory pages accessed by the thread.
	PagePrio uint8
	// UstackBase is the base address of the thread's user space stack.
	UstackBase kparams.Hex
	// UstackLimit is the limit of the thread's user space stack.
	UstackLimit kparams.Hex
	// KStackBase is the base address of the thread's kernel space stack.
	KstackBase kparams.Hex
	// KstackLimit is the limit of the thread's kernel space stack.
	KstackLimit kparams.Hex
	// Entrypoint is the starting address of the function to be executed by the thread.
	Entrypoint kparams.Hex
}

// String returns the thread as a human-readable string.
func (t Thread) String() string {
	return fmt.Sprintf("ID: %d IO prio: %d, Base prio: %d, Page prio: %d, Ustack base: %s, Ustack limit: %s, Kstack base: %s, Kstack limit: %s, Entrypoint: %s", t.Tid, t.IOPrio, t.BasePrio, t.PagePrio, t.UstackBase, t.UstackLimit, t.KstackBase, t.UstackLimit, t.Entrypoint)
}

// Module represents the data for all dynamic libraries/executables that reside in the process' address space.
type Module struct {
	// Size designates the size in bytes of the image file.
	Size uint32
	// Checksum is the checksum of the image file.
	Checksum uint32
	// Name represents the full path of this image.
	Name string
	// BaseAddress is the base address of process in which the image is loaded.
	BaseAddress kparams.Hex
	// DefaultBaseAddress is the default base address.
	DefaultBaseAddress kparams.Hex
}

// String returns the string representation of the module.
func (m Module) String() string {
	return fmt.Sprintf("Name: %s, Size: %d, Checksum: %d, Base address: %s, Default base address: %s", m.Name, m.Size, m.Checksum, m.BaseAddress, m.DefaultBaseAddress)
}

// FromKevent produces a new process state from kernel event.
func FromKevent(pid, ppid uint32, name, comm, exe, sid string, sessionID uint8) *PS {
	return &PS{
		PID:       pid,
		Ppid:      ppid,
		Name:      name,
		Comm:      comm,
		Exe:       exe,
		Args:      splitArgs(comm),
		SID:       sid,
		SessionID: sessionID,
		Threads:   make(map[uint32]Thread),
		Modules:   make([]Module, 0),
		Handles:   make([]htypes.Handle, 0),
	}
}

// ThreadFromKevent builds a thread info from kernel event.
func ThreadFromKevent(pid, tid uint32, ustackBase, ustackLimit, kstackBase, kstackLimit kparams.Hex, ioPrio, basePrio, pagePrio uint8, entrypoint kparams.Hex) Thread {
	return Thread{
		Pid:         pid,
		Tid:         tid,
		UstackBase:  ustackBase,
		UstackLimit: ustackLimit,
		KstackBase:  kstackBase,
		KstackLimit: kstackLimit,
		IOPrio:      ioPrio,
		BasePrio:    basePrio,
		PagePrio:    pagePrio,
		Entrypoint:  entrypoint,
	}
}

// ImageFromKevent constructs a module info from the corresponding kernel event.
func ImageFromKevent(size, checksum uint32, name string, baseAddress, defaultBaseAddress kparams.Hex) Module {
	return Module{
		Size:               size,
		Checksum:           checksum,
		Name:               name,
		BaseAddress:        baseAddress,
		DefaultBaseAddress: defaultBaseAddress,
	}
}

// NewPS produces a new process state from passed arguments.
func NewPS(pid, ppid uint32, exe, cwd, comm string, thread Thread, envs map[string]string) *PS {
	return &PS{
		PID:     pid,
		Ppid:    ppid,
		Name:    filepath.Base(exe),
		Exe:     exe,
		Comm:    comm,
		Cwd:     cwd,
		Args:    splitArgs(comm),
		Threads: map[uint32]Thread{thread.Tid: thread},
		Modules: make([]Module, 0),
		Handles: make([]htypes.Handle, 0),
		Envs:    envs,
	}
}

// NewFromKcap reconstructs the state of the process from kcap file.
func NewFromKcap(buf []byte) (*PS, error) {
	ps := PS{
		Args:    make([]string, 0),
		Envs:    make(map[string]string),
		Handles: make([]htypes.Handle, 0),
		Modules: make([]Module, 0),
		Threads: make(map[uint32]Thread),
	}
	if err := ps.Unmarshal(buf); err != nil {
		return nil, err
	}
	return &ps, nil
}

func splitArgs(cmdline string) []string { return strings.Fields(cmdline) }

// AddThread adds a thread to process's state descriptor.
func (ps *PS) AddThread(thread Thread) {
	ps.mu.Lock()
	defer ps.mu.Unlock()
	ps.Threads[thread.Tid] = thread
}

// RemoveThread eliminates a thread from the process's state.
func (ps *PS) RemoveThread(tid uint32) {
	ps.mu.Lock()
	defer ps.mu.Unlock()
	delete(ps.Threads, tid)
}

// RLock acquires a read mutex on the process state.
func (ps *PS) RLock() {
	ps.mu.RLock()
}

// RUnlock releases a read mutex on the process sate.
func (ps *PS) RUnlock() {
	ps.mu.RUnlock()
}

// AddHandle adds a new handle to this process state.
func (ps *PS) AddHandle(handle htypes.Handle) {
	ps.Handles = append(ps.Handles, handle)
}

// RemoveHandle removes a handle with specified identifier from the list of allocated handles.
func (ps *PS) RemoveHandle(num hndl.Handle) {
	for i, h := range ps.Handles {
		if h.Num == num {
			ps.Handles = append(ps.Handles[:i], ps.Handles[i+1:]...)
			break
		}
	}
}

// AddModule adds a new module to this process state.
func (ps *PS) AddModule(mod Module) {
	m := ps.FindModule(mod.Name)
	if m != nil {
		return
	}
	ps.Modules = append(ps.Modules, mod)
}

// RemoveModule removes a module with specified full-path from this process state.
func (ps *PS) RemoveModule(name string) {
	for i, mod := range ps.Modules {
		if mod.Name == name {
			ps.Modules = append(ps.Modules[:i], ps.Modules[i+1:]...)
			break
		}
	}
}

// FindModule finds the module by name.
func (ps *PS) FindModule(name string) *Module {
	for _, mod := range ps.Modules {
		if filepath.Base(mod.Name) == name {
			return &mod
		}
	}
	return nil
}

```

`pkg/ps/types/types_windows_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"github.com/magiconair/properties/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestVisit(t *testing.T) {
	ps1 := &PS{
		Name: "cmd.exe",
	}
	ps2 := &PS{
		Name:   "powershell.exe",
		Parent: ps1,
	}
	ps3 := &PS{
		Name:   "winword.exe",
		Parent: ps2,
	}

	expected := []string{"powershell.exe", "cmd.exe"}
	parents := make([]string, 0)

	Walk(func(ps *PS) { parents = append(parents, ps.Name) }, ps3)

	assert.Equal(t, expected, parents)

	ps4 := &PS{
		Name:   "iexplorer.exe",
		Parent: ps3,
	}
	ps5 := &PS{
		Name:   "dropper.exe",
		Parent: ps4,
	}

	expected1 := []string{"iexplorer.exe", "winword.exe", "powershell.exe", "cmd.exe"}
	parents1 := make([]string, 0)

	Walk(func(ps *PS) { parents1 = append(parents1, ps.Name) }, ps5)

	assert.Equal(t, expected1, parents1)
}

func TestPSArgs(t *testing.T) {
	ps := NewPS(
		233,
		4532,
		"spotify.exe",
		"",
		"C:\\Users\\admin\\AppData\\Roaming\\Spotify\\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler \"--metrics-dir=C:\\Users\\admin\\AppData\\Local\\Spotify\\User Data\" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify",
		Thread{}, nil)
	require.Len(t, ps.Args, 12)
	require.Equal(t, "/prefetch:7", ps.Args[2])
}

```

`pkg/syscall/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package syscall contains the definitions of functions, structures and constants for interacting with the Windows API.
package syscall

```

`pkg/syscall/etw/etw.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"os"
	"syscall"
	"unsafe"

	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/utf16"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
)

var (
	advapi32 = syscall.NewLazyDLL("advapi32.dll")

	startTrace          = advapi32.NewProc("StartTraceW")
	controlTrace        = advapi32.NewProc("ControlTraceW")
	closeTrace          = advapi32.NewProc("CloseTrace")
	openTrace           = advapi32.NewProc("OpenTraceW")
	processTrace        = advapi32.NewProc("ProcessTrace")
	traceSetInformation = advapi32.NewProc("TraceSetInformation")
	enableTrace         = advapi32.NewProc("EnableTraceEx")
)

// TraceOperation is the type alias for the trace operation.
type TraceOperation uint32

const (
	// Query represents the query trace operation.
	Query TraceOperation = 0
	// Stop represents the stop trace operation.
	Stop TraceOperation = 1
	// Update represents the update trace operation.
	Update TraceOperation = 2
	// Flush represents the flush trace operation.
	Flush TraceOperation = 3
)

// TraceHandle is an alias for trace handle type
type TraceHandle uintptr

// IsValid determines if the session handle is valid
func (handle TraceHandle) IsValid() bool { return handle != 0 }

// StartTrace registers and starts an event tracing session for the specified provider. The trace assumes there will be a real-time
// event consumer responsible for collecting and processing events. If the function succeeds, it returns the handle to the tracing
// session.
func StartTrace(name string, props *EventTraceProperties) (TraceHandle, error) {
	var handle TraceHandle
	errno, _, err := startTrace.Call(
		uintptr(unsafe.Pointer(&handle)),
		uintptr(unsafe.Pointer(utf16.StringToUTF16Ptr(name))),
		uintptr(unsafe.Pointer(props)),
	)
	switch winerrno.Errno(errno) {
	case winerrno.Success:
		return handle, nil
	case winerrno.AccessDenied:
		return TraceHandle(0), kerrors.ErrTraceAccessDenied
	case winerrno.DiskFull:
		return TraceHandle(0), kerrors.ErrTraceDiskFull
	case winerrno.AlreadyExists:
		return TraceHandle(0), kerrors.ErrTraceAlreadyRunning
	case winerrno.InvalidParameter:
		return TraceHandle(0), kerrors.ErrTraceInvalidParameter
	case winerrno.BadLength:
		return TraceHandle(0), kerrors.ErrTraceBadLength
	case winerrno.NoSysResources:
		return TraceHandle(0), kerrors.ErrTraceNoSysResources
	default:
		return TraceHandle(0), os.NewSyscallError("StartTrace", err)
	}
}

// ControlTrace performs various operation on the specified event tracing session, such as updating, flushing or stopping
// the session.
func ControlTrace(handle TraceHandle, name string, props *EventTraceProperties, operation TraceOperation) error {
	errno, _, err := controlTrace.Call(
		uintptr(handle),
		uintptr(unsafe.Pointer(utf16.StringToUTF16Ptr(name))),
		uintptr(unsafe.Pointer(props)),
		uintptr(operation),
	)
	switch winerrno.Errno(errno) {
	case winerrno.Success:
		return nil
	case winerrno.WMIInstanceNotFound:
		return kerrors.ErrKsessionNotRunning
	default:
		return os.NewSyscallError("ControlTrace", err)
	}
}

// CloseTrace closes a trace. If you call this function before ProcessTrace returns, the CloseTrace function
// returns ErrorCtxClosePending. The ErrorCtxClosePending code indicates that the CloseTrace function call
// was successful; the ProcessTrace function will stop processing events after it processes all events in its buffers.
func CloseTrace(handle TraceHandle) error {
	errno, _, err := closeTrace.Call(uintptr(handle))
	if winerrno.Errno(errno) != winerrno.Success && winerrno.Errno(errno) != winerrno.CtxClosePending {
		return os.NewSyscallError("CloseTrace", err)
	}
	return nil
}

// OpenTrace opens a real-time trace session or log file for consuming.
func OpenTrace(ktrace EventTraceLogfile) TraceHandle {
	handle, _, _ := openTrace.Call(uintptr(unsafe.Pointer(&ktrace)))
	return TraceHandle(handle)
}

// ProcessTrace function delivers events from one or more event tracing sessions to the consumer. Function sorts the events
// chronologically and delivers all events generated between StartTime and EndTime. The ProcessTrace function blocks the
// thread until it delivers all events, the BufferCallback function returns false, or you call CloseTrace.
func ProcessTrace(handle TraceHandle) error {
	errno, _, err := processTrace.Call(uintptr(unsafe.Pointer(&handle)), 1, 0, 0)
	switch winerrno.Errno(errno) {
	case winerrno.Success:
		return nil
	case winerrno.WMIInstanceNotFound:
		return kerrors.ErrKsessionNotRunning
	case winerrno.NoAccess:
		return kerrors.ErrEventCallbackException
	case winerrno.Cancelled:
		return kerrors.ErrTraceCancelled
	default:
		return os.NewSyscallError("ProcessTrace", err)
	}
}

// SetTraceInformation enables or disables event tracing session settings for the specified information class.
func SetTraceInformation(handle TraceHandle, infoClass uint8, traceFlags []EventTraceFlags) error {
	errno, _, err := traceSetInformation.Call(uintptr(handle), uintptr(infoClass), uintptr(unsafe.Pointer(&traceFlags[0])), unsafe.Sizeof(traceFlags))
	if winerrno.Errno(errno) == winerrno.Success {
		return nil
	}
	return os.NewSyscallError("TraceSetInformation", err)
}

// EnableTrace influences the behaviour of the specified event trace provider.
func EnableTrace(guid syscall.GUID, handle TraceHandle, keyword uint32) error {
	errno, _, err := enableTrace.Call(uintptr(unsafe.Pointer(&guid)), 0, uintptr(handle), 1, 0, uintptr(keyword), 0, 0, 0)
	if winerrno.Errno(errno) == winerrno.Success {
		return nil
	}
	return os.NewSyscallError("EnableTraceEx", err)
}

```

`pkg/syscall/etw/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"strings"
	"syscall"
)

// EventTraceFlags is the type alias for kernel trace events
type EventTraceFlags uint32

// KernelTraceControlGUID is the GUID for the kernel system logger
var KernelTraceControlGUID = syscall.GUID{Data1: 0x9e814aad, Data2: 0x3204, Data3: 0x11d2, Data4: [8]byte{0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}}

// KernelRundownGUID is the GUID for the kernel rundown logger
var KernelRundownGUID = syscall.GUID{Data1: 0x3b9c9951, Data2: 0x3480, Data3: 0x4220, Data4: [8]byte{0x93, 0x77, 0x9c, 0x8e, 0x51, 0x84, 0xf5, 0xcd}}

// KernelAuditAPICallsGUID represents the GUID for the kernel audit API provider
var KernelAuditAPICallsGUID = syscall.GUID{Data1: 0xe02a841c, Data2: 0x75a3, Data3: 0x4fa7, Data4: [8]byte{0xaf, 0xc8, 0xae, 0x09, 0xcf, 0x9b, 0x7f, 0x23}}

const (
	// TraceSystemTraceEnableFlagsInfo controls system logger event flags
	TraceSystemTraceEnableFlagsInfo = uint8(4)
)

const (
	// KernelLoggerSession represents the default session name for NT kernel logger
	KernelLoggerSession = "NT Kernel Logger"
	// KernelLoggerRundownSession is the session name for the kernel rundown logger
	KernelLoggerRundownSession = "Kernel Rundown Logger"
	// KernelAuditAPICallsSession represents the session name for the kernel audit API logger
	KernelAuditAPICallsSession = "Kernel Audit API Calls Logger"
	// WnodeTraceFlagGUID indicates that the structure contains event tracing information
	WnodeTraceFlagGUID = 0x00020000
	// ProcessTraceModeRealtime denotes that there will be a real-time consumers for events forwarded from the providers
	ProcessTraceModeRealtime = 0x00000100
	// ProcessTraceModeEventRecord is the mode that enables the "event record" format for kernel events
	ProcessTraceModeEventRecord = 0x10000000
)

const (
	// ALPC flag activates ALPC events
	ALPC EventTraceFlags = 0x00100000
	// Cswitch flag enables context switch events
	Cswitch EventTraceFlags = 0x00000010
	// DbgPrint flag enables stack walk information
	DbgPrint EventTraceFlags = 0x00040000
	// DiskFileIO flag enables file system events
	DiskFileIO EventTraceFlags = 0x00000200
	// DiskIO flag enables disk I/O events
	DiskIO EventTraceFlags = 0x00000100
	// DiskIOInit flag enables start/end disk I/O events
	DiskIOInit EventTraceFlags = 0x00000400
	// Dispatcher flag activates dispatcher events
	Dispatcher EventTraceFlags = 0x00000800
	// DPC flag enables Deferred Procedure Call events
	DPC EventTraceFlags = 0x00000020
	// Driver flag enables driver events
	Driver EventTraceFlags = 0x00800000
	// FileIO enables file I/O events.
	FileIO EventTraceFlags = 0x02000000
	// FileIOInit flag enables file start/end events.
	FileIOInit EventTraceFlags = 0x04000000
	// ImageLoad flag enables image events.
	ImageLoad EventTraceFlags = 0x00000004
	// Handle flag enables handle events.
	Handle EventTraceFlags = 0x80000040
	// IRQ flag enables IRQ events.
	IRQ EventTraceFlags = 0x00000040
	// Job flag enables job events.
	Job EventTraceFlags = 0x00080000
	// NetTCPIP flag enables network events.
	NetTCPIP EventTraceFlags = 0x00010000
	// Process flag enables process events.
	Process EventTraceFlags = 0x00000001
	// Registry flag enable registry events.
	Registry EventTraceFlags = 0x00020000
	// Syscall flag enables syscall enter/exit events.
	Syscall EventTraceFlags = 0x00000080
	// Thread flag enables thread events.
	Thread EventTraceFlags = 0x00000002
)

// String returns the string representation of enabled event trace flags.
func (f EventTraceFlags) String() string {
	flags := make([]string, 0)
	if f&ALPC == ALPC {
		flags = append(flags, "ALPC")
	}
	if f&Cswitch == Cswitch {
		flags = append(flags, "Cswitch")
	}
	if f&DiskFileIO == DiskFileIO {
		flags = append(flags, "DiskFileIO")
	}
	if f&DiskIO == DiskIO {
		flags = append(flags, "DiskIO")
	}
	if f&FileIO == FileIO {
		flags = append(flags, "FileIO")
	}
	if f&ImageLoad == ImageLoad {
		flags = append(flags, "DLL")
	}
	if f&Handle == Handle {
		flags = append(flags, "Handle")
	}
	if f&NetTCPIP == NetTCPIP {
		flags = append(flags, "TCPIP")
	}
	if f&Process == Process {
		flags = append(flags, "Process")
	}
	if f&Registry == Registry {
		flags = append(flags, "Registry")
	}
	if f&Thread == Thread {
		flags = append(flags, "Thread")
	}
	return strings.Join(flags, ", ")
}

// WnodeHeader is a member of `EventTraceProperties` structure. The majority of the fields in this structure are not relevant to us.
type WnodeHeader struct {
	// BufferSize is the total size of memory allocated, in bytes, for the event tracing session properties.
	BufferSize uint32
	// ProviderID is reserved for internal use.
	ProviderID uint32
	// HostricalContext is an union field with the following C representation:
	// union {
	//	ULONG64 HistoricalContext;
	//	struct {
	//	  ULONG Version;
	//	  ULONG Linkage;
	//	};
	// };
	// On output, HistoricalContext stores the handle to the event tracing session. Version and Linkage fields are reserved for internal use.
	HistoricalContext [8]byte
	// KernelHandle is an union with the following C representation:
	// union {
	//	HANDLE        KernelHandle;
	//	LARGE_INTEGER TimeStamp;
	//  };
	// `KernelHandle` is reserved for internal use. `TimeStamp` designates the instant at which the information of this
	// structure was updated.
	KernelHandle [8]byte
	// GUID that defines the session. For NT Kernel Logger session we have to set this member to `SystemTraceControlGuid`.
	GUID syscall.GUID
	// ClientContext represents clock resolution to use when logging the time stamp for each event. The default is Query performance counter (QPC).
	ClientContext uint32
	// Flags must contain `WnodeFlagTracedGUID` to indicate that the structure contains event tracing information.
	Flags uint32
}

// EventTraceProperties contains information about an event tracing session. Each time a new session is created, or an existing session
// is about to be modified, this structure is used to describe session properties.
type EventTraceProperties struct {
	// Wnode structure requires `BufferSize`, `Flags` and `GUID` members to be initialized.
	Wnode WnodeHeader
	// BufferSize represents the amount of memory allocated for each event tracing session buffer, in kilobytes.
	// The maximum buffer size is 1 MB. ETW uses the size of physical memory to calculate this value.
	// If an application expects a relatively low event rate, the buffer size should be set to the memory page size.
	// To get the page memory size, you can invoke GetSystemInfo() function.
	// If the event rate is expected to be relatively high, the application should specify a larger buffer size,
	// and should increase the maximum number of buffers.
	//
	// The buffer size affects the rate at which buffers fill and must be flushed. Although a small buffer size requires
	// less memory, it increases the rate at which buffers must be flushed.
	BufferSize uint32
	// MinimumBuffers specifies the minimum number of buffers allocated for the event tracing session's buffer pool.
	// The minimum number of buffers that you can specify is two buffers per processor. For example, on a single processor machine,
	// the minimum number of buffers is two.
	MinimumBuffers uint32
	// MaximumBuffers is the maximum number of buffers allocated for the event tracing session's buffer pool. Typically, this value is
	// the minimum number of buffers plus twenty. ETW uses the buffer size and the size of physical memory to calculate this value.
	MaximumBuffers uint32
	// MaximumFileSize is the maximum size of the file used to log events, in megabytes.
	MaximumFileSize uint32
	// LogFileMode determines the logging modes for the event tracing session. You use this member to specify that you want events written to a
	// log file, a real-time consumer, or both. In real-time logging mode, if no consumers are available, events will be written
	// to disk, and when a consumers begins processing real-time events, the events in the playback file are consumed first.
	LogFileMode uint32
	// FlushTimer specifies how often, in seconds, the trace buffers are forcibly flushed. The minimum flush time is 1 second.
	// This forced flush is in addition to the automatic flush that occurs whenever a buffer is full and when the trace session
	// stops. If zero, ETW flushes buffers as soon as they become full. If nonzero, ETW flushes all buffers that contain events
	// based on the timer value. Typically, you want to flush buffers only when they become full. Forcing the buffers to flush
	// (either by setting this member to a nonzero value or by calling `FlushTrace`) can increase the file size of the log file
	// with unfilled buffer space.
	//
	// If the consumer is consuming events in real time, you may want to set this member to a nonzero value if the event rate is
	// low to force events to be delivered before the buffer is full.
	// For the case of a realtime logger, a value of zero (the default value) means that the flush time will be set to 1 second.
	// A realtime logger is when LogFileMode is set to `EventTraceRealTimeMode`.
	FlushTimer uint32
	// EnableFlags specifies which kernel events are delievered to the consumer when NT Kernel logger session is started.
	// For example, registry events, process, disk IO and so on.
	EnableFlags EventTraceFlags
	// AgeLimit is not used.
	AgeLimit int32
	// NumberOfBuffers indicates the number of buffers allocated for the event tracing session's buffer pool.
	NumberOfBuffers uint32
	// FreeBuffers indicates the number of buffers that are allocated but unused in the event tracing session's buffer pool.
	FreeBuffers uint32
	// EventsLost counts the number of events that were not recorded.
	EventsLost uint32
	// BuffersWritten counts the number of buffers written.
	BuffersWritten uint32
	// LogBuffersLost determines the number of buffers that could not be written to the log file.
	LogBuffersLost uint32
	// RealTimeBuffersLost represents the number of buffers that could not be delivered in real-time to the consumer.
	RealTimeBuffersLost uint32
	// LoggerThreadID is the thread identifier for the event tracing session.
	LoggerThreadID uintptr
	// LogFileNameOffset is the offset from the start of the structure's allocated memory to beginning of the null-terminated
	// string that contains the log file name.
	LogFileNameOffset uint32
	// LoggerNameOffset is the offset from the start of the structure's allocated memory to beginning of the null-terminated
	// string that contains the session name. The session name is limited to 1024 characters. The session name is case-insensitive
	// and must be unique.
	LoggerNameOffset uint32
}

// EventTraceHeader contains standard event tracing information common to all events.
type EventTraceHeader struct {
	// Size represents the total number of bytes of the event. It includes the size of the header structure,
	// plus the size of any event-specific data appended to the header.
	Size uint16
	// FieldTypeFlags is an union field represented as follow:
	//  union {
	//	USHORT FieldTypeFlags;
	//	struct {
	//	  UCHAR HeaderType;
	//	  UCHAR MarkerFlags;
	//	};
	// };
	// All memebers of this union are reserved for internal use.
	FieldTypeFlags [2]byte
	// Versions in an union field with the following declaration:
	// union {
	//	ULONG  Version;
	//	struct {
	//	  UCHAR  Type;
	//	  UCHAR  Level;
	//	  USHORT Version;
	//	} Class;
	//  };
	// `Type` field indicates the general purpose type of this event (e.g. data collection end/start, checkpoint, etc.)
	// `Level` designates the severity of the generated event and the `Version` tells the consumer which MOF class to use to
	// decipher the event data.
	Version [4]byte
	// ThreadID identifes the thread that generated this event.
	ThreadID uint32
	// ProcessID identifes the process that generated this event.
	ProcessID uint32
	// Timestamp contains the time that the event occurred.
	Timestamp uint64
	// GUID is an union:
	// union {
	//	GUID      Guid;
	//	ULONGLONG GuidPtr;
	// };
	// `Guid` identifies a category of events. `GuidPtr` is the pointer to an event trace class GUID.
	GUID [16]byte
	// ProcessorTime is another union type:
	// union {
	//	struct {
	//		ULONG ClientContext;
	//		ULONG Flags;
	//	  };
	//	  struct {
	//		ULONG KernelTime;
	//		ULONG UserTime;
	//	  };
	//	  ULONG64 ProcessorTime;
	// };
	// `ClientContext` is reserved, while `Flags` must be set to `WnodeFlagTracedGuid`. The rest of the members
	// specify elapsed execution time for kernel and user mode instructions respectively.
	ProcessorTime [8]byte
}

// EventTrace stores event information that is delivered to an event trace consumer.
type EventTrace struct {
	// Header contains standard event tracing metadata.
	Header EventTraceHeader
	// InstanceID represents the instance identifier.
	InstanceID uint32
	// ParentInstanceID represents instance identifer for a parent event.
	ParentInstanceID uint32
	// ParentGUID is the class GUID of the parent event.
	ParentGUID syscall.GUID
	// MofData is the pointer to the beginning of the event-specific data for this event.
	MofData uintptr
	// MofLength represents the number of bytes to which `MofData` points.
	MofLength uint32
	// Context is an union type:
	// union {
	//	ULONG              ClientContext;
	//	ETW_BUFFER_CONTEXT BufferContext;
	// };
	// `ClientContext` field is reserved. `BufferContext` Provides information about the event such as the session identifier
	// and processor number of the CPU on which the provider process ran.
	Context [2]byte
}

// TraceLogfileHeader contains information about an event tracing session and its events.
type TraceLogfileHeader struct {
	// BufferSize is the size of the event tracing session's buffers in bytes.
	BufferSize uint32
	// Version is the union type that represents version number of the operating system.
	Version [4]byte
	// ProviderVersion is the build number of the operating system.
	ProviderVersion uint32
	// NumberOfProcessors indicates the number of processors on the system.
	NumberOfProcessors uint32
	// EndTime is the time at which the event tracing session stopped. This value is 0 for real time event consumers.
	EndTime uint64
	// TimerResolution is the resolution of the hardware timer, in units of 100 nanoseconds.
	TimerResolution uint32
	// MaximumFileSize is the size of the log file, in megabytes.
	MaximumFileSize uint32
	// LogfileMode represents the current logging mode for the event tracing session.
	LogfileMode uint32
	// BuffersWritten is the total number of buffers written by the event tracing session.
	BuffersWritten uint32
	// GUID is a an union type with the two first field reserved for internal usage. Other fields indicate
	// the number of events lost and the CPU speed in Mhz.
	GUID [16]byte
	// LoggerName is a reserved field.
	LoggerName *uint16
	// LogfileName is a reserved field.
	LogfileName *uint16
	// TimeZone contains time-zone information for `BootTime`, `EndTime` and `StartTime` fields.
	TimeZone syscall.Timezoneinformation
	// BootTime is the time at which the system was started, in 100-nanosecond intervals since midnight, January 1, 1601.
	BootTime uint64
	// PerfFreq is the frequency of the high-resolution performance counter, if one exists.
	PerfFreq uint64
	// StartTime is the time at which the event tracing session started, in 100-nanosecond intervals since midnight, January 1, 1601.
	StartTime uint64
	// ReservedFlags specifies the clock type.
	ReservedFlags uint32
	// BuffersLost is the total number of buffers lost during the event tracing session.
	BuffersLost uint32
}

// EventTraceLogfile specifies how the consumer wants to read events (from a log file or in real-time) and the callbacks
// that will receive the events.When ETW flushes a buffer, this structure contains information about the event tracing
// session and the buffer that ETW flushed.
type EventTraceLogfile struct {
	// LogFileName is the name of the log file used by the event tracing session.
	LogFileName *uint16
	// LoggerName is the name of the event tracing session. Only applicable when consuming events in real time.
	LoggerName *uint16
	// CurrentTime on output, the current time, in 100-nanosecond intervals since midnight, January 1, 1601.
	CurrentTime int64
	// BuffersRead represents the number of buffers processed.
	BuffersRead uint32
	// LogFileMode is union type the dictates the processing mode for events.
	LogFileMode [4]byte
	// CurrentEvents contains the last event processed.
	CurrentEvent EventTrace
	// LogfileHeader represents global information about the tracing session.
	LogfileHeader TraceLogfileHeader
	// BufferCallback is a pointer to the function that receives buffer-related statistics for each buffer ETW flushes.
	// ETW calls this callback after it delivers all the events in the buffer.
	BufferCallback uintptr
	// BufferSize contains the size of each buffer, in bytes.
	BufferSize uint32
	// Filled contains the number of bytes in the buffer that contain valid information.
	Filled uint32
	// EventsLost is an unused field.
	EventsLost uint32
	// EventCallback is the union field that contains pointers to callback functions that ETW calls for each buffer.
	EventCallback [8]byte
	// IsKernelTrace specifies whether the event tracing session is the NT kernel logger.
	IsKernelTrace uint32
	// Context is data that a consumer can specify when calling `OpenTrace` function.
	Context uintptr
}

// EventDescriptor contains metadata that defines the event.
type EventDescriptor struct {
	// ID represents event identifier.
	ID uint16
	// Version indicates a revision to the event definition.
	Version uint8
	// Channel is the audience for the event (e.g. administrator or developer).
	Channel uint8
	// Level is the severity or level of detail included in the event.
	Level uint8
	// Opcode is step in a sequence of operations being performed within the `Task` field. For MOF-defined events,
	// the `Opcode` member contains the event type value.
	Opcode uint8
	// Task represents a larger unit of work within an application or component.
	Task uint16
	// Keyword A bitmask that specifies a logical group of related events. Each bit corresponds to one group. An event may belong to one or more groups.
	// The keyword can contain one or more provider-defined keywords, standard keywords, or both.
	Keyword uint64
}

// EventHeader defines information about the event.
type EventHeader struct {
	// Size represents the size of the event, in bytes.
	Size uint16
	// HeaderType is reserved.
	HeaderType uint16
	// Flags provides information about the event such as the type of session it was logged to and if
	// the event contains extended data.
	Flags uint16
	// EventProperty indicates the source to use for parsing the event data.
	EventProperty uint16
	// ThreadID identifies the thread that generated the event.
	ThreadID uint32
	// ProcessID identifies the process that generated the event.
	ProcessID uint32
	// Timestamps contains the time that the event occurred.
	Timestamp uint64
	// ProviderID is the GUID that uniquely identifies the provider that logged the event.
	ProviderID syscall.GUID
	// EventDescriptor defines the information about the event such as the event identifier and severity level.
	EventDescriptor EventDescriptor
	// ProcessorTime is the union type that defines elapsed execution time for kernel-mode and user-mode instructions
	// in CPU units.
	ProcessorTime [8]byte
	// ActivityID is the identifier that relates two events.
	ActivityID syscall.GUID
}

// BufferContext provides context information about the event.
type BufferContext struct {
	// ProcessorIndex is an union type that contains among other fields the number of the CPU on which
	// the provider process was running.
	ProcessorIndex [2]byte
	// LoggerID identifies of the session that logged the event.
	LoggerID uint16
}

// Linkage is the inner struct for EventHeaderExtendedDataItem.
type Linkage struct {
	Linkage   uint16
	Resreved2 uint16
}

// EventHeaderExtendedDataItem defines the extended data that ETW collects as part of the event data.
type EventHeaderExtendedDataItem struct {
	// Reserverd1 is a reserved field.
	Reserved1 uint16
	// ExtType defines the type of extended data.
	ExtType uint16
	Linkage
	// DataSize is the size in bytes, of the extended data
	DataSize uint16
	// DataPtr is the pointer to extended data.
	DataPtr uint64
}

// EventRecord defines the layout of an event that ETW delivers.
type EventRecord struct {
	// Header represents information about the event such as the time stamp for when it was written.
	Header EventHeader
	// BufferContext defines information such as the session that logged the event.
	BufferContext BufferContext
	// ExtendedDataCount is the number of extended data structures in the `ExtendedData` field.
	ExtendedDataCount uint16
	// BufferLen represents the size, in bytes, of the event data buffer
	BufferLen uint16
	// ExtendedData designates extended data items that ETW collects. The extended data includes some items, such as the security
	// identifier (SID) of the user that logged the event.
	ExtendedData *EventHeaderExtendedDataItem
	// Buffer represents raw event data that's parsed via TDH API.
	Buffer uintptr
	// UserContext is a pointer to custom user data passed in `EventTraceLogfile` structure.
	UserContext uintptr
}

```

`pkg/syscall/file/file.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package file

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/utf16"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	"os"
	"syscall"
	"unsafe"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32")
	shlwapi  = syscall.NewLazyDLL("shlwapi")
	nt       = syscall.NewLazyDLL("ntdll")

	getLogicalDrives = kernel32.NewProc("GetLogicalDrives")
	queryDosDevice   = kernel32.NewProc("QueryDosDeviceW")
	pathIsDirectory  = shlwapi.NewProc("PathIsDirectoryW")

	ntQueryVolumeInformationFile = nt.NewProc("NtQueryVolumeInformationFile")

	drives = []string{
		"A",
		"B",
		"C",
		"D",
		"E",
		"F",
		"G",
		"H",
		"I",
		"J",
		"K",
		"L",
		"M",
		"N",
		"O",
		"P",
		"Q",
		"R",
		"S",
		"T",
		"U",
		"V",
		"W",
		"X",
		"Y",
		"Z"}
)

const (
	fsDeviceInformation = 4
)

// GetLogicalDrives returns available device drives in the system.
func GetLogicalDrives() []string {
	r, _, _ := getLogicalDrives.Call()
	bitmask := uint32(r)
	devs := make([]string, 0)
	for _, drive := range drives {
		if bitmask&1 == 1 {
			devs = append(devs, drive+":")
		}
		bitmask >>= 1
	}
	return devs
}

// QueryVolumeInfo obtains device information for the specified file handle.
func QueryVolumeInfo(fd uintptr) (*DevInfo, error) {
	var (
		iosb ioStatusBlock
		di   DevInfo
	)
	_, _, err := ntQueryVolumeInformationFile.Call(
		fd,
		uintptr(unsafe.Pointer(&iosb)),
		uintptr(unsafe.Pointer(&di)),
		unsafe.Sizeof(di),
		uintptr(fsDeviceInformation),
	)
	if err != nil && err != syscall.Errno(0) {
		return nil, os.NewSyscallError("NtQueryVolumeInformationFile", err)
	}
	return &di, nil
}

// QueryDosDevice translates the DOS device name to hard disk drive letter.
func QueryDosDevice(drive string) (string, error) {
	dev := make([]uint16, syscall.MAX_PATH)
	errno, _, err := queryDosDevice.Call(
		uintptr(unsafe.Pointer(utf16.StringToUTF16Ptr(drive))),
		uintptr(unsafe.Pointer(&dev[0])),
		uintptr(syscall.MAX_PATH),
	)
	if winerrno.Errno(errno) == winerrno.Success {
		return "", os.NewSyscallError("QueryDosDevice", err)
	}
	return syscall.UTF16ToString(dev), nil
}

// IsPathDirectory indicates if path is a valid directory.
func IsPathDirectory(path string) bool {
	isDir, _, _ := pathIsDirectory.Call(uintptr(unsafe.Pointer(utf16.StringToUTF16Ptr(path))))
	return isDir > 0
}

```

`pkg/syscall/file/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package file

import "syscall"

// AttributeData contains meta information about a file.
type AttributeData struct {
	// FileAttributes represents the file attributes.
	FileAttributes uint32
	// CreationTime specifies when a file or directory is created. If the underlying file system does not support creation time, this member is zero.
	CreationTime syscall.Filetime
	// LastAccessTime for a file, the structure specifies the last time that a file is read from or written to.
	// For a directory, the structure specifies when the directory is created. For both files and directories,
	// the specified date is correct, but the time of day is always set to midnight. If the underlying file
	// system does not support the last access time, this member is zero (0).
	LastAccessTime syscall.Filetime
	// LastWriteTime for a file, the structure specifies the last time that a file is written to. For a directory,
	// the structure specifies when the directory is created. If the underlying file system does not support the last write time,
	// this member is zero (0).
	LastWriteTime syscall.Filetime
	// FileSizeHigh high-order part of the file size.
	FileSizeHigh uint32
	// FileSizeLow low-order part of the file size.
	FileSizeLow uint32
}

// DevInfo provides file system device information about the type of device object associated with a file object.
type DevInfo struct {
	// Type designates the type of underlying device.
	Type uint32
	// Characteristics represents device characteristics.
	Characteristcs uint32
}

type ioStatusBlock struct {
	Status, Information uintptr
}

```

`pkg/syscall/handle/handle.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	"os"
	"syscall"
	"unsafe"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	closeHandle     = kernel32.NewProc("CloseHandle")
	duplicateHandle = kernel32.NewProc("DuplicateHandle")
)

// Handle represents the handle type.
type Handle uintptr

// DuplicateAccess is the enum for handle duplicate access flags.
type DuplicateAccess uint32

const (
	// ThreadQueryAccess determines that handle duplication requires the ability to query thread info.
	ThreadQueryAccess DuplicateAccess = 0x0040
	// ProcessQueryAccess determines that handle duplication requires the ability to query process info.
	ProcessQueryAccess DuplicateAccess = 0x1000
	// ReadControlAccess specifies the ability to query the security descriptor.
	ReadControlAccess DuplicateAccess = 0x00020000
	// SemaQueryAccess is the duplicate access type required for synchronization objects such as mutants.
	SemaQueryAccess DuplicateAccess = 0x0001
	// AllAccess doesn't specify the access mask.
	AllAccess DuplicateAccess = 0
)

// IsValid determines if handle instance if valid.
func (handle Handle) IsValid() bool {
	return handle != ^Handle(0)
}

// Close disposes the underlying handle object.
func (handle Handle) Close() {
	if handle == 0 {
		return
	}
	_, _, _ = closeHandle.Call(uintptr(handle))
}

// Duplicate duplicates an object handle in the caller address's space.
func (handle Handle) Duplicate(src, dest Handle, access DuplicateAccess) (Handle, error) {
	var destHandle Handle
	errno, _, err := duplicateHandle.Call(
		uintptr(src),
		uintptr(handle),
		uintptr(dest),
		uintptr(unsafe.Pointer(&destHandle)),
		uintptr(access),
		0,
		0,
	)
	if winerrno.Errno(errno) != winerrno.Success {
		return destHandle, nil
	}
	return Handle(0), os.NewSyscallError("DuplicateHandle", err)
}

```

`pkg/syscall/object/alpc.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package object

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"unsafe"
)

// AlpcInformationClass defines the type for the ALPC information class values.
type AlpcInformationClass uint8

const (
	// AlpcBasicPortInfo obtains basic ALPC port information
	AlpcBasicPortInfo AlpcInformationClass = iota
)

var ntAlpcQueryInformation = nt.NewProc("NtAlpcQueryInformation")

// GetAlpcInformation gets specified information for the ALPC handle.
func GetAlpcInformation(handle handle.Handle, klass AlpcInformationClass, buf []byte) error {
	status, _, _ := ntAlpcQueryInformation.Call(
		uintptr(handle),
		uintptr(klass),
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(len(buf)),
		0,
	)
	if status != 0 {
		return fmt.Errorf("NtAlpcQueryInformation failed with status code 0x%X", status)
	}
	return nil
}

```

`pkg/syscall/object/event.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package object

import (
	"os"
	"syscall"
)

var (
	kernel32    = syscall.NewLazyDLL("kernel32")
	createEvent = kernel32.NewProc("CreateEventA")
	setEvent    = kernel32.NewProc("SetEvent")
	resetEvent  = kernel32.NewProc("ResetEvent")
)

// Event is the type alias for event objects.
type Event uintptr

// NewEvent produces a new event with the specified flags.
func NewEvent(manualReset, isSignaled bool) (Event, error) {
	var reset uint8
	var signaled uint8
	if manualReset {
		reset = 1
	}
	if isSignaled {
		signaled = 1
	}
	handle, _, err := createEvent.Call(0, uintptr(reset), uintptr(signaled), 0)
	if handle == 0 {
		return Event(0), os.NewSyscallError("CreateEventA", err)
	}
	return Event(handle), nil
}

// Set sets the event object to the signaled state.
func (e Event) Set() error {
	errno, _, err := setEvent.Call(uintptr(e))
	if errno == 0 {
		return os.NewSyscallError("SetEvent", err)
	}
	return nil
}

// Reset sets the event object to the nonsignaled state.
func (e Event) Reset() error {
	errno, _, err := resetEvent.Call(uintptr(e))
	if errno == 0 {
		return os.NewSyscallError("ResetEvent", err)
	}
	return nil
}

// Close closes the handle allocated by the event object.
func (e Event) Close() error {
	return syscall.Close(syscall.Handle(e))
}

```

`pkg/syscall/object/mutant.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package object

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"unsafe"
)

var ntQueryMutant = nt.NewProc("NtQueryMutant")

// MutantInformationClass is the type alias for the mutant information class.
type MutantInformationClass uint8

const (
	// MutantBasicInfo is the information class for getting mutant basic information.
	MutantBasicInfo MutantInformationClass = iota
)

// QueryMutant gets mutant detalied information according to the information class.
func QueryMutant(handle handle.Handle, klass MutantInformationClass, buf []byte) error {
	status, _, _ := ntQueryMutant.Call(
		uintptr(handle),
		uintptr(klass),
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(len(buf)),
		0,
	)
	if status != 0 {
		return fmt.Errorf("NtQueryMutant failed with status code 0x%X", status)
	}
	return nil
}

```

`pkg/syscall/object/object.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package object

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	"syscall"
	"unsafe"
)

var (
	nt = syscall.NewLazyDLL("ntdll")

	ntQueryObject = nt.NewProc("NtQueryObject")
)

// InformationClass is the type alias for object information classes.
type InformationClass uint8

const (
	// NameInformationClass returns the object name information.
	NameInformationClass InformationClass = 1
	// TypeInformationClass returns the object type information.
	TypeInformationClass InformationClass = 2
	// TypesInformationClass returns handle object types.
	TypesInformationClass InformationClass = 3
	// SystemHandleInformationClass returns allocated system handles.
	SystemHandleInformationClass = 16
	// SystemExtendedHandleInformation returns extended allocated system handles.
	SystemExtendedHandleInformation = 64
)

// Query retrieves specified information for the handle reference.
func Query(handle handle.Handle, klass InformationClass, buf []byte) (uint32, error) {
	size := uint32(len(buf))
	status, _, _ := ntQueryObject.Call(
		uintptr(handle),
		uintptr(klass),
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(size),
		uintptr(unsafe.Pointer(&size)),
	)
	if status != 0 {
		if status == winerrno.StatusInfoLengthMismatch || status == winerrno.StatusBufferTooSmall {
			return size, errors.ErrNeedsReallocateBuffer
		}
		return size, fmt.Errorf("NtQueryObject failed with status code 0x%X", status)
	}
	return size, nil
}

```

`pkg/syscall/object/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package object

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/utf16"
)

type genericMapping struct {
	GenericRead    uint32
	GenericWrite   uint32
	GenericExecute uint32
	GenericAll     uint32
}

// TypeInformation contains object type data.
type TypeInformation struct {
	TypeName                   utf16.UnicodeString
	TotalNumberOfObjects       uint32
	TotalNumberOfHandles       uint32
	TotalPagedPoolUsage        uint32
	TotalNonPagedPoolUsage     uint32
	TotalNamePoolUsage         uint32
	TotalHandleTableUsage      uint32
	HighWaterNumberOfObjects   uint32
	HighWaterNumberOfHandles   uint32
	HighWaterPagedPoolUsage    uint32
	HighWaterNonPagedPoolUsage uint32
	HighWaterNamePoolUsage     uint32
	HighWaterHandleTableUsage  uint32
	InvalidAttributes          uint32
	GenericMapping             genericMapping
	ValidAccessMask            uint32
	SecurityRequired           bool
	MaintainHandleCount        bool
	TypeIndex                  uint8
	ReservedByte               int8
	PoolType                   uint32
	DefaultPagedPoolCharge     uint32
	DefaultNonPagedPoolCharge  uint32
}

// TypesInformation stores the number of resolved object type names.
type TypesInformation struct {
	NumberOfTypes uint32
}

// NameInformation sotres object name information.
type NameInformation struct {
	ObjectName utf16.UnicodeString
}

// ProcessHandleTableEntryInfo is the structure that describes the process handle entry.
type ProcessHandleTableEntryInfo struct {
	Handle           handle.Handle
	HandleCount      uintptr
	PointerCount     uintptr
	GrantedAccess    uint32
	ObjectTypeIndex  uint32
	HandleAttributes uint32
	Reserved         uint32
}

// ProcessHandleSnapshotInformation is the structure that holds the process handle table.
type ProcessHandleSnapshotInformation struct {
	NumberOfHandles uintptr
	Reserved        uintptr
	Handles         [1]ProcessHandleTableEntryInfo
}

// SystemHandleTableEntryInfoEx is the structure that describes the process handle entry.
type SystemHandleTableEntryInfoEx struct {
	Object                uint64
	ProcessID             uintptr
	Handle                handle.Handle
	GrantedAccess         uint32
	CreatorBackTraceIndex uint8
	ObjectTypeIndex       uint8
	HandleAttributes      uint32
	Reserved              uint32
}

// SystemHandleInformationEx is the structures that holds the process handle table.
type SystemHandleInformationEx struct {
	NumberOfHandles uintptr
	Reserved        uintptr
	Handles         [1]SystemHandleTableEntryInfoEx
}

```

`pkg/syscall/process/process.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package process

import (
	"fmt"
	"os"
	"syscall"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")
	native   = syscall.NewLazyDLL("ntdll.dll")

	openProcess               = kernel32.NewProc("OpenProcess")
	queryFullProcessImageName = kernel32.NewProc("QueryFullProcessImageNameW")
	readProcessMemory         = kernel32.NewProc("ReadProcessMemory")
	ntQueryInformationProcess = native.NewProc("NtQueryInformationProcess")
	getProcessTimes           = kernel32.NewProc("GetProcessTimes")
	getProcessIDOfThread      = kernel32.NewProc("GetProcessIdOfThread")
	getExitCodeProcess        = kernel32.NewProc("GetExitCodeProcess")
)

const procStatusStillActive = 259

// DesiredAccess defines the type alias for process's access modifiers
type DesiredAccess uint32

const (
	// Terminate is required to terminate a process
	Terminate DesiredAccess = 0x0001
	// CreateThread is required to create a thread in the process
	CreateThread DesiredAccess = 0x0002
	// VMOperation is required to perform an operation on the address space of a process
	VMOperation DesiredAccess = 0x0008
	// VMRead is required to read memory in a process
	VMRead DesiredAccess = 0x0010
	// VMWrite is required to write to memory in a process
	VMWrite DesiredAccess = 0x0020
	// DupHandle lets duplicate handles of the target process
	DupHandle DesiredAccess = 0x0040
	// CreateProcess is required to use this process as the parent process
	CreateProcess DesiredAccess = 0x0080
	// SetQuota is required to set memory limits
	SetQuota DesiredAccess = 0x0100
	// SetInformation is required to set certain information about a process
	SetInformation DesiredAccess = 0x0200
	// QueryInformation is required to retrieve certain information about a process, such as its token, exit code, and priority class
	QueryInformation DesiredAccess = 0x0400
	// SuspendResume is required to suspend or resume a process
	SuspendResume DesiredAccess = 0x0800
	// QueryLimitedInformation is required to get certain information about process, such as process's image name
	QueryLimitedInformation DesiredAccess = 0x1000
	// AllAccess represents all possible access rights
	AllAccess DesiredAccess = 0x000F0000 | 0x00100000 | 0xFFFF
)

// String returns a human-readable process desired access.
func (access DesiredAccess) String() string {
	switch access {
	case Terminate:
		return "TERMINATE"
	case CreateThread:
		return "CREATE_THREAD"
	case VMOperation:
		return "VM_OPERATION"
	case VMWrite:
		return "VM_WRITE"
	case VMRead:
		return "VM_READ"
	case DupHandle:
		return "DUP_HANDLE"
	case CreateProcess:
		return "CREATE_PROCESS"
	case SetQuota:
		return "SET_QUOTA"
	case QueryInformation:
		return "QUERY_INFORMATION"
	case QueryLimitedInformation:
		return "QUERY_LIMITED_INFORMATION"
	case SetInformation:
		return "SET_INFORMATION"
	case SuspendResume:
		return "SUSPEND_RESUME"
	case AllAccess:
		return "ALL_ACCESS"
	default:
		return "UNKNOWN"
	}
}

const maxFlags = 0x2460

// Flags converts the desired access mask to the slice of string values.
func (access DesiredAccess) Flags() []string {
	flags := make([]string, 0)
	if access == AllAccess {
		return []string{AllAccess.String()}
	}
	if (access & Terminate) != 0 {
		flags = append(flags, Terminate.String())
	}
	if (access & CreateThread) != 0 {
		flags = append(flags, CreateThread.String())
	}
	if (access & VMOperation) != 0 {
		flags = append(flags, VMOperation.String())
	}
	for mask := VMRead; mask <= maxFlags; mask *= 2 {
		if (access & mask) != 0 {
			flags = append(flags, mask.String())
		}
	}
	return flags
}

// InfoClassFlags defines the type for process's info class
type InfoClassFlags uint8

const (
	// BasicInformationClass returns basic process's information
	BasicInformationClass InfoClassFlags = 0
	// HandleInformationClass returns allocated process handles
	HandleInformationClass InfoClassFlags = 51
)

// Open acquires a handle from the running process.
func Open(access DesiredAccess, inheritHandle bool, processID uint32) (handle.Handle, error) {
	var inherit uint8
	if inheritHandle {
		inherit = 1
	} else {
		inherit = 0
	}
	h, _, err := openProcess.Call(uintptr(access), uintptr(inherit), uintptr(processID))
	if h == 0 {
		return handle.Handle(0), os.NewSyscallError("OpenProcess", err)
	}
	return handle.Handle(h), nil
}

// QueryFullImageName retrieves the full name of the executable image for the specified process.
func QueryFullImageName(handle handle.Handle) (string, error) {
	var size uint32 = syscall.MAX_PATH
	name := make([]uint16, size)

	errno, _, err := queryFullProcessImageName.Call(uintptr(handle), uintptr(0), uintptr(unsafe.Pointer(&name[0])), uintptr(unsafe.Pointer(&size)))
	if winerrno.Errno(errno) != winerrno.Success {
		return syscall.UTF16ToString(name), nil
	}
	return "", os.NewSyscallError("QueryFullProcessImageName", err)
}

// QueryInfo retrieves a variety of process's information depending on the info class passed to this function.
func QueryInfo(handle handle.Handle, infoClass InfoClassFlags, buf []byte) (uint32, error) {
	var size uint32
	if ntQueryInformationProcess != nil {
		errno, _, _ := ntQueryInformationProcess.Call(uintptr(handle), uintptr(infoClass), uintptr(unsafe.Pointer(&buf[0])), uintptr(len(buf)), uintptr(unsafe.Pointer(&size)))
		if winerrno.Errno(errno) != winerrno.Success {
			if errno == winerrno.StatusInfoLengthMismatch || errno == winerrno.StatusBufferTooSmall {
				return size, errors.ErrNeedsReallocateBuffer
			}
			return size, fmt.Errorf("NtQueryInformationProcess failed with status code 0x%X", errno)
		}
		return size, nil
	}
	return size, nil
}

// ReadMemory reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
func ReadMemory(handle handle.Handle, addr unsafe.Pointer, size uintptr) ([]byte, error) {
	buf := make([]byte, size)
	errno, _, err := readProcessMemory.Call(uintptr(handle), uintptr(addr), uintptr(unsafe.Pointer(&buf[0])), size, uintptr(0))
	if winerrno.Errno(errno) != winerrno.Success {
		return buf, nil
	}
	return nil, os.NewSyscallError("ReadProcessMemory", err)
}

// ReadMemoryUnicode reads data from an area of memory as a slice of Unicode code points.
func ReadMemoryUnicode(handle handle.Handle, addr unsafe.Pointer, size uintptr) ([]uint16, error) {
	buf := make([]uint16, size)
	errno, _, err := readProcessMemory.Call(uintptr(handle), uintptr(addr), uintptr(unsafe.Pointer(&buf[0])), size, uintptr(0))
	if winerrno.Errno(errno) != winerrno.Success {
		return buf, nil
	}
	return nil, os.NewSyscallError("ReadProcessMemory", err)
}

// GetParentPID returns the identifier of the parent process from the process's basic information structure.
func GetParentPID(handle handle.Handle) uint32 {
	buf := make([]byte, unsafe.Sizeof(BasicInformation{}))
	_, err := QueryInfo(handle, BasicInformationClass, buf)
	if err != nil {
		return uint32(0)
	}
	info := (*BasicInformation)(unsafe.Pointer(&buf[0]))
	return uint32(info.InheritedFromUniqueProcessID)
}

// GetStartTime returns process's timing statistics.
func GetStartTime(handle handle.Handle) (time.Time, error) {
	var (
		ct syscall.Filetime
		xt syscall.Filetime
		kt syscall.Filetime
		ut syscall.Filetime
	)
	errno, _, err := getProcessTimes.Call(uintptr(handle), uintptr(unsafe.Pointer(&ct)), uintptr(unsafe.Pointer(&xt)), uintptr(unsafe.Pointer(&kt)), uintptr(unsafe.Pointer(&ut)))
	if winerrno.Errno(errno) != winerrno.Success {
		return time.Unix(0, ct.Nanoseconds()), nil
	}
	return time.Now(), os.NewSyscallError("GetProcessTime", err)
}

// GetPIDFromThread returns the pid to which the specified thread belongs.
func GetPIDFromThread(handle handle.Handle) (uint32, error) {
	pid, _, err := getProcessIDOfThread.Call(uintptr(handle))
	if pid == 0 {
		return uint32(0), os.NewSyscallError("GetProcessIdOfThread", err)
	}
	return uint32(pid), nil
}

// IsAlive checks if the process identified by the specified handle is still in running state.
func IsAlive(handle handle.Handle) bool {
	var exitCode uint32
	errno, _, _ := getExitCodeProcess.Call(uintptr(handle), uintptr(unsafe.Pointer(&exitCode)))
	if winerrno.Errno(errno) == winerrno.Success {
		return false
	}
	return exitCode == procStatusStillActive
}

```

`pkg/syscall/process/process_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package process

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestDesiredAccessToFlags(t *testing.T) {
	assert.Contains(t, DesiredAccess(0x1400).Flags(), "QUERY_INFORMATION")
	assert.Contains(t, DesiredAccess(0x1400).Flags(), "QUERY_LIMITED_INFORMATION")
	assert.Contains(t, DesiredAccess(0x1fffff).Flags(), "ALL_ACCESS")
}

```

`pkg/syscall/process/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package process

import "github.com/rabbitstack/fibratus/pkg/syscall/utf16"

// PEB describes the Process Environment Block.
type PEB struct {
	Reserved1              [2]byte
	BeingDebugged          byte
	Reserved2              [21]byte
	LDR                    *LDRData
	ProcessParameters      *RTLUserProcessParameters
	Reserved3              [520]byte
	PostProcessInitRoutine uintptr
	Reserved4              [136]byte
	SessionID              uint32
}

// BasicInformation describes the process basic information.
type BasicInformation struct {
	Reserved1                    uintptr
	PEB                          *PEB
	Reserved2                    [2]uintptr
	UniqueProcessID              uintptr
	InheritedFromUniqueProcessID uintptr
}

// String is the definition of the Unicode string.
type String struct {
	Length        uint8
	MaximumLength uint8
}

// RTLUserProcessParameters describes the process parameters such as the current working directory or the
// process environment block.
type RTLUserProcessParameters struct {
	Reserved1        [16]byte
	ConsoleHandle    uintptr
	ConsoleFlags     uint32
	Stdin            uintptr
	Stdout           uintptr
	Stderr           uintptr
	CurrentDirectory CurDir
	DllPath          utf16.UnicodeString
	ImagePathName    utf16.UnicodeString
	CommandLine      utf16.UnicodeString
	Environment      uintptr
}

// CurDir describes the string that stores the process current working directory.
type CurDir struct {
	DosPath utf16.UnicodeString
	Handle  uintptr
}

// LDRData contains information about all of the loaded modules in the current process.
type LDRData struct {
	Reserved1  [8]byte
	Reserved2  [3]uintptr
	ModuleList ListEntry
}

// ListEntry is the linked list item that points to the next module.
type ListEntry struct {
	Flink *ListEntry
	Blink *ListEntry
}

```

`pkg/syscall/registry/key.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package registry

// Key is the type alias for the registry root keys
type Key uint32

const (
	// InvalidKey designates invalid registry key.
	InvalidKey Key = 0
)

const (
	// ClassesRoot represents the HKEY_CLASSES_ROOT hive
	ClassesRoot Key = 0x80000000 + iota
	// CurrentUser represents the HKEY_CURRENT_USER hive
	CurrentUser
	// LocalMachine represents the HKEY_LOCAL_MACHINE hive
	LocalMachine
	// Users represents the HKEY_USERS hive
	Users
	// Hive represents the global hive that doesn't fall into category of any of the previous keys.
	Hive
)

// String returns a human-readable root key name.
func (k Key) String() string {
	switch k {
	case ClassesRoot:
		return "HKEY_CLASSES_ROOT"
	case CurrentUser:
		return "HKEY_CURRENT_USER"
	case LocalMachine:
		return "HKEY_LOCAL_MACHINE"
	case Users:
		return "HKEY_USERS"
	case Hive:
		return ""
	default:
		return "Unknown"
	}
}

```

`pkg/syscall/security/privileges.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package security

import (
	"bytes"
	"encoding/binary"
	"github.com/pkg/errors"
	"sync"
	"syscall"
	"unsafe"
)

var (
	procLookupPrivilegeValueW = advapi32.NewProc("LookupPrivilegeValueW")
	procAdjustTokenPrivileges = advapi32.NewProc("AdjustTokenPrivileges")
)

// Cache of privilege names to LUIDs.
var (
	privNames     = make(map[string]int64)
	privNameMutex sync.Mutex
)

const (
	// SeDebugPrivilege is the name of the privilege used to debug programs.
	SeDebugPrivilege = "SeDebugPrivilege"
)

// Errors returned by AdjustTokenPrivileges.
const (
	// ErrorNotAllAsigned specifies that the token does not have one or more of the privileges specified in the state parameter.
	ErrorNotAllAsigned syscall.Errno = 1300
)

// Attribute bits for privileges.
const (
	// PrivilegedEnabled enables the privilege.
	PrivilegedEnabled uint32 = 0x00000002
)

func lookupPrivilegeValue(systemName string, name string, luid *int64) (err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(systemName)
	if err != nil {
		return
	}
	var _p1 *uint16
	_p1, err = syscall.UTF16PtrFromString(name)
	if err != nil {
		return
	}
	return lookupPrivilegeValueW(_p0, _p1, luid)
}

func lookupPrivilegeValueW(systemName *uint16, name *uint16, luid *int64) (err error) {
	r1, _, e1 := syscall.Syscall(procLookupPrivilegeValueW.Addr(), 3, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(luid)))
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func adjustTokenPrivileges(token syscall.Token, releaseAll bool, input *byte, outputSize uint32, output *byte, requiredSize *uint32) (success bool, err error) {
	var _p0 uint32
	if releaseAll {
		_p0 = 1
	} else {
		_p0 = 0
	}
	r0, _, e1 := syscall.Syscall6(procAdjustTokenPrivileges.Addr(), 6, uintptr(token), uintptr(_p0), uintptr(unsafe.Pointer(input)), uintptr(outputSize), uintptr(unsafe.Pointer(output)), uintptr(unsafe.Pointer(requiredSize)))
	success = r0 != 0
	if true {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// mapPrivileges maps privilege names to LUID values.
func mapPrivileges(names []string) ([]int64, error) {
	var privileges []int64
	privNameMutex.Lock()
	defer privNameMutex.Unlock()
	for _, name := range names {
		p, ok := privNames[name]
		if !ok {
			err := lookupPrivilegeValue("", name, &p)
			if err != nil {
				return nil, errors.Wrapf(err, "LookupPrivilegeValue failed on '%v'", name)
			}
			privNames[name] = p
		}
		privileges = append(privileges, p)
	}
	return privileges, nil
}

// EnableTokenPrivileges enables the specified privileges in the given
// Token. The token must have TOKEN_ADJUST_PRIVILEGES access. If the token
// does not already contain the privilege it cannot be enabled.
func EnableTokenPrivileges(token syscall.Token, privileges ...string) error {
	privValues, err := mapPrivileges(privileges)
	if err != nil {
		return err
	}

	var b bytes.Buffer
	if err := binary.Write(&b, binary.LittleEndian, uint32(len(privValues))); err != nil {
		return err
	}
	for _, p := range privValues {
		if err := binary.Write(&b, binary.LittleEndian, p); err != nil {
			continue
		}
		if err := binary.Write(&b, binary.LittleEndian, PrivilegedEnabled); err != nil {
			continue
		}
	}

	success, err := adjustTokenPrivileges(token, false, &b.Bytes()[0], uint32(b.Len()), nil, nil)
	if !success {
		return err
	}
	if err == ErrorNotAllAsigned {
		return errors.Wrap(err, "error not all privileges were assigned")
	}

	return nil
}

// SetDebugPrivilege sets the debug privilege in the current running process.
func SetDebugPrivilege() {
	h, err := syscall.GetCurrentProcess()
	if err == nil {
		var token syscall.Token
		_ = syscall.OpenProcessToken(h, syscall.TOKEN_ADJUST_PRIVILEGES|syscall.TOKEN_QUERY, &token)
		_ = EnableTokenPrivileges(token, SeDebugPrivilege)
	}
}

```

`pkg/syscall/security/sid.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package security

import (
	"errors"
	"os"
	"syscall"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
)

var (
	advapi32 = syscall.NewLazyDLL("advapi32.dll")
	netapi32 = syscall.NewLazyDLL("netapi32.dll")

	lookupAccountSid = advapi32.NewProc("LookupAccountSidW")
	netUserEnum      = netapi32.NewProc("NetUserEnum")
	netBufferFree    = netapi32.NewProc("NetApiBufferFree")
)

const (
	userMaxPreferredLength = 0xFFFFFFFF
)

// LookupAccount returns the account and domain name from a security identifier.
func LookupAccount(buffer []byte, wbemSID bool) (string, string) {
	n := uint32(50)
	dn := uint32(50)
	if len(buffer) == 0 {
		return "", ""
	}
	sid := uintptr(unsafe.Pointer(&buffer[0]))

	if wbemSID {
		// a WBEM SID is actually a TOKEN_USER structure followed
		// by the SID, so we have to double the pointer size
		sid += uintptr(8 * 2)
	}
	var accType uint32
	for {
		b := make([]uint16, n)
		db := make([]uint16, dn)
		errno, _, _ := lookupAccountSid.Call(
			0,
			sid,
			uintptr(unsafe.Pointer(&b[0])),
			uintptr(unsafe.Pointer(&n)),
			uintptr(unsafe.Pointer(&db[0])),
			uintptr(unsafe.Pointer(&dn)),
			uintptr(unsafe.Pointer(&accType)),
			0,
			0)

		if winerrno.Errno(errno) != winerrno.Success {
			return syscall.UTF16ToString(b), syscall.UTF16ToString(db)
		}
		if winerrno.Errno(errno) != winerrno.InsufficientBuffer {
			return "", ""
		}
		if n <= uint32(len(b)) {
			return "", ""
		}
	}
}

type userInfo struct {
	name *uint16
}

// LookupAllSids returns SIDs for each user account in the system.
func LookupAllSids() ([]string, error) {
	var (
		buf    uintptr
		handle uintptr
		read   uint32
		total  uint32
	)

	errno, _, err := netUserEnum.Call(
		uintptr(0),
		uintptr(uint32(0)),
		uintptr(0),
		uintptr(unsafe.Pointer(&buf)),
		uintptr(uint32(userMaxPreferredLength)),
		uintptr(unsafe.Pointer(&read)),
		uintptr(unsafe.Pointer(&total)),
		uintptr(unsafe.Pointer(&handle)),
	)
	if winerrno.Errno(errno) != winerrno.Success {
		return nil, os.NewSyscallError("NetUserEnum", err)
	}

	if buf == uintptr(0) {
		return nil, os.NewSyscallError("NetUserEnum", errors.New("null buffer pointer"))
	}
	sids := make([]string, 0)
	entry := buf
	for i := uint32(0); i < read; i++ {
		info := (*userInfo)(unsafe.Pointer(entry))
		if info == nil {
			continue
		}
		username := syscall.UTF16ToString((*[4096]uint16)(unsafe.Pointer(info.name))[:])
		sid, _, _, err := syscall.LookupSID("", username)
		if err != nil {
			continue
		}
		s, err := sid.String()
		if err != nil {
			continue
		}
		sids = append(sids, s)
		entry = uintptr(unsafe.Pointer(entry + unsafe.Sizeof(userInfo{})))
	}
	_, _, _ = netBufferFree.Call(buf)
	return sids, nil
}

```

`pkg/syscall/sys/sys.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/object"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	"syscall"
	"unsafe"
)

var (
	native = syscall.NewLazyDLL("ntdll")

	ntQuerySystemInformation = native.NewProc("NtQuerySystemInformation")
	rtlNtStatusToDosError    = native.NewProc("RtlNtStatusToDosError")
)

// QuerySystemInformation retrieves system low-level information.
func QuerySystemInformation(class object.InformationClass, buf []byte) (uint32, error) {
	size := uint32(0)
	status, _, _ := ntQuerySystemInformation.Call(uintptr(class),
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(len(buf)),
		uintptr(unsafe.Pointer(&size)))
	if status != 0 {
		if status == winerrno.StatusInfoLengthMismatch || status == winerrno.StatusBufferTooSmall {
			return size, errors.ErrNeedsReallocateBuffer
		}
		return size, fmt.Errorf("NtQuerySystemInformation failed with status code 0x%X", status)
	}
	return size, nil
}

// CodeFromNtStatus converts the specified NTSTATUS code to its equivalent system error code.
func CodeFromNtStatus(status uint32) uint32 {
	code, _, _ := rtlNtStatusToDosError.Call(uintptr(status))
	return uint32(code)
}

```

`pkg/syscall/tdh/tdh.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tdh

import (
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/syscall/etw"
	"github.com/rabbitstack/fibratus/pkg/syscall/winerrno"
	"os"
	"syscall"
	"unsafe"
)

var (
	tdh = syscall.NewLazyDLL("tdh.dll")

	tdhGetEventInformation = tdh.NewProc("TdhGetEventInformation")
	tdhGetPropertySize     = tdh.NewProc("TdhGetPropertySize")
	tdhGetProperty         = tdh.NewProc("TdhGetProperty")
)

// GetEventInformation retrieves metadata about an event. It receives a buffer that to allocate
// `TraceEventInfo` structure.
func GetEventInformation(evt *etw.EventRecord, buffer []byte, size uint32) error {
	errno, _, err := tdhGetEventInformation.Call(
		uintptr(unsafe.Pointer(evt)),
		0,
		0,
		uintptr(unsafe.Pointer(&buffer[0])),
		uintptr(unsafe.Pointer(&size)),
	)
	switch winerrno.Errno(errno) {
	case winerrno.Success:
		return nil
	case winerrno.InsufficientBuffer:
		return kerrors.ErrInsufficentBuffer
	case winerrno.NotFound:
		return kerrors.ErrEventSchemaNotFound
	default:
		return os.NewSyscallError("TdhGetEventInformation", err)
	}
}

// GetPropertySize retrieves the size of one or more property values in the event data.
func GetPropertySize(evt *etw.EventRecord, descriptor *PropertyDataDescriptor) (uint32, error) {
	var size uint32
	errno, _, err := tdhGetPropertySize.Call(
		uintptr(unsafe.Pointer(evt)),
		0,
		0,
		1,
		uintptr(unsafe.Pointer(descriptor)),
		uintptr(unsafe.Pointer(&size)),
	)
	if winerrno.Errno(errno) != winerrno.Success {
		return uint32(0), os.NewSyscallError("TdhGetPropertySize", err)
	}
	return size, nil
}

// GetProperty retrieves a property value from the event data.
func GetProperty(evt *etw.EventRecord, descriptor *PropertyDataDescriptor, size uint32, buffer []byte) error {
	errno, _, err := tdhGetProperty.Call(
		uintptr(unsafe.Pointer(evt)),
		0,
		0,
		1,
		uintptr(unsafe.Pointer(descriptor)),
		uintptr(size),
		uintptr(unsafe.Pointer(&buffer[0])),
	)
	if winerrno.Errno(errno) != winerrno.Success {
		return os.NewSyscallError("TdhGetProperty", err)
	}
	return nil
}

```

`pkg/syscall/tdh/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tdh

import (
	"github.com/rabbitstack/fibratus/pkg/syscall/etw"
	sc "syscall"
	"unsafe"
)

const (
	// IntypeNull represents the null property type
	IntypeNull = iota
	// IntypeUnicodeString represents a string of 16-bit characters. By default, assumed to have been encoded using UTF-16LE
	IntypeUnicodeString
	// IntypeAnsiString represents a string of 8-bit characters
	IntypeAnsiString
	// IntypeInt8 represents a signed 8-bit integer
	IntypeInt8
	// IntypeUint8 represents an unsigned 8-bit integer
	IntypeUint8
	// IntypeInt16 represents a signed 16-bit integer
	IntypeInt16
	// IntypeUint16 represents an unsigned 18-bit integer
	IntypeUint16
	// IntypeInt32 represents a signed 32-bit integer
	IntypeInt32
	// IntypeUint32 represents an unsigned 8-bit integer
	IntypeUint32
	// IntypeInt64 represents a signed 64-bit integer
	IntypeInt64
	// IntypeUint64 represents an unsigned 64-bit integer
	IntypeUint64
	// IntypeFloat represents an IEEE 4-byte floating-point number
	IntypeFloat
	// IntypeDouble represents an IEEE 8-byte floating-point number
	IntypeDouble
	// IntypeBoolean a 32-bit value where 0 is false and 1 is true
	IntypeBoolean
	// IntypeBinary represents a binary data of variable size
	IntypeBinary
	// IntypeGUID is a GUID structure. On output, the GUID is rendered in the registry string form, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	IntypeGUID
	// IntypePointer represents an unsigned 32-bit or 64-bit pointer value. The size depends on the architecture of the computer logging the event
	IntypePointer
	// IntypeFiletime represents the file timestamp
	IntypeFiletime
	// IntypeSystime represents the system timestamp
	IntypeSystime
	// IntypeSID represents a security identifier (SID) structure that uniquely identifies a user or group
	IntypeSID
	// IntypeHexInt32 represents the hexadecimal representation of 32-bit integer
	IntypeHexInt32
	// IntypeHexInt64 represents the hexadecimal representation of 64-bit integer
	IntypeHexInt64
	// IntypeUnicodeChar represents the Unicode codepoint
	IntypeUnicodeChar = 306
	// IntypeAnsiChar represents the ASCII character
	IntypeAnsiChar = 307
	// IntypeSizet represents the architecture-variable size
	IntypeSizet = 308
	// IntypeHexdump represents the hexadecimal dump
	IntypeHexdump = 309
	// IntypeWbemSID represents the Web-Based Enterprise Management security identifier
	IntypeWbemSID = 310
)

const (
	// OutypeNull represents the null property type
	OutypeNull = iota
	// OutypeString represents a string value
	OutypeString
	// OutypeDatetime represents the timestamp value
	OutypeDatetime
	// OutypeByte represents a signed 8-bit value
	OutypeByte
	// OutypeUnsignedByte represents an unsigned 8-bit value
	OutypeUnsignedByte
	// OutypeShort represents a signed 16-bit value
	OutypeShort
	// OutypeUnsignedShort represents an unsigned 16-bit value
	OutypeUnsignedShort
	// OutypeInt represents a signed 32-bit value
	OutypeInt
	// OutypeUnsignedInt represents an unsigned 32-bit value
	OutypeUnsignedInt
	// OutypeLong represents a signed 64-bit value
	OutypeLong
	// OutypeUnsignedLong represents an unsigned 64-bit value
	OutypeUnsignedLong
	// OutypeFloat represents an IEEE 4-byte floating-point number
	OutypeFloat
	// OutypeDouble represents an IEEE 8-byte floating-point number
	OutypeDouble
	// OutypeBoolean a 32-bit value where 0 is false and 1 is true
	OutypeBoolean
	// OutypeGUID represents an unsigned 32-bit or 64-bit pointer value. The size depends on the architecture of the computer logging the event
	OutypeGUID
	// OutypeHexBinary represents a binary data of variable size in hexadecimal format
	OutypeHexBinary
	// OutypeHexInt8 represents the hexadecimal representation of 8-bit integer
	OutypeHexInt8
	// OutypeHexInt16 represents the hexadecimal representation of 16-bit integer
	OutypeHexInt16
	// OutypeHexInt32 represents the hexadecimal representation of 32-bit integer
	OutypeHexInt32
	// OutypeHexInt64 represents the hexadecimal representation of 64-bit integer
	OutypeHexInt64
	// OutypePID represents the process identifier
	OutypePID
	// OutypeTID represents the thread identifier
	OutypeTID
	// OutypePort represents the port
	OutypePort
	// OutypeIPv4 represents the IPv4 address
	OutypeIPv4
	// OutypeIPv6 represents the IPv6 address
	OutypeIPv6
)

// NonStructType defines if the property is contained in a structure or array.
type NonStructType struct {
	InType        uint16
	OutType       uint16
	MapNameOffset uint32
}

// EventPropertyInfo provides information about a single property of the event or filter.
type EventPropertyInfo struct {
	Flags      int32
	NameOffset uint32
	Types      [8]byte
	Count      [2]byte
	Length     [2]byte
	Reserved   [4]byte
}

// TraceEventInfo defines the information about the event.
type TraceEventInfo struct {
	ProviderGUID           sc.GUID
	EventGUID              sc.GUID
	EventDescriptor        etw.EventDescriptor
	DecodingSource         int32
	ProviderNameOffset     uint32
	LevelNameOffset        uint32
	ChannelNameOffset      uint32
	KeywordsNameOffset     uint32
	TaskNameOffset         uint32
	OpcodeNameOffset       uint32
	EventMessageOffset     uint32
	ProviderMessageOffset  uint32
	BinaryXMLOffset        uint32
	BinaryXMLSize          uint32
	EventNameOffset        [4]byte
	EventAttributeOffset   [4]byte
	PropertyCount          uint32
	TopLevelPropertyCount  uint32
	Flags                  [4]byte
	EventPropertyInfoArray [1]EventPropertyInfo
}

// PropertyDataDescriptor defines the property to retrieve.
type PropertyDataDescriptor struct {
	PropertyName unsafe.Pointer
	ArrayIndex   uint32
	Reserved     uint32
}

```

`pkg/syscall/thread/thread.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package thread

import (
	"os"
	"syscall"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	openThread      = kernel32.NewProc("OpenThread")
	createThread    = kernel32.NewProc("CreateThread")
	terminateThread = kernel32.NewProc("TerminateThread")
)

// DesiredAccess defines the type alias for thread's access modifiers
type DesiredAccess uint32

const (
	// TerminateThread is required to terminate a thread using `TerminateThread`
	TerminateThread DesiredAccess = 0x0001
	// SuspendResume is required to suspend or resume a thread
	SuspendResume DesiredAccess = 0x0002
	// GetContext is required to read the context of a thread using `GetThreadContext`
	GetContext DesiredAccess = 0x0008
	// SetContext is required to write the context of a thread
	SetContext DesiredAccess = 0x0010
	// SetInformation is required to set certain information in the thread object
	SetInformation DesiredAccess = 0x0020
	// QueryInformation is required to read certain information from the thread object
	QueryInformation DesiredAccess = 0x0040
	// SetThreadToken is required to set the impersonation token for a thread
	SetThreadToken DesiredAccess = 0x0080
	// Impersonate is required to use a thread's security information directly without calling it by using a communication mechanism that provides impersonation services
	Impersonate DesiredAccess = 0x0100
	// DirectImpersonation is required for a server thread that impersonates a client
	DirectImpersonation DesiredAccess = 0x0200
	// SetLimitedInformation is required to set certain information in the thread object
	SetLimitedInformation DesiredAccess = 0x0400
	// QueryLimitedInformation is required to get certain information from the thread objects (e.g. PID to which pertains some thread)
	QueryLimitedInformation DesiredAccess = 0x0800

	// AllAccess grants all possible access rights for a thread object
	AllAccess DesiredAccess = 0x000F0000 | 0x00100000 | 0xFFFF
)

// String returns the human-readable representation of the thread access rights.
func (access DesiredAccess) String() string {
	switch access {
	case TerminateThread:
		return "TERMINATE"
	case SuspendResume:
		return "SUSPEND_RESUME"
	case GetContext:
		return "GET_CONTEXT"
	case SetContext:
		return "SET_CONTEXT"
	case SetInformation:
		return "SET_INFORMATION"
	case QueryInformation:
		return "QUERY_INFORMATION"
	case SetThreadToken:
		return "SET_THREAD_TOKEN"
	case Impersonate:
		return "IMPERSONATE"
	case DirectImpersonation:
		return "DIRECT_IMPERSONATION"
	case SetLimitedInformation:
		return "SET_LIMITED_INFORMATION"
	case QueryLimitedInformation:
		return "QUERY_LIMITED_INFORMATION"
	case AllAccess:
		return "ALL_ACCESS"
	default:
		return "UNKNOWN"
	}
}

const maxFlags = 0x1800

// Flags returns a list of thread access right flags.
func (access DesiredAccess) Flags() []string {
	flags := make([]string, 0)
	if access == AllAccess {
		return []string{AllAccess.String()}
	}
	if (access & TerminateThread) != 0 {
		flags = append(flags, TerminateThread.String())
	}
	if (access & SuspendResume) != 0 {
		flags = append(flags, SuspendResume.String())
	}
	if (access & GetContext) != 0 {
		flags = append(flags, GetContext.String())
	}
	if (access & SetInformation) != 0 {
		flags = append(flags, SetInformation.String())
	}
	if (access & QueryInformation) != 0 {
		flags = append(flags, QueryInformation.String())
	}
	if (access & SetThreadToken) != 0 {
		flags = append(flags, SetThreadToken.String())
	}
	for mask := Impersonate; mask <= maxFlags; mask *= 2 {
		if (access & mask) != 0 {
			flags = append(flags, mask.String())
		}
	}
	return flags
}

// Open opens an existing thread object.
func Open(access DesiredAccess, inheritHandle bool, threadID uint32) (handle.Handle, error) {
	var inherit uint8
	if inheritHandle {
		inherit = 1
	} else {
		inherit = 0
	}
	h, _, err := openThread.Call(uintptr(access), uintptr(inherit), uintptr(threadID))
	if h == 0 {
		return handle.Handle(0), os.NewSyscallError("OpenThread", err)
	}
	return handle.Handle(h), nil
}

// Create creates a thread to execute within the virtual address space of the calling process.
func Create(ctx unsafe.Pointer, cb uintptr) (handle.Handle, uint32, error) {
	var threadID uint32
	h, _, err := createThread.Call(0, 0, cb, uintptr(ctx), 0, uintptr(unsafe.Pointer(&threadID)))
	if h == 0 {
		return handle.Handle(0), threadID, os.NewSyscallError("CreateThread", err)
	}
	return handle.Handle(h), threadID, nil
}

// Terminate terminates the specified thread.
func Terminate(handle handle.Handle, exitCode uint32) error {
	errno, _, err := terminateThread.Call(uintptr(handle), uintptr(exitCode))
	if errno == 0 {
		return os.NewSyscallError("TerminateThread", err)
	}
	return nil
}

```

`pkg/syscall/thread/thread_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package thread

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestDesiredAccessFlags(t *testing.T) {
	assert.Contains(t, DesiredAccess(0x1800).Flags(), "QUERY_LIMITED_INFORMATION")
}

```

`pkg/syscall/utf16/string.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utf16

import (
	"reflect"
	"syscall"
	"unicode/utf16"
	"unsafe"
)

// UnicodeString stores the size and the memory buffer of the unicode string.
type UnicodeString struct {
	Length    uint16
	MaxLength uint16
	Buffer    *uint16
}

// String returns the native string from the Unicode stream.
func (u UnicodeString) String() string {
	if u.Length == 0 {
		return ""
	}
	var s []uint16
	hdr := (*reflect.SliceHeader)(unsafe.Pointer(&s))
	hdr.Data = uintptr(unsafe.Pointer(u.Buffer))
	hdr.Len = int(u.Length / 2)
	hdr.Cap = int(u.MaxLength / 2)
	return string(utf16.Decode(s))
}

// StringToUTF16Ptr returns the pointer to UTF-8 encoded string. It will silently return
// an invalid pointer if `s` argument contains a NUL byte at any location.
func StringToUTF16Ptr(s string) *uint16 {
	var p *uint16
	p, _ = syscall.UTF16PtrFromString(s)
	return p
}

// PtrToString is like UTF16ToString, but takes *uint16
// as a parameter instead of []uint16.
func PtrToString(p unsafe.Pointer) string {
	if p == nil {
		return ""
	}
	var s []uint16
	hdr := (*reflect.SliceHeader)(unsafe.Pointer(&s))
	hdr.Data = uintptr(p)
	hdr.Cap = 1
	hdr.Len = 1
	for s[len(s)-1] != 0 {
		hdr.Cap++
		hdr.Len++
	}
	// Remove trailing NUL and decode into a Go string.
	return string(utf16.Decode(s[:len(s)-1]))
}

```

`pkg/syscall/winerrno/errors.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package winerrno

// Errno is the type alias for error codes returned by API functions
type Errno uintptr

const (
	// InvalidProcessTraceHandle designates an invalid trace handle reference
	InvalidProcessTraceHandle uint64 = 0xffffffffffffffff
	// InvalidPID indicates invalid process identifier value
	InvalidPID uint32 = 0xffffffff
	// StatusInfoLengthMismatch indicates an issue with the parameter length
	StatusInfoLengthMismatch = 0xC0000004
	// StatusBufferTooSmall indicates that the passed memory buffer doesn't have enough space to satisfy the call
	StatusBufferTooSmall = 0xC0000023
	// StatusBufferOverflow indicates that the data was too small to fit in the buffer
	StatusBufferOverflow = 0x80000005
	// Success determines successful return code
	Success Errno = 0x0
	// InvalidParameter defines that the parameter is incorrect
	InvalidParameter Errno = 0x57
	// AlreadyExists cannot create a file when that file already exists
	AlreadyExists Errno = 0xb7
	// DiskFull defines there is not enough space on the disk
	DiskFull Errno = 0x70
	// AccessDenied defines that the access is denied because of insufficient privileges
	AccessDenied Errno = 0x5
	// NoSysResources is thrown when insufficient system resources exist to complete the requested service
	NoSysResources Errno = 0x5aa
	// BadLength is given when the process issued a command but the command length is incorrect
	BadLength Errno = 0x18
	// WMIInstanceNotFound is thrown when he instance name passed was not recognized as valid by a WMI data provider
	WMIInstanceNotFound Errno = 0x1069
	// Cancelled determines the operation was canceled by the user
	Cancelled Errno = 0x4c7
	// NoAccess denotes invalid access to memory location
	NoAccess Errno = 0x3e6
	// InsufficientBuffer determines that the data area passed to a system call is too small
	InsufficientBuffer Errno = 0x7a
	// NotFound denotes that the element is not found
	NotFound Errno = 0x490
	// CtxClosePending indicates that function will stop after it has processed all real-time events in
	// its buffers (it will not receive any new events)
	CtxClosePending Errno = 0x1B5F
)

// IsNotFound returns true is the underlying error is NotFound.
func (e Errno) IsNotFound() bool {
	return e == NotFound
}

```

`pkg/util/atomic/atomic.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package atomic

import atom "sync/atomic"

// Bool provides an atomic boolean type.
type Bool struct{ u Uint32 }

// Uint32 provides an atomic uint32 type.
type Uint32 struct{ value uint32 }

func MakeBool(v bool) Bool   { return Bool{MakeUint32(btoi(v))} }
func NewBool(v bool) *Bool   { return &Bool{MakeUint32(btoi(v))} }
func (b *Bool) Load() bool   { return b.u.Load() == 1 }
func (b *Bool) Store(v bool) { b.u.Store(btoi(v)) }

func MakeUint32(v uint32) Uint32 { return Uint32{v} }
func NewUint32(v uint32) *Uint32 { return &Uint32{v} }
func (u *Uint32) Load() uint32   { return atom.LoadUint32(&u.value) }
func (u *Uint32) Store(v uint32) { atom.StoreUint32(&u.value, v) }

func btoi(b bool) uint32 {
	if b {
		return 1
	}
	return 0
}

```

`pkg/util/bytes/bytes.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bytes

import (
	"encoding/binary"
	"unsafe"
)

// NativeEndian represents the endianness of the current machine
var NativeEndian binary.ByteOrder

func init() {
	InitNativeEndian(nil)
}

// InitNativeEndian figures out the endianness of the current machine (https://stackoverflow.com/questions/51332658/any-better-way-to-check-endianness-in-go)
func InitNativeEndian(b []byte) {
	buf := [8]byte{}
	if len(b) == 8 {
		copy(buf[:], b[:8])
	} else {
		*(*uint64)(unsafe.Pointer(&buf[0])) = uint64(0x6669627261747573)
	}

	switch buf {
	case [8]byte{0x73, 0x75, 0x74, 0x61, 0x72, 0x62, 0x69, 0x66}:
		NativeEndian = binary.LittleEndian
	case [8]byte{0x66, 0x69, 0x62, 0x72, 0x61, 0x74, 0x75, 0x73}:
		NativeEndian = binary.BigEndian
	default:
		panic("could not determine native endianness")
	}
}

// ReadUint16 reads the uint16 value from the byte slice.
func ReadUint16(b []byte) uint16 {
	return NativeEndian.Uint16(b)
}

// ReadUint32 reads the uint32 value from the byte slice.
func ReadUint32(b []byte) uint32 {
	return NativeEndian.Uint32(b)
}

// ReadUint64 reads the uint64 value from the byte slice.
func ReadUint64(b []byte) uint64 {
	return NativeEndian.Uint64(b)
}

// WriteUint16 writes the provided uint16 value to byte slice.
func WriteUint16(v uint16) (b []byte) {
	b = make([]byte, 2)
	NativeEndian.PutUint16(b, v)
	return
}

// WriteUint16Buffer writes the provided uint16 value to the byte slice.
func WriteUint16Buffer(v uint16, b []byte) {
	NativeEndian.PutUint16(b, v)
}

// WriteUint32 writes the provided uint32 value to byte slice.
func WriteUint32(v uint32) (b []byte) {
	b = make([]byte, 4)
	NativeEndian.PutUint32(b, v)
	return
}

// WriteUint64 writes the provided uint64 value to byte slice.
func WriteUint64(v uint64) (b []byte) {
	b = make([]byte, 8)
	NativeEndian.PutUint64(b, v)
	return
}

```

`pkg/util/fasttemplate/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package fasttemplate implements simple and fast template library. Credits goes to: https://github.com/valyala/fasttemplate
//
// Fasttemplate is faster than text/template, strings.Replace
// and strings.Replacer.
//
// Fasttemplate ideally fits for fast and simple placeholders' substitutions.
package fasttemplate

```

`pkg/util/fasttemplate/template.go`:

```go
/*
 *	The MIT License (MIT)
 *
 *	Copyright (c) 2015 Aliaksandr Valialkin
 *  Modifications Copyright (c) 2019-2020 by Nedim Sabic
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files (the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 */

package fasttemplate

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/valyala/bytebufferpool"
	"io"
)

// Template implements simple template engine, which can be used for fast
// tags' (aka placeholders) substitution.
type Template struct {
	template string
	startTag string
	endTag   string

	texts          [][]byte
	tags           []string
	byteBufferPool bytebufferpool.Pool
}

// NewTemplate parses the given template using the given startTag and endTag
// as tag start and tag end.
//
// The returned template can be executed by concurrently running goroutines
// using Execute* methods.
func NewTemplate(template, startTag, endTag string) (*Template, error) {
	var t Template
	err := t.Reset(template, startTag, endTag)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// TagFunc can be used as a substitution value in the map passed to Execute*.
// Execute* functions pass tag (placeholder) name in 'tag' argument.
//
// TagFunc must be safe to call from concurrently running goroutines.
//
// TagFunc must write contents to w and return the number of bytes written.
type TagFunc func(w io.Writer, tag string) (int, error)

// Reset resets the template t to new one defined by
// template, startTag and endTag.
//
// Reset allows Template object re-use.
//
// Reset may be called only if no other goroutines call t methods at the moment.
func (t *Template) Reset(template, startTag, endTag string) error {
	// Keep these vars in t, so GC won't collect them and won't break
	// vars derived via unsafe*
	t.template = template
	t.startTag = startTag
	t.endTag = endTag
	t.texts = t.texts[:0]
	t.tags = t.tags[:0]

	if len(startTag) == 0 {
		return errors.New("start tag cannot be empty")
	}
	if len(endTag) == 0 {
		return errors.New("end tag cannot be empty")
	}

	s := stringToBytes(template)
	a := stringToBytes(startTag)
	b := stringToBytes(endTag)

	tagsCount := bytes.Count(s, a)
	if tagsCount == 0 {
		return nil
	}

	if tagsCount+1 > cap(t.texts) {
		t.texts = make([][]byte, 0, tagsCount+1)
	}
	if tagsCount > cap(t.tags) {
		t.tags = make([]string, 0, tagsCount)
	}

	for {
		n := bytes.Index(s, a)
		if n < 0 {
			t.texts = append(t.texts, s)
			break
		}
		t.texts = append(t.texts, s[:n])

		s = s[n+len(a):]
		n = bytes.Index(s, b)
		if n < 0 {
			return fmt.Errorf("cannot find end tag=%q in the template=%q starting from %q", endTag, template, s)
		}

		t.tags = append(t.tags, bytesToString(s[:n]))
		s = s[n+len(b):]
	}

	return nil
}

// ExecuteFunc calls f on each template tag (placeholder) occurrence.
//
// Returns the number of bytes written to w.
//
// This function is optimized for frozen templates.
// Use ExecuteFunc for constantly changing templates.
func (t *Template) ExecuteFunc(w io.Writer, f TagFunc) (int64, error) {
	var nn int64

	n := len(t.texts) - 1
	if n == -1 {
		ni, err := w.Write(stringToBytes(t.template))
		return int64(ni), err
	}

	for i := 0; i < n; i++ {
		ni, err := w.Write(t.texts[i])
		nn += int64(ni)
		if err != nil {
			return nn, err
		}

		ni, err = f(w, t.tags[i])
		nn += int64(ni)
		if err != nil {
			return nn, err
		}
	}
	ni, err := w.Write(t.texts[n])
	nn += int64(ni)
	return nn, err
}

// Execute substitutes template tags (placeholders) with the corresponding
// values from the map m and writes the result to the given writer w.
//
// Substitution map m may contain values with the following types:
//   * []byte - the fastest value type
//   * string - convenient value type
//   * TagFunc - flexible value type
//
// Returns the number of bytes written to w.
func (t *Template) Execute(w io.Writer, m map[string]interface{}) (int64, error) {
	return t.ExecuteFunc(w, func(w io.Writer, tag string) (int, error) { return stdTagFunc(w, tag, m) })
}

// ExecuteFuncString calls f on each template tag (placeholder) occurrence
// and substitutes it with the data written to TagFunc's w.
//
// Returns the resulting string.
//
// This function is optimized for frozen templates.
// Use ExecuteFuncString for constantly changing templates.
func (t *Template) ExecuteFuncString(f TagFunc) []byte {
	bb := t.byteBufferPool.Get()
	if _, err := t.ExecuteFunc(bb, f); err != nil {
		return []byte{}
	}
	s := bb.Bytes()
	bb.Reset()
	t.byteBufferPool.Put(bb)
	return s
}

// ExecuteString substitutes template tags (placeholders) with the corresponding
// values from the map m and returns the result.
//
// Substitution map m may contain values with the following types:
//   * []byte - the fastest value type
//   * string - convenient value type
//   * TagFunc - flexible value type
//
// This function is optimized for frozen templates.
// Use ExecuteString for constantly changing templates.
func (t *Template) ExecuteString(m map[string]interface{}) []byte {
	return t.ExecuteFuncString(func(w io.Writer, tag string) (int, error) { return stdTagFunc(w, tag, m) })
}

func stdTagFunc(w io.Writer, tag string, m map[string]interface{}) (int, error) {
	v := m[tag]
	if v == nil {
		return 0, nil
	}
	switch value := v.(type) {
	case []byte:
		return w.Write(value)
	case string:
		return w.Write([]byte(value))
	case TagFunc:
		return value(w, tag)
	default:
		return 0, fmt.Errorf("tag=%q contains unexpected value type=%#v. Expected []byte, string or TagFunc", tag, v)
	}
}

```

`pkg/util/fasttemplate/unsafe.go`:

```go
/*
 *	The MIT License (MIT)
 *
 *	Copyright (c) 2015 Aliaksandr Valialkin
 *  Modifications Copyright (c) 2019-2020 by Nedim Sabic
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files (the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 */

package fasttemplate

import (
	"reflect"
	"unsafe"
)

func bytesToString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

//nolint:govet
func stringToBytes(s string) []byte {
	sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
	bh := reflect.SliceHeader{
		Data: sh.Data,
		Len:  sh.Len,
		Cap:  sh.Len,
	}
	return *(*[]byte)(unsafe.Pointer(&bh))
}

```

`pkg/util/filetime/filetime.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filetime

import (
	"time"
)

// ToEpoch converts file timestamp to Unix time.
func ToEpoch(ts uint64) time.Time { return time.Unix(0, nanoseconds(ts)) }

// nanoseconds returns Filetime ft in nanoseconds
// since Epoch (00:00:00 UTC, January 1, 1970). This
// function is copied from the stdlib to avoid allocating
// the FileTime structure in the `ToEpoch` function.
func nanoseconds(ts uint64) int64 {
	// 100-nanosecond intervals since January 1, 1601
	nsec := int64(uint32(ts>>32))<<32 + int64(uint32(ts))
	// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)
	nsec -= 116444736000000000
	// convert into nanoseconds
	nsec *= 100
	return nsec
}

```

`pkg/util/hostname/hostname_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hostname

import (
	"expvar"
	"net"
	"os"
	"syscall"
	"unsafe"
)

// hostname is the current host name or FQDN
var hostname string

// hostnameErrors exposes host/fqdn resolution errors
var hostnameErrors = expvar.NewMap("hostname.errors")

const computerNamePhysicalDNSFullyQualified = 7

var (
	kernel32        = syscall.NewLazyDLL("kernel32.dll")
	getComputerName = kernel32.NewProc("GetComputerNameExW")
)

// Get returns the host name or the FQDN of the machine.
func Get() string {
	if hostname != "" {
		return hostname
	}
	var err error
	hostname, err = os.Hostname()
	if err != nil {
		hostnameErrors.Add(err.Error(), 1)
	}

	// get the Fully Qualified Domain Name (FQDN) of this machine
	maxComputerLength := 1024
	buf := make([]uint16, maxComputerLength)
	errno, _, err := getComputerName.Call(
		uintptr(computerNamePhysicalDNSFullyQualified),
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(unsafe.Pointer(&maxComputerLength)))
	if errno == 0 {
		// we couldn't get the hostname neither the FQDN
		// so we try to fetch the local IP and use as hostname
		if hostname == "" {
			ip := localIP()
			if ip != "" {
				hostname = ip
			} else {
				hostname = "unknown"
			}
		}
		hostnameErrors.Add(err.Error(), 1)
		return hostname
	}

	fqdn := syscall.UTF16ToString(buf)
	if fqdn != "" {
		hostname = fqdn
	}

	return hostname
}

// localIP returns the first non-loopback interface IP address.
func localIP() string {
	ifaces, err := net.Interfaces()
	if err != nil {
		return ""
	}
	for _, i := range ifaces {
		addrs, err := i.Addrs()
		if err != nil {
			continue
		}
		for _, addr := range addrs {
			var ip net.IP
			switch v := addr.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}
			if !ip.IsLoopback() {
				return ip.String()
			}
		}
	}
	return ""
}

```

`pkg/util/ip/ip.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ip

import (
	"net"
	"syscall"
	"unsafe"
)

var (
	nt = syscall.NewLazyDLL("ntdll.dll")

	// rtlIpv6AddressToString is the procedure for `RtlIpv6AddressToStringW` API call.
	rtlIpv6AddressToString = nt.NewProc("RtlIpv6AddressToStringW")
)

// ToIPv4 accepts an integer IP address in network byte order and returns an IP-typed address.
func ToIPv4(ip uint32) net.IP {
	return net.IPv4(byte(ip), byte(ip>>8), byte(ip>>16), byte(ip>>24))
}

// ToIPv6 converts the buffer with IPv6 address in network byte order to an IP-typed address.
func ToIPv6(buffer []byte) net.IP {
	ipv6 := make([]uint16, 46)
	if rtlIpv6AddressToString != nil {
		_, _, _ = rtlIpv6AddressToString.Call(uintptr(unsafe.Pointer(&buffer[0])), uintptr(unsafe.Pointer(&ipv6[0])))
	}
	return net.ParseIP(syscall.UTF16ToString(ipv6))
}

```

`pkg/util/ip/ip_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ip

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestToIPv4(t *testing.T) {
	ip := ToIPv4(16777343)
	assert.Equal(t, "127.0.0.1", ip.String())
}

func TestToIPv6(t *testing.T) {
	ip := ToIPv6([]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1})
	assert.Equal(t, "::1", ip.String())
}

```

`pkg/util/log/_fixtures/fibratus.log`:

```log
time="2021-08-26T16:28:10+02:00" level=info msg="fibratus initialized" source="log/logger_test.go:34"

```

`pkg/util/log/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	logLevel      = "logging.level"
	logMaxAge     = "logging.max-age"
	logMaxBackups = "logging.max-backups"
	logMaxSize    = "logging.max-size"
	logFormatter  = "logging.formatter"
	logPath       = "logging.path"
	logStdout     = "logging.log-stdout"
)

// Config contains a set of setting that control the behaviour of the logging system.
type Config struct {
	// Level specifies the minimum allowed log level.
	Level string `json:"logging.level" yaml:"logging.level"`
	// MaxAge is the maximum number of days to retain old log files based on the
	// timestamp encoded in their filename.
	MaxAge int `json:"logging.max-age" yaml:"logging.max-age"`
	// MaxBackups is the maximum number of old log files to retain.
	MaxBackups int `json:"logging.max-backups" yaml:"logging.max-backups"`
	// MaxSize is the maximum size in megabytes of the log file before it gets rotated.
	MaxSize int `json:"logging.max-size" yaml:"logging.max-size"`
	// Formatter represents the log formatter (json | text ).
	Formatter string `json:"logging.formatter" yaml:"logging.formatter"`
	// Path represents the alternative paths for storing the logs.
	Path string `json:"logging.path" yaml:"logging.path"`
	// LogStdout indicates whether log lines are written to standard output in addition to writing them
	// to log files.
	LogStdout bool `json:"logging.log-stdout" yaml:"logging.log-stdout"`
}

// InitFromViper initializes logging configuration from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Level = v.GetString(logLevel)
	c.MaxAge = v.GetInt(logMaxAge)
	c.MaxBackups = v.GetInt(logMaxBackups)
	c.MaxSize = v.GetInt(logMaxSize)
	c.Formatter = v.GetString(logFormatter)
	c.Path = v.GetString(logPath)
	c.LogStdout = v.GetBool(logStdout)
}

// AddFlags registers persistent logging flags.
func (c *Config) AddFlags(flags *pflag.FlagSet) {
	flags.String(logLevel, "info", "Specifies the minimum allowed log level")
	flags.Int(logMaxAge, 0, "Sets he maximum number of days to retain old log files based on the timestamp encoded in their filename. By default no old log files will be removed")
	flags.Int(logMaxBackups, 15, "Specifies the maximum number of old log files to retain")
	flags.Int(logMaxSize, 100, "Specifies the maximum size in megabytes of the log file before it gets rotated")
	flags.String(logFormatter, "json", "Represents the log formatter (json|text )")
	flags.String(logPath, "", "Specifies the alternative paths for storing the logs")
	flags.Bool(logStdout, false, "Indicates whether log lines are written to standard output in addition to writing them to log files")
}

```

`pkg/util/log/logger.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/log/rotate"
	fs "github.com/rifflock/lfshook"
	"github.com/sirupsen/logrus"
	"io/ioutil"
	"os"
	"path/filepath"
)

var (
	// errEmptyLogsPath contains logger setup errors
	loggerErrors = expvar.NewMap("logger.errors")
)

// InitFromConfig initializes a Logrus instance from config options.
func InitFromConfig(c Config) error {
	exe, err := os.Executable()
	var path string
	if err != nil {
		path = filepath.Join(os.Getenv("PROGRAMFILES"), "fibratus", "logs")
	} else {
		path = filepath.Join(filepath.Dir(exe), "..", "logs")
	}
	if c.Path != "" {
		path = c.Path
	}
	if path == "" {
		return errors.New("got an empty logs directory path. Please make sure Fibratus is installed properly")
	}
	_, err = os.Stat(path)
	if err != nil {
		// let's create the logs directory since it doesn't exist, even though
		// this should rarely happen because Fibratus installer already creates
		// the logs directory
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			return fmt.Errorf("unable to create the %s logs directory: %v", path, err)
		}
	}

	file := filepath.Join(path, "fibratus.log")

	// setup log formatter
	var formatter logrus.Formatter
	switch c.Formatter {
	case "json":
		formatter = &logrus.JSONFormatter{}
	case "text":
		formatter = &logrus.TextFormatter{}
	default:
		formatter = &logrus.JSONFormatter{}
	}
	logrus.SetFormatter(formatter)

	level, err := logrus.ParseLevel(c.Level)
	if err != nil {
		return err
	}
	logrus.SetLevel(level)

	// disable writing to stdout
	if !c.LogStdout {
		logrus.SetOutput(ioutil.Discard)
	}

	// initialize log rotate hook
	rhook, err := rotate.NewHook(rotate.Config{
		MaxAge:     c.MaxAge,
		MaxBackups: c.MaxBackups,
		MaxSize:    c.MaxSize,
		Level:      level,
		Formatter:  formatter,
		Filename:   file,
	})

	if err != nil {
		loggerErrors.Add(err.Error(), 1)
		// failed to initialize log rotate, so we fallback on simple log hook
		var pathMap fs.PathMap = make(map[logrus.Level]string)
		for _, lvl := range logrus.AllLevels {
			pathMap[lvl] = file
		}
		logrus.AddHook(fs.NewHook(pathMap, formatter))
		logrus.Warnf("unable to initialize rotate file hook: %v", err)
		return nil
	}
	logrus.AddHook(rhook)

	return nil
}

```

`pkg/util/log/logger_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
)

func TestInitFromConfig(t *testing.T) {
	require.Error(t, InitFromConfig(Config{}))
	require.NoError(t, InitFromConfig(Config{Path: "_fixtures", Level: "info", Formatter: "text"}))

	os.Remove("_fixtures\\fibratus.log")

	logrus.Info("fibratus initialized")

	_, err := os.Stat("_fixtures\\fibratus.log")
	require.NoError(t, err)
}

```

`pkg/util/log/rotate/rotate.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rotate

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"gopkg.in/natefinch/lumberjack.v2"
	"io"
	"runtime"
	"strings"
)

// Config is the configuration for the rotate file hook.
type Config struct {
	Filename   string
	MaxSize    int
	MaxBackups int
	MaxAge     int
	Level      logrus.Level
	Formatter  logrus.Formatter
}

// File represents the rotate file hook.
type File struct {
	config       Config
	w            io.Writer
	depth        int
	skip         int
	formatter    func(file, function string, line int) string
	skipPrefixes []string
}

// NewHook builds a new rotate file hook.
func NewHook(config Config) (logrus.Hook, error) {
	hook := File{
		config:       config,
		depth:        20,
		skip:         5,
		skipPrefixes: []string{"logrus/", "logrus@"},
		formatter: func(file, function string, line int) string {
			return fmt.Sprintf("%s:%d", file, line)
		},
	}
	hook.w = &lumberjack.Logger{
		Filename:   config.Filename,
		MaxSize:    config.MaxSize,
		MaxBackups: config.MaxBackups,
		MaxAge:     config.MaxAge,
	}
	return &hook, nil
}

// Levels determines log levels that for which the logs are written.
func (hook *File) Levels() []logrus.Level {
	return logrus.AllLevels[:hook.config.Level+1]
}

// Fire is called by logrus when it is about to write the log entry.
func (hook *File) Fire(entry *logrus.Entry) (err error) {
	modified := entry.WithField("source", hook.formatter(hook.findCaller()))
	modified.Level = entry.Level
	modified.Message = entry.Message
	b, err := hook.config.Formatter.Format(modified)
	if err != nil {
		return err
	}
	_, err = hook.w.Write(b)
	return err
}

func (hook *File) findCaller() (string, string, int) {
	var (
		pc       uintptr
		file     string
		function string
		line     int
	)
	for i := 0; i < hook.depth; i++ {
		pc, file, line = getCaller(hook.skip + i)
		if !hook.skipFile(file) {
			break
		}
	}
	if pc != 0 {
		frames := runtime.CallersFrames([]uintptr{pc})
		frame, _ := frames.Next()
		function = frame.Function
	}

	return file, function, line
}

func (hook *File) skipFile(file string) bool {
	for i := range hook.skipPrefixes {
		if strings.HasPrefix(file, hook.skipPrefixes[i]) {
			return true
		}
	}
	return false
}

func getCaller(skip int) (uintptr, string, int) {
	pc, file, line, ok := runtime.Caller(skip)
	if !ok {
		return 0, "", 0
	}

	n := 0
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			n++
			if n >= 2 {
				file = file[i+1:]
				break
			}
		}
	}

	return pc, file, line
}

```

`pkg/util/multierror/multierror.go`:

```go
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package multierror

import (
	"strings"
)

// Wrap takes a slice of errors and returns a single error that encapsulates
// those underlying errors. If the slice is nil or empty it returns nil.
// If the slice only contains a single element, that error is returned directly.
// When more than one error is wrapped, the Error() string is a concatenation
// of the Error() values of all underlying errors.
func Wrap(errs ...error) error {
	return multiError(errs).flatten()
}

// multiError bundles several errors together into a single error.
type multiError []error

// flatten returns either: nil, the only error, or the multiError instance itself
// if there are 0, 1, or more errors in the slice respectively.
func (errors multiError) flatten() error {
	switch len(errors) {
	case 0:
		return nil
	case 1:
		return errors[0]
	default:
		return errors
	}
}

// Error returns a string like "[e1, e2, ...]" where each eN is the Error() of
// each error in the slice.
func (errors multiError) Error() string {
	parts := make([]string, 0)
	for _, err := range errors {
		if err == nil {
			continue
		}
		parts = append(parts, err.Error())
	}
	return strings.Join(parts, ", ")
}

```

`pkg/util/ports/iana_ports.go`:

```go
// Copyright 2012 Google, Inc. All rights reserved.
// Borrowed from gopacket. https://github.com/google/gopacket/blob/master/layers/iana_ports.go

package ports

// Created by gen.go, don't edit manually
// Generated at 2017-10-23 09:57:28.214859163 -0600 MDT m=+1.011679290
// Fetched from "http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml"

// TCPPortNames contains the port names for all TCP ports.
var TCPPortNames = tcpPortNames

// UDPPortNames contains the port names for all UDP ports.
var UDPPortNames = udpPortNames

// SCTPPortNames contains the port names for all SCTP ports.
var SCTPPortNames = sctpPortNames

var tcpPortNames = map[uint16]string{
	1:     "tcpmux",
	2:     "compressnet",
	3:     "compressnet",
	5:     "rje",
	7:     "echo",
	9:     "discard",
	11:    "systat",
	13:    "daytime",
	17:    "qotd",
	18:    "msp",
	19:    "chargen",
	20:    "ftp-data",
	21:    "ftp",
	22:    "ssh",
	23:    "telnet",
	25:    "smtp",
	27:    "nsw-fe",
	29:    "msg-icp",
	31:    "msg-auth",
	33:    "dsp",
	37:    "time",
	38:    "rap",
	39:    "rlp",
	41:    "graphics",
	42:    "name",
	43:    "nicname",
	44:    "mpm-flags",
	45:    "mpm",
	46:    "mpm-snd",
	48:    "auditd",
	49:    "tacacs",
	50:    "re-mail-ck",
	52:    "xns-time",
	53:    "domain",
	54:    "xns-ch",
	55:    "isi-gl",
	56:    "xns-auth",
	58:    "xns-mail",
	62:    "acas",
	63:    "whoispp",
	64:    "covia",
	65:    "tacacs-ds",
	66:    "sql-net",
	67:    "bootps",
	68:    "bootpc",
	69:    "tftp",
	70:    "gopher",
	71:    "netrjs-1",
	72:    "netrjs-2",
	73:    "netrjs-3",
	74:    "netrjs-4",
	76:    "deos",
	78:    "vettcp",
	79:    "finger",
	80:    "http",
	82:    "xfer",
	83:    "mit-ml-dev",
	84:    "ctf",
	85:    "mit-ml-dev",
	86:    "mfcobol",
	88:    "kerberos",
	89:    "su-mit-tg",
	90:    "dnsix",
	91:    "mit-dov",
	92:    "npp",
	93:    "dcp",
	94:    "objcall",
	95:    "supdup",
	96:    "dixie",
	97:    "swift-rvf",
	98:    "tacnews",
	99:    "metagram",
	101:   "hostname",
	102:   "iso-tsap",
	103:   "gppitnp",
	104:   "acr-nema",
	105:   "cso",
	106:   "3com-tsmux",
	107:   "rtelnet",
	108:   "snagas",
	109:   "pop2",
	110:   "pop3",
	111:   "sunrpc",
	112:   "mcidas",
	113:   "ident",
	115:   "sftp",
	116:   "ansanotify",
	117:   "uucp-path",
	118:   "sqlserv",
	119:   "nntp",
	120:   "cfdptkt",
	121:   "erpc",
	122:   "smakynet",
	123:   "ntp",
	124:   "ansatrader",
	125:   "locus-map",
	126:   "nxedit",
	127:   "locus-con",
	128:   "gss-xlicen",
	129:   "pwdgen",
	130:   "cisco-fna",
	131:   "cisco-tna",
	132:   "cisco-sys",
	133:   "statsrv",
	134:   "ingres-net",
	135:   "epmap",
	136:   "profile",
	137:   "netbios-ns",
	138:   "netbios-dgm",
	139:   "netbios-ssn",
	140:   "emfis-data",
	141:   "emfis-cntl",
	142:   "bl-idm",
	143:   "imap",
	144:   "uma",
	145:   "uaac",
	146:   "iso-tp0",
	147:   "iso-ip",
	148:   "jargon",
	149:   "aed-512",
	150:   "sql-net",
	151:   "hems",
	152:   "bftp",
	153:   "sgmp",
	154:   "netsc-prod",
	155:   "netsc-dev",
	156:   "sqlsrv",
	157:   "knet-cmp",
	158:   "pcmail-srv",
	159:   "nss-routing",
	160:   "sgmp-traps",
	161:   "snmp",
	162:   "snmptrap",
	163:   "cmip-man",
	164:   "cmip-agent",
	165:   "xns-courier",
	166:   "s-net",
	167:   "namp",
	168:   "rsvd",
	169:   "send",
	170:   "print-srv",
	171:   "multiplex",
	172:   "cl-1",
	173:   "xyplex-mux",
	174:   "mailq",
	175:   "vmnet",
	176:   "genrad-mux",
	177:   "xdmcp",
	178:   "nextstep",
	179:   "bgp",
	180:   "ris",
	181:   "unify",
	182:   "audit",
	183:   "ocbinder",
	184:   "ocserver",
	185:   "remote-kis",
	186:   "kis",
	187:   "aci",
	188:   "mumps",
	189:   "qft",
	190:   "gacp",
	191:   "prospero",
	192:   "osu-nms",
	193:   "srmp",
	194:   "irc",
	195:   "dn6-nlm-aud",
	196:   "dn6-smm-red",
	197:   "dls",
	198:   "dls-mon",
	199:   "smux",
	200:   "src",
	201:   "at-rtmp",
	202:   "at-nbp",
	203:   "at-3",
	204:   "at-echo",
	205:   "at-5",
	206:   "at-zis",
	207:   "at-7",
	208:   "at-8",
	209:   "qmtp",
	210:   "z39-50",
	211:   "914c-g",
	212:   "anet",
	213:   "ipx",
	214:   "vmpwscs",
	215:   "softpc",
	216:   "CAIlic",
	217:   "dbase",
	218:   "mpp",
	219:   "uarps",
	220:   "imap3",
	221:   "fln-spx",
	222:   "rsh-spx",
	223:   "cdc",
	224:   "masqdialer",
	242:   "direct",
	243:   "sur-meas",
	244:   "inbusiness",
	245:   "link",
	246:   "dsp3270",
	247:   "subntbcst-tftp",
	248:   "bhfhs",
	256:   "rap",
	257:   "set",
	259:   "esro-gen",
	260:   "openport",
	261:   "nsiiops",
	262:   "arcisdms",
	263:   "hdap",
	264:   "bgmp",
	265:   "x-bone-ctl",
	266:   "sst",
	267:   "td-service",
	268:   "td-replica",
	269:   "manet",
	271:   "pt-tls",
	280:   "http-mgmt",
	281:   "personal-link",
	282:   "cableport-ax",
	283:   "rescap",
	284:   "corerjd",
	286:   "fxp",
	287:   "k-block",
	308:   "novastorbakcup",
	309:   "entrusttime",
	310:   "bhmds",
	311:   "asip-webadmin",
	312:   "vslmp",
	313:   "magenta-logic",
	314:   "opalis-robot",
	315:   "dpsi",
	316:   "decauth",
	317:   "zannet",
	318:   "pkix-timestamp",
	319:   "ptp-event",
	320:   "ptp-general",
	321:   "pip",
	322:   "rtsps",
	323:   "rpki-rtr",
	324:   "rpki-rtr-tls",
	333:   "texar",
	344:   "pdap",
	345:   "pawserv",
	346:   "zserv",
	347:   "fatserv",
	348:   "csi-sgwp",
	349:   "mftp",
	350:   "matip-type-a",
	351:   "matip-type-b",
	352:   "dtag-ste-sb",
	353:   "ndsauth",
	354:   "bh611",
	355:   "datex-asn",
	356:   "cloanto-net-1",
	357:   "bhevent",
	358:   "shrinkwrap",
	359:   "nsrmp",
	360:   "scoi2odialog",
	361:   "semantix",
	362:   "srssend",
	363:   "rsvp-tunnel",
	364:   "aurora-cmgr",
	365:   "dtk",
	366:   "odmr",
	367:   "mortgageware",
	368:   "qbikgdp",
	369:   "rpc2portmap",
	370:   "codaauth2",
	371:   "clearcase",
	372:   "ulistproc",
	373:   "legent-1",
	374:   "legent-2",
	375:   "hassle",
	376:   "nip",
	377:   "tnETOS",
	378:   "dsETOS",
	379:   "is99c",
	380:   "is99s",
	381:   "hp-collector",
	382:   "hp-managed-node",
	383:   "hp-alarm-mgr",
	384:   "arns",
	385:   "ibm-app",
	386:   "asa",
	387:   "aurp",
	388:   "unidata-ldm",
	389:   "ldap",
	390:   "uis",
	391:   "synotics-relay",
	392:   "synotics-broker",
	393:   "meta5",
	394:   "embl-ndt",
	395:   "netcp",
	396:   "netware-ip",
	397:   "mptn",
	398:   "kryptolan",
	399:   "iso-tsap-c2",
	400:   "osb-sd",
	401:   "ups",
	402:   "genie",
	403:   "decap",
	404:   "nced",
	405:   "ncld",
	406:   "imsp",
	407:   "timbuktu",
	408:   "prm-sm",
	409:   "prm-nm",
	410:   "decladebug",
	411:   "rmt",
	412:   "synoptics-trap",
	413:   "smsp",
	414:   "infoseek",
	415:   "bnet",
	416:   "silverplatter",
	417:   "onmux",
	418:   "hyper-g",
	419:   "ariel1",
	420:   "smpte",
	421:   "ariel2",
	422:   "ariel3",
	423:   "opc-job-start",
	424:   "opc-job-track",
	425:   "icad-el",
	426:   "smartsdp",
	427:   "svrloc",
	428:   "ocs-cmu",
	429:   "ocs-amu",
	430:   "utmpsd",
	431:   "utmpcd",
	432:   "iasd",
	433:   "nnsp",
	434:   "mobileip-agent",
	435:   "mobilip-mn",
	436:   "dna-cml",
	437:   "comscm",
	438:   "dsfgw",
	439:   "dasp",
	440:   "sgcp",
	441:   "decvms-sysmgt",
	442:   "cvc-hostd",
	443:   "https",
	444:   "snpp",
	445:   "microsoft-ds",
	446:   "ddm-rdb",
	447:   "ddm-dfm",
	448:   "ddm-ssl",
	449:   "as-servermap",
	450:   "tserver",
	451:   "sfs-smp-net",
	452:   "sfs-config",
	453:   "creativeserver",
	454:   "contentserver",
	455:   "creativepartnr",
	456:   "macon-tcp",
	457:   "scohelp",
	458:   "appleqtc",
	459:   "ampr-rcmd",
	460:   "skronk",
	461:   "datasurfsrv",
	462:   "datasurfsrvsec",
	463:   "alpes",
	464:   "kpasswd",
	465:   "urd",
	466:   "digital-vrc",
	467:   "mylex-mapd",
	468:   "photuris",
	469:   "rcp",
	470:   "scx-proxy",
	471:   "mondex",
	472:   "ljk-login",
	473:   "hybrid-pop",
	474:   "tn-tl-w1",
	475:   "tcpnethaspsrv",
	476:   "tn-tl-fd1",
	477:   "ss7ns",
	478:   "spsc",
	479:   "iafserver",
	480:   "iafdbase",
	481:   "ph",
	482:   "bgs-nsi",
	483:   "ulpnet",
	484:   "integra-sme",
	485:   "powerburst",
	486:   "avian",
	487:   "saft",
	488:   "gss-http",
	489:   "nest-protocol",
	490:   "micom-pfs",
	491:   "go-login",
	492:   "ticf-1",
	493:   "ticf-2",
	494:   "pov-ray",
	495:   "intecourier",
	496:   "pim-rp-disc",
	497:   "retrospect",
	498:   "siam",
	499:   "iso-ill",
	500:   "isakmp",
	501:   "stmf",
	502:   "mbap",
	503:   "intrinsa",
	504:   "citadel",
	505:   "mailbox-lm",
	506:   "ohimsrv",
	507:   "crs",
	508:   "xvttp",
	509:   "snare",
	510:   "fcp",
	511:   "passgo",
	512:   "exec",
	513:   "login",
	514:   "shell",
	515:   "printer",
	516:   "videotex",
	517:   "talk",
	518:   "ntalk",
	519:   "utime",
	520:   "efs",
	521:   "ripng",
	522:   "ulp",
	523:   "ibm-db2",
	524:   "ncp",
	525:   "timed",
	526:   "tempo",
	527:   "stx",
	528:   "custix",
	529:   "irc-serv",
	530:   "courier",
	531:   "conference",
	532:   "netnews",
	533:   "netwall",
	534:   "windream",
	535:   "iiop",
	536:   "opalis-rdv",
	537:   "nmsp",
	538:   "gdomap",
	539:   "apertus-ldp",
	540:   "uucp",
	541:   "uucp-rlogin",
	542:   "commerce",
	543:   "klogin",
	544:   "kshell",
	545:   "appleqtcsrvr",
	546:   "dhcpv6-client",
	547:   "dhcpv6-server",
	548:   "afpovertcp",
	549:   "idfp",
	550:   "new-rwho",
	551:   "cybercash",
	552:   "devshr-nts",
	553:   "pirp",
	554:   "rtsp",
	555:   "dsf",
	556:   "remotefs",
	557:   "openvms-sysipc",
	558:   "sdnskmp",
	559:   "teedtap",
	560:   "rmonitor",
	561:   "monitor",
	562:   "chshell",
	563:   "nntps",
	564:   "9pfs",
	565:   "whoami",
	566:   "streettalk",
	567:   "banyan-rpc",
	568:   "ms-shuttle",
	569:   "ms-rome",
	570:   "meter",
	571:   "meter",
	572:   "sonar",
	573:   "banyan-vip",
	574:   "ftp-agent",
	575:   "vemmi",
	576:   "ipcd",
	577:   "vnas",
	578:   "ipdd",
	579:   "decbsrv",
	580:   "sntp-heartbeat",
	581:   "bdp",
	582:   "scc-security",
	583:   "philips-vc",
	584:   "keyserver",
	586:   "password-chg",
	587:   "submission",
	588:   "cal",
	589:   "eyelink",
	590:   "tns-cml",
	591:   "http-alt",
	592:   "eudora-set",
	593:   "http-rpc-epmap",
	594:   "tpip",
	595:   "cab-protocol",
	596:   "smsd",
	597:   "ptcnameservice",
	598:   "sco-websrvrmg3",
	599:   "acp",
	600:   "ipcserver",
	601:   "syslog-conn",
	602:   "xmlrpc-beep",
	603:   "idxp",
	604:   "tunnel",
	605:   "soap-beep",
	606:   "urm",
	607:   "nqs",
	608:   "sift-uft",
	609:   "npmp-trap",
	610:   "npmp-local",
	611:   "npmp-gui",
	612:   "hmmp-ind",
	613:   "hmmp-op",
	614:   "sshell",
	615:   "sco-inetmgr",
	616:   "sco-sysmgr",
	617:   "sco-dtmgr",
	618:   "dei-icda",
	619:   "compaq-evm",
	620:   "sco-websrvrmgr",
	621:   "escp-ip",
	622:   "collaborator",
	623:   "oob-ws-http",
	624:   "cryptoadmin",
	625:   "dec-dlm",
	626:   "asia",
	627:   "passgo-tivoli",
	628:   "qmqp",
	629:   "3com-amp3",
	630:   "rda",
	631:   "ipp",
	632:   "bmpp",
	633:   "servstat",
	634:   "ginad",
	635:   "rlzdbase",
	636:   "ldaps",
	637:   "lanserver",
	638:   "mcns-sec",
	639:   "msdp",
	640:   "entrust-sps",
	641:   "repcmd",
	642:   "esro-emsdp",
	643:   "sanity",
	644:   "dwr",
	645:   "pssc",
	646:   "ldp",
	647:   "dhcp-failover",
	648:   "rrp",
	649:   "cadview-3d",
	650:   "obex",
	651:   "ieee-mms",
	652:   "hello-port",
	653:   "repscmd",
	654:   "aodv",
	655:   "tinc",
	656:   "spmp",
	657:   "rmc",
	658:   "tenfold",
	660:   "mac-srvr-admin",
	661:   "hap",
	662:   "pftp",
	663:   "purenoise",
	664:   "oob-ws-https",
	665:   "sun-dr",
	666:   "mdqs",
	667:   "disclose",
	668:   "mecomm",
	669:   "meregister",
	670:   "vacdsm-sws",
	671:   "vacdsm-app",
	672:   "vpps-qua",
	673:   "cimplex",
	674:   "acap",
	675:   "dctp",
	676:   "vpps-via",
	677:   "vpp",
	678:   "ggf-ncp",
	679:   "mrm",
	680:   "entrust-aaas",
	681:   "entrust-aams",
	682:   "xfr",
	683:   "corba-iiop",
	684:   "corba-iiop-ssl",
	685:   "mdc-portmapper",
	686:   "hcp-wismar",
	687:   "asipregistry",
	688:   "realm-rusd",
	689:   "nmap",
	690:   "vatp",
	691:   "msexch-routing",
	692:   "hyperwave-isp",
	693:   "connendp",
	694:   "ha-cluster",
	695:   "ieee-mms-ssl",
	696:   "rushd",
	697:   "uuidgen",
	698:   "olsr",
	699:   "accessnetwork",
	700:   "epp",
	701:   "lmp",
	702:   "iris-beep",
	704:   "elcsd",
	705:   "agentx",
	706:   "silc",
	707:   "borland-dsj",
	709:   "entrust-kmsh",
	710:   "entrust-ash",
	711:   "cisco-tdp",
	712:   "tbrpf",
	713:   "iris-xpc",
	714:   "iris-xpcs",
	715:   "iris-lwz",
	729:   "netviewdm1",
	730:   "netviewdm2",
	731:   "netviewdm3",
	741:   "netgw",
	742:   "netrcs",
	744:   "flexlm",
	747:   "fujitsu-dev",
	748:   "ris-cm",
	749:   "kerberos-adm",
	750:   "rfile",
	751:   "pump",
	752:   "qrh",
	753:   "rrh",
	754:   "tell",
	758:   "nlogin",
	759:   "con",
	760:   "ns",
	761:   "rxe",
	762:   "quotad",
	763:   "cycleserv",
	764:   "omserv",
	765:   "webster",
	767:   "phonebook",
	769:   "vid",
	770:   "cadlock",
	771:   "rtip",
	772:   "cycleserv2",
	773:   "submit",
	774:   "rpasswd",
	775:   "entomb",
	776:   "wpages",
	777:   "multiling-http",
	780:   "wpgs",
	800:   "mdbs-daemon",
	801:   "device",
	802:   "mbap-s",
	810:   "fcp-udp",
	828:   "itm-mcell-s",
	829:   "pkix-3-ca-ra",
	830:   "netconf-ssh",
	831:   "netconf-beep",
	832:   "netconfsoaphttp",
	833:   "netconfsoapbeep",
	847:   "dhcp-failover2",
	848:   "gdoi",
	853:   "domain-s",
	854:   "dlep",
	860:   "iscsi",
	861:   "owamp-control",
	862:   "twamp-control",
	873:   "rsync",
	886:   "iclcnet-locate",
	887:   "iclcnet-svinfo",
	888:   "accessbuilder",
	900:   "omginitialrefs",
	901:   "smpnameres",
	902:   "ideafarm-door",
	903:   "ideafarm-panic",
	910:   "kink",
	911:   "xact-backup",
	912:   "apex-mesh",
	913:   "apex-edge",
	953:   "rndc",
	989:   "ftps-data",
	990:   "ftps",
	991:   "nas",
	992:   "telnets",
	993:   "imaps",
	995:   "pop3s",
	996:   "vsinet",
	997:   "maitrd",
	998:   "busboy",
	999:   "garcon",
	1000:  "cadlock2",
	1001:  "webpush",
	1010:  "surf",
	1021:  "exp1",
	1022:  "exp2",
	1025:  "blackjack",
	1026:  "cap",
	1029:  "solid-mux",
	1033:  "netinfo-local",
	1034:  "activesync",
	1035:  "mxxrlogin",
	1036:  "nsstp",
	1037:  "ams",
	1038:  "mtqp",
	1039:  "sbl",
	1040:  "netarx",
	1041:  "danf-ak2",
	1042:  "afrog",
	1043:  "boinc-client",
	1044:  "dcutility",
	1045:  "fpitp",
	1046:  "wfremotertm",
	1047:  "neod1",
	1048:  "neod2",
	1049:  "td-postman",
	1050:  "cma",
	1051:  "optima-vnet",
	1052:  "ddt",
	1053:  "remote-as",
	1054:  "brvread",
	1055:  "ansyslmd",
	1056:  "vfo",
	1057:  "startron",
	1058:  "nim",
	1059:  "nimreg",
	1060:  "polestar",
	1061:  "kiosk",
	1062:  "veracity",
	1063:  "kyoceranetdev",
	1064:  "jstel",
	1065:  "syscomlan",
	1066:  "fpo-fns",
	1067:  "instl-boots",
	1068:  "instl-bootc",
	1069:  "cognex-insight",
	1070:  "gmrupdateserv",
	1071:  "bsquare-voip",
	1072:  "cardax",
	1073:  "bridgecontrol",
	1074:  "warmspotMgmt",
	1075:  "rdrmshc",
	1076:  "dab-sti-c",
	1077:  "imgames",
	1078:  "avocent-proxy",
	1079:  "asprovatalk",
	1080:  "socks",
	1081:  "pvuniwien",
	1082:  "amt-esd-prot",
	1083:  "ansoft-lm-1",
	1084:  "ansoft-lm-2",
	1085:  "webobjects",
	1086:  "cplscrambler-lg",
	1087:  "cplscrambler-in",
	1088:  "cplscrambler-al",
	1089:  "ff-annunc",
	1090:  "ff-fms",
	1091:  "ff-sm",
	1092:  "obrpd",
	1093:  "proofd",
	1094:  "rootd",
	1095:  "nicelink",
	1096:  "cnrprotocol",
	1097:  "sunclustermgr",
	1098:  "rmiactivation",
	1099:  "rmiregistry",
	1100:  "mctp",
	1101:  "pt2-discover",
	1102:  "adobeserver-1",
	1103:  "adobeserver-2",
	1104:  "xrl",
	1105:  "ftranhc",
	1106:  "isoipsigport-1",
	1107:  "isoipsigport-2",
	1108:  "ratio-adp",
	1110:  "webadmstart",
	1111:  "lmsocialserver",
	1112:  "icp",
	1113:  "ltp-deepspace",
	1114:  "mini-sql",
	1115:  "ardus-trns",
	1116:  "ardus-cntl",
	1117:  "ardus-mtrns",
	1118:  "sacred",
	1119:  "bnetgame",
	1120:  "bnetfile",
	1121:  "rmpp",
	1122:  "availant-mgr",
	1123:  "murray",
	1124:  "hpvmmcontrol",
	1125:  "hpvmmagent",
	1126:  "hpvmmdata",
	1127:  "kwdb-commn",
	1128:  "saphostctrl",
	1129:  "saphostctrls",
	1130:  "casp",
	1131:  "caspssl",
	1132:  "kvm-via-ip",
	1133:  "dfn",
	1134:  "aplx",
	1135:  "omnivision",
	1136:  "hhb-gateway",
	1137:  "trim",
	1138:  "encrypted-admin",
	1139:  "evm",
	1140:  "autonoc",
	1141:  "mxomss",
	1142:  "edtools",
	1143:  "imyx",
	1144:  "fuscript",
	1145:  "x9-icue",
	1146:  "audit-transfer",
	1147:  "capioverlan",
	1148:  "elfiq-repl",
	1149:  "bvtsonar",
	1150:  "blaze",
	1151:  "unizensus",
	1152:  "winpoplanmess",
	1153:  "c1222-acse",
	1154:  "resacommunity",
	1155:  "nfa",
	1156:  "iascontrol-oms",
	1157:  "iascontrol",
	1158:  "dbcontrol-oms",
	1159:  "oracle-oms",
	1160:  "olsv",
	1161:  "health-polling",
	1162:  "health-trap",
	1163:  "sddp",
	1164:  "qsm-proxy",
	1165:  "qsm-gui",
	1166:  "qsm-remote",
	1167:  "cisco-ipsla",
	1168:  "vchat",
	1169:  "tripwire",
	1170:  "atc-lm",
	1171:  "atc-appserver",
	1172:  "dnap",
	1173:  "d-cinema-rrp",
	1174:  "fnet-remote-ui",
	1175:  "dossier",
	1176:  "indigo-server",
	1177:  "dkmessenger",
	1178:  "sgi-storman",
	1179:  "b2n",
	1180:  "mc-client",
	1181:  "3comnetman",
	1182:  "accelenet",
	1183:  "llsurfup-http",
	1184:  "llsurfup-https",
	1185:  "catchpole",
	1186:  "mysql-cluster",
	1187:  "alias",
	1188:  "hp-webadmin",
	1189:  "unet",
	1190:  "commlinx-avl",
	1191:  "gpfs",
	1192:  "caids-sensor",
	1193:  "fiveacross",
	1194:  "openvpn",
	1195:  "rsf-1",
	1196:  "netmagic",
	1197:  "carrius-rshell",
	1198:  "cajo-discovery",
	1199:  "dmidi",
	1200:  "scol",
	1201:  "nucleus-sand",
	1202:  "caiccipc",
	1203:  "ssslic-mgr",
	1204:  "ssslog-mgr",
	1205:  "accord-mgc",
	1206:  "anthony-data",
	1207:  "metasage",
	1208:  "seagull-ais",
	1209:  "ipcd3",
	1210:  "eoss",
	1211:  "groove-dpp",
	1212:  "lupa",
	1213:  "mpc-lifenet",
	1214:  "kazaa",
	1215:  "scanstat-1",
	1216:  "etebac5",
	1217:  "hpss-ndapi",
	1218:  "aeroflight-ads",
	1219:  "aeroflight-ret",
	1220:  "qt-serveradmin",
	1221:  "sweetware-apps",
	1222:  "nerv",
	1223:  "tgp",
	1224:  "vpnz",
	1225:  "slinkysearch",
	1226:  "stgxfws",
	1227:  "dns2go",
	1228:  "florence",
	1229:  "zented",
	1230:  "periscope",
	1231:  "menandmice-lpm",
	1232:  "first-defense",
	1233:  "univ-appserver",
	1234:  "search-agent",
	1235:  "mosaicsyssvc1",
	1236:  "bvcontrol",
	1237:  "tsdos390",
	1238:  "hacl-qs",
	1239:  "nmsd",
	1240:  "instantia",
	1241:  "nessus",
	1242:  "nmasoverip",
	1243:  "serialgateway",
	1244:  "isbconference1",
	1245:  "isbconference2",
	1246:  "payrouter",
	1247:  "visionpyramid",
	1248:  "hermes",
	1249:  "mesavistaco",
	1250:  "swldy-sias",
	1251:  "servergraph",
	1252:  "bspne-pcc",
	1253:  "q55-pcc",
	1254:  "de-noc",
	1255:  "de-cache-query",
	1256:  "de-server",
	1257:  "shockwave2",
	1258:  "opennl",
	1259:  "opennl-voice",
	1260:  "ibm-ssd",
	1261:  "mpshrsv",
	1262:  "qnts-orb",
	1263:  "dka",
	1264:  "prat",
	1265:  "dssiapi",
	1266:  "dellpwrappks",
	1267:  "epc",
	1268:  "propel-msgsys",
	1269:  "watilapp",
	1270:  "opsmgr",
	1271:  "excw",
	1272:  "cspmlockmgr",
	1273:  "emc-gateway",
	1274:  "t1distproc",
	1275:  "ivcollector",
	1277:  "miva-mqs",
	1278:  "dellwebadmin-1",
	1279:  "dellwebadmin-2",
	1280:  "pictrography",
	1281:  "healthd",
	1282:  "emperion",
	1283:  "productinfo",
	1284:  "iee-qfx",
	1285:  "neoiface",
	1286:  "netuitive",
	1287:  "routematch",
	1288:  "navbuddy",
	1289:  "jwalkserver",
	1290:  "winjaserver",
	1291:  "seagulllms",
	1292:  "dsdn",
	1293:  "pkt-krb-ipsec",
	1294:  "cmmdriver",
	1295:  "ehtp",
	1296:  "dproxy",
	1297:  "sdproxy",
	1298:  "lpcp",
	1299:  "hp-sci",
	1300:  "h323hostcallsc",
	1301:  "ci3-software-1",
	1302:  "ci3-software-2",
	1303:  "sftsrv",
	1304:  "boomerang",
	1305:  "pe-mike",
	1306:  "re-conn-proto",
	1307:  "pacmand",
	1308:  "odsi",
	1309:  "jtag-server",
	1310:  "husky",
	1311:  "rxmon",
	1312:  "sti-envision",
	1313:  "bmc-patroldb",
	1314:  "pdps",
	1315:  "els",
	1316:  "exbit-escp",
	1317:  "vrts-ipcserver",
	1318:  "krb5gatekeeper",
	1319:  "amx-icsp",
	1320:  "amx-axbnet",
	1321:  "pip",
	1322:  "novation",
	1323:  "brcd",
	1324:  "delta-mcp",
	1325:  "dx-instrument",
	1326:  "wimsic",
	1327:  "ultrex",
	1328:  "ewall",
	1329:  "netdb-export",
	1330:  "streetperfect",
	1331:  "intersan",
	1332:  "pcia-rxp-b",
	1333:  "passwrd-policy",
	1334:  "writesrv",
	1335:  "digital-notary",
	1336:  "ischat",
	1337:  "menandmice-dns",
	1338:  "wmc-log-svc",
	1339:  "kjtsiteserver",
	1340:  "naap",
	1341:  "qubes",
	1342:  "esbroker",
	1343:  "re101",
	1344:  "icap",
	1345:  "vpjp",
	1346:  "alta-ana-lm",
	1347:  "bbn-mmc",
	1348:  "bbn-mmx",
	1349:  "sbook",
	1350:  "editbench",
	1351:  "equationbuilder",
	1352:  "lotusnote",
	1353:  "relief",
	1354:  "XSIP-network",
	1355:  "intuitive-edge",
	1356:  "cuillamartin",
	1357:  "pegboard",
	1358:  "connlcli",
	1359:  "ftsrv",
	1360:  "mimer",
	1361:  "linx",
	1362:  "timeflies",
	1363:  "ndm-requester",
	1364:  "ndm-server",
	1365:  "adapt-sna",
	1366:  "netware-csp",
	1367:  "dcs",
	1368:  "screencast",
	1369:  "gv-us",
	1370:  "us-gv",
	1371:  "fc-cli",
	1372:  "fc-ser",
	1373:  "chromagrafx",
	1374:  "molly",
	1375:  "bytex",
	1376:  "ibm-pps",
	1377:  "cichlid",
	1378:  "elan",
	1379:  "dbreporter",
	1380:  "telesis-licman",
	1381:  "apple-licman",
	1382:  "udt-os",
	1383:  "gwha",
	1384:  "os-licman",
	1385:  "atex-elmd",
	1386:  "checksum",
	1387:  "cadsi-lm",
	1388:  "objective-dbc",
	1389:  "iclpv-dm",
	1390:  "iclpv-sc",
	1391:  "iclpv-sas",
	1392:  "iclpv-pm",
	1393:  "iclpv-nls",
	1394:  "iclpv-nlc",
	1395:  "iclpv-wsm",
	1396:  "dvl-activemail",
	1397:  "audio-activmail",
	1398:  "video-activmail",
	1399:  "cadkey-licman",
	1400:  "cadkey-tablet",
	1401:  "goldleaf-licman",
	1402:  "prm-sm-np",
	1403:  "prm-nm-np",
	1404:  "igi-lm",
	1405:  "ibm-res",
	1406:  "netlabs-lm",
	1407:  "tibet-server",
	1408:  "sophia-lm",
	1409:  "here-lm",
	1410:  "hiq",
	1411:  "af",
	1412:  "innosys",
	1413:  "innosys-acl",
	1414:  "ibm-mqseries",
	1415:  "dbstar",
	1416:  "novell-lu6-2",
	1417:  "timbuktu-srv1",
	1418:  "timbuktu-srv2",
	1419:  "timbuktu-srv3",
	1420:  "timbuktu-srv4",
	1421:  "gandalf-lm",
	1422:  "autodesk-lm",
	1423:  "essbase",
	1424:  "hybrid",
	1425:  "zion-lm",
	1426:  "sais",
	1427:  "mloadd",
	1428:  "informatik-lm",
	1429:  "nms",
	1430:  "tpdu",
	1431:  "rgtp",
	1432:  "blueberry-lm",
	1433:  "ms-sql-s",
	1434:  "ms-sql-m",
	1435:  "ibm-cics",
	1436:  "saism",
	1437:  "tabula",
	1438:  "eicon-server",
	1439:  "eicon-x25",
	1440:  "eicon-slp",
	1441:  "cadis-1",
	1442:  "cadis-2",
	1443:  "ies-lm",
	1444:  "marcam-lm",
	1445:  "proxima-lm",
	1446:  "ora-lm",
	1447:  "apri-lm",
	1448:  "oc-lm",
	1449:  "peport",
	1450:  "dwf",
	1451:  "infoman",
	1452:  "gtegsc-lm",
	1453:  "genie-lm",
	1454:  "interhdl-elmd",
	1455:  "esl-lm",
	1456:  "dca",
	1457:  "valisys-lm",
	1458:  "nrcabq-lm",
	1459:  "proshare1",
	1460:  "proshare2",
	1461:  "ibm-wrless-lan",
	1462:  "world-lm",
	1463:  "nucleus",
	1464:  "msl-lmd",
	1465:  "pipes",
	1466:  "oceansoft-lm",
	1467:  "csdmbase",
	1468:  "csdm",
	1469:  "aal-lm",
	1470:  "uaiact",
	1471:  "csdmbase",
	1472:  "csdm",
	1473:  "openmath",
	1474:  "telefinder",
	1475:  "taligent-lm",
	1476:  "clvm-cfg",
	1477:  "ms-sna-server",
	1478:  "ms-sna-base",
	1479:  "dberegister",
	1480:  "pacerforum",
	1481:  "airs",
	1482:  "miteksys-lm",
	1483:  "afs",
	1484:  "confluent",
	1485:  "lansource",
	1486:  "nms-topo-serv",
	1487:  "localinfosrvr",
	1488:  "docstor",
	1489:  "dmdocbroker",
	1490:  "insitu-conf",
	1492:  "stone-design-1",
	1493:  "netmap-lm",
	1494:  "ica",
	1495:  "cvc",
	1496:  "liberty-lm",
	1497:  "rfx-lm",
	1498:  "sybase-sqlany",
	1499:  "fhc",
	1500:  "vlsi-lm",
	1501:  "saiscm",
	1502:  "shivadiscovery",
	1503:  "imtc-mcs",
	1504:  "evb-elm",
	1505:  "funkproxy",
	1506:  "utcd",
	1507:  "symplex",
	1508:  "diagmond",
	1509:  "robcad-lm",
	1510:  "mvx-lm",
	1511:  "3l-l1",
	1512:  "wins",
	1513:  "fujitsu-dtc",
	1514:  "fujitsu-dtcns",
	1515:  "ifor-protocol",
	1516:  "vpad",
	1517:  "vpac",
	1518:  "vpvd",
	1519:  "vpvc",
	1520:  "atm-zip-office",
	1521:  "ncube-lm",
	1522:  "ricardo-lm",
	1523:  "cichild-lm",
	1524:  "ingreslock",
	1525:  "orasrv",
	1526:  "pdap-np",
	1527:  "tlisrv",
	1529:  "coauthor",
	1530:  "rap-service",
	1531:  "rap-listen",
	1532:  "miroconnect",
	1533:  "virtual-places",
	1534:  "micromuse-lm",
	1535:  "ampr-info",
	1536:  "ampr-inter",
	1537:  "sdsc-lm",
	1538:  "3ds-lm",
	1539:  "intellistor-lm",
	1540:  "rds",
	1541:  "rds2",
	1542:  "gridgen-elmd",
	1543:  "simba-cs",
	1544:  "aspeclmd",
	1545:  "vistium-share",
	1546:  "abbaccuray",
	1547:  "laplink",
	1548:  "axon-lm",
	1549:  "shivahose",
	1550:  "3m-image-lm",
	1551:  "hecmtl-db",
	1552:  "pciarray",
	1553:  "sna-cs",
	1554:  "caci-lm",
	1555:  "livelan",
	1556:  "veritas-pbx",
	1557:  "arbortext-lm",
	1558:  "xingmpeg",
	1559:  "web2host",
	1560:  "asci-val",
	1561:  "facilityview",
	1562:  "pconnectmgr",
	1563:  "cadabra-lm",
	1564:  "pay-per-view",
	1565:  "winddlb",
	1566:  "corelvideo",
	1567:  "jlicelmd",
	1568:  "tsspmap",
	1569:  "ets",
	1570:  "orbixd",
	1571:  "rdb-dbs-disp",
	1572:  "chip-lm",
	1573:  "itscomm-ns",
	1574:  "mvel-lm",
	1575:  "oraclenames",
	1576:  "moldflow-lm",
	1577:  "hypercube-lm",
	1578:  "jacobus-lm",
	1579:  "ioc-sea-lm",
	1580:  "tn-tl-r1",
	1581:  "mil-2045-47001",
	1582:  "msims",
	1583:  "simbaexpress",
	1584:  "tn-tl-fd2",
	1585:  "intv",
	1586:  "ibm-abtact",
	1587:  "pra-elmd",
	1588:  "triquest-lm",
	1589:  "vqp",
	1590:  "gemini-lm",
	1591:  "ncpm-pm",
	1592:  "commonspace",
	1593:  "mainsoft-lm",
	1594:  "sixtrak",
	1595:  "radio",
	1596:  "radio-sm",
	1597:  "orbplus-iiop",
	1598:  "picknfs",
	1599:  "simbaservices",
	1600:  "issd",
	1601:  "aas",
	1602:  "inspect",
	1603:  "picodbc",
	1604:  "icabrowser",
	1605:  "slp",
	1606:  "slm-api",
	1607:  "stt",
	1608:  "smart-lm",
	1609:  "isysg-lm",
	1610:  "taurus-wh",
	1611:  "ill",
	1612:  "netbill-trans",
	1613:  "netbill-keyrep",
	1614:  "netbill-cred",
	1615:  "netbill-auth",
	1616:  "netbill-prod",
	1617:  "nimrod-agent",
	1618:  "skytelnet",
	1619:  "xs-openstorage",
	1620:  "faxportwinport",
	1621:  "softdataphone",
	1622:  "ontime",
	1623:  "jaleosnd",
	1624:  "udp-sr-port",
	1625:  "svs-omagent",
	1626:  "shockwave",
	1627:  "t128-gateway",
	1628:  "lontalk-norm",
	1629:  "lontalk-urgnt",
	1630:  "oraclenet8cman",
	1631:  "visitview",
	1632:  "pammratc",
	1633:  "pammrpc",
	1634:  "loaprobe",
	1635:  "edb-server1",
	1636:  "isdc",
	1637:  "islc",
	1638:  "ismc",
	1639:  "cert-initiator",
	1640:  "cert-responder",
	1641:  "invision",
	1642:  "isis-am",
	1643:  "isis-ambc",
	1644:  "saiseh",
	1645:  "sightline",
	1646:  "sa-msg-port",
	1647:  "rsap",
	1648:  "concurrent-lm",
	1649:  "kermit",
	1650:  "nkd",
	1651:  "shiva-confsrvr",
	1652:  "xnmp",
	1653:  "alphatech-lm",
	1654:  "stargatealerts",
	1655:  "dec-mbadmin",
	1656:  "dec-mbadmin-h",
	1657:  "fujitsu-mmpdc",
	1658:  "sixnetudr",
	1659:  "sg-lm",
	1660:  "skip-mc-gikreq",
	1661:  "netview-aix-1",
	1662:  "netview-aix-2",
	1663:  "netview-aix-3",
	1664:  "netview-aix-4",
	1665:  "netview-aix-5",
	1666:  "netview-aix-6",
	1667:  "netview-aix-7",
	1668:  "netview-aix-8",
	1669:  "netview-aix-9",
	1670:  "netview-aix-10",
	1671:  "netview-aix-11",
	1672:  "netview-aix-12",
	1673:  "proshare-mc-1",
	1674:  "proshare-mc-2",
	1675:  "pdp",
	1676:  "netcomm1",
	1677:  "groupwise",
	1678:  "prolink",
	1679:  "darcorp-lm",
	1680:  "microcom-sbp",
	1681:  "sd-elmd",
	1682:  "lanyon-lantern",
	1683:  "ncpm-hip",
	1684:  "snaresecure",
	1685:  "n2nremote",
	1686:  "cvmon",
	1687:  "nsjtp-ctrl",
	1688:  "nsjtp-data",
	1689:  "firefox",
	1690:  "ng-umds",
	1691:  "empire-empuma",
	1692:  "sstsys-lm",
	1693:  "rrirtr",
	1694:  "rrimwm",
	1695:  "rrilwm",
	1696:  "rrifmm",
	1697:  "rrisat",
	1698:  "rsvp-encap-1",
	1699:  "rsvp-encap-2",
	1700:  "mps-raft",
	1701:  "l2f",
	1702:  "deskshare",
	1703:  "hb-engine",
	1704:  "bcs-broker",
	1705:  "slingshot",
	1706:  "jetform",
	1707:  "vdmplay",
	1708:  "gat-lmd",
	1709:  "centra",
	1710:  "impera",
	1711:  "pptconference",
	1712:  "registrar",
	1713:  "conferencetalk",
	1714:  "sesi-lm",
	1715:  "houdini-lm",
	1716:  "xmsg",
	1717:  "fj-hdnet",
	1718:  "h323gatedisc",
	1719:  "h323gatestat",
	1720:  "h323hostcall",
	1721:  "caicci",
	1722:  "hks-lm",
	1723:  "pptp",
	1724:  "csbphonemaster",
	1725:  "iden-ralp",
	1726:  "iberiagames",
	1727:  "winddx",
	1728:  "telindus",
	1729:  "citynl",
	1730:  "roketz",
	1731:  "msiccp",
	1732:  "proxim",
	1733:  "siipat",
	1734:  "cambertx-lm",
	1735:  "privatechat",
	1736:  "street-stream",
	1737:  "ultimad",
	1738:  "gamegen1",
	1739:  "webaccess",
	1740:  "encore",
	1741:  "cisco-net-mgmt",
	1742:  "3Com-nsd",
	1743:  "cinegrfx-lm",
	1744:  "ncpm-ft",
	1745:  "remote-winsock",
	1746:  "ftrapid-1",
	1747:  "ftrapid-2",
	1748:  "oracle-em1",
	1749:  "aspen-services",
	1750:  "sslp",
	1751:  "swiftnet",
	1752:  "lofr-lm",
	1753:  "predatar-comms",
	1754:  "oracle-em2",
	1755:  "ms-streaming",
	1756:  "capfast-lmd",
	1757:  "cnhrp",
	1758:  "tftp-mcast",
	1759:  "spss-lm",
	1760:  "www-ldap-gw",
	1761:  "cft-0",
	1762:  "cft-1",
	1763:  "cft-2",
	1764:  "cft-3",
	1765:  "cft-4",
	1766:  "cft-5",
	1767:  "cft-6",
	1768:  "cft-7",
	1769:  "bmc-net-adm",
	1770:  "bmc-net-svc",
	1771:  "vaultbase",
	1772:  "essweb-gw",
	1773:  "kmscontrol",
	1774:  "global-dtserv",
	1775:  "vdab",
	1776:  "femis",
	1777:  "powerguardian",
	1778:  "prodigy-intrnet",
	1779:  "pharmasoft",
	1780:  "dpkeyserv",
	1781:  "answersoft-lm",
	1782:  "hp-hcip",
	1784:  "finle-lm",
	1785:  "windlm",
	1786:  "funk-logger",
	1787:  "funk-license",
	1788:  "psmond",
	1789:  "hello",
	1790:  "nmsp",
	1791:  "ea1",
	1792:  "ibm-dt-2",
	1793:  "rsc-robot",
	1794:  "cera-bcm",
	1795:  "dpi-proxy",
	1796:  "vocaltec-admin",
	1797:  "uma",
	1798:  "etp",
	1799:  "netrisk",
	1800:  "ansys-lm",
	1801:  "msmq",
	1802:  "concomp1",
	1803:  "hp-hcip-gwy",
	1804:  "enl",
	1805:  "enl-name",
	1806:  "musiconline",
	1807:  "fhsp",
	1808:  "oracle-vp2",
	1809:  "oracle-vp1",
	1810:  "jerand-lm",
	1811:  "scientia-sdb",
	1812:  "radius",
	1813:  "radius-acct",
	1814:  "tdp-suite",
	1815:  "mmpft",
	1816:  "harp",
	1817:  "rkb-oscs",
	1818:  "etftp",
	1819:  "plato-lm",
	1820:  "mcagent",
	1821:  "donnyworld",
	1822:  "es-elmd",
	1823:  "unisys-lm",
	1824:  "metrics-pas",
	1825:  "direcpc-video",
	1826:  "ardt",
	1827:  "asi",
	1828:  "itm-mcell-u",
	1829:  "optika-emedia",
	1830:  "net8-cman",
	1831:  "myrtle",
	1832:  "tht-treasure",
	1833:  "udpradio",
	1834:  "ardusuni",
	1835:  "ardusmul",
	1836:  "ste-smsc",
	1837:  "csoft1",
	1838:  "talnet",
	1839:  "netopia-vo1",
	1840:  "netopia-vo2",
	1841:  "netopia-vo3",
	1842:  "netopia-vo4",
	1843:  "netopia-vo5",
	1844:  "direcpc-dll",
	1845:  "altalink",
	1846:  "tunstall-pnc",
	1847:  "slp-notify",
	1848:  "fjdocdist",
	1849:  "alpha-sms",
	1850:  "gsi",
	1851:  "ctcd",
	1852:  "virtual-time",
	1853:  "vids-avtp",
	1854:  "buddy-draw",
	1855:  "fiorano-rtrsvc",
	1856:  "fiorano-msgsvc",
	1857:  "datacaptor",
	1858:  "privateark",
	1859:  "gammafetchsvr",
	1860:  "sunscalar-svc",
	1861:  "lecroy-vicp",
	1862:  "mysql-cm-agent",
	1863:  "msnp",
	1864:  "paradym-31port",
	1865:  "entp",
	1866:  "swrmi",
	1867:  "udrive",
	1868:  "viziblebrowser",
	1869:  "transact",
	1870:  "sunscalar-dns",
	1871:  "canocentral0",
	1872:  "canocentral1",
	1873:  "fjmpjps",
	1874:  "fjswapsnp",
	1875:  "westell-stats",
	1876:  "ewcappsrv",
	1877:  "hp-webqosdb",
	1878:  "drmsmc",
	1879:  "nettgain-nms",
	1880:  "vsat-control",
	1881:  "ibm-mqseries2",
	1882:  "ecsqdmn",
	1883:  "mqtt",
	1884:  "idmaps",
	1885:  "vrtstrapserver",
	1886:  "leoip",
	1887:  "filex-lport",
	1888:  "ncconfig",
	1889:  "unify-adapter",
	1890:  "wilkenlistener",
	1891:  "childkey-notif",
	1892:  "childkey-ctrl",
	1893:  "elad",
	1894:  "o2server-port",
	1896:  "b-novative-ls",
	1897:  "metaagent",
	1898:  "cymtec-port",
	1899:  "mc2studios",
	1900:  "ssdp",
	1901:  "fjicl-tep-a",
	1902:  "fjicl-tep-b",
	1903:  "linkname",
	1904:  "fjicl-tep-c",
	1905:  "sugp",
	1906:  "tpmd",
	1907:  "intrastar",
	1908:  "dawn",
	1909:  "global-wlink",
	1910:  "ultrabac",
	1911:  "mtp",
	1912:  "rhp-iibp",
	1913:  "armadp",
	1914:  "elm-momentum",
	1915:  "facelink",
	1916:  "persona",
	1917:  "noagent",
	1918:  "can-nds",
	1919:  "can-dch",
	1920:  "can-ferret",
	1921:  "noadmin",
	1922:  "tapestry",
	1923:  "spice",
	1924:  "xiip",
	1925:  "discovery-port",
	1926:  "egs",
	1927:  "videte-cipc",
	1928:  "emsd-port",
	1929:  "bandwiz-system",
	1930:  "driveappserver",
	1931:  "amdsched",
	1932:  "ctt-broker",
	1933:  "xmapi",
	1934:  "xaapi",
	1935:  "macromedia-fcs",
	1936:  "jetcmeserver",
	1937:  "jwserver",
	1938:  "jwclient",
	1939:  "jvserver",
	1940:  "jvclient",
	1941:  "dic-aida",
	1942:  "res",
	1943:  "beeyond-media",
	1944:  "close-combat",
	1945:  "dialogic-elmd",
	1946:  "tekpls",
	1947:  "sentinelsrm",
	1948:  "eye2eye",
	1949:  "ismaeasdaqlive",
	1950:  "ismaeasdaqtest",
	1951:  "bcs-lmserver",
	1952:  "mpnjsc",
	1953:  "rapidbase",
	1954:  "abr-api",
	1955:  "abr-secure",
	1956:  "vrtl-vmf-ds",
	1957:  "unix-status",
	1958:  "dxadmind",
	1959:  "simp-all",
	1960:  "nasmanager",
	1961:  "bts-appserver",
	1962:  "biap-mp",
	1963:  "webmachine",
	1964:  "solid-e-engine",
	1965:  "tivoli-npm",
	1966:  "slush",
	1967:  "sns-quote",
	1968:  "lipsinc",
	1969:  "lipsinc1",
	1970:  "netop-rc",
	1971:  "netop-school",
	1972:  "intersys-cache",
	1973:  "dlsrap",
	1974:  "drp",
	1975:  "tcoflashagent",
	1976:  "tcoregagent",
	1977:  "tcoaddressbook",
	1978:  "unisql",
	1979:  "unisql-java",
	1980:  "pearldoc-xact",
	1981:  "p2pq",
	1982:  "estamp",
	1983:  "lhtp",
	1984:  "bb",
	1985:  "hsrp",
	1986:  "licensedaemon",
	1987:  "tr-rsrb-p1",
	1988:  "tr-rsrb-p2",
	1989:  "tr-rsrb-p3",
	1990:  "stun-p1",
	1991:  "stun-p2",
	1992:  "stun-p3",
	1993:  "snmp-tcp-port",
	1994:  "stun-port",
	1995:  "perf-port",
	1996:  "tr-rsrb-port",
	1997:  "gdp-port",
	1998:  "x25-svc-port",
	1999:  "tcp-id-port",
	2000:  "cisco-sccp",
	2001:  "dc",
	2002:  "globe",
	2003:  "brutus",
	2004:  "mailbox",
	2005:  "berknet",
	2006:  "invokator",
	2007:  "dectalk",
	2008:  "conf",
	2009:  "news",
	2010:  "search",
	2011:  "raid-cc",
	2012:  "ttyinfo",
	2013:  "raid-am",
	2014:  "troff",
	2015:  "cypress",
	2016:  "bootserver",
	2017:  "cypress-stat",
	2018:  "terminaldb",
	2019:  "whosockami",
	2020:  "xinupageserver",
	2021:  "servexec",
	2022:  "down",
	2023:  "xinuexpansion3",
	2024:  "xinuexpansion4",
	2025:  "ellpack",
	2026:  "scrabble",
	2027:  "shadowserver",
	2028:  "submitserver",
	2029:  "hsrpv6",
	2030:  "device2",
	2031:  "mobrien-chat",
	2032:  "blackboard",
	2033:  "glogger",
	2034:  "scoremgr",
	2035:  "imsldoc",
	2036:  "e-dpnet",
	2037:  "applus",
	2038:  "objectmanager",
	2039:  "prizma",
	2040:  "lam",
	2041:  "interbase",
	2042:  "isis",
	2043:  "isis-bcast",
	2044:  "rimsl",
	2045:  "cdfunc",
	2046:  "sdfunc",
	2047:  "dls",
	2048:  "dls-monitor",
	2049:  "shilp",
	2050:  "av-emb-config",
	2051:  "epnsdp",
	2052:  "clearvisn",
	2053:  "lot105-ds-upd",
	2054:  "weblogin",
	2055:  "iop",
	2056:  "omnisky",
	2057:  "rich-cp",
	2058:  "newwavesearch",
	2059:  "bmc-messaging",
	2060:  "teleniumdaemon",
	2061:  "netmount",
	2062:  "icg-swp",
	2063:  "icg-bridge",
	2064:  "icg-iprelay",
	2065:  "dlsrpn",
	2066:  "aura",
	2067:  "dlswpn",
	2068:  "avauthsrvprtcl",
	2069:  "event-port",
	2070:  "ah-esp-encap",
	2071:  "acp-port",
	2072:  "msync",
	2073:  "gxs-data-port",
	2074:  "vrtl-vmf-sa",
	2075:  "newlixengine",
	2076:  "newlixconfig",
	2077:  "tsrmagt",
	2078:  "tpcsrvr",
	2079:  "idware-router",
	2080:  "autodesk-nlm",
	2081:  "kme-trap-port",
	2082:  "infowave",
	2083:  "radsec",
	2084:  "sunclustergeo",
	2085:  "ada-cip",
	2086:  "gnunet",
	2087:  "eli",
	2088:  "ip-blf",
	2089:  "sep",
	2090:  "lrp",
	2091:  "prp",
	2092:  "descent3",
	2093:  "nbx-cc",
	2094:  "nbx-au",
	2095:  "nbx-ser",
	2096:  "nbx-dir",
	2097:  "jetformpreview",
	2098:  "dialog-port",
	2099:  "h2250-annex-g",
	2100:  "amiganetfs",
	2101:  "rtcm-sc104",
	2102:  "zephyr-srv",
	2103:  "zephyr-clt",
	2104:  "zephyr-hm",
	2105:  "minipay",
	2106:  "mzap",
	2107:  "bintec-admin",
	2108:  "comcam",
	2109:  "ergolight",
	2110:  "umsp",
	2111:  "dsatp",
	2112:  "idonix-metanet",
	2113:  "hsl-storm",
	2114:  "newheights",
	2115:  "kdm",
	2116:  "ccowcmr",
	2117:  "mentaclient",
	2118:  "mentaserver",
	2119:  "gsigatekeeper",
	2120:  "qencp",
	2121:  "scientia-ssdb",
	2122:  "caupc-remote",
	2123:  "gtp-control",
	2124:  "elatelink",
	2125:  "lockstep",
	2126:  "pktcable-cops",
	2127:  "index-pc-wb",
	2128:  "net-steward",
	2129:  "cs-live",
	2130:  "xds",
	2131:  "avantageb2b",
	2132:  "solera-epmap",
	2133:  "zymed-zpp",
	2134:  "avenue",
	2135:  "gris",
	2136:  "appworxsrv",
	2137:  "connect",
	2138:  "unbind-cluster",
	2139:  "ias-auth",
	2140:  "ias-reg",
	2141:  "ias-admind",
	2142:  "tdmoip",
	2143:  "lv-jc",
	2144:  "lv-ffx",
	2145:  "lv-pici",
	2146:  "lv-not",
	2147:  "lv-auth",
	2148:  "veritas-ucl",
	2149:  "acptsys",
	2150:  "dynamic3d",
	2151:  "docent",
	2152:  "gtp-user",
	2153:  "ctlptc",
	2154:  "stdptc",
	2155:  "brdptc",
	2156:  "trp",
	2157:  "xnds",
	2158:  "touchnetplus",
	2159:  "gdbremote",
	2160:  "apc-2160",
	2161:  "apc-2161",
	2162:  "navisphere",
	2163:  "navisphere-sec",
	2164:  "ddns-v3",
	2165:  "x-bone-api",
	2166:  "iwserver",
	2167:  "raw-serial",
	2168:  "easy-soft-mux",
	2169:  "brain",
	2170:  "eyetv",
	2171:  "msfw-storage",
	2172:  "msfw-s-storage",
	2173:  "msfw-replica",
	2174:  "msfw-array",
	2175:  "airsync",
	2176:  "rapi",
	2177:  "qwave",
	2178:  "bitspeer",
	2179:  "vmrdp",
	2180:  "mc-gt-srv",
	2181:  "eforward",
	2182:  "cgn-stat",
	2183:  "cgn-config",
	2184:  "nvd",
	2185:  "onbase-dds",
	2186:  "gtaua",
	2187:  "ssmc",
	2188:  "radware-rpm",
	2189:  "radware-rpm-s",
	2190:  "tivoconnect",
	2191:  "tvbus",
	2192:  "asdis",
	2193:  "drwcs",
	2197:  "mnp-exchange",
	2198:  "onehome-remote",
	2199:  "onehome-help",
	2200:  "ici",
	2201:  "ats",
	2202:  "imtc-map",
	2203:  "b2-runtime",
	2204:  "b2-license",
	2205:  "jps",
	2206:  "hpocbus",
	2207:  "hpssd",
	2208:  "hpiod",
	2209:  "rimf-ps",
	2210:  "noaaport",
	2211:  "emwin",
	2212:  "leecoposserver",
	2213:  "kali",
	2214:  "rpi",
	2215:  "ipcore",
	2216:  "vtu-comms",
	2217:  "gotodevice",
	2218:  "bounzza",
	2219:  "netiq-ncap",
	2220:  "netiq",
	2221:  "ethernet-ip-s",
	2222:  "EtherNet-IP-1",
	2223:  "rockwell-csp2",
	2224:  "efi-mg",
	2225:  "rcip-itu",
	2226:  "di-drm",
	2227:  "di-msg",
	2228:  "ehome-ms",
	2229:  "datalens",
	2230:  "queueadm",
	2231:  "wimaxasncp",
	2232:  "ivs-video",
	2233:  "infocrypt",
	2234:  "directplay",
	2235:  "sercomm-wlink",
	2236:  "nani",
	2237:  "optech-port1-lm",
	2238:  "aviva-sna",
	2239:  "imagequery",
	2240:  "recipe",
	2241:  "ivsd",
	2242:  "foliocorp",
	2243:  "magicom",
	2244:  "nmsserver",
	2245:  "hao",
	2246:  "pc-mta-addrmap",
	2247:  "antidotemgrsvr",
	2248:  "ums",
	2249:  "rfmp",
	2250:  "remote-collab",
	2251:  "dif-port",
	2252:  "njenet-ssl",
	2253:  "dtv-chan-req",
	2254:  "seispoc",
	2255:  "vrtp",
	2256:  "pcc-mfp",
	2257:  "simple-tx-rx",
	2258:  "rcts",
	2260:  "apc-2260",
	2261:  "comotionmaster",
	2262:  "comotionback",
	2263:  "ecwcfg",
	2264:  "apx500api-1",
	2265:  "apx500api-2",
	2266:  "mfserver",
	2267:  "ontobroker",
	2268:  "amt",
	2269:  "mikey",
	2270:  "starschool",
	2271:  "mmcals",
	2272:  "mmcal",
	2273:  "mysql-im",
	2274:  "pcttunnell",
	2275:  "ibridge-data",
	2276:  "ibridge-mgmt",
	2277:  "bluectrlproxy",
	2278:  "s3db",
	2279:  "xmquery",
	2280:  "lnvpoller",
	2281:  "lnvconsole",
	2282:  "lnvalarm",
	2283:  "lnvstatus",
	2284:  "lnvmaps",
	2285:  "lnvmailmon",
	2286:  "nas-metering",
	2287:  "dna",
	2288:  "netml",
	2289:  "dict-lookup",
	2290:  "sonus-logging",
	2291:  "eapsp",
	2292:  "mib-streaming",
	2293:  "npdbgmngr",
	2294:  "konshus-lm",
	2295:  "advant-lm",
	2296:  "theta-lm",
	2297:  "d2k-datamover1",
	2298:  "d2k-datamover2",
	2299:  "pc-telecommute",
	2300:  "cvmmon",
	2301:  "cpq-wbem",
	2302:  "binderysupport",
	2303:  "proxy-gateway",
	2304:  "attachmate-uts",
	2305:  "mt-scaleserver",
	2306:  "tappi-boxnet",
	2307:  "pehelp",
	2308:  "sdhelp",
	2309:  "sdserver",
	2310:  "sdclient",
	2311:  "messageservice",
	2312:  "wanscaler",
	2313:  "iapp",
	2314:  "cr-websystems",
	2315:  "precise-sft",
	2316:  "sent-lm",
	2317:  "attachmate-g32",
	2318:  "cadencecontrol",
	2319:  "infolibria",
	2320:  "siebel-ns",
	2321:  "rdlap",
	2322:  "ofsd",
	2323:  "3d-nfsd",
	2324:  "cosmocall",
	2325:  "ansysli",
	2326:  "idcp",
	2327:  "xingcsm",
	2328:  "netrix-sftm",
	2329:  "nvd",
	2330:  "tscchat",
	2331:  "agentview",
	2332:  "rcc-host",
	2333:  "snapp",
	2334:  "ace-client",
	2335:  "ace-proxy",
	2336:  "appleugcontrol",
	2337:  "ideesrv",
	2338:  "norton-lambert",
	2339:  "3com-webview",
	2340:  "wrs-registry",
	2341:  "xiostatus",
	2342:  "manage-exec",
	2343:  "nati-logos",
	2344:  "fcmsys",
	2345:  "dbm",
	2346:  "redstorm-join",
	2347:  "redstorm-find",
	2348:  "redstorm-info",
	2349:  "redstorm-diag",
	2350:  "psbserver",
	2351:  "psrserver",
	2352:  "pslserver",
	2353:  "pspserver",
	2354:  "psprserver",
	2355:  "psdbserver",
	2356:  "gxtelmd",
	2357:  "unihub-server",
	2358:  "futrix",
	2359:  "flukeserver",
	2360:  "nexstorindltd",
	2361:  "tl1",
	2362:  "digiman",
	2363:  "mediacntrlnfsd",
	2364:  "oi-2000",
	2365:  "dbref",
	2366:  "qip-login",
	2367:  "service-ctrl",
	2368:  "opentable",
	2370:  "l3-hbmon",
	2371:  "hp-rda",
	2372:  "lanmessenger",
	2373:  "remographlm",
	2374:  "hydra",
	2375:  "docker",
	2376:  "docker-s",
	2377:  "swarm",
	2379:  "etcd-client",
	2380:  "etcd-server",
	2381:  "compaq-https",
	2382:  "ms-olap3",
	2383:  "ms-olap4",
	2384:  "sd-request",
	2385:  "sd-data",
	2386:  "virtualtape",
	2387:  "vsamredirector",
	2388:  "mynahautostart",
	2389:  "ovsessionmgr",
	2390:  "rsmtp",
	2391:  "3com-net-mgmt",
	2392:  "tacticalauth",
	2393:  "ms-olap1",
	2394:  "ms-olap2",
	2395:  "lan900-remote",
	2396:  "wusage",
	2397:  "ncl",
	2398:  "orbiter",
	2399:  "fmpro-fdal",
	2400:  "opequus-server",
	2401:  "cvspserver",
	2402:  "taskmaster2000",
	2403:  "taskmaster2000",
	2404:  "iec-104",
	2405:  "trc-netpoll",
	2406:  "jediserver",
	2407:  "orion",
	2408:  "railgun-webaccl",
	2409:  "sns-protocol",
	2410:  "vrts-registry",
	2411:  "netwave-ap-mgmt",
	2412:  "cdn",
	2413:  "orion-rmi-reg",
	2414:  "beeyond",
	2415:  "codima-rtp",
	2416:  "rmtserver",
	2417:  "composit-server",
	2418:  "cas",
	2419:  "attachmate-s2s",
	2420:  "dslremote-mgmt",
	2421:  "g-talk",
	2422:  "crmsbits",
	2423:  "rnrp",
	2424:  "kofax-svr",
	2425:  "fjitsuappmgr",
	2426:  "vcmp",
	2427:  "mgcp-gateway",
	2428:  "ott",
	2429:  "ft-role",
	2430:  "venus",
	2431:  "venus-se",
	2432:  "codasrv",
	2433:  "codasrv-se",
	2434:  "pxc-epmap",
	2435:  "optilogic",
	2436:  "topx",
	2437:  "unicontrol",
	2438:  "msp",
	2439:  "sybasedbsynch",
	2440:  "spearway",
	2441:  "pvsw-inet",
	2442:  "netangel",
	2443:  "powerclientcsf",
	2444:  "btpp2sectrans",
	2445:  "dtn1",
	2446:  "bues-service",
	2447:  "ovwdb",
	2448:  "hpppssvr",
	2449:  "ratl",
	2450:  "netadmin",
	2451:  "netchat",
	2452:  "snifferclient",
	2453:  "madge-ltd",
	2454:  "indx-dds",
	2455:  "wago-io-system",
	2456:  "altav-remmgt",
	2457:  "rapido-ip",
	2458:  "griffin",
	2459:  "community",
	2460:  "ms-theater",
	2461:  "qadmifoper",
	2462:  "qadmifevent",
	2463:  "lsi-raid-mgmt",
	2464:  "direcpc-si",
	2465:  "lbm",
	2466:  "lbf",
	2467:  "high-criteria",
	2468:  "qip-msgd",
	2469:  "mti-tcs-comm",
	2470:  "taskman-port",
	2471:  "seaodbc",
	2472:  "c3",
	2473:  "aker-cdp",
	2474:  "vitalanalysis",
	2475:  "ace-server",
	2476:  "ace-svr-prop",
	2477:  "ssm-cvs",
	2478:  "ssm-cssps",
	2479:  "ssm-els",
	2480:  "powerexchange",
	2481:  "giop",
	2482:  "giop-ssl",
	2483:  "ttc",
	2484:  "ttc-ssl",
	2485:  "netobjects1",
	2486:  "netobjects2",
	2487:  "pns",
	2488:  "moy-corp",
	2489:  "tsilb",
	2490:  "qip-qdhcp",
	2491:  "conclave-cpp",
	2492:  "groove",
	2493:  "talarian-mqs",
	2494:  "bmc-ar",
	2495:  "fast-rem-serv",
	2496:  "dirgis",
	2497:  "quaddb",
	2498:  "odn-castraq",
	2499:  "unicontrol",
	2500:  "rtsserv",
	2501:  "rtsclient",
	2502:  "kentrox-prot",
	2503:  "nms-dpnss",
	2504:  "wlbs",
	2505:  "ppcontrol",
	2506:  "jbroker",
	2507:  "spock",
	2508:  "jdatastore",
	2509:  "fjmpss",
	2510:  "fjappmgrbulk",
	2511:  "metastorm",
	2512:  "citrixima",
	2513:  "citrixadmin",
	2514:  "facsys-ntp",
	2515:  "facsys-router",
	2516:  "maincontrol",
	2517:  "call-sig-trans",
	2518:  "willy",
	2519:  "globmsgsvc",
	2520:  "pvsw",
	2521:  "adaptecmgr",
	2522:  "windb",
	2523:  "qke-llc-v3",
	2524:  "optiwave-lm",
	2525:  "ms-v-worlds",
	2526:  "ema-sent-lm",
	2527:  "iqserver",
	2528:  "ncr-ccl",
	2529:  "utsftp",
	2530:  "vrcommerce",
	2531:  "ito-e-gui",
	2532:  "ovtopmd",
	2533:  "snifferserver",
	2534:  "combox-web-acc",
	2535:  "madcap",
	2536:  "btpp2audctr1",
	2537:  "upgrade",
	2538:  "vnwk-prapi",
	2539:  "vsiadmin",
	2540:  "lonworks",
	2541:  "lonworks2",
	2542:  "udrawgraph",
	2543:  "reftek",
	2544:  "novell-zen",
	2545:  "sis-emt",
	2546:  "vytalvaultbrtp",
	2547:  "vytalvaultvsmp",
	2548:  "vytalvaultpipe",
	2549:  "ipass",
	2550:  "ads",
	2551:  "isg-uda-server",
	2552:  "call-logging",
	2553:  "efidiningport",
	2554:  "vcnet-link-v10",
	2555:  "compaq-wcp",
	2556:  "nicetec-nmsvc",
	2557:  "nicetec-mgmt",
	2558:  "pclemultimedia",
	2559:  "lstp",
	2560:  "labrat",
	2561:  "mosaixcc",
	2562:  "delibo",
	2563:  "cti-redwood",
	2564:  "hp-3000-telnet",
	2565:  "coord-svr",
	2566:  "pcs-pcw",
	2567:  "clp",
	2568:  "spamtrap",
	2569:  "sonuscallsig",
	2570:  "hs-port",
	2571:  "cecsvc",
	2572:  "ibp",
	2573:  "trustestablish",
	2574:  "blockade-bpsp",
	2575:  "hl7",
	2576:  "tclprodebugger",
	2577:  "scipticslsrvr",
	2578:  "rvs-isdn-dcp",
	2579:  "mpfoncl",
	2580:  "tributary",
	2581:  "argis-te",
	2582:  "argis-ds",
	2583:  "mon",
	2584:  "cyaserv",
	2585:  "netx-server",
	2586:  "netx-agent",
	2587:  "masc",
	2588:  "privilege",
	2589:  "quartus-tcl",
	2590:  "idotdist",
	2591:  "maytagshuffle",
	2592:  "netrek",
	2593:  "mns-mail",
	2594:  "dts",
	2595:  "worldfusion1",
	2596:  "worldfusion2",
	2597:  "homesteadglory",
	2598:  "citriximaclient",
	2599:  "snapd",
	2600:  "hpstgmgr",
	2601:  "discp-client",
	2602:  "discp-server",
	2603:  "servicemeter",
	2604:  "nsc-ccs",
	2605:  "nsc-posa",
	2606:  "netmon",
	2607:  "connection",
	2608:  "wag-service",
	2609:  "system-monitor",
	2610:  "versa-tek",
	2611:  "lionhead",
	2612:  "qpasa-agent",
	2613:  "smntubootstrap",
	2614:  "neveroffline",
	2615:  "firepower",
	2616:  "appswitch-emp",
	2617:  "cmadmin",
	2618:  "priority-e-com",
	2619:  "bruce",
	2620:  "lpsrecommender",
	2621:  "miles-apart",
	2622:  "metricadbc",
	2623:  "lmdp",
	2624:  "aria",
	2625:  "blwnkl-port",
	2626:  "gbjd816",
	2627:  "moshebeeri",
	2628:  "dict",
	2629:  "sitaraserver",
	2630:  "sitaramgmt",
	2631:  "sitaradir",
	2632:  "irdg-post",
	2633:  "interintelli",
	2634:  "pk-electronics",
	2635:  "backburner",
	2636:  "solve",
	2637:  "imdocsvc",
	2638:  "sybaseanywhere",
	2639:  "aminet",
	2640:  "ami-control",
	2641:  "hdl-srv",
	2642:  "tragic",
	2643:  "gte-samp",
	2644:  "travsoft-ipx-t",
	2645:  "novell-ipx-cmd",
	2646:  "and-lm",
	2647:  "syncserver",
	2648:  "upsnotifyprot",
	2649:  "vpsipport",
	2650:  "eristwoguns",
	2651:  "ebinsite",
	2652:  "interpathpanel",
	2653:  "sonus",
	2654:  "corel-vncadmin",
	2655:  "unglue",
	2656:  "kana",
	2657:  "sns-dispatcher",
	2658:  "sns-admin",
	2659:  "sns-query",
	2660:  "gcmonitor",
	2661:  "olhost",
	2662:  "bintec-capi",
	2663:  "bintec-tapi",
	2664:  "patrol-mq-gm",
	2665:  "patrol-mq-nm",
	2666:  "extensis",
	2667:  "alarm-clock-s",
	2668:  "alarm-clock-c",
	2669:  "toad",
	2670:  "tve-announce",
	2671:  "newlixreg",
	2672:  "nhserver",
	2673:  "firstcall42",
	2674:  "ewnn",
	2675:  "ttc-etap",
	2676:  "simslink",
	2677:  "gadgetgate1way",
	2678:  "gadgetgate2way",
	2679:  "syncserverssl",
	2680:  "pxc-sapxom",
	2681:  "mpnjsomb",
	2683:  "ncdloadbalance",
	2684:  "mpnjsosv",
	2685:  "mpnjsocl",
	2686:  "mpnjsomg",
	2687:  "pq-lic-mgmt",
	2688:  "md-cg-http",
	2689:  "fastlynx",
	2690:  "hp-nnm-data",
	2691:  "itinternet",
	2692:  "admins-lms",
	2694:  "pwrsevent",
	2695:  "vspread",
	2696:  "unifyadmin",
	2697:  "oce-snmp-trap",
	2698:  "mck-ivpip",
	2699:  "csoft-plusclnt",
	2700:  "tqdata",
	2701:  "sms-rcinfo",
	2702:  "sms-xfer",
	2703:  "sms-chat",
	2704:  "sms-remctrl",
	2705:  "sds-admin",
	2706:  "ncdmirroring",
	2707:  "emcsymapiport",
	2708:  "banyan-net",
	2709:  "supermon",
	2710:  "sso-service",
	2711:  "sso-control",
	2712:  "aocp",
	2713:  "raventbs",
	2714:  "raventdm",
	2715:  "hpstgmgr2",
	2716:  "inova-ip-disco",
	2717:  "pn-requester",
	2718:  "pn-requester2",
	2719:  "scan-change",
	2720:  "wkars",
	2721:  "smart-diagnose",
	2722:  "proactivesrvr",
	2723:  "watchdog-nt",
	2724:  "qotps",
	2725:  "msolap-ptp2",
	2726:  "tams",
	2727:  "mgcp-callagent",
	2728:  "sqdr",
	2729:  "tcim-control",
	2730:  "nec-raidplus",
	2731:  "fyre-messanger",
	2732:  "g5m",
	2733:  "signet-ctf",
	2734:  "ccs-software",
	2735:  "netiq-mc",
	2736:  "radwiz-nms-srv",
	2737:  "srp-feedback",
	2738:  "ndl-tcp-ois-gw",
	2739:  "tn-timing",
	2740:  "alarm",
	2741:  "tsb",
	2742:  "tsb2",
	2743:  "murx",
	2744:  "honyaku",
	2745:  "urbisnet",
	2746:  "cpudpencap",
	2747:  "fjippol-swrly",
	2748:  "fjippol-polsvr",
	2749:  "fjippol-cnsl",
	2750:  "fjippol-port1",
	2751:  "fjippol-port2",
	2752:  "rsisysaccess",
	2753:  "de-spot",
	2754:  "apollo-cc",
	2755:  "expresspay",
	2756:  "simplement-tie",
	2757:  "cnrp",
	2758:  "apollo-status",
	2759:  "apollo-gms",
	2760:  "sabams",
	2761:  "dicom-iscl",
	2762:  "dicom-tls",
	2763:  "desktop-dna",
	2764:  "data-insurance",
	2765:  "qip-audup",
	2766:  "compaq-scp",
	2767:  "uadtc",
	2768:  "uacs",
	2769:  "exce",
	2770:  "veronica",
	2771:  "vergencecm",
	2772:  "auris",
	2773:  "rbakcup1",
	2774:  "rbakcup2",
	2775:  "smpp",
	2776:  "ridgeway1",
	2777:  "ridgeway2",
	2778:  "gwen-sonya",
	2779:  "lbc-sync",
	2780:  "lbc-control",
	2781:  "whosells",
	2782:  "everydayrc",
	2783:  "aises",
	2784:  "www-dev",
	2785:  "aic-np",
	2786:  "aic-oncrpc",
	2787:  "piccolo",
	2788:  "fryeserv",
	2789:  "media-agent",
	2790:  "plgproxy",
	2791:  "mtport-regist",
	2792:  "f5-globalsite",
	2793:  "initlsmsad",
	2795:  "livestats",
	2796:  "ac-tech",
	2797:  "esp-encap",
	2798:  "tmesis-upshot",
	2799:  "icon-discover",
	2800:  "acc-raid",
	2801:  "igcp",
	2802:  "veritas-tcp1",
	2803:  "btprjctrl",
	2804:  "dvr-esm",
	2805:  "wta-wsp-s",
	2806:  "cspuni",
	2807:  "cspmulti",
	2808:  "j-lan-p",
	2809:  "corbaloc",
	2810:  "netsteward",
	2811:  "gsiftp",
	2812:  "atmtcp",
	2813:  "llm-pass",
	2814:  "llm-csv",
	2815:  "lbc-measure",
	2816:  "lbc-watchdog",
	2817:  "nmsigport",
	2818:  "rmlnk",
	2819:  "fc-faultnotify",
	2820:  "univision",
	2821:  "vrts-at-port",
	2822:  "ka0wuc",
	2823:  "cqg-netlan",
	2824:  "cqg-netlan-1",
	2826:  "slc-systemlog",
	2827:  "slc-ctrlrloops",
	2828:  "itm-lm",
	2829:  "silkp1",
	2830:  "silkp2",
	2831:  "silkp3",
	2832:  "silkp4",
	2833:  "glishd",
	2834:  "evtp",
	2835:  "evtp-data",
	2836:  "catalyst",
	2837:  "repliweb",
	2838:  "starbot",
	2839:  "nmsigport",
	2840:  "l3-exprt",
	2841:  "l3-ranger",
	2842:  "l3-hawk",
	2843:  "pdnet",
	2844:  "bpcp-poll",
	2845:  "bpcp-trap",
	2846:  "aimpp-hello",
	2847:  "aimpp-port-req",
	2848:  "amt-blc-port",
	2849:  "fxp",
	2850:  "metaconsole",
	2851:  "webemshttp",
	2852:  "bears-01",
	2853:  "ispipes",
	2854:  "infomover",
	2855:  "msrp",
	2856:  "cesdinv",
	2857:  "simctlp",
	2858:  "ecnp",
	2859:  "activememory",
	2860:  "dialpad-voice1",
	2861:  "dialpad-voice2",
	2862:  "ttg-protocol",
	2863:  "sonardata",
	2864:  "astromed-main",
	2865:  "pit-vpn",
	2866:  "iwlistener",
	2867:  "esps-portal",
	2868:  "npep-messaging",
	2869:  "icslap",
	2870:  "daishi",
	2871:  "msi-selectplay",
	2872:  "radix",
	2874:  "dxmessagebase1",
	2875:  "dxmessagebase2",
	2876:  "sps-tunnel",
	2877:  "bluelance",
	2878:  "aap",
	2879:  "ucentric-ds",
	2880:  "synapse",
	2881:  "ndsp",
	2882:  "ndtp",
	2883:  "ndnp",
	2884:  "flashmsg",
	2885:  "topflow",
	2886:  "responselogic",
	2887:  "aironetddp",
	2888:  "spcsdlobby",
	2889:  "rsom",
	2890:  "cspclmulti",
	2891:  "cinegrfx-elmd",
	2892:  "snifferdata",
	2893:  "vseconnector",
	2894:  "abacus-remote",
	2895:  "natuslink",
	2896:  "ecovisiong6-1",
	2897:  "citrix-rtmp",
	2898:  "appliance-cfg",
	2899:  "powergemplus",
	2900:  "quicksuite",
	2901:  "allstorcns",
	2902:  "netaspi",
	2903:  "suitcase",
	2904:  "m2ua",
	2905:  "m3ua",
	2906:  "caller9",
	2907:  "webmethods-b2b",
	2908:  "mao",
	2909:  "funk-dialout",
	2910:  "tdaccess",
	2911:  "blockade",
	2912:  "epicon",
	2913:  "boosterware",
	2914:  "gamelobby",
	2915:  "tksocket",
	2916:  "elvin-server",
	2917:  "elvin-client",
	2918:  "kastenchasepad",
	2919:  "roboer",
	2920:  "roboeda",
	2921:  "cesdcdman",
	2922:  "cesdcdtrn",
	2923:  "wta-wsp-wtp-s",
	2924:  "precise-vip",
	2926:  "mobile-file-dl",
	2927:  "unimobilectrl",
	2928:  "redstone-cpss",
	2929:  "amx-webadmin",
	2930:  "amx-weblinx",
	2931:  "circle-x",
	2932:  "incp",
	2933:  "4-tieropmgw",
	2934:  "4-tieropmcli",
	2935:  "qtp",
	2936:  "otpatch",
	2937:  "pnaconsult-lm",
	2938:  "sm-pas-1",
	2939:  "sm-pas-2",
	2940:  "sm-pas-3",
	2941:  "sm-pas-4",
	2942:  "sm-pas-5",
	2943:  "ttnrepository",
	2944:  "megaco-h248",
	2945:  "h248-binary",
	2946:  "fjsvmpor",
	2947:  "gpsd",
	2948:  "wap-push",
	2949:  "wap-pushsecure",
	2950:  "esip",
	2951:  "ottp",
	2952:  "mpfwsas",
	2953:  "ovalarmsrv",
	2954:  "ovalarmsrv-cmd",
	2955:  "csnotify",
	2956:  "ovrimosdbman",
	2957:  "jmact5",
	2958:  "jmact6",
	2959:  "rmopagt",
	2960:  "dfoxserver",
	2961:  "boldsoft-lm",
	2962:  "iph-policy-cli",
	2963:  "iph-policy-adm",
	2964:  "bullant-srap",
	2965:  "bullant-rap",
	2966:  "idp-infotrieve",
	2967:  "ssc-agent",
	2968:  "enpp",
	2969:  "essp",
	2970:  "index-net",
	2971:  "netclip",
	2972:  "pmsm-webrctl",
	2973:  "svnetworks",
	2974:  "signal",
	2975:  "fjmpcm",
	2976:  "cns-srv-port",
	2977:  "ttc-etap-ns",
	2978:  "ttc-etap-ds",
	2979:  "h263-video",
	2980:  "wimd",
	2981:  "mylxamport",
	2982:  "iwb-whiteboard",
	2983:  "netplan",
	2984:  "hpidsadmin",
	2985:  "hpidsagent",
	2986:  "stonefalls",
	2987:  "identify",
	2988:  "hippad",
	2989:  "zarkov",
	2990:  "boscap",
	2991:  "wkstn-mon",
	2992:  "avenyo",
	2993:  "veritas-vis1",
	2994:  "veritas-vis2",
	2995:  "idrs",
	2996:  "vsixml",
	2997:  "rebol",
	2998:  "realsecure",
	2999:  "remoteware-un",
	3000:  "hbci",
	3001:  "origo-native",
	3002:  "exlm-agent",
	3003:  "cgms",
	3004:  "csoftragent",
	3005:  "geniuslm",
	3006:  "ii-admin",
	3007:  "lotusmtap",
	3008:  "midnight-tech",
	3009:  "pxc-ntfy",
	3010:  "gw",
	3011:  "trusted-web",
	3012:  "twsdss",
	3013:  "gilatskysurfer",
	3014:  "broker-service",
	3015:  "nati-dstp",
	3016:  "notify-srvr",
	3017:  "event-listener",
	3018:  "srvc-registry",
	3019:  "resource-mgr",
	3020:  "cifs",
	3021:  "agriserver",
	3022:  "csregagent",
	3023:  "magicnotes",
	3024:  "nds-sso",
	3025:  "arepa-raft",
	3026:  "agri-gateway",
	3027:  "LiebDevMgmt-C",
	3028:  "LiebDevMgmt-DM",
	3029:  "LiebDevMgmt-A",
	3030:  "arepa-cas",
	3031:  "eppc",
	3032:  "redwood-chat",
	3033:  "pdb",
	3034:  "osmosis-aeea",
	3035:  "fjsv-gssagt",
	3036:  "hagel-dump",
	3037:  "hp-san-mgmt",
	3038:  "santak-ups",
	3039:  "cogitate",
	3040:  "tomato-springs",
	3041:  "di-traceware",
	3042:  "journee",
	3043:  "brp",
	3044:  "epp",
	3045:  "responsenet",
	3046:  "di-ase",
	3047:  "hlserver",
	3048:  "pctrader",
	3049:  "nsws",
	3050:  "gds-db",
	3051:  "galaxy-server",
	3052:  "apc-3052",
	3053:  "dsom-server",
	3054:  "amt-cnf-prot",
	3055:  "policyserver",
	3056:  "cdl-server",
	3057:  "goahead-fldup",
	3058:  "videobeans",
	3059:  "qsoft",
	3060:  "interserver",
	3061:  "cautcpd",
	3062:  "ncacn-ip-tcp",
	3063:  "ncadg-ip-udp",
	3064:  "rprt",
	3065:  "slinterbase",
	3066:  "netattachsdmp",
	3067:  "fjhpjp",
	3068:  "ls3bcast",
	3069:  "ls3",
	3070:  "mgxswitch",
	3071:  "xplat-replicate",
	3072:  "csd-monitor",
	3073:  "vcrp",
	3074:  "xbox",
	3075:  "orbix-locator",
	3076:  "orbix-config",
	3077:  "orbix-loc-ssl",
	3078:  "orbix-cfg-ssl",
	3079:  "lv-frontpanel",
	3080:  "stm-pproc",
	3081:  "tl1-lv",
	3082:  "tl1-raw",
	3083:  "tl1-telnet",
	3084:  "itm-mccs",
	3085:  "pcihreq",
	3086:  "jdl-dbkitchen",
	3087:  "asoki-sma",
	3088:  "xdtp",
	3089:  "ptk-alink",
	3090:  "stss",
	3091:  "1ci-smcs",
	3093:  "rapidmq-center",
	3094:  "rapidmq-reg",
	3095:  "panasas",
	3096:  "ndl-aps",
	3098:  "umm-port",
	3099:  "chmd",
	3100:  "opcon-xps",
	3101:  "hp-pxpib",
	3102:  "slslavemon",
	3103:  "autocuesmi",
	3104:  "autocuelog",
	3105:  "cardbox",
	3106:  "cardbox-http",
	3107:  "business",
	3108:  "geolocate",
	3109:  "personnel",
	3110:  "sim-control",
	3111:  "wsynch",
	3112:  "ksysguard",
	3113:  "cs-auth-svr",
	3114:  "ccmad",
	3115:  "mctet-master",
	3116:  "mctet-gateway",
	3117:  "mctet-jserv",
	3118:  "pkagent",
	3119:  "d2000kernel",
	3120:  "d2000webserver",
	3121:  "pcmk-remote",
	3122:  "vtr-emulator",
	3123:  "edix",
	3124:  "beacon-port",
	3125:  "a13-an",
	3127:  "ctx-bridge",
	3128:  "ndl-aas",
	3129:  "netport-id",
	3130:  "icpv2",
	3131:  "netbookmark",
	3132:  "ms-rule-engine",
	3133:  "prism-deploy",
	3134:  "ecp",
	3135:  "peerbook-port",
	3136:  "grubd",
	3137:  "rtnt-1",
	3138:  "rtnt-2",
	3139:  "incognitorv",
	3140:  "ariliamulti",
	3141:  "vmodem",
	3142:  "rdc-wh-eos",
	3143:  "seaview",
	3144:  "tarantella",
	3145:  "csi-lfap",
	3146:  "bears-02",
	3147:  "rfio",
	3148:  "nm-game-admin",
	3149:  "nm-game-server",
	3150:  "nm-asses-admin",
	3151:  "nm-assessor",
	3152:  "feitianrockey",
	3153:  "s8-client-port",
	3154:  "ccmrmi",
	3155:  "jpegmpeg",
	3156:  "indura",
	3157:  "e3consultants",
	3158:  "stvp",
	3159:  "navegaweb-port",
	3160:  "tip-app-server",
	3161:  "doc1lm",
	3162:  "sflm",
	3163:  "res-sap",
	3164:  "imprs",
	3165:  "newgenpay",
	3166:  "sossecollector",
	3167:  "nowcontact",
	3168:  "poweronnud",
	3169:  "serverview-as",
	3170:  "serverview-asn",
	3171:  "serverview-gf",
	3172:  "serverview-rm",
	3173:  "serverview-icc",
	3174:  "armi-server",
	3175:  "t1-e1-over-ip",
	3176:  "ars-master",
	3177:  "phonex-port",
	3178:  "radclientport",
	3179:  "h2gf-w-2m",
	3180:  "mc-brk-srv",
	3181:  "bmcpatrolagent",
	3182:  "bmcpatrolrnvu",
	3183:  "cops-tls",
	3184:  "apogeex-port",
	3185:  "smpppd",
	3186:  "iiw-port",
	3187:  "odi-port",
	3188:  "brcm-comm-port",
	3189:  "pcle-infex",
	3190:  "csvr-proxy",
	3191:  "csvr-sslproxy",
	3192:  "firemonrcc",
	3193:  "spandataport",
	3194:  "magbind",
	3195:  "ncu-1",
	3196:  "ncu-2",
	3197:  "embrace-dp-s",
	3198:  "embrace-dp-c",
	3199:  "dmod-workspace",
	3200:  "tick-port",
	3201:  "cpq-tasksmart",
	3202:  "intraintra",
	3203:  "netwatcher-mon",
	3204:  "netwatcher-db",
	3205:  "isns",
	3206:  "ironmail",
	3207:  "vx-auth-port",
	3208:  "pfu-prcallback",
	3209:  "netwkpathengine",
	3210:  "flamenco-proxy",
	3211:  "avsecuremgmt",
	3212:  "surveyinst",
	3213:  "neon24x7",
	3214:  "jmq-daemon-1",
	3215:  "jmq-daemon-2",
	3216:  "ferrari-foam",
	3217:  "unite",
	3218:  "smartpackets",
	3219:  "wms-messenger",
	3220:  "xnm-ssl",
	3221:  "xnm-clear-text",
	3222:  "glbp",
	3223:  "digivote",
	3224:  "aes-discovery",
	3225:  "fcip-port",
	3226:  "isi-irp",
	3227:  "dwnmshttp",
	3228:  "dwmsgserver",
	3229:  "global-cd-port",
	3230:  "sftdst-port",
	3231:  "vidigo",
	3232:  "mdtp",
	3233:  "whisker",
	3234:  "alchemy",
	3235:  "mdap-port",
	3236:  "apparenet-ts",
	3237:  "apparenet-tps",
	3238:  "apparenet-as",
	3239:  "apparenet-ui",
	3240:  "triomotion",
	3241:  "sysorb",
	3242:  "sdp-id-port",
	3243:  "timelot",
	3244:  "onesaf",
	3245:  "vieo-fe",
	3246:  "dvt-system",
	3247:  "dvt-data",
	3248:  "procos-lm",
	3249:  "ssp",
	3250:  "hicp",
	3251:  "sysscanner",
	3252:  "dhe",
	3253:  "pda-data",
	3254:  "pda-sys",
	3255:  "semaphore",
	3256:  "cpqrpm-agent",
	3257:  "cpqrpm-server",
	3258:  "ivecon-port",
	3259:  "epncdp2",
	3260:  "iscsi-target",
	3261:  "winshadow",
	3262:  "necp",
	3263:  "ecolor-imager",
	3264:  "ccmail",
	3265:  "altav-tunnel",
	3266:  "ns-cfg-server",
	3267:  "ibm-dial-out",
	3268:  "msft-gc",
	3269:  "msft-gc-ssl",
	3270:  "verismart",
	3271:  "csoft-prev",
	3272:  "user-manager",
	3273:  "sxmp",
	3274:  "ordinox-server",
	3275:  "samd",
	3276:  "maxim-asics",
	3277:  "awg-proxy",
	3278:  "lkcmserver",
	3279:  "admind",
	3280:  "vs-server",
	3281:  "sysopt",
	3282:  "datusorb",
	3283:  "Apple Remote Desktop (Net Assistant)",
	3284:  "4talk",
	3285:  "plato",
	3286:  "e-net",
	3287:  "directvdata",
	3288:  "cops",
	3289:  "enpc",
	3290:  "caps-lm",
	3291:  "sah-lm",
	3292:  "cart-o-rama",
	3293:  "fg-fps",
	3294:  "fg-gip",
	3295:  "dyniplookup",
	3296:  "rib-slm",
	3297:  "cytel-lm",
	3298:  "deskview",
	3299:  "pdrncs",
	3300:  "ceph",
	3302:  "mcs-fastmail",
	3303:  "opsession-clnt",
	3304:  "opsession-srvr",
	3305:  "odette-ftp",
	3306:  "mysql",
	3307:  "opsession-prxy",
	3308:  "tns-server",
	3309:  "tns-adv",
	3310:  "dyna-access",
	3311:  "mcns-tel-ret",
	3312:  "appman-server",
	3313:  "uorb",
	3314:  "uohost",
	3315:  "cdid",
	3316:  "aicc-cmi",
	3317:  "vsaiport",
	3318:  "ssrip",
	3319:  "sdt-lmd",
	3320:  "officelink2000",
	3321:  "vnsstr",
	3326:  "sftu",
	3327:  "bbars",
	3328:  "egptlm",
	3329:  "hp-device-disc",
	3330:  "mcs-calypsoicf",
	3331:  "mcs-messaging",
	3332:  "mcs-mailsvr",
	3333:  "dec-notes",
	3334:  "directv-web",
	3335:  "directv-soft",
	3336:  "directv-tick",
	3337:  "directv-catlg",
	3338:  "anet-b",
	3339:  "anet-l",
	3340:  "anet-m",
	3341:  "anet-h",
	3342:  "webtie",
	3343:  "ms-cluster-net",
	3344:  "bnt-manager",
	3345:  "influence",
	3346:  "trnsprntproxy",
	3347:  "phoenix-rpc",
	3348:  "pangolin-laser",
	3349:  "chevinservices",
	3350:  "findviatv",
	3351:  "btrieve",
	3352:  "ssql",
	3353:  "fatpipe",
	3354:  "suitjd",
	3355:  "ordinox-dbase",
	3356:  "upnotifyps",
	3357:  "adtech-test",
	3358:  "mpsysrmsvr",
	3359:  "wg-netforce",
	3360:  "kv-server",
	3361:  "kv-agent",
	3362:  "dj-ilm",
	3363:  "nati-vi-server",
	3364:  "creativeserver",
	3365:  "contentserver",
	3366:  "creativepartnr",
	3372:  "tip2",
	3373:  "lavenir-lm",
	3374:  "cluster-disc",
	3375:  "vsnm-agent",
	3376:  "cdbroker",
	3377:  "cogsys-lm",
	3378:  "wsicopy",
	3379:  "socorfs",
	3380:  "sns-channels",
	3381:  "geneous",
	3382:  "fujitsu-neat",
	3383:  "esp-lm",
	3384:  "hp-clic",
	3385:  "qnxnetman",
	3386:  "gprs-data",
	3387:  "backroomnet",
	3388:  "cbserver",
	3389:  "ms-wbt-server",
	3390:  "dsc",
	3391:  "savant",
	3392:  "efi-lm",
	3393:  "d2k-tapestry1",
	3394:  "d2k-tapestry2",
	3395:  "dyna-lm",
	3396:  "printer-agent",
	3397:  "cloanto-lm",
	3398:  "mercantile",
	3399:  "csms",
	3400:  "csms2",
	3401:  "filecast",
	3402:  "fxaengine-net",
	3405:  "nokia-ann-ch1",
	3406:  "nokia-ann-ch2",
	3407:  "ldap-admin",
	3408:  "BESApi",
	3409:  "networklens",
	3410:  "networklenss",
	3411:  "biolink-auth",
	3412:  "xmlblaster",
	3413:  "svnet",
	3414:  "wip-port",
	3415:  "bcinameservice",
	3416:  "commandport",
	3417:  "csvr",
	3418:  "rnmap",
	3419:  "softaudit",
	3420:  "ifcp-port",
	3421:  "bmap",
	3422:  "rusb-sys-port",
	3423:  "xtrm",
	3424:  "xtrms",
	3425:  "agps-port",
	3426:  "arkivio",
	3427:  "websphere-snmp",
	3428:  "twcss",
	3429:  "gcsp",
	3430:  "ssdispatch",
	3431:  "ndl-als",
	3432:  "osdcp",
	3433:  "opnet-smp",
	3434:  "opencm",
	3435:  "pacom",
	3436:  "gc-config",
	3437:  "autocueds",
	3438:  "spiral-admin",
	3439:  "hri-port",
	3440:  "ans-console",
	3441:  "connect-client",
	3442:  "connect-server",
	3443:  "ov-nnm-websrv",
	3444:  "denali-server",
	3445:  "monp",
	3446:  "3comfaxrpc",
	3447:  "directnet",
	3448:  "dnc-port",
	3449:  "hotu-chat",
	3450:  "castorproxy",
	3451:  "asam",
	3452:  "sabp-signal",
	3453:  "pscupd",
	3454:  "mira",
	3455:  "prsvp",
	3456:  "vat",
	3457:  "vat-control",
	3458:  "d3winosfi",
	3459:  "integral",
	3460:  "edm-manager",
	3461:  "edm-stager",
	3462:  "edm-std-notify",
	3463:  "edm-adm-notify",
	3464:  "edm-mgr-sync",
	3465:  "edm-mgr-cntrl",
	3466:  "workflow",
	3467:  "rcst",
	3468:  "ttcmremotectrl",
	3469:  "pluribus",
	3470:  "jt400",
	3471:  "jt400-ssl",
	3472:  "jaugsremotec-1",
	3473:  "jaugsremotec-2",
	3474:  "ttntspauto",
	3475:  "genisar-port",
	3476:  "nppmp",
	3477:  "ecomm",
	3478:  "stun",
	3479:  "twrpc",
	3480:  "plethora",
	3481:  "cleanerliverc",
	3482:  "vulture",
	3483:  "slim-devices",
	3484:  "gbs-stp",
	3485:  "celatalk",
	3486:  "ifsf-hb-port",
	3487:  "ltctcp",
	3488:  "fs-rh-srv",
	3489:  "dtp-dia",
	3490:  "colubris",
	3491:  "swr-port",
	3492:  "tvdumtray-port",
	3493:  "nut",
	3494:  "ibm3494",
	3495:  "seclayer-tcp",
	3496:  "seclayer-tls",
	3497:  "ipether232port",
	3498:  "dashpas-port",
	3499:  "sccip-media",
	3500:  "rtmp-port",
	3501:  "isoft-p2p",
	3502:  "avinstalldisc",
	3503:  "lsp-ping",
	3504:  "ironstorm",
	3505:  "ccmcomm",
	3506:  "apc-3506",
	3507:  "nesh-broker",
	3508:  "interactionweb",
	3509:  "vt-ssl",
	3510:  "xss-port",
	3511:  "webmail-2",
	3512:  "aztec",
	3513:  "arcpd",
	3514:  "must-p2p",
	3515:  "must-backplane",
	3516:  "smartcard-port",
	3517:  "802-11-iapp",
	3518:  "artifact-msg",
	3519:  "nvmsgd",
	3520:  "galileolog",
	3521:  "mc3ss",
	3522:  "nssocketport",
	3523:  "odeumservlink",
	3524:  "ecmport",
	3525:  "eisport",
	3526:  "starquiz-port",
	3527:  "beserver-msg-q",
	3528:  "jboss-iiop",
	3529:  "jboss-iiop-ssl",
	3530:  "gf",
	3531:  "joltid",
	3532:  "raven-rmp",
	3533:  "raven-rdp",
	3534:  "urld-port",
	3535:  "ms-la",
	3536:  "snac",
	3537:  "ni-visa-remote",
	3538:  "ibm-diradm",
	3539:  "ibm-diradm-ssl",
	3540:  "pnrp-port",
	3541:  "voispeed-port",
	3542:  "hacl-monitor",
	3543:  "qftest-lookup",
	3544:  "teredo",
	3545:  "camac",
	3547:  "symantec-sim",
	3548:  "interworld",
	3549:  "tellumat-nms",
	3550:  "ssmpp",
	3551:  "apcupsd",
	3552:  "taserver",
	3553:  "rbr-discovery",
	3554:  "questnotify",
	3555:  "razor",
	3556:  "sky-transport",
	3557:  "personalos-001",
	3558:  "mcp-port",
	3559:  "cctv-port",
	3560:  "iniserve-port",
	3561:  "bmc-onekey",
	3562:  "sdbproxy",
	3563:  "watcomdebug",
	3564:  "esimport",
	3565:  "m2pa",
	3566:  "quest-data-hub",
	3567:  "dof-eps",
	3568:  "dof-tunnel-sec",
	3569:  "mbg-ctrl",
	3570:  "mccwebsvr-port",
	3571:  "megardsvr-port",
	3572:  "megaregsvrport",
	3573:  "tag-ups-1",
	3574:  "dmaf-server",
	3575:  "ccm-port",
	3576:  "cmc-port",
	3577:  "config-port",
	3578:  "data-port",
	3579:  "ttat3lb",
	3580:  "nati-svrloc",
	3581:  "kfxaclicensing",
	3582:  "press",
	3583:  "canex-watch",
	3584:  "u-dbap",
	3585:  "emprise-lls",
	3586:  "emprise-lsc",
	3587:  "p2pgroup",
	3588:  "sentinel",
	3589:  "isomair",
	3590:  "wv-csp-sms",
	3591:  "gtrack-server",
	3592:  "gtrack-ne",
	3593:  "bpmd",
	3594:  "mediaspace",
	3595:  "shareapp",
	3596:  "iw-mmogame",
	3597:  "a14",
	3598:  "a15",
	3599:  "quasar-server",
	3600:  "trap-daemon",
	3601:  "visinet-gui",
	3602:  "infiniswitchcl",
	3603:  "int-rcv-cntrl",
	3604:  "bmc-jmx-port",
	3605:  "comcam-io",
	3606:  "splitlock",
	3607:  "precise-i3",
	3608:  "trendchip-dcp",
	3609:  "cpdi-pidas-cm",
	3610:  "echonet",
	3611:  "six-degrees",
	3612:  "hp-dataprotect",
	3613:  "alaris-disc",
	3614:  "sigma-port",
	3615:  "start-network",
	3616:  "cd3o-protocol",
	3617:  "sharp-server",
	3618:  "aairnet-1",
	3619:  "aairnet-2",
	3620:  "ep-pcp",
	3621:  "ep-nsp",
	3622:  "ff-lr-port",
	3623:  "haipe-discover",
	3624:  "dist-upgrade",
	3625:  "volley",
	3626:  "bvcdaemon-port",
	3627:  "jamserverport",
	3628:  "ept-machine",
	3629:  "escvpnet",
	3630:  "cs-remote-db",
	3631:  "cs-services",
	3632:  "distcc",
	3633:  "wacp",
	3634:  "hlibmgr",
	3635:  "sdo",
	3636:  "servistaitsm",
	3637:  "scservp",
	3638:  "ehp-backup",
	3639:  "xap-ha",
	3640:  "netplay-port1",
	3641:  "netplay-port2",
	3642:  "juxml-port",
	3643:  "audiojuggler",
	3644:  "ssowatch",
	3645:  "cyc",
	3646:  "xss-srv-port",
	3647:  "splitlock-gw",
	3648:  "fjcp",
	3649:  "nmmp",
	3650:  "prismiq-plugin",
	3651:  "xrpc-registry",
	3652:  "vxcrnbuport",
	3653:  "tsp",
	3654:  "vaprtm",
	3655:  "abatemgr",
	3656:  "abatjss",
	3657:  "immedianet-bcn",
	3658:  "ps-ams",
	3659:  "apple-sasl",
	3660:  "can-nds-ssl",
	3661:  "can-ferret-ssl",
	3662:  "pserver",
	3663:  "dtp",
	3664:  "ups-engine",
	3665:  "ent-engine",
	3666:  "eserver-pap",
	3667:  "infoexch",
	3668:  "dell-rm-port",
	3669:  "casanswmgmt",
	3670:  "smile",
	3671:  "efcp",
	3672:  "lispworks-orb",
	3673:  "mediavault-gui",
	3674:  "wininstall-ipc",
	3675:  "calltrax",
	3676:  "va-pacbase",
	3677:  "roverlog",
	3678:  "ipr-dglt",
	3679:  "Escale (Newton Dock)",
	3680:  "npds-tracker",
	3681:  "bts-x73",
	3682:  "cas-mapi",
	3683:  "bmc-ea",
	3684:  "faxstfx-port",
	3685:  "dsx-agent",
	3686:  "tnmpv2",
	3687:  "simple-push",
	3688:  "simple-push-s",
	3689:  "daap",
	3690:  "svn",
	3691:  "magaya-network",
	3692:  "intelsync",
	3693:  "easl",
	3695:  "bmc-data-coll",
	3696:  "telnetcpcd",
	3697:  "nw-license",
	3698:  "sagectlpanel",
	3699:  "kpn-icw",
	3700:  "lrs-paging",
	3701:  "netcelera",
	3702:  "ws-discovery",
	3703:  "adobeserver-3",
	3704:  "adobeserver-4",
	3705:  "adobeserver-5",
	3706:  "rt-event",
	3707:  "rt-event-s",
	3708:  "sun-as-iiops",
	3709:  "ca-idms",
	3710:  "portgate-auth",
	3711:  "edb-server2",
	3712:  "sentinel-ent",
	3713:  "tftps",
	3714:  "delos-dms",
	3715:  "anoto-rendezv",
	3716:  "wv-csp-sms-cir",
	3717:  "wv-csp-udp-cir",
	3718:  "opus-services",
	3719:  "itelserverport",
	3720:  "ufastro-instr",
	3721:  "xsync",
	3722:  "xserveraid",
	3723:  "sychrond",
	3724:  "blizwow",
	3725:  "na-er-tip",
	3726:  "array-manager",
	3727:  "e-mdu",
	3728:  "e-woa",
	3729:  "fksp-audit",
	3730:  "client-ctrl",
	3731:  "smap",
	3732:  "m-wnn",
	3733:  "multip-msg",
	3734:  "synel-data",
	3735:  "pwdis",
	3736:  "rs-rmi",
	3737:  "xpanel",
	3738:  "versatalk",
	3739:  "launchbird-lm",
	3740:  "heartbeat",
	3741:  "wysdma",
	3742:  "cst-port",
	3743:  "ipcs-command",
	3744:  "sasg",
	3745:  "gw-call-port",
	3746:  "linktest",
	3747:  "linktest-s",
	3748:  "webdata",
	3749:  "cimtrak",
	3750:  "cbos-ip-port",
	3751:  "gprs-cube",
	3752:  "vipremoteagent",
	3753:  "nattyserver",
	3754:  "timestenbroker",
	3755:  "sas-remote-hlp",
	3756:  "canon-capt",
	3757:  "grf-port",
	3758:  "apw-registry",
	3759:  "exapt-lmgr",
	3760:  "adtempusclient",
	3761:  "gsakmp",
	3762:  "gbs-smp",
	3763:  "xo-wave",
	3764:  "mni-prot-rout",
	3765:  "rtraceroute",
	3766:  "sitewatch-s",
	3767:  "listmgr-port",
	3768:  "rblcheckd",
	3769:  "haipe-otnk",
	3770:  "cindycollab",
	3771:  "paging-port",
	3772:  "ctp",
	3773:  "ctdhercules",
	3774:  "zicom",
	3775:  "ispmmgr",
	3776:  "dvcprov-port",
	3777:  "jibe-eb",
	3778:  "c-h-it-port",
	3779:  "cognima",
	3780:  "nnp",
	3781:  "abcvoice-port",
	3782:  "iso-tp0s",
	3783:  "bim-pem",
	3784:  "bfd-control",
	3785:  "bfd-echo",
	3786:  "upstriggervsw",
	3787:  "fintrx",
	3788:  "isrp-port",
	3789:  "remotedeploy",
	3790:  "quickbooksrds",
	3791:  "tvnetworkvideo",
	3792:  "sitewatch",
	3793:  "dcsoftware",
	3794:  "jaus",
	3795:  "myblast",
	3796:  "spw-dialer",
	3797:  "idps",
	3798:  "minilock",
	3799:  "radius-dynauth",
	3800:  "pwgpsi",
	3801:  "ibm-mgr",
	3802:  "vhd",
	3803:  "soniqsync",
	3804:  "iqnet-port",
	3805:  "tcpdataserver",
	3806:  "wsmlb",
	3807:  "spugna",
	3808:  "sun-as-iiops-ca",
	3809:  "apocd",
	3810:  "wlanauth",
	3811:  "amp",
	3812:  "neto-wol-server",
	3813:  "rap-ip",
	3814:  "neto-dcs",
	3815:  "lansurveyorxml",
	3816:  "sunlps-http",
	3817:  "tapeware",
	3818:  "crinis-hb",
	3819:  "epl-slp",
	3820:  "scp",
	3821:  "pmcp",
	3822:  "acp-discovery",
	3823:  "acp-conduit",
	3824:  "acp-policy",
	3825:  "ffserver",
	3826:  "warmux",
	3827:  "netmpi",
	3828:  "neteh",
	3829:  "neteh-ext",
	3830:  "cernsysmgmtagt",
	3831:  "dvapps",
	3832:  "xxnetserver",
	3833:  "aipn-auth",
	3834:  "spectardata",
	3835:  "spectardb",
	3836:  "markem-dcp",
	3837:  "mkm-discovery",
	3838:  "sos",
	3839:  "amx-rms",
	3840:  "flirtmitmir",
	3841:  "shiprush-db-svr",
	3842:  "nhci",
	3843:  "quest-agent",
	3844:  "rnm",
	3845:  "v-one-spp",
	3846:  "an-pcp",
	3847:  "msfw-control",
	3848:  "item",
	3849:  "spw-dnspreload",
	3850:  "qtms-bootstrap",
	3851:  "spectraport",
	3852:  "sse-app-config",
	3853:  "sscan",
	3854:  "stryker-com",
	3855:  "opentrac",
	3856:  "informer",
	3857:  "trap-port",
	3858:  "trap-port-mom",
	3859:  "nav-port",
	3860:  "sasp",
	3861:  "winshadow-hd",
	3862:  "giga-pocket",
	3863:  "asap-tcp",
	3864:  "asap-tcp-tls",
	3865:  "xpl",
	3866:  "dzdaemon",
	3867:  "dzoglserver",
	3868:  "diameter",
	3869:  "ovsam-mgmt",
	3870:  "ovsam-d-agent",
	3871:  "avocent-adsap",
	3872:  "oem-agent",
	3873:  "fagordnc",
	3874:  "sixxsconfig",
	3875:  "pnbscada",
	3876:  "dl-agent",
	3877:  "xmpcr-interface",
	3878:  "fotogcad",
	3879:  "appss-lm",
	3880:  "igrs",
	3881:  "idac",
	3882:  "msdts1",
	3883:  "vrpn",
	3884:  "softrack-meter",
	3885:  "topflow-ssl",
	3886:  "nei-management",
	3887:  "ciphire-data",
	3888:  "ciphire-serv",
	3889:  "dandv-tester",
	3890:  "ndsconnect",
	3891:  "rtc-pm-port",
	3892:  "pcc-image-port",
	3893:  "cgi-starapi",
	3894:  "syam-agent",
	3895:  "syam-smc",
	3896:  "sdo-tls",
	3897:  "sdo-ssh",
	3898:  "senip",
	3899:  "itv-control",
	3900:  "udt-os",
	3901:  "nimsh",
	3902:  "nimaux",
	3903:  "charsetmgr",
	3904:  "omnilink-port",
	3905:  "mupdate",
	3906:  "topovista-data",
	3907:  "imoguia-port",
	3908:  "hppronetman",
	3909:  "surfcontrolcpa",
	3910:  "prnrequest",
	3911:  "prnstatus",
	3912:  "gbmt-stars",
	3913:  "listcrt-port",
	3914:  "listcrt-port-2",
	3915:  "agcat",
	3916:  "wysdmc",
	3917:  "aftmux",
	3918:  "pktcablemmcops",
	3919:  "hyperip",
	3920:  "exasoftport1",
	3921:  "herodotus-net",
	3922:  "sor-update",
	3923:  "symb-sb-port",
	3924:  "mpl-gprs-port",
	3925:  "zmp",
	3926:  "winport",
	3927:  "natdataservice",
	3928:  "netboot-pxe",
	3929:  "smauth-port",
	3930:  "syam-webserver",
	3931:  "msr-plugin-port",
	3932:  "dyn-site",
	3933:  "plbserve-port",
	3934:  "sunfm-port",
	3935:  "sdp-portmapper",
	3936:  "mailprox",
	3937:  "dvbservdsc",
	3938:  "dbcontrol-agent",
	3939:  "aamp",
	3940:  "xecp-node",
	3941:  "homeportal-web",
	3942:  "srdp",
	3943:  "tig",
	3944:  "sops",
	3945:  "emcads",
	3946:  "backupedge",
	3947:  "ccp",
	3948:  "apdap",
	3949:  "drip",
	3950:  "namemunge",
	3951:  "pwgippfax",
	3952:  "i3-sessionmgr",
	3953:  "xmlink-connect",
	3954:  "adrep",
	3955:  "p2pcommunity",
	3956:  "gvcp",
	3957:  "mqe-broker",
	3958:  "mqe-agent",
	3959:  "treehopper",
	3960:  "bess",
	3961:  "proaxess",
	3962:  "sbi-agent",
	3963:  "thrp",
	3964:  "sasggprs",
	3965:  "ati-ip-to-ncpe",
	3966:  "bflckmgr",
	3967:  "ppsms",
	3968:  "ianywhere-dbns",
	3969:  "landmarks",
	3970:  "lanrevagent",
	3971:  "lanrevserver",
	3972:  "iconp",
	3973:  "progistics",
	3974:  "citysearch",
	3975:  "airshot",
	3976:  "opswagent",
	3977:  "opswmanager",
	3978:  "secure-cfg-svr",
	3979:  "smwan",
	3980:  "acms",
	3981:  "starfish",
	3982:  "eis",
	3983:  "eisp",
	3984:  "mapper-nodemgr",
	3985:  "mapper-mapethd",
	3986:  "mapper-ws-ethd",
	3987:  "centerline",
	3988:  "dcs-config",
	3989:  "bv-queryengine",
	3990:  "bv-is",
	3991:  "bv-smcsrv",
	3992:  "bv-ds",
	3993:  "bv-agent",
	3995:  "iss-mgmt-ssl",
	3996:  "abcsoftware",
	3997:  "agentsease-db",
	3998:  "dnx",
	3999:  "nvcnet",
	4000:  "terabase",
	4001:  "newoak",
	4002:  "pxc-spvr-ft",
	4003:  "pxc-splr-ft",
	4004:  "pxc-roid",
	4005:  "pxc-pin",
	4006:  "pxc-spvr",
	4007:  "pxc-splr",
	4008:  "netcheque",
	4009:  "chimera-hwm",
	4010:  "samsung-unidex",
	4011:  "altserviceboot",
	4012:  "pda-gate",
	4013:  "acl-manager",
	4014:  "taiclock",
	4015:  "talarian-mcast1",
	4016:  "talarian-mcast2",
	4017:  "talarian-mcast3",
	4018:  "talarian-mcast4",
	4019:  "talarian-mcast5",
	4020:  "trap",
	4021:  "nexus-portal",
	4022:  "dnox",
	4023:  "esnm-zoning",
	4024:  "tnp1-port",
	4025:  "partimage",
	4026:  "as-debug",
	4027:  "bxp",
	4028:  "dtserver-port",
	4029:  "ip-qsig",
	4030:  "jdmn-port",
	4031:  "suucp",
	4032:  "vrts-auth-port",
	4033:  "sanavigator",
	4034:  "ubxd",
	4035:  "wap-push-http",
	4036:  "wap-push-https",
	4037:  "ravehd",
	4038:  "fazzt-ptp",
	4039:  "fazzt-admin",
	4040:  "yo-main",
	4041:  "houston",
	4042:  "ldxp",
	4043:  "nirp",
	4044:  "ltp",
	4045:  "npp",
	4046:  "acp-proto",
	4047:  "ctp-state",
	4049:  "wafs",
	4050:  "cisco-wafs",
	4051:  "cppdp",
	4052:  "interact",
	4053:  "ccu-comm-1",
	4054:  "ccu-comm-2",
	4055:  "ccu-comm-3",
	4056:  "lms",
	4057:  "wfm",
	4058:  "kingfisher",
	4059:  "dlms-cosem",
	4060:  "dsmeter-iatc",
	4061:  "ice-location",
	4062:  "ice-slocation",
	4063:  "ice-router",
	4064:  "ice-srouter",
	4065:  "avanti-cdp",
	4066:  "pmas",
	4067:  "idp",
	4068:  "ipfltbcst",
	4069:  "minger",
	4070:  "tripe",
	4071:  "aibkup",
	4072:  "zieto-sock",
	4073:  "iRAPP",
	4074:  "cequint-cityid",
	4075:  "perimlan",
	4076:  "seraph",
	4078:  "cssp",
	4079:  "santools",
	4080:  "lorica-in",
	4081:  "lorica-in-sec",
	4082:  "lorica-out",
	4083:  "lorica-out-sec",
	4085:  "ezmessagesrv",
	4087:  "applusservice",
	4088:  "npsp",
	4089:  "opencore",
	4090:  "omasgport",
	4091:  "ewinstaller",
	4092:  "ewdgs",
	4093:  "pvxpluscs",
	4094:  "sysrqd",
	4095:  "xtgui",
	4096:  "bre",
	4097:  "patrolview",
	4098:  "drmsfsd",
	4099:  "dpcp",
	4100:  "igo-incognito",
	4101:  "brlp-0",
	4102:  "brlp-1",
	4103:  "brlp-2",
	4104:  "brlp-3",
	4105:  "shofar",
	4106:  "synchronite",
	4107:  "j-ac",
	4108:  "accel",
	4109:  "izm",
	4110:  "g2tag",
	4111:  "xgrid",
	4112:  "apple-vpns-rp",
	4113:  "aipn-reg",
	4114:  "jomamqmonitor",
	4115:  "cds",
	4116:  "smartcard-tls",
	4117:  "hillrserv",
	4118:  "netscript",
	4119:  "assuria-slm",
	4120:  "minirem",
	4121:  "e-builder",
	4122:  "fprams",
	4123:  "z-wave",
	4124:  "tigv2",
	4125:  "opsview-envoy",
	4126:  "ddrepl",
	4127:  "unikeypro",
	4128:  "nufw",
	4129:  "nuauth",
	4130:  "fronet",
	4131:  "stars",
	4132:  "nuts-dem",
	4133:  "nuts-bootp",
	4134:  "nifty-hmi",
	4135:  "cl-db-attach",
	4136:  "cl-db-request",
	4137:  "cl-db-remote",
	4138:  "nettest",
	4139:  "thrtx",
	4140:  "cedros-fds",
	4141:  "oirtgsvc",
	4142:  "oidocsvc",
	4143:  "oidsr",
	4145:  "vvr-control",
	4146:  "tgcconnect",
	4147:  "vrxpservman",
	4148:  "hhb-handheld",
	4149:  "agslb",
	4150:  "PowerAlert-nsa",
	4151:  "menandmice-noh",
	4152:  "idig-mux",
	4153:  "mbl-battd",
	4154:  "atlinks",
	4155:  "bzr",
	4156:  "stat-results",
	4157:  "stat-scanner",
	4158:  "stat-cc",
	4159:  "nss",
	4160:  "jini-discovery",
	4161:  "omscontact",
	4162:  "omstopology",
	4163:  "silverpeakpeer",
	4164:  "silverpeakcomm",
	4165:  "altcp",
	4166:  "joost",
	4167:  "ddgn",
	4168:  "pslicser",
	4169:  "iadt",
	4170:  "d-cinema-csp",
	4171:  "ml-svnet",
	4172:  "pcoip",
	4174:  "smcluster",
	4175:  "bccp",
	4176:  "tl-ipcproxy",
	4177:  "wello",
	4178:  "storman",
	4179:  "MaxumSP",
	4180:  "httpx",
	4181:  "macbak",
	4182:  "pcptcpservice",
	4183:  "cyborgnet",
	4184:  "universe-suite",
	4185:  "wcpp",
	4186:  "boxbackupstore",
	4187:  "csc-proxy",
	4188:  "vatata",
	4189:  "pcep",
	4190:  "sieve",
	4192:  "azeti",
	4193:  "pvxplusio",
	4197:  "hctl",
	4199:  "eims-admin",
	4300:  "corelccam",
	4301:  "d-data",
	4302:  "d-data-control",
	4303:  "srcp",
	4304:  "owserver",
	4305:  "batman",
	4306:  "pinghgl",
	4307:  "trueconf",
	4308:  "compx-lockview",
	4309:  "dserver",
	4310:  "mirrtex",
	4311:  "p6ssmc",
	4312:  "pscl-mgt",
	4313:  "perrla",
	4314:  "choiceview-agt",
	4316:  "choiceview-clt",
	4320:  "fdt-rcatp",
	4321:  "rwhois",
	4322:  "trim-event",
	4323:  "trim-ice",
	4325:  "geognosisman",
	4326:  "geognosis",
	4327:  "jaxer-web",
	4328:  "jaxer-manager",
	4329:  "publiqare-sync",
	4330:  "dey-sapi",
	4331:  "ktickets-rest",
	4333:  "ahsp",
	4334:  "netconf-ch-ssh",
	4335:  "netconf-ch-tls",
	4336:  "restconf-ch-tls",
	4340:  "gaia",
	4341:  "lisp-data",
	4342:  "lisp-cons",
	4343:  "unicall",
	4344:  "vinainstall",
	4345:  "m4-network-as",
	4346:  "elanlm",
	4347:  "lansurveyor",
	4348:  "itose",
	4349:  "fsportmap",
	4350:  "net-device",
	4351:  "plcy-net-svcs",
	4352:  "pjlink",
	4353:  "f5-iquery",
	4354:  "qsnet-trans",
	4355:  "qsnet-workst",
	4356:  "qsnet-assist",
	4357:  "qsnet-cond",
	4358:  "qsnet-nucl",
	4359:  "omabcastltkm",
	4360:  "matrix-vnet",
	4368:  "wxbrief",
	4369:  "epmd",
	4370:  "elpro-tunnel",
	4371:  "l2c-control",
	4372:  "l2c-data",
	4373:  "remctl",
	4374:  "psi-ptt",
	4375:  "tolteces",
	4376:  "bip",
	4377:  "cp-spxsvr",
	4378:  "cp-spxdpy",
	4379:  "ctdb",
	4389:  "xandros-cms",
	4390:  "wiegand",
	4391:  "apwi-imserver",
	4392:  "apwi-rxserver",
	4393:  "apwi-rxspooler",
	4395:  "omnivisionesx",
	4396:  "fly",
	4400:  "ds-srv",
	4401:  "ds-srvr",
	4402:  "ds-clnt",
	4403:  "ds-user",
	4404:  "ds-admin",
	4405:  "ds-mail",
	4406:  "ds-slp",
	4407:  "nacagent",
	4408:  "slscc",
	4409:  "netcabinet-com",
	4410:  "itwo-server",
	4411:  "found",
	4413:  "avi-nms",
	4414:  "updog",
	4415:  "brcd-vr-req",
	4416:  "pjj-player",
	4417:  "workflowdir",
	4419:  "cbp",
	4420:  "nvm-express",
	4421:  "scaleft",
	4422:  "tsepisp",
	4423:  "thingkit",
	4425:  "netrockey6",
	4426:  "beacon-port-2",
	4427:  "drizzle",
	4428:  "omviserver",
	4429:  "omviagent",
	4430:  "rsqlserver",
	4431:  "wspipe",
	4432:  "l-acoustics",
	4433:  "vop",
	4442:  "saris",
	4443:  "pharos",
	4444:  "krb524",
	4445:  "upnotifyp",
	4446:  "n1-fwp",
	4447:  "n1-rmgmt",
	4448:  "asc-slmd",
	4449:  "privatewire",
	4450:  "camp",
	4451:  "ctisystemmsg",
	4452:  "ctiprogramload",
	4453:  "nssalertmgr",
	4454:  "nssagentmgr",
	4455:  "prchat-user",
	4456:  "prchat-server",
	4457:  "prRegister",
	4458:  "mcp",
	4484:  "hpssmgmt",
	4485:  "assyst-dr",
	4486:  "icms",
	4487:  "prex-tcp",
	4488:  "awacs-ice",
	4500:  "ipsec-nat-t",
	4535:  "ehs",
	4536:  "ehs-ssl",
	4537:  "wssauthsvc",
	4538:  "swx-gate",
	4545:  "worldscores",
	4546:  "sf-lm",
	4547:  "lanner-lm",
	4548:  "synchromesh",
	4549:  "aegate",
	4550:  "gds-adppiw-db",
	4551:  "ieee-mih",
	4552:  "menandmice-mon",
	4553:  "icshostsvc",
	4554:  "msfrs",
	4555:  "rsip",
	4556:  "dtn-bundle",
	4559:  "hylafax",
	4563:  "amahi-anywhere",
	4566:  "kwtc",
	4567:  "tram",
	4568:  "bmc-reporting",
	4569:  "iax",
	4570:  "deploymentmap",
	4573:  "cardifftec-back",
	4590:  "rid",
	4591:  "l3t-at-an",
	4593:  "ipt-anri-anri",
	4594:  "ias-session",
	4595:  "ias-paging",
	4596:  "ias-neighbor",
	4597:  "a21-an-1xbs",
	4598:  "a16-an-an",
	4599:  "a17-an-an",
	4600:  "piranha1",
	4601:  "piranha2",
	4602:  "mtsserver",
	4603:  "menandmice-upg",
	4604:  "irp",
	4605:  "sixchat",
	4658:  "playsta2-app",
	4659:  "playsta2-lob",
	4660:  "smaclmgr",
	4661:  "kar2ouche",
	4662:  "oms",
	4663:  "noteit",
	4664:  "ems",
	4665:  "contclientms",
	4666:  "eportcomm",
	4667:  "mmacomm",
	4668:  "mmaeds",
	4669:  "eportcommdata",
	4670:  "light",
	4671:  "acter",
	4672:  "rfa",
	4673:  "cxws",
	4674:  "appiq-mgmt",
	4675:  "dhct-status",
	4676:  "dhct-alerts",
	4677:  "bcs",
	4678:  "traversal",
	4679:  "mgesupervision",
	4680:  "mgemanagement",
	4681:  "parliant",
	4682:  "finisar",
	4683:  "spike",
	4684:  "rfid-rp1",
	4685:  "autopac",
	4686:  "msp-os",
	4687:  "nst",
	4688:  "mobile-p2p",
	4689:  "altovacentral",
	4690:  "prelude",
	4691:  "mtn",
	4692:  "conspiracy",
	4700:  "netxms-agent",
	4701:  "netxms-mgmt",
	4702:  "netxms-sync",
	4703:  "npqes-test",
	4704:  "assuria-ins",
	4711:  "trinity-dist",
	4725:  "truckstar",
	4727:  "fcis",
	4728:  "capmux",
	4730:  "gearman",
	4731:  "remcap",
	4733:  "resorcs",
	4737:  "ipdr-sp",
	4738:  "solera-lpn",
	4739:  "ipfix",
	4740:  "ipfixs",
	4741:  "lumimgrd",
	4742:  "sicct",
	4743:  "openhpid",
	4744:  "ifsp",
	4745:  "fmp",
	4749:  "profilemac",
	4750:  "ssad",
	4751:  "spocp",
	4752:  "snap",
	4753:  "simon",
	4756:  "RDCenter",
	4774:  "converge",
	4784:  "bfd-multi-ctl",
	4786:  "smart-install",
	4787:  "sia-ctrl-plane",
	4788:  "xmcp",
	4800:  "iims",
	4801:  "iwec",
	4802:  "ilss",
	4803:  "notateit",
	4827:  "htcp",
	4837:  "varadero-0",
	4838:  "varadero-1",
	4839:  "varadero-2",
	4840:  "opcua-tcp",
	4841:  "quosa",
	4842:  "gw-asv",
	4843:  "opcua-tls",
	4844:  "gw-log",
	4845:  "wcr-remlib",
	4846:  "contamac-icm",
	4847:  "wfc",
	4848:  "appserv-http",
	4849:  "appserv-https",
	4850:  "sun-as-nodeagt",
	4851:  "derby-repli",
	4867:  "unify-debug",
	4868:  "phrelay",
	4869:  "phrelaydbg",
	4870:  "cc-tracking",
	4871:  "wired",
	4876:  "tritium-can",
	4877:  "lmcs",
	4879:  "wsdl-event",
	4880:  "hislip",
	4883:  "wmlserver",
	4884:  "hivestor",
	4885:  "abbs",
	4894:  "lyskom",
	4899:  "radmin-port",
	4900:  "hfcs",
	4901:  "flr-agent",
	4902:  "magiccontrol",
	4912:  "lutap",
	4913:  "lutcp",
	4914:  "bones",
	4915:  "frcs",
	4940:  "eq-office-4940",
	4941:  "eq-office-4941",
	4942:  "eq-office-4942",
	4949:  "munin",
	4950:  "sybasesrvmon",
	4951:  "pwgwims",
	4952:  "sagxtsds",
	4953:  "dbsyncarbiter",
	4969:  "ccss-qmm",
	4970:  "ccss-qsm",
	4971:  "burp",
	4984:  "webyast",
	4985:  "gerhcs",
	4986:  "mrip",
	4987:  "smar-se-port1",
	4988:  "smar-se-port2",
	4989:  "parallel",
	4990:  "busycal",
	4991:  "vrt",
	4999:  "hfcs-manager",
	5000:  "commplex-main",
	5001:  "commplex-link",
	5002:  "rfe",
	5003:  "fmpro-internal",
	5004:  "avt-profile-1",
	5005:  "avt-profile-2",
	5006:  "wsm-server",
	5007:  "wsm-server-ssl",
	5008:  "synapsis-edge",
	5009:  "winfs",
	5010:  "telelpathstart",
	5011:  "telelpathattack",
	5012:  "nsp",
	5013:  "fmpro-v6",
	5015:  "fmwp",
	5020:  "zenginkyo-1",
	5021:  "zenginkyo-2",
	5022:  "mice",
	5023:  "htuilsrv",
	5024:  "scpi-telnet",
	5025:  "scpi-raw",
	5026:  "strexec-d",
	5027:  "strexec-s",
	5028:  "qvr",
	5029:  "infobright",
	5030:  "surfpass",
	5032:  "signacert-agent",
	5033:  "jtnetd-server",
	5034:  "jtnetd-status",
	5042:  "asnaacceler8db",
	5043:  "swxadmin",
	5044:  "lxi-evntsvc",
	5045:  "osp",
	5048:  "texai",
	5049:  "ivocalize",
	5050:  "mmcc",
	5051:  "ita-agent",
	5052:  "ita-manager",
	5053:  "rlm",
	5054:  "rlm-admin",
	5055:  "unot",
	5056:  "intecom-ps1",
	5057:  "intecom-ps2",
	5059:  "sds",
	5060:  "sip",
	5061:  "sips",
	5062:  "na-localise",
	5063:  "csrpc",
	5064:  "ca-1",
	5065:  "ca-2",
	5066:  "stanag-5066",
	5067:  "authentx",
	5068:  "bitforestsrv",
	5069:  "i-net-2000-npr",
	5070:  "vtsas",
	5071:  "powerschool",
	5072:  "ayiya",
	5073:  "tag-pm",
	5074:  "alesquery",
	5075:  "pvaccess",
	5080:  "onscreen",
	5081:  "sdl-ets",
	5082:  "qcp",
	5083:  "qfp",
	5084:  "llrp",
	5085:  "encrypted-llrp",
	5086:  "aprigo-cs",
	5087:  "biotic",
	5093:  "sentinel-lm",
	5094:  "hart-ip",
	5099:  "sentlm-srv2srv",
	5100:  "socalia",
	5101:  "talarian-tcp",
	5102:  "oms-nonsecure",
	5103:  "actifio-c2c",
	5106:  "actifioudsagent",
	5107:  "actifioreplic",
	5111:  "taep-as-svc",
	5112:  "pm-cmdsvr",
	5114:  "ev-services",
	5115:  "autobuild",
	5117:  "gradecam",
	5120:  "barracuda-bbs",
	5133:  "nbt-pc",
	5134:  "ppactivation",
	5135:  "erp-scale",
	5137:  "ctsd",
	5145:  "rmonitor-secure",
	5146:  "social-alarm",
	5150:  "atmp",
	5151:  "esri-sde",
	5152:  "sde-discovery",
	5153:  "toruxserver",
	5154:  "bzflag",
	5155:  "asctrl-agent",
	5156:  "rugameonline",
	5157:  "mediat",
	5161:  "snmpssh",
	5162:  "snmpssh-trap",
	5163:  "sbackup",
	5164:  "vpa",
	5165:  "ife-icorp",
	5166:  "winpcs",
	5167:  "scte104",
	5168:  "scte30",
	5172:  "pcoip-mgmt",
	5190:  "aol",
	5191:  "aol-1",
	5192:  "aol-2",
	5193:  "aol-3",
	5194:  "cpscomm",
	5195:  "ampl-lic",
	5196:  "ampl-tableproxy",
	5197:  "tunstall-lwp",
	5200:  "targus-getdata",
	5201:  "targus-getdata1",
	5202:  "targus-getdata2",
	5203:  "targus-getdata3",
	5209:  "nomad",
	5215:  "noteza",
	5221:  "3exmp",
	5222:  "xmpp-client",
	5223:  "hpvirtgrp",
	5224:  "hpvirtctrl",
	5225:  "hp-server",
	5226:  "hp-status",
	5227:  "perfd",
	5228:  "hpvroom",
	5229:  "jaxflow",
	5230:  "jaxflow-data",
	5231:  "crusecontrol",
	5232:  "csedaemon",
	5233:  "enfs",
	5234:  "eenet",
	5235:  "galaxy-network",
	5236:  "padl2sim",
	5237:  "mnet-discovery",
	5245:  "downtools",
	5248:  "caacws",
	5249:  "caaclang2",
	5250:  "soagateway",
	5251:  "caevms",
	5252:  "movaz-ssc",
	5253:  "kpdp",
	5254:  "logcabin",
	5264:  "3com-njack-1",
	5265:  "3com-njack-2",
	5269:  "xmpp-server",
	5270:  "cartographerxmp",
	5271:  "cuelink",
	5272:  "pk",
	5280:  "xmpp-bosh",
	5281:  "undo-lm",
	5282:  "transmit-port",
	5298:  "presence",
	5299:  "nlg-data",
	5300:  "hacl-hb",
	5301:  "hacl-gs",
	5302:  "hacl-cfg",
	5303:  "hacl-probe",
	5304:  "hacl-local",
	5305:  "hacl-test",
	5306:  "sun-mc-grp",
	5307:  "sco-aip",
	5308:  "cfengine",
	5309:  "jprinter",
	5310:  "outlaws",
	5312:  "permabit-cs",
	5313:  "rrdp",
	5314:  "opalis-rbt-ipc",
	5315:  "hacl-poll",
	5316:  "hpbladems",
	5317:  "hpdevms",
	5318:  "pkix-cmc",
	5320:  "bsfserver-zn",
	5321:  "bsfsvr-zn-ssl",
	5343:  "kfserver",
	5344:  "xkotodrcp",
	5349:  "stuns",
	5352:  "dns-llq",
	5353:  "mdns",
	5354:  "mdnsresponder",
	5355:  "llmnr",
	5356:  "ms-smlbiz",
	5357:  "wsdapi",
	5358:  "wsdapi-s",
	5359:  "ms-alerter",
	5360:  "ms-sideshow",
	5361:  "ms-s-sideshow",
	5362:  "serverwsd2",
	5363:  "net-projection",
	5397:  "stresstester",
	5398:  "elektron-admin",
	5399:  "securitychase",
	5400:  "excerpt",
	5401:  "excerpts",
	5402:  "mftp",
	5403:  "hpoms-ci-lstn",
	5404:  "hpoms-dps-lstn",
	5405:  "netsupport",
	5406:  "systemics-sox",
	5407:  "foresyte-clear",
	5408:  "foresyte-sec",
	5409:  "salient-dtasrv",
	5410:  "salient-usrmgr",
	5411:  "actnet",
	5412:  "continuus",
	5413:  "wwiotalk",
	5414:  "statusd",
	5415:  "ns-server",
	5416:  "sns-gateway",
	5417:  "sns-agent",
	5418:  "mcntp",
	5419:  "dj-ice",
	5420:  "cylink-c",
	5421:  "netsupport2",
	5422:  "salient-mux",
	5423:  "virtualuser",
	5424:  "beyond-remote",
	5425:  "br-channel",
	5426:  "devbasic",
	5427:  "sco-peer-tta",
	5428:  "telaconsole",
	5429:  "base",
	5430:  "radec-corp",
	5431:  "park-agent",
	5432:  "postgresql",
	5433:  "pyrrho",
	5434:  "sgi-arrayd",
	5435:  "sceanics",
	5443:  "spss",
	5445:  "smbdirect",
	5450:  "tiepie",
	5453:  "surebox",
	5454:  "apc-5454",
	5455:  "apc-5455",
	5456:  "apc-5456",
	5461:  "silkmeter",
	5462:  "ttl-publisher",
	5463:  "ttlpriceproxy",
	5464:  "quailnet",
	5465:  "netops-broker",
	5470:  "apsolab-col",
	5471:  "apsolab-cols",
	5472:  "apsolab-tag",
	5473:  "apsolab-tags",
	5475:  "apsolab-data",
	5500:  "fcp-addr-srvr1",
	5501:  "fcp-addr-srvr2",
	5502:  "fcp-srvr-inst1",
	5503:  "fcp-srvr-inst2",
	5504:  "fcp-cics-gw1",
	5505:  "checkoutdb",
	5506:  "amc",
	5507:  "psl-management",
	5550:  "cbus",
	5553:  "sgi-eventmond",
	5554:  "sgi-esphttp",
	5555:  "personal-agent",
	5556:  "freeciv",
	5557:  "farenet",
	5565:  "hpe-dp-bura",
	5566:  "westec-connect",
	5567:  "dof-dps-mc-sec",
	5568:  "sdt",
	5569:  "rdmnet-ctrl",
	5573:  "sdmmp",
	5574:  "lsi-bobcat",
	5575:  "ora-oap",
	5579:  "fdtracks",
	5580:  "tmosms0",
	5581:  "tmosms1",
	5582:  "fac-restore",
	5583:  "tmo-icon-sync",
	5584:  "bis-web",
	5585:  "bis-sync",
	5586:  "att-mt-sms",
	5597:  "ininmessaging",
	5598:  "mctfeed",
	5599:  "esinstall",
	5600:  "esmmanager",
	5601:  "esmagent",
	5602:  "a1-msc",
	5603:  "a1-bs",
	5604:  "a3-sdunode",
	5605:  "a4-sdunode",
	5618:  "efr",
	5627:  "ninaf",
	5628:  "htrust",
	5629:  "symantec-sfdb",
	5630:  "precise-comm",
	5631:  "pcanywheredata",
	5632:  "pcanywherestat",
	5633:  "beorl",
	5634:  "xprtld",
	5635:  "sfmsso",
	5636:  "sfm-db-server",
	5637:  "cssc",
	5638:  "flcrs",
	5639:  "ics",
	5646:  "vfmobile",
	5666:  "nrpe",
	5670:  "filemq",
	5671:  "amqps",
	5672:  "amqp",
	5673:  "jms",
	5674:  "hyperscsi-port",
	5675:  "v5ua",
	5676:  "raadmin",
	5677:  "questdb2-lnchr",
	5678:  "rrac",
	5679:  "dccm",
	5680:  "auriga-router",
	5681:  "ncxcp",
	5688:  "ggz",
	5689:  "qmvideo",
	5693:  "rbsystem",
	5696:  "kmip",
	5700:  "supportassist",
	5705:  "storageos",
	5713:  "proshareaudio",
	5714:  "prosharevideo",
	5715:  "prosharedata",
	5716:  "prosharerequest",
	5717:  "prosharenotify",
	5718:  "dpm",
	5719:  "dpm-agent",
	5720:  "ms-licensing",
	5721:  "dtpt",
	5722:  "msdfsr",
	5723:  "omhs",
	5724:  "omsdk",
	5725:  "ms-ilm",
	5726:  "ms-ilm-sts",
	5727:  "asgenf",
	5728:  "io-dist-data",
	5729:  "openmail",
	5730:  "unieng",
	5741:  "ida-discover1",
	5742:  "ida-discover2",
	5743:  "watchdoc-pod",
	5744:  "watchdoc",
	5745:  "fcopy-server",
	5746:  "fcopys-server",
	5747:  "tunatic",
	5748:  "tunalyzer",
	5750:  "rscd",
	5755:  "openmailg",
	5757:  "x500ms",
	5766:  "openmailns",
	5767:  "s-openmail",
	5768:  "openmailpxy",
	5769:  "spramsca",
	5770:  "spramsd",
	5771:  "netagent",
	5777:  "dali-port",
	5780:  "vts-rpc",
	5781:  "3par-evts",
	5782:  "3par-mgmt",
	5783:  "3par-mgmt-ssl",
	5785:  "3par-rcopy",
	5793:  "xtreamx",
	5813:  "icmpd",
	5814:  "spt-automation",
	5841:  "shiprush-d-ch",
	5842:  "reversion",
	5859:  "wherehoo",
	5863:  "ppsuitemsg",
	5868:  "diameters",
	5883:  "jute",
	5900:  "rfb",
	5910:  "cm",
	5911:  "cpdlc",
	5912:  "fis",
	5913:  "ads-c",
	5963:  "indy",
	5968:  "mppolicy-v5",
	5969:  "mppolicy-mgr",
	5984:  "couchdb",
	5985:  "wsman",
	5986:  "wsmans",
	5987:  "wbem-rmi",
	5988:  "wbem-http",
	5989:  "wbem-https",
	5990:  "wbem-exp-https",
	5991:  "nuxsl",
	5992:  "consul-insight",
	5993:  "cim-rs",
	5999:  "cvsup",
	6064:  "ndl-ahp-svc",
	6065:  "winpharaoh",
	6066:  "ewctsp",
	6068:  "gsmp-ancp",
	6069:  "trip",
	6070:  "messageasap",
	6071:  "ssdtp",
	6072:  "diagnose-proc",
	6073:  "directplay8",
	6074:  "max",
	6075:  "dpm-acm",
	6076:  "msft-dpm-cert",
	6077:  "iconstructsrv",
	6084:  "reload-config",
	6085:  "konspire2b",
	6086:  "pdtp",
	6087:  "ldss",
	6088:  "doglms",
	6099:  "raxa-mgmt",
	6100:  "synchronet-db",
	6101:  "synchronet-rtc",
	6102:  "synchronet-upd",
	6103:  "rets",
	6104:  "dbdb",
	6105:  "primaserver",
	6106:  "mpsserver",
	6107:  "etc-control",
	6108:  "sercomm-scadmin",
	6109:  "globecast-id",
	6110:  "softcm",
	6111:  "spc",
	6112:  "dtspcd",
	6113:  "dayliteserver",
	6114:  "wrspice",
	6115:  "xic",
	6116:  "xtlserv",
	6117:  "daylitetouch",
	6121:  "spdy",
	6122:  "bex-webadmin",
	6123:  "backup-express",
	6124:  "pnbs",
	6130:  "damewaremobgtwy",
	6133:  "nbt-wol",
	6140:  "pulsonixnls",
	6141:  "meta-corp",
	6142:  "aspentec-lm",
	6143:  "watershed-lm",
	6144:  "statsci1-lm",
	6145:  "statsci2-lm",
	6146:  "lonewolf-lm",
	6147:  "montage-lm",
	6148:  "ricardo-lm",
	6149:  "tal-pod",
	6159:  "efb-aci",
	6160:  "ecmp",
	6161:  "patrol-ism",
	6162:  "patrol-coll",
	6163:  "pscribe",
	6200:  "lm-x",
	6209:  "qmtps",
	6222:  "radmind",
	6241:  "jeol-nsdtp-1",
	6242:  "jeol-nsdtp-2",
	6243:  "jeol-nsdtp-3",
	6244:  "jeol-nsdtp-4",
	6251:  "tl1-raw-ssl",
	6252:  "tl1-ssh",
	6253:  "crip",
	6267:  "gld",
	6268:  "grid",
	6269:  "grid-alt",
	6300:  "bmc-grx",
	6301:  "bmc-ctd-ldap",
	6306:  "ufmp",
	6315:  "scup",
	6316:  "abb-escp",
	6317:  "nav-data-cmd",
	6320:  "repsvc",
	6321:  "emp-server1",
	6322:  "emp-server2",
	6324:  "hrd-ncs",
	6325:  "dt-mgmtsvc",
	6326:  "dt-vra",
	6343:  "sflow",
	6344:  "streletz",
	6346:  "gnutella-svc",
	6347:  "gnutella-rtr",
	6350:  "adap",
	6355:  "pmcs",
	6360:  "metaedit-mu",
	6370:  "metaedit-se",
	6379:  "redis",
	6382:  "metatude-mds",
	6389:  "clariion-evr01",
	6390:  "metaedit-ws",
	6417:  "faxcomservice",
	6418:  "syserverremote",
	6419:  "svdrp",
	6420:  "nim-vdrshell",
	6421:  "nim-wan",
	6432:  "pgbouncer",
	6442:  "tarp",
	6443:  "sun-sr-https",
	6444:  "sge-qmaster",
	6445:  "sge-execd",
	6446:  "mysql-proxy",
	6455:  "skip-cert-recv",
	6456:  "skip-cert-send",
	6464:  "ieee11073-20701",
	6471:  "lvision-lm",
	6480:  "sun-sr-http",
	6481:  "servicetags",
	6482:  "ldoms-mgmt",
	6483:  "SunVTS-RMI",
	6484:  "sun-sr-jms",
	6485:  "sun-sr-iiop",
	6486:  "sun-sr-iiops",
	6487:  "sun-sr-iiop-aut",
	6488:  "sun-sr-jmx",
	6489:  "sun-sr-admin",
	6500:  "boks",
	6501:  "boks-servc",
	6502:  "boks-servm",
	6503:  "boks-clntd",
	6505:  "badm-priv",
	6506:  "badm-pub",
	6507:  "bdir-priv",
	6508:  "bdir-pub",
	6509:  "mgcs-mfp-port",
	6510:  "mcer-port",
	6513:  "netconf-tls",
	6514:  "syslog-tls",
	6515:  "elipse-rec",
	6543:  "lds-distrib",
	6544:  "lds-dump",
	6547:  "apc-6547",
	6548:  "apc-6548",
	6549:  "apc-6549",
	6550:  "fg-sysupdate",
	6551:  "sum",
	6558:  "xdsxdm",
	6566:  "sane-port",
	6568:  "canit-store",
	6579:  "affiliate",
	6580:  "parsec-master",
	6581:  "parsec-peer",
	6582:  "parsec-game",
	6583:  "joaJewelSuite",
	6600:  "mshvlm",
	6601:  "mstmg-sstp",
	6602:  "wsscomfrmwk",
	6619:  "odette-ftps",
	6620:  "kftp-data",
	6621:  "kftp",
	6622:  "mcftp",
	6623:  "ktelnet",
	6624:  "datascaler-db",
	6625:  "datascaler-ctl",
	6626:  "wago-service",
	6627:  "nexgen",
	6628:  "afesc-mc",
	6629:  "nexgen-aux",
	6632:  "mxodbc-connect",
	6640:  "ovsdb",
	6653:  "openflow",
	6655:  "pcs-sf-ui-man",
	6656:  "emgmsg",
	6670:  "vocaltec-gold",
	6671:  "p4p-portal",
	6672:  "vision-server",
	6673:  "vision-elmd",
	6678:  "vfbp",
	6679:  "osaut",
	6687:  "clever-ctrace",
	6688:  "clever-tcpip",
	6689:  "tsa",
	6690:  "cleverdetect",
	6697:  "ircs-u",
	6701:  "kti-icad-srvr",
	6702:  "e-design-net",
	6703:  "e-design-web",
	6714:  "ibprotocol",
	6715:  "fibotrader-com",
	6716:  "princity-agent",
	6767:  "bmc-perf-agent",
	6768:  "bmc-perf-mgrd",
	6769:  "adi-gxp-srvprt",
	6770:  "plysrv-http",
	6771:  "plysrv-https",
	6777:  "ntz-tracker",
	6778:  "ntz-p2p-storage",
	6785:  "dgpf-exchg",
	6786:  "smc-jmx",
	6787:  "smc-admin",
	6788:  "smc-http",
	6789:  "radg",
	6790:  "hnmp",
	6791:  "hnm",
	6801:  "acnet",
	6817:  "pentbox-sim",
	6831:  "ambit-lm",
	6841:  "netmo-default",
	6842:  "netmo-http",
	6850:  "iccrushmore",
	6868:  "acctopus-cc",
	6888:  "muse",
	6900:  "rtimeviewer",
	6901:  "jetstream",
	6935:  "ethoscan",
	6936:  "xsmsvc",
	6946:  "bioserver",
	6951:  "otlp",
	6961:  "jmact3",
	6962:  "jmevt2",
	6963:  "swismgr1",
	6964:  "swismgr2",
	6965:  "swistrap",
	6966:  "swispol",
	6969:  "acmsoda",
	6970:  "conductor",
	6997:  "MobilitySrv",
	6998:  "iatp-highpri",
	6999:  "iatp-normalpri",
	7000:  "afs3-fileserver",
	7001:  "afs3-callback",
	7002:  "afs3-prserver",
	7003:  "afs3-vlserver",
	7004:  "afs3-kaserver",
	7005:  "afs3-volser",
	7006:  "afs3-errors",
	7007:  "afs3-bos",
	7008:  "afs3-update",
	7009:  "afs3-rmtsys",
	7010:  "ups-onlinet",
	7011:  "talon-disc",
	7012:  "talon-engine",
	7013:  "microtalon-dis",
	7014:  "microtalon-com",
	7015:  "talon-webserver",
	7016:  "spg",
	7017:  "grasp",
	7018:  "fisa-svc",
	7019:  "doceri-ctl",
	7020:  "dpserve",
	7021:  "dpserveadmin",
	7022:  "ctdp",
	7023:  "ct2nmcs",
	7024:  "vmsvc",
	7025:  "vmsvc-2",
	7030:  "op-probe",
	7031:  "iposplanet",
	7070:  "arcp",
	7071:  "iwg1",
	7073:  "martalk",
	7080:  "empowerid",
	7099:  "lazy-ptop",
	7100:  "font-service",
	7101:  "elcn",
	7117:  "rothaga",
	7121:  "virprot-lm",
	7128:  "scenidm",
	7129:  "scenccs",
	7161:  "cabsm-comm",
	7162:  "caistoragemgr",
	7163:  "cacsambroker",
	7164:  "fsr",
	7165:  "doc-server",
	7166:  "aruba-server",
	7167:  "casrmagent",
	7168:  "cnckadserver",
	7169:  "ccag-pib",
	7170:  "nsrp",
	7171:  "drm-production",
	7172:  "metalbend",
	7173:  "zsecure",
	7174:  "clutild",
	7200:  "fodms",
	7201:  "dlip",
	7202:  "pon-ictp",
	7215:  "PS-Server",
	7216:  "PS-Capture-Pro",
	7227:  "ramp",
	7228:  "citrixupp",
	7229:  "citrixuppg",
	7236:  "display",
	7237:  "pads",
	7244:  "frc-hicp",
	7262:  "cnap",
	7272:  "watchme-7272",
	7273:  "oma-rlp",
	7274:  "oma-rlp-s",
	7275:  "oma-ulp",
	7276:  "oma-ilp",
	7277:  "oma-ilp-s",
	7278:  "oma-dcdocbs",
	7279:  "ctxlic",
	7280:  "itactionserver1",
	7281:  "itactionserver2",
	7282:  "mzca-action",
	7283:  "genstat",
	7365:  "lcm-server",
	7391:  "mindfilesys",
	7392:  "mrssrendezvous",
	7393:  "nfoldman",
	7394:  "fse",
	7395:  "winqedit",
	7397:  "hexarc",
	7400:  "rtps-discovery",
	7401:  "rtps-dd-ut",
	7402:  "rtps-dd-mt",
	7410:  "ionixnetmon",
	7411:  "daqstream",
	7421:  "mtportmon",
	7426:  "pmdmgr",
	7427:  "oveadmgr",
	7428:  "ovladmgr",
	7429:  "opi-sock",
	7430:  "xmpv7",
	7431:  "pmd",
	7437:  "faximum",
	7443:  "oracleas-https",
	7471:  "sttunnel",
	7473:  "rise",
	7474:  "neo4j",
	7478:  "openit",
	7491:  "telops-lmd",
	7500:  "silhouette",
	7501:  "ovbus",
	7508:  "adcp",
	7509:  "acplt",
	7510:  "ovhpas",
	7511:  "pafec-lm",
	7542:  "saratoga",
	7543:  "atul",
	7544:  "nta-ds",
	7545:  "nta-us",
	7546:  "cfs",
	7547:  "cwmp",
	7548:  "tidp",
	7549:  "nls-tl",
	7551:  "controlone-con",
	7560:  "sncp",
	7563:  "cfw",
	7566:  "vsi-omega",
	7569:  "dell-eql-asm",
	7570:  "aries-kfinder",
	7574:  "coherence",
	7588:  "sun-lm",
	7606:  "mipi-debug",
	7624:  "indi",
	7626:  "simco",
	7627:  "soap-http",
	7628:  "zen-pawn",
	7629:  "xdas",
	7630:  "hawk",
	7631:  "tesla-sys-msg",
	7633:  "pmdfmgt",
	7648:  "cuseeme",
	7672:  "imqstomp",
	7673:  "imqstomps",
	7674:  "imqtunnels",
	7675:  "imqtunnel",
	7676:  "imqbrokerd",
	7677:  "sun-user-https",
	7680:  "pando-pub",
	7683:  "dmt",
	7687:  "bolt",
	7689:  "collaber",
	7697:  "klio",
	7700:  "em7-secom",
	7707:  "sync-em7",
	7708:  "scinet",
	7720:  "medimageportal",
	7724:  "nsdeepfreezectl",
	7725:  "nitrogen",
	7726:  "freezexservice",
	7727:  "trident-data",
	7728:  "osvr",
	7734:  "smip",
	7738:  "aiagent",
	7741:  "scriptview",
	7742:  "msss",
	7743:  "sstp-1",
	7744:  "raqmon-pdu",
	7747:  "prgp",
	7775:  "inetfs",
	7777:  "cbt",
	7778:  "interwise",
	7779:  "vstat",
	7781:  "accu-lmgr",
	7786:  "minivend",
	7787:  "popup-reminders",
	7789:  "office-tools",
	7794:  "q3ade",
	7797:  "pnet-conn",
	7798:  "pnet-enc",
	7799:  "altbsdp",
	7800:  "asr",
	7801:  "ssp-client",
	7810:  "rbt-wanopt",
	7845:  "apc-7845",
	7846:  "apc-7846",
	7847:  "csoauth",
	7869:  "mobileanalyzer",
	7870:  "rbt-smc",
	7871:  "mdm",
	7878:  "owms",
	7880:  "pss",
	7887:  "ubroker",
	7900:  "mevent",
	7901:  "tnos-sp",
	7902:  "tnos-dp",
	7903:  "tnos-dps",
	7913:  "qo-secure",
	7932:  "t2-drm",
	7933:  "t2-brm",
	7962:  "generalsync",
	7967:  "supercell",
	7979:  "micromuse-ncps",
	7980:  "quest-vista",
	7981:  "sossd-collect",
	7982:  "sossd-agent",
	7997:  "pushns",
	7999:  "irdmi2",
	8000:  "irdmi",
	8001:  "vcom-tunnel",
	8002:  "teradataordbms",
	8003:  "mcreport",
	8005:  "mxi",
	8006:  "wpl-analytics",
	8007:  "warppipe",
	8008:  "http-alt",
	8019:  "qbdb",
	8020:  "intu-ec-svcdisc",
	8021:  "intu-ec-client",
	8022:  "oa-system",
	8025:  "ca-audit-da",
	8026:  "ca-audit-ds",
	8032:  "pro-ed",
	8033:  "mindprint",
	8034:  "vantronix-mgmt",
	8040:  "ampify",
	8041:  "enguity-xccetp",
	8042:  "fs-agent",
	8043:  "fs-server",
	8044:  "fs-mgmt",
	8051:  "rocrail",
	8052:  "senomix01",
	8053:  "senomix02",
	8054:  "senomix03",
	8055:  "senomix04",
	8056:  "senomix05",
	8057:  "senomix06",
	8058:  "senomix07",
	8059:  "senomix08",
	8066:  "toad-bi-appsrvr",
	8067:  "infi-async",
	8070:  "ucs-isc",
	8074:  "gadugadu",
	8077:  "mles",
	8080:  "http-alt",
	8081:  "sunproxyadmin",
	8082:  "us-cli",
	8083:  "us-srv",
	8086:  "d-s-n",
	8087:  "simplifymedia",
	8088:  "radan-http",
	8090:  "opsmessaging",
	8091:  "jamlink",
	8097:  "sac",
	8100:  "xprint-server",
	8101:  "ldoms-migr",
	8102:  "kz-migr",
	8115:  "mtl8000-matrix",
	8116:  "cp-cluster",
	8117:  "purityrpc",
	8118:  "privoxy",
	8121:  "apollo-data",
	8122:  "apollo-admin",
	8128:  "paycash-online",
	8129:  "paycash-wbp",
	8130:  "indigo-vrmi",
	8131:  "indigo-vbcp",
	8132:  "dbabble",
	8140:  "puppet",
	8148:  "isdd",
	8153:  "quantastor",
	8160:  "patrol",
	8161:  "patrol-snmp",
	8162:  "lpar2rrd",
	8181:  "intermapper",
	8182:  "vmware-fdm",
	8183:  "proremote",
	8184:  "itach",
	8190:  "gcp-rphy",
	8191:  "limnerpressure",
	8192:  "spytechphone",
	8194:  "blp1",
	8195:  "blp2",
	8199:  "vvr-data",
	8200:  "trivnet1",
	8201:  "trivnet2",
	8204:  "lm-perfworks",
	8205:  "lm-instmgr",
	8206:  "lm-dta",
	8207:  "lm-sserver",
	8208:  "lm-webwatcher",
	8230:  "rexecj",
	8243:  "synapse-nhttps",
	8270:  "robot-remote",
	8276:  "pando-sec",
	8280:  "synapse-nhttp",
	8282:  "libelle",
	8292:  "blp3",
	8293:  "hiperscan-id",
	8294:  "blp4",
	8300:  "tmi",
	8301:  "amberon",
	8313:  "hub-open-net",
	8320:  "tnp-discover",
	8321:  "tnp",
	8322:  "garmin-marine",
	8351:  "server-find",
	8376:  "cruise-enum",
	8377:  "cruise-swroute",
	8378:  "cruise-config",
	8379:  "cruise-diags",
	8380:  "cruise-update",
	8383:  "m2mservices",
	8400:  "cvd",
	8401:  "sabarsd",
	8402:  "abarsd",
	8403:  "admind",
	8404:  "svcloud",
	8405:  "svbackup",
	8415:  "dlpx-sp",
	8416:  "espeech",
	8417:  "espeech-rtp",
	8423:  "aritts",
	8442:  "cybro-a-bus",
	8443:  "pcsync-https",
	8444:  "pcsync-http",
	8445:  "copy",
	8450:  "npmp",
	8457:  "nexentamv",
	8470:  "cisco-avp",
	8471:  "pim-port",
	8472:  "otv",
	8473:  "vp2p",
	8474:  "noteshare",
	8500:  "fmtp",
	8501:  "cmtp-mgt",
	8502:  "ftnmtp",
	8554:  "rtsp-alt",
	8555:  "d-fence",
	8567:  "dof-tunnel",
	8600:  "asterix",
	8610:  "canon-mfnp",
	8611:  "canon-bjnp1",
	8612:  "canon-bjnp2",
	8613:  "canon-bjnp3",
	8614:  "canon-bjnp4",
	8615:  "imink",
	8665:  "monetra",
	8666:  "monetra-admin",
	8675:  "msi-cps-rm",
	8686:  "sun-as-jmxrmi",
	8688:  "openremote-ctrl",
	8699:  "vnyx",
	8711:  "nvc",
	8733:  "ibus",
	8750:  "dey-keyneg",
	8763:  "mc-appserver",
	8764:  "openqueue",
	8765:  "ultraseek-http",
	8766:  "amcs",
	8770:  "dpap",
	8778:  "uec",
	8786:  "msgclnt",
	8787:  "msgsrvr",
	8793:  "acd-pm",
	8800:  "sunwebadmin",
	8804:  "truecm",
	8873:  "dxspider",
	8880:  "cddbp-alt",
	8881:  "galaxy4d",
	8883:  "secure-mqtt",
	8888:  "ddi-tcp-1",
	8889:  "ddi-tcp-2",
	8890:  "ddi-tcp-3",
	8891:  "ddi-tcp-4",
	8892:  "ddi-tcp-5",
	8893:  "ddi-tcp-6",
	8894:  "ddi-tcp-7",
	8899:  "ospf-lite",
	8900:  "jmb-cds1",
	8901:  "jmb-cds2",
	8910:  "manyone-http",
	8911:  "manyone-xml",
	8912:  "wcbackup",
	8913:  "dragonfly",
	8937:  "twds",
	8953:  "ub-dns-control",
	8954:  "cumulus-admin",
	8980:  "nod-provider",
	8989:  "sunwebadmins",
	8990:  "http-wmap",
	8991:  "https-wmap",
	8997:  "oracle-ms-ens",
	8998:  "canto-roboflow",
	8999:  "bctp",
	9000:  "cslistener",
	9001:  "etlservicemgr",
	9002:  "dynamid",
	9005:  "golem",
	9008:  "ogs-server",
	9009:  "pichat",
	9010:  "sdr",
	9020:  "tambora",
	9021:  "panagolin-ident",
	9022:  "paragent",
	9023:  "swa-1",
	9024:  "swa-2",
	9025:  "swa-3",
	9026:  "swa-4",
	9050:  "versiera",
	9051:  "fio-cmgmt",
	9060:  "CardWeb-IO",
	9080:  "glrpc",
	9083:  "emc-pp-mgmtsvc",
	9084:  "aurora",
	9085:  "ibm-rsyscon",
	9086:  "net2display",
	9087:  "classic",
	9088:  "sqlexec",
	9089:  "sqlexec-ssl",
	9090:  "websm",
	9091:  "xmltec-xmlmail",
	9092:  "XmlIpcRegSvc",
	9093:  "copycat",
	9100:  "hp-pdl-datastr",
	9101:  "bacula-dir",
	9102:  "bacula-fd",
	9103:  "bacula-sd",
	9104:  "peerwire",
	9105:  "xadmin",
	9106:  "astergate",
	9107:  "astergatefax",
	9119:  "mxit",
	9122:  "grcmp",
	9123:  "grcp",
	9131:  "dddp",
	9160:  "apani1",
	9161:  "apani2",
	9162:  "apani3",
	9163:  "apani4",
	9164:  "apani5",
	9191:  "sun-as-jpda",
	9200:  "wap-wsp",
	9201:  "wap-wsp-wtp",
	9202:  "wap-wsp-s",
	9203:  "wap-wsp-wtp-s",
	9204:  "wap-vcard",
	9205:  "wap-vcal",
	9206:  "wap-vcard-s",
	9207:  "wap-vcal-s",
	9208:  "rjcdb-vcards",
	9209:  "almobile-system",
	9210:  "oma-mlp",
	9211:  "oma-mlp-s",
	9212:  "serverviewdbms",
	9213:  "serverstart",
	9214:  "ipdcesgbs",
	9215:  "insis",
	9216:  "acme",
	9217:  "fsc-port",
	9222:  "teamcoherence",
	9255:  "mon",
	9278:  "pegasus",
	9279:  "pegasus-ctl",
	9280:  "pgps",
	9281:  "swtp-port1",
	9282:  "swtp-port2",
	9283:  "callwaveiam",
	9284:  "visd",
	9285:  "n2h2server",
	9287:  "cumulus",
	9292:  "armtechdaemon",
	9293:  "storview",
	9294:  "armcenterhttp",
	9295:  "armcenterhttps",
	9300:  "vrace",
	9306:  "sphinxql",
	9312:  "sphinxapi",
	9318:  "secure-ts",
	9321:  "guibase",
	9343:  "mpidcmgr",
	9344:  "mphlpdmc",
	9345:  "rancher",
	9346:  "ctechlicensing",
	9374:  "fjdmimgr",
	9380:  "boxp",
	9387:  "d2dconfig",
	9388:  "d2ddatatrans",
	9389:  "adws",
	9390:  "otp",
	9396:  "fjinvmgr",
	9397:  "mpidcagt",
	9400:  "sec-t4net-srv",
	9401:  "sec-t4net-clt",
	9402:  "sec-pc2fax-srv",
	9418:  "git",
	9443:  "tungsten-https",
	9444:  "wso2esb-console",
	9445:  "mindarray-ca",
	9450:  "sntlkeyssrvr",
	9500:  "ismserver",
	9535:  "mngsuite",
	9536:  "laes-bf",
	9555:  "trispen-sra",
	9592:  "ldgateway",
	9593:  "cba8",
	9594:  "msgsys",
	9595:  "pds",
	9596:  "mercury-disc",
	9597:  "pd-admin",
	9598:  "vscp",
	9599:  "robix",
	9600:  "micromuse-ncpw",
	9612:  "streamcomm-ds",
	9614:  "iadt-tls",
	9616:  "erunbook-agent",
	9617:  "erunbook-server",
	9618:  "condor",
	9628:  "odbcpathway",
	9629:  "uniport",
	9630:  "peoctlr",
	9631:  "peocoll",
	9640:  "pqsflows",
	9666:  "zoomcp",
	9667:  "xmms2",
	9668:  "tec5-sdctp",
	9694:  "client-wakeup",
	9695:  "ccnx",
	9700:  "board-roar",
	9747:  "l5nas-parchan",
	9750:  "board-voip",
	9753:  "rasadv",
	9762:  "tungsten-http",
	9800:  "davsrc",
	9801:  "sstp-2",
	9802:  "davsrcs",
	9875:  "sapv1",
	9876:  "sd",
	9888:  "cyborg-systems",
	9889:  "gt-proxy",
	9898:  "monkeycom",
	9900:  "iua",
	9909:  "domaintime",
	9911:  "sype-transport",
	9925:  "xybrid-cloud",
	9950:  "apc-9950",
	9951:  "apc-9951",
	9952:  "apc-9952",
	9953:  "acis",
	9954:  "hinp",
	9955:  "alljoyn-stm",
	9966:  "odnsp",
	9978:  "xybrid-rt",
	9979:  "visweather",
	9981:  "pumpkindb",
	9987:  "dsm-scm-target",
	9988:  "nsesrvr",
	9990:  "osm-appsrvr",
	9991:  "osm-oev",
	9992:  "palace-1",
	9993:  "palace-2",
	9994:  "palace-3",
	9995:  "palace-4",
	9996:  "palace-5",
	9997:  "palace-6",
	9998:  "distinct32",
	9999:  "distinct",
	10000: "ndmp",
	10001: "scp-config",
	10002: "documentum",
	10003: "documentum-s",
	10004: "emcrmirccd",
	10005: "emcrmird",
	10006: "netapp-sync",
	10007: "mvs-capacity",
	10008: "octopus",
	10009: "swdtp-sv",
	10010: "rxapi",
	10020: "abb-hw",
	10050: "zabbix-agent",
	10051: "zabbix-trapper",
	10055: "qptlmd",
	10080: "amanda",
	10081: "famdc",
	10100: "itap-ddtp",
	10101: "ezmeeting-2",
	10102: "ezproxy-2",
	10103: "ezrelay",
	10104: "swdtp",
	10107: "bctp-server",
	10110: "nmea-0183",
	10113: "netiq-endpoint",
	10114: "netiq-qcheck",
	10115: "netiq-endpt",
	10116: "netiq-voipa",
	10117: "iqrm",
	10125: "cimple",
	10128: "bmc-perf-sd",
	10129: "bmc-gms",
	10160: "qb-db-server",
	10161: "snmptls",
	10162: "snmptls-trap",
	10200: "trisoap",
	10201: "rsms",
	10252: "apollo-relay",
	10260: "axis-wimp-port",
	10261: "tile-ml",
	10288: "blocks",
	10321: "cosir",
	10540: "MOS-lower",
	10541: "MOS-upper",
	10542: "MOS-aux",
	10543: "MOS-soap",
	10544: "MOS-soap-opt",
	10548: "serverdocs",
	10631: "printopia",
	10800: "gap",
	10805: "lpdg",
	10809: "nbd",
	10860: "helix",
	10880: "bveapi",
	10933: "octopustentacle",
	10990: "rmiaux",
	11000: "irisa",
	11001: "metasys",
	11095: "weave",
	11103: "origo-sync",
	11104: "netapp-icmgmt",
	11105: "netapp-icdata",
	11106: "sgi-lk",
	11109: "sgi-dmfmgr",
	11110: "sgi-soap",
	11111: "vce",
	11112: "dicom",
	11161: "suncacao-snmp",
	11162: "suncacao-jmxmp",
	11163: "suncacao-rmi",
	11164: "suncacao-csa",
	11165: "suncacao-websvc",
	11172: "oemcacao-jmxmp",
	11173: "t5-straton",
	11174: "oemcacao-rmi",
	11175: "oemcacao-websvc",
	11201: "smsqp",
	11202: "dcsl-backup",
	11208: "wifree",
	11211: "memcache",
	11319: "imip",
	11320: "imip-channels",
	11321: "arena-server",
	11367: "atm-uhas",
	11371: "hkp",
	11489: "asgcypresstcps",
	11600: "tempest-port",
	11623: "emc-xsw-dconfig",
	11720: "h323callsigalt",
	11723: "emc-xsw-dcache",
	11751: "intrepid-ssl",
	11796: "lanschool",
	11876: "xoraya",
	11967: "sysinfo-sp",
	12000: "entextxid",
	12001: "entextnetwk",
	12002: "entexthigh",
	12003: "entextmed",
	12004: "entextlow",
	12005: "dbisamserver1",
	12006: "dbisamserver2",
	12007: "accuracer",
	12008: "accuracer-dbms",
	12010: "edbsrvr",
	12012: "vipera",
	12013: "vipera-ssl",
	12109: "rets-ssl",
	12121: "nupaper-ss",
	12168: "cawas",
	12172: "hivep",
	12300: "linogridengine",
	12302: "rads",
	12321: "warehouse-sss",
	12322: "warehouse",
	12345: "italk",
	12753: "tsaf",
	12865: "netperf",
	13160: "i-zipqd",
	13216: "bcslogc",
	13217: "rs-pias",
	13218: "emc-vcas-tcp",
	13223: "powwow-client",
	13224: "powwow-server",
	13400: "doip-data",
	13720: "bprd",
	13721: "bpdbm",
	13722: "bpjava-msvc",
	13724: "vnetd",
	13782: "bpcd",
	13783: "vopied",
	13785: "nbdb",
	13786: "nomdb",
	13818: "dsmcc-config",
	13819: "dsmcc-session",
	13820: "dsmcc-passthru",
	13821: "dsmcc-download",
	13822: "dsmcc-ccp",
	13823: "bmdss",
	13894: "ucontrol",
	13929: "dta-systems",
	13930: "medevolve",
	14000: "scotty-ft",
	14001: "sua",
	14033: "sage-best-com1",
	14034: "sage-best-com2",
	14141: "vcs-app",
	14142: "icpp",
	14143: "icpps",
	14145: "gcm-app",
	14149: "vrts-tdd",
	14150: "vcscmd",
	14154: "vad",
	14250: "cps",
	14414: "ca-web-update",
	14500: "xpra",
	14936: "hde-lcesrvr-1",
	14937: "hde-lcesrvr-2",
	15000: "hydap",
	15002: "onep-tls",
	15345: "xpilot",
	15363: "3link",
	15555: "cisco-snat",
	15660: "bex-xr",
	15740: "ptp",
	15999: "programmar",
	16000: "fmsas",
	16001: "fmsascon",
	16002: "gsms",
	16020: "jwpc",
	16021: "jwpc-bin",
	16161: "sun-sea-port",
	16162: "solaris-audit",
	16309: "etb4j",
	16310: "pduncs",
	16311: "pdefmns",
	16360: "netserialext1",
	16361: "netserialext2",
	16367: "netserialext3",
	16368: "netserialext4",
	16384: "connected",
	16385: "rdgs",
	16619: "xoms",
	16665: "axon-tunnel",
	16789: "cadsisvr",
	16900: "newbay-snc-mc",
	16950: "sgcip",
	16991: "intel-rci-mp",
	16992: "amt-soap-http",
	16993: "amt-soap-https",
	16994: "amt-redir-tcp",
	16995: "amt-redir-tls",
	17007: "isode-dua",
	17184: "vestasdlp",
	17185: "soundsvirtual",
	17219: "chipper",
	17220: "avtp",
	17221: "avdecc",
	17223: "isa100-gci",
	17225: "trdp-md",
	17234: "integrius-stp",
	17235: "ssh-mgmt",
	17500: "db-lsp",
	17555: "ailith",
	17729: "ea",
	17754: "zep",
	17755: "zigbee-ip",
	17756: "zigbee-ips",
	17777: "sw-orion",
	18000: "biimenu",
	18104: "radpdf",
	18136: "racf",
	18181: "opsec-cvp",
	18182: "opsec-ufp",
	18183: "opsec-sam",
	18184: "opsec-lea",
	18185: "opsec-omi",
	18186: "ohsc",
	18187: "opsec-ela",
	18241: "checkpoint-rtm",
	18242: "iclid",
	18243: "clusterxl",
	18262: "gv-pf",
	18463: "ac-cluster",
	18634: "rds-ib",
	18635: "rds-ip",
	18668: "vdmmesh",
	18769: "ique",
	18881: "infotos",
	18888: "apc-necmp",
	19000: "igrid",
	19007: "scintilla",
	19020: "j-link",
	19191: "opsec-uaa",
	19194: "ua-secureagent",
	19220: "cora",
	19283: "keysrvr",
	19315: "keyshadow",
	19398: "mtrgtrans",
	19410: "hp-sco",
	19411: "hp-sca",
	19412: "hp-sessmon",
	19539: "fxuptp",
	19540: "sxuptp",
	19541: "jcp",
	19998: "iec-104-sec",
	19999: "dnp-sec",
	20000: "dnp",
	20001: "microsan",
	20002: "commtact-http",
	20003: "commtact-https",
	20005: "openwebnet",
	20013: "ss-idi",
	20014: "opendeploy",
	20034: "nburn-id",
	20046: "tmophl7mts",
	20048: "mountd",
	20049: "nfsrdma",
	20057: "avesterra",
	20167: "tolfab",
	20202: "ipdtp-port",
	20222: "ipulse-ics",
	20480: "emwavemsg",
	20670: "track",
	20999: "athand-mmp",
	21000: "irtrans",
	21010: "notezilla-lan",
	21221: "aigairserver",
	21553: "rdm-tfs",
	21554: "dfserver",
	21590: "vofr-gateway",
	21800: "tvpm",
	21845: "webphone",
	21846: "netspeak-is",
	21847: "netspeak-cs",
	21848: "netspeak-acd",
	21849: "netspeak-cps",
	22000: "snapenetio",
	22001: "optocontrol",
	22002: "optohost002",
	22003: "optohost003",
	22004: "optohost004",
	22005: "optohost004",
	22125: "dcap",
	22128: "gsidcap",
	22222: "easyengine",
	22273: "wnn6",
	22305: "cis",
	22335: "shrewd-control",
	22343: "cis-secure",
	22347: "wibukey",
	22350: "codemeter",
	22351: "codemeter-cmwan",
	22537: "caldsoft-backup",
	22555: "vocaltec-wconf",
	22763: "talikaserver",
	22800: "aws-brf",
	22951: "brf-gw",
	23000: "inovaport1",
	23001: "inovaport2",
	23002: "inovaport3",
	23003: "inovaport4",
	23004: "inovaport5",
	23005: "inovaport6",
	23053: "gntp",
	23294: "5afe-dir",
	23333: "elxmgmt",
	23400: "novar-dbase",
	23401: "novar-alarm",
	23402: "novar-global",
	23456: "aequus",
	23457: "aequus-alt",
	23546: "areaguard-neo",
	24000: "med-ltp",
	24001: "med-fsp-rx",
	24002: "med-fsp-tx",
	24003: "med-supp",
	24004: "med-ovw",
	24005: "med-ci",
	24006: "med-net-svc",
	24242: "filesphere",
	24249: "vista-4gl",
	24321: "ild",
	24386: "intel-rci",
	24465: "tonidods",
	24554: "binkp",
	24577: "bilobit",
	24666: "sdtvwcam",
	24676: "canditv",
	24677: "flashfiler",
	24678: "proactivate",
	24680: "tcc-http",
	24754: "cslg",
	24922: "find",
	25000: "icl-twobase1",
	25001: "icl-twobase2",
	25002: "icl-twobase3",
	25003: "icl-twobase4",
	25004: "icl-twobase5",
	25005: "icl-twobase6",
	25006: "icl-twobase7",
	25007: "icl-twobase8",
	25008: "icl-twobase9",
	25009: "icl-twobase10",
	25576: "sauterdongle",
	25604: "idtp",
	25793: "vocaltec-hos",
	25900: "tasp-net",
	25901: "niobserver",
	25902: "nilinkanalyst",
	25903: "niprobe",
	26000: "quake",
	26133: "scscp",
	26208: "wnn6-ds",
	26257: "cockroach",
	26260: "ezproxy",
	26261: "ezmeeting",
	26262: "k3software-svr",
	26263: "k3software-cli",
	26486: "exoline-tcp",
	26487: "exoconfig",
	26489: "exonet",
	27345: "imagepump",
	27442: "jesmsjc",
	27504: "kopek-httphead",
	27782: "ars-vista",
	27876: "astrolink",
	27999: "tw-auth-key",
	28000: "nxlmd",
	28001: "pqsp",
	28200: "voxelstorm",
	28240: "siemensgsm",
	28589: "bosswave",
	29167: "otmp",
	29999: "bingbang",
	30000: "ndmps",
	30001: "pago-services1",
	30002: "pago-services2",
	30003: "amicon-fpsu-ra",
	30100: "rwp",
	30260: "kingdomsonline",
	30400: "gs-realtime",
	30999: "ovobs",
	31016: "ka-sddp",
	31020: "autotrac-acp",
	31400: "pace-licensed",
	31416: "xqosd",
	31457: "tetrinet",
	31620: "lm-mon",
	31685: "dsx-monitor",
	31765: "gamesmith-port",
	31948: "iceedcp-tx",
	31949: "iceedcp-rx",
	32034: "iracinghelper",
	32249: "t1distproc60",
	32400: "plex",
	32483: "apm-link",
	32635: "sec-ntb-clnt",
	32636: "DMExpress",
	32767: "filenet-powsrm",
	32768: "filenet-tms",
	32769: "filenet-rpc",
	32770: "filenet-nch",
	32771: "filenet-rmi",
	32772: "filenet-pa",
	32773: "filenet-cm",
	32774: "filenet-re",
	32775: "filenet-pch",
	32776: "filenet-peior",
	32777: "filenet-obrok",
	32801: "mlsn",
	32811: "retp",
	32896: "idmgratm",
	33060: "mysqlx",
	33123: "aurora-balaena",
	33331: "diamondport",
	33333: "dgi-serv",
	33334: "speedtrace",
	33434: "traceroute",
	33656: "snip-slave",
	34249: "turbonote-2",
	34378: "p-net-local",
	34379: "p-net-remote",
	34567: "dhanalakshmi",
	34962: "profinet-rt",
	34963: "profinet-rtm",
	34964: "profinet-cm",
	34980: "ethercat",
	35000: "heathview",
	35001: "rt-viewer",
	35002: "rt-sound",
	35003: "rt-devicemapper",
	35004: "rt-classmanager",
	35005: "rt-labtracker",
	35006: "rt-helper",
	35100: "axio-disc",
	35354: "kitim",
	35355: "altova-lm",
	35356: "guttersnex",
	35357: "openstack-id",
	36001: "allpeers",
	36524: "febooti-aw",
	36602: "observium-agent",
	36700: "mapx",
	36865: "kastenxpipe",
	37475: "neckar",
	37483: "gdrive-sync",
	37601: "eftp",
	37654: "unisys-eportal",
	38000: "ivs-database",
	38001: "ivs-insertion",
	38002: "cresco-control",
	38201: "galaxy7-data",
	38202: "fairview",
	38203: "agpolicy",
	38800: "sruth",
	38865: "secrmmsafecopya",
	39681: "turbonote-1",
	40000: "safetynetp",
	40404: "sptx",
	40841: "cscp",
	40842: "csccredir",
	40843: "csccfirewall",
	41111: "fs-qos",
	41121: "tentacle",
	41230: "z-wave-s",
	41794: "crestron-cip",
	41795: "crestron-ctp",
	41796: "crestron-cips",
	41797: "crestron-ctps",
	42508: "candp",
	42509: "candrp",
	42510: "caerpc",
	43000: "recvr-rc",
	43188: "reachout",
	43189: "ndm-agent-port",
	43190: "ip-provision",
	43191: "noit-transport",
	43210: "shaperai",
	43439: "eq3-update",
	43440: "ew-mgmt",
	43441: "ciscocsdb",
	44123: "z-wave-tunnel",
	44321: "pmcd",
	44322: "pmcdproxy",
	44323: "pmwebapi",
	44444: "cognex-dataman",
	44553: "rbr-debug",
	44818: "EtherNet-IP-2",
	44900: "m3da",
	45000: "asmp",
	45001: "asmps",
	45002: "rs-status",
	45045: "synctest",
	45054: "invision-ag",
	45514: "cloudcheck",
	45678: "eba",
	45824: "dai-shell",
	45825: "qdb2service",
	45966: "ssr-servermgr",
	46336: "inedo",
	46998: "spremotetablet",
	46999: "mediabox",
	47000: "mbus",
	47001: "winrm",
	47557: "dbbrowse",
	47624: "directplaysrvr",
	47806: "ap",
	47808: "bacnet",
	48000: "nimcontroller",
	48001: "nimspooler",
	48002: "nimhub",
	48003: "nimgtw",
	48004: "nimbusdb",
	48005: "nimbusdbctrl",
	48049: "3gpp-cbsp",
	48050: "weandsf",
	48128: "isnetserv",
	48129: "blp5",
	48556: "com-bardac-dw",
	48619: "iqobject",
	48653: "robotraconteur",
	49000: "matahari",
	49001: "nusrp",
}
var udpPortNames = map[uint16]string{
	1:     "tcpmux",
	2:     "compressnet",
	3:     "compressnet",
	5:     "rje",
	7:     "echo",
	9:     "discard",
	11:    "systat",
	13:    "daytime",
	17:    "qotd",
	18:    "msp",
	19:    "chargen",
	20:    "ftp-data",
	21:    "ftp",
	22:    "ssh",
	23:    "telnet",
	25:    "smtp",
	27:    "nsw-fe",
	29:    "msg-icp",
	31:    "msg-auth",
	33:    "dsp",
	37:    "time",
	38:    "rap",
	39:    "rlp",
	41:    "graphics",
	42:    "name",
	43:    "nicname",
	44:    "mpm-flags",
	45:    "mpm",
	46:    "mpm-snd",
	48:    "auditd",
	49:    "tacacs",
	50:    "re-mail-ck",
	52:    "xns-time",
	53:    "domain",
	54:    "xns-ch",
	55:    "isi-gl",
	56:    "xns-auth",
	58:    "xns-mail",
	62:    "acas",
	63:    "whoispp",
	64:    "covia",
	65:    "tacacs-ds",
	66:    "sql-net",
	67:    "bootps",
	68:    "bootpc",
	69:    "tftp",
	70:    "gopher",
	71:    "netrjs-1",
	72:    "netrjs-2",
	73:    "netrjs-3",
	74:    "netrjs-4",
	76:    "deos",
	78:    "vettcp",
	79:    "finger",
	80:    "http",
	82:    "xfer",
	83:    "mit-ml-dev",
	84:    "ctf",
	85:    "mit-ml-dev",
	86:    "mfcobol",
	88:    "kerberos",
	89:    "su-mit-tg",
	90:    "dnsix",
	91:    "mit-dov",
	92:    "npp",
	93:    "dcp",
	94:    "objcall",
	95:    "supdup",
	96:    "dixie",
	97:    "swift-rvf",
	98:    "tacnews",
	99:    "metagram",
	101:   "hostname",
	102:   "iso-tsap",
	103:   "gppitnp",
	104:   "acr-nema",
	105:   "cso",
	106:   "3com-tsmux",
	107:   "rtelnet",
	108:   "snagas",
	109:   "pop2",
	110:   "pop3",
	111:   "sunrpc",
	112:   "mcidas",
	113:   "auth",
	115:   "sftp",
	116:   "ansanotify",
	117:   "uucp-path",
	118:   "sqlserv",
	119:   "nntp",
	120:   "cfdptkt",
	121:   "erpc",
	122:   "smakynet",
	123:   "ntp",
	124:   "ansatrader",
	125:   "locus-map",
	126:   "nxedit",
	127:   "locus-con",
	128:   "gss-xlicen",
	129:   "pwdgen",
	130:   "cisco-fna",
	131:   "cisco-tna",
	132:   "cisco-sys",
	133:   "statsrv",
	134:   "ingres-net",
	135:   "epmap",
	136:   "profile",
	137:   "netbios-ns",
	138:   "netbios-dgm",
	139:   "netbios-ssn",
	140:   "emfis-data",
	141:   "emfis-cntl",
	142:   "bl-idm",
	143:   "imap",
	144:   "uma",
	145:   "uaac",
	146:   "iso-tp0",
	147:   "iso-ip",
	148:   "jargon",
	149:   "aed-512",
	150:   "sql-net",
	151:   "hems",
	152:   "bftp",
	153:   "sgmp",
	154:   "netsc-prod",
	155:   "netsc-dev",
	156:   "sqlsrv",
	157:   "knet-cmp",
	158:   "pcmail-srv",
	159:   "nss-routing",
	160:   "sgmp-traps",
	161:   "snmp",
	162:   "snmptrap",
	163:   "cmip-man",
	164:   "cmip-agent",
	165:   "xns-courier",
	166:   "s-net",
	167:   "namp",
	168:   "rsvd",
	169:   "send",
	170:   "print-srv",
	171:   "multiplex",
	172:   "cl-1",
	173:   "xyplex-mux",
	174:   "mailq",
	175:   "vmnet",
	176:   "genrad-mux",
	177:   "xdmcp",
	178:   "nextstep",
	179:   "bgp",
	180:   "ris",
	181:   "unify",
	182:   "audit",
	183:   "ocbinder",
	184:   "ocserver",
	185:   "remote-kis",
	186:   "kis",
	187:   "aci",
	188:   "mumps",
	189:   "qft",
	190:   "gacp",
	191:   "prospero",
	192:   "osu-nms",
	193:   "srmp",
	194:   "irc",
	195:   "dn6-nlm-aud",
	196:   "dn6-smm-red",
	197:   "dls",
	198:   "dls-mon",
	199:   "smux",
	200:   "src",
	201:   "at-rtmp",
	202:   "at-nbp",
	203:   "at-3",
	204:   "at-echo",
	205:   "at-5",
	206:   "at-zis",
	207:   "at-7",
	208:   "at-8",
	209:   "qmtp",
	210:   "z39-50",
	211:   "914c-g",
	212:   "anet",
	213:   "ipx",
	214:   "vmpwscs",
	215:   "softpc",
	216:   "CAIlic",
	217:   "dbase",
	218:   "mpp",
	219:   "uarps",
	220:   "imap3",
	221:   "fln-spx",
	222:   "rsh-spx",
	223:   "cdc",
	224:   "masqdialer",
	242:   "direct",
	243:   "sur-meas",
	244:   "inbusiness",
	245:   "link",
	246:   "dsp3270",
	247:   "subntbcst-tftp",
	248:   "bhfhs",
	256:   "rap",
	257:   "set",
	259:   "esro-gen",
	260:   "openport",
	261:   "nsiiops",
	262:   "arcisdms",
	263:   "hdap",
	264:   "bgmp",
	265:   "x-bone-ctl",
	266:   "sst",
	267:   "td-service",
	268:   "td-replica",
	269:   "manet",
	270:   "gist",
	280:   "http-mgmt",
	281:   "personal-link",
	282:   "cableport-ax",
	283:   "rescap",
	284:   "corerjd",
	286:   "fxp",
	287:   "k-block",
	308:   "novastorbakcup",
	309:   "entrusttime",
	310:   "bhmds",
	311:   "asip-webadmin",
	312:   "vslmp",
	313:   "magenta-logic",
	314:   "opalis-robot",
	315:   "dpsi",
	316:   "decauth",
	317:   "zannet",
	318:   "pkix-timestamp",
	319:   "ptp-event",
	320:   "ptp-general",
	321:   "pip",
	322:   "rtsps",
	333:   "texar",
	344:   "pdap",
	345:   "pawserv",
	346:   "zserv",
	347:   "fatserv",
	348:   "csi-sgwp",
	349:   "mftp",
	350:   "matip-type-a",
	351:   "matip-type-b",
	352:   "dtag-ste-sb",
	353:   "ndsauth",
	354:   "bh611",
	355:   "datex-asn",
	356:   "cloanto-net-1",
	357:   "bhevent",
	358:   "shrinkwrap",
	359:   "nsrmp",
	360:   "scoi2odialog",
	361:   "semantix",
	362:   "srssend",
	363:   "rsvp-tunnel",
	364:   "aurora-cmgr",
	365:   "dtk",
	366:   "odmr",
	367:   "mortgageware",
	368:   "qbikgdp",
	369:   "rpc2portmap",
	370:   "codaauth2",
	371:   "clearcase",
	372:   "ulistproc",
	373:   "legent-1",
	374:   "legent-2",
	375:   "hassle",
	376:   "nip",
	377:   "tnETOS",
	378:   "dsETOS",
	379:   "is99c",
	380:   "is99s",
	381:   "hp-collector",
	382:   "hp-managed-node",
	383:   "hp-alarm-mgr",
	384:   "arns",
	385:   "ibm-app",
	386:   "asa",
	387:   "aurp",
	388:   "unidata-ldm",
	389:   "ldap",
	390:   "uis",
	391:   "synotics-relay",
	392:   "synotics-broker",
	393:   "meta5",
	394:   "embl-ndt",
	395:   "netcp",
	396:   "netware-ip",
	397:   "mptn",
	398:   "kryptolan",
	399:   "iso-tsap-c2",
	400:   "osb-sd",
	401:   "ups",
	402:   "genie",
	403:   "decap",
	404:   "nced",
	405:   "ncld",
	406:   "imsp",
	407:   "timbuktu",
	408:   "prm-sm",
	409:   "prm-nm",
	410:   "decladebug",
	411:   "rmt",
	412:   "synoptics-trap",
	413:   "smsp",
	414:   "infoseek",
	415:   "bnet",
	416:   "silverplatter",
	417:   "onmux",
	418:   "hyper-g",
	419:   "ariel1",
	420:   "smpte",
	421:   "ariel2",
	422:   "ariel3",
	423:   "opc-job-start",
	424:   "opc-job-track",
	425:   "icad-el",
	426:   "smartsdp",
	427:   "svrloc",
	428:   "ocs-cmu",
	429:   "ocs-amu",
	430:   "utmpsd",
	431:   "utmpcd",
	432:   "iasd",
	433:   "nnsp",
	434:   "mobileip-agent",
	435:   "mobilip-mn",
	436:   "dna-cml",
	437:   "comscm",
	438:   "dsfgw",
	439:   "dasp",
	440:   "sgcp",
	441:   "decvms-sysmgt",
	442:   "cvc-hostd",
	443:   "https",
	444:   "snpp",
	445:   "microsoft-ds",
	446:   "ddm-rdb",
	447:   "ddm-dfm",
	448:   "ddm-ssl",
	449:   "as-servermap",
	450:   "tserver",
	451:   "sfs-smp-net",
	452:   "sfs-config",
	453:   "creativeserver",
	454:   "contentserver",
	455:   "creativepartnr",
	456:   "macon-udp",
	457:   "scohelp",
	458:   "appleqtc",
	459:   "ampr-rcmd",
	460:   "skronk",
	461:   "datasurfsrv",
	462:   "datasurfsrvsec",
	463:   "alpes",
	464:   "kpasswd",
	465:   "igmpv3lite",
	466:   "digital-vrc",
	467:   "mylex-mapd",
	468:   "photuris",
	469:   "rcp",
	470:   "scx-proxy",
	471:   "mondex",
	472:   "ljk-login",
	473:   "hybrid-pop",
	474:   "tn-tl-w2",
	475:   "tcpnethaspsrv",
	476:   "tn-tl-fd1",
	477:   "ss7ns",
	478:   "spsc",
	479:   "iafserver",
	480:   "iafdbase",
	481:   "ph",
	482:   "bgs-nsi",
	483:   "ulpnet",
	484:   "integra-sme",
	485:   "powerburst",
	486:   "avian",
	487:   "saft",
	488:   "gss-http",
	489:   "nest-protocol",
	490:   "micom-pfs",
	491:   "go-login",
	492:   "ticf-1",
	493:   "ticf-2",
	494:   "pov-ray",
	495:   "intecourier",
	496:   "pim-rp-disc",
	497:   "retrospect",
	498:   "siam",
	499:   "iso-ill",
	500:   "isakmp",
	501:   "stmf",
	502:   "mbap",
	503:   "intrinsa",
	504:   "citadel",
	505:   "mailbox-lm",
	506:   "ohimsrv",
	507:   "crs",
	508:   "xvttp",
	509:   "snare",
	510:   "fcp",
	511:   "passgo",
	512:   "comsat",
	513:   "who",
	514:   "syslog",
	515:   "printer",
	516:   "videotex",
	517:   "talk",
	518:   "ntalk",
	519:   "utime",
	520:   "router",
	521:   "ripng",
	522:   "ulp",
	523:   "ibm-db2",
	524:   "ncp",
	525:   "timed",
	526:   "tempo",
	527:   "stx",
	528:   "custix",
	529:   "irc-serv",
	530:   "courier",
	531:   "conference",
	532:   "netnews",
	533:   "netwall",
	534:   "windream",
	535:   "iiop",
	536:   "opalis-rdv",
	537:   "nmsp",
	538:   "gdomap",
	539:   "apertus-ldp",
	540:   "uucp",
	541:   "uucp-rlogin",
	542:   "commerce",
	543:   "klogin",
	544:   "kshell",
	545:   "appleqtcsrvr",
	546:   "dhcpv6-client",
	547:   "dhcpv6-server",
	548:   "afpovertcp",
	549:   "idfp",
	550:   "new-rwho",
	551:   "cybercash",
	552:   "devshr-nts",
	553:   "pirp",
	554:   "rtsp",
	555:   "dsf",
	556:   "remotefs",
	557:   "openvms-sysipc",
	558:   "sdnskmp",
	559:   "teedtap",
	560:   "rmonitor",
	561:   "monitor",
	562:   "chshell",
	563:   "nntps",
	564:   "9pfs",
	565:   "whoami",
	566:   "streettalk",
	567:   "banyan-rpc",
	568:   "ms-shuttle",
	569:   "ms-rome",
	570:   "meter",
	571:   "meter",
	572:   "sonar",
	573:   "banyan-vip",
	574:   "ftp-agent",
	575:   "vemmi",
	576:   "ipcd",
	577:   "vnas",
	578:   "ipdd",
	579:   "decbsrv",
	580:   "sntp-heartbeat",
	581:   "bdp",
	582:   "scc-security",
	583:   "philips-vc",
	584:   "keyserver",
	586:   "password-chg",
	587:   "submission",
	588:   "cal",
	589:   "eyelink",
	590:   "tns-cml",
	591:   "http-alt",
	592:   "eudora-set",
	593:   "http-rpc-epmap",
	594:   "tpip",
	595:   "cab-protocol",
	596:   "smsd",
	597:   "ptcnameservice",
	598:   "sco-websrvrmg3",
	599:   "acp",
	600:   "ipcserver",
	601:   "syslog-conn",
	602:   "xmlrpc-beep",
	603:   "idxp",
	604:   "tunnel",
	605:   "soap-beep",
	606:   "urm",
	607:   "nqs",
	608:   "sift-uft",
	609:   "npmp-trap",
	610:   "npmp-local",
	611:   "npmp-gui",
	612:   "hmmp-ind",
	613:   "hmmp-op",
	614:   "sshell",
	615:   "sco-inetmgr",
	616:   "sco-sysmgr",
	617:   "sco-dtmgr",
	618:   "dei-icda",
	619:   "compaq-evm",
	620:   "sco-websrvrmgr",
	621:   "escp-ip",
	622:   "collaborator",
	623:   "asf-rmcp",
	624:   "cryptoadmin",
	625:   "dec-dlm",
	626:   "asia",
	627:   "passgo-tivoli",
	628:   "qmqp",
	629:   "3com-amp3",
	630:   "rda",
	631:   "ipp",
	632:   "bmpp",
	633:   "servstat",
	634:   "ginad",
	635:   "rlzdbase",
	636:   "ldaps",
	637:   "lanserver",
	638:   "mcns-sec",
	639:   "msdp",
	640:   "entrust-sps",
	641:   "repcmd",
	642:   "esro-emsdp",
	643:   "sanity",
	644:   "dwr",
	645:   "pssc",
	646:   "ldp",
	647:   "dhcp-failover",
	648:   "rrp",
	649:   "cadview-3d",
	650:   "obex",
	651:   "ieee-mms",
	652:   "hello-port",
	653:   "repscmd",
	654:   "aodv",
	655:   "tinc",
	656:   "spmp",
	657:   "rmc",
	658:   "tenfold",
	660:   "mac-srvr-admin",
	661:   "hap",
	662:   "pftp",
	663:   "purenoise",
	664:   "asf-secure-rmcp",
	665:   "sun-dr",
	666:   "mdqs",
	667:   "disclose",
	668:   "mecomm",
	669:   "meregister",
	670:   "vacdsm-sws",
	671:   "vacdsm-app",
	672:   "vpps-qua",
	673:   "cimplex",
	674:   "acap",
	675:   "dctp",
	676:   "vpps-via",
	677:   "vpp",
	678:   "ggf-ncp",
	679:   "mrm",
	680:   "entrust-aaas",
	681:   "entrust-aams",
	682:   "xfr",
	683:   "corba-iiop",
	684:   "corba-iiop-ssl",
	685:   "mdc-portmapper",
	686:   "hcp-wismar",
	687:   "asipregistry",
	688:   "realm-rusd",
	689:   "nmap",
	690:   "vatp",
	691:   "msexch-routing",
	692:   "hyperwave-isp",
	693:   "connendp",
	694:   "ha-cluster",
	695:   "ieee-mms-ssl",
	696:   "rushd",
	697:   "uuidgen",
	698:   "olsr",
	699:   "accessnetwork",
	700:   "epp",
	701:   "lmp",
	702:   "iris-beep",
	704:   "elcsd",
	705:   "agentx",
	706:   "silc",
	707:   "borland-dsj",
	709:   "entrust-kmsh",
	710:   "entrust-ash",
	711:   "cisco-tdp",
	712:   "tbrpf",
	713:   "iris-xpc",
	714:   "iris-xpcs",
	715:   "iris-lwz",
	716:   "pana",
	729:   "netviewdm1",
	730:   "netviewdm2",
	731:   "netviewdm3",
	741:   "netgw",
	742:   "netrcs",
	744:   "flexlm",
	747:   "fujitsu-dev",
	748:   "ris-cm",
	749:   "kerberos-adm",
	750:   "loadav",
	751:   "pump",
	752:   "qrh",
	753:   "rrh",
	754:   "tell",
	758:   "nlogin",
	759:   "con",
	760:   "ns",
	761:   "rxe",
	762:   "quotad",
	763:   "cycleserv",
	764:   "omserv",
	765:   "webster",
	767:   "phonebook",
	769:   "vid",
	770:   "cadlock",
	771:   "rtip",
	772:   "cycleserv2",
	773:   "notify",
	774:   "acmaint-dbd",
	775:   "acmaint-transd",
	776:   "wpages",
	777:   "multiling-http",
	780:   "wpgs",
	800:   "mdbs-daemon",
	801:   "device",
	802:   "mbap-s",
	810:   "fcp-udp",
	828:   "itm-mcell-s",
	829:   "pkix-3-ca-ra",
	830:   "netconf-ssh",
	831:   "netconf-beep",
	832:   "netconfsoaphttp",
	833:   "netconfsoapbeep",
	847:   "dhcp-failover2",
	848:   "gdoi",
	853:   "domain-s",
	854:   "dlep",
	860:   "iscsi",
	861:   "owamp-control",
	862:   "twamp-control",
	873:   "rsync",
	886:   "iclcnet-locate",
	887:   "iclcnet-svinfo",
	888:   "accessbuilder",
	900:   "omginitialrefs",
	901:   "smpnameres",
	902:   "ideafarm-door",
	903:   "ideafarm-panic",
	910:   "kink",
	911:   "xact-backup",
	912:   "apex-mesh",
	913:   "apex-edge",
	989:   "ftps-data",
	990:   "ftps",
	991:   "nas",
	992:   "telnets",
	993:   "imaps",
	995:   "pop3s",
	996:   "vsinet",
	997:   "maitrd",
	998:   "puparp",
	999:   "applix",
	1000:  "cadlock2",
	1010:  "surf",
	1021:  "exp1",
	1022:  "exp2",
	1025:  "blackjack",
	1026:  "cap",
	1027:  "6a44",
	1029:  "solid-mux",
	1033:  "netinfo-local",
	1034:  "activesync",
	1035:  "mxxrlogin",
	1036:  "nsstp",
	1037:  "ams",
	1038:  "mtqp",
	1039:  "sbl",
	1040:  "netarx",
	1041:  "danf-ak2",
	1042:  "afrog",
	1043:  "boinc-client",
	1044:  "dcutility",
	1045:  "fpitp",
	1046:  "wfremotertm",
	1047:  "neod1",
	1048:  "neod2",
	1049:  "td-postman",
	1050:  "cma",
	1051:  "optima-vnet",
	1052:  "ddt",
	1053:  "remote-as",
	1054:  "brvread",
	1055:  "ansyslmd",
	1056:  "vfo",
	1057:  "startron",
	1058:  "nim",
	1059:  "nimreg",
	1060:  "polestar",
	1061:  "kiosk",
	1062:  "veracity",
	1063:  "kyoceranetdev",
	1064:  "jstel",
	1065:  "syscomlan",
	1066:  "fpo-fns",
	1067:  "instl-boots",
	1068:  "instl-bootc",
	1069:  "cognex-insight",
	1070:  "gmrupdateserv",
	1071:  "bsquare-voip",
	1072:  "cardax",
	1073:  "bridgecontrol",
	1074:  "warmspotMgmt",
	1075:  "rdrmshc",
	1076:  "dab-sti-c",
	1077:  "imgames",
	1078:  "avocent-proxy",
	1079:  "asprovatalk",
	1080:  "socks",
	1081:  "pvuniwien",
	1082:  "amt-esd-prot",
	1083:  "ansoft-lm-1",
	1084:  "ansoft-lm-2",
	1085:  "webobjects",
	1086:  "cplscrambler-lg",
	1087:  "cplscrambler-in",
	1088:  "cplscrambler-al",
	1089:  "ff-annunc",
	1090:  "ff-fms",
	1091:  "ff-sm",
	1092:  "obrpd",
	1093:  "proofd",
	1094:  "rootd",
	1095:  "nicelink",
	1096:  "cnrprotocol",
	1097:  "sunclustermgr",
	1098:  "rmiactivation",
	1099:  "rmiregistry",
	1100:  "mctp",
	1101:  "pt2-discover",
	1102:  "adobeserver-1",
	1103:  "adobeserver-2",
	1104:  "xrl",
	1105:  "ftranhc",
	1106:  "isoipsigport-1",
	1107:  "isoipsigport-2",
	1108:  "ratio-adp",
	1110:  "nfsd-keepalive",
	1111:  "lmsocialserver",
	1112:  "icp",
	1113:  "ltp-deepspace",
	1114:  "mini-sql",
	1115:  "ardus-trns",
	1116:  "ardus-cntl",
	1117:  "ardus-mtrns",
	1118:  "sacred",
	1119:  "bnetgame",
	1120:  "bnetfile",
	1121:  "rmpp",
	1122:  "availant-mgr",
	1123:  "murray",
	1124:  "hpvmmcontrol",
	1125:  "hpvmmagent",
	1126:  "hpvmmdata",
	1127:  "kwdb-commn",
	1128:  "saphostctrl",
	1129:  "saphostctrls",
	1130:  "casp",
	1131:  "caspssl",
	1132:  "kvm-via-ip",
	1133:  "dfn",
	1134:  "aplx",
	1135:  "omnivision",
	1136:  "hhb-gateway",
	1137:  "trim",
	1138:  "encrypted-admin",
	1139:  "evm",
	1140:  "autonoc",
	1141:  "mxomss",
	1142:  "edtools",
	1143:  "imyx",
	1144:  "fuscript",
	1145:  "x9-icue",
	1146:  "audit-transfer",
	1147:  "capioverlan",
	1148:  "elfiq-repl",
	1149:  "bvtsonar",
	1150:  "blaze",
	1151:  "unizensus",
	1152:  "winpoplanmess",
	1153:  "c1222-acse",
	1154:  "resacommunity",
	1155:  "nfa",
	1156:  "iascontrol-oms",
	1157:  "iascontrol",
	1158:  "dbcontrol-oms",
	1159:  "oracle-oms",
	1160:  "olsv",
	1161:  "health-polling",
	1162:  "health-trap",
	1163:  "sddp",
	1164:  "qsm-proxy",
	1165:  "qsm-gui",
	1166:  "qsm-remote",
	1167:  "cisco-ipsla",
	1168:  "vchat",
	1169:  "tripwire",
	1170:  "atc-lm",
	1171:  "atc-appserver",
	1172:  "dnap",
	1173:  "d-cinema-rrp",
	1174:  "fnet-remote-ui",
	1175:  "dossier",
	1176:  "indigo-server",
	1177:  "dkmessenger",
	1178:  "sgi-storman",
	1179:  "b2n",
	1180:  "mc-client",
	1181:  "3comnetman",
	1182:  "accelenet-data",
	1183:  "llsurfup-http",
	1184:  "llsurfup-https",
	1185:  "catchpole",
	1186:  "mysql-cluster",
	1187:  "alias",
	1188:  "hp-webadmin",
	1189:  "unet",
	1190:  "commlinx-avl",
	1191:  "gpfs",
	1192:  "caids-sensor",
	1193:  "fiveacross",
	1194:  "openvpn",
	1195:  "rsf-1",
	1196:  "netmagic",
	1197:  "carrius-rshell",
	1198:  "cajo-discovery",
	1199:  "dmidi",
	1200:  "scol",
	1201:  "nucleus-sand",
	1202:  "caiccipc",
	1203:  "ssslic-mgr",
	1204:  "ssslog-mgr",
	1205:  "accord-mgc",
	1206:  "anthony-data",
	1207:  "metasage",
	1208:  "seagull-ais",
	1209:  "ipcd3",
	1210:  "eoss",
	1211:  "groove-dpp",
	1212:  "lupa",
	1213:  "mpc-lifenet",
	1214:  "kazaa",
	1215:  "scanstat-1",
	1216:  "etebac5",
	1217:  "hpss-ndapi",
	1218:  "aeroflight-ads",
	1219:  "aeroflight-ret",
	1220:  "qt-serveradmin",
	1221:  "sweetware-apps",
	1222:  "nerv",
	1223:  "tgp",
	1224:  "vpnz",
	1225:  "slinkysearch",
	1226:  "stgxfws",
	1227:  "dns2go",
	1228:  "florence",
	1229:  "zented",
	1230:  "periscope",
	1231:  "menandmice-lpm",
	1232:  "first-defense",
	1233:  "univ-appserver",
	1234:  "search-agent",
	1235:  "mosaicsyssvc1",
	1236:  "bvcontrol",
	1237:  "tsdos390",
	1238:  "hacl-qs",
	1239:  "nmsd",
	1240:  "instantia",
	1241:  "nessus",
	1242:  "nmasoverip",
	1243:  "serialgateway",
	1244:  "isbconference1",
	1245:  "isbconference2",
	1246:  "payrouter",
	1247:  "visionpyramid",
	1248:  "hermes",
	1249:  "mesavistaco",
	1250:  "swldy-sias",
	1251:  "servergraph",
	1252:  "bspne-pcc",
	1253:  "q55-pcc",
	1254:  "de-noc",
	1255:  "de-cache-query",
	1256:  "de-server",
	1257:  "shockwave2",
	1258:  "opennl",
	1259:  "opennl-voice",
	1260:  "ibm-ssd",
	1261:  "mpshrsv",
	1262:  "qnts-orb",
	1263:  "dka",
	1264:  "prat",
	1265:  "dssiapi",
	1266:  "dellpwrappks",
	1267:  "epc",
	1268:  "propel-msgsys",
	1269:  "watilapp",
	1270:  "opsmgr",
	1271:  "excw",
	1272:  "cspmlockmgr",
	1273:  "emc-gateway",
	1274:  "t1distproc",
	1275:  "ivcollector",
	1277:  "miva-mqs",
	1278:  "dellwebadmin-1",
	1279:  "dellwebadmin-2",
	1280:  "pictrography",
	1281:  "healthd",
	1282:  "emperion",
	1283:  "productinfo",
	1284:  "iee-qfx",
	1285:  "neoiface",
	1286:  "netuitive",
	1287:  "routematch",
	1288:  "navbuddy",
	1289:  "jwalkserver",
	1290:  "winjaserver",
	1291:  "seagulllms",
	1292:  "dsdn",
	1293:  "pkt-krb-ipsec",
	1294:  "cmmdriver",
	1295:  "ehtp",
	1296:  "dproxy",
	1297:  "sdproxy",
	1298:  "lpcp",
	1299:  "hp-sci",
	1300:  "h323hostcallsc",
	1301:  "ci3-software-1",
	1302:  "ci3-software-2",
	1303:  "sftsrv",
	1304:  "boomerang",
	1305:  "pe-mike",
	1306:  "re-conn-proto",
	1307:  "pacmand",
	1308:  "odsi",
	1309:  "jtag-server",
	1310:  "husky",
	1311:  "rxmon",
	1312:  "sti-envision",
	1313:  "bmc-patroldb",
	1314:  "pdps",
	1315:  "els",
	1316:  "exbit-escp",
	1317:  "vrts-ipcserver",
	1318:  "krb5gatekeeper",
	1319:  "amx-icsp",
	1320:  "amx-axbnet",
	1321:  "pip",
	1322:  "novation",
	1323:  "brcd",
	1324:  "delta-mcp",
	1325:  "dx-instrument",
	1326:  "wimsic",
	1327:  "ultrex",
	1328:  "ewall",
	1329:  "netdb-export",
	1330:  "streetperfect",
	1331:  "intersan",
	1332:  "pcia-rxp-b",
	1333:  "passwrd-policy",
	1334:  "writesrv",
	1335:  "digital-notary",
	1336:  "ischat",
	1337:  "menandmice-dns",
	1338:  "wmc-log-svc",
	1339:  "kjtsiteserver",
	1340:  "naap",
	1341:  "qubes",
	1342:  "esbroker",
	1343:  "re101",
	1344:  "icap",
	1345:  "vpjp",
	1346:  "alta-ana-lm",
	1347:  "bbn-mmc",
	1348:  "bbn-mmx",
	1349:  "sbook",
	1350:  "editbench",
	1351:  "equationbuilder",
	1352:  "lotusnote",
	1353:  "relief",
	1354:  "XSIP-network",
	1355:  "intuitive-edge",
	1356:  "cuillamartin",
	1357:  "pegboard",
	1358:  "connlcli",
	1359:  "ftsrv",
	1360:  "mimer",
	1361:  "linx",
	1362:  "timeflies",
	1363:  "ndm-requester",
	1364:  "ndm-server",
	1365:  "adapt-sna",
	1366:  "netware-csp",
	1367:  "dcs",
	1368:  "screencast",
	1369:  "gv-us",
	1370:  "us-gv",
	1371:  "fc-cli",
	1372:  "fc-ser",
	1373:  "chromagrafx",
	1374:  "molly",
	1375:  "bytex",
	1376:  "ibm-pps",
	1377:  "cichlid",
	1378:  "elan",
	1379:  "dbreporter",
	1380:  "telesis-licman",
	1381:  "apple-licman",
	1382:  "udt-os",
	1383:  "gwha",
	1384:  "os-licman",
	1385:  "atex-elmd",
	1386:  "checksum",
	1387:  "cadsi-lm",
	1388:  "objective-dbc",
	1389:  "iclpv-dm",
	1390:  "iclpv-sc",
	1391:  "iclpv-sas",
	1392:  "iclpv-pm",
	1393:  "iclpv-nls",
	1394:  "iclpv-nlc",
	1395:  "iclpv-wsm",
	1396:  "dvl-activemail",
	1397:  "audio-activmail",
	1398:  "video-activmail",
	1399:  "cadkey-licman",
	1400:  "cadkey-tablet",
	1401:  "goldleaf-licman",
	1402:  "prm-sm-np",
	1403:  "prm-nm-np",
	1404:  "igi-lm",
	1405:  "ibm-res",
	1406:  "netlabs-lm",
	1408:  "sophia-lm",
	1409:  "here-lm",
	1410:  "hiq",
	1411:  "af",
	1412:  "innosys",
	1413:  "innosys-acl",
	1414:  "ibm-mqseries",
	1415:  "dbstar",
	1416:  "novell-lu6-2",
	1417:  "timbuktu-srv1",
	1418:  "timbuktu-srv2",
	1419:  "timbuktu-srv3",
	1420:  "timbuktu-srv4",
	1421:  "gandalf-lm",
	1422:  "autodesk-lm",
	1423:  "essbase",
	1424:  "hybrid",
	1425:  "zion-lm",
	1426:  "sais",
	1427:  "mloadd",
	1428:  "informatik-lm",
	1429:  "nms",
	1430:  "tpdu",
	1431:  "rgtp",
	1432:  "blueberry-lm",
	1433:  "ms-sql-s",
	1434:  "ms-sql-m",
	1435:  "ibm-cics",
	1436:  "saism",
	1437:  "tabula",
	1438:  "eicon-server",
	1439:  "eicon-x25",
	1440:  "eicon-slp",
	1441:  "cadis-1",
	1442:  "cadis-2",
	1443:  "ies-lm",
	1444:  "marcam-lm",
	1445:  "proxima-lm",
	1446:  "ora-lm",
	1447:  "apri-lm",
	1448:  "oc-lm",
	1449:  "peport",
	1450:  "dwf",
	1451:  "infoman",
	1452:  "gtegsc-lm",
	1453:  "genie-lm",
	1454:  "interhdl-elmd",
	1455:  "esl-lm",
	1456:  "dca",
	1457:  "valisys-lm",
	1458:  "nrcabq-lm",
	1459:  "proshare1",
	1460:  "proshare2",
	1461:  "ibm-wrless-lan",
	1462:  "world-lm",
	1463:  "nucleus",
	1464:  "msl-lmd",
	1465:  "pipes",
	1466:  "oceansoft-lm",
	1467:  "csdmbase",
	1468:  "csdm",
	1469:  "aal-lm",
	1470:  "uaiact",
	1471:  "csdmbase",
	1472:  "csdm",
	1473:  "openmath",
	1474:  "telefinder",
	1475:  "taligent-lm",
	1476:  "clvm-cfg",
	1477:  "ms-sna-server",
	1478:  "ms-sna-base",
	1479:  "dberegister",
	1480:  "pacerforum",
	1481:  "airs",
	1482:  "miteksys-lm",
	1483:  "afs",
	1484:  "confluent",
	1485:  "lansource",
	1486:  "nms-topo-serv",
	1487:  "localinfosrvr",
	1488:  "docstor",
	1489:  "dmdocbroker",
	1490:  "insitu-conf",
	1492:  "stone-design-1",
	1493:  "netmap-lm",
	1494:  "ica",
	1495:  "cvc",
	1496:  "liberty-lm",
	1497:  "rfx-lm",
	1498:  "sybase-sqlany",
	1499:  "fhc",
	1500:  "vlsi-lm",
	1501:  "saiscm",
	1502:  "shivadiscovery",
	1503:  "imtc-mcs",
	1504:  "evb-elm",
	1505:  "funkproxy",
	1506:  "utcd",
	1507:  "symplex",
	1508:  "diagmond",
	1509:  "robcad-lm",
	1510:  "mvx-lm",
	1511:  "3l-l1",
	1512:  "wins",
	1513:  "fujitsu-dtc",
	1514:  "fujitsu-dtcns",
	1515:  "ifor-protocol",
	1516:  "vpad",
	1517:  "vpac",
	1518:  "vpvd",
	1519:  "vpvc",
	1520:  "atm-zip-office",
	1521:  "ncube-lm",
	1522:  "ricardo-lm",
	1523:  "cichild-lm",
	1524:  "ingreslock",
	1525:  "orasrv",
	1526:  "pdap-np",
	1527:  "tlisrv",
	1528:  "ngr-t",
	1529:  "coauthor",
	1530:  "rap-service",
	1531:  "rap-listen",
	1532:  "miroconnect",
	1533:  "virtual-places",
	1534:  "micromuse-lm",
	1535:  "ampr-info",
	1536:  "ampr-inter",
	1537:  "sdsc-lm",
	1538:  "3ds-lm",
	1539:  "intellistor-lm",
	1540:  "rds",
	1541:  "rds2",
	1542:  "gridgen-elmd",
	1543:  "simba-cs",
	1544:  "aspeclmd",
	1545:  "vistium-share",
	1546:  "abbaccuray",
	1547:  "laplink",
	1548:  "axon-lm",
	1549:  "shivasound",
	1550:  "3m-image-lm",
	1551:  "hecmtl-db",
	1552:  "pciarray",
	1553:  "sna-cs",
	1554:  "caci-lm",
	1555:  "livelan",
	1556:  "veritas-pbx",
	1557:  "arbortext-lm",
	1558:  "xingmpeg",
	1559:  "web2host",
	1560:  "asci-val",
	1561:  "facilityview",
	1562:  "pconnectmgr",
	1563:  "cadabra-lm",
	1564:  "pay-per-view",
	1565:  "winddlb",
	1566:  "corelvideo",
	1567:  "jlicelmd",
	1568:  "tsspmap",
	1569:  "ets",
	1570:  "orbixd",
	1571:  "rdb-dbs-disp",
	1572:  "chip-lm",
	1573:  "itscomm-ns",
	1574:  "mvel-lm",
	1575:  "oraclenames",
	1576:  "moldflow-lm",
	1577:  "hypercube-lm",
	1578:  "jacobus-lm",
	1579:  "ioc-sea-lm",
	1580:  "tn-tl-r2",
	1581:  "mil-2045-47001",
	1582:  "msims",
	1583:  "simbaexpress",
	1584:  "tn-tl-fd2",
	1585:  "intv",
	1586:  "ibm-abtact",
	1587:  "pra-elmd",
	1588:  "triquest-lm",
	1589:  "vqp",
	1590:  "gemini-lm",
	1591:  "ncpm-pm",
	1592:  "commonspace",
	1593:  "mainsoft-lm",
	1594:  "sixtrak",
	1595:  "radio",
	1596:  "radio-bc",
	1597:  "orbplus-iiop",
	1598:  "picknfs",
	1599:  "simbaservices",
	1600:  "issd",
	1601:  "aas",
	1602:  "inspect",
	1603:  "picodbc",
	1604:  "icabrowser",
	1605:  "slp",
	1606:  "slm-api",
	1607:  "stt",
	1608:  "smart-lm",
	1609:  "isysg-lm",
	1610:  "taurus-wh",
	1611:  "ill",
	1612:  "netbill-trans",
	1613:  "netbill-keyrep",
	1614:  "netbill-cred",
	1615:  "netbill-auth",
	1616:  "netbill-prod",
	1617:  "nimrod-agent",
	1618:  "skytelnet",
	1619:  "xs-openstorage",
	1620:  "faxportwinport",
	1621:  "softdataphone",
	1622:  "ontime",
	1623:  "jaleosnd",
	1624:  "udp-sr-port",
	1625:  "svs-omagent",
	1626:  "shockwave",
	1627:  "t128-gateway",
	1628:  "lontalk-norm",
	1629:  "lontalk-urgnt",
	1630:  "oraclenet8cman",
	1631:  "visitview",
	1632:  "pammratc",
	1633:  "pammrpc",
	1634:  "loaprobe",
	1635:  "edb-server1",
	1636:  "isdc",
	1637:  "islc",
	1638:  "ismc",
	1639:  "cert-initiator",
	1640:  "cert-responder",
	1641:  "invision",
	1642:  "isis-am",
	1643:  "isis-ambc",
	1644:  "saiseh",
	1645:  "sightline",
	1646:  "sa-msg-port",
	1647:  "rsap",
	1648:  "concurrent-lm",
	1649:  "kermit",
	1650:  "nkd",
	1651:  "shiva-confsrvr",
	1652:  "xnmp",
	1653:  "alphatech-lm",
	1654:  "stargatealerts",
	1655:  "dec-mbadmin",
	1656:  "dec-mbadmin-h",
	1657:  "fujitsu-mmpdc",
	1658:  "sixnetudr",
	1659:  "sg-lm",
	1660:  "skip-mc-gikreq",
	1661:  "netview-aix-1",
	1662:  "netview-aix-2",
	1663:  "netview-aix-3",
	1664:  "netview-aix-4",
	1665:  "netview-aix-5",
	1666:  "netview-aix-6",
	1667:  "netview-aix-7",
	1668:  "netview-aix-8",
	1669:  "netview-aix-9",
	1670:  "netview-aix-10",
	1671:  "netview-aix-11",
	1672:  "netview-aix-12",
	1673:  "proshare-mc-1",
	1674:  "proshare-mc-2",
	1675:  "pdp",
	1676:  "netcomm2",
	1677:  "groupwise",
	1678:  "prolink",
	1679:  "darcorp-lm",
	1680:  "microcom-sbp",
	1681:  "sd-elmd",
	1682:  "lanyon-lantern",
	1683:  "ncpm-hip",
	1684:  "snaresecure",
	1685:  "n2nremote",
	1686:  "cvmon",
	1687:  "nsjtp-ctrl",
	1688:  "nsjtp-data",
	1689:  "firefox",
	1690:  "ng-umds",
	1691:  "empire-empuma",
	1692:  "sstsys-lm",
	1693:  "rrirtr",
	1694:  "rrimwm",
	1695:  "rrilwm",
	1696:  "rrifmm",
	1697:  "rrisat",
	1698:  "rsvp-encap-1",
	1699:  "rsvp-encap-2",
	1700:  "mps-raft",
	1701:  "l2f",
	1702:  "deskshare",
	1703:  "hb-engine",
	1704:  "bcs-broker",
	1705:  "slingshot",
	1706:  "jetform",
	1707:  "vdmplay",
	1708:  "gat-lmd",
	1709:  "centra",
	1710:  "impera",
	1711:  "pptconference",
	1712:  "registrar",
	1713:  "conferencetalk",
	1714:  "sesi-lm",
	1715:  "houdini-lm",
	1716:  "xmsg",
	1717:  "fj-hdnet",
	1718:  "h323gatedisc",
	1719:  "h323gatestat",
	1720:  "h323hostcall",
	1721:  "caicci",
	1722:  "hks-lm",
	1723:  "pptp",
	1724:  "csbphonemaster",
	1725:  "iden-ralp",
	1726:  "iberiagames",
	1727:  "winddx",
	1728:  "telindus",
	1729:  "citynl",
	1730:  "roketz",
	1731:  "msiccp",
	1732:  "proxim",
	1733:  "siipat",
	1734:  "cambertx-lm",
	1735:  "privatechat",
	1736:  "street-stream",
	1737:  "ultimad",
	1738:  "gamegen1",
	1739:  "webaccess",
	1740:  "encore",
	1741:  "cisco-net-mgmt",
	1742:  "3Com-nsd",
	1743:  "cinegrfx-lm",
	1744:  "ncpm-ft",
	1745:  "remote-winsock",
	1746:  "ftrapid-1",
	1747:  "ftrapid-2",
	1748:  "oracle-em1",
	1749:  "aspen-services",
	1750:  "sslp",
	1751:  "swiftnet",
	1752:  "lofr-lm",
	1754:  "oracle-em2",
	1755:  "ms-streaming",
	1756:  "capfast-lmd",
	1757:  "cnhrp",
	1758:  "tftp-mcast",
	1759:  "spss-lm",
	1760:  "www-ldap-gw",
	1761:  "cft-0",
	1762:  "cft-1",
	1763:  "cft-2",
	1764:  "cft-3",
	1765:  "cft-4",
	1766:  "cft-5",
	1767:  "cft-6",
	1768:  "cft-7",
	1769:  "bmc-net-adm",
	1770:  "bmc-net-svc",
	1771:  "vaultbase",
	1772:  "essweb-gw",
	1773:  "kmscontrol",
	1774:  "global-dtserv",
	1776:  "femis",
	1777:  "powerguardian",
	1778:  "prodigy-intrnet",
	1779:  "pharmasoft",
	1780:  "dpkeyserv",
	1781:  "answersoft-lm",
	1782:  "hp-hcip",
	1784:  "finle-lm",
	1785:  "windlm",
	1786:  "funk-logger",
	1787:  "funk-license",
	1788:  "psmond",
	1789:  "hello",
	1790:  "nmsp",
	1791:  "ea1",
	1792:  "ibm-dt-2",
	1793:  "rsc-robot",
	1794:  "cera-bcm",
	1795:  "dpi-proxy",
	1796:  "vocaltec-admin",
	1797:  "uma",
	1798:  "etp",
	1799:  "netrisk",
	1800:  "ansys-lm",
	1801:  "msmq",
	1802:  "concomp1",
	1803:  "hp-hcip-gwy",
	1804:  "enl",
	1805:  "enl-name",
	1806:  "musiconline",
	1807:  "fhsp",
	1808:  "oracle-vp2",
	1809:  "oracle-vp1",
	1810:  "jerand-lm",
	1811:  "scientia-sdb",
	1812:  "radius",
	1813:  "radius-acct",
	1814:  "tdp-suite",
	1815:  "mmpft",
	1816:  "harp",
	1817:  "rkb-oscs",
	1818:  "etftp",
	1819:  "plato-lm",
	1820:  "mcagent",
	1821:  "donnyworld",
	1822:  "es-elmd",
	1823:  "unisys-lm",
	1824:  "metrics-pas",
	1825:  "direcpc-video",
	1826:  "ardt",
	1827:  "asi",
	1828:  "itm-mcell-u",
	1829:  "optika-emedia",
	1830:  "net8-cman",
	1831:  "myrtle",
	1832:  "tht-treasure",
	1833:  "udpradio",
	1834:  "ardusuni",
	1835:  "ardusmul",
	1836:  "ste-smsc",
	1837:  "csoft1",
	1838:  "talnet",
	1839:  "netopia-vo1",
	1840:  "netopia-vo2",
	1841:  "netopia-vo3",
	1842:  "netopia-vo4",
	1843:  "netopia-vo5",
	1844:  "direcpc-dll",
	1845:  "altalink",
	1846:  "tunstall-pnc",
	1847:  "slp-notify",
	1848:  "fjdocdist",
	1849:  "alpha-sms",
	1850:  "gsi",
	1851:  "ctcd",
	1852:  "virtual-time",
	1853:  "vids-avtp",
	1854:  "buddy-draw",
	1855:  "fiorano-rtrsvc",
	1856:  "fiorano-msgsvc",
	1857:  "datacaptor",
	1858:  "privateark",
	1859:  "gammafetchsvr",
	1860:  "sunscalar-svc",
	1861:  "lecroy-vicp",
	1862:  "mysql-cm-agent",
	1863:  "msnp",
	1864:  "paradym-31port",
	1865:  "entp",
	1866:  "swrmi",
	1867:  "udrive",
	1868:  "viziblebrowser",
	1869:  "transact",
	1870:  "sunscalar-dns",
	1871:  "canocentral0",
	1872:  "canocentral1",
	1873:  "fjmpjps",
	1874:  "fjswapsnp",
	1875:  "westell-stats",
	1876:  "ewcappsrv",
	1877:  "hp-webqosdb",
	1878:  "drmsmc",
	1879:  "nettgain-nms",
	1880:  "vsat-control",
	1881:  "ibm-mqseries2",
	1882:  "ecsqdmn",
	1883:  "mqtt",
	1884:  "idmaps",
	1885:  "vrtstrapserver",
	1886:  "leoip",
	1887:  "filex-lport",
	1888:  "ncconfig",
	1889:  "unify-adapter",
	1890:  "wilkenlistener",
	1891:  "childkey-notif",
	1892:  "childkey-ctrl",
	1893:  "elad",
	1894:  "o2server-port",
	1896:  "b-novative-ls",
	1897:  "metaagent",
	1898:  "cymtec-port",
	1899:  "mc2studios",
	1900:  "ssdp",
	1901:  "fjicl-tep-a",
	1902:  "fjicl-tep-b",
	1903:  "linkname",
	1904:  "fjicl-tep-c",
	1905:  "sugp",
	1906:  "tpmd",
	1907:  "intrastar",
	1908:  "dawn",
	1909:  "global-wlink",
	1910:  "ultrabac",
	1911:  "mtp",
	1912:  "rhp-iibp",
	1913:  "armadp",
	1914:  "elm-momentum",
	1915:  "facelink",
	1916:  "persona",
	1917:  "noagent",
	1918:  "can-nds",
	1919:  "can-dch",
	1920:  "can-ferret",
	1921:  "noadmin",
	1922:  "tapestry",
	1923:  "spice",
	1924:  "xiip",
	1925:  "discovery-port",
	1926:  "egs",
	1927:  "videte-cipc",
	1928:  "emsd-port",
	1929:  "bandwiz-system",
	1930:  "driveappserver",
	1931:  "amdsched",
	1932:  "ctt-broker",
	1933:  "xmapi",
	1934:  "xaapi",
	1935:  "macromedia-fcs",
	1936:  "jetcmeserver",
	1937:  "jwserver",
	1938:  "jwclient",
	1939:  "jvserver",
	1940:  "jvclient",
	1941:  "dic-aida",
	1942:  "res",
	1943:  "beeyond-media",
	1944:  "close-combat",
	1945:  "dialogic-elmd",
	1946:  "tekpls",
	1947:  "sentinelsrm",
	1948:  "eye2eye",
	1949:  "ismaeasdaqlive",
	1950:  "ismaeasdaqtest",
	1951:  "bcs-lmserver",
	1952:  "mpnjsc",
	1953:  "rapidbase",
	1954:  "abr-api",
	1955:  "abr-secure",
	1956:  "vrtl-vmf-ds",
	1957:  "unix-status",
	1958:  "dxadmind",
	1959:  "simp-all",
	1960:  "nasmanager",
	1961:  "bts-appserver",
	1962:  "biap-mp",
	1963:  "webmachine",
	1964:  "solid-e-engine",
	1965:  "tivoli-npm",
	1966:  "slush",
	1967:  "sns-quote",
	1968:  "lipsinc",
	1969:  "lipsinc1",
	1970:  "netop-rc",
	1971:  "netop-school",
	1972:  "intersys-cache",
	1973:  "dlsrap",
	1974:  "drp",
	1975:  "tcoflashagent",
	1976:  "tcoregagent",
	1977:  "tcoaddressbook",
	1978:  "unisql",
	1979:  "unisql-java",
	1980:  "pearldoc-xact",
	1981:  "p2pq",
	1982:  "estamp",
	1983:  "lhtp",
	1984:  "bb",
	1985:  "hsrp",
	1986:  "licensedaemon",
	1987:  "tr-rsrb-p1",
	1988:  "tr-rsrb-p2",
	1989:  "tr-rsrb-p3",
	1990:  "stun-p1",
	1991:  "stun-p2",
	1992:  "stun-p3",
	1993:  "snmp-tcp-port",
	1994:  "stun-port",
	1995:  "perf-port",
	1996:  "tr-rsrb-port",
	1997:  "gdp-port",
	1998:  "x25-svc-port",
	1999:  "tcp-id-port",
	2000:  "cisco-sccp",
	2001:  "wizard",
	2002:  "globe",
	2003:  "brutus",
	2004:  "emce",
	2005:  "oracle",
	2006:  "raid-cd",
	2007:  "raid-am",
	2008:  "terminaldb",
	2009:  "whosockami",
	2010:  "pipe-server",
	2011:  "servserv",
	2012:  "raid-ac",
	2013:  "raid-cd",
	2014:  "raid-sf",
	2015:  "raid-cs",
	2016:  "bootserver",
	2017:  "bootclient",
	2018:  "rellpack",
	2019:  "about",
	2020:  "xinupageserver",
	2021:  "xinuexpansion1",
	2022:  "xinuexpansion2",
	2023:  "xinuexpansion3",
	2024:  "xinuexpansion4",
	2025:  "xribs",
	2026:  "scrabble",
	2027:  "shadowserver",
	2028:  "submitserver",
	2029:  "hsrpv6",
	2030:  "device2",
	2031:  "mobrien-chat",
	2032:  "blackboard",
	2033:  "glogger",
	2034:  "scoremgr",
	2035:  "imsldoc",
	2036:  "e-dpnet",
	2037:  "applus",
	2038:  "objectmanager",
	2039:  "prizma",
	2040:  "lam",
	2041:  "interbase",
	2042:  "isis",
	2043:  "isis-bcast",
	2044:  "rimsl",
	2045:  "cdfunc",
	2046:  "sdfunc",
	2047:  "dls",
	2048:  "dls-monitor",
	2049:  "shilp",
	2050:  "av-emb-config",
	2051:  "epnsdp",
	2052:  "clearvisn",
	2053:  "lot105-ds-upd",
	2054:  "weblogin",
	2055:  "iop",
	2056:  "omnisky",
	2057:  "rich-cp",
	2058:  "newwavesearch",
	2059:  "bmc-messaging",
	2060:  "teleniumdaemon",
	2061:  "netmount",
	2062:  "icg-swp",
	2063:  "icg-bridge",
	2064:  "icg-iprelay",
	2065:  "dlsrpn",
	2066:  "aura",
	2067:  "dlswpn",
	2068:  "avauthsrvprtcl",
	2069:  "event-port",
	2070:  "ah-esp-encap",
	2071:  "acp-port",
	2072:  "msync",
	2073:  "gxs-data-port",
	2074:  "vrtl-vmf-sa",
	2075:  "newlixengine",
	2076:  "newlixconfig",
	2077:  "tsrmagt",
	2078:  "tpcsrvr",
	2079:  "idware-router",
	2080:  "autodesk-nlm",
	2081:  "kme-trap-port",
	2082:  "infowave",
	2083:  "radsec",
	2084:  "sunclustergeo",
	2085:  "ada-cip",
	2086:  "gnunet",
	2087:  "eli",
	2088:  "ip-blf",
	2089:  "sep",
	2090:  "lrp",
	2091:  "prp",
	2092:  "descent3",
	2093:  "nbx-cc",
	2094:  "nbx-au",
	2095:  "nbx-ser",
	2096:  "nbx-dir",
	2097:  "jetformpreview",
	2098:  "dialog-port",
	2099:  "h2250-annex-g",
	2100:  "amiganetfs",
	2101:  "rtcm-sc104",
	2102:  "zephyr-srv",
	2103:  "zephyr-clt",
	2104:  "zephyr-hm",
	2105:  "minipay",
	2106:  "mzap",
	2107:  "bintec-admin",
	2108:  "comcam",
	2109:  "ergolight",
	2110:  "umsp",
	2111:  "dsatp",
	2112:  "idonix-metanet",
	2113:  "hsl-storm",
	2114:  "newheights",
	2115:  "kdm",
	2116:  "ccowcmr",
	2117:  "mentaclient",
	2118:  "mentaserver",
	2119:  "gsigatekeeper",
	2120:  "qencp",
	2121:  "scientia-ssdb",
	2122:  "caupc-remote",
	2123:  "gtp-control",
	2124:  "elatelink",
	2125:  "lockstep",
	2126:  "pktcable-cops",
	2127:  "index-pc-wb",
	2128:  "net-steward",
	2129:  "cs-live",
	2130:  "xds",
	2131:  "avantageb2b",
	2132:  "solera-epmap",
	2133:  "zymed-zpp",
	2134:  "avenue",
	2135:  "gris",
	2136:  "appworxsrv",
	2137:  "connect",
	2138:  "unbind-cluster",
	2139:  "ias-auth",
	2140:  "ias-reg",
	2141:  "ias-admind",
	2142:  "tdmoip",
	2143:  "lv-jc",
	2144:  "lv-ffx",
	2145:  "lv-pici",
	2146:  "lv-not",
	2147:  "lv-auth",
	2148:  "veritas-ucl",
	2149:  "acptsys",
	2150:  "dynamic3d",
	2151:  "docent",
	2152:  "gtp-user",
	2153:  "ctlptc",
	2154:  "stdptc",
	2155:  "brdptc",
	2156:  "trp",
	2157:  "xnds",
	2158:  "touchnetplus",
	2159:  "gdbremote",
	2160:  "apc-2160",
	2161:  "apc-2161",
	2162:  "navisphere",
	2163:  "navisphere-sec",
	2164:  "ddns-v3",
	2165:  "x-bone-api",
	2166:  "iwserver",
	2167:  "raw-serial",
	2168:  "easy-soft-mux",
	2169:  "brain",
	2170:  "eyetv",
	2171:  "msfw-storage",
	2172:  "msfw-s-storage",
	2173:  "msfw-replica",
	2174:  "msfw-array",
	2175:  "airsync",
	2176:  "rapi",
	2177:  "qwave",
	2178:  "bitspeer",
	2179:  "vmrdp",
	2180:  "mc-gt-srv",
	2181:  "eforward",
	2182:  "cgn-stat",
	2183:  "cgn-config",
	2184:  "nvd",
	2185:  "onbase-dds",
	2186:  "gtaua",
	2187:  "ssmd",
	2190:  "tivoconnect",
	2191:  "tvbus",
	2192:  "asdis",
	2193:  "drwcs",
	2197:  "mnp-exchange",
	2198:  "onehome-remote",
	2199:  "onehome-help",
	2200:  "ici",
	2201:  "ats",
	2202:  "imtc-map",
	2203:  "b2-runtime",
	2204:  "b2-license",
	2205:  "jps",
	2206:  "hpocbus",
	2207:  "hpssd",
	2208:  "hpiod",
	2209:  "rimf-ps",
	2210:  "noaaport",
	2211:  "emwin",
	2212:  "leecoposserver",
	2213:  "kali",
	2214:  "rpi",
	2215:  "ipcore",
	2216:  "vtu-comms",
	2217:  "gotodevice",
	2218:  "bounzza",
	2219:  "netiq-ncap",
	2220:  "netiq",
	2221:  "ethernet-ip-s",
	2222:  "EtherNet-IP-1",
	2223:  "rockwell-csp2",
	2224:  "efi-mg",
	2226:  "di-drm",
	2227:  "di-msg",
	2228:  "ehome-ms",
	2229:  "datalens",
	2230:  "queueadm",
	2231:  "wimaxasncp",
	2232:  "ivs-video",
	2233:  "infocrypt",
	2234:  "directplay",
	2235:  "sercomm-wlink",
	2236:  "nani",
	2237:  "optech-port1-lm",
	2238:  "aviva-sna",
	2239:  "imagequery",
	2240:  "recipe",
	2241:  "ivsd",
	2242:  "foliocorp",
	2243:  "magicom",
	2244:  "nmsserver",
	2245:  "hao",
	2246:  "pc-mta-addrmap",
	2247:  "antidotemgrsvr",
	2248:  "ums",
	2249:  "rfmp",
	2250:  "remote-collab",
	2251:  "dif-port",
	2252:  "njenet-ssl",
	2253:  "dtv-chan-req",
	2254:  "seispoc",
	2255:  "vrtp",
	2256:  "pcc-mfp",
	2257:  "simple-tx-rx",
	2258:  "rcts",
	2260:  "apc-2260",
	2261:  "comotionmaster",
	2262:  "comotionback",
	2263:  "ecwcfg",
	2264:  "apx500api-1",
	2265:  "apx500api-2",
	2266:  "mfserver",
	2267:  "ontobroker",
	2268:  "amt",
	2269:  "mikey",
	2270:  "starschool",
	2271:  "mmcals",
	2272:  "mmcal",
	2273:  "mysql-im",
	2274:  "pcttunnell",
	2275:  "ibridge-data",
	2276:  "ibridge-mgmt",
	2277:  "bluectrlproxy",
	2278:  "s3db",
	2279:  "xmquery",
	2280:  "lnvpoller",
	2281:  "lnvconsole",
	2282:  "lnvalarm",
	2283:  "lnvstatus",
	2284:  "lnvmaps",
	2285:  "lnvmailmon",
	2286:  "nas-metering",
	2287:  "dna",
	2288:  "netml",
	2289:  "dict-lookup",
	2290:  "sonus-logging",
	2291:  "eapsp",
	2292:  "mib-streaming",
	2293:  "npdbgmngr",
	2294:  "konshus-lm",
	2295:  "advant-lm",
	2296:  "theta-lm",
	2297:  "d2k-datamover1",
	2298:  "d2k-datamover2",
	2299:  "pc-telecommute",
	2300:  "cvmmon",
	2301:  "cpq-wbem",
	2302:  "binderysupport",
	2303:  "proxy-gateway",
	2304:  "attachmate-uts",
	2305:  "mt-scaleserver",
	2306:  "tappi-boxnet",
	2307:  "pehelp",
	2308:  "sdhelp",
	2309:  "sdserver",
	2310:  "sdclient",
	2311:  "messageservice",
	2312:  "wanscaler",
	2313:  "iapp",
	2314:  "cr-websystems",
	2315:  "precise-sft",
	2316:  "sent-lm",
	2317:  "attachmate-g32",
	2318:  "cadencecontrol",
	2319:  "infolibria",
	2320:  "siebel-ns",
	2321:  "rdlap",
	2322:  "ofsd",
	2323:  "3d-nfsd",
	2324:  "cosmocall",
	2325:  "ansysli",
	2326:  "idcp",
	2327:  "xingcsm",
	2328:  "netrix-sftm",
	2329:  "nvd",
	2330:  "tscchat",
	2331:  "agentview",
	2332:  "rcc-host",
	2333:  "snapp",
	2334:  "ace-client",
	2335:  "ace-proxy",
	2336:  "appleugcontrol",
	2337:  "ideesrv",
	2338:  "norton-lambert",
	2339:  "3com-webview",
	2340:  "wrs-registry",
	2341:  "xiostatus",
	2342:  "manage-exec",
	2343:  "nati-logos",
	2344:  "fcmsys",
	2345:  "dbm",
	2346:  "redstorm-join",
	2347:  "redstorm-find",
	2348:  "redstorm-info",
	2349:  "redstorm-diag",
	2350:  "psbserver",
	2351:  "psrserver",
	2352:  "pslserver",
	2353:  "pspserver",
	2354:  "psprserver",
	2355:  "psdbserver",
	2356:  "gxtelmd",
	2357:  "unihub-server",
	2358:  "futrix",
	2359:  "flukeserver",
	2360:  "nexstorindltd",
	2361:  "tl1",
	2362:  "digiman",
	2363:  "mediacntrlnfsd",
	2364:  "oi-2000",
	2365:  "dbref",
	2366:  "qip-login",
	2367:  "service-ctrl",
	2368:  "opentable",
	2370:  "l3-hbmon",
	2372:  "lanmessenger",
	2381:  "compaq-https",
	2382:  "ms-olap3",
	2383:  "ms-olap4",
	2384:  "sd-capacity",
	2385:  "sd-data",
	2386:  "virtualtape",
	2387:  "vsamredirector",
	2388:  "mynahautostart",
	2389:  "ovsessionmgr",
	2390:  "rsmtp",
	2391:  "3com-net-mgmt",
	2392:  "tacticalauth",
	2393:  "ms-olap1",
	2394:  "ms-olap2",
	2395:  "lan900-remote",
	2396:  "wusage",
	2397:  "ncl",
	2398:  "orbiter",
	2399:  "fmpro-fdal",
	2400:  "opequus-server",
	2401:  "cvspserver",
	2402:  "taskmaster2000",
	2403:  "taskmaster2000",
	2404:  "iec-104",
	2405:  "trc-netpoll",
	2406:  "jediserver",
	2407:  "orion",
	2409:  "sns-protocol",
	2410:  "vrts-registry",
	2411:  "netwave-ap-mgmt",
	2412:  "cdn",
	2413:  "orion-rmi-reg",
	2414:  "beeyond",
	2415:  "codima-rtp",
	2416:  "rmtserver",
	2417:  "composit-server",
	2418:  "cas",
	2419:  "attachmate-s2s",
	2420:  "dslremote-mgmt",
	2421:  "g-talk",
	2422:  "crmsbits",
	2423:  "rnrp",
	2424:  "kofax-svr",
	2425:  "fjitsuappmgr",
	2426:  "vcmp",
	2427:  "mgcp-gateway",
	2428:  "ott",
	2429:  "ft-role",
	2430:  "venus",
	2431:  "venus-se",
	2432:  "codasrv",
	2433:  "codasrv-se",
	2434:  "pxc-epmap",
	2435:  "optilogic",
	2436:  "topx",
	2437:  "unicontrol",
	2438:  "msp",
	2439:  "sybasedbsynch",
	2440:  "spearway",
	2441:  "pvsw-inet",
	2442:  "netangel",
	2443:  "powerclientcsf",
	2444:  "btpp2sectrans",
	2445:  "dtn1",
	2446:  "bues-service",
	2447:  "ovwdb",
	2448:  "hpppssvr",
	2449:  "ratl",
	2450:  "netadmin",
	2451:  "netchat",
	2452:  "snifferclient",
	2453:  "madge-ltd",
	2454:  "indx-dds",
	2455:  "wago-io-system",
	2456:  "altav-remmgt",
	2457:  "rapido-ip",
	2458:  "griffin",
	2459:  "community",
	2460:  "ms-theater",
	2461:  "qadmifoper",
	2462:  "qadmifevent",
	2463:  "lsi-raid-mgmt",
	2464:  "direcpc-si",
	2465:  "lbm",
	2466:  "lbf",
	2467:  "high-criteria",
	2468:  "qip-msgd",
	2469:  "mti-tcs-comm",
	2470:  "taskman-port",
	2471:  "seaodbc",
	2472:  "c3",
	2473:  "aker-cdp",
	2474:  "vitalanalysis",
	2475:  "ace-server",
	2476:  "ace-svr-prop",
	2477:  "ssm-cvs",
	2478:  "ssm-cssps",
	2479:  "ssm-els",
	2480:  "powerexchange",
	2481:  "giop",
	2482:  "giop-ssl",
	2483:  "ttc",
	2484:  "ttc-ssl",
	2485:  "netobjects1",
	2486:  "netobjects2",
	2487:  "pns",
	2488:  "moy-corp",
	2489:  "tsilb",
	2490:  "qip-qdhcp",
	2491:  "conclave-cpp",
	2492:  "groove",
	2493:  "talarian-mqs",
	2494:  "bmc-ar",
	2495:  "fast-rem-serv",
	2496:  "dirgis",
	2497:  "quaddb",
	2498:  "odn-castraq",
	2499:  "unicontrol",
	2500:  "rtsserv",
	2501:  "rtsclient",
	2502:  "kentrox-prot",
	2503:  "nms-dpnss",
	2504:  "wlbs",
	2505:  "ppcontrol",
	2506:  "jbroker",
	2507:  "spock",
	2508:  "jdatastore",
	2509:  "fjmpss",
	2510:  "fjappmgrbulk",
	2511:  "metastorm",
	2512:  "citrixima",
	2513:  "citrixadmin",
	2514:  "facsys-ntp",
	2515:  "facsys-router",
	2516:  "maincontrol",
	2517:  "call-sig-trans",
	2518:  "willy",
	2519:  "globmsgsvc",
	2520:  "pvsw",
	2521:  "adaptecmgr",
	2522:  "windb",
	2523:  "qke-llc-v3",
	2524:  "optiwave-lm",
	2525:  "ms-v-worlds",
	2526:  "ema-sent-lm",
	2527:  "iqserver",
	2528:  "ncr-ccl",
	2529:  "utsftp",
	2530:  "vrcommerce",
	2531:  "ito-e-gui",
	2532:  "ovtopmd",
	2533:  "snifferserver",
	2534:  "combox-web-acc",
	2535:  "madcap",
	2536:  "btpp2audctr1",
	2537:  "upgrade",
	2538:  "vnwk-prapi",
	2539:  "vsiadmin",
	2540:  "lonworks",
	2541:  "lonworks2",
	2542:  "udrawgraph",
	2543:  "reftek",
	2544:  "novell-zen",
	2545:  "sis-emt",
	2546:  "vytalvaultbrtp",
	2547:  "vytalvaultvsmp",
	2548:  "vytalvaultpipe",
	2549:  "ipass",
	2550:  "ads",
	2551:  "isg-uda-server",
	2552:  "call-logging",
	2553:  "efidiningport",
	2554:  "vcnet-link-v10",
	2555:  "compaq-wcp",
	2556:  "nicetec-nmsvc",
	2557:  "nicetec-mgmt",
	2558:  "pclemultimedia",
	2559:  "lstp",
	2560:  "labrat",
	2561:  "mosaixcc",
	2562:  "delibo",
	2563:  "cti-redwood",
	2564:  "hp-3000-telnet",
	2565:  "coord-svr",
	2566:  "pcs-pcw",
	2567:  "clp",
	2568:  "spamtrap",
	2569:  "sonuscallsig",
	2570:  "hs-port",
	2571:  "cecsvc",
	2572:  "ibp",
	2573:  "trustestablish",
	2574:  "blockade-bpsp",
	2575:  "hl7",
	2576:  "tclprodebugger",
	2577:  "scipticslsrvr",
	2578:  "rvs-isdn-dcp",
	2579:  "mpfoncl",
	2580:  "tributary",
	2581:  "argis-te",
	2582:  "argis-ds",
	2583:  "mon",
	2584:  "cyaserv",
	2585:  "netx-server",
	2586:  "netx-agent",
	2587:  "masc",
	2588:  "privilege",
	2589:  "quartus-tcl",
	2590:  "idotdist",
	2591:  "maytagshuffle",
	2592:  "netrek",
	2593:  "mns-mail",
	2594:  "dts",
	2595:  "worldfusion1",
	2596:  "worldfusion2",
	2597:  "homesteadglory",
	2598:  "citriximaclient",
	2599:  "snapd",
	2600:  "hpstgmgr",
	2601:  "discp-client",
	2602:  "discp-server",
	2603:  "servicemeter",
	2604:  "nsc-ccs",
	2605:  "nsc-posa",
	2606:  "netmon",
	2607:  "connection",
	2608:  "wag-service",
	2609:  "system-monitor",
	2610:  "versa-tek",
	2611:  "lionhead",
	2612:  "qpasa-agent",
	2613:  "smntubootstrap",
	2614:  "neveroffline",
	2615:  "firepower",
	2616:  "appswitch-emp",
	2617:  "cmadmin",
	2618:  "priority-e-com",
	2619:  "bruce",
	2620:  "lpsrecommender",
	2621:  "miles-apart",
	2622:  "metricadbc",
	2623:  "lmdp",
	2624:  "aria",
	2625:  "blwnkl-port",
	2626:  "gbjd816",
	2627:  "moshebeeri",
	2628:  "dict",
	2629:  "sitaraserver",
	2630:  "sitaramgmt",
	2631:  "sitaradir",
	2632:  "irdg-post",
	2633:  "interintelli",
	2634:  "pk-electronics",
	2635:  "backburner",
	2636:  "solve",
	2637:  "imdocsvc",
	2638:  "sybaseanywhere",
	2639:  "aminet",
	2640:  "ami-control",
	2641:  "hdl-srv",
	2642:  "tragic",
	2643:  "gte-samp",
	2644:  "travsoft-ipx-t",
	2645:  "novell-ipx-cmd",
	2646:  "and-lm",
	2647:  "syncserver",
	2648:  "upsnotifyprot",
	2649:  "vpsipport",
	2650:  "eristwoguns",
	2651:  "ebinsite",
	2652:  "interpathpanel",
	2653:  "sonus",
	2654:  "corel-vncadmin",
	2655:  "unglue",
	2656:  "kana",
	2657:  "sns-dispatcher",
	2658:  "sns-admin",
	2659:  "sns-query",
	2660:  "gcmonitor",
	2661:  "olhost",
	2662:  "bintec-capi",
	2663:  "bintec-tapi",
	2664:  "patrol-mq-gm",
	2665:  "patrol-mq-nm",
	2666:  "extensis",
	2667:  "alarm-clock-s",
	2668:  "alarm-clock-c",
	2669:  "toad",
	2670:  "tve-announce",
	2671:  "newlixreg",
	2672:  "nhserver",
	2673:  "firstcall42",
	2674:  "ewnn",
	2675:  "ttc-etap",
	2676:  "simslink",
	2677:  "gadgetgate1way",
	2678:  "gadgetgate2way",
	2679:  "syncserverssl",
	2680:  "pxc-sapxom",
	2681:  "mpnjsomb",
	2683:  "ncdloadbalance",
	2684:  "mpnjsosv",
	2685:  "mpnjsocl",
	2686:  "mpnjsomg",
	2687:  "pq-lic-mgmt",
	2688:  "md-cg-http",
	2689:  "fastlynx",
	2690:  "hp-nnm-data",
	2691:  "itinternet",
	2692:  "admins-lms",
	2694:  "pwrsevent",
	2695:  "vspread",
	2696:  "unifyadmin",
	2697:  "oce-snmp-trap",
	2698:  "mck-ivpip",
	2699:  "csoft-plusclnt",
	2700:  "tqdata",
	2701:  "sms-rcinfo",
	2702:  "sms-xfer",
	2703:  "sms-chat",
	2704:  "sms-remctrl",
	2705:  "sds-admin",
	2706:  "ncdmirroring",
	2707:  "emcsymapiport",
	2708:  "banyan-net",
	2709:  "supermon",
	2710:  "sso-service",
	2711:  "sso-control",
	2712:  "aocp",
	2713:  "raventbs",
	2714:  "raventdm",
	2715:  "hpstgmgr2",
	2716:  "inova-ip-disco",
	2717:  "pn-requester",
	2718:  "pn-requester2",
	2719:  "scan-change",
	2720:  "wkars",
	2721:  "smart-diagnose",
	2722:  "proactivesrvr",
	2723:  "watchdog-nt",
	2724:  "qotps",
	2725:  "msolap-ptp2",
	2726:  "tams",
	2727:  "mgcp-callagent",
	2728:  "sqdr",
	2729:  "tcim-control",
	2730:  "nec-raidplus",
	2731:  "fyre-messanger",
	2732:  "g5m",
	2733:  "signet-ctf",
	2734:  "ccs-software",
	2735:  "netiq-mc",
	2736:  "radwiz-nms-srv",
	2737:  "srp-feedback",
	2738:  "ndl-tcp-ois-gw",
	2739:  "tn-timing",
	2740:  "alarm",
	2741:  "tsb",
	2742:  "tsb2",
	2743:  "murx",
	2744:  "honyaku",
	2745:  "urbisnet",
	2746:  "cpudpencap",
	2747:  "fjippol-swrly",
	2748:  "fjippol-polsvr",
	2749:  "fjippol-cnsl",
	2750:  "fjippol-port1",
	2751:  "fjippol-port2",
	2752:  "rsisysaccess",
	2753:  "de-spot",
	2754:  "apollo-cc",
	2755:  "expresspay",
	2756:  "simplement-tie",
	2757:  "cnrp",
	2758:  "apollo-status",
	2759:  "apollo-gms",
	2760:  "sabams",
	2761:  "dicom-iscl",
	2762:  "dicom-tls",
	2763:  "desktop-dna",
	2764:  "data-insurance",
	2765:  "qip-audup",
	2766:  "compaq-scp",
	2767:  "uadtc",
	2768:  "uacs",
	2769:  "exce",
	2770:  "veronica",
	2771:  "vergencecm",
	2772:  "auris",
	2773:  "rbakcup1",
	2774:  "rbakcup2",
	2775:  "smpp",
	2776:  "ridgeway1",
	2777:  "ridgeway2",
	2778:  "gwen-sonya",
	2779:  "lbc-sync",
	2780:  "lbc-control",
	2781:  "whosells",
	2782:  "everydayrc",
	2783:  "aises",
	2784:  "www-dev",
	2785:  "aic-np",
	2786:  "aic-oncrpc",
	2787:  "piccolo",
	2788:  "fryeserv",
	2789:  "media-agent",
	2790:  "plgproxy",
	2791:  "mtport-regist",
	2792:  "f5-globalsite",
	2793:  "initlsmsad",
	2795:  "livestats",
	2796:  "ac-tech",
	2797:  "esp-encap",
	2798:  "tmesis-upshot",
	2799:  "icon-discover",
	2800:  "acc-raid",
	2801:  "igcp",
	2802:  "veritas-udp1",
	2803:  "btprjctrl",
	2804:  "dvr-esm",
	2805:  "wta-wsp-s",
	2806:  "cspuni",
	2807:  "cspmulti",
	2808:  "j-lan-p",
	2809:  "corbaloc",
	2810:  "netsteward",
	2811:  "gsiftp",
	2812:  "atmtcp",
	2813:  "llm-pass",
	2814:  "llm-csv",
	2815:  "lbc-measure",
	2816:  "lbc-watchdog",
	2817:  "nmsigport",
	2818:  "rmlnk",
	2819:  "fc-faultnotify",
	2820:  "univision",
	2821:  "vrts-at-port",
	2822:  "ka0wuc",
	2823:  "cqg-netlan",
	2824:  "cqg-netlan-1",
	2826:  "slc-systemlog",
	2827:  "slc-ctrlrloops",
	2828:  "itm-lm",
	2829:  "silkp1",
	2830:  "silkp2",
	2831:  "silkp3",
	2832:  "silkp4",
	2833:  "glishd",
	2834:  "evtp",
	2835:  "evtp-data",
	2836:  "catalyst",
	2837:  "repliweb",
	2838:  "starbot",
	2839:  "nmsigport",
	2840:  "l3-exprt",
	2841:  "l3-ranger",
	2842:  "l3-hawk",
	2843:  "pdnet",
	2844:  "bpcp-poll",
	2845:  "bpcp-trap",
	2846:  "aimpp-hello",
	2847:  "aimpp-port-req",
	2848:  "amt-blc-port",
	2849:  "fxp",
	2850:  "metaconsole",
	2851:  "webemshttp",
	2852:  "bears-01",
	2853:  "ispipes",
	2854:  "infomover",
	2856:  "cesdinv",
	2857:  "simctlp",
	2858:  "ecnp",
	2859:  "activememory",
	2860:  "dialpad-voice1",
	2861:  "dialpad-voice2",
	2862:  "ttg-protocol",
	2863:  "sonardata",
	2864:  "astromed-main",
	2865:  "pit-vpn",
	2866:  "iwlistener",
	2867:  "esps-portal",
	2868:  "npep-messaging",
	2869:  "icslap",
	2870:  "daishi",
	2871:  "msi-selectplay",
	2872:  "radix",
	2874:  "dxmessagebase1",
	2875:  "dxmessagebase2",
	2876:  "sps-tunnel",
	2877:  "bluelance",
	2878:  "aap",
	2879:  "ucentric-ds",
	2880:  "synapse",
	2881:  "ndsp",
	2882:  "ndtp",
	2883:  "ndnp",
	2884:  "flashmsg",
	2885:  "topflow",
	2886:  "responselogic",
	2887:  "aironetddp",
	2888:  "spcsdlobby",
	2889:  "rsom",
	2890:  "cspclmulti",
	2891:  "cinegrfx-elmd",
	2892:  "snifferdata",
	2893:  "vseconnector",
	2894:  "abacus-remote",
	2895:  "natuslink",
	2896:  "ecovisiong6-1",
	2897:  "citrix-rtmp",
	2898:  "appliance-cfg",
	2899:  "powergemplus",
	2900:  "quicksuite",
	2901:  "allstorcns",
	2902:  "netaspi",
	2903:  "suitcase",
	2904:  "m2ua",
	2906:  "caller9",
	2907:  "webmethods-b2b",
	2908:  "mao",
	2909:  "funk-dialout",
	2910:  "tdaccess",
	2911:  "blockade",
	2912:  "epicon",
	2913:  "boosterware",
	2914:  "gamelobby",
	2915:  "tksocket",
	2916:  "elvin-server",
	2917:  "elvin-client",
	2918:  "kastenchasepad",
	2919:  "roboer",
	2920:  "roboeda",
	2921:  "cesdcdman",
	2922:  "cesdcdtrn",
	2923:  "wta-wsp-wtp-s",
	2924:  "precise-vip",
	2926:  "mobile-file-dl",
	2927:  "unimobilectrl",
	2928:  "redstone-cpss",
	2929:  "amx-webadmin",
	2930:  "amx-weblinx",
	2931:  "circle-x",
	2932:  "incp",
	2933:  "4-tieropmgw",
	2934:  "4-tieropmcli",
	2935:  "qtp",
	2936:  "otpatch",
	2937:  "pnaconsult-lm",
	2938:  "sm-pas-1",
	2939:  "sm-pas-2",
	2940:  "sm-pas-3",
	2941:  "sm-pas-4",
	2942:  "sm-pas-5",
	2943:  "ttnrepository",
	2944:  "megaco-h248",
	2945:  "h248-binary",
	2946:  "fjsvmpor",
	2947:  "gpsd",
	2948:  "wap-push",
	2949:  "wap-pushsecure",
	2950:  "esip",
	2951:  "ottp",
	2952:  "mpfwsas",
	2953:  "ovalarmsrv",
	2954:  "ovalarmsrv-cmd",
	2955:  "csnotify",
	2956:  "ovrimosdbman",
	2957:  "jmact5",
	2958:  "jmact6",
	2959:  "rmopagt",
	2960:  "dfoxserver",
	2961:  "boldsoft-lm",
	2962:  "iph-policy-cli",
	2963:  "iph-policy-adm",
	2964:  "bullant-srap",
	2965:  "bullant-rap",
	2966:  "idp-infotrieve",
	2967:  "ssc-agent",
	2968:  "enpp",
	2969:  "essp",
	2970:  "index-net",
	2971:  "netclip",
	2972:  "pmsm-webrctl",
	2973:  "svnetworks",
	2974:  "signal",
	2975:  "fjmpcm",
	2976:  "cns-srv-port",
	2977:  "ttc-etap-ns",
	2978:  "ttc-etap-ds",
	2979:  "h263-video",
	2980:  "wimd",
	2981:  "mylxamport",
	2982:  "iwb-whiteboard",
	2983:  "netplan",
	2984:  "hpidsadmin",
	2985:  "hpidsagent",
	2986:  "stonefalls",
	2987:  "identify",
	2988:  "hippad",
	2989:  "zarkov",
	2990:  "boscap",
	2991:  "wkstn-mon",
	2992:  "avenyo",
	2993:  "veritas-vis1",
	2994:  "veritas-vis2",
	2995:  "idrs",
	2996:  "vsixml",
	2997:  "rebol",
	2998:  "realsecure",
	2999:  "remoteware-un",
	3000:  "hbci",
	3002:  "exlm-agent",
	3003:  "cgms",
	3004:  "csoftragent",
	3005:  "geniuslm",
	3006:  "ii-admin",
	3007:  "lotusmtap",
	3008:  "midnight-tech",
	3009:  "pxc-ntfy",
	3010:  "ping-pong",
	3011:  "trusted-web",
	3012:  "twsdss",
	3013:  "gilatskysurfer",
	3014:  "broker-service",
	3015:  "nati-dstp",
	3016:  "notify-srvr",
	3017:  "event-listener",
	3018:  "srvc-registry",
	3019:  "resource-mgr",
	3020:  "cifs",
	3021:  "agriserver",
	3022:  "csregagent",
	3023:  "magicnotes",
	3024:  "nds-sso",
	3025:  "arepa-raft",
	3026:  "agri-gateway",
	3027:  "LiebDevMgmt-C",
	3028:  "LiebDevMgmt-DM",
	3029:  "LiebDevMgmt-A",
	3030:  "arepa-cas",
	3031:  "eppc",
	3032:  "redwood-chat",
	3033:  "pdb",
	3034:  "osmosis-aeea",
	3035:  "fjsv-gssagt",
	3036:  "hagel-dump",
	3037:  "hp-san-mgmt",
	3038:  "santak-ups",
	3039:  "cogitate",
	3040:  "tomato-springs",
	3041:  "di-traceware",
	3042:  "journee",
	3043:  "brp",
	3044:  "epp",
	3045:  "responsenet",
	3046:  "di-ase",
	3047:  "hlserver",
	3048:  "pctrader",
	3049:  "nsws",
	3050:  "gds-db",
	3051:  "galaxy-server",
	3052:  "apc-3052",
	3053:  "dsom-server",
	3054:  "amt-cnf-prot",
	3055:  "policyserver",
	3056:  "cdl-server",
	3057:  "goahead-fldup",
	3058:  "videobeans",
	3059:  "qsoft",
	3060:  "interserver",
	3061:  "cautcpd",
	3062:  "ncacn-ip-tcp",
	3063:  "ncadg-ip-udp",
	3064:  "rprt",
	3065:  "slinterbase",
	3066:  "netattachsdmp",
	3067:  "fjhpjp",
	3068:  "ls3bcast",
	3069:  "ls3",
	3070:  "mgxswitch",
	3072:  "csd-monitor",
	3073:  "vcrp",
	3074:  "xbox",
	3075:  "orbix-locator",
	3076:  "orbix-config",
	3077:  "orbix-loc-ssl",
	3078:  "orbix-cfg-ssl",
	3079:  "lv-frontpanel",
	3080:  "stm-pproc",
	3081:  "tl1-lv",
	3082:  "tl1-raw",
	3083:  "tl1-telnet",
	3084:  "itm-mccs",
	3085:  "pcihreq",
	3086:  "jdl-dbkitchen",
	3087:  "asoki-sma",
	3088:  "xdtp",
	3089:  "ptk-alink",
	3090:  "stss",
	3091:  "1ci-smcs",
	3093:  "rapidmq-center",
	3094:  "rapidmq-reg",
	3095:  "panasas",
	3096:  "ndl-aps",
	3098:  "umm-port",
	3099:  "chmd",
	3100:  "opcon-xps",
	3101:  "hp-pxpib",
	3102:  "slslavemon",
	3103:  "autocuesmi",
	3104:  "autocuetime",
	3105:  "cardbox",
	3106:  "cardbox-http",
	3107:  "business",
	3108:  "geolocate",
	3109:  "personnel",
	3110:  "sim-control",
	3111:  "wsynch",
	3112:  "ksysguard",
	3113:  "cs-auth-svr",
	3114:  "ccmad",
	3115:  "mctet-master",
	3116:  "mctet-gateway",
	3117:  "mctet-jserv",
	3118:  "pkagent",
	3119:  "d2000kernel",
	3120:  "d2000webserver",
	3122:  "vtr-emulator",
	3123:  "edix",
	3124:  "beacon-port",
	3125:  "a13-an",
	3127:  "ctx-bridge",
	3128:  "ndl-aas",
	3129:  "netport-id",
	3130:  "icpv2",
	3131:  "netbookmark",
	3132:  "ms-rule-engine",
	3133:  "prism-deploy",
	3134:  "ecp",
	3135:  "peerbook-port",
	3136:  "grubd",
	3137:  "rtnt-1",
	3138:  "rtnt-2",
	3139:  "incognitorv",
	3140:  "ariliamulti",
	3141:  "vmodem",
	3142:  "rdc-wh-eos",
	3143:  "seaview",
	3144:  "tarantella",
	3145:  "csi-lfap",
	3146:  "bears-02",
	3147:  "rfio",
	3148:  "nm-game-admin",
	3149:  "nm-game-server",
	3150:  "nm-asses-admin",
	3151:  "nm-assessor",
	3152:  "feitianrockey",
	3153:  "s8-client-port",
	3154:  "ccmrmi",
	3155:  "jpegmpeg",
	3156:  "indura",
	3157:  "e3consultants",
	3158:  "stvp",
	3159:  "navegaweb-port",
	3160:  "tip-app-server",
	3161:  "doc1lm",
	3162:  "sflm",
	3163:  "res-sap",
	3164:  "imprs",
	3165:  "newgenpay",
	3166:  "sossecollector",
	3167:  "nowcontact",
	3168:  "poweronnud",
	3169:  "serverview-as",
	3170:  "serverview-asn",
	3171:  "serverview-gf",
	3172:  "serverview-rm",
	3173:  "serverview-icc",
	3174:  "armi-server",
	3175:  "t1-e1-over-ip",
	3176:  "ars-master",
	3177:  "phonex-port",
	3178:  "radclientport",
	3179:  "h2gf-w-2m",
	3180:  "mc-brk-srv",
	3181:  "bmcpatrolagent",
	3182:  "bmcpatrolrnvu",
	3183:  "cops-tls",
	3184:  "apogeex-port",
	3185:  "smpppd",
	3186:  "iiw-port",
	3187:  "odi-port",
	3188:  "brcm-comm-port",
	3189:  "pcle-infex",
	3190:  "csvr-proxy",
	3191:  "csvr-sslproxy",
	3192:  "firemonrcc",
	3193:  "spandataport",
	3194:  "magbind",
	3195:  "ncu-1",
	3196:  "ncu-2",
	3197:  "embrace-dp-s",
	3198:  "embrace-dp-c",
	3199:  "dmod-workspace",
	3200:  "tick-port",
	3201:  "cpq-tasksmart",
	3202:  "intraintra",
	3203:  "netwatcher-mon",
	3204:  "netwatcher-db",
	3205:  "isns",
	3206:  "ironmail",
	3207:  "vx-auth-port",
	3208:  "pfu-prcallback",
	3209:  "netwkpathengine",
	3210:  "flamenco-proxy",
	3211:  "avsecuremgmt",
	3212:  "surveyinst",
	3213:  "neon24x7",
	3214:  "jmq-daemon-1",
	3215:  "jmq-daemon-2",
	3216:  "ferrari-foam",
	3217:  "unite",
	3218:  "smartpackets",
	3219:  "wms-messenger",
	3220:  "xnm-ssl",
	3221:  "xnm-clear-text",
	3222:  "glbp",
	3223:  "digivote",
	3224:  "aes-discovery",
	3225:  "fcip-port",
	3226:  "isi-irp",
	3227:  "dwnmshttp",
	3228:  "dwmsgserver",
	3229:  "global-cd-port",
	3230:  "sftdst-port",
	3231:  "vidigo",
	3232:  "mdtp",
	3233:  "whisker",
	3234:  "alchemy",
	3235:  "mdap-port",
	3236:  "apparenet-ts",
	3237:  "apparenet-tps",
	3238:  "apparenet-as",
	3239:  "apparenet-ui",
	3240:  "triomotion",
	3241:  "sysorb",
	3242:  "sdp-id-port",
	3243:  "timelot",
	3244:  "onesaf",
	3245:  "vieo-fe",
	3246:  "dvt-system",
	3247:  "dvt-data",
	3248:  "procos-lm",
	3249:  "ssp",
	3250:  "hicp",
	3251:  "sysscanner",
	3252:  "dhe",
	3253:  "pda-data",
	3254:  "pda-sys",
	3255:  "semaphore",
	3256:  "cpqrpm-agent",
	3257:  "cpqrpm-server",
	3258:  "ivecon-port",
	3259:  "epncdp2",
	3260:  "iscsi-target",
	3261:  "winshadow",
	3262:  "necp",
	3263:  "ecolor-imager",
	3264:  "ccmail",
	3265:  "altav-tunnel",
	3266:  "ns-cfg-server",
	3267:  "ibm-dial-out",
	3268:  "msft-gc",
	3269:  "msft-gc-ssl",
	3270:  "verismart",
	3271:  "csoft-prev",
	3272:  "user-manager",
	3273:  "sxmp",
	3274:  "ordinox-server",
	3275:  "samd",
	3276:  "maxim-asics",
	3277:  "awg-proxy",
	3278:  "lkcmserver",
	3279:  "admind",
	3280:  "vs-server",
	3281:  "sysopt",
	3282:  "datusorb",
	3283:  "Apple Remote Desktop (Net Assistant)",
	3284:  "4talk",
	3285:  "plato",
	3286:  "e-net",
	3287:  "directvdata",
	3288:  "cops",
	3289:  "enpc",
	3290:  "caps-lm",
	3291:  "sah-lm",
	3292:  "cart-o-rama",
	3293:  "fg-fps",
	3294:  "fg-gip",
	3295:  "dyniplookup",
	3296:  "rib-slm",
	3297:  "cytel-lm",
	3298:  "deskview",
	3299:  "pdrncs",
	3302:  "mcs-fastmail",
	3303:  "opsession-clnt",
	3304:  "opsession-srvr",
	3305:  "odette-ftp",
	3306:  "mysql",
	3307:  "opsession-prxy",
	3308:  "tns-server",
	3309:  "tns-adv",
	3310:  "dyna-access",
	3311:  "mcns-tel-ret",
	3312:  "appman-server",
	3313:  "uorb",
	3314:  "uohost",
	3315:  "cdid",
	3316:  "aicc-cmi",
	3317:  "vsaiport",
	3318:  "ssrip",
	3319:  "sdt-lmd",
	3320:  "officelink2000",
	3321:  "vnsstr",
	3326:  "sftu",
	3327:  "bbars",
	3328:  "egptlm",
	3329:  "hp-device-disc",
	3330:  "mcs-calypsoicf",
	3331:  "mcs-messaging",
	3332:  "mcs-mailsvr",
	3333:  "dec-notes",
	3334:  "directv-web",
	3335:  "directv-soft",
	3336:  "directv-tick",
	3337:  "directv-catlg",
	3338:  "anet-b",
	3339:  "anet-l",
	3340:  "anet-m",
	3341:  "anet-h",
	3342:  "webtie",
	3343:  "ms-cluster-net",
	3344:  "bnt-manager",
	3345:  "influence",
	3346:  "trnsprntproxy",
	3347:  "phoenix-rpc",
	3348:  "pangolin-laser",
	3349:  "chevinservices",
	3350:  "findviatv",
	3351:  "btrieve",
	3352:  "ssql",
	3353:  "fatpipe",
	3354:  "suitjd",
	3355:  "ordinox-dbase",
	3356:  "upnotifyps",
	3357:  "adtech-test",
	3358:  "mpsysrmsvr",
	3359:  "wg-netforce",
	3360:  "kv-server",
	3361:  "kv-agent",
	3362:  "dj-ilm",
	3363:  "nati-vi-server",
	3364:  "creativeserver",
	3365:  "contentserver",
	3366:  "creativepartnr",
	3372:  "tip2",
	3373:  "lavenir-lm",
	3374:  "cluster-disc",
	3375:  "vsnm-agent",
	3376:  "cdbroker",
	3377:  "cogsys-lm",
	3378:  "wsicopy",
	3379:  "socorfs",
	3380:  "sns-channels",
	3381:  "geneous",
	3382:  "fujitsu-neat",
	3383:  "esp-lm",
	3384:  "hp-clic",
	3385:  "qnxnetman",
	3386:  "gprs-sig",
	3387:  "backroomnet",
	3388:  "cbserver",
	3389:  "ms-wbt-server",
	3390:  "dsc",
	3391:  "savant",
	3392:  "efi-lm",
	3393:  "d2k-tapestry1",
	3394:  "d2k-tapestry2",
	3395:  "dyna-lm",
	3396:  "printer-agent",
	3397:  "cloanto-lm",
	3398:  "mercantile",
	3399:  "csms",
	3400:  "csms2",
	3401:  "filecast",
	3402:  "fxaengine-net",
	3405:  "nokia-ann-ch1",
	3406:  "nokia-ann-ch2",
	3407:  "ldap-admin",
	3408:  "BESApi",
	3409:  "networklens",
	3410:  "networklenss",
	3411:  "biolink-auth",
	3412:  "xmlblaster",
	3413:  "svnet",
	3414:  "wip-port",
	3415:  "bcinameservice",
	3416:  "commandport",
	3417:  "csvr",
	3418:  "rnmap",
	3419:  "softaudit",
	3420:  "ifcp-port",
	3421:  "bmap",
	3422:  "rusb-sys-port",
	3423:  "xtrm",
	3424:  "xtrms",
	3425:  "agps-port",
	3426:  "arkivio",
	3427:  "websphere-snmp",
	3428:  "twcss",
	3429:  "gcsp",
	3430:  "ssdispatch",
	3431:  "ndl-als",
	3432:  "osdcp",
	3433:  "opnet-smp",
	3434:  "opencm",
	3435:  "pacom",
	3436:  "gc-config",
	3437:  "autocueds",
	3438:  "spiral-admin",
	3439:  "hri-port",
	3440:  "ans-console",
	3441:  "connect-client",
	3442:  "connect-server",
	3443:  "ov-nnm-websrv",
	3444:  "denali-server",
	3445:  "monp",
	3446:  "3comfaxrpc",
	3447:  "directnet",
	3448:  "dnc-port",
	3449:  "hotu-chat",
	3450:  "castorproxy",
	3451:  "asam",
	3452:  "sabp-signal",
	3453:  "pscupd",
	3454:  "mira",
	3455:  "prsvp",
	3456:  "vat",
	3457:  "vat-control",
	3458:  "d3winosfi",
	3459:  "integral",
	3460:  "edm-manager",
	3461:  "edm-stager",
	3462:  "edm-std-notify",
	3463:  "edm-adm-notify",
	3464:  "edm-mgr-sync",
	3465:  "edm-mgr-cntrl",
	3466:  "workflow",
	3467:  "rcst",
	3468:  "ttcmremotectrl",
	3469:  "pluribus",
	3470:  "jt400",
	3471:  "jt400-ssl",
	3472:  "jaugsremotec-1",
	3473:  "jaugsremotec-2",
	3474:  "ttntspauto",
	3475:  "genisar-port",
	3476:  "nppmp",
	3477:  "ecomm",
	3478:  "stun",
	3479:  "twrpc",
	3480:  "plethora",
	3481:  "cleanerliverc",
	3482:  "vulture",
	3483:  "slim-devices",
	3484:  "gbs-stp",
	3485:  "celatalk",
	3486:  "ifsf-hb-port",
	3487:  "ltcudp",
	3488:  "fs-rh-srv",
	3489:  "dtp-dia",
	3490:  "colubris",
	3491:  "swr-port",
	3492:  "tvdumtray-port",
	3493:  "nut",
	3494:  "ibm3494",
	3495:  "seclayer-tcp",
	3496:  "seclayer-tls",
	3497:  "ipether232port",
	3498:  "dashpas-port",
	3499:  "sccip-media",
	3500:  "rtmp-port",
	3501:  "isoft-p2p",
	3502:  "avinstalldisc",
	3503:  "lsp-ping",
	3504:  "ironstorm",
	3505:  "ccmcomm",
	3506:  "apc-3506",
	3507:  "nesh-broker",
	3508:  "interactionweb",
	3509:  "vt-ssl",
	3510:  "xss-port",
	3511:  "webmail-2",
	3512:  "aztec",
	3513:  "arcpd",
	3514:  "must-p2p",
	3515:  "must-backplane",
	3516:  "smartcard-port",
	3517:  "802-11-iapp",
	3518:  "artifact-msg",
	3519:  "galileo",
	3520:  "galileolog",
	3521:  "mc3ss",
	3522:  "nssocketport",
	3523:  "odeumservlink",
	3524:  "ecmport",
	3525:  "eisport",
	3526:  "starquiz-port",
	3527:  "beserver-msg-q",
	3528:  "jboss-iiop",
	3529:  "jboss-iiop-ssl",
	3530:  "gf",
	3531:  "joltid",
	3532:  "raven-rmp",
	3533:  "raven-rdp",
	3534:  "urld-port",
	3535:  "ms-la",
	3536:  "snac",
	3537:  "ni-visa-remote",
	3538:  "ibm-diradm",
	3539:  "ibm-diradm-ssl",
	3540:  "pnrp-port",
	3541:  "voispeed-port",
	3542:  "hacl-monitor",
	3543:  "qftest-lookup",
	3544:  "teredo",
	3545:  "camac",
	3547:  "symantec-sim",
	3548:  "interworld",
	3549:  "tellumat-nms",
	3550:  "ssmpp",
	3551:  "apcupsd",
	3552:  "taserver",
	3553:  "rbr-discovery",
	3554:  "questnotify",
	3555:  "razor",
	3556:  "sky-transport",
	3557:  "personalos-001",
	3558:  "mcp-port",
	3559:  "cctv-port",
	3560:  "iniserve-port",
	3561:  "bmc-onekey",
	3562:  "sdbproxy",
	3563:  "watcomdebug",
	3564:  "esimport",
	3567:  "dof-eps",
	3568:  "dof-tunnel-sec",
	3569:  "mbg-ctrl",
	3570:  "mccwebsvr-port",
	3571:  "megardsvr-port",
	3572:  "megaregsvrport",
	3573:  "tag-ups-1",
	3574:  "dmaf-caster",
	3575:  "ccm-port",
	3576:  "cmc-port",
	3577:  "config-port",
	3578:  "data-port",
	3579:  "ttat3lb",
	3580:  "nati-svrloc",
	3581:  "kfxaclicensing",
	3582:  "press",
	3583:  "canex-watch",
	3584:  "u-dbap",
	3585:  "emprise-lls",
	3586:  "emprise-lsc",
	3587:  "p2pgroup",
	3588:  "sentinel",
	3589:  "isomair",
	3590:  "wv-csp-sms",
	3591:  "gtrack-server",
	3592:  "gtrack-ne",
	3593:  "bpmd",
	3594:  "mediaspace",
	3595:  "shareapp",
	3596:  "iw-mmogame",
	3597:  "a14",
	3598:  "a15",
	3599:  "quasar-server",
	3600:  "trap-daemon",
	3601:  "visinet-gui",
	3602:  "infiniswitchcl",
	3603:  "int-rcv-cntrl",
	3604:  "bmc-jmx-port",
	3605:  "comcam-io",
	3606:  "splitlock",
	3607:  "precise-i3",
	3608:  "trendchip-dcp",
	3609:  "cpdi-pidas-cm",
	3610:  "echonet",
	3611:  "six-degrees",
	3612:  "hp-dataprotect",
	3613:  "alaris-disc",
	3614:  "sigma-port",
	3615:  "start-network",
	3616:  "cd3o-protocol",
	3617:  "sharp-server",
	3618:  "aairnet-1",
	3619:  "aairnet-2",
	3620:  "ep-pcp",
	3621:  "ep-nsp",
	3622:  "ff-lr-port",
	3623:  "haipe-discover",
	3624:  "dist-upgrade",
	3625:  "volley",
	3626:  "bvcdaemon-port",
	3627:  "jamserverport",
	3628:  "ept-machine",
	3629:  "escvpnet",
	3630:  "cs-remote-db",
	3631:  "cs-services",
	3632:  "distcc",
	3633:  "wacp",
	3634:  "hlibmgr",
	3635:  "sdo",
	3636:  "servistaitsm",
	3637:  "scservp",
	3638:  "ehp-backup",
	3639:  "xap-ha",
	3640:  "netplay-port1",
	3641:  "netplay-port2",
	3642:  "juxml-port",
	3643:  "audiojuggler",
	3644:  "ssowatch",
	3645:  "cyc",
	3646:  "xss-srv-port",
	3647:  "splitlock-gw",
	3648:  "fjcp",
	3649:  "nmmp",
	3650:  "prismiq-plugin",
	3651:  "xrpc-registry",
	3652:  "vxcrnbuport",
	3653:  "tsp",
	3654:  "vaprtm",
	3655:  "abatemgr",
	3656:  "abatjss",
	3657:  "immedianet-bcn",
	3658:  "ps-ams",
	3659:  "apple-sasl",
	3660:  "can-nds-ssl",
	3661:  "can-ferret-ssl",
	3662:  "pserver",
	3663:  "dtp",
	3664:  "ups-engine",
	3665:  "ent-engine",
	3666:  "eserver-pap",
	3667:  "infoexch",
	3668:  "dell-rm-port",
	3669:  "casanswmgmt",
	3670:  "smile",
	3671:  "efcp",
	3672:  "lispworks-orb",
	3673:  "mediavault-gui",
	3674:  "wininstall-ipc",
	3675:  "calltrax",
	3676:  "va-pacbase",
	3677:  "roverlog",
	3678:  "ipr-dglt",
	3679:  "Escale (Newton Dock)",
	3680:  "npds-tracker",
	3681:  "bts-x73",
	3682:  "cas-mapi",
	3683:  "bmc-ea",
	3684:  "faxstfx-port",
	3685:  "dsx-agent",
	3686:  "tnmpv2",
	3687:  "simple-push",
	3688:  "simple-push-s",
	3689:  "daap",
	3690:  "svn",
	3691:  "magaya-network",
	3692:  "intelsync",
	3695:  "bmc-data-coll",
	3696:  "telnetcpcd",
	3697:  "nw-license",
	3698:  "sagectlpanel",
	3699:  "kpn-icw",
	3700:  "lrs-paging",
	3701:  "netcelera",
	3702:  "ws-discovery",
	3703:  "adobeserver-3",
	3704:  "adobeserver-4",
	3705:  "adobeserver-5",
	3706:  "rt-event",
	3707:  "rt-event-s",
	3708:  "sun-as-iiops",
	3709:  "ca-idms",
	3710:  "portgate-auth",
	3711:  "edb-server2",
	3712:  "sentinel-ent",
	3713:  "tftps",
	3714:  "delos-dms",
	3715:  "anoto-rendezv",
	3716:  "wv-csp-sms-cir",
	3717:  "wv-csp-udp-cir",
	3718:  "opus-services",
	3719:  "itelserverport",
	3720:  "ufastro-instr",
	3721:  "xsync",
	3722:  "xserveraid",
	3723:  "sychrond",
	3724:  "blizwow",
	3725:  "na-er-tip",
	3726:  "array-manager",
	3727:  "e-mdu",
	3728:  "e-woa",
	3729:  "fksp-audit",
	3730:  "client-ctrl",
	3731:  "smap",
	3732:  "m-wnn",
	3733:  "multip-msg",
	3734:  "synel-data",
	3735:  "pwdis",
	3736:  "rs-rmi",
	3738:  "versatalk",
	3739:  "launchbird-lm",
	3740:  "heartbeat",
	3741:  "wysdma",
	3742:  "cst-port",
	3743:  "ipcs-command",
	3744:  "sasg",
	3745:  "gw-call-port",
	3746:  "linktest",
	3747:  "linktest-s",
	3748:  "webdata",
	3749:  "cimtrak",
	3750:  "cbos-ip-port",
	3751:  "gprs-cube",
	3752:  "vipremoteagent",
	3753:  "nattyserver",
	3754:  "timestenbroker",
	3755:  "sas-remote-hlp",
	3756:  "canon-capt",
	3757:  "grf-port",
	3758:  "apw-registry",
	3759:  "exapt-lmgr",
	3760:  "adtempusclient",
	3761:  "gsakmp",
	3762:  "gbs-smp",
	3763:  "xo-wave",
	3764:  "mni-prot-rout",
	3765:  "rtraceroute",
	3767:  "listmgr-port",
	3768:  "rblcheckd",
	3769:  "haipe-otnk",
	3770:  "cindycollab",
	3771:  "paging-port",
	3772:  "ctp",
	3773:  "ctdhercules",
	3774:  "zicom",
	3775:  "ispmmgr",
	3776:  "dvcprov-port",
	3777:  "jibe-eb",
	3778:  "c-h-it-port",
	3779:  "cognima",
	3780:  "nnp",
	3781:  "abcvoice-port",
	3782:  "iso-tp0s",
	3783:  "bim-pem",
	3784:  "bfd-control",
	3785:  "bfd-echo",
	3786:  "upstriggervsw",
	3787:  "fintrx",
	3788:  "isrp-port",
	3789:  "remotedeploy",
	3790:  "quickbooksrds",
	3791:  "tvnetworkvideo",
	3792:  "sitewatch",
	3793:  "dcsoftware",
	3794:  "jaus",
	3795:  "myblast",
	3796:  "spw-dialer",
	3797:  "idps",
	3798:  "minilock",
	3799:  "radius-dynauth",
	3800:  "pwgpsi",
	3801:  "ibm-mgr",
	3802:  "vhd",
	3803:  "soniqsync",
	3804:  "iqnet-port",
	3805:  "tcpdataserver",
	3806:  "wsmlb",
	3807:  "spugna",
	3808:  "sun-as-iiops-ca",
	3809:  "apocd",
	3810:  "wlanauth",
	3811:  "amp",
	3812:  "neto-wol-server",
	3813:  "rap-ip",
	3814:  "neto-dcs",
	3815:  "lansurveyorxml",
	3816:  "sunlps-http",
	3817:  "tapeware",
	3818:  "crinis-hb",
	3819:  "epl-slp",
	3820:  "scp",
	3821:  "pmcp",
	3822:  "acp-discovery",
	3823:  "acp-conduit",
	3824:  "acp-policy",
	3825:  "ffserver",
	3826:  "warmux",
	3827:  "netmpi",
	3828:  "neteh",
	3829:  "neteh-ext",
	3830:  "cernsysmgmtagt",
	3831:  "dvapps",
	3832:  "xxnetserver",
	3833:  "aipn-auth",
	3834:  "spectardata",
	3835:  "spectardb",
	3836:  "markem-dcp",
	3837:  "mkm-discovery",
	3838:  "sos",
	3839:  "amx-rms",
	3840:  "flirtmitmir",
	3842:  "nhci",
	3843:  "quest-agent",
	3844:  "rnm",
	3845:  "v-one-spp",
	3846:  "an-pcp",
	3847:  "msfw-control",
	3848:  "item",
	3849:  "spw-dnspreload",
	3850:  "qtms-bootstrap",
	3851:  "spectraport",
	3852:  "sse-app-config",
	3853:  "sscan",
	3854:  "stryker-com",
	3855:  "opentrac",
	3856:  "informer",
	3857:  "trap-port",
	3858:  "trap-port-mom",
	3859:  "nav-port",
	3860:  "sasp",
	3861:  "winshadow-hd",
	3862:  "giga-pocket",
	3863:  "asap-udp",
	3865:  "xpl",
	3866:  "dzdaemon",
	3867:  "dzoglserver",
	3869:  "ovsam-mgmt",
	3870:  "ovsam-d-agent",
	3871:  "avocent-adsap",
	3872:  "oem-agent",
	3873:  "fagordnc",
	3874:  "sixxsconfig",
	3875:  "pnbscada",
	3876:  "dl-agent",
	3877:  "xmpcr-interface",
	3878:  "fotogcad",
	3879:  "appss-lm",
	3880:  "igrs",
	3881:  "idac",
	3882:  "msdts1",
	3883:  "vrpn",
	3884:  "softrack-meter",
	3885:  "topflow-ssl",
	3886:  "nei-management",
	3887:  "ciphire-data",
	3888:  "ciphire-serv",
	3889:  "dandv-tester",
	3890:  "ndsconnect",
	3891:  "rtc-pm-port",
	3892:  "pcc-image-port",
	3893:  "cgi-starapi",
	3894:  "syam-agent",
	3895:  "syam-smc",
	3896:  "sdo-tls",
	3897:  "sdo-ssh",
	3898:  "senip",
	3899:  "itv-control",
	3900:  "udt-os",
	3901:  "nimsh",
	3902:  "nimaux",
	3903:  "charsetmgr",
	3904:  "omnilink-port",
	3905:  "mupdate",
	3906:  "topovista-data",
	3907:  "imoguia-port",
	3908:  "hppronetman",
	3909:  "surfcontrolcpa",
	3910:  "prnrequest",
	3911:  "prnstatus",
	3912:  "gbmt-stars",
	3913:  "listcrt-port",
	3914:  "listcrt-port-2",
	3915:  "agcat",
	3916:  "wysdmc",
	3917:  "aftmux",
	3918:  "pktcablemmcops",
	3919:  "hyperip",
	3920:  "exasoftport1",
	3921:  "herodotus-net",
	3922:  "sor-update",
	3923:  "symb-sb-port",
	3924:  "mpl-gprs-port",
	3925:  "zmp",
	3926:  "winport",
	3927:  "natdataservice",
	3928:  "netboot-pxe",
	3929:  "smauth-port",
	3930:  "syam-webserver",
	3931:  "msr-plugin-port",
	3932:  "dyn-site",
	3933:  "plbserve-port",
	3934:  "sunfm-port",
	3935:  "sdp-portmapper",
	3936:  "mailprox",
	3937:  "dvbservdsc",
	3938:  "dbcontrol-agent",
	3939:  "aamp",
	3940:  "xecp-node",
	3941:  "homeportal-web",
	3942:  "srdp",
	3943:  "tig",
	3944:  "sops",
	3945:  "emcads",
	3946:  "backupedge",
	3947:  "ccp",
	3948:  "apdap",
	3949:  "drip",
	3950:  "namemunge",
	3951:  "pwgippfax",
	3952:  "i3-sessionmgr",
	3953:  "xmlink-connect",
	3954:  "adrep",
	3955:  "p2pcommunity",
	3956:  "gvcp",
	3957:  "mqe-broker",
	3958:  "mqe-agent",
	3959:  "treehopper",
	3960:  "bess",
	3961:  "proaxess",
	3962:  "sbi-agent",
	3963:  "thrp",
	3964:  "sasggprs",
	3965:  "ati-ip-to-ncpe",
	3966:  "bflckmgr",
	3967:  "ppsms",
	3968:  "ianywhere-dbns",
	3969:  "landmarks",
	3970:  "lanrevagent",
	3971:  "lanrevserver",
	3972:  "iconp",
	3973:  "progistics",
	3974:  "citysearch",
	3975:  "airshot",
	3976:  "opswagent",
	3977:  "opswmanager",
	3978:  "secure-cfg-svr",
	3979:  "smwan",
	3980:  "acms",
	3981:  "starfish",
	3982:  "eis",
	3983:  "eisp",
	3984:  "mapper-nodemgr",
	3985:  "mapper-mapethd",
	3986:  "mapper-ws-ethd",
	3987:  "centerline",
	3988:  "dcs-config",
	3989:  "bv-queryengine",
	3990:  "bv-is",
	3991:  "bv-smcsrv",
	3992:  "bv-ds",
	3993:  "bv-agent",
	3995:  "iss-mgmt-ssl",
	3996:  "abcsoftware",
	3997:  "agentsease-db",
	3998:  "dnx",
	3999:  "nvcnet",
	4000:  "terabase",
	4001:  "newoak",
	4002:  "pxc-spvr-ft",
	4003:  "pxc-splr-ft",
	4004:  "pxc-roid",
	4005:  "pxc-pin",
	4006:  "pxc-spvr",
	4007:  "pxc-splr",
	4008:  "netcheque",
	4009:  "chimera-hwm",
	4010:  "samsung-unidex",
	4011:  "altserviceboot",
	4012:  "pda-gate",
	4013:  "acl-manager",
	4014:  "taiclock",
	4015:  "talarian-mcast1",
	4016:  "talarian-mcast2",
	4017:  "talarian-mcast3",
	4018:  "talarian-mcast4",
	4019:  "talarian-mcast5",
	4020:  "trap",
	4021:  "nexus-portal",
	4022:  "dnox",
	4023:  "esnm-zoning",
	4024:  "tnp1-port",
	4025:  "partimage",
	4026:  "as-debug",
	4027:  "bxp",
	4028:  "dtserver-port",
	4029:  "ip-qsig",
	4030:  "jdmn-port",
	4031:  "suucp",
	4032:  "vrts-auth-port",
	4033:  "sanavigator",
	4034:  "ubxd",
	4035:  "wap-push-http",
	4036:  "wap-push-https",
	4037:  "ravehd",
	4038:  "fazzt-ptp",
	4039:  "fazzt-admin",
	4040:  "yo-main",
	4041:  "houston",
	4042:  "ldxp",
	4043:  "nirp",
	4044:  "ltp",
	4045:  "npp",
	4046:  "acp-proto",
	4047:  "ctp-state",
	4049:  "wafs",
	4050:  "cisco-wafs",
	4051:  "cppdp",
	4052:  "interact",
	4053:  "ccu-comm-1",
	4054:  "ccu-comm-2",
	4055:  "ccu-comm-3",
	4056:  "lms",
	4057:  "wfm",
	4058:  "kingfisher",
	4059:  "dlms-cosem",
	4060:  "dsmeter-iatc",
	4061:  "ice-location",
	4062:  "ice-slocation",
	4063:  "ice-router",
	4064:  "ice-srouter",
	4065:  "avanti-cdp",
	4066:  "pmas",
	4067:  "idp",
	4068:  "ipfltbcst",
	4069:  "minger",
	4070:  "tripe",
	4071:  "aibkup",
	4072:  "zieto-sock",
	4073:  "iRAPP",
	4074:  "cequint-cityid",
	4075:  "perimlan",
	4076:  "seraph",
	4077:  "ascomalarm",
	4079:  "santools",
	4080:  "lorica-in",
	4081:  "lorica-in-sec",
	4082:  "lorica-out",
	4083:  "lorica-out-sec",
	4084:  "fortisphere-vm",
	4086:  "ftsync",
	4089:  "opencore",
	4090:  "omasgport",
	4091:  "ewinstaller",
	4092:  "ewdgs",
	4093:  "pvxpluscs",
	4094:  "sysrqd",
	4095:  "xtgui",
	4096:  "bre",
	4097:  "patrolview",
	4098:  "drmsfsd",
	4099:  "dpcp",
	4100:  "igo-incognito",
	4101:  "brlp-0",
	4102:  "brlp-1",
	4103:  "brlp-2",
	4104:  "brlp-3",
	4105:  "shofar",
	4106:  "synchronite",
	4107:  "j-ac",
	4108:  "accel",
	4109:  "izm",
	4110:  "g2tag",
	4111:  "xgrid",
	4112:  "apple-vpns-rp",
	4113:  "aipn-reg",
	4114:  "jomamqmonitor",
	4115:  "cds",
	4116:  "smartcard-tls",
	4117:  "hillrserv",
	4118:  "netscript",
	4119:  "assuria-slm",
	4121:  "e-builder",
	4122:  "fprams",
	4123:  "z-wave",
	4124:  "tigv2",
	4125:  "opsview-envoy",
	4126:  "ddrepl",
	4127:  "unikeypro",
	4128:  "nufw",
	4129:  "nuauth",
	4130:  "fronet",
	4131:  "stars",
	4132:  "nuts-dem",
	4133:  "nuts-bootp",
	4134:  "nifty-hmi",
	4135:  "cl-db-attach",
	4136:  "cl-db-request",
	4137:  "cl-db-remote",
	4138:  "nettest",
	4139:  "thrtx",
	4140:  "cedros-fds",
	4141:  "oirtgsvc",
	4142:  "oidocsvc",
	4143:  "oidsr",
	4145:  "vvr-control",
	4146:  "tgcconnect",
	4147:  "vrxpservman",
	4148:  "hhb-handheld",
	4149:  "agslb",
	4150:  "PowerAlert-nsa",
	4151:  "menandmice-noh",
	4152:  "idig-mux",
	4153:  "mbl-battd",
	4154:  "atlinks",
	4155:  "bzr",
	4156:  "stat-results",
	4157:  "stat-scanner",
	4158:  "stat-cc",
	4159:  "nss",
	4160:  "jini-discovery",
	4161:  "omscontact",
	4162:  "omstopology",
	4163:  "silverpeakpeer",
	4164:  "silverpeakcomm",
	4165:  "altcp",
	4166:  "joost",
	4167:  "ddgn",
	4168:  "pslicser",
	4169:  "iadt-disc",
	4172:  "pcoip",
	4173:  "mma-discovery",
	4174:  "sm-disc",
	4177:  "wello",
	4178:  "storman",
	4179:  "MaxumSP",
	4180:  "httpx",
	4181:  "macbak",
	4182:  "pcptcpservice",
	4183:  "cyborgnet",
	4184:  "universe-suite",
	4185:  "wcpp",
	4188:  "vatata",
	4191:  "dsmipv6",
	4192:  "azeti-bd",
	4197:  "hctl",
	4199:  "eims-admin",
	4300:  "corelccam",
	4301:  "d-data",
	4302:  "d-data-control",
	4303:  "srcp",
	4304:  "owserver",
	4305:  "batman",
	4306:  "pinghgl",
	4307:  "trueconf",
	4308:  "compx-lockview",
	4309:  "dserver",
	4310:  "mirrtex",
	4320:  "fdt-rcatp",
	4321:  "rwhois",
	4322:  "trim-event",
	4323:  "trim-ice",
	4325:  "geognosisman",
	4326:  "geognosis",
	4327:  "jaxer-web",
	4328:  "jaxer-manager",
	4333:  "ahsp",
	4340:  "gaia",
	4341:  "lisp-data",
	4342:  "lisp-control",
	4343:  "unicall",
	4344:  "vinainstall",
	4345:  "m4-network-as",
	4346:  "elanlm",
	4347:  "lansurveyor",
	4348:  "itose",
	4349:  "fsportmap",
	4350:  "net-device",
	4351:  "plcy-net-svcs",
	4352:  "pjlink",
	4353:  "f5-iquery",
	4354:  "qsnet-trans",
	4355:  "qsnet-workst",
	4356:  "qsnet-assist",
	4357:  "qsnet-cond",
	4358:  "qsnet-nucl",
	4359:  "omabcastltkm",
	4361:  "nacnl",
	4362:  "afore-vdp-disc",
	4366:  "shadowstream",
	4368:  "wxbrief",
	4369:  "epmd",
	4370:  "elpro-tunnel",
	4371:  "l2c-disc",
	4372:  "l2c-data",
	4373:  "remctl",
	4375:  "tolteces",
	4376:  "bip",
	4377:  "cp-spxsvr",
	4378:  "cp-spxdpy",
	4379:  "ctdb",
	4389:  "xandros-cms",
	4390:  "wiegand",
	4394:  "apwi-disc",
	4395:  "omnivisionesx",
	4400:  "ds-srv",
	4401:  "ds-srvr",
	4402:  "ds-clnt",
	4403:  "ds-user",
	4404:  "ds-admin",
	4405:  "ds-mail",
	4406:  "ds-slp",
	4412:  "smallchat",
	4413:  "avi-nms-disc",
	4416:  "pjj-player-disc",
	4418:  "axysbridge",
	4420:  "nvm-express",
	4425:  "netrockey6",
	4426:  "beacon-port-2",
	4430:  "rsqlserver",
	4432:  "l-acoustics",
	4441:  "netblox",
	4442:  "saris",
	4443:  "pharos",
	4444:  "krb524",
	4445:  "upnotifyp",
	4446:  "n1-fwp",
	4447:  "n1-rmgmt",
	4448:  "asc-slmd",
	4449:  "privatewire",
	4450:  "camp",
	4451:  "ctisystemmsg",
	4452:  "ctiprogramload",
	4453:  "nssalertmgr",
	4454:  "nssagentmgr",
	4455:  "prchat-user",
	4456:  "prchat-server",
	4457:  "prRegister",
	4458:  "mcp",
	4484:  "hpssmgmt",
	4486:  "icms",
	4488:  "awacs-ice",
	4500:  "ipsec-nat-t",
	4534:  "armagetronad",
	4535:  "ehs",
	4536:  "ehs-ssl",
	4537:  "wssauthsvc",
	4538:  "swx-gate",
	4545:  "worldscores",
	4546:  "sf-lm",
	4547:  "lanner-lm",
	4548:  "synchromesh",
	4549:  "aegate",
	4550:  "gds-adppiw-db",
	4551:  "ieee-mih",
	4552:  "menandmice-mon",
	4554:  "msfrs",
	4555:  "rsip",
	4556:  "dtn-bundle",
	4557:  "mtcevrunqss",
	4558:  "mtcevrunqman",
	4559:  "hylafax",
	4566:  "kwtc",
	4567:  "tram",
	4568:  "bmc-reporting",
	4569:  "iax",
	4591:  "l3t-at-an",
	4592:  "hrpd-ith-at-an",
	4593:  "ipt-anri-anri",
	4594:  "ias-session",
	4595:  "ias-paging",
	4596:  "ias-neighbor",
	4597:  "a21-an-1xbs",
	4598:  "a16-an-an",
	4599:  "a17-an-an",
	4600:  "piranha1",
	4601:  "piranha2",
	4621:  "ventoso",
	4658:  "playsta2-app",
	4659:  "playsta2-lob",
	4660:  "smaclmgr",
	4661:  "kar2ouche",
	4662:  "oms",
	4663:  "noteit",
	4664:  "ems",
	4665:  "contclientms",
	4666:  "eportcomm",
	4667:  "mmacomm",
	4668:  "mmaeds",
	4669:  "eportcommdata",
	4670:  "light",
	4671:  "acter",
	4672:  "rfa",
	4673:  "cxws",
	4674:  "appiq-mgmt",
	4675:  "dhct-status",
	4676:  "dhct-alerts",
	4677:  "bcs",
	4678:  "traversal",
	4679:  "mgesupervision",
	4680:  "mgemanagement",
	4681:  "parliant",
	4682:  "finisar",
	4683:  "spike",
	4684:  "rfid-rp1",
	4685:  "autopac",
	4686:  "msp-os",
	4687:  "nst",
	4688:  "mobile-p2p",
	4689:  "altovacentral",
	4690:  "prelude",
	4691:  "mtn",
	4692:  "conspiracy",
	4700:  "netxms-agent",
	4701:  "netxms-mgmt",
	4702:  "netxms-sync",
	4711:  "trinity-dist",
	4725:  "truckstar",
	4726:  "a26-fap-fgw",
	4727:  "fcis-disc",
	4728:  "capmux",
	4729:  "gsmtap",
	4730:  "gearman",
	4732:  "ohmtrigger",
	4737:  "ipdr-sp",
	4738:  "solera-lpn",
	4739:  "ipfix",
	4740:  "ipfixs",
	4741:  "lumimgrd",
	4742:  "sicct-sdp",
	4743:  "openhpid",
	4744:  "ifsp",
	4745:  "fmp",
	4746:  "intelliadm-disc",
	4747:  "buschtrommel",
	4749:  "profilemac",
	4750:  "ssad",
	4751:  "spocp",
	4752:  "snap",
	4753:  "simon-disc",
	4754:  "gre-in-udp",
	4755:  "gre-udp-dtls",
	4784:  "bfd-multi-ctl",
	4785:  "cncp",
	4789:  "vxlan",
	4790:  "vxlan-gpe",
	4791:  "roce",
	4800:  "iims",
	4801:  "iwec",
	4802:  "ilss",
	4803:  "notateit-disc",
	4804:  "aja-ntv4-disc",
	4827:  "htcp",
	4837:  "varadero-0",
	4838:  "varadero-1",
	4839:  "varadero-2",
	4840:  "opcua-udp",
	4841:  "quosa",
	4842:  "gw-asv",
	4843:  "opcua-tls",
	4844:  "gw-log",
	4845:  "wcr-remlib",
	4846:  "contamac-icm",
	4847:  "wfc",
	4848:  "appserv-http",
	4849:  "appserv-https",
	4850:  "sun-as-nodeagt",
	4851:  "derby-repli",
	4867:  "unify-debug",
	4868:  "phrelay",
	4869:  "phrelaydbg",
	4870:  "cc-tracking",
	4871:  "wired",
	4876:  "tritium-can",
	4877:  "lmcs",
	4878:  "inst-discovery",
	4881:  "socp-t",
	4882:  "socp-c",
	4884:  "hivestor",
	4885:  "abbs",
	4894:  "lyskom",
	4899:  "radmin-port",
	4900:  "hfcs",
	4914:  "bones",
	4936:  "an-signaling",
	4937:  "atsc-mh-ssc",
	4940:  "eq-office-4940",
	4941:  "eq-office-4941",
	4942:  "eq-office-4942",
	4949:  "munin",
	4950:  "sybasesrvmon",
	4951:  "pwgwims",
	4952:  "sagxtsds",
	4969:  "ccss-qmm",
	4970:  "ccss-qsm",
	4980:  "ctxs-vpp",
	4986:  "mrip",
	4987:  "smar-se-port1",
	4988:  "smar-se-port2",
	4989:  "parallel",
	4990:  "busycal",
	4991:  "vrt",
	4999:  "hfcs-manager",
	5000:  "commplex-main",
	5001:  "commplex-link",
	5002:  "rfe",
	5003:  "fmpro-internal",
	5004:  "avt-profile-1",
	5005:  "avt-profile-2",
	5006:  "wsm-server",
	5007:  "wsm-server-ssl",
	5008:  "synapsis-edge",
	5009:  "winfs",
	5010:  "telelpathstart",
	5011:  "telelpathattack",
	5012:  "nsp",
	5013:  "fmpro-v6",
	5014:  "onpsocket",
	5020:  "zenginkyo-1",
	5021:  "zenginkyo-2",
	5022:  "mice",
	5023:  "htuilsrv",
	5024:  "scpi-telnet",
	5025:  "scpi-raw",
	5026:  "strexec-d",
	5027:  "strexec-s",
	5029:  "infobright",
	5030:  "surfpass",
	5031:  "dmp",
	5042:  "asnaacceler8db",
	5043:  "swxadmin",
	5044:  "lxi-evntsvc",
	5046:  "vpm-udp",
	5047:  "iscape",
	5049:  "ivocalize",
	5050:  "mmcc",
	5051:  "ita-agent",
	5052:  "ita-manager",
	5053:  "rlm-disc",
	5055:  "unot",
	5056:  "intecom-ps1",
	5057:  "intecom-ps2",
	5058:  "locus-disc",
	5059:  "sds",
	5060:  "sip",
	5061:  "sips",
	5062:  "na-localise",
	5064:  "ca-1",
	5065:  "ca-2",
	5066:  "stanag-5066",
	5067:  "authentx",
	5069:  "i-net-2000-npr",
	5070:  "vtsas",
	5071:  "powerschool",
	5072:  "ayiya",
	5073:  "tag-pm",
	5074:  "alesquery",
	5078:  "pixelpusher",
	5079:  "cp-spxrpts",
	5080:  "onscreen",
	5081:  "sdl-ets",
	5082:  "qcp",
	5083:  "qfp",
	5084:  "llrp",
	5085:  "encrypted-llrp",
	5092:  "magpie",
	5093:  "sentinel-lm",
	5094:  "hart-ip",
	5099:  "sentlm-srv2srv",
	5100:  "socalia",
	5101:  "talarian-udp",
	5102:  "oms-nonsecure",
	5104:  "tinymessage",
	5105:  "hughes-ap",
	5111:  "taep-as-svc",
	5112:  "pm-cmdsvr",
	5116:  "emb-proj-cmd",
	5120:  "barracuda-bbs",
	5133:  "nbt-pc",
	5136:  "minotaur-sa",
	5137:  "ctsd",
	5145:  "rmonitor-secure",
	5150:  "atmp",
	5151:  "esri-sde",
	5152:  "sde-discovery",
	5154:  "bzflag",
	5155:  "asctrl-agent",
	5164:  "vpa-disc",
	5165:  "ife-icorp",
	5166:  "winpcs",
	5167:  "scte104",
	5168:  "scte30",
	5190:  "aol",
	5191:  "aol-1",
	5192:  "aol-2",
	5193:  "aol-3",
	5200:  "targus-getdata",
	5201:  "targus-getdata1",
	5202:  "targus-getdata2",
	5203:  "targus-getdata3",
	5223:  "hpvirtgrp",
	5224:  "hpvirtctrl",
	5225:  "hp-server",
	5226:  "hp-status",
	5227:  "perfd",
	5234:  "eenet",
	5235:  "galaxy-network",
	5236:  "padl2sim",
	5237:  "mnet-discovery",
	5245:  "downtools-disc",
	5246:  "capwap-control",
	5247:  "capwap-data",
	5248:  "caacws",
	5249:  "caaclang2",
	5250:  "soagateway",
	5251:  "caevms",
	5252:  "movaz-ssc",
	5264:  "3com-njack-1",
	5265:  "3com-njack-2",
	5270:  "cartographerxmp",
	5271:  "cuelink-disc",
	5272:  "pk",
	5282:  "transmit-port",
	5298:  "presence",
	5299:  "nlg-data",
	5300:  "hacl-hb",
	5301:  "hacl-gs",
	5302:  "hacl-cfg",
	5303:  "hacl-probe",
	5304:  "hacl-local",
	5305:  "hacl-test",
	5306:  "sun-mc-grp",
	5307:  "sco-aip",
	5308:  "cfengine",
	5309:  "jprinter",
	5310:  "outlaws",
	5312:  "permabit-cs",
	5313:  "rrdp",
	5314:  "opalis-rbt-ipc",
	5315:  "hacl-poll",
	5343:  "kfserver",
	5344:  "xkotodrcp",
	5349:  "stuns",
	5350:  "pcp-multicast",
	5351:  "pcp",
	5352:  "dns-llq",
	5353:  "mdns",
	5354:  "mdnsresponder",
	5355:  "llmnr",
	5356:  "ms-smlbiz",
	5357:  "wsdapi",
	5358:  "wsdapi-s",
	5359:  "ms-alerter",
	5360:  "ms-sideshow",
	5361:  "ms-s-sideshow",
	5362:  "serverwsd2",
	5363:  "net-projection",
	5364:  "kdnet",
	5397:  "stresstester",
	5398:  "elektron-admin",
	5399:  "securitychase",
	5400:  "excerpt",
	5401:  "excerpts",
	5402:  "mftp",
	5403:  "hpoms-ci-lstn",
	5404:  "hpoms-dps-lstn",
	5405:  "netsupport",
	5406:  "systemics-sox",
	5407:  "foresyte-clear",
	5408:  "foresyte-sec",
	5409:  "salient-dtasrv",
	5410:  "salient-usrmgr",
	5411:  "actnet",
	5412:  "continuus",
	5413:  "wwiotalk",
	5414:  "statusd",
	5415:  "ns-server",
	5416:  "sns-gateway",
	5417:  "sns-agent",
	5418:  "mcntp",
	5419:  "dj-ice",
	5420:  "cylink-c",
	5421:  "netsupport2",
	5422:  "salient-mux",
	5423:  "virtualuser",
	5424:  "beyond-remote",
	5425:  "br-channel",
	5426:  "devbasic",
	5427:  "sco-peer-tta",
	5428:  "telaconsole",
	5429:  "base",
	5430:  "radec-corp",
	5431:  "park-agent",
	5432:  "postgresql",
	5433:  "pyrrho",
	5434:  "sgi-arrayd",
	5435:  "sceanics",
	5436:  "pmip6-cntl",
	5437:  "pmip6-data",
	5443:  "spss",
	5450:  "tiepie-disc",
	5453:  "surebox",
	5454:  "apc-5454",
	5455:  "apc-5455",
	5456:  "apc-5456",
	5461:  "silkmeter",
	5462:  "ttl-publisher",
	5463:  "ttlpriceproxy",
	5464:  "quailnet",
	5465:  "netops-broker",
	5474:  "apsolab-rpc",
	5500:  "fcp-addr-srvr1",
	5501:  "fcp-addr-srvr2",
	5502:  "fcp-srvr-inst1",
	5503:  "fcp-srvr-inst2",
	5504:  "fcp-cics-gw1",
	5505:  "checkoutdb",
	5506:  "amc",
	5553:  "sgi-eventmond",
	5554:  "sgi-esphttp",
	5555:  "personal-agent",
	5556:  "freeciv",
	5567:  "dof-dps-mc-sec",
	5568:  "sdt",
	5569:  "rdmnet-device",
	5573:  "sdmmp",
	5580:  "tmosms0",
	5581:  "tmosms1",
	5582:  "fac-restore",
	5583:  "tmo-icon-sync",
	5584:  "bis-web",
	5585:  "bis-sync",
	5597:  "ininmessaging",
	5598:  "mctfeed",
	5599:  "esinstall",
	5600:  "esmmanager",
	5601:  "esmagent",
	5602:  "a1-msc",
	5603:  "a1-bs",
	5604:  "a3-sdunode",
	5605:  "a4-sdunode",
	5627:  "ninaf",
	5628:  "htrust",
	5629:  "symantec-sfdb",
	5630:  "precise-comm",
	5631:  "pcanywheredata",
	5632:  "pcanywherestat",
	5633:  "beorl",
	5634:  "xprtld",
	5670:  "zre-disc",
	5671:  "amqps",
	5672:  "amqp",
	5673:  "jms",
	5674:  "hyperscsi-port",
	5675:  "v5ua",
	5676:  "raadmin",
	5677:  "questdb2-lnchr",
	5678:  "rrac",
	5679:  "dccm",
	5680:  "auriga-router",
	5681:  "ncxcp",
	5682:  "brightcore",
	5683:  "coap",
	5684:  "coaps",
	5687:  "gog-multiplayer",
	5688:  "ggz",
	5689:  "qmvideo",
	5713:  "proshareaudio",
	5714:  "prosharevideo",
	5715:  "prosharedata",
	5716:  "prosharerequest",
	5717:  "prosharenotify",
	5718:  "dpm",
	5719:  "dpm-agent",
	5720:  "ms-licensing",
	5721:  "dtpt",
	5722:  "msdfsr",
	5723:  "omhs",
	5724:  "omsdk",
	5728:  "io-dist-group",
	5729:  "openmail",
	5730:  "unieng",
	5741:  "ida-discover1",
	5742:  "ida-discover2",
	5743:  "watchdoc-pod",
	5744:  "watchdoc",
	5745:  "fcopy-server",
	5746:  "fcopys-server",
	5747:  "tunatic",
	5748:  "tunalyzer",
	5750:  "rscd",
	5755:  "openmailg",
	5757:  "x500ms",
	5766:  "openmailns",
	5767:  "s-openmail",
	5768:  "openmailpxy",
	5769:  "spramsca",
	5770:  "spramsd",
	5771:  "netagent",
	5777:  "dali-port",
	5781:  "3par-evts",
	5782:  "3par-mgmt",
	5783:  "3par-mgmt-ssl",
	5784:  "ibar",
	5785:  "3par-rcopy",
	5786:  "cisco-redu",
	5787:  "waascluster",
	5793:  "xtreamx",
	5794:  "spdp",
	5813:  "icmpd",
	5814:  "spt-automation",
	5859:  "wherehoo",
	5863:  "ppsuitemsg",
	5900:  "rfb",
	5910:  "cm",
	5911:  "cpdlc",
	5912:  "fis",
	5913:  "ads-c",
	5963:  "indy",
	5968:  "mppolicy-v5",
	5969:  "mppolicy-mgr",
	5984:  "couchdb",
	5985:  "wsman",
	5986:  "wsmans",
	5987:  "wbem-rmi",
	5988:  "wbem-http",
	5989:  "wbem-https",
	5990:  "wbem-exp-https",
	5991:  "nuxsl",
	5992:  "consul-insight",
	5999:  "cvsup",
	6064:  "ndl-ahp-svc",
	6065:  "winpharaoh",
	6066:  "ewctsp",
	6069:  "trip",
	6070:  "messageasap",
	6071:  "ssdtp",
	6072:  "diagnose-proc",
	6073:  "directplay8",
	6074:  "max",
	6080:  "gue",
	6081:  "geneve",
	6082:  "p25cai",
	6083:  "miami-bcast",
	6085:  "konspire2b",
	6086:  "pdtp",
	6087:  "ldss",
	6088:  "doglms-notify",
	6100:  "synchronet-db",
	6101:  "synchronet-rtc",
	6102:  "synchronet-upd",
	6103:  "rets",
	6104:  "dbdb",
	6105:  "primaserver",
	6106:  "mpsserver",
	6107:  "etc-control",
	6108:  "sercomm-scadmin",
	6109:  "globecast-id",
	6110:  "softcm",
	6111:  "spc",
	6112:  "dtspcd",
	6118:  "tipc",
	6122:  "bex-webadmin",
	6123:  "backup-express",
	6124:  "pnbs",
	6133:  "nbt-wol",
	6140:  "pulsonixnls",
	6141:  "meta-corp",
	6142:  "aspentec-lm",
	6143:  "watershed-lm",
	6144:  "statsci1-lm",
	6145:  "statsci2-lm",
	6146:  "lonewolf-lm",
	6147:  "montage-lm",
	6148:  "ricardo-lm",
	6149:  "tal-pod",
	6160:  "ecmp-data",
	6161:  "patrol-ism",
	6162:  "patrol-coll",
	6163:  "pscribe",
	6200:  "lm-x",
	6201:  "thermo-calc",
	6209:  "qmtps",
	6222:  "radmind",
	6241:  "jeol-nsddp-1",
	6242:  "jeol-nsddp-2",
	6243:  "jeol-nsddp-3",
	6244:  "jeol-nsddp-4",
	6251:  "tl1-raw-ssl",
	6252:  "tl1-ssh",
	6253:  "crip",
	6268:  "grid",
	6269:  "grid-alt",
	6300:  "bmc-grx",
	6301:  "bmc-ctd-ldap",
	6306:  "ufmp",
	6315:  "scup-disc",
	6316:  "abb-escp",
	6317:  "nav-data",
	6320:  "repsvc",
	6321:  "emp-server1",
	6322:  "emp-server2",
	6324:  "hrd-ns-disc",
	6343:  "sflow",
	6346:  "gnutella-svc",
	6347:  "gnutella-rtr",
	6350:  "adap",
	6355:  "pmcs",
	6360:  "metaedit-mu",
	6363:  "ndn",
	6370:  "metaedit-se",
	6382:  "metatude-mds",
	6389:  "clariion-evr01",
	6390:  "metaedit-ws",
	6417:  "faxcomservice",
	6419:  "svdrp-disc",
	6420:  "nim-vdrshell",
	6421:  "nim-wan",
	6443:  "sun-sr-https",
	6444:  "sge-qmaster",
	6445:  "sge-execd",
	6446:  "mysql-proxy",
	6455:  "skip-cert-recv",
	6456:  "skip-cert-send",
	6464:  "ieee11073-20701",
	6471:  "lvision-lm",
	6480:  "sun-sr-http",
	6481:  "servicetags",
	6482:  "ldoms-mgmt",
	6483:  "SunVTS-RMI",
	6484:  "sun-sr-jms",
	6485:  "sun-sr-iiop",
	6486:  "sun-sr-iiops",
	6487:  "sun-sr-iiop-aut",
	6488:  "sun-sr-jmx",
	6489:  "sun-sr-admin",
	6500:  "boks",
	6501:  "boks-servc",
	6502:  "boks-servm",
	6503:  "boks-clntd",
	6505:  "badm-priv",
	6506:  "badm-pub",
	6507:  "bdir-priv",
	6508:  "bdir-pub",
	6509:  "mgcs-mfp-port",
	6510:  "mcer-port",
	6511:  "dccp-udp",
	6514:  "syslog-tls",
	6515:  "elipse-rec",
	6543:  "lds-distrib",
	6544:  "lds-dump",
	6547:  "apc-6547",
	6548:  "apc-6548",
	6549:  "apc-6549",
	6550:  "fg-sysupdate",
	6551:  "sum",
	6558:  "xdsxdm",
	6566:  "sane-port",
	6568:  "rp-reputation",
	6579:  "affiliate",
	6580:  "parsec-master",
	6581:  "parsec-peer",
	6582:  "parsec-game",
	6583:  "joaJewelSuite",
	6619:  "odette-ftps",
	6620:  "kftp-data",
	6621:  "kftp",
	6622:  "mcftp",
	6623:  "ktelnet",
	6626:  "wago-service",
	6627:  "nexgen",
	6628:  "afesc-mc",
	6629:  "nexgen-aux",
	6633:  "cisco-vpath-tun",
	6634:  "mpls-pm",
	6635:  "mpls-udp",
	6636:  "mpls-udp-dtls",
	6653:  "openflow",
	6657:  "palcom-disc",
	6670:  "vocaltec-gold",
	6671:  "p4p-portal",
	6672:  "vision-server",
	6673:  "vision-elmd",
	6678:  "vfbp-disc",
	6679:  "osaut",
	6689:  "tsa",
	6696:  "babel",
	6701:  "kti-icad-srvr",
	6702:  "e-design-net",
	6703:  "e-design-web",
	6714:  "ibprotocol",
	6715:  "fibotrader-com",
	6767:  "bmc-perf-agent",
	6768:  "bmc-perf-mgrd",
	6769:  "adi-gxp-srvprt",
	6770:  "plysrv-http",
	6771:  "plysrv-https",
	6784:  "bfd-lag",
	6785:  "dgpf-exchg",
	6786:  "smc-jmx",
	6787:  "smc-admin",
	6788:  "smc-http",
	6790:  "hnmp",
	6791:  "hnm",
	6801:  "acnet",
	6831:  "ambit-lm",
	6841:  "netmo-default",
	6842:  "netmo-http",
	6850:  "iccrushmore",
	6868:  "acctopus-st",
	6888:  "muse",
	6935:  "ethoscan",
	6936:  "xsmsvc",
	6946:  "bioserver",
	6951:  "otlp",
	6961:  "jmact3",
	6962:  "jmevt2",
	6963:  "swismgr1",
	6964:  "swismgr2",
	6965:  "swistrap",
	6966:  "swispol",
	6969:  "acmsoda",
	6997:  "MobilitySrv",
	6998:  "iatp-highpri",
	6999:  "iatp-normalpri",
	7000:  "afs3-fileserver",
	7001:  "afs3-callback",
	7002:  "afs3-prserver",
	7003:  "afs3-vlserver",
	7004:  "afs3-kaserver",
	7005:  "afs3-volser",
	7006:  "afs3-errors",
	7007:  "afs3-bos",
	7008:  "afs3-update",
	7009:  "afs3-rmtsys",
	7010:  "ups-onlinet",
	7011:  "talon-disc",
	7012:  "talon-engine",
	7013:  "microtalon-dis",
	7014:  "microtalon-com",
	7015:  "talon-webserver",
	7016:  "spg",
	7017:  "grasp",
	7019:  "doceri-view",
	7020:  "dpserve",
	7021:  "dpserveadmin",
	7022:  "ctdp",
	7023:  "ct2nmcs",
	7024:  "vmsvc",
	7025:  "vmsvc-2",
	7030:  "op-probe",
	7040:  "quest-disc",
	7070:  "arcp",
	7071:  "iwg1",
	7080:  "empowerid",
	7088:  "zixi-transport",
	7095:  "jdp-disc",
	7099:  "lazy-ptop",
	7100:  "font-service",
	7101:  "elcn",
	7107:  "aes-x170",
	7121:  "virprot-lm",
	7128:  "scenidm",
	7129:  "scenccs",
	7161:  "cabsm-comm",
	7162:  "caistoragemgr",
	7163:  "cacsambroker",
	7164:  "fsr",
	7165:  "doc-server",
	7166:  "aruba-server",
	7169:  "ccag-pib",
	7170:  "nsrp",
	7171:  "drm-production",
	7174:  "clutild",
	7181:  "janus-disc",
	7200:  "fodms",
	7201:  "dlip",
	7227:  "ramp",
	7235:  "aspcoordination",
	7244:  "frc-hicp-disc",
	7262:  "cnap",
	7272:  "watchme-7272",
	7273:  "oma-rlp",
	7274:  "oma-rlp-s",
	7275:  "oma-ulp",
	7276:  "oma-ilp",
	7277:  "oma-ilp-s",
	7278:  "oma-dcdocbs",
	7279:  "ctxlic",
	7280:  "itactionserver1",
	7281:  "itactionserver2",
	7282:  "mzca-alert",
	7365:  "lcm-server",
	7391:  "mindfilesys",
	7392:  "mrssrendezvous",
	7393:  "nfoldman",
	7394:  "fse",
	7395:  "winqedit",
	7397:  "hexarc",
	7400:  "rtps-discovery",
	7401:  "rtps-dd-ut",
	7402:  "rtps-dd-mt",
	7410:  "ionixnetmon",
	7411:  "daqstream",
	7421:  "mtportmon",
	7426:  "pmdmgr",
	7427:  "oveadmgr",
	7428:  "ovladmgr",
	7429:  "opi-sock",
	7430:  "xmpv7",
	7431:  "pmd",
	7437:  "faximum",
	7443:  "oracleas-https",
	7473:  "rise",
	7491:  "telops-lmd",
	7500:  "silhouette",
	7501:  "ovbus",
	7510:  "ovhpas",
	7511:  "pafec-lm",
	7542:  "saratoga",
	7543:  "atul",
	7544:  "nta-ds",
	7545:  "nta-us",
	7546:  "cfs",
	7547:  "cwmp",
	7548:  "tidp",
	7549:  "nls-tl",
	7550:  "cloudsignaling",
	7560:  "sncp",
	7566:  "vsi-omega",
	7570:  "aries-kfinder",
	7574:  "coherence-disc",
	7588:  "sun-lm",
	7606:  "mipi-debug",
	7624:  "indi",
	7627:  "soap-http",
	7628:  "zen-pawn",
	7629:  "xdas",
	7633:  "pmdfmgt",
	7648:  "cuseeme",
	7674:  "imqtunnels",
	7675:  "imqtunnel",
	7676:  "imqbrokerd",
	7677:  "sun-user-https",
	7680:  "pando-pub",
	7689:  "collaber",
	7697:  "klio",
	7707:  "sync-em7",
	7708:  "scinet",
	7720:  "medimageportal",
	7724:  "nsdeepfreezectl",
	7725:  "nitrogen",
	7726:  "freezexservice",
	7727:  "trident-data",
	7728:  "osvr",
	7734:  "smip",
	7738:  "aiagent",
	7741:  "scriptview",
	7743:  "sstp-1",
	7744:  "raqmon-pdu",
	7747:  "prgp",
	7777:  "cbt",
	7778:  "interwise",
	7779:  "vstat",
	7781:  "accu-lmgr",
	7784:  "s-bfd",
	7786:  "minivend",
	7787:  "popup-reminders",
	7789:  "office-tools",
	7794:  "q3ade",
	7797:  "pnet-conn",
	7798:  "pnet-enc",
	7799:  "altbsdp",
	7800:  "asr",
	7801:  "ssp-client",
	7802:  "vns-tp",
	7810:  "rbt-wanopt",
	7845:  "apc-7845",
	7846:  "apc-7846",
	7872:  "mipv6tls",
	7880:  "pss",
	7887:  "ubroker",
	7900:  "mevent",
	7901:  "tnos-sp",
	7902:  "tnos-dp",
	7903:  "tnos-dps",
	7913:  "qo-secure",
	7932:  "t2-drm",
	7933:  "t2-brm",
	7962:  "generalsync",
	7967:  "supercell",
	7979:  "micromuse-ncps",
	7980:  "quest-vista",
	7982:  "sossd-disc",
	7998:  "usicontentpush",
	7999:  "irdmi2",
	8000:  "irdmi",
	8001:  "vcom-tunnel",
	8002:  "teradataordbms",
	8003:  "mcreport",
	8005:  "mxi",
	8006:  "wpl-disc",
	8007:  "warppipe",
	8008:  "http-alt",
	8019:  "qbdb",
	8020:  "intu-ec-svcdisc",
	8021:  "intu-ec-client",
	8022:  "oa-system",
	8025:  "ca-audit-da",
	8026:  "ca-audit-ds",
	8032:  "pro-ed",
	8033:  "mindprint",
	8034:  "vantronix-mgmt",
	8040:  "ampify",
	8041:  "enguity-xccetp",
	8052:  "senomix01",
	8053:  "senomix02",
	8054:  "senomix03",
	8055:  "senomix04",
	8056:  "senomix05",
	8057:  "senomix06",
	8058:  "senomix07",
	8059:  "senomix08",
	8060:  "aero",
	8074:  "gadugadu",
	8080:  "http-alt",
	8081:  "sunproxyadmin",
	8082:  "us-cli",
	8083:  "us-srv",
	8086:  "d-s-n",
	8087:  "simplifymedia",
	8088:  "radan-http",
	8097:  "sac",
	8100:  "xprint-server",
	8115:  "mtl8000-matrix",
	8116:  "cp-cluster",
	8118:  "privoxy",
	8121:  "apollo-data",
	8122:  "apollo-admin",
	8128:  "paycash-online",
	8129:  "paycash-wbp",
	8130:  "indigo-vrmi",
	8131:  "indigo-vbcp",
	8132:  "dbabble",
	8148:  "isdd",
	8149:  "eor-game",
	8160:  "patrol",
	8161:  "patrol-snmp",
	8182:  "vmware-fdm",
	8184:  "itach",
	8192:  "spytechphone",
	8194:  "blp1",
	8195:  "blp2",
	8199:  "vvr-data",
	8200:  "trivnet1",
	8201:  "trivnet2",
	8202:  "aesop",
	8204:  "lm-perfworks",
	8205:  "lm-instmgr",
	8206:  "lm-dta",
	8207:  "lm-sserver",
	8208:  "lm-webwatcher",
	8230:  "rexecj",
	8231:  "hncp-udp-port",
	8232:  "hncp-dtls-port",
	8243:  "synapse-nhttps",
	8276:  "pando-sec",
	8280:  "synapse-nhttp",
	8282:  "libelle-disc",
	8292:  "blp3",
	8294:  "blp4",
	8300:  "tmi",
	8301:  "amberon",
	8320:  "tnp-discover",
	8321:  "tnp",
	8322:  "garmin-marine",
	8351:  "server-find",
	8376:  "cruise-enum",
	8377:  "cruise-swroute",
	8378:  "cruise-config",
	8379:  "cruise-diags",
	8380:  "cruise-update",
	8383:  "m2mservices",
	8384:  "marathontp",
	8400:  "cvd",
	8401:  "sabarsd",
	8402:  "abarsd",
	8403:  "admind",
	8416:  "espeech",
	8417:  "espeech-rtp",
	8442:  "cybro-a-bus",
	8443:  "pcsync-https",
	8444:  "pcsync-http",
	8445:  "copy-disc",
	8450:  "npmp",
	8472:  "otv",
	8473:  "vp2p",
	8474:  "noteshare",
	8500:  "fmtp",
	8501:  "cmtp-av",
	8503:  "lsp-self-ping",
	8554:  "rtsp-alt",
	8555:  "d-fence",
	8567:  "dof-tunnel",
	8600:  "asterix",
	8609:  "canon-cpp-disc",
	8610:  "canon-mfnp",
	8611:  "canon-bjnp1",
	8612:  "canon-bjnp2",
	8613:  "canon-bjnp3",
	8614:  "canon-bjnp4",
	8675:  "msi-cps-rm-disc",
	8686:  "sun-as-jmxrmi",
	8732:  "dtp-net",
	8733:  "ibus",
	8763:  "mc-appserver",
	8764:  "openqueue",
	8765:  "ultraseek-http",
	8766:  "amcs",
	8770:  "dpap",
	8786:  "msgclnt",
	8787:  "msgsrvr",
	8793:  "acd-pm",
	8800:  "sunwebadmin",
	8804:  "truecm",
	8805:  "pfcp",
	8808:  "ssports-bcast",
	8873:  "dxspider",
	8880:  "cddbp-alt",
	8883:  "secure-mqtt",
	8888:  "ddi-udp-1",
	8889:  "ddi-udp-2",
	8890:  "ddi-udp-3",
	8891:  "ddi-udp-4",
	8892:  "ddi-udp-5",
	8893:  "ddi-udp-6",
	8894:  "ddi-udp-7",
	8899:  "ospf-lite",
	8900:  "jmb-cds1",
	8901:  "jmb-cds2",
	8910:  "manyone-http",
	8911:  "manyone-xml",
	8912:  "wcbackup",
	8913:  "dragonfly",
	8954:  "cumulus-admin",
	8980:  "nod-provider",
	8981:  "nod-client",
	8989:  "sunwebadmins",
	8990:  "http-wmap",
	8991:  "https-wmap",
	8999:  "bctp",
	9000:  "cslistener",
	9001:  "etlservicemgr",
	9002:  "dynamid",
	9007:  "ogs-client",
	9009:  "pichat",
	9020:  "tambora",
	9021:  "panagolin-ident",
	9022:  "paragent",
	9023:  "swa-1",
	9024:  "swa-2",
	9025:  "swa-3",
	9026:  "swa-4",
	9060:  "CardWeb-RT",
	9080:  "glrpc",
	9084:  "aurora",
	9085:  "ibm-rsyscon",
	9086:  "net2display",
	9087:  "classic",
	9088:  "sqlexec",
	9089:  "sqlexec-ssl",
	9090:  "websm",
	9091:  "xmltec-xmlmail",
	9092:  "XmlIpcRegSvc",
	9100:  "hp-pdl-datastr",
	9101:  "bacula-dir",
	9102:  "bacula-fd",
	9103:  "bacula-sd",
	9104:  "peerwire",
	9105:  "xadmin",
	9106:  "astergate-disc",
	9119:  "mxit",
	9131:  "dddp",
	9160:  "apani1",
	9161:  "apani2",
	9162:  "apani3",
	9163:  "apani4",
	9164:  "apani5",
	9191:  "sun-as-jpda",
	9200:  "wap-wsp",
	9201:  "wap-wsp-wtp",
	9202:  "wap-wsp-s",
	9203:  "wap-wsp-wtp-s",
	9204:  "wap-vcard",
	9205:  "wap-vcal",
	9206:  "wap-vcard-s",
	9207:  "wap-vcal-s",
	9208:  "rjcdb-vcards",
	9209:  "almobile-system",
	9210:  "oma-mlp",
	9211:  "oma-mlp-s",
	9212:  "serverviewdbms",
	9213:  "serverstart",
	9214:  "ipdcesgbs",
	9215:  "insis",
	9216:  "acme",
	9217:  "fsc-port",
	9222:  "teamcoherence",
	9255:  "mon",
	9277:  "traingpsdata",
	9278:  "pegasus",
	9279:  "pegasus-ctl",
	9280:  "pgps",
	9281:  "swtp-port1",
	9282:  "swtp-port2",
	9283:  "callwaveiam",
	9284:  "visd",
	9285:  "n2h2server",
	9286:  "n2receive",
	9287:  "cumulus",
	9292:  "armtechdaemon",
	9293:  "storview",
	9294:  "armcenterhttp",
	9295:  "armcenterhttps",
	9300:  "vrace",
	9318:  "secure-ts",
	9321:  "guibase",
	9343:  "mpidcmgr",
	9344:  "mphlpdmc",
	9346:  "ctechlicensing",
	9374:  "fjdmimgr",
	9380:  "boxp",
	9396:  "fjinvmgr",
	9397:  "mpidcagt",
	9400:  "sec-t4net-srv",
	9401:  "sec-t4net-clt",
	9402:  "sec-pc2fax-srv",
	9418:  "git",
	9443:  "tungsten-https",
	9444:  "wso2esb-console",
	9450:  "sntlkeyssrvr",
	9500:  "ismserver",
	9522:  "sma-spw",
	9535:  "mngsuite",
	9536:  "laes-bf",
	9555:  "trispen-sra",
	9592:  "ldgateway",
	9593:  "cba8",
	9594:  "msgsys",
	9595:  "pds",
	9596:  "mercury-disc",
	9597:  "pd-admin",
	9598:  "vscp",
	9599:  "robix",
	9600:  "micromuse-ncpw",
	9612:  "streamcomm-ds",
	9618:  "condor",
	9628:  "odbcpathway",
	9629:  "uniport",
	9632:  "mc-comm",
	9667:  "xmms2",
	9668:  "tec5-sdctp",
	9694:  "client-wakeup",
	9695:  "ccnx",
	9700:  "board-roar",
	9747:  "l5nas-parchan",
	9750:  "board-voip",
	9753:  "rasadv",
	9762:  "tungsten-http",
	9800:  "davsrc",
	9801:  "sstp-2",
	9802:  "davsrcs",
	9875:  "sapv1",
	9878:  "kca-service",
	9888:  "cyborg-systems",
	9889:  "gt-proxy",
	9898:  "monkeycom",
	9899:  "sctp-tunneling",
	9900:  "iua",
	9901:  "enrp",
	9903:  "multicast-ping",
	9909:  "domaintime",
	9911:  "sype-transport",
	9950:  "apc-9950",
	9951:  "apc-9951",
	9952:  "apc-9952",
	9953:  "acis",
	9955:  "alljoyn-mcm",
	9956:  "alljoyn",
	9966:  "odnsp",
	9987:  "dsm-scm-target",
	9990:  "osm-appsrvr",
	9991:  "osm-oev",
	9992:  "palace-1",
	9993:  "palace-2",
	9994:  "palace-3",
	9995:  "palace-4",
	9996:  "palace-5",
	9997:  "palace-6",
	9998:  "distinct32",
	9999:  "distinct",
	10000: "ndmp",
	10001: "scp-config",
	10002: "documentum",
	10003: "documentum-s",
	10007: "mvs-capacity",
	10008: "octopus",
	10009: "swdtp-sv",
	10050: "zabbix-agent",
	10051: "zabbix-trapper",
	10080: "amanda",
	10081: "famdc",
	10100: "itap-ddtp",
	10101: "ezmeeting-2",
	10102: "ezproxy-2",
	10103: "ezrelay",
	10104: "swdtp",
	10107: "bctp-server",
	10110: "nmea-0183",
	10111: "nmea-onenet",
	10113: "netiq-endpoint",
	10114: "netiq-qcheck",
	10115: "netiq-endpt",
	10116: "netiq-voipa",
	10117: "iqrm",
	10128: "bmc-perf-sd",
	10160: "qb-db-server",
	10161: "snmpdtls",
	10162: "snmpdtls-trap",
	10200: "trisoap",
	10201: "rscs",
	10252: "apollo-relay",
	10253: "eapol-relay",
	10260: "axis-wimp-port",
	10288: "blocks",
	10439: "bngsync",
	10500: "hip-nat-t",
	10540: "MOS-lower",
	10541: "MOS-upper",
	10542: "MOS-aux",
	10543: "MOS-soap",
	10544: "MOS-soap-opt",
	10800: "gap",
	10805: "lpdg",
	10810: "nmc-disc",
	10860: "helix",
	10880: "bveapi",
	10990: "rmiaux",
	11000: "irisa",
	11001: "metasys",
	10023: "cefd-vmp",
	11095: "weave",
	11106: "sgi-lk",
	11108: "myq-termlink",
	11111: "vce",
	11112: "dicom",
	11161: "suncacao-snmp",
	11162: "suncacao-jmxmp",
	11163: "suncacao-rmi",
	11164: "suncacao-csa",
	11165: "suncacao-websvc",
	11171: "snss",
	11201: "smsqp",
	11208: "wifree",
	11211: "memcache",
	11319: "imip",
	11320: "imip-channels",
	11321: "arena-server",
	11367: "atm-uhas",
	11371: "hkp",
	11430: "lsdp",
	11600: "tempest-port",
	11720: "h323callsigalt",
	11723: "emc-xsw-dcache",
	11751: "intrepid-ssl",
	11796: "lanschool-mpt",
	11876: "xoraya",
	11877: "x2e-disc",
	11967: "sysinfo-sp",
	12000: "entextxid",
	12001: "entextnetwk",
	12002: "entexthigh",
	12003: "entextmed",
	12004: "entextlow",
	12005: "dbisamserver1",
	12006: "dbisamserver2",
	12007: "accuracer",
	12008: "accuracer-dbms",
	12009: "ghvpn",
	12012: "vipera",
	12013: "vipera-ssl",
	12109: "rets-ssl",
	12121: "nupaper-ss",
	12168: "cawas",
	12172: "hivep",
	12300: "linogridengine",
	12321: "warehouse-sss",
	12322: "warehouse",
	12345: "italk",
	12753: "tsaf",
	13160: "i-zipqd",
	13216: "bcslogc",
	13217: "rs-pias",
	13218: "emc-vcas-udp",
	13223: "powwow-client",
	13224: "powwow-server",
	13400: "doip-disc",
	13720: "bprd",
	13721: "bpdbm",
	13722: "bpjava-msvc",
	13724: "vnetd",
	13782: "bpcd",
	13783: "vopied",
	13785: "nbdb",
	13786: "nomdb",
	13818: "dsmcc-config",
	13819: "dsmcc-session",
	13820: "dsmcc-passthru",
	13821: "dsmcc-download",
	13822: "dsmcc-ccp",
	13894: "ucontrol",
	13929: "dta-systems",
	14000: "scotty-ft",
	14001: "sua",
	14002: "scotty-disc",
	14033: "sage-best-com1",
	14034: "sage-best-com2",
	14141: "vcs-app",
	14142: "icpp",
	14145: "gcm-app",
	14149: "vrts-tdd",
	14154: "vad",
	14250: "cps",
	14414: "ca-web-update",
	14936: "hde-lcesrvr-1",
	14937: "hde-lcesrvr-2",
	15000: "hydap",
	15118: "v2g-secc",
	15345: "xpilot",
	15363: "3link",
	15555: "cisco-snat",
	15660: "bex-xr",
	15740: "ptp",
	15998: "2ping",
	16003: "alfin",
	16161: "sun-sea-port",
	16309: "etb4j",
	16310: "pduncs",
	16311: "pdefmns",
	16360: "netserialext1",
	16361: "netserialext2",
	16367: "netserialext3",
	16368: "netserialext4",
	16384: "connected",
	16666: "vtp",
	16900: "newbay-snc-mc",
	16950: "sgcip",
	16991: "intel-rci-mp",
	16992: "amt-soap-http",
	16993: "amt-soap-https",
	16994: "amt-redir-tcp",
	16995: "amt-redir-tls",
	17007: "isode-dua",
	17185: "soundsvirtual",
	17219: "chipper",
	17220: "avtp",
	17221: "avdecc",
	17222: "cpsp",
	17224: "trdp-pd",
	17225: "trdp-md",
	17234: "integrius-stp",
	17235: "ssh-mgmt",
	17500: "db-lsp-disc",
	17729: "ea",
	17754: "zep",
	17755: "zigbee-ip",
	17756: "zigbee-ips",
	18000: "biimenu",
	18181: "opsec-cvp",
	18182: "opsec-ufp",
	18183: "opsec-sam",
	18184: "opsec-lea",
	18185: "opsec-omi",
	18186: "ohsc",
	18187: "opsec-ela",
	18241: "checkpoint-rtm",
	18262: "gv-pf",
	18463: "ac-cluster",
	18634: "rds-ib",
	18635: "rds-ip",
	18668: "vdmmesh-disc",
	18769: "ique",
	18881: "infotos",
	18888: "apc-necmp",
	19000: "igrid",
	19007: "scintilla",
	19191: "opsec-uaa",
	19194: "ua-secureagent",
	19220: "cora-disc",
	19283: "keysrvr",
	19315: "keyshadow",
	19398: "mtrgtrans",
	19410: "hp-sco",
	19411: "hp-sca",
	19412: "hp-sessmon",
	19539: "fxuptp",
	19540: "sxuptp",
	19541: "jcp",
	19788: "mle",
	19999: "dnp-sec",
	20000: "dnp",
	20001: "microsan",
	20002: "commtact-http",
	20003: "commtact-https",
	20005: "openwebnet",
	20012: "ss-idi-disc",
	20014: "opendeploy",
	20034: "nburn-id",
	20046: "tmophl7mts",
	20048: "mountd",
	20049: "nfsrdma",
	20167: "tolfab",
	20202: "ipdtp-port",
	20222: "ipulse-ics",
	20480: "emwavemsg",
	20670: "track",
	20999: "athand-mmp",
	21000: "irtrans",
	21554: "dfserver",
	21590: "vofr-gateway",
	21800: "tvpm",
	21845: "webphone",
	21846: "netspeak-is",
	21847: "netspeak-cs",
	21848: "netspeak-acd",
	21849: "netspeak-cps",
	22000: "snapenetio",
	22001: "optocontrol",
	22002: "optohost002",
	22003: "optohost003",
	22004: "optohost004",
	22005: "optohost004",
	22273: "wnn6",
	22305: "cis",
	22335: "shrewd-stream",
	22343: "cis-secure",
	22347: "wibukey",
	22350: "codemeter",
	22555: "vocaltec-phone",
	22763: "talikaserver",
	22800: "aws-brf",
	22951: "brf-gw",
	23000: "inovaport1",
	23001: "inovaport2",
	23002: "inovaport3",
	23003: "inovaport4",
	23004: "inovaport5",
	23005: "inovaport6",
	23272: "s102",
	23294: "5afe-disc",
	23333: "elxmgmt",
	23400: "novar-dbase",
	23401: "novar-alarm",
	23402: "novar-global",
	24000: "med-ltp",
	24001: "med-fsp-rx",
	24002: "med-fsp-tx",
	24003: "med-supp",
	24004: "med-ovw",
	24005: "med-ci",
	24006: "med-net-svc",
	24242: "filesphere",
	24249: "vista-4gl",
	24321: "ild",
	24322: "hid",
	24386: "intel-rci",
	24465: "tonidods",
	24554: "binkp",
	24577: "bilobit-update",
	24676: "canditv",
	24677: "flashfiler",
	24678: "proactivate",
	24680: "tcc-http",
	24850: "assoc-disc",
	24922: "find",
	25000: "icl-twobase1",
	25001: "icl-twobase2",
	25002: "icl-twobase3",
	25003: "icl-twobase4",
	25004: "icl-twobase5",
	25005: "icl-twobase6",
	25006: "icl-twobase7",
	25007: "icl-twobase8",
	25008: "icl-twobase9",
	25009: "icl-twobase10",
	25793: "vocaltec-hos",
	25900: "tasp-net",
	25901: "niobserver",
	25902: "nilinkanalyst",
	25903: "niprobe",
	25954: "bf-game",
	25955: "bf-master",
	26000: "quake",
	26133: "scscp",
	26208: "wnn6-ds",
	26260: "ezproxy",
	26261: "ezmeeting",
	26262: "k3software-svr",
	26263: "k3software-cli",
	26486: "exoline-udp",
	26487: "exoconfig",
	26489: "exonet",
	27345: "imagepump",
	27442: "jesmsjc",
	27504: "kopek-httphead",
	27782: "ars-vista",
	27999: "tw-auth-key",
	28000: "nxlmd",
	28119: "a27-ran-ran",
	28200: "voxelstorm",
	28240: "siemensgsm",
	29167: "otmp",
	30001: "pago-services1",
	30002: "pago-services2",
	30003: "amicon-fpsu-ra",
	30004: "amicon-fpsu-s",
	30260: "kingdomsonline",
	30832: "samsung-disc",
	30999: "ovobs",
	31016: "ka-kdp",
	31029: "yawn",
	31416: "xqosd",
	31457: "tetrinet",
	31620: "lm-mon",
	31765: "gamesmith-port",
	31948: "iceedcp-tx",
	31949: "iceedcp-rx",
	32034: "iracinghelper",
	32249: "t1distproc60",
	32483: "apm-link",
	32635: "sec-ntb-clnt",
	32636: "DMExpress",
	32767: "filenet-powsrm",
	32768: "filenet-tms",
	32769: "filenet-rpc",
	32770: "filenet-nch",
	32771: "filenet-rmi",
	32772: "filenet-pa",
	32773: "filenet-cm",
	32774: "filenet-re",
	32775: "filenet-pch",
	32776: "filenet-peior",
	32777: "filenet-obrok",
	32801: "mlsn",
	32896: "idmgratm",
	33123: "aurora-balaena",
	33331: "diamondport",
	33334: "speedtrace-disc",
	33434: "traceroute",
	33656: "snip-slave",
	34249: "turbonote-2",
	34378: "p-net-local",
	34379: "p-net-remote",
	34567: "edi_service",
	34962: "profinet-rt",
	34963: "profinet-rtm",
	34964: "profinet-cm",
	34980: "ethercat",
	35001: "rt-viewer",
	35004: "rt-classmanager",
	35100: "axio-disc",
	35355: "altova-lm-disc",
	36001: "allpeers",
	36411: "wlcp",
	36865: "kastenxpipe",
	37475: "neckar",
	37654: "unisys-eportal",
	38002: "crescoctrl-disc",
	38201: "galaxy7-data",
	38202: "fairview",
	38203: "agpolicy",
	39681: "turbonote-1",
	40000: "safetynetp",
	40023: "k-patentssensor",
	40841: "cscp",
	40842: "csccredir",
	40843: "csccfirewall",
	40853: "ortec-disc",
	41111: "fs-qos",
	41230: "z-wave-s",
	41794: "crestron-cip",
	41795: "crestron-ctp",
	42508: "candp",
	42509: "candrp",
	42510: "caerpc",
	43000: "recvr-rc-disc",
	43188: "reachout",
	43189: "ndm-agent-port",
	43190: "ip-provision",
	43210: "shaperai-disc",
	43439: "eq3-config",
	43440: "ew-disc-cmd",
	43441: "ciscocsdb",
	44321: "pmcd",
	44322: "pmcdproxy",
	44544: "domiq",
	44553: "rbr-debug",
	44600: "asihpi",
	44818: "EtherNet-IP-2",
	44900: "m3da-disc",
	45000: "asmp-mon",
	45054: "invision-ag",
	45514: "cloudcheck-ping",
	45678: "eba",
	45825: "qdb2service",
	45966: "ssr-servermgr",
	46999: "mediabox",
	47000: "mbus",
	47100: "jvl-mactalk",
	47557: "dbbrowse",
	47624: "directplaysrvr",
	47806: "ap",
	47808: "bacnet",
	47809: "presonus-ucnet",
	48000: "nimcontroller",
	48001: "nimspooler",
	48002: "nimhub",
	48003: "nimgtw",
	48128: "isnetserv",
	48129: "blp5",
	48556: "com-bardac-dw",
	48619: "iqobject",
	48653: "robotraconteur",
	49001: "nusdp-disc",
}
var sctpPortNames = map[uint16]string{
	9:     "discard",
	20:    "ftp-data",
	21:    "ftp",
	22:    "ssh",
	80:    "http",
	179:   "bgp",
	443:   "https",
	1021:  "exp1",
	1022:  "exp2",
	1167:  "cisco-ipsla",
	1720:  "h323hostcall",
	2049:  "nfs",
	2225:  "rcip-itu",
	2904:  "m2ua",
	2905:  "m3ua",
	2944:  "megaco-h248",
	2945:  "h248-binary",
	3097:  "itu-bicc-stc",
	3565:  "m2pa",
	3863:  "asap-sctp",
	3864:  "asap-sctp-tls",
	3868:  "diameter",
	4333:  "ahsp",
	4502:  "a25-fap-fgw",
	4711:  "trinity-dist",
	4739:  "ipfix",
	4740:  "ipfixs",
	5060:  "sip",
	5061:  "sips",
	5090:  "car",
	5091:  "cxtp",
	5215:  "noteza",
	5445:  "smbdirect",
	5672:  "amqp",
	5675:  "v5ua",
	5868:  "diameters",
	5910:  "cm",
	5911:  "cpdlc",
	5912:  "fis",
	5913:  "ads-c",
	6704:  "frc-hp",
	6705:  "frc-mp",
	6706:  "frc-lp",
	6970:  "conductor-mpx",
	7626:  "simco",
	7701:  "nfapi",
	7728:  "osvr",
	8471:  "pim-port",
	9082:  "lcs-ap",
	9084:  "aurora",
	9900:  "iua",
	9901:  "enrp-sctp",
	9902:  "enrp-sctp-tls",
	11997: "wmereceiving",
	11998: "wmedistribution",
	11999: "wmereporting",
	14001: "sua",
	20049: "nfsrdma",
	25471: "rna",
	29118: "sgsap",
	29168: "sbcap",
	29169: "iuhsctpassoc",
	30100: "rwp",
	36412: "s1-control",
	36422: "x2-control",
	36423: "slmap",
	36424: "nq-ap",
	36443: "m2ap",
	36444: "m3ap",
	36462: "xw-control",
	38412: "ng-control",
	38422: "xn-control",
	38472: "f1-control",
}

```

`pkg/util/rest/rest.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rest

import (
	"context"
	"errors"
	"github.com/rabbitstack/fibratus/pkg/api"
	"io/ioutil"
	"net"
	"net/http"
	"path"
	"strings"
	"time"
)

var transport *http.Transport

type opts struct {
	addr        string
	uri         string
	contentType string
	timeout     time.Duration
}

// Option represents the option for the HTTP client.
type Option func(o *opts)

// WithTransport sets the preferred transport for the HTTP client.
func WithTransport(addr string) Option {
	return func(o *opts) {
		o.addr = addr
		if strings.HasPrefix(addr, `npipe:///`) {
			transport = &http.Transport{
				DialContext: api.DialPipe(addr),
			}
		} else {
			transport = &http.Transport{
				DialContext: (&net.Dialer{}).DialContext,
			}
		}
	}
}

// WithURI initializes the URI where the request is sent.
func WithURI(uri string) Option {
	return func(o *opts) {
		o.uri = uri
	}
}

// WithContentType sets the content type header for the HTTP requests.
func WithContentType(contentType string) Option {
	return func(o *opts) {
		o.contentType = contentType
	}
}

// Get performs the GET request.
func Get(opts ...Option) ([]byte, error) {
	return request("GET", opts...)
}

func request(method string, options ...Option) ([]byte, error) {
	var opts opts
	for _, opt := range options {
		opt(&opts)
	}

	if transport == nil {
		return nil, errors.New("transport is not initialized")
	}

	timeout := opts.timeout
	if timeout == 0 {
		timeout = time.Second * 10
	}

	contentType := opts.contentType
	if contentType == "" {
		contentType = "application/json"
	}

	client := http.Client{
		Transport: transport,
		Timeout:   timeout,
	}

	scheme := "http://"
	addr := opts.addr
	if strings.HasPrefix(addr, `npipe:///`) {
		addr = strings.TrimPrefix(addr, `npipe:///`)
	}

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, method, scheme+path.Join(addr, opts.uri), nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", contentType)
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

```

`pkg/util/rest/rest_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rest

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net/http"
	"net/http/httptest"
	"os/user"
	"strings"
	"testing"
)

func TestGet(t *testing.T) {
	mux := http.NewServeMux()
	mux.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte("test")); err != nil {
			t.Fatal(err)
		}
	})

	srv := httptest.NewServer(mux)
	defer srv.Close()

	resp, err := Get(WithURI("config"), WithTransport(fmt.Sprintf("localhost:%s", port(srv.URL))))
	require.NoError(t, err)
	require.NotNil(t, resp)
	assert.Equal(t, "test", string(resp))
}

func TestGetPipe(t *testing.T) {
	usr, err := user.Current()
	require.NoError(t, err)
	descriptor := "D:P(A;;GA;;;" + usr.Uid + ")"
	listener, err := api.MakePipeListener(`npipe:///fibratus`, descriptor)
	require.NoError(t, err)

	mux := http.NewServeMux()

	mux.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte("test")); err != nil {
			t.Fatal(err)
		}
	})

	srv := httptest.NewUnstartedServer(mux)
	srv.Listener = listener

	srv.Start()
	defer srv.Close()

	resp, err := Get(WithURI("config"), WithTransport(`npipe:///fibratus`))
	require.NoError(t, err)
	require.NotNil(t, resp)
	assert.Equal(t, "test", string(resp))
}

func port(s string) string {
	i := strings.LastIndex(s, ":")
	if i == 0 {
		return ""
	}
	return s[i+1:]
}

```

`pkg/util/spinner/spinner.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package spinner

import (
	"github.com/briandowns/spinner"
	"time"
)

// Show creates a new spinner and starts it.
func Show(prefix string) *spinner.Spinner {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond) // Build our spinner
	s.Prefix = "> " + prefix + " "
	s.HideCursor = true
	s.Start()
	return s
}

```

`pkg/util/stringcase/camel.go`:

```go
/*
 * Credits to: https://github.com/iancoleman/strcase/blob/master/camel.go
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Ian Coleman
 * Copyright (c) 2018 Ma_124, <github.com/Ma124>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, Subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or Substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package stringcase

import "strings"

// Camel a string to CamelCase.
func Camel(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return s
	}

	var n strings.Builder
	n.Grow(len(s))
	capNext := true
	for i, v := range []byte(s) {
		vIsCap := v >= 'A' && v <= 'Z'
		vIsLow := v >= 'a' && v <= 'z'
		if capNext {
			if vIsLow {
				v += 'A'
				v -= 'a'
			}
		} else if i == 0 {
			if vIsCap {
				v += 'a'
				v -= 'A'
			}
		}
		if vIsCap || vIsLow {
			n.WriteByte(v)
			capNext = false
		} else if vIsNum := v >= '0' && v <= '9'; vIsNum {
			n.WriteByte(v)
			capNext = true
		} else {
			capNext = v == '_' || v == ' ' || v == '-' || v == '.'
		}
	}
	return n.String()
}

```

`pkg/util/stringcase/camel_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stringcase

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCamel(t *testing.T) {
	assert.Equal(t, "CamelCase", Camel("camel_case"))
	assert.Equal(t, "FileNameOp", Camel("file_name_op"))
}

```

`pkg/util/term/fb.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package term

import (
	"fmt"
	"io"
	"syscall"
	"unicode/utf16"
	"unsafe"
)

var (
	createConsoleScreenBuffer    = kernel32.NewProc("CreateConsoleScreenBuffer")
	setConsoleActiveScreenBuffer = kernel32.NewProc("SetConsoleActiveScreenBuffer")
)

const consoleTextModeBuffer = 0x1

// FrameBuffer is a special type of the I/O writer that outputs the character stream to the
// active console screen buffer.
type FrameBuffer struct {
	handle syscall.Handle
}

// NewFrameBuffer builds a fresh frame buffer.
func NewFrameBuffer() (io.Writer, error) {
	handle, _, err := createConsoleScreenBuffer.Call(
		uintptr(syscall.GENERIC_READ|syscall.GENERIC_WRITE),
		uintptr(0),
		uintptr(0),
		uintptr(consoleTextModeBuffer),
		uintptr(0),
		uintptr(0),
	)
	if handle == 0 {
		return nil, fmt.Errorf("unable to create screen buffer: %v", err)
	}
	fb := &FrameBuffer{
		handle: syscall.Handle(handle),
	}
	errno, _, err := setConsoleActiveScreenBuffer.Call(handle)
	if errno == 0 {
		return nil, fmt.Errorf("couldn't activate console screen buffer: %v", err)
	}
	showCursor(fb.handle, false)
	return fb, nil
}

// Write draws the character buffer to the screen frame buffer.
func (fb FrameBuffer) Write(p []byte) (int, error) {
	bufferInfo, err := getScreenBufferInfo(fb.handle)
	if err != nil {
		return 0, err
	}
	if len(p) == 1 {
		return 0, nil
	}

	rows := int(bufferInfo.rect.bottom)
	cols := int(bufferInfo.rect.right)

	chars := make([]charInfo, cols*rows)

	var x int
	var y int
	var newLine bool

	for _, char := range string(p) {
		c := char
		if c == '\n' || c == '\r' {
			newLine = true
		}
		r, c := utf16.EncodeRune(c)
		if r == 0xFFFD {
			c = char
		}
		y++
		// if the last column has been reached and a new line was encountered at
		// that position then we'll stop the iteration and reset the column number
		if y == cols {
			y = 0
			if newLine {
				newLine = false
				continue
			}
		}
		if newLine {
			newLine = false
			space := y
			// keep filling the rectangle with spaces until we reach the last column. Then
			// we'll reset the column and stop the current iteration
			for space <= cols {
				if space-1 > len(chars)-1 {
					continue
				}
				chars[space-1].char = uint16(' ')
				space++
				x++
			}
			y = 0
			continue
		}

		if x > len(chars)-1 {
			continue
		}

		chars[x].char = uint16(c)
		chars[x].attr = bufferInfo.attributes
		x++
	}

	// clear the current frame buffer screen
	fb.cls(bufferInfo)

	// the following block of code does the heavy lifting of writing the
	// character buffer to the screen frame buffer that we previously created
	cord := point{}
	size := point{x: int16(cols), y: int16(rows)}
	rect := rect{left: 0, top: 0, right: int16(cols) - 1, bottom: int16(rows) - 1}
	_, _, _ = writeConsoleOutput.Call(
		uintptr(fb.handle),
		uintptr(unsafe.Pointer(&chars[0])),
		size.uintptr(),
		cord.uintptr(),
		uintptr(unsafe.Pointer(&rect)),
	)

	return len(p), nil
}

// Close closes this frame buffer.
func (fb *FrameBuffer) Close() error {
	return syscall.Close(fb.handle)
}

// cls clears the frame buffer content.
func (fb *FrameBuffer) cls(bufferInfo *consoleScreenBufferInfo) {
	var w uint16
	var cursor point
	rows := bufferInfo.size.x
	cols := bufferInfo.size.y

	_, _, _ = fillConsoleOutputCharacter.Call(
		uintptr(fb.handle),
		uintptr(' '),
		uintptr(rows*cols),
		*(*uintptr)(unsafe.Pointer(&cursor)),
		uintptr(unsafe.Pointer(&w)),
	)

	_, _, _ = fillConsoleOutputAttribute.Call(
		uintptr(fb.handle),
		uintptr(bufferInfo.attributes),
		uintptr(rows*cols),
		*(*uintptr)(unsafe.Pointer(&cursor)),
		uintptr(unsafe.Pointer(&w)),
	)
}

```

`pkg/util/term/term.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package term

import (
	"os"
	"syscall"
	"unsafe"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	setConsoleCursorInfo       = kernel32.NewProc("SetConsoleCursorInfo")
	getConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
	writeConsoleOutput         = kernel32.NewProc("WriteConsoleOutputW")

	fillConsoleOutputCharacter = kernel32.NewProc("FillConsoleOutputCharacterW")
	fillConsoleOutputAttribute = kernel32.NewProc("FillConsoleOutputAttribute")
)

type point struct {
	x int16
	y int16
}

func (p point) uintptr() uintptr { return uintptr(*(*int32)(unsafe.Pointer(&p))) }

type rect struct {
	left, top     int16
	right, bottom int16
}

//nolint:unused
func (r *rect) uintptr() uintptr { return uintptr(unsafe.Pointer(r)) }

type charInfo struct {
	char uint16
	attr uint16
}

type consoleScreenBufferInfo struct {
	size       point
	_          point
	attributes uint16
	rect       rect
	_          point
}

type consoleCursorInfo struct {
	size    uint32
	visible bool
}

// getScreenBufferInfo retrieves information about the specified console screen buffer.
func getScreenBufferInfo(cons syscall.Handle) (*consoleScreenBufferInfo, error) {
	var bi consoleScreenBufferInfo
	errno, _, err := getConsoleScreenBufferInfo.Call(uintptr(cons), uintptr(unsafe.Pointer(&bi)))
	if errno == 0 {
		return nil, err
	}
	return &bi, nil
}

// GetColumns gets the number of character columns.
func GetColumns() int {
	bufferInfo, err := getScreenBufferInfo(syscall.Handle(os.Stdout.Fd()))
	if err != nil {
		return 0
	}
	return int(bufferInfo.rect.right)
}

// showCursor shows/hides the cursor.
func showCursor(cons syscall.Handle, visible bool) {
	var ci consoleCursorInfo
	ci.size = 100
	ci.visible = visible
	_, _, _ = setConsoleCursorInfo.Call(uintptr(cons), uintptr(unsafe.Pointer(&ci)))
}

```

`pkg/util/tls/tls.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tls

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"io/ioutil"
)

// MakeConfig builds a TLS config from the certificate, private/public key and the CA cert files.
func MakeConfig(certFile, keyFile, caFile string, insecureSkipVerify bool) (*tls.Config, error) {
	if certFile == "" && keyFile == "" && caFile == "" {
		return nil, nil
	}

	var cert tls.Certificate
	tlsConfig := &tls.Config{
		InsecureSkipVerify: insecureSkipVerify,
	}

	// load certificate/key
	if certFile != "" && keyFile == "" {
		var err error
		cert, err = tls.LoadX509KeyPair(certFile, keyFile)
		if err != nil {
			return nil, err
		}
		tlsConfig.Certificates = []tls.Certificate{cert}
	}
	// load certificate issuing authority
	if caFile != "" {
		cpool := x509.NewCertPool()
		caCert, err := ioutil.ReadFile(caFile)
		if err != nil {
			return nil, err
		}
		ok := cpool.AppendCertsFromPEM(caCert)
		if !ok {
			return nil, fmt.Errorf("fail to load certificate authority: %s", caFile)
		}
		tlsConfig.RootCAs = cpool
	}

	return tlsConfig, nil
}

```

`pkg/util/typesize/typesize.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package typesize

import "unsafe"

//nolint:unused
var ptr uintptr

// Pointer returns the pointer size on this machine.
func Pointer() uintptr { return unsafe.Sizeof(ptr) }

```

`pkg/util/version/version.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package version

import (
	"fmt"
	"os"
	"regexp"
	"runtime"
	"strconv"
	"strings"

	"github.com/jedib0t/go-pretty/v6/table"
)

// Version stores the SemVer release information along with the
// commit that produced the release and other useful information.
type Version struct {
	Major  int64
	Minor  int64
	Patch  int64
	Commit string
	Date   string
}

var versionRegexp = regexp.MustCompile(`(\d+\.\d+\.\d+)`)

var version string

// Set initializes the version string as global variable.
func Set(v string) { version = v }

// ProductToken returns a tag to be poked in User Agent headers.
func ProductToken() string { return fmt.Sprintf("fibratus/%s", version) }

// New parses the version string and return the version instance.
func New(version, commit, date string) Version {
	if version == "" {
		return Version{Commit: commit, Date: date}
	}

	toks := versionRegexp.FindStringSubmatch(version)
	if len(toks) == 0 || toks[0] != version {
		panic(fmt.Sprintf("invalid semver release: %s", version))
	}

	// split version info
	parts := strings.Split(toks[1], ".")
	major, _ := strconv.ParseInt(parts[0], 10, 64)
	minor, _ := strconv.ParseInt(parts[1], 10, 64)
	patch, _ := strconv.ParseInt(parts[2], 10, 64)

	v := Version{
		Major:  major,
		Minor:  minor,
		Patch:  patch,
		Commit: commit,
		Date:   date,
	}

	return v
}

// Render dumps the version information to stdout.
func (v Version) Render() {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.SetStyle(table.StyleLight)

	var version string
	if v.Major == 0 && v.Minor == 0 && v.Patch == 0 {
		version = "dev"
	} else {
		version = fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch)
	}

	t.AppendRow(table.Row{"Version", version})
	t.AppendRow(table.Row{"Commit", v.Commit})
	t.AppendRow(table.Row{"Build date", v.Date})

	t.AppendSeparator()

	t.AppendRow(table.Row{"Go compiler", runtime.Version()})

	t.Render()
}

```

`pkg/util/wildcard/wildcard.go`:

```go
/*
 * MinIO Cloud Storage, (C) 2015, 2016 MinIO, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package wildcard

// Match -  finds whether the text matches/satisfies the pattern string.
// supports  '*' and '?' wildcards in the pattern string.
// unlike path.Match(), considers a path as a flat name space while matching the pattern.
// The difference is illustrated in the example here https://play.golang.org/p/Ega9qgD4Qz .
func Match(pattern, name string) (matched bool) {
	if pattern == "" {
		return name == pattern
	}
	if pattern == "*" {
		return true
	}
	// Does extended wildcard '*' and '?' match.
	return deepMatchRune([]rune(name), []rune(pattern), false)
}

func deepMatchRune(str, pattern []rune, simple bool) bool {
	for len(pattern) > 0 {
		switch pattern[0] {
		default:
			if len(str) == 0 || str[0] != pattern[0] {
				return false
			}
		case '?':
			if len(str) == 0 && !simple {
				return false
			}
		case '*':
			return deepMatchRune(str, pattern[1:], simple) ||
				(len(str) > 0 && deepMatchRune(str[1:], pattern, simple))
		}
		str = str[1:]
		pattern = pattern[1:]
	}
	return len(str) == 0 && len(pattern) == 0
}

```

`pkg/util/wildcard/wildcard_test.go`:

```go
/*
 *	Copyright 2019-2020 by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

package wildcard

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestMatch(t *testing.T) {
	assert.True(t, Match("C:\\*\\lsass?.dmp", "C:\\Windows\\System32\\lsass2.dmp"))
	assert.True(t, Match("C:\\*\\ActionList.x?l", "C:\\Windows\\Setup\\LatentAcquisition\\ActionList.xml"))
	assert.True(t, Match("C:\\ProgramData\\*.dll", "C:\\ProgramData\\Directory\\OneMoreDirectory\\mal.dll"))
	assert.True(t, Match("C:\\ProgramData\\*.dll", "C:\\ProgramData\\Directory\\OneMoreDirectory\\mal.dll"))
	assert.True(t, Match("HKEY_USERS\\*\\Environment\\windir", "HKEY_USERS\\S-1-5-21-2271034452-2606270099-984871569-1001\\Environment\\windir"))
	assert.True(t, Match("C:\\Windows\\SoftwareDistribution\\*", "C:\\Windows\\SoftwareDistribution\\SLS\\7971F918-A847-4430-9279-4A52D1EFE18D\\sls.rar"))
}

```

`pkg/yara/_fixtures/rules/dll.yar`:

```yar
rule DLL : dll
{
	meta:
		severity = "Critical"
		date = "2020-07"
	strings:
		$c0 = "Go" fullword ascii
	condition:
		$c0
}
```

`pkg/yara/_fixtures/rules/notepad.yar`:

```yar
rule Notepad : notepad
{
	meta:
		severity = "Normal"
		date = "2016-07"
	strings:
		$c0 = "Notepad" fullword ascii
	condition:
		$c0
}

rule NotepadCompany
{
	meta:
		severity = "Normal"
		date = "2016-07"
	strings:
		$c0 = "Microsoft" fullword ascii
	condition:
		$c0
}
```

`pkg/yara/config/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/mitchellh/mapstructure"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"path/filepath"
	"strings"
	"time"
)

const (
	enabled            = "yara.enabled"
	alertVia           = "yara.alert-via"
	alertTextTemplate  = "yara.alert-template.text"
	alertTitleTemplate = "yara.alert-template.title"
	fastScanMode       = "yara.fastscan"
	scanTimeout        = "yara.scan-timeout"
	skipFiles          = "yara.skip-files"
	excludedProcesses  = "yara.excluded-procs"
	excludedFiles      = "yara.excluded-files"
)

// RulePath contains the rule path information.
type RulePath struct {
	Path      string `json:"path" yaml:"path" mapstructure:"path"`
	Namespace string `json:"namespace" yaml:"namespace" mapstructure:"namespace"`
}

// RuleString contains the in-place strings for the rule definition.
type RuleString struct {
	String    string `json:"string" yaml:"string" mapstructure:"string"`
	Namespace string `json:"namespace" yaml:"namespace" mapstructure:"namespace"`
}

// Rule contains rule-specific settings.
type Rule struct {
	// Paths defines the location of the yara rules
	Paths []RulePath `json:"yara.rule.paths" yaml:"yara.rule.paths" mapstructure:"paths"`
	// Strings contains the raw rule definitions
	Strings []RuleString `json:"yara.rule.strings" yaml:"yara.rule.strings" mapstructure:"strings"`
}

// Config stores YARA watcher specific configuration.
type Config struct {
	// Enabled indicates if YARA watcher is enabled.
	Enabled bool `json:"yara.enabled" yaml:"yara.enabled"`
	// Rule contains rule-specific settings.
	Rule Rule `json:"yara.rule" yaml:"yara.rule" mapstructure:"rule"`
	// AlertVia defines which alert sender is used to emit the alert on rule matches.
	AlertVia string `json:"yara.alert-via" yaml:"yara.alert-via"`
	// AlertTemplate defines the template that is used to render the text of the alert.
	AlertTextTemplate string `json:"yara.alert-text-template" yaml:"yara.alert-text-template"`
	// AlertTitle represents the template for the alert title
	AlertTitleTemplate string `json:"yara.alert-title-template" yaml:"yara.alert-title-template"`
	// FastScanMode avoids multiple matches of the same string when not necessary.
	FastScanMode bool `json:"yara.fastscan" yaml:"yara.fastscan"`
	// ScanTimeout sets the timeout for the scanner. If the timeout is reached, the scan operation is cancelled.
	ScanTimeout time.Duration `json:"yara.scan-timeout" yaml:"yara.scan-timeout"`
	// SkipFiles indicates whether file scanning is disabled
	SkipFiles bool `json:"yara.skip-files" yaml:"yara.skip-files"`
	// ExcludedProcesses contains the list of the process' image names that shouldn't be scanned
	ExcludedProcesses []string `json:"yara.excluded-procs" yaml:"yara.excluded-procs"`
	// ExcludedProcesses contains the list of the file names that shouldn't be scanned
	ExcludedFiles []string `json:"yara.excluded-files" yaml:"yara.excluded-files"`
}

// InitFromViper initializes Yara config from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Enabled = v.GetBool(enabled)
	c.AlertVia = v.GetString(alertVia)
	c.AlertTextTemplate = v.GetString(alertTextTemplate)
	c.AlertTitleTemplate = v.GetString(alertTitleTemplate)
	c.FastScanMode = v.GetBool(fastScanMode)
	c.ScanTimeout = v.GetDuration(scanTimeout)
	c.SkipFiles = v.GetBool(skipFiles)
	c.ExcludedFiles = v.GetStringSlice(excludedFiles)
	c.ExcludedProcesses = v.GetStringSlice(excludedProcesses)

	all := v.AllSettings()
	if _, ok := all["yara"]; !ok {
		return
	}
	if _, ok := all["yara"].(map[string]interface{}); !ok {
		return
	}

	var r Rule
	_ = decode(all["yara"].(map[string]interface{})["rule"], &r)
	c.Rule = r
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Specifies if Yara scanner is enabled")
	flags.String(alertVia, "mail", "Defines which alert sender is used to emit the alert on rule matches")
	flags.String(alertTextTemplate, "", "Defines the template that is used to render the text of the alert")
	flags.String(alertTitleTemplate, "", "Defines the template that is used to render the title of the alert")
	flags.Bool(fastScanMode, true, "Avoids multiple matches of the same string when not necessary")
	flags.Duration(scanTimeout, time.Second*10, "Specifies the timeout for the scanner. If the timeout is reached, the scan operation is cancelled")
	flags.Bool(skipFiles, true, "Indicates whether file scanning is disabled")
	flags.StringSlice(excludedFiles, []string{}, "Contains the list of the comma-separated file names that shouldn't be scanned")
	flags.StringSlice(excludedProcesses, []string{}, "Contains the list of the comma-separated process' image names that shouldn't be scanned")
}

// ShouldSkipProcess determines whether the specified process name is rejected by the scanner.
func (c Config) ShouldSkipProcess(ps string) bool {
	for _, proc := range c.ExcludedProcesses {
		if strings.EqualFold(proc, ps) {
			return true
		}
	}
	return false
}

// ShouldSkipFile determines whether the specified file name is rejected by the scanner.
func (c Config) ShouldSkipFile(file string) bool {
	for _, f := range c.ExcludedFiles {
		if strings.EqualFold(f, filepath.Base(file)) {
			return true
		}
	}
	return false
}

func decode(input, output interface{}) error {
	var decoderConfig = &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
		),
	}
	decoder, err := mapstructure.NewDecoder(decoderConfig)
	if err != nil {
		return err
	}
	return decoder.Decode(input)
}

```

`pkg/yara/scanner.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import (
	"bytes"
	"encoding/json"
	"expvar"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"time"

	"github.com/hillu/go-yara/v4"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/yara/config"
	ytypes "github.com/rabbitstack/fibratus/pkg/yara/types"
	log "github.com/sirupsen/logrus"
)

const alertTitleTmpl = `{{if .PS }}YARA alert on process {{ .PS.Name }}{{ else }}YARA alert on file {{ .Filename }}{{ end }}`

var (
	// ruleMatches computes all the rule matches
	ruleMatches = expvar.NewInt("yara.rule.matches")
	// rulesInCompiler keeps the counter of the number of rules in the compiler
	rulesInCompiler = expvar.NewInt("yara.rules.in.compiler")
	// totalScans computes the number of process/file scans
	totalScans = expvar.NewInt("yara.total.scans")
)

type scanner struct {
	c      *yara.Compiler
	rules  *yara.Rules
	config config.Config

	psnap ps.Snapshotter
}

// AlertContext contains the process state or file name along with all the rule matches.
type AlertContext struct {
	PS        *pstypes.PS
	Filename  string
	Matches   []yara.MatchRule
	Timestamp string
}

const tsLayout = "02 Jan 2006 15:04:05 MST"

// NewScanner creates a new YARA scanner.
func NewScanner(psnap ps.Snapshotter, config config.Config) (Scanner, error) {
	c, err := yara.NewCompiler()
	if err != nil {
		return nil, fmt.Errorf("unable to create yara compiler: %v", err)
	}
	// add yara rules from file system paths by walking the dirs recursively
	for _, dir := range config.Rule.Paths {
		f, err := os.Stat(dir.Path)
		if err != nil {
			log.Warnf("cannot access %q rule path: %v", dir.Path, err)
			continue
		}
		if !f.IsDir() {
			continue
		}
		err = filepath.Walk(dir.Path, func(path string, fi os.FileInfo, err error) error {
			if filepath.Ext(path) != ".yar" {
				return nil
			}
			f, err := os.Open(path)
			if err != nil {
				log.Warnf("cannot open the rule %q: %v", path, err)
				return nil
			}
			err = c.AddFile(f, dir.Namespace)
			_ = f.Close()
			if err != nil {
				log.Warnf("couldn't add %s rule: %v", fi.Name(), err)
				return nil
			}
			rulesInCompiler.Add(1)

			return nil
		})
		if err != nil {
			log.Warnf("couldn't walk %s path: %v", dir.Path, err)
		}
	}

	// add yara rules from config strings
	for _, s := range config.Rule.Strings {
		err := c.AddString(s.String, s.Namespace)
		if err != nil {
			log.Warnf("couldn't add %s rule string: %v", s.String, err)
			continue
		}
		rulesInCompiler.Add(1)
	}

	if len(c.Errors) > 0 {
		return nil, parseCompilerErrors(c.Errors)
	}

	rules, err := c.GetRules()
	if err != nil {
		return nil, fmt.Errorf("couldn't compile yara rules: %v", err)
	}

	return &scanner{
		c:      c,
		rules:  rules,
		config: config,
		psnap:  psnap,
	}, nil
}

// newInternalScanner creates a new instance of the go-yara scanner.
func (s scanner) newInternalScanner() (*yara.Scanner, error) {
	sn, err := yara.NewScanner(s.rules)
	if err != nil {
		return nil, fmt.Errorf("fail to create yara scanner: %v", err)
	}

	// set scan flags
	var flags yara.ScanFlags
	if s.config.FastScanMode {
		flags |= yara.ScanFlagsFastMode
	}
	sn.SetFlags(flags)
	sn.SetTimeout(s.config.ScanTimeout)
	return sn, nil
}

func parseCompilerErrors(errors []yara.CompilerMessage) error {
	errs := make([]error, len(errors))
	for i, err := range errors {
		errs[i] = fmt.Errorf("%s, filename: %s line: %d", err.Text, err.Filename, err.Line)
	}
	return multierror.Wrap(errs...)
}

func (s scanner) ScanProc(pid uint32, kevt *kevent.Kevent) error {
	proc := s.psnap.Find(pid)
	if proc == nil {
		return fmt.Errorf("cannot scan proc. pid %d does not exist in snapshotter", pid)
	}

	if s.config.ShouldSkipProcess(proc.Name) {
		return nil
	}
	var matches yara.MatchRules
	sn, err := s.newInternalScanner()
	if err != nil {
		return err
	}
	err = sn.SetCallback(&matches).ScanProc(int(pid))
	if err != nil {
		return fmt.Errorf("yara scan failed on proc %s (%d): %v", proc.Name, pid, err)
	}
	totalScans.Add(1)
	if len(matches) == 0 {
		return nil
	}
	ruleMatches.Add(int64(len(matches)))

	if err := putMatchesMeta(matches, kevt); err != nil {
		return err
	}

	ctx := AlertContext{
		PS:        proc,
		Matches:   matches,
		Timestamp: time.Now().Format(tsLayout),
	}

	return s.send(ctx)
}

func (s scanner) ScanFile(filename string, kevt *kevent.Kevent) error {
	if s.config.SkipFiles || s.config.ShouldSkipFile(filename) {
		return nil
	}
	sn, err := s.newInternalScanner()
	if err != nil {
		return err
	}
	var matches yara.MatchRules
	err = sn.SetCallback(&matches).ScanFile(filename)
	if err != nil {
		return fmt.Errorf("yara scan failed on %s file: %v", filename, err)
	}
	totalScans.Add(1)
	if len(matches) == 0 {
		return nil
	}
	ruleMatches.Add(int64(len(matches)))

	if err := putMatchesMeta(matches, kevt); err != nil {
		return err
	}

	ctx := AlertContext{
		Filename:  filename,
		Matches:   matches,
		Timestamp: time.Now().Format(tsLayout),
	}

	return s.send(ctx)
}

func (s scanner) send(ctx AlertContext) error {
	if s.config.AlertTitleTemplate == "" {
		s.config.AlertTitleTemplate = alertTitleTmpl
	}
	if s.config.AlertTextTemplate == "" {
		s.config.AlertTextTemplate = alertTextTmpl
	}
	// build a new yara alert template from the config options
	// or use a default template string. We'll feed the alertsender
	// with the output of the parsed template. Template content is
	// rendered by employing the Go templating engine. For more
	// details see https://golang.org/pkg/text/template/
	title, err := executeTmpl(s.config.AlertTitleTemplate, ctx)
	if err != nil {
		return err
	}
	text, err := executeTmpl(s.config.AlertTextTemplate, ctx)
	if err != nil {
		return err
	}

	// fetch the alert sender that is specified in the config
	sender := alertsender.Find(alertsender.ToType(s.config.AlertVia))
	if sender == nil {
		return fmt.Errorf("%q alert sender is not initialized", s.config.AlertVia)
	}

	alert := alertsender.NewAlert(
		title,
		text,
		tagsFromMatches(ctx.Matches),
		alertsender.Normal,
	)

	log.Infof("emitting yara alert via %q sender: %s", s.config.AlertVia, alert)

	return sender.Send(alert)
}

func executeTmpl(body string, ctx AlertContext) (string, error) {
	var writer bytes.Buffer

	tmpl, err := template.New("yara").Parse(body)
	if err != nil {
		return "", fmt.Errorf("template syntax error: %v", err)
	}
	err = tmpl.Execute(&writer, ctx)
	if err != nil {
		return "", fmt.Errorf("couldn't execute template: %v", err)
	}

	return writer.String(), nil
}

func tagsFromMatches(matches []yara.MatchRule) []string {
	tags := make([]string, 0)
	for _, match := range matches {
		tags = append(tags, match.Tags...)
	}
	return tags
}

// putMatchesMeta injects rule matches into event metadata as a JSON payload.
func putMatchesMeta(matches yara.MatchRules, kevt *kevent.Kevent) error {
	ruleMatches := make([]ytypes.MatchRule, 0)
	for _, m := range matches {
		match := ytypes.MatchRule{
			Rule:      m.Rule,
			Namespace: m.Namespace,
			Tags:      m.Tags,
			Metas:     make([]ytypes.Meta, 0),
			Strings:   make([]ytypes.MatchString, 0),
		}
		for _, meta := range m.Metas {
			match.Metas = append(match.Metas, ytypes.Meta{Value: meta.Value, Identifier: meta.Identifier})
		}
		for _, s := range m.Strings {
			match.Strings = append(match.Strings, ytypes.MatchString{Name: s.Name, Base: s.Base, Data: s.Data, Offset: s.Offset})
		}
		ruleMatches = append(ruleMatches, match)
	}
	b, err := json.Marshal(ruleMatches)
	if err != nil {
		return err
	}
	kevt.AddMeta(kevent.YaraMatchesKey, string(b))
	return nil
}

func (s scanner) Close() {
	if s.c != nil {
		s.c.Destroy()
	}
}

```

`pkg/yara/scanner_test.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import (
	"os"
	"path/filepath"
	"syscall"
	"testing"
	"time"

	"github.com/hillu/go-yara/v4"
	"github.com/rabbitstack/fibratus/pkg/kevent"
	"github.com/rabbitstack/fibratus/pkg/kevent/ktypes"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/kevent/kparams"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/syscall/handle"
	"github.com/rabbitstack/fibratus/pkg/syscall/process"
	"github.com/rabbitstack/fibratus/pkg/yara/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

var yaraAlert *alertsender.Alert

type mockSender struct{}

func (s *mockSender) Send(a alertsender.Alert) error {
	yaraAlert = &a
	return nil
}

func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	return &mockSender{}, nil
}

func init() {
	alertsender.Register(alertsender.Noop, makeSender)
}

func TestScan(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.Noop}}))

	s, err := NewScanner(psnap, config.Config{
		Enabled:  true,
		AlertVia: "noop",
		Rule: config.Rule{
			Paths: []config.RulePath{
				{
					Namespace: "default",
					Path:      "_fixtures/rules",
				},
			},
		},
	})
	require.NoError(t, err)

	var si syscall.StartupInfo
	var pi syscall.ProcessInformation

	argv := syscall.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "notepad.exe"))

	err = syscall.CreateProcess(
		nil,
		argv,
		nil,
		nil,
		true,
		0,
		nil,
		nil,
		&si,
		&pi)
	require.NoError(t, err)
	defer syscall.TerminateProcess(pi.Process, uint32(257))

	proc := &pstypes.PS{
		Name:      "notepad.exe",
		PID:       pi.ProcessId,
		Ppid:      2434,
		Exe:       `C:\Windows\notepad.exe`,
		Comm:      `C:\Windows\notepad.exe`,
		SID:       "archrabbit\\SYSTEM",
		Cwd:       `C:\Windows\`,
		SessionID: 1,
		Threads: map[uint32]pstypes.Thread{
			3453: {Tid: 3453, Entrypoint: kparams.Hex("0x7ffe2557ff80"), IOPrio: 2, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
			3455: {Tid: 3455, Entrypoint: kparams.Hex("0x5efe2557ff80"), IOPrio: 3, PagePrio: 5, KstackBase: kparams.Hex("0xffffc307810d6000"), KstackLimit: kparams.Hex("0xffffc307810cf000"), UstackLimit: kparams.Hex("0x5260000"), UstackBase: kparams.Hex("0x525f000")},
		},
		Envs: map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
		Modules: []pstypes.Module{
			{Name: "kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: kparams.Hex("fff23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
			{Name: "user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: kparams.Hex("fef23fff"), DefaultBaseAddress: kparams.Hex("fff124fd")},
		},
		Handles: []htypes.Handle{
			{Num: handle.Handle(0xffffd105e9baaf70),
				Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
				Type:   "Key",
				Object: 777488883434455544,
				Pid:    uint32(1023),
			},
			{
				Num:  handle.Handle(0xffffd105e9adaf70),
				Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
				Type: "ALPC Port",
				Pid:  uint32(1023),
				MD: &htypes.AlpcPortInfo{
					Seqno:   1,
					Context: 0x0,
					Flags:   0x0,
				},
				Object: 457488883434455544,
			},
			{
				Num:  handle.Handle(0xeaffd105e9adaf30),
				Name: `C:\Users\bunny`,
				Type: "File",
				Pid:  uint32(1023),
				MD: &htypes.FileInfo{
					IsDirectory: true,
				},
				Object: 357488883434455544,
			},
		},
		PE: &pe.PE{
			NumberOfSections: 2,
			NumberOfSymbols:  10,
			EntryPoint:       "0x20110",
			ImageBase:        "0x140000000",
			LinkTime:         time.Now(),
			Sections: []pe.Sec{
				{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
				{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
			},
			Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
			Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
			VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
		},
	}
	psnap.On("Find", mock.Anything).Return(proc)

	for {
		if process.IsAlive(handle.Handle(pi.Process)) {
			break
		}
		time.Sleep(time.Millisecond * 100)
	}

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.ProcessName: {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "svchost.exe"},
		},
		Metadata: make(map[kevent.MetadataKey]string),
	}

	// test attaching on pid
	require.NoError(t, s.ScanProc(pi.ProcessId, kevt))
	require.NotNil(t, yaraAlert)

	assert.Equal(t, "YARA alert on process notepad.exe", yaraAlert.Title)
	assert.NotEmpty(t, yaraAlert.Text)
	assert.Contains(t, yaraAlert.Tags, "notepad")

	// test file scanning on DLL that merely contains
	// the fmt.Println("Go Yara DLL Test") statement
	require.NoError(t, s.ScanFile("_fixtures/yara-test.dll", kevt))
	require.NotNil(t, yaraAlert)

	assert.Equal(t, "YARA alert on file _fixtures/yara-test.dll", yaraAlert.Title)
	assert.Contains(t, yaraAlert.Tags, "dll")

}

func TestMatchesMeta(t *testing.T) {
	yaraMatches := []yara.MatchRule{
		{Rule: "test", Namespace: "ns1"},
		{Rule: "test2", Namespace: "ns2", Tags: []string{"dropper"}, Metas: []yara.Meta{{Identifier: "author", Value: "rabbit"}}},
	}

	kevt := &kevent.Kevent{
		Type: ktypes.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		Kparams: kevent.Kparams{
			kparams.ProcessName: {Name: kparams.ProcessName, Type: kparams.UnicodeString, Value: "svchost.exe"},
		},
		Metadata: make(map[kevent.MetadataKey]string),
	}
	assert.Empty(t, kevt.Metadata)

	putMatchesMeta(yaraMatches, kevt)

	assert.NotEmpty(t, kevt.Metadata)
	assert.Contains(t, kevt.Metadata, kevent.YaraMatchesKey)
}

```

`pkg/yara/scanner_unsupported.go`:

```go
//go:build !yara
// +build !yara

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import (
	kerrors "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/yara/config"
)

// NewScanner returns unsupported scanner error.
func NewScanner(psnap ps.Snapshotter, config config.Config) (Scanner, error) {
	return nil, kerrors.ErrFeatureUnsupported("yara")
}

```

`pkg/yara/scanner_windows.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

const alertTextTmpl = `
	{{ if .PS }}
	Possible malicious process, {{ .PS.Name }} ({{ .PS.PID }}), detected at {{ .Timestamp }}.
	
	Rule matches
	{{- with .Matches }}
	{{ range . }}
		Rule: {{ .Rule }}
		Namespace: {{ .Namespace }}
		Metas: {{ .Metas }}
		Tags: {{ .Tags }}
	{{ end }}
	{{- end }}
	
	Process information

	Name: 		{{ .PS.Name }}
	PID:  		{{ .PS.PID }}
	PPID: 		{{ .PS.Ppid }}
	Comm:		{{ .PS.Comm }}
	Cwd:		{{ .PS.Cwd }}
	SID:		{{ .PS.SID }}
	Session ID: {{ .PS.SessionID }}
	{{ if .PS.Envs }}
	Env:	
			{{- with .PS.Envs }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
	{{ end }}
	Threads:
			{{- with .PS.Threads }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	Modules:	
			{{- with .PS.Modules }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ if .PS.Handles }}
	Handles:    
			{{- with .PS.Handles }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ end }}

	{{ if .PS.PE }}
	Entrypoint:  		{{ .PS.PE.EntryPoint }}
	Image base: 		{{ .PS.PE.ImageBase }}
	Build date:  		{{ .PS.PE.LinkTime }}
	
	Number of symbols: 	{{ .PS.PE.NumberOfSymbols }}
	Number of sections: {{ .PS.PE.NumberOfSections }}

	Sections: 
			{{- with .PS.PE.Sections }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ if .PS.PE.Symbols }}
	Symbols:
			{{- with .PS.PE.Symbols }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ end }}
	{{ if .PS.PE.Imports }}
	Imports:
			{{- with .PS.PE.Imports }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
	{{ end }}
	{{ if .PS.PE.VersionResources }}
	Resources:
			{{- with .PS.PE.VersionResources }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
	{{ end }}
	{{ end }}

	{{ else }}

	Possible malicious file, {{ .Filename }}, detected at {{ .Timestamp }}.
	
	Rule matches
	{{ with .Matches }}
	{{ range . }}
		Rule: {{ .Rule }}
		Namespace: {{ .Namespace }}
		Metas: {{ .Metas }}
		Tags:  {{ .Tags }}
	{{ end }}
	{{ end }}

	{{ end }}
`

```

`pkg/yara/types.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import "github.com/rabbitstack/fibratus/pkg/kevent"

// Scanner watches for certain kernel events such as process creation or image loading and
// triggers the scanning either of the target process or image file. If matches occur, an
// alert is emitted via specified alert sender.
type Scanner interface {
	// ScanProc scans process memory.
	ScanProc(pid uint32, kevt *kevent.Kevent) error
	// ScanFile scans the specified file in the file system.
	ScanFile(filename string, kevt *kevent.Kevent) error
	// Close disposes any resources allocated by scanner.
	Close()
}

```

`pkg/yara/types/types.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

// A MatchRule represents a rule successfully matched against a block
// of data.
type MatchRule struct {
	Rule      string        `json:"rule"`
	Namespace string        `json:"namespace"`
	Tags      []string      `json:"tags"`
	Metas     []Meta        `json:"metas"`
	Strings   []MatchString `json:"strings"`
}

// A MatchString represents a string declared and matched in a rule.
type MatchString struct {
	Name   string `json:"name"`
	Base   uint64 `json:"base"`
	Offset uint64 `json:"offset"`
	Data   []byte `json:"data"`
}

// Meta represents a rule meta variable. Value can be of type string,
// int, boolean, or nil.
type Meta struct {
	Identifier string      `json:"identifier"`
	Value      interface{} `json:"value"`
}

```