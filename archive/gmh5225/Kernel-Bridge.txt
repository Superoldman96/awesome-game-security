Project Path: arc_gmh5225_Kernel-Bridge_oyzgij1e

Source Tree:

```txt
arc_gmh5225_Kernel-Bridge_oyzgij1e
├── CommonTypes
│   ├── CPUID.h
│   ├── Hyper-V.h
│   ├── Interrupts.h
│   ├── MSR.h
│   ├── PTE.h
│   ├── Registers.h
│   ├── SVM.h
│   ├── Segmentation.h
│   └── VMX.h
├── HookLib
├── Kernel-Bridge
│   ├── API
│   │   ├── CPU.cpp
│   │   ├── CPU.h
│   │   ├── Callable.cpp
│   │   ├── Callable.h
│   │   ├── CommPort.cpp
│   │   ├── CommPort.h
│   │   ├── CppSupport.cpp
│   │   ├── CppSupport.h
│   │   ├── FilesAPI.cpp
│   │   ├── FilesAPI.h
│   │   ├── Hypervisor.cpp
│   │   ├── Hypervisor.h
│   │   ├── IO.cpp
│   │   ├── IO.h
│   │   ├── Importer.cpp
│   │   ├── Importer.h
│   │   ├── KernelShells.cpp
│   │   ├── KernelShells.h
│   │   ├── LinkedList.h
│   │   ├── Locks.h
│   │   ├── MemoryUtils.cpp
│   │   ├── MemoryUtils.h
│   │   ├── OSVersion.cpp
│   │   ├── OSVersion.h
│   │   ├── ObCallbacks.cpp
│   │   ├── ObCallbacks.h
│   │   ├── ProcessesUtils.cpp
│   │   ├── ProcessesUtils.h
│   │   ├── PsCallbacks.cpp
│   │   ├── PsCallbacks.h
│   │   ├── PteUtils.cpp
│   │   ├── PteUtils.h
│   │   ├── RAII.h
│   │   ├── SectionsUtils.cpp
│   │   ├── SectionsUtils.h
│   │   ├── Signatures.cpp
│   │   ├── Signatures.h
│   │   ├── Stopwatch.cpp
│   │   ├── Stopwatch.h
│   │   ├── StringsAPI.h
│   │   └── VMM.asm
│   ├── Exports.def
│   ├── Kernel-Bridge
│   │   ├── DriverEvents.cpp
│   │   ├── DriverEvents.h
│   │   ├── FilterCallbacks.cpp
│   │   ├── FilterCallbacks.h
│   │   ├── IOCTLHandlers.cpp
│   │   ├── IOCTLHandlers.h
│   │   ├── IOCTLs.h
│   │   ├── LoadableModules.cpp
│   │   └── LoadableModules.h
│   ├── Kernel-Bridge.cpp
│   ├── Kernel-Bridge.inf
│   ├── Kernel-Bridge.rc
│   ├── Kernel-Bridge.vcxproj
│   └── Kernel-Bridge.vcxproj.filters
├── Kernel-Bridge.sln
├── Kernel-Tests
│   ├── Kernel-Tests.cpp
│   ├── Kernel-Tests.h
│   ├── Kernel-Tests.vcxproj
│   ├── Kernel-Tests.vcxproj.filters
│   ├── Main.cpp
│   ├── pch.cpp
│   ├── pch.h
│   └── resource.h
├── Kernel-Toolkit
│   └── Kernel-Toolkit
│       ├── Kernel-Toolkit.pro
│       ├── Main.cpp
│       ├── MainWindow.cpp
│       ├── MainWindow.h
│       ├── MainWindow.ui
│       ├── ObjectsStorage.cpp
│       └── ObjectsStorage.h
├── LICENSE
├── LoadableModule
│   ├── Exports.def
│   ├── LoadableModule.vcxproj
│   ├── LoadableModule.vcxproj.filters
│   └── Main.cpp
├── MakeBundle.bat
├── Python-Bridge
│   └── Python-Bridge.py
├── README.md
├── SharedTypes
│   ├── CtlTypes.h
│   ├── FltTypes.h
│   └── WdkTypes.h
├── User-Bridge
│   ├── API
│   │   ├── CommPort.cpp
│   │   ├── CommPort.h
│   │   ├── DriversUtils.cpp
│   │   ├── DriversUtils.h
│   │   ├── Flt-Bridge.h
│   │   ├── PEUtils
│   │   │   ├── PEAnalyzer.cpp
│   │   │   ├── PEAnalyzer.h
│   │   │   ├── PELoader.cpp
│   │   │   └── PELoader.h
│   │   ├── Rtl-Bridge.cpp
│   │   ├── Rtl-Bridge.h
│   │   ├── SymParser.cpp
│   │   ├── SymParser.h
│   │   ├── User-Bridge.cpp
│   │   └── User-Bridge.h
│   ├── Exports.def
│   ├── Main.cpp
│   ├── User-Bridge.vcxproj
│   └── User-Bridge.vcxproj.filters
├── x32-debug.ddf
├── x32-release.ddf
├── x64-debug.ddf
└── x64-release.ddf

```

`CommonTypes/CPUID.h`:

```h
#pragma once

union CPUID_REGS {
    int Raw[4];
    struct {
        unsigned int Eax;
        unsigned int Ebx;
        unsigned int Ecx;
        unsigned int Edx;
    } Regs;
};
static_assert(sizeof(CPUID_REGS) == sizeof(int) * 4, "Size of CPUID_REGS != sizeof(int[4])");

namespace CPUID {
    namespace Generic {
        enum CPUID_FUNCTIONS { // EAX values:
            // Standard CPUID functions:
            CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID = 0x00000000,
            CPUID_FEATURE_INFORMATION = 0x00000001,
            CPUID_MONITOR_MWAIT_PARAMETERS = 0x00000005,
            CPUID_THERMAL_POWER_MANAGEMENT = 0x00000006,
            CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION = 0x00000007,

            // Extended CPUID functions:
            CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID = 0x80000000,
            CPUID_EXTENDED_FEATURE_INFORMATION = 0x80000001,
            CPUID_PROCESSOR_BRAND_STRING_0 = 0x80000002,
            CPUID_PROCESSOR_BRAND_STRING_1 = 0x80000003,
            CPUID_PROCESSOR_BRAND_STRING_2 = 0x80000004,
        };
    }

    namespace Intel {
        enum CPUID_FUNCTIONS { // EAX values:
            // Standard CPUID functions:
            CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID = 0x00000000,
            CPUID_FEATURE_INFORMATION = 0x00000001,
            CPUID_CACHE_DESCRIPTORS = 0x00000002,
            CPUID_PROCESSOR_SERIAL_NUMBER = 0x00000003,
            CPUID_DETERMINISTIC_CACHE_PARAMETERS = 0x00000004,
            CPUID_MONITOR_MWAIT_PARAMETERS = 0x00000005,
            CPUID_THERMAL_POWER_MANAGEMENT = 0x00000006,
            CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION = 0x00000007,
            // 0x00000008 is reserved
            CPUID_DIRECT_CACHE_ACCESS_PARAMETERS = 0x00000009,
            CPUID_ARCHITECTUAL_PERFORMANCE_MONITOR_FEATURES = 0x0000000A,
            CPUID_X2APIC_FEATURES = 0x0000000B,
            // 0x0000000C is reserved
            CPUID_XSAVE_FEATURES = 0x0000000D,

            // Extended CPUID functions:
            CPUID_LARGEST_EXTENDED_FUNCTION = 0x80000000,
            CPUID_EXTENDED_FEATURE_INFORMATION = 0x80000001,
            CPUID_PROCESSOR_BRAND_STRING_0 = 0x80000002,
            CPUID_PROCESSOR_BRAND_STRING_1 = 0x80000003,
            CPUID_PROCESSOR_BRAND_STRING_2 = 0x80000004,
            // 0x80000005 is reserved
            CPUID_EXTENDED_L2_CACHE_FEATURES = 0x80000006,
            CPUID_ADVANCED_POWER_MANAGEMENT = 0x80000007,
            CPUID_VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES = 0x80000008
        };
    }

    namespace AMD {
        enum CPUID_FUNCTIONS { // EAX values:
            // Standard CPUID functions:
            CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID = 0x00000000,
            CPUID_FEATURE_INFORMATION = 0x00000001,
            // 0x00000002..0x00000004 are reserved
            CPUID_MONITOR_MWAIT_PARAMETERS = 0x00000005,
            CPUID_THERMAL_POWER_MANAGEMENT = 0x00000006,
            CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION = 0x00000007,
            // 0x00000008..0x0000000C are reserved
            CPUID_PROCESSOR_EXTENDED_STATE_ENUMERATION = 0x0000000C,
            // 0x40000000..0x400000FF are reserved for hypervisor use

            // Extended CPUID functions:
            CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID = 0x80000000,
            CPUID_EXTENDED_FEATURE_INFORMATION = 0x80000001,
            CPUID_PROCESSOR_BRAND_STRING_0 = 0x80000002,
            CPUID_PROCESSOR_BRAND_STRING_1 = 0x80000003,
            CPUID_PROCESSOR_BRAND_STRING_2 = 0x80000004,
            CPUID_L1_AND_TLB = 0x80000005,
            CPUID_L2_L3_TLB = 0x80000006,
            CPUID_POWER_MANAGEMENT_AND_RAS_CAPABILITIES = 0x80000007,
            CPUID_CAPACITY_AND_EXTENDED_FEATURES = 0x80000008,
            // 0x80000009 is reserved
            CPUID_SVM_FEATURES = 0x8000000A,
            // 0x8000000B..0x80000018 are reserved
            CPUID_TLB_CHARACTERISTICS_FOR_1GB_PAGES = 0x80000019,
            CPUID_INSTRUCTION_OPTIMIZATIONS = 0x8000001A,
            CPUID_INSTRUCTION_BASED_SAMPLING_CAPABILITIES = 0x8000001B,
            CPUID_LIGHTWEIGHT_PROFILING_CAPABILITIES = 0x8000001C,
            CPUID_CACHE_TOPOLOGY_INFORMATION = 0x8000001D,
            CPUID_PROCESSOR_TOPOLOGY_INFORMATION = 0x8000001E,
            CPUID_ENCRYPTED_MEMORY_CAPABILITIES = 0x8000001F
        };
    }

    union MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID {
        CPUID_REGS Regs;
        struct {
            unsigned int LargestStandardFunctionNumber;
            unsigned int VendorPart1; // 'uneG' || 'htuA'
            unsigned int VendorPart3; // 'letn' || 'DMAc' --> 'GenuineIntel' or 'AuthenticAMD' (EAX + EDX + ECX)
            unsigned int VendorPart2; // 'Ieni' || 'itne'
        } Bitmap;
    };
    static_assert(sizeof(MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID) == sizeof(CPUID_REGS), "Size of MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID != sizeof(int[4])");

    union MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID {
        CPUID_REGS Regs;
        struct {
            unsigned int LargestExtendedFunctionNumber;
            unsigned int VendorPart1; // 'uneG' || 'htuA'
            unsigned int VendorPart3; // 'letn' || 'DMAc' --> 'GenuineIntel' or 'AuthenticAMD' (EAX + EDX + ECX)
            unsigned int VendorPart2; // 'Ieni' || 'itne'
        } Bitmap;
    };
    static_assert(sizeof(MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID) == sizeof(CPUID_REGS), "Size of MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID != sizeof(int[4])");

    union FEATURE_INFORMATION {
        CPUID_REGS Regs;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int ProcessorType : 2;
            unsigned int Reserved0 : 2;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int BrandIndex : 8;
            unsigned int ClflushLineSize : 8; // Value * 8 = cache line size in bytes
            unsigned int LogicalProcessorCount : 8; // Valid only if CPUID.1.EDX.HTT == 1
            unsigned int InitialApicId : 8;

            // ECX:
            unsigned int SSE3 : 1;
            unsigned int PCLMULQDQ : 1;
            unsigned int DTES64 : 1; // 64-bit DS area
            unsigned int MONITOR : 1;
            unsigned int DS_CPL : 1; // CPL qualified debug store
            unsigned int VMX : 1;
            unsigned int SMX : 1;
            unsigned int EIST : 1; // Enhanced Intel Speed-Step
            unsigned int TM2 : 1; // Thermal monitor 2
            unsigned int SSSE3 : 1;
            unsigned int CNXT_ID : 1; // L1 context ID
            unsigned int SDBG : 1; // Support of IA32_DEBUG_INTERFACE MSR
            unsigned int FMA : 1;
            unsigned int CMPXCHG16B : 1;
            unsigned int xTPRUpdateControl : 1; // Support of IA32_MISC_ENABLE changing
            unsigned int PDCM : 1; // Perfmon and debug capability: support of MSR IA32_PERF_CAPABILITIES
            unsigned int Reserved2 : 1;
            unsigned int PCID : 1; // Process-context identifiers: support of setting the CR4.PCIDE to 1
            unsigned int DSA : 1; // Ability to prefetch data from a memory mapped device
            unsigned int SSE41 : 1;
            unsigned int SSE42 : 1;
            unsigned int x2APIC : 1; // Support of x2APIC feature
            unsigned int MOVBE : 1;
            unsigned int POPCNT : 1;
            unsigned int TSCDeadline : 1; // Indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline value
            unsigned int AESNI : 1;
            unsigned int XSAVE : 1;
            unsigned int OSXSAVE : 1;
            unsigned int AVX : 1;
            unsigned int F16C : 1;
            unsigned int RDRAND : 1;
            unsigned int NotUsed : 1; // Always returns 0

            // EDX:
            unsigned int FPU : 1;
            unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extension
            unsigned int TSC : 1; // Time stamp counter
            unsigned int MSR : 1; // RDMSR/WRMSR support
            unsigned int PAE : 1; // Physical address extensions support
            unsigned int MCE : 1; // Machine check exception
            unsigned int CX8 : 1; // CMPXCHG8B
            unsigned int APIC : 1;
            unsigned int Reserved3 : 1;
            unsigned int SEP : 1; // SYSENTER/SYSEXIT instructions support
            unsigned int MTRR : 1; // Memory-Type Range Registers support
            unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
            unsigned int MCA : 1; // Machine check architecture
            unsigned int CMOV : 1; // Conditional move instruction support
            unsigned int PAT : 1; // Page attribute table
            unsigned int PSE36 : 1; // 36-bit page size extension
            unsigned int PSN : 1; // Support of 96-bit processor serial number
            unsigned int CLFSH : 1; // CLFLUSH instruction support
            unsigned int Reserved4 : 1;
            unsigned int DS : 1; // Debug store
            unsigned int ACPI : 1; // Thermal Monitor and Software Controlled Clock Facilities
            unsigned int MMX : 1;
            unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
            unsigned int SSE : 1;
            unsigned int SSE2 : 1;
            unsigned int SS : 1; // Self-snoop
            unsigned int HTT : 1; // Max APIC IDs reserved field is Valid (CPUID.1.EBX.LogicalProcessorCount is valid)
            unsigned int TM : 1; // Thermal monitor
            unsigned int Reserved5 : 1;
            unsigned int PBE : 1; // Pending break enable
        } Intel;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int BrandIndex : 8;
            unsigned int ClflushLineSize : 8; // Value * 8 = cache line size in bytes
            unsigned int LogicalProcessorCount : 8; // Valid only if CPUID.1.EDX.HTT == 1
            unsigned int InitialApicId : 8;

            // ECX:
            unsigned int SSE3 : 1;
            unsigned int PCLMULQDQ : 1;
            unsigned int Reserved2 : 1;
            unsigned int MONITOR : 1;
            unsigned int Reserved3 : 5;
            unsigned int SSSE3 : 1;
            unsigned int Reserved4 : 2;
            unsigned int FMA : 1;
            unsigned int CMPXCHG16B : 1;
            unsigned int Reserved5 : 5;
            unsigned int SSE41 : 1;
            unsigned int SSE42 : 1;
            unsigned int Reserved6 : 1;
            unsigned int MOVBE : 1;
            unsigned int POPCNT : 1;
            unsigned int Reserved7 : 1;
            unsigned int AES : 1;
            unsigned int XSAVE : 1;
            unsigned int OSXSAVE : 1;
            unsigned int AVX : 1;
            unsigned int F16C : 1;
            unsigned int RDRAND : 1;
            unsigned int ReservedForHvGuestStatus : 1; // Reserved for use by hypervisor to indicate guest status

            // EDX:
            unsigned int FPU : 1;
            unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extension
            unsigned int TSC : 1; // Time stamp counter
            unsigned int MSR : 1; // RDMSR/WRMSR support
            unsigned int PAE : 1; // Physical address extensions support
            unsigned int MCE : 1; // Machine check exception
            unsigned int CMPXCHG8B : 1;
            unsigned int APIC : 1;
            unsigned int Reserved8 : 1;
            unsigned int SysEnterSysExit : 1; // SYSENTER/SYSEXIT instructions support
            unsigned int MTRR : 1; // Memory-Type Range Registers support
            unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
            unsigned int MCA : 1; // Machine check architecture
            unsigned int CMOV : 1; // Conditional move instruction support
            unsigned int PAT : 1; // Page attribute table
            unsigned int PSE36 : 1; // 36-bit page size extension
            unsigned int Reserved9 : 1;
            unsigned int CLFSH : 1; // CLFLUSH instruction support
            unsigned int Reserved10 : 3;
            unsigned int MMX : 1;
            unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
            unsigned int SSE : 1;
            unsigned int SSE2 : 1;
            unsigned int Reserved11 : 1;
            unsigned int HTT : 1; // Max APIC IDs reserved field is Valid (CPUID.1.EBX.LogicalProcessorCount is valid)
            unsigned int Reserved12 : 3;
        } Generic, AMD;
    };
    static_assert(sizeof(FEATURE_INFORMATION) == sizeof(CPUID_REGS), "Size of FEATURE_INFORMATION != sizeof(int[4])");

    union EXTENDED_FEATURE_INFORMATION {
        CPUID_REGS Regs;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int Reserved2 : 32;

            // ECX:
            unsigned int LahfSahf : 1;
            unsigned int Reserved3 : 4;
            unsigned int LZCNT : 1;
            unsigned int Reserved4 : 2;
            unsigned int PREFETCHW : 1;
            unsigned int Reserved5 : 23;

            // EDX:
            unsigned int Reserved6 : 11;
            unsigned int SysCallSysRet : 1;
            unsigned int Reserved7 : 8;
            unsigned int NX : 1;
            unsigned int Reserved8 : 5;
            unsigned int Page1Gb : 1; // 1-Gb large page support
            unsigned int RDTSCP : 1;
            unsigned int Reserved9 : 1;
            unsigned int LongMode : 1; // 64-bit mode
            unsigned int Reserved10 : 2;
        } Generic;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int Reserved2 : 32;

            // ECX:
            unsigned int LahfSahf : 1;
            unsigned int Reserved3 : 4;
            unsigned int LZCNT : 1;
            unsigned int Reserved4 : 2;
            unsigned int PREFETCHW : 1;
            unsigned int Reserved5 : 23;

            // EDX:
            unsigned int Reserved6 : 11;
            unsigned int SysCallSysRet : 1;
            unsigned int Reserved7 : 8;
            unsigned int NX : 1;
            unsigned int Reserved8 : 5;
            unsigned int Page1Gb : 1; // 1-Gb large page support
            unsigned int RdtscpIa32TscAux : 1;
            unsigned int Reserved9 : 1;
            unsigned int IA64 : 1; // Intel64 Architecture support
            unsigned int Reserved10 : 2;
        } Intel;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int BrandId : 16;
            unsigned int Reserved2 : 12;
            unsigned int PkgType : 4;

            // ECX:
            unsigned int LahfSahf : 1;
            unsigned int CmpLegacy : 1; // Core multiprocessing legacy mode
            unsigned int SVM : 1; // Secure virtual machine
            unsigned int ExtApicSpace : 1;
            unsigned int AltMovCr8 : 1; // "lock mov cr0" means "mov cr8"
            unsigned int ABM : 1; // Advanced bit manipulation
            unsigned int SSE4A : 1; // EXTRQ, INSERTQ, MOVNTSS, and MOVNTSD instruction support
            unsigned int MisAlignSse : 1; // Misaligned SSE mode
            unsigned int _3DNowPrefetch : 1; // PREFETCH and PREFETCHW instruction support
            unsigned int OSVW : 1; // OS visible workaround
            unsigned int IBS : 1; // Instruction based sampling
            unsigned int XOP : 1; // Extended operation support
            unsigned int SKINIT : 1; // SKINIT and STGI are supported, independent of the value of MSRC000_0080[SVME]
            unsigned int WDT : 1; // Watchdog time support
            unsigned int Reserved3 : 1;
            unsigned int LWP : 1; // Lightweight profiling support
            unsigned int FMA4 : 1;
            unsigned int Reserved4 : 1;
            unsigned int Reserved5 : 1;
            unsigned int NodeId : 1;
            unsigned int Reserved6 : 1;
            unsigned int TBM : 1; // Trailing bit manipulation instruction support
            unsigned int TopologyExtension : 1;
            unsigned int Reserved7 : 9;

            // EDX:
            unsigned int FPU : 1;
            unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extension
            unsigned int TSC : 1; // Time stamp counter
            unsigned int MSR : 1; // RDMSR/WRMSR support
            unsigned int PAE : 1; // Physical address extensions support
            unsigned int MCE : 1; // Machine check exception
            unsigned int CMPXCHG8B : 1;
            unsigned int APIC : 1;
            unsigned int Reserved8 : 1;
            unsigned int SysCallSysRet : 1; // SYSCALL/SYSRET instructions support
            unsigned int MTRR : 1; // Memory-Type Range Registers support
            unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
            unsigned int MCA : 1; // Machine check architecture
            unsigned int CMOV : 1; // Conditional move instruction support
            unsigned int PAT : 1; // Page attribute table
            unsigned int PSE36 : 1; // 36-bit page size extension
            unsigned int Reserved9 : 2;
            unsigned int NX : 1; // No-execute page protection
            unsigned int Reserved10 : 1;
            unsigned int MmxExt : 1;
            unsigned int MMX : 1;
            unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
            unsigned int FFXSR : 1;  // FXSAVE and FXRSTOR instruction optimizations
            unsigned int Page1Gb : 1; // 1-Gb large page support
            unsigned int RDTSCP : 1;
            unsigned int Reserved11 : 1;
            unsigned int LM : 1; // Long-mode
            unsigned int _3DNowExt : 1;
            unsigned int _3DNow : 1;
        } AMD;
    };
    static_assert(sizeof(EXTENDED_FEATURE_INFORMATION) == sizeof(CPUID_REGS), "Size of EXTENDED_FEATURE_INFORMATION != sizeof(int[4])");

    union PROCESSOR_BRAND_STRING_0 {
        CPUID_REGS Regs;
        struct {
            unsigned int Part0;
            unsigned int Part1;
            unsigned int Part2;
            unsigned int Part3;
        } ProcessorName;
    };
    static_assert(sizeof(PROCESSOR_BRAND_STRING_0) == sizeof(CPUID_REGS), "Size of PROCESSOR_BRAND_STRING_0 != sizeof(int[4])");

    union PROCESSOR_BRAND_STRING_1 {
        CPUID_REGS Regs;
        struct {
            unsigned int Part4;
            unsigned int Part5;
            unsigned int Part6;
            unsigned int Part7;
        } ProcessorName;
    };
    static_assert(sizeof(PROCESSOR_BRAND_STRING_1) == sizeof(CPUID_REGS), "Size of PROCESSOR_BRAND_STRING_1 != sizeof(int[4])");

    union PROCESSOR_BRAND_STRING_2 {
        CPUID_REGS Regs;
        struct {
            unsigned int Part8;
            unsigned int Part9;
            unsigned int Part10;
            unsigned int Part11;
        } ProcessorName;
    };
    static_assert(sizeof(PROCESSOR_BRAND_STRING_2) == sizeof(CPUID_REGS), "Size of PROCESSOR_BRAND_STRING_2 != sizeof(int[4])");

    namespace Intel {
        union VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES {
            CPUID_REGS Regs;
            struct {
                // EAX:
                unsigned int PhysicalAddressBits : 8;
                unsigned int LinearAddressBits : 8;
                unsigned int Reserved0 : 16;
                
                unsigned int Reserved1 : 32; // EBX
                unsigned int Reserved2 : 32; // ECX
                unsigned int Reserved3 : 32; // EDX
            } Bitmap;
        };
        static_assert(sizeof(VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES) == sizeof(CPUID_REGS), "Size of VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES != sizeof(int[4])");
    }
}
```

`CommonTypes/Hyper-V.h`:

```h
#pragma once

// Hyper-V conformance requirements:
// https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs

namespace HyperV
{
    // Version 6.0b (Feb. 2020)

    union HYPERCALL_INPUT_VALUE
    {
        unsigned long long Value;
        struct
        {
            unsigned long long CallCode : 16; // HYPERCALL_CODE
            unsigned long long Fast : 1;
            unsigned long long VariableHeaderSize : 9;
            unsigned long long IsNested : 1;
            unsigned long long Reserved0 : 5;
            unsigned long long RepCount : 12;
            unsigned long long Reserved1 : 4;
            unsigned long long RepStartIndex : 12;
            unsigned long long Reserved2 : 4;
        } Bitmap;
    };
    static_assert(sizeof(HYPERCALL_INPUT_VALUE) == sizeof(unsigned long long), "Size of HYPERCALL_INPUT_VALUE != sizeof(unsigned long long)");

    union HYPERCALL_RESULT_VALUE
    {
        unsigned long long Value;
        struct
        {
            unsigned long long Result : 16; // HV_STATUS
            unsigned long long Reserved0 : 16;
            unsigned long long RepsComplete : 12;
            unsigned long long Reserved1 : 20;
        } Bitmap;
    };
    static_assert(sizeof(HYPERCALL_RESULT_VALUE) == sizeof(unsigned long long), "Size of HYPERCALL_RESULT_VALUE != sizeof(unsigned long long)");

    enum class HYPERCALL_CODE
    {
        HvSwitchVirtualAddressSpace = 0x0001,
        HvFlushVirtualAddressSpace = 0x0002,
        HvFlushVirtualAddressList = 0x0003,
        HvGetLogicalProcessorRunTime = 0x0004,
        // 0x0005..0x0007 are reserved
        HvCallNotifyLongSpinWait = 0x0008,
        HvCallParkedVirtualProcessors = 0x0009,
        HvCallSyntheticClusterIpi = 0x000B,
        HvCallModifyVtlProtectionMask = 0x000C,
        HvCallEnablePartitionVtl = 0x000D,
        HvCallDisablePartitionVtl = 0x000E,
        HvCallEnableVpVtl = 0x000F,
        HvCallDisableVpVtl = 0x0010,
        HvCallVtlCall = 0x0011,
        HvCallVtlReturn = 0x0012,
        HvCallFlushVirtualAddressSpaceEx = 0x0013,
        HvCallFlushVirtualAddressListEx = 0x0014,
        HvCallSendSyntheticClusterIpiEx = 0x0015,
        // 0x0016..0x003F are reserved
        HvCreatePartition = 0x0040,
        HvInitializePartition = 0x0041,
        HvFinalizePartition = 0x0042,
        HvDeletePartition = 0x0043,
        HvGetPartitionProperty = 0x0044,
        HvSetPartitionProperty = 0x0045,
        HvGetPartitionId = 0x0046,
        HvGetNextChildPartition = 0x0047,
        HvDepositMemory = 0x0048,
        HvWithdrawMemory = 0x0049,
        HvGetMemoryBalance = 0x004A,
        HvMapGpaPages = 0x004B,
        HvUnmapGpaPages = 0x004C,
        HvInstallIntercept = 0x004D,
        HvCreateVp = 0x004E,
        HvDeleteVp = 0x004F,
        HvGetVpRegisters = 0x0050,
        HvSetVpRegisters = 0x0051,
        HvTranslateVirtualAddress = 0x0052,
        HvReadGpa = 0x0053,
        HvWriteGpa = 0x0054,
        // 0x0055 is deprecated
        HvClearVirtualInterrupt = 0x0056,
        // 0x0057 is deprecated
        HvDeletePort = 0x0058,
        HvConnectPort = 0x0059,
        HvGetPortProperty = 0x005A,
        HvDisconnectPort = 0x005B,
        HvPostMessage = 0x005C,
        HvSignalEvent = 0x005D,
        HvSavePartitionState = 0x005E,
        HvRestorePartitionState = 0x005F,
        HvInitializeEventLogBufferGroup = 0x0060,
        HvFinalizeEventLogBufferGroup = 0x0061,
        HvCreateEventLogBuffer = 0x0062,
        HvDeleteEventLogBuffer = 0x0063,
        HvMapEventLogBuffer = 0x0064,
        HvUnmapEventLogBuffer = 0x0065,
        HvSetEventLogGroupSources = 0x0066,
        HvReleaseEventLogBuffer = 0x0067,
        HvFlushEventLogBuffer = 0x0068,
        HvPostDebugData = 0x0069,
        HvRetrieveDebugData = 0x006A,
        HvResetDebugSession = 0x006B,
        HvMapStatsPage = 0x006C,
        HvUnmapStatsPage = 0x006D,
        HvCallMapSparseGpaPages = 0x006E,
        HvCallSetSystemProperty = 0x006F,
        HvCallSetPortProperty = 0x0070,
        // 0x0071..0x0075 are reserved
        HvCallAddLogicalProcessor = 0x0076,
        HvCallRemoveLogicalProcessor = 0x0077,
        HvCallQueryNumaDistance = 0x0078,
        HvCallSetLogicalProcessorProperty = 0x0079,
        HvCallGetLogicalProcessorProperty = 0x007A,
        HvCallGetSystemProperty = 0x007B,
        HvCallMapDeviceInterrupt = 0x007C,
        HvCallUnmapDeviceInterrupt = 0x007D,
        HvCallRetargetDeviceInterrupt = 0x007E,
        // 0x007F is reserved
        HvCallMapDevicePages = 0x0080,
        HvCallUnmapDevicePages = 0x0081,
        HvCallAttachDevice = 0x0082,
        HvCallDetachDevice = 0x0083,
        HvCallNotifyStandbyTransition = 0x0084,
        HvCallPrepareForSleep = 0x0085,
        HvCallPrepareForHibernate = 0x0086,
        HvCallNotifyPartitionEvent = 0x0087,
        HvCallGetLogicalProcessorRegisters = 0x0088,
        HvCallSetLogicalProcessorRegisters = 0x0089,
        HvCallQueryAssotiatedLpsforMca = 0x008A,
        HvCallNotifyRingEmpty = 0x008B,
        HvCallInjectSyntheticMachineCheck = 0x008C,
        HvCallScrubPartition = 0x008D,
        HvCallCollectLivedump = 0x008E,
        HvCallDisableHypervisor = 0x008F,
        HvCallModifySparseGpaPages = 0x0090,
        HvCallRegisterInterceptResult = 0x0091,
        HvCallUnregisterInterceptResult = 0x0092,
        HvCallAssertVirtualInterrupt = 0x0094,
        HvCallCreatePort = 0x0095,
        HvCallConnectPort = 0x0096,
        HvCallGetSpaPageList = 0x0097,
        // 0x0098 is reserved
        HvCallStartVirtualProcessor = 0x009A,
        HvCallGetVpIndexFromApicId = 0x009A,
        // 0x009A..0x00AE are reserved
        HvCallFlushGuestPhysicalAddressSpace = 0x00AF,
        HvCallFlushGuestPhysicalAddressList = 0x00B0
    };

    enum class HV_STATUS
    {
        HV_STATUS_SUCCESS = 0x0000,
        // 0x0001 is reserved
        HV_STATUS_INVALID_HYPERCALL_CODE = 0x0002,
        HV_STATUS_INVALID_HYPERCALL_INPUT = 0x0003,
        HV_STATUS_INVALID_ALIGNMENT = 0x0004,
        HV_STATUS_INVALID_PARAMETER = 0x0005,
        HV_STATUS_ACCESS_DENIED = 0x0006,
        HV_STATUS_INVALID_PARTITION_STATE = 0x0007,
        HV_STATUS_OPERATION_DENIED = 0x0008,
        HV_STATUS_UNKNOWN_PROPERTY = 0x0009,
        HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE = 0x000A,
        HV_STATUS_INSUFFICIENT_MEMORY = 0x000B,
        HV_STATUS_PARTITION_TOO_DEEP = 0x000C,
        HV_STATUS_INVALID_PARTITION_ID = 0x000D,
        HV_STATUS_INVALID_VP_INDEX = 0x000E,
        // 0x000F..0x0010 are reserved
        HV_STATUS_INVALID_PORT_ID = 0x0011,
        HV_STATUS_INVALID_CONNECTION_ID = 0x0012,
        HV_STATUS_INSUFFICIENT_BUFFERS = 0x0013,
        HV_STATUS_NOT_ACKNOWLEDGED = 0x0014,
        HV_STATUS_INVALID_VP_STATE = 0x0015,
        HV_STATUS_ACKNOWLEDGED = 0x0016,
        HV_STATUS_INVALID_SAVE_REStORE_STATE = 0x0017,
        HV_STATUS_INVALID_SYNIC_STATE = 0x0018,
        HV_STATUS_OBJECT_IN_USE = 0x0019,
        HV_STATUS_INVALID_PROXIMITY_DOMAIN_INFO = 0x001A,
        HV_STATUS_NO_DATA = 0x001B,
        HV_STATUS_INACTIVE = 0x001C,
        HV_STATUS_NO_RESOURCES = 0x001D,
        HV_STATUS_FEATURE_UNAVAILABLE = 0x001E,
        HV_STATUS_PARTIAL_PACKET = 0x001F,
        HV_STATUS_PROCESSOR_FEATURE_NOT_SUPPORTED = 0x0020,
        HV_STATUS_PROCESSOR_CACHE_LINE_FLUSH_SIZE_INCOMPATIBLE = 0x0030,
        HV_STATUS_INSUFFICIENT_BUFFER = 0x0033,
        HV_STATUS_INCOMPATIBLE_PROCESSOR = 0x0037,
        HV_STATUS_INSUFFICIENT_DEVICE_DOMAINS = 0x0038,
        HV_STATUS_CPUID_FEATURE_VALIDATION_ERROR = 0x003C,
        HV_STATUS_CPUID_XSAVE_FEATURE_VALIDATION_ERROR = 0x003D,
        HV_STATUS_PROCESSOR_STARTUP_TIMEOUT = 0x003E,
        HV_STATUS_SMX_ENABLED = 0x003F,
        HV_STATUS_INVALID_LP_INDEX = 0x0041,
        HV_STATUS_INVALID_REGISTER_VALUE = 0x0050,
        HV_STATUS_NX_NOT_DETECTED = 0x0055,
        HV_STATUS_INVALID_DEVICE_ID = 0x0057,
        HV_STATUS_INVALID_DEVICE_STATE = 0x0058,
        HV_STATUS_PENDING_PAGE_REQUESTS = 0x0059,
        HV_STATUS_PAGE_REQUEST_INVALID = 0x0060,
        HV_STATUS_OPERATION_FAILED = 0x0071,
        HV_STATUS_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = 0x0072,
    };

    enum class CPUID
    {
        MAX_LEAF_NUMBER_AND_VENDOR_ID = 0x40000000,
        INTERFACE_SIGNATURE = 0x40000001,
        SYSTEM_IDENTITY = 0x40000002,
        FEATURE_IDENTIFICATION = 0x40000003,
        IMPLEMENTATION_RECOMMENDATIONS = 0x40000004,
        IMPLEMENTATION_LIMITS = 0x40000005,
        IMPLEMENTATION_HARDWARE_FEATURES = 0x40000006,
        CPU_MANAGEMENT_FEATURES = 0x40000007,
        SVM_FEATURES = 0x40000008,
        NESTED_HYPERVISOR_FEATURE_IDENTIFICATION = 0x40000009,
        NESTED_VIRTUALIZATION_FEATURES = 0x4000000A,
    };

    enum class HYPERVISOR_SYNTHETIC_MSRS
    {
        HV_X64_MSR_GUEST_OS_ID = 0x40000000,
        HV_X64_MSR_HYPERCALL   = 0x40000001,
        HV_X64_MSR_VP_INDEX    = 0x40000002,
        HV_X64_MSR_RESET = 0x40000003,
        HV_X64_MSR_VP_RUNTIME = 0x40000010,
        HV_X64_MSR_TIME_REF_COUNT = 0x40000020,
        HV_X64_MSR_REFERENCE_TSC = 0x40000021,
        HV_X64_MSR_TSC_FREQUENCY = 0x40000022,
        HV_X64_MSR_APIC_FREQUENCY = 0x40000023,
        HV_X64_MSR_NPIEP_CONFIG = 0x40000040,
        HV_X64_MSR_EOI = 0x40000070,
        HV_X64_MSR_ICR = 0x40000071,
        HV_X64_MSR_TPR = 0x40000072,
        HV_X64_MSR_VP_ASSIST_PAGE = 0x40000073,
        HV_X64_MSR_SCONTROL = 0x40000080,
        HV_X64_MSR_SVERSION = 0x40000081,
        HV_X64_MSR_SIEFP = 0x40000082,
        HV_X64_MSR_SIMP = 0x40000083,
        HV_X64_MSR_EOM = 0x40000084,
        HV_X64_MSR_SINT0 = 0x40000090,
        HV_X64_MSR_SINT1 = 0x40000091,
        HV_X64_MSR_SINT2 = 0x40000092,
        HV_X64_MSR_SINT3 = 0x40000093,
        HV_X64_MSR_SINT4 = 0x40000094,
        HV_X64_MSR_SINT5 = 0x40000095,
        HV_X64_MSR_SINT6 = 0x40000096,
        HV_X64_MSR_SINT7 = 0x40000097,
        HV_X64_MSR_SINT8 = 0x40000098,
        HV_X64_MSR_SINT9 = 0x40000099,
        HV_X64_MSR_SINT10 = 0x4000009A,
        HV_X64_MSR_SINT11 = 0x4000009B,
        HV_X64_MSR_SINT12 = 0x4000009C,
        HV_X64_MSR_SINT13 = 0x4000009D,
        HV_X64_MSR_SINT14 = 0x4000009E,
        HV_X64_MSR_SINT15 = 0x4000009F,
        HV_X64_MSR_STIMER0_CONFIG = 0x400000B0,
        HV_X64_MSR_STIMER0_COUNT = 0x400000B1,
        HV_X64_MSR_STIMER1_CONFIG = 0x400000B2,
        HV_X64_MSR_STIMER1_COUNT = 0x400000B3,
        HV_X64_MSR_STIMER2_CONFIG = 0x400000B4,
        HV_X64_MSR_STIMER2_COUNT = 0x400000B5,
        HV_X64_MSR_STIMER3_CONFIG = 0x400000B6,
        HV_X64_MSR_STIMER3_COUNT = 0x400000B7,
        HV_X64_MSR_GUEST_IDLE = 0x400000F0,
        HV_X64_MSR_CRASH_P0 = 0x40000100,
        HV_X64_MSR_CRASH_P1 = 0x40000101,
        HV_X64_MSR_CRASH_P2 = 0x40000102,
        HV_X64_MSR_CRASH_P3 = 0x40000103,
        HV_X64_MSR_CRASH_P4 = 0x40000104,
        HV_X64_MSR_CRASH_CTL = 0x40000105,
        HV_X64_MSR_REENLIGHTENMENT_CONTROL = 0x40000106,
        HV_X64_MSR_TSC_EMULATION_CONTROL = 0x40000107,
        HV_X64_MSR_TSC_EMULATION_STATUS = 0x40000108,
        HV_X64_MSR_STIME_UNHALTED_TIMER_CONFIG = 0x40000114,
        HV_X64_MSR_STIME_UNHALTED_TIMER_COUNT = 0x30000115,
        HV_X64_MSR_NESTED_VP_INDEX = 0x40001002,
        HV_X64_MSR_NESTED_SCONTROL = 0x40001080,
        HV_X64_MSR_NESTED_SVERSION = 0x40001081,
        HV_X64_MSR_NESTED_SIEFP = 0x40001082,
        HV_X64_MSR_NESTED_SIMP = 0x40001083,
        HV_X64_MSR_NESTED_EOM = 0x40001084,
        HV_X64_MSR_NESTED_SINT0 = 0x40001090,
        HV_X64_MSR_NESTED_SINT1 = 0x40001091,
        HV_X64_MSR_NESTED_SINT2 = 0x40001092,
        HV_X64_MSR_NESTED_SINT3 = 0x40001093,
        HV_X64_MSR_NESTED_SINT4 = 0x40001094,
        HV_X64_MSR_NESTED_SINT5 = 0x40001095,
        HV_X64_MSR_NESTED_SINT6 = 0x40001096,
        HV_X64_MSR_NESTED_SINT7 = 0x40001097,
        HV_X64_MSR_NESTED_SINT8 = 0x40001098,
        HV_X64_MSR_NESTED_SINT9 = 0x40001099,
        HV_X64_MSR_NESTED_SINT10 = 0x4000109A,
        HV_X64_MSR_NESTED_SINT11 = 0x4000109B,
        HV_X64_MSR_NESTED_SINT12 = 0x4000109C,
        HV_X64_MSR_NESTED_SINT13 = 0x4000109D,
        HV_X64_MSR_NESTED_SINT14 = 0x4000109E,
        HV_X64_MSR_NESTED_SINT15 = 0x4000109F,
    };
}
```

`CommonTypes/Interrupts.h`:

```h
#pragma once

enum class INTERRUPT_VECTOR
{
    DivideError = 0,                 // #DE, DIV and IDIV instructions
    Debug = 1,                       // #DB, any code or data reference
    NmiInterrupt = 2,                //      Non-maskable interrupt
    Breakpoint = 3,                  // #BP, INT3 instruction
    Overflow = 4,                    // #OF, INT0 instruction
    BoundRangeExceeded = 5,          // #BR, BOUND instruction
    InvalidOpcode = 6,               // #UD, UD instruction or reserved opcode
    DeviceNotAvailable = 7,          // #NM, No math coprocoessor (floating point or WAIT/FWAIT instruction)
    DoubleFault = 8,                 // #DF, Any instruction that can generate an exception, an NMI or an INTR
    CoProcessorSegmentOverrun = 9,   // #MF, Floating-point instruction
    InvalidTss = 10,                 // #TS, Task switch or TSS access
    SegmentNotPresent = 11,          // #NP, Loading segment register or accessing system segments
    StackSegmentFault = 12,          // #SS, Stack operations and SS register loads
    GeneralProtection = 13,          // #GP, Any memory reference and other protection checks
    PageFault = 14,                  // #PF, Any memory reference
    Reserved = 15,
    FloatingPointError = 16,         // #MF, Floating-point or WAIT/FWAIT instruction
    AlignmentCheck = 17,             // #AC, Any data reference in memory
    MachineCheck = 18,               // #MC, Error codes (if any) and source are model-dependent
    SimdFloatingPointException = 19, // #XM, SIMD floating-point instruction
    VirtualizationException = 20,    // #VE, EPT violations
    ControlProtectionException = 21, // #CP, The RET, IRET, RSTORSSP, SETSSBSY, and ENDBRANCH (whet CET is enabled) instructions
    // 22..31 are reserved
    // 32..255 are maskable interrupts (external interrupt from INTR pin or INTn instruction
};
```

`CommonTypes/MSR.h`:

```h
#pragma once

namespace Intel
{
    enum class INTEL_MSR : unsigned int {
        IA32_FEATURE_CONTROL = 0x0000003A,
        IA32_SYSENTER_CS = 0x00000174,
        IA32_SYSENTER_ESP = 0x00000175,
        IA32_SYSENTER_EIP = 0x00000176,
        IA32_EFER = 0xC0000080,
        IA32_STAR = 0xC0000081,
        IA32_LSTAR = 0xC0000082,
        IA32_CSTAR = 0xC0000083,
        IA32_FS_BASE = 0xC0000100,
        IA32_GS_BASE = 0xC0000101,
        IA32_KERNEL_GS_BASE = 0xC0000102,
        IA32_DEBUGCTL = 0x000001D9,

        // MTRR:
        IA32_MTRRCAP = 0xFE,
        IA32_MTRR_DEF_TYPE = 0x2FF,
        IA32_MTRR_PHYSBASE0 = 0x200,
        IA32_MTRR_PHYSMASK0 = 0x201,
        IA32_MTRR_PHYSBASE1 = 0x202,
        IA32_MTRR_PHYSMASK1 = 0x203,
        IA32_MTRR_PHYSBASE2 = 0x204,
        IA32_MTRR_PHYSMASK2 = 0x205,
        IA32_MTRR_PHYSBASE3 = 0x206,
        IA32_MTRR_PHYSMASK3 = 0x207,
        IA32_MTRR_PHYSBASE4 = 0x208,
        IA32_MTRR_PHYSMASK4 = 0x209,
        IA32_MTRR_PHYSBASE5 = 0x20A,
        IA32_MTRR_PHYSMASK5 = 0x20B,
        IA32_MTRR_PHYSBASE6 = 0x20C,
        IA32_MTRR_PHYSMASK6 = 0x20D,
        IA32_MTRR_PHYSBASE7 = 0x20E,
        IA32_MTRR_PHYSMASK7 = 0x20F,
        IA32_MTRR_PHYSBASE8 = 0x210,
        IA32_MTRR_PHYSMASK8 = 0x211,
        IA32_MTRR_PHYSBASE9 = 0x212,
        IA32_MTRR_PHYSMASK9 = 0x213,
        IA32_MTRR_FIX64K_00000 = 0x250,
        IA32_MTRR_FIX16K_80000 = 0x258,
        IA32_MTRR_FIX16K_A0000 = 0x259,
        IA32_MTRR_FIX4K_C0000 = 0x268,
        IA32_MTRR_FIX4K_C8000 = 0x269,
        IA32_MTRR_FIX4K_D0000 = 0x26A,
        IA32_MTRR_FIX4K_D8000 = 0x26B,
        IA32_MTRR_FIX4K_E0000 = 0x26C,
        IA32_MTRR_FIX4K_E8000 = 0x26D,
        IA32_MTRR_FIX4K_F0000 = 0x26E,
        IA32_MTRR_FIX4K_F8000 = 0x26F,

        // VMX-related MSRs:
        IA32_VMX_BASIC = 0x00000480,
        IA32_VMX_PINBASED_CTLS = 0x481,
        IA32_VMX_PROCBASED_CTLS = 0x482,
        IA32_VMX_EXIT_CTLS = 0x483,
        IA32_VMX_ENTRY_CTLS = 0x484,
        IA32_VMX_MISC = 0x485,
        IA32_VMX_CR0_FIXED0 = 0x486,
        IA32_VMX_CR0_FIXED1 = 0x487,
        IA32_VMX_CR4_FIXED0 = 0x488,
        IA32_VMX_CR4_FIXED1 = 0x489,
        IA32_VMX_VMCS_ENUM = 0x48A,
        IA32_VMX_PROCBASED_CTLS2 = 0x48B,
        IA32_VMX_EPT_VPID_CAP = 0x48C,
        IA32_VMX_TRUE_PINBASED_CTLS = 0x48D,
        IA32_VMX_TRUE_PROCBASED_CTLS = 0x48E,
        IA32_VMX_TRUE_EXIT_CTLS = 0x48F,
        IA32_VMX_TRUE_ENTRY_CTLS = 0x490,
        IA32_VMX_VMFUNC = 0x491
    };

    union IA32_FEATURE_CONTROL {
        unsigned long long Value;
        struct {
            unsigned long long LockBit : 1;
            unsigned long long EnableVmxInsideSmx : 1;
            unsigned long long EnableVmxOutsideSmx : 1;
            unsigned long long Reserved0 : 5;
            unsigned long long SenterLocalFunctionEnables : 7;
            unsigned long long SenterGlobalEnable : 1;
            unsigned long long Reserved1 : 1;
            unsigned long long SgxLaunchControlEnable : 1;
            unsigned long long SgxGlobalEnable : 1;
            unsigned long long Reserved2 : 1;
            unsigned long long LmceOn : 1;
            unsigned long long Reserved3 : 43;
        } Bitmap;
    };
    static_assert(sizeof(IA32_FEATURE_CONTROL) == sizeof(unsigned long long), "Size of IA32_FEATURE_CONTROL != sizeof(unsigned long long)");

    union IA32_EFER {
        unsigned long long Value;
        struct {
            unsigned long long SCE : 1; // Syscall enable (R/W) - enables syscall/sysret instructions in 64-bit mode 
            unsigned long long Reserved0 : 7;
            unsigned long long LME : 1; // Enables IA-32e mode operation (R/W)
            unsigned long long Reserved1 : 1;
            unsigned long long LMA : 1; // IA32-e mode active (R)
            unsigned long long NXE : 1; // Execute Disable bit Enable (R/W)
            unsigned long long Reserved2 : 52;
        } Bitmap;
    };
    static_assert(sizeof(IA32_EFER) == sizeof(unsigned long long), "Size of IA32_EFER != sizeof(unsigned long long)");

    union IA32_VMX_BASIC {
        unsigned long long Value;
        struct {
            unsigned long long VmcsRevision : 31;
            unsigned long long Reserved0 : 1;
            unsigned long long VmxonVmcsRegionsSize : 13;
            unsigned long long Reserved1 : 3;
            unsigned long long PhysicalAddressesWidth : 1; // 0 = Processor's physical-address width (always 0 on Intel64), 1 = 32-bit
            unsigned long long DualMonitorTreatmentOfSmiAndSmm : 1;
            unsigned long long MemoryType : 4; // 0 = Uncacheable, 6 = Write-back, 1..5 and 7..15 aren't used
            unsigned long long InsOutsReporting : 1;
            unsigned long long AnyVmxControlsThatDefaultToOneMayBeZeroed : 1;
            unsigned long long CanUseVMEntryToDeliverHardwareException : 1;
            unsigned long long Reserved2 : 7;
        } Bitmap;
    };
    static_assert(sizeof(IA32_VMX_BASIC) == sizeof(unsigned long long), "Size of IA32_VMX_BASIC != sizeof(unsigned long long)");

    union IA32_VMX_EPT_VPID_CAP {
        unsigned long long Value;
        struct {
            unsigned long long ExecuteOnlyTranslationsSupportByEpt : 1;
            unsigned long long Reserved0 : 5;
            unsigned long long PageWalkLength4Support : 1;
            unsigned long long Reserved1 : 1;
            unsigned long long UncacheableEptSupport : 1;
            unsigned long long Reserved2 : 5;
            unsigned long long WriteBackEptSupport : 1;
            unsigned long long Reserved3 : 1;
            unsigned long long EptPde2MbSupport : 1;
            unsigned long long EptPdpte1GbSupport : 1;
            unsigned long long Reserved4 : 2;
            unsigned long long InveptSupport : 1;
            unsigned long long AccessedDirtyFlagsSupported : 1;
            unsigned long long EptViolationsSupport : 1;
            unsigned long long SupervisorShadowStackControlSupported : 1;
            unsigned long long Reserved5 : 1;
            unsigned long long SingleContextInveptTypeSupported : 1;
            unsigned long long AllContextInveptTypeSupported : 1;
            unsigned long long Reserved6 : 5;
            unsigned long long InvvpidSupported : 1;
            unsigned long long Reserved7 : 7;
            unsigned long long IndividualAddressInvvpidTypeSupported : 1;
            unsigned long long SingleContextInvvpidTypeSupported : 1;
            unsigned long long AllContextInvvpidTypeSupported : 1;
            unsigned long long SingleContextRetainingGlobalsInvvpidTypeSupported : 1;
            unsigned long long Reserved8 : 20;
        } Bitmap;
    };
    static_assert(sizeof(IA32_VMX_EPT_VPID_CAP) == sizeof(unsigned long long), "Size of IA32_VMX_EPT_VPID_CAP != sizeof(unsigned long long)");

    union IA32_MTRRCAP {
        unsigned long long Value;
        struct {
            unsigned long long VCNT : 8; // Variable range registers count
            unsigned long long FIX : 1; // Fixed range registers supported
            unsigned long long Reserved0 : 1;
            unsigned long long WC : 1; // Write combining
            unsigned long long SMRR : 1; // System-management range registers
            unsigned long long PRMRR : 1; // Processor-reserved memory range registers (starting with 7th Gen and 8th Gen Intel Core processors)
            unsigned long long Reserved1 : 51;
        } Bitmap;
    };
    static_assert(sizeof(IA32_MTRRCAP) == sizeof(unsigned long long), "Size of IA32_MTRRCAP != sizeof(unsigned long long)");

    enum class MTRR_MEMORY_TYPE {
        Uncacheable = 0x00,
        WriteCombining = 0x01,
        // 0x02 and 0x03 are reserved
        WriteThrough = 0x04,
        WriteProtected = 0x05,
        WriteBack = 0x06,
        // 0x07..0xFF are reserved
    };

    union IA32_MTRR_DEF_TYPE {
        unsigned long long Value;
        struct {
            unsigned long long Type : 3; // Default memory type (the only valid values are 0, 1, 4, 5, and 6), look at the MTRR_MEMORY_TYPE
            unsigned long long Reserved0 : 7;
            unsigned long long FE : 1; // Fixed MTRRs enabled
            unsigned long long E : 1; // MTRRs enabled
            unsigned long long Reserved1 : 52;
        } Bitmap;
    };
    static_assert(sizeof(IA32_MTRR_DEF_TYPE) == sizeof(unsigned long long), "Size of IA32_MTRR_DEF_TYPE != sizeof(unsigned long long)");

    union IA32_MTRR_FIX64K {
        unsigned long long Value;
        struct { // Maps the 512-Kbyte address range (0..7FFFF) divided into eight 64-Kbyte sub-ranges:
            unsigned long long TypeOf64KbRange0 : 8; // 00000..0FFFF
            unsigned long long TypeOf64KbRange1 : 8; // 10000..1FFFF
            unsigned long long TypeOf64KbRange2 : 8; // 20000..2FFFF
            unsigned long long TypeOf64KbRange3 : 8; // 30000..3FFFF
            unsigned long long TypeOf64KbRange4 : 8; // 40000..4FFFF
            unsigned long long TypeOf64KbRange5 : 8; // 50000..5FFFF
            unsigned long long TypeOf64KbRange6 : 8; // 60000..6FFFF
            unsigned long long TypeOf64KbRange7 : 8; // 70000..7FFFF
        } Bitmap, Range00000;
    };
    static_assert(sizeof(IA32_MTRR_FIX64K) == sizeof(unsigned long long), "Size of IA32_MTRR_FIX64K != sizeof(unsigned long long)");

    union IA32_MTRR_FIX16K {
        unsigned long long Value;
        struct {
            unsigned long long TypeOf16KbRange0 : 8; // 80000..83FFF  |  A0000..A3FFF
            unsigned long long TypeOf16KbRange1 : 8; // 84000..87FFF  |  A4000..A7FFF
            unsigned long long TypeOf16KbRange2 : 8; // 88000..8BFFF  |  A8000..ABFFF
            unsigned long long TypeOf16KbRange3 : 8; // 8C000..8FFFF  |  AC000..AFFFF
            unsigned long long TypeOf16KbRange4 : 8; // 90000..93FFF  |  B0000..B3FFF
            unsigned long long TypeOf16KbRange5 : 8; // 94000..97FFF  |  B4000..B7FFF
            unsigned long long TypeOf16KbRange6 : 8; // 98000..9BFFF  |  B8000..BBFFF
            unsigned long long TypeOf16KbRange7 : 8; // 9C000..9FFFF  |  BC000..BFFFF
        } Bitmap, Range80000, RangeA0000;
    };
    static_assert(sizeof(IA32_MTRR_FIX16K) == sizeof(unsigned long long), "Size of IA32_MTRR_FIX16K != sizeof(unsigned long long)");

    union IA32_MTRR_FIX4K {
        unsigned long long Value;
        struct {
            unsigned long long TypeOf4KbRange0 : 8; // [C..F]0000..[C..F]0FFF  |  [C..F]8000..[C..F]8FFF
            unsigned long long TypeOf4KbRange1 : 8; // [C..F]1000..[C..F]1FFF  |  [C..F]9000..[C..F]9FFF
            unsigned long long TypeOf4KbRange2 : 8; // [C..F]2000..[C..F]2FFF  |  [C..F]A000..[C..F]AFFF
            unsigned long long TypeOf4KbRange3 : 8; // [C..F]3000..[C..F]3FFF  |  [C..F]B000..[C..F]BFFF
            unsigned long long TypeOf4KbRange4 : 8; // [C..F]4000..[C..F]4FFF  |  [C..F]C000..[C..F]CFFF
            unsigned long long TypeOf4KbRange5 : 8; // [C..F]5000..[C..F]5FFF  |  [C..F]D000..[C..F]DFFF
            unsigned long long TypeOf4KbRange6 : 8; // [C..F]6000..[C..F]6FFF  |  [C..F]E000..[C..F]EFFF
            unsigned long long TypeOf4KbRange7 : 8; // [C..F]7000..[C..F]7FFF  |  [C..F]F000..[C..F]FFFF
        } Bitmap,
            RangeC0000, RangeC8000,
            RangeD0000, RangeD8000,
            RangeE0000, RangeE8000,
            RangeF0000, RangeF8000;
    };
    static_assert(sizeof(IA32_MTRR_FIX4K) == sizeof(unsigned long long), "Size of IA32_MTRR_FIX4K != sizeof(unsigned long long)");

    union MTRR_FIXED_GENERIC {
        unsigned long long Value;
        struct {
            unsigned long long Range0 : 8;
            unsigned long long Range1 : 8;
            unsigned long long Range2 : 8;
            unsigned long long Range3 : 8;
            unsigned long long Range4 : 8;
            unsigned long long Range5 : 8;
            unsigned long long Range6 : 8;
            unsigned long long Range7 : 8;
        } Generic;
        IA32_MTRR_FIX64K Fix64k;
        IA32_MTRR_FIX16K Fix16k;
        IA32_MTRR_FIX4K  Fix4k;
    };
    static_assert(sizeof(MTRR_FIXED_GENERIC) == sizeof(unsigned long long), "Size of MTRR_FIXED_GENERIC != sizeof(unsigned long long)");

    union IA32_MTRR_PHYSBASE {
        unsigned long long Value;
        struct {
            unsigned long long Type : 8; // Memory type for range
            unsigned long long Reserved : 4;
            unsigned long long PhysBasePfn : 52; // 36-bit or MAXPHYSADDR length (depending on CPUID(0x80000008)), all other bits are reserved
        } Bitmap;
    };
    static_assert(sizeof(IA32_MTRR_PHYSBASE) == sizeof(unsigned long long), "Size of IA32_MTRR_PHYSBASE != sizeof(unsigned long long)");

    union IA32_MTRR_PHYSMASK {
        unsigned long long Value;
        struct {
            unsigned long long Reserved : 11;
            unsigned long long V : 1; // Valid
            unsigned long long PhysMaskPfn : 52; // 36-bit or MAXPHYSADDR length (depending on CPUID(0x80000008)), all other bits are reserved
        } Bitmap;
    };
    static_assert(sizeof(IA32_MTRR_PHYSMASK) == sizeof(unsigned long long), "Size of IA32_MTRR_PHYSMASK != sizeof(unsigned long long)");
}

namespace AMD
{
    enum class AMD_MSR : unsigned int {
        MSR_PAT = 0x00000277, // Extension of the page tables in SVM (nested paging)
        MSR_EFER = 0xC0000080, // Etended Feature Enable Register
        MSR_STAR = 0xC0000081, // Legacy mode: address of a SYSCALL instruction
        MSR_LSTAR = 0xC0000081, // Long mode: address of a SYSCALL instruction
        MSR_CSTAR = 0xC0000081, // Compatibility mode: address of a SYSCALL instruction
        MSR_VM_CR = 0xC0010114, // Controls global aspects of SVM
        MSR_VM_HSAVE_PA = 0xC0010117, // Physical address of a 4KB block of memory where VMRUN saves host state, and from which #VMEXIT reloads host state
    };

    union EFER {
        unsigned long long Value;
        struct {
            unsigned long long SystemCallExtensions : 1; // 1 = enable SYSCALL/SYSRET support
            unsigned long long Reserved0 : 7;
            unsigned long long LongModeEnable : 1;
            unsigned long long Reserved1 : 1;
            unsigned long long LongModeActive : 1;
            unsigned long long NoExecuteEnable : 1;
            unsigned long long SecureVirtualMachineEnable : 1;
            unsigned long long LongModeSegmentLimitEnable : 1;
            unsigned long long FastFxsaveFxrstor : 1;
            unsigned long long TranslationCacheExtension : 1;
            unsigned long long Reserved2 : 48;
        } Bitmap;
    };
    static_assert(sizeof(EFER) == sizeof(unsigned long long), "Size of EFER != sizeof(unsigned long long)");

    union VM_CR {
        unsigned long long Value;
        struct {
            unsigned long long DPD : 1;
            unsigned long long R_INIT : 1;
            unsigned long long DIS_A20M : 1;
            unsigned long long LOCK : 1;
            unsigned long long SVMDIS : 1; // When set, EFER.SVME must be zero
            unsigned long long Reserved : 59;
        } Bitmap;
    };
    static_assert(sizeof(VM_CR) == sizeof(unsigned long long), "Size of VM_CR != sizeof(unsigned long long)");
}
```

`CommonTypes/PTE.h`:

```h
#pragma once

/*
    Page size (max VA = 64 bit, max PA = 52 bit):
     * Long Mode (CR4.PAE always = 1, CR4.PSE ignored): 
         // Maximum VA = 64 bit
         // Maximum PA = 52 bit
         if (PDPE.PS) {
             PML4E -> PDPE -> PA
             PageSize = 1 Gbyte;
         }
         else {
             if (PDE.PS) {
                 PML4E -> PDPE -> PDE -> PA
                 PageSize = 2 Mbyte;
             } else {
                 PML4E -> PDPE -> PDE -> PTE -> PA
                 PageSize = 4 Kbyte;
             }
         }

     * Legacy Mode:
         // PDPE.PS always = 0
         // Maximum VA = 32 bit
         if (CR4.PAE) {
             // CR4.PSE ignored
             // Maximum PA = 52 bit
             if (PDE.PS) {
                 PDPE -> PDE -> PA
                 PageSize = 2 Mbyte;
             } else {
                 PDPE -> PDE -> PTE -> PA
                 PageSize = 4 Kbyte;
             }
         }
         else {
             if (CR4.PSE) {
                 if (PDE.PS) {
                     // Maximum PA = 40 bit
                     PDE -> PA
                     PageSize = 4 Mbyte;
                 } else {
                     // Maximum PA = 32 bit
                     PDE -> PTE -> PA
                     PageSize = 4 Kbyte;
                 }
             }
             else {
                 // PDE.PS ignored
                 // Maximum PA = 32 bit
                 PDE -> PTE -> PA
                 PageSize = 4 Kbyte;
             }
         }
*/

// 1 << 12 == 4096 (0x1000, 4Kb):
#define PFN_TO_PAGE(pfn)        ((pfn)  << 12)
#define PAGE_TO_PFN(page)       ((page) >> 12)

// 1 << 21 == 2097152 (0x200000, 2Mb):
#define PFN_TO_LARGE_PAGE(pfn)  ((pfn)  << 21)
#define LARGE_PAGE_TO_PFN(page) ((page) >> 21)

// 1 << 30 == 1'073'741'824‬ (0x40000000, 1Gb):
#define PFN_TO_HUGE_PAGE(pfn)   ((pfn)  << 30)
#define HUGE_PAGE_TO_PFN(page)  ((page) >> 30)

// CR3 in PAE : PDP at 5:31
#define PFN_TO_PDP_PAE(pfn) ((pfn) << 5)

#pragma pack(push, 1)
union VIRTUAL_ADDRESS {
    unsigned long long Value;
    union {
        unsigned int Value;
        union {
            struct {
                unsigned int Reserved0 : 22; // Depends on page size
                unsigned int PageDirectoryOffset : 10;
            } Generic;
            struct {
                unsigned int PageOffset : 12; // Offset into the physical page
                unsigned int PageTableOffset : 10; // Index into the 1024-entry page-table
                unsigned int PageDirectoryOffset : 10; // Index into the 1024-entry page-directory table
            } Page4Kb; // PDE.PS == 0
            struct {
                unsigned int PageOffset : 22; // Offset into the physical page
                unsigned int PageDirectoryOffset : 10; // Index into the 1024-entry page-directory table
            } Page4Mb; // PDE.PS == 1
        } NonPae; // CR4.PAE == 0
        union {
            struct {
                unsigned int Reserved0 : 30; // Depends on page size
                unsigned int PageDirectoryOffset : 9;
                unsigned int PageDirectoryPointerOffset : 2;
            } Generic;
            struct {
                unsigned int PageOffset : 12; // Byte offset into the physical page
                unsigned int PageTableOffset : 9; // Index into the 512-entry page table
                unsigned int PageDirectoryOffset : 9; // Index into the 512-entry page-directory table
                unsigned int PageDirectoryPointerOffset : 2; // Index into a 4-entry page-directory-pointer table
            } Page4Kb; // PDE.PS == 0
            struct {
                unsigned int PageOffset : 21; // Byte offset into the physical page
                unsigned int PageDirectoryOffset : 9; // Index into the 512-entry page-directory table
                unsigned int PageDirectoryPointerOffset : 2; // Index into a 4-entry page-directory-pointer table
            } Page2Mb; // PDE.PS == 1
        } Pae; // CR4.PAE == 1
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long Reserved0 : 30; // Depends on page size
            unsigned long long PageDirectoryPointerOffset : 9;
            unsigned long long PageMapLevel4Offset : 9;
            unsigned long long SignExtend : 16;
        } Generic;
        union {
            struct {
                unsigned long long Reserved0 : 21; // Depends on page size
                unsigned long long PageDirectoryOffset : 9;
                unsigned long long PageDirectoryPointerOffset : 9;
                unsigned long long PageMapLevel4Offset : 9;
                unsigned long long SignExtend : 16;
            } Generic; // To determine whether the page size is 4Kb or 2Mb
            struct {
                unsigned long long PageOffset : 12; // Byte offset into the physical page
                unsigned long long PageTableOffset : 9; // Index into the 512-entry page table
                unsigned long long PageDirectoryOffset : 9; // Index into the 512-entry page-directory table
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry page-directory pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry page-map level-4 table
                unsigned long long SignExtend : 16;
            } Page4Kb; // PDE.PS == 0
            struct {
                unsigned long long PageOffset : 21; // Byte offset into the physical page
                unsigned long long PageDirectoryOffset : 9; // Index into the 512-entry page-directory table
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry page-directory pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry page-map level-4 table
                unsigned long long SignExtend : 16;
            } Page2Mb; // PDE.PS == 1
        } NonPageSize; // PDPE.PS == 0
        union {
            struct {
                unsigned long long PageOffset : 30; // Byte offset into the physical page
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry page-directory pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry page-map level-4 table
                unsigned long long SignExtend : 16;
            } Page1Gb;
        } PageSize; // PDPE.PS == 1
    } x64;
};

union PML4E {
    union {
        unsigned long long Value;
        struct {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long Ignored0 : 1;
            unsigned long long Reserved1 : 2;
            unsigned long long AVL : 3; // Available to software
            unsigned long long PDP : 40; // Page frame number
            unsigned long long Available : 11;
            unsigned long long NX : 1; // No Execute
        } Page4Kb, Page2Mb, Page1Gb, Generic; // Same for the 4Kb, 2Mb and 1Gb page size
    } x64;
};

union PDPE {
    union {
        union {
            unsigned long long Value;
            struct {
                unsigned long long P : 1; // Present
                unsigned long long Reserved0 : 2;
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long Reserved1 : 4;
                unsigned long long AVL : 3; // Available to software
                unsigned long long PD : 40; // Page frame number
                unsigned long long Reserved2 : 12;
            } Page4Kb, Page2Mb, Generic; // Same for the 4Kb and 2Mb page size
        } Pae;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long Reserved0 : 1;
            unsigned long long PS : 1; // PageSize
            unsigned long long Reserved1 : 1;
            unsigned long long AVL : 3; // Available to software
            unsigned long long Reserved3 : 51;
            unsigned long long NX : 1; // No Execute
        } Generic;
        union {
            struct {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long Ignored0 : 1;
                unsigned long long PS : 1; // PageSize == 0
                unsigned long long Reserved0 : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long PD : 40; // Page frame number
                unsigned long long Available : 11;
                unsigned long long NX : 1; // No Execute
            } Page4Kb, Page2Mb, Generic;
        } NonPageSize; // PDPE.PS == 0
        union {
            struct {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long D : 1; // Dirty
                unsigned long long PS : 1; // PageSize == 1
                unsigned long long G : 1; // Global Page
                unsigned long long AVL : 3; // Available to software
                unsigned long long PAT : 1; // Page-Attribute Table
                unsigned long long Reserved0 : 17;
                unsigned long long PhysicalPageFrameNumber : 22;
                unsigned long long Available : 11;
                unsigned long long NX : 1; // No Execute
            } Page1Gb;
        } PageSize; // PDPE.PS == 1
    } x64;
};

union PDE {
    union {
        union {
            unsigned int Value;
            struct {
                unsigned int P : 1; // Present
                unsigned int RW : 1; // Read/Write
                unsigned int US : 1; // User/Supervisor
                unsigned int PWT : 1; // Page-Level Writethrough
                unsigned int PCD : 1; // Page-Level Cache Disable
                unsigned int A : 1; // Accessed
                unsigned int Reserved0 : 1;
                unsigned int PS : 1; // PageSize bit
                unsigned int Reserved1 : 1;
                unsigned int AVL : 3; // Available to software
                unsigned int Reserved2 : 20;
            } Generic;
            struct {
                unsigned int P : 1; // Present
                unsigned int RW : 1; // Read/Write
                unsigned int US : 1; // User/Supervisor
                unsigned int PWT : 1; // Page-Level Writethrough
                unsigned int PCD : 1; // Page-Level Cache Disable
                unsigned int A : 1; // Accessed
                unsigned int Ignored0 : 1;
                unsigned int PS : 1; // PageSize == 0
                unsigned int Ignored1 : 1;
                unsigned int AVL : 3; // Available to software
                unsigned int PT : 20; // Page frame number
            } Page4Kb;
            struct {
                unsigned int P : 1; // Present
                unsigned int RW : 1; // Read/Write
                unsigned int US : 1; // User/Supervisor
                unsigned int PWT : 1; // Page-Level Writethrough
                unsigned int PCD : 1; // Page-Level Cache Disable
                unsigned int A : 1; // Accessed
                unsigned int D : 1; // Dirty
                unsigned int PS : 1; // PageSize == 1
                unsigned int G : 1; // Global Page
                unsigned int AVL : 3; // Available to software
                unsigned int PAT : 1; // Page-Attribute Table
                unsigned int PhysicalPageFrameNumberHigh : 8;
                unsigned int Reserved0 : 1;
                unsigned int PhysicalPageFrameNumberLow : 10;
            } Page4Mb;
        } NonPae;
        union {
            unsigned long long Value;
            struct {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long Reserved0 : 1;
                unsigned long long PS : 1; // PageSize
                unsigned long long Reserved1 : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long Reserved2 : 51;
                unsigned long long NX : 1; // No Execute
            } Generic;
            struct {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long Ignored0 : 1;
                unsigned long long PS : 1; // PageSize == 0
                unsigned long long Ignored1 : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long PT : 40;
                unsigned long long Reserved0 : 11;
                unsigned long long NX : 1; // No Execute
            } Page4Kb;
            struct {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long D : 1; // Dirty
                unsigned long long PS : 1; // PageSize == 1
                unsigned long long G : 1; // Global Page
                unsigned long long AVL : 3; // Available to software
                unsigned long long PAT : 1; // Page-Attribute Table
                unsigned long long Reserved0 : 8;
                unsigned long long PhysicalPageFrameNumber : 31;
                unsigned long long Reserved1 : 11;
                unsigned long long NX : 1; // No Execute
            } Page2Mb;
        } Pae;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long Reserved0 : 1;
            unsigned long long PS : 1; // PageSize
            unsigned long long Reserved1 : 1;
            unsigned long long AVL : 3; // Available to software
            unsigned long long Reserved2 : 51;
            unsigned long long NX : 1; // No Execute
        } Generic;
        struct {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long Ignored0 : 1;
            unsigned long long PS : 1; // PageSize == 0
            unsigned long long Ignored1 : 1;
            unsigned long long AVL : 3; // Available to software
            unsigned long long PT : 40; // Page frame number
            unsigned long long Available : 11;
            unsigned long long NX : 1; // No Execute
        } Page4Kb;
        struct {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long D : 1; // Dirty
            unsigned long long PS : 1; // PageSize == 1
            unsigned long long G : 1; // Global Page
            unsigned long long AVL : 3; // Available to software
            unsigned long long PAT : 1; // Page-Attribute Table
            unsigned long long Reserved0 : 8;
            unsigned long long PhysicalPageFrameNumber : 31;
            unsigned long long Available : 11;
            unsigned long long NX : 1; // No Execute
        } Page2Mb;
    } x64;
};

union PTE {
    union {
        union {
            unsigned int Value;
            struct {
                unsigned int P : 1; // Present
                unsigned int RW : 1; // Read/Write
                unsigned int US : 1; // User/Supervisor
                unsigned int PWT : 1; // Page-Level Writethrough
                unsigned int PCD : 1; // Page-Level Cache Disable
                unsigned int A : 1; // Accessed
                unsigned int D : 1; // Dirty
                unsigned int PAT : 1; // Page-Attribute Table
                unsigned int G : 1; // Global Page
                unsigned int AVL : 3; // Available to software
                unsigned int PhysicalPageFrameNumber : 20;
            } Page4Kb;
        } NonPae;
        union {
            unsigned long long Value;
            struct {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long D : 1; // Dirty
                unsigned long long PAT : 1; // Page-Attribute Table
                unsigned long long G : 1; // Global Page
                unsigned long long AVL : 3; // Available to software
                unsigned long long PhysicalPageFrameNumber : 40;
                unsigned long long Reserved0 : 11;
                unsigned long long NX : 1; // No Execute
            } Page4Kb;
        } Pae;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long D : 1; // Dirty
            unsigned long long PAT : 1; // Page-Attribute Table
            unsigned long long G : 1; // Global Page
            unsigned long long AVL : 3; // Available to software
            unsigned long long PhysicalPageFrameNumber : 40;
            unsigned long long Available : 11;
            unsigned long long NX : 1; // No Execute
        } Page4Kb;
    } x64;
};
#pragma pack(pop)

```

`CommonTypes/Registers.h`:

```h
#pragma once

/*
    Registers CR1, CR5..CR7, CR9..CR15, DR8..DR15 aren't implemented.
    Any attempt to access unimplemented registers results in an invalid-opcode exception (#UD).
*/

#pragma pack(push, 1)
union EFLAGS {
    unsigned int Value;
    struct {
        unsigned int CF : 1; // Carry flag
        unsigned int MustBe1Bit1 : 1;
        unsigned int PF : 1; // Parity flag
        unsigned int MustBe0Bit3 : 1;
        unsigned int AF : 1; // Auxiliary carry flag
        unsigned int MustBe0Bit5 : 1;
        unsigned int ZF : 1; // Zero flag
        unsigned int SF : 1; // Sign flag
        unsigned int TF : 1; // Trap flag
        unsigned int IF : 1; // Interrupt enable flag
        unsigned int DF : 1; // Direction flag
        unsigned int OF : 1; // Overflow flag
        unsigned int IOPL : 2; // Input-output privilege level
        unsigned int NT : 1; // Nested task
        unsigned int MustBe0Bit15 : 1;
        unsigned int RF : 1; // Resume flag
        unsigned int VM : 1; // Virtual-8086 mode
        unsigned int AC : 1; // Alignment-check / access control
        unsigned int VIF : 1; // Virtual interrupt flag
        unsigned int VIP : 1; // Virtual interrupt pending
        unsigned int ID : 1; // ID flag
        unsigned int MustBe0Bit22 : 1;
        unsigned int MustBe0Bit23 : 1;
        unsigned int MustBe0Bit24 : 1;
        unsigned int MustBe0Bit25 : 1;
        unsigned int MustBe0Bit26 : 1;
        unsigned int MustBe0Bit27 : 1;
        unsigned int MustBe0Bit28 : 1;
        unsigned int MustBe0Bit29 : 1;
        unsigned int MustBe0Bit30 : 1;
        unsigned int MustBe0Bit31 : 1;
    } Bitmap;
};

union RFLAGS {
    unsigned long long Value;
    struct {
        EFLAGS Eflags;
        unsigned int Reserved;
    } Bitmap;
};

union CR0 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int PE : 1; // Protection enabled
            unsigned int MP : 1; // Monitor coprocessor
            unsigned int EM : 1; // Emulation of 8087
            unsigned int TS : 1; // Task switched
            unsigned int ET : 1; // Extension type (readonly)
            unsigned int NE : 1; // Numeric error
            unsigned int Reserved0 : 10;
            unsigned int WP : 1; // Write protect
            unsigned int Reserved1 : 1;
            unsigned int AM : 1; // Alignment mask
            unsigned int Reserved3 : 10;
            unsigned int NW : 1; // Not writethrough
            unsigned int CD : 1; // Cache disable
            unsigned int PG : 1; // Paging
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long PE : 1; // Protection enabled
            unsigned long long MP : 1; // Monitor coprocessor
            unsigned long long EM : 1; // Emulation of 8087
            unsigned long long TS : 1; // Task switched
            unsigned long long ET : 1; // Extension type (readonly)
            unsigned long long NE : 1; // Numeric error
            unsigned long long Reserved0 : 10;
            unsigned long long WP : 1; // Write protect
            unsigned long long Reserved1 : 1;
            unsigned long long AM : 1; // Alignment mask
            unsigned long long Reserved3 : 10;
            unsigned long long NW : 1; // Not writethrough
            unsigned long long CD : 1; // Cache disable
            unsigned long long PG : 1; // Paging
            unsigned long long Reserved4 : 32;
        } Bitmap;
    } x64;
};

union CR2 {
    unsigned long long Value;
    struct {
        unsigned int PageFaultLinearAddress;
    } x32;
    struct {
        unsigned long long PageFaultLinearAddress;
    } x64;
};

union CR3 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int Reserved0 : 3;
            unsigned int PWT : 1; // Write through
            unsigned int PCD : 1; // Cache disable
            unsigned int Reserved1 : 7;
            unsigned int PD : 20; // Page Directory table base address
        } NonPae;
        struct {
            unsigned int Reserved0 : 3;
            unsigned int PWT : 1; // Write through
            unsigned int PCD : 1; // Cache disable
            unsigned int PDP : 27; // Page Directory Pointer table base address
        } Pae;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long Reserved0 : 3;
            unsigned long long PWT : 1; // Write through
            unsigned long long PCD : 1; // Cache disable
            unsigned long long Reserved1 : 7;
            unsigned long long PML4 : 40; // PML4 table base address
            unsigned long long Reserved2 : 12;
        } Bitmap;
    } x64;
};

union CR4 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int VME : 1; // Virtual 8086-mode extensions
            unsigned int PVI : 1; // Protected-mode virtual interrupts
            unsigned int TSD : 1; // Timestamp disable
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extensions
            unsigned int PAE : 1; // Physical address extension
            unsigned int MCE : 1; // Machine check enable
            unsigned int PGE : 1; // Page global enable
            unsigned int PCE : 1; // Performance-monitoring counter enable
            unsigned int OSFXSR : 1; // Operating system FXSAVE/FXSTOR support
            unsigned int OSXMMEXCPT : 1; // Operating system unmasked exception support
            unsigned int UMIP : 1; // Usermode instruction prevention
            unsigned int Reserved0 : 1;
            unsigned int VMXE : 1; // VMX-enable bit (Intel only)
            unsigned int SMXE : 1; // SMX-enable bit (Safer Mode Extensions, Intel only)
            unsigned int Reserved1 : 1;
            unsigned int FSGSBASE : 1; // Enable RDFSBASE, RDGSBASE, WRFSBASE and WRGSBASE instructions
            unsigned int PCIDE : 1; // PCID-enable bit (Process-Context Identifiers, Intel only)
            unsigned int OSXSAVE : 1; // XSAVE and Processor Extended States Enable bit
            unsigned int Reserved2 : 1;
            unsigned int SMEP : 1; // Supervisor mode execution prevention
            unsigned int SMAP : 1; // Supervisor mode access prevention
            unsigned int PKE : 1; // Protection key enable (Intel only)
            unsigned int Reserved3 : 9;
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long VME : 1; // Virtual 8086-mode extensions
            unsigned long long PVI : 1; // Protected-mode virtual interrupts
            unsigned long long TSD : 1; // Timestamp disable
            unsigned long long DE : 1; // Debugging extensions
            unsigned long long PSE : 1; // Page size extensions
            unsigned long long PAE : 1; // Physical address extension
            unsigned long long MCE : 1; // Machine check enable
            unsigned long long PGE : 1; // Page global enable
            unsigned long long PCE : 1; // Performance-monitoring counter enable
            unsigned long long OSFXSR : 1; // Operating system FXSAVE/FXSTOR support
            unsigned long long OSXMMEXCPT : 1; // Operating system unmasked exception support
            unsigned long long UMIP : 1; // Usermode instruction prevention
            unsigned long long Reserved0 : 1;
            unsigned long long VMXE : 1; // VMX-enable bit (Intel only)
            unsigned long long SMXE : 1; // SMX-enable bit (Safer Mode Extensions, Intel only)
            unsigned long long Reserved1 : 1;
            unsigned long long FSGSBASE : 1; // Enable RDFSBASE, RDGSBASE, WRFSBASE and WRGSBASE instructions
            unsigned long long PCIDE : 1; // PCID-enable bit (Process-Context Identifiers, Intel only)
            unsigned long long OSXSAVE : 1; // XSAVE and Processor Extended States Enable bit
            unsigned long long Reserved2 : 1;
            unsigned long long SMEP : 1; // Supervisor mode execution prevention
            unsigned long long SMAP : 1; // Supervisor mode access prevention
            unsigned long long PKE : 1; // Protection key enable (Intel only)
            unsigned long long Reserved3 : 41;
        } Bitmap;
    } x64;
};

union CR8 { // Task priority register:
    unsigned long long Reserved;
    struct {
        unsigned long long TPR : 4; // Priority
        unsigned long long Reserved : 60;
    } x64;
};



union DR0 {
    unsigned long long Breakpoint0LinearAddress;
    struct {
        unsigned int Breakpoint0LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint0LinearAddress;
    } x64;
};

union DR1 {
    unsigned long long Breakpoint1LinearAddress;
    struct {
        unsigned int Breakpoint1LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint1LinearAddress;
    } x64;
};

union DR2 {
    unsigned long long Breakpoint2LinearAddress;
    struct {
        unsigned int Breakpoint2LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint2LinearAddress;
    } x64;
};

union DR3 {
    unsigned long long Breakpoint3LinearAddress;
    struct {
        unsigned int Breakpoint3LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint3LinearAddress;
    } x64;
};

union DR4 { // Aliased to the DR6
    unsigned long long Reserved;
};

union DR5 { // Aliased to the DR7
    unsigned long long Reserved;
};

union DR6 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int B0 : 1; // Breakpoint #0 condition detected
            unsigned int B1 : 1; // Breakpoint #1 condition detected
            unsigned int B2 : 1; // Breakpoint #2 condition detected
            unsigned int B3 : 1; // Breakpoint #3 condition detected
            unsigned int FilledByOnes0 : 8; // Must be 0xFF (8 bits of ones: 0b1111_1111)
            unsigned int ReservedByZero : 1;
            unsigned int BD : 1; // Debug register access detected
            unsigned int BS : 1; // Single step
            unsigned int BT : 1; // Task switch
            unsigned int RTM : 1; // Intel only, must be 1 on AMD platforms
            unsigned int FilledByOnes1 : 15; // Must be 0x7FFF (15 bits of ones: 0b111_1111_1111_1111)
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long B0 : 1; // Breakpoint #0 condition detected
            unsigned long long B1 : 1; // Breakpoint #1 condition detected
            unsigned long long B2 : 1; // Breakpoint #2 condition detected
            unsigned long long B3 : 1; // Breakpoint #3 condition detected
            unsigned long long FilledByOnes0 : 8; // Must be 0xFF (8 bits of ones: 0b1111_1111)
            unsigned long long ReservedByZero : 1;
            unsigned long long BD : 1; // Debug register access detected
            unsigned long long BS : 1; // Single step
            unsigned long long BT : 1; // Task switch
            unsigned long long RTM : 1; // Intel only, must be 1 on AMD platforms
            unsigned long long FilledByOnes1 : 15; // Must be 0x7FFF (15 bits of ones: 0b111_1111_1111_1111)
            unsigned long long MustBeZero : 32;
        } Bitmap;
    } x64;
};

union DR7 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int L0 : 1; // Local  exact breakpoint #0 enabled
            unsigned int G0 : 1; // Global exact breakpoint #0 enabled
            unsigned int L1 : 1; // Local  exact breakpoint #1 enabled
            unsigned int G1 : 1; // Global exact breakpoint #1 enabled
            unsigned int L2 : 1; // Local  exact breakpoint #2 enabled
            unsigned int G2 : 1; // Global exact breakpoint #2 enabled
            unsigned int L3 : 1; // Local  exact breakpoint #3 enabled
            unsigned int G3 : 1; // Global exact breakpoint #3 enabled
            unsigned int LE : 1; // Local  exact breakpoint enabled
            unsigned int GE : 1; // Global exact breakpoint enabled
            unsigned int ReservedAsOne : 1;
            unsigned int RTM : 1; // Intel only, must be zero on AMD platforms
            unsigned int ReservedAsZero0 : 1;
            unsigned int GD : 1; // General detect enabled
            unsigned int ReservedAsZero1 : 2;
            unsigned int RW0 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN0 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned int RW1 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN1 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned int RW2 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN2 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned int RW3 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN3 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long L0 : 1; // Local  exact breakpoint #0 enabled
            unsigned long long G0 : 1; // Global exact breakpoint #0 enabled
            unsigned long long L1 : 1; // Local  exact breakpoint #1 enabled
            unsigned long long G1 : 1; // Global exact breakpoint #1 enabled
            unsigned long long L2 : 1; // Local  exact breakpoint #2 enabled
            unsigned long long G2 : 1; // Global exact breakpoint #2 enabled
            unsigned long long L3 : 1; // Local  exact breakpoint #3 enabled
            unsigned long long G3 : 1; // Global exact breakpoint #3 enabled
            unsigned long long LE : 1; // Local  exact breakpoint enabled
            unsigned long long GE : 1; // Global exact breakpoint enabled
            unsigned long long ReservedAsOne : 1;
            unsigned long long RTM : 1; // Intel only, must be zero on AMD platforms
            unsigned long long ReservedAsZero0 : 1;
            unsigned long long GD : 1; // General detect enabled
            unsigned long long ReservedAsZero1 : 2;
            unsigned long long RW0 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN0 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long RW1 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN1 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long RW2 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN2 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long RW3 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN3 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long ReservedAsZero2 : 32;
        } Bitmap;
    } x64;
};
#pragma pack(pop)
```

`CommonTypes/SVM.h`:

```h
#pragma once

namespace SVM
{
    struct VMCB_CONTROL_AREA {
        union {
            unsigned int Value;
            struct {
                union {
                    unsigned short Value; // Interception of CR0..CR15 reads
                    struct {
                        unsigned short ReadCr0 : 1;
                        unsigned short ReadCr1 : 1;
                        unsigned short ReadCr2 : 1;
                        unsigned short ReadCr3 : 1;
                        unsigned short ReadCr4 : 1;
                        unsigned short ReadCr5 : 1;
                        unsigned short ReadCr6 : 1;
                        unsigned short ReadCr7 : 1;
                        unsigned short ReadCr8 : 1;
                        unsigned short ReadCr9 : 1;
                        unsigned short ReadCr10 : 1;
                        unsigned short ReadCr11 : 1;
                        unsigned short ReadCr12 : 1;
                        unsigned short ReadCr13 : 1;
                        unsigned short ReadCr14 : 1;
                        unsigned short ReadCr15 : 1;
                    } Bitmap;
                } Read;
                union {
                    unsigned short Value; // Interception of CR0..CR15 writes
                    struct {
                        unsigned short WriteCr0 : 1;
                        unsigned short WriteCr1 : 1;
                        unsigned short WriteCr2 : 1;
                        unsigned short WriteCr3 : 1;
                        unsigned short WriteCr4 : 1;
                        unsigned short WriteCr5 : 1;
                        unsigned short WriteCr6 : 1;
                        unsigned short WriteCr7 : 1;
                        unsigned short WriteCr8 : 1;
                        unsigned short WriteCr9 : 1;
                        unsigned short WriteCr10 : 1;
                        unsigned short WriteCr11 : 1;
                        unsigned short WriteCr12 : 1;
                        unsigned short WriteCr13 : 1;
                        unsigned short WriteCr14 : 1;
                        unsigned short WriteCr15 : 1;
                    } Bitmap;
                } Write;
            } RW;
        } InterceptCr;
        union {
            unsigned int Value;
            struct {
                union {
                    unsigned short Value; // Interception of CR0..CR15 reads
                    struct {
                        unsigned short ReadDr0 : 1;
                        unsigned short ReadDr1 : 1;
                        unsigned short ReadDr2 : 1;
                        unsigned short ReadDr3 : 1;
                        unsigned short ReadDr4 : 1;
                        unsigned short ReadDr5 : 1;
                        unsigned short ReadDr6 : 1;
                        unsigned short ReadDr7 : 1;
                        unsigned short ReadDr8 : 1;
                        unsigned short ReadDr9 : 1;
                        unsigned short ReadDr10 : 1;
                        unsigned short ReadDr11 : 1;
                        unsigned short ReadDr12 : 1;
                        unsigned short ReadDr13 : 1;
                        unsigned short ReadDr14 : 1;
                        unsigned short ReadDr15 : 1;
                    } Bitmap;
                } Read;
                union {
                    unsigned short Value; // Interception of CR0..CR15 writes
                    struct {
                        unsigned short WriteDr0 : 1;
                        unsigned short WriteDr1 : 1;
                        unsigned short WriteDr2 : 1;
                        unsigned short WriteDr3 : 1;
                        unsigned short WriteDr4 : 1;
                        unsigned short WriteDr5 : 1;
                        unsigned short WriteDr6 : 1;
                        unsigned short WriteDr7 : 1;
                        unsigned short WriteDr8 : 1;
                        unsigned short WriteDr9 : 1;
                        unsigned short WriteDr10 : 1;
                        unsigned short WriteDr11 : 1;
                        unsigned short WriteDr12 : 1;
                        unsigned short WriteDr13 : 1;
                        unsigned short WriteDr14 : 1;
                        unsigned short WriteDr15 : 1;
                    } Bitmap;
                } Write;
            } RW;
        } InterceptDr;
        union {
            unsigned int Value;
            struct {
                unsigned int InterceptionVector0 : 1;
                unsigned int InterceptionVector1 : 1;
                unsigned int InterceptionVector2 : 1;
                unsigned int InterceptionVector3 : 1;
                unsigned int InterceptionVector4 : 1;
                unsigned int InterceptionVector5 : 1;
                unsigned int InterceptionVector6 : 1;
                unsigned int InterceptionVector7 : 1;
                unsigned int InterceptionVector8 : 1;
                unsigned int InterceptionVector9 : 1;
                unsigned int InterceptionVector10 : 1;
                unsigned int InterceptionVector11 : 1;
                unsigned int InterceptionVector12 : 1;
                unsigned int InterceptionVector13 : 1;
                unsigned int InterceptionVector14 : 1;
                unsigned int InterceptionVector15 : 1;
                unsigned int InterceptionVector16 : 1;
                unsigned int InterceptionVector17 : 1;
                unsigned int InterceptionVector18 : 1;
                unsigned int InterceptionVector19 : 1;
                unsigned int InterceptionVector20 : 1;
                unsigned int InterceptionVector21 : 1;
                unsigned int InterceptionVector22 : 1;
                unsigned int InterceptionVector23 : 1;
                unsigned int InterceptionVector24 : 1;
                unsigned int InterceptionVector25 : 1;
                unsigned int InterceptionVector26 : 1;
                unsigned int InterceptionVector27 : 1;
                unsigned int InterceptionVector28 : 1;
                unsigned int InterceptionVector29 : 1;
                unsigned int InterceptionVector30 : 1;
                unsigned int InterceptionVector31 : 1;
            } Bitmap;
        } InterceptExceptions;
        unsigned int InterceptIntr : 1; // Physical maskable interrupt
        unsigned int InterceptNmi : 1;
        unsigned int InterceptSmi : 1;
        unsigned int InterceptInit : 1;
        unsigned int InterceptVirtualIntr : 1; // Virtual maskable interrupt
        unsigned int InterceptCr0WritesOther : 1; // Intercept CR0 writes that change bits other than CR0.TS or CR0.MP
        unsigned int InterceptIdtrRead : 1;
        unsigned int InterceptGdtrRead : 1;
        unsigned int InterceptLdtrRead : 1;
        unsigned int InterceptTrRead : 1;
        unsigned int InterceptIdtrWrite : 1;
        unsigned int InterceptGdtrWrite : 1;
        unsigned int InterceptLdtrWrite : 1;
        unsigned int InterceptTrWrite : 1;
        unsigned int InterceptRdtsc : 1;
        unsigned int InterceptRdpmc : 1;
        unsigned int InterceptPushf : 1;
        unsigned int InterceptPopf : 1;
        unsigned int InterceptCpuid : 1;
        unsigned int InterceptRsm : 1;
        unsigned int InterceptIret : 1;
        unsigned int InterceptInt : 1; // Intercept Int N instruction
        unsigned int InterceptInvd : 1;
        unsigned int InterceptPause : 1;
        unsigned int InterceptHlt : 1;
        unsigned int InterceptInvlpg : 1;
        unsigned int InterceptInvlpga : 1;
        unsigned int InterceptIoIo : 1; // Intercept IN and OUT accesses to selected ports
        unsigned int InterceptMsr : 1; // Intercept RDMSR and WRMSR accesses to selected MSRs
        unsigned int InterceptTaskSwitched : 1;
        unsigned int InterceptFerrFreeze : 1; // Intercept processor "freezing" during legacy FERR handling
        unsigned int InterceptShutdown : 1; // Intercept shutdown events
        unsigned short InterceptVmrun : 1;
        unsigned short InterceptVmcall : 1;
        unsigned short InterceptVmload : 1;
        unsigned short InterceptVmsave : 1;
        unsigned short InterceptStgi : 1;
        unsigned short InterceptClgi : 1;
        unsigned short InterceptSkinit : 1;
        unsigned short InterceptRdtscp : 1;
        unsigned short InterceptIcebp : 1;
        unsigned short InterceptWbinvd : 1;
        unsigned short InterceptMonitor : 1;
        unsigned short InterceptMwaitUnconditionally : 1; // Intercept MWAIT instruction unconditionally
        unsigned short InterceptMwaitIfMonitorHwIsArmed : 1; // Intercept MWAIT instruction if monitor hardware is armed
        unsigned short InterceptXsetbv : 1;
        unsigned short Reserved0 : 1; // Should be zero
        unsigned short InterceptEferWrite : 1; // Occures after guest instruction finishes
        union {
            unsigned short Value;
            struct {
                unsigned short InterceptCr0WriteAfter : 1;
                unsigned short InterceptCr1WriteAfter : 1;
                unsigned short InterceptCr2WriteAfter : 1;
                unsigned short InterceptCr3WriteAfter : 1;
                unsigned short InterceptCr4WriteAfter : 1;
                unsigned short InterceptCr5WriteAfter : 1;
                unsigned short InterceptCr6WriteAfter : 1;
                unsigned short InterceptCr7WriteAfter : 1;
                unsigned short InterceptCr8WriteAfter : 1;
                unsigned short InterceptCr9WriteAfter : 1;
                unsigned short InterceptCr10WriteAfter : 1;
                unsigned short InterceptCr11WriteAfter : 1;
                unsigned short InterceptCr12WriteAfter : 1;
                unsigned short InterceptCr13WriteAfter : 1;
                unsigned short InterceptCr14WriteAfter : 1;
                unsigned short InterceptCr15WriteAfter : 1;
            } Bitmap;
        } InterceptCrWritesAfter; // Occures after guest instruction finishes
        unsigned char Reserved1[40]; // Should be zero
        unsigned short PauseFilterThreshold;
        unsigned short PauseFilterCount;
        unsigned long long IopmBasePa; // Physical base address of IOPM,  bits 11:0 are ignored
        unsigned long long MsrpmBasePa; // Physical base address of MSRPM, bits 11:0 are ignored
        unsigned long long TscOffset; // To be added in RDTSC and RDTSCP
        unsigned int GuestAsid;
        union {
            unsigned int Value;
            struct {
                unsigned int TlbControl : 8; // 0x00 - Do nothing
                                             // 0x01 - Flush entire TLB (all entries, all ASIDs) on VMRUN (for legacy hypervisors)
                                             // 0x03 - Flush the guest's TLB entries
                                             // 0x07 - Flush the guest's non-global TLB entries
                                             // All other encodings are reserved
                unsigned int Reserved2 : 24;
            } Bitmap;
        } TlbControl;
        union {
            unsigned long long Value;
            struct {
                unsigned long long VirtualTpr : 8; // Virtual TPR for the guest (3:0 = 4-bit virtual TPR value, 7:4 should be zero), written back to the VMCB at #VMEXIT
                unsigned long long VirtualIrq : 1; // If nonzero, virtual INTR is pending, ignored on VMRUN if AVIC is enabled, written back to the VMCB at #VMEXIT
                unsigned long long VirtualGif : 1; // 0 - virtual interrupts are masked, 1 - unmasked
                unsigned long long Reserved0 : 6;
                unsigned long long VirtualIntrPriority : 4; // Priority for virtual interrupt, ignored on VMRUN if AVIC is enabled
                unsigned long long VirtualIgnoreTpr : 1; // If nonzero, the current virtual interrupt ignores (virtual) TPR, ignored on VMRUN if AVIC is enabled
                unsigned long long Reserved1 : 3;
                unsigned long long VirtualIntrMasking : 1; // Virtualize masking of INTR interrupts
                unsigned long long VirtualGifEnabled : 1; // 0 - Disabled, 1 - Enabled for this guest
                unsigned long long Reserved2 : 5;
                unsigned long long AvicEnable : 1;
                unsigned long long VirtualIntrVector : 8; // Vector to use for this interrupt, ignored on VMRUN if AVIC is enabled
                unsigned long long Reserved3 : 24;
            } Bitmap;
        } VirtualIntr;
        union {
            unsigned long long Value;
            struct {
                unsigned long long InterruptShadow : 1; // Guest is in an interrupt shadow
                unsigned long long GuestInterruptMask : 1; // Value of the RFLAGS.IF for the guest, written back to the VMCB at #VMEXIT, not used on VMRUN
                unsigned long long Reserved : 62;
            } Bitmap;
        } InterruptShadow;
        unsigned long long ExitCode;
        unsigned long long ExitInfo1;
        unsigned long long ExitInfo2;
        unsigned long long ExitIntInfo;
        unsigned long long NpEnable : 1; // Nested paging
        unsigned long long EnableSev : 1; // Secure Encrypted Virtualization
        unsigned long long EnabledEncryptedState : 1; // Enable encrypted state for SEV
        unsigned long long Reserved2 : 61; // Should be zero
        unsigned long long AvicApicBar : 52; // Address must be 4-Kbyte aligned
        unsigned long long Reserved3 : 12;
        unsigned long long GuestGhcbPa; // Guest physical address of GHCB
        unsigned long long EventInjection;
        unsigned long long NestedPageTableCr3; // Nested page table CR3 to use for nested paging
        unsigned long long LbrVirtualizationEnable : 1; // 0 - Do nothing, 1 - Enable LBR virtualization hardware acceleration
        unsigned long long VirtualizedVmsaveVmload : 1;
        unsigned long long Reserved4 : 62;
        unsigned long long VmcbCleanBits : 32;
        unsigned long long Reserved5 : 32;
        unsigned long long NextRip; // Next sequential instruction pointer
        unsigned char NumberOfBytesFetched;
        unsigned char GuestInstructionBytes[15];
        unsigned long long AvicApicBackingPageAddr : 52; // Must be 4-Kbyte aligned
        unsigned long long Reserved6 : 12;
        unsigned long long Reserved7;
        union {
            unsigned long long Value;
            struct {
                unsigned long long AvicLogicalMaxIndex : 8;
                unsigned long long Reserved0 : 4;
                unsigned long long AvicLogicalTableAddr : 40; // Must be 4-Kbyte aligned
                unsigned long long Reserved1 : 12;
            } Bitmap;
        } AvicLogicalTable;
        union {
            unsigned long long Value;
            struct {
                unsigned long long AvicPhysicalMaxIndex : 8;
                unsigned long long Reserved0 : 4;
                unsigned long long AvicPhysicalTableAddr : 40; // Must be 4-Kbyte aligned
                unsigned long long Reserved1 : 12;
            } Bitmap;
        } AvicPhysicalTable;
        unsigned long long Reserved8;
        unsigned long long Reserved9 : 12;
        unsigned long long VmcbSaveStatePointer : 40;
        unsigned long long Reserved10 : 12;
        unsigned char Reserved11[752]; // Final padding to 0x400 size
    };

    struct VMCB_STATE_SAVE_AREA {
        union VMCB_SEGMENT_ATTRIBUTE {
            unsigned short Value;
            struct {
                unsigned short Type : 4;
                unsigned short System : 1;
                unsigned short Dpl : 2;
                unsigned short Present : 1;
                unsigned short Available : 1;
                unsigned short LongMode : 1;
                unsigned short DefaultOperandSize : 1;
                unsigned short Granularity : 1;
                unsigned short Reserved : 4;
            } Bitmap;
        };
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base; // Only lower 32 bits are implemented
        } Es;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base; // Only lower 32 bits are implemented
        } Cs;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base; // Only lower 32 bits are implemented
        } Ss;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base; // Only lower 32 bits are implemented
        } Ds;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base;
        } Fs;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base;
        } Gs;
        struct {
            unsigned short Selector; // Reserved
            VMCB_SEGMENT_ATTRIBUTE Attrib; // Reserved
            unsigned int Limit; // Only lower 16 bits are implemented
            unsigned long long Base;
        } Gdtr;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base;
        } Ldtr;
        struct {
            unsigned short Selector; // Reserved
            VMCB_SEGMENT_ATTRIBUTE Attrib; // Reserved
            unsigned int Limit; // Only lower 16 bits are implemented
            unsigned long long Base;
        } Idtr;
        struct {
            unsigned short Selector;
            VMCB_SEGMENT_ATTRIBUTE Attrib;
            unsigned int Limit;
            unsigned long long Base;
        } Tr;
        unsigned char Reserved0[43];
        unsigned char Cpl; // If the guest is in real-mode, CPL forced to 0, if the guest in virtual-mode, CPL forced to 3
        unsigned int Reserved1;
        unsigned long long Efer;
        unsigned char Reserved2[112];
        unsigned long long Cr4;
        unsigned long long Cr3;
        unsigned long long Cr0;
        unsigned long long Dr7;
        unsigned long long Dr6;
        unsigned long long Rflags;
        unsigned long long Rip;
        unsigned char Reserved3[88];
        unsigned long long Rsp;
        unsigned char Reserved4[24];
        unsigned long long Rax;
        unsigned long long Star;
        unsigned long long Lstar;
        unsigned long long Cstar;
        unsigned long long Sfmask;
        unsigned long long KernelGsBase;
        unsigned long long SysenterCs;
        unsigned long long SysenterEsp;
        unsigned long long SysenterEip;
        unsigned long long Cr2;
        unsigned char Reserved5[32];
        unsigned long long GuestPat;     // Guest PAT - only used if nested paging enabled
        unsigned long long DbgCtl;       // Guest debug ctl MSR - only used if HW acceleration is enabled by VMCB.LBR_VIRTUALIZATION_ENABLE
        unsigned long long BrFrom;       // Guest LastBranchFromIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
        unsigned long long BrTo;         // Guest LastBranchToIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
        unsigned long long LastExcpFrom; // Guest LastIntFromIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
        unsigned long long LastExcpTo;   // Guest LastIntToIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
    };

    struct VMCB {
        VMCB_CONTROL_AREA ControlArea;
        VMCB_STATE_SAVE_AREA StateSaveArea;
        unsigned char Reserved[0x1000 - sizeof(VMCB_CONTROL_AREA) - sizeof(VMCB_STATE_SAVE_AREA)];
    };
    static_assert(sizeof(VMCB_CONTROL_AREA) == 0x400, "Size of VMCB Control Area != 0x400 bytes");
    static_assert(sizeof(VMCB_STATE_SAVE_AREA) == 0x298, "Size of VMCB State Save Area != 0x298 bytes");
    static_assert(sizeof(VMCB) == 0x1000, "Size of VMCB != 0x1000 bytes");

    union EVENTINJ {
        unsigned long long Value;
        struct {
            unsigned long long Vector : 8; // IDT vector of the interrupt/exception (ignored if Type == 2)
            unsigned long long Type : 2; // 0 = External/virtual interrupt (INTR), 2 = NMI, 3 = Exception (fault/trap), 4 = Software interrupt (INTn instruction)
            unsigned long long ErrorCodeValid : 1; // 1 - Exception should push an error code onto the stack
            unsigned long long Reserved : 19;
            unsigned long long Valid : 1; // 1 - Event is to be injected into the guest
            unsigned long long ErrorCode : 32; // This error code will be pushed onto the stack if the ErrorCodeValid == 1
        } Bitmap;
    };
    static_assert(sizeof(EVENTINJ) == sizeof(unsigned long long), "Size of EVEINTINJ != sizeof(unsigned long long)");

    // 2 bits per MSR:
    union MSRPM {
        unsigned char Msrpm[2048 * 4];
        struct {
            unsigned char Msrpm0[2048]; // 0000_0000 to 0000_1FFF
            unsigned char Msrpm1[2048]; // C000_0000 to C000_1FFF
            unsigned char Msrpm2[2048]; // C001_0000 to C001_1FFF
            unsigned char Msrpm3[2048]; // Reserved
        } Vectors;
    };
    static_assert(sizeof(MSRPM) == 8192, "Size of MSRPM != 8192 bytes");

    enum SVM_EXIT_CODE {
        VMEXIT_INVALID = -1,
        VMEXIT_CR0_READ,
        VMEXIT_CR1_READ,
        VMEXIT_CR2_READ,
        VMEXIT_CR3_READ,
        VMEXIT_CR4_READ,
        VMEXIT_CR5_READ,
        VMEXIT_CR6_READ,
        VMEXIT_CR7_READ,
        VMEXIT_CR8_READ,
        VMEXIT_CR9_READ,
        VMEXIT_CR10_READ,
        VMEXIT_CR11_READ,
        VMEXIT_CR12_READ,
        VMEXIT_CR13_READ,
        VMEXIT_CR14_READ,
        VMEXIT_CR15_READ,
        VMEXIT_CR0_WRITE,
        VMEXIT_CR1_WRITE,
        VMEXIT_CR2_WRITE,
        VMEXIT_CR3_WRITE,
        VMEXIT_CR4_WRITE,
        VMEXIT_CR5_WRITE,
        VMEXIT_CR6_WRITE,
        VMEXIT_CR7_WRITE,
        VMEXIT_CR8_WRITE,
        VMEXIT_CR9_WRITE,
        VMEXIT_CR10_WRITE,
        VMEXIT_CR11_WRITE,
        VMEXIT_CR12_WRITE,
        VMEXIT_CR13_WRITE,
        VMEXIT_CR14_WRITE,
        VMEXIT_CR15_WRITE,
        VMEXIT_DR0_READ,
        VMEXIT_DR1_READ,
        VMEXIT_DR2_READ,
        VMEXIT_DR3_READ,
        VMEXIT_DR4_READ,
        VMEXIT_DR5_READ,
        VMEXIT_DR6_READ,
        VMEXIT_DR7_READ,
        VMEXIT_DR8_READ,
        VMEXIT_DR9_READ,
        VMEXIT_DR10_READ,
        VMEXIT_DR11_READ,
        VMEXIT_DR12_READ,
        VMEXIT_DR13_READ,
        VMEXIT_DR14_READ,
        VMEXIT_DR15_READ,
        VMEXIT_DR0_WRITE,
        VMEXIT_DR1_WRITE,
        VMEXIT_DR2_WRITE,
        VMEXIT_DR3_WRITE,
        VMEXIT_DR4_WRITE,
        VMEXIT_DR5_WRITE,
        VMEXIT_DR6_WRITE,
        VMEXIT_DR7_WRITE,
        VMEXIT_DR8_WRITE,
        VMEXIT_DR9_WRITE,
        VMEXIT_DR10_WRITE,
        VMEXIT_DR11_WRITE,
        VMEXIT_DR12_WRITE,
        VMEXIT_DR13_WRITE,
        VMEXIT_DR14_WRITE,
        VMEXIT_DR15_WRITE,
        VMEXIT_EXCP0,
        VMEXIT_EXCP1,
        VMEXIT_EXCP2,
        VMEXIT_EXCP3,
        VMEXIT_EXCP4,
        VMEXIT_EXCP5,
        VMEXIT_EXCP6,
        VMEXIT_EXCP7,
        VMEXIT_EXCP8,
        VMEXIT_EXCP9,
        VMEXIT_EXCP10,
        VMEXIT_EXCP11,
        VMEXIT_EXCP12,
        VMEXIT_EXCP13,
        VMEXIT_EXCP14,
        VMEXIT_EXCP15,
        VMEXIT_EXCP16,
        VMEXIT_EXCP17,
        VMEXIT_EXCP18,
        VMEXIT_EXCP19,
        VMEXIT_EXCP20,
        VMEXIT_EXCP21,
        VMEXIT_EXCP22,
        VMEXIT_EXCP23,
        VMEXIT_EXCP24,
        VMEXIT_EXCP25,
        VMEXIT_EXCP26,
        VMEXIT_EXCP27,
        VMEXIT_EXCP28,
        VMEXIT_EXCP29,
        VMEXIT_EXCP30,
        VMEXIT_EXCP31,
        VMEXIT_INTR,
        VMEXIT_NMI,
        VMEXIT_SMI,
        VMEXIT_INIT,
        VMEXIT_VINTR,
        VMEXIT_CR0_SEL_WRITE,
        VMEXIT_IDTR_READ,
        VMEXIT_GDTR_READ,
        VMEXIT_LDTR_READ,
        VMEXIT_TR_READ,
        VMEXIT_IDTR_WRITE,
        VMEXIT_GDTR_WRITE,
        VMEXIT_LDTR_WRITE,
        VMEXIT_TR_WRITE,
        VMEXIT_RDTSC,
        VMEXIT_RDPMC,
        VMEXIT_PUSHF,
        VMEXIT_POPF,
        VMEXIT_CPUID,
        VMEXIT_RSM,
        VMEXIT_IRET,
        VMEXIT_SWINT,
        VMEXIT_INVD,
        VMEXIT_PAUSE,
        VMEXIT_HLT,
        VMEXIT_INVLPG,
        VMEXIT_INVLPGA,
        VMEXIT_IOIO,
        VMEXIT_MSR,
        VMEXIT_TASK_SWITCH,
        VMEXIT_FERR_FREEZE,
        VMEXIT_SHUTDOWN,
        VMEXIT_VMRUN,
        VMEXIT_VMMCALL,
        VMEXIT_VMLOAD,
        VMEXIT_VMSAVE,
        VMEXIT_STGI,
        VMEXIT_CLGI,
        VMEXIT_SKINIT,
        VMEXIT_RDTSCP,
        VMEXIT_ICEBP,
        VMEXIT_WBINVD,
        VMEXIT_MONITOR,
        VMEXIT_MWAIT,
        VMEXIT_MWAIT_CONDITIONAL,
        VMEXIT_XSETBV,
        VMEXIT_EFER_WRITE_TRAP,
        VMEXIT_CR0_WRITE_TRAP,
        VMEXIT_CR1_WRITE_TRAP,
        VMEXIT_CR2_WRITE_TRAP,
        VMEXIT_CR3_WRITE_TRAP,
        VMEXIT_CR4_WRITE_TRAP,
        VMEXIT_CR5_WRITE_TRAP,
        VMEXIT_CR6_WRITE_TRAP,
        VMEXIT_CR7_WRITE_TRAP,
        VMEXIT_CR8_WRITE_TRAP,
        VMEXIT_CR9_WRITE_TRAP,
        VMEXIT_CR10_WRITE_TRAP,
        VMEXIT_CR11_WRITE_TRAP,
        VMEXIT_CR12_WRITE_TRAP,
        VMEXIT_CR13_WRITE_TRAP,
        VMEXIT_CR14_WRITE_TRAP,
        VMEXIT_CR15_WRITE_TRAP,
        VMEXIT_NPF = 0x400,
        AVIC_INCOMPLETE_IPI,
        AVIC_NOACCEL,
        VMEXIT_VMGEXIT
    };
}
```

`CommonTypes/Segmentation.h`:

```h
#pragma once

#pragma pack(push, 1)
// Value of CS, DS, GS, FS, ES, SS, TR registers:
union SEGMENT_SELECTOR {
    unsigned short Value;
    struct {
        unsigned short Rpl : 2; // Requestor privilege level
        unsigned short TableIndicator : 1; // 0 = GDT using, 1 = LDT using
        unsigned short SelectorIndex : 13; // Entry base = Table base + SelectorIndex * sizeof(Table entry)
    } Bitmap;
};
static_assert(sizeof(SEGMENT_SELECTOR) == sizeof(unsigned short), "Size of SEGMENT_SELECTOR != sizeof(unsigned short)");

// Value of the IDTR/GDTR/LDTR registers in the legacy mode:
struct DESCRIPTOR_TABLE_REGISTER_LEGACY {
    unsigned short Limit; // Size of descriptor table in bytes
    unsigned int BaseAddress; // Points to the first entry in a descriptor table
};
static_assert(sizeof(DESCRIPTOR_TABLE_REGISTER_LEGACY) == sizeof(unsigned short) + sizeof(unsigned int), "Size of DESCRIPTOR_TABLE_REGISTER_LEGACY != sizeof(unsigned short) + sizeof(unsigned int)");

// Value of the IDTR/GDTR/LDTR registers in the long mode:
struct DESCRIPTOR_TABLE_REGISTER_LONG {
    unsigned short Limit; // Size of descriptor table in bytes
    unsigned long long BaseAddress; // Points to the first entry in a descriptor table
};
static_assert(sizeof(DESCRIPTOR_TABLE_REGISTER_LONG) == sizeof(unsigned short) + sizeof(unsigned long long), "Size of DESCRIPTOR_TABLE_REGISTER_LONG != sizeof(unsigned short) + sizeof(unsigned long long)");

enum SYSTEM_SEGMENT_DESCRIPTOR_TYPE_LEGACY {
    ssdtReserved0,
    ssdtAvailable16BitTss,
    ssdtLdt,
    ssdtBusy16BitTss,
    ssdt16BitCallGate,
    ssdtTaskGate,
    ssdt16BitInterruptGate,
    ssdt16BitTrapGate,
    ssdtReserved1,
    ssdtAvailable32BitTss,
    ssdtReserved2,
    ssdtBusy32BitTss,
    ssdt32BitCallGate,
    ssdtReserved3,
    ssdt32BitInterruptGate,
    ssdt32BitTrapGate
};

// Legacy:
union SEGMENT_DESCRIPTOR_LEGACY {
    unsigned long long Value;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long BaseAddressLow : 16; // [15:0]
        unsigned long long BaseAddressMiddle : 8; // [23:16]
        unsigned long long Type : 4; // SEGMENT_DESCRIPTOR_TYPE_LEGACY
        unsigned long long System : 1; // 0 = System (LDT, TSS, Gate), 1 = User (Code, Data)
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long Reserved : 1;
        unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
        unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        unsigned long long BaseAddressHigh : 8; // [31:24]
    } Generic;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long BaseAddressLow : 16; // [15:0]
        unsigned long long BaseAddressMiddle : 8; // [23:16]
        unsigned long long Accessed : 1;
        unsigned long long Readable : 1;
        unsigned long long Conforming : 1;
        unsigned long long Type : 1; // Must be 1 (1 = Code, 0 = Data)
        unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long Reserved : 1;
        unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
        unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        unsigned long long BaseAddressHigh : 8; // [31:24]
    } Code;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long BaseAddressLow : 16; // [15:0]
        unsigned long long BaseAddressMiddle : 8; // [23:16]
        unsigned long long Accessed : 1;
        unsigned long long Writeable : 1;
        unsigned long long ExpandDown : 1;
        unsigned long long Type : 1; // Must be 0 (1 = Code, 0 = Data)
        unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long Reserved : 1;
        unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
        unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        unsigned long long BaseAddressHigh : 8; // [31:24]
    } Data;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long BaseAddressLow : 16; // [15:0]
        unsigned long long BaseAddressMiddle : 8; // [23:16]
        unsigned long long Type : 4;
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long Reserved : 2;
        unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        unsigned long long BaseAddressHigh : 8; // [31:24]
    } Ldt, Tss;
};
static_assert(sizeof(SEGMENT_DESCRIPTOR_LEGACY) == sizeof(unsigned long long), "Size of SEGMENT_DESCRIPTOR_LEGACY != sizeof(unsigned long long)");

union GATE_DESCRIPTOR_LEGACY {
    unsigned long long Value;
    struct {
        unsigned long long TargetCodeSegmentOffsetLow : 16; // [15:0]
        unsigned long long TargetCodeSegmentSelector : 16;
        unsigned long long ParameterCount : 5;
        unsigned long long Reserved : 3;
        unsigned long long Type : 4;
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long TargetCodeSegmentOffsetHigh : 16; // [31:16]
    } CallGate;
    struct {
        unsigned long long TargetCodeSegmentOffsetLow : 16; // [15:0]
        unsigned long long TargetCodeSegmentSelector : 16;
        unsigned long long Reserved : 8;
        unsigned long long Type : 4;
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long TargetCodeSegmentOffsetHigh : 16; // [31:16]
    } InterruptGate, TrapGate;
    struct {
        unsigned long long Reserved0 : 16;
        unsigned long long TssSelector : 16;
        unsigned long long Reserved1 : 8;
        unsigned long long Type : 4;
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long Reserved2 : 16;
    } TaskGate;
};
static_assert(sizeof(GATE_DESCRIPTOR_LEGACY) == sizeof(unsigned long long), "Size of GATE_DESCRIPTOR_LEGACY != sizeof(unsigned long long)");

enum SYSTEM_SEGMENT_DESCRIPTOR_TYPE_LONG {
    ssdt64BitLdt = 0x02,
    ssdtAvailable64BitTss = 0x09,
    ssdtBusy64BitTss = 0x0B,
    ssdt64BitCallGate = 0x0C,
    ssdt64BitInterruptGate = 0x0E,
    ssdt64BitTrapGate = 0x0F,
};

// Generic entry in descriptor tables (can be USER_SEGMENT_DESCRIPTOR_LONG (8 bytes) or SYSTEM_SEGMENT_DESCRIPTOR_LONG (16 bytes)):
union SEGMENT_DESCRIPTOR_LONG {
    unsigned long long Value;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long Reserved0 : 24; // Base address low[15:0]+middle[23:16], marked as reserved: USER_*** and SYSTEM_*** addresses lengths are different
        unsigned long long Type : 4; // 1 = Code, 0 = Data
        unsigned long long System : 1; // 0 = System (LDT, TSS, Gate), 1 = User (Code, Data)
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long LongMode : 1; // For the USER_SEGMENT_DESCRIPTOR_LONG::Code only, otherwise is reserved
        unsigned long long Reserved1 : 1;
        unsigned long long Granularity : 1;
        unsigned long long Reserved2 : 8; // Base address high[31:24 or 63:24], marked as reserved: USER_*** and SYSTEM_*** addresses lengths are different
        // ... Here may be additional 8 bytes of SYSTEM_SEGMENT_DESCRIPTOR_LONG if the System field is 0 ...
    } Generic;
};
static_assert(sizeof(SEGMENT_DESCRIPTOR_LONG) == sizeof(unsigned long long), "Size of SEGMENT_DESCRIPTOR_LONG != sizeof(unsigned long long)");

union USER_SEGMENT_DESCRIPTOR_LONG {
    unsigned long long Value;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long BaseAddressLow : 16; // [15:0]
        unsigned long long BaseAddressMiddle : 8; // [23:16]
        unsigned long long Type : 4; // 1 = Code, 0 = Data
        unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long LongMode : 1;
        unsigned long long DefaultOperandSize : 1; // Must be 0 (0 = 64-bit, 1 = Reserved)
        unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        unsigned long long BaseAddressHigh : 8; // [31:24]
    } Generic;
    struct {
        /* COMPAT MODE ONLY */ unsigned long long SegmentLimitLow : 16;
        /* COMPAT MODE ONLY */ unsigned long long BaseAddressLow : 16; // [15:0]
        /* COMPAT MODE ONLY */ unsigned long long BaseAddressMiddle : 8; // [23:16]
        /* COMPAT MODE ONLY */ unsigned long long Accessed : 1;
        /* COMPAT MODE ONLY */ unsigned long long Readable : 1;
        unsigned long long Conforming : 1;
        unsigned long long Type : 1; // Must be 1 (1 = Code, 0 = Data)
        unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        /* COMPAT MODE ONLY */ unsigned long long SegmentLimitHigh : 4;
        /* COMPAT MODE ONLY */ unsigned long long Available : 1;
        unsigned long long LongMode : 1;
        unsigned long long DefaultOperandSize : 1; // Must be 0 (0 = 64-bit, 1 = Reserved)
        /* COMPAT MODE ONLY */ unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        /* COMPAT MODE ONLY */ unsigned long long BaseAddressHigh : 8; // [31:24]
    } Code;
    struct {
        /* COMPAT MODE ONLY */ unsigned long long SegmentLimitLow : 16;
        /* COMPAT MODE ONLY */ unsigned long long BaseAddressLow : 16; // [15:0]
        /* COMPAT MODE ONLY */ unsigned long long BaseAddressMiddle : 8; // [23:16]
        /* COMPAT MODE ONLY */ unsigned long long Accessed : 1;
        /* COMPAT MODE ONLY */ unsigned long long Writeable : 1;
        /* COMPAT MODE ONLY */ unsigned long long ExpandDown : 1;
        /* COMPAT MODE ONLY */ unsigned long long Type : 1; // Must be 0 (1 = Code, 0 = Data)
        /* COMPAT MODE ONLY */ unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        /* COMPAT MODE ONLY */ unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        /* COMPAT MODE ONLY */ unsigned long long SegmentLimitHigh : 4;
        /* COMPAT MODE ONLY */ unsigned long long Available : 1;
        /* COMPAT MODE ONLY */ unsigned long long Reserved : 1;
        /* COMPAT MODE ONLY */ unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
        /* COMPAT MODE ONLY */ unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        /* COMPAT MODE ONLY */ unsigned long long BaseAddressHigh : 8; // [31:24]
    } Data;
};
static_assert(sizeof(USER_SEGMENT_DESCRIPTOR_LONG) == sizeof(unsigned long long), "Size of USER_SEGMENT_DESCRIPTOR_LONG != sizeof(unsigned long long)");

// LDT or TSS:
union SYSTEM_SEGMENT_DESCRIPTOR_LONG {
    struct {
        unsigned long long Low;
        unsigned long long High;
    } Value;
    struct {
        unsigned long long SegmentLimitLow : 16;
        unsigned long long BaseAddressLow : 16; // [15:0]
        unsigned long long BaseAddressMiddle : 8; // [23:16]
        unsigned long long Type : 4; // SEGMENT_DESCRIPTOR_TYPE_LONG
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long SegmentLimitHigh : 4;
        unsigned long long Available : 1;
        unsigned long long Reserved0 : 2;
        unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
        unsigned long long BaseAddressHigh : 8; // [32:24]
        unsigned long long BaseAddressHighest : 32; // [63:32]
        unsigned long long Reserved1 : 8;
        unsigned long long MustBeZero : 5;
        unsigned long long Reserved2 : 19;
    } Bitmap;
};
static_assert(sizeof(SYSTEM_SEGMENT_DESCRIPTOR_LONG) == 2 * sizeof(unsigned long long), "Size of SYSTEM_SEGMENT_DESCRIPTOR_LONG != 2 * sizeof(unsigned long long)");

union GATE_DESCRIPTOR_LONG {
    struct {
        unsigned long long Low;
        unsigned long long High;
    } Value;
    struct {
        unsigned long long TargetOffsetLow : 16; // [15:0]
        unsigned long long TargetSelector : 16;
        unsigned long long Reserved0 : 8;
        unsigned long long Type : 4; // SEGMENT_DESCRIPTOR_TYPE_LONG
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long TargetOffsetMiddle : 16; // [31:16]
        unsigned long long TargetOffsetHigh : 32; // [63:32]
        unsigned long long Reserved1 : 8;
        unsigned long long MustBeZero : 5;
        unsigned long long Reserved2 : 19;
    } CallGate;
    struct {
        unsigned long long TargetOffsetLow : 16; // [15:0]
        unsigned long long TargetSelector : 16;
        unsigned long long InterruptStackTable : 3;
        unsigned long long Reserved0 : 5;
        unsigned long long Type : 4; // SEGMENT_DESCRIPTOR_TYPE_LONG
        unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
        unsigned long long Dpl : 2;
        unsigned long long Present : 1;
        unsigned long long TargetOffsetMiddle : 16; // [31:16]
        unsigned long long TargetOffsetHigh : 32; // [63:32]
        unsigned long long Reserved1 : 32;
    } InterruptGate, TrapGate;
};
static_assert(sizeof(GATE_DESCRIPTOR_LONG) == 2 * sizeof(unsigned long long), "Size of GATE_DESCRIPTOR_LONG != 2 * sizeof(unsigned long long)");

union TSS {
    struct {
        unsigned short Link; // Prior TSS selector
        unsigned short Reserved0;
        unsigned int Esp0;
        unsigned short Ss0;
        unsigned short Reserved1;
        unsigned int Esp1;
        unsigned short Ss1;
        unsigned short Reserved2;
        unsigned int Esp2;
        unsigned short Ss2;
        unsigned short Reserved3;
        unsigned int Cr3;
        unsigned int Eip;
        unsigned int EFlags;
        unsigned int Eax;
        unsigned int Ecx;
        unsigned int Edx;
        unsigned int Ebx;
        unsigned int Esp;
        unsigned int Ebp;
        unsigned int Esi;
        unsigned int Edi;
        unsigned short Es;
        unsigned short Reserved4;
        unsigned short Cs;
        unsigned short Reserved5;
        unsigned short Ss;
        unsigned short Reserved6;
        unsigned short Ds;
        unsigned short Reserved7;
        unsigned short Fs;
        unsigned short Reserved8;
        unsigned short Gs;
        unsigned short Reserved9;
        unsigned short LdtSelector;
        unsigned short Reserved10;
        unsigned short Trap : 1;
        unsigned short Reserved11 : 15;
        unsigned short IopbBaseAddress;
        unsigned int ShadowStackPointer; // Intel platforms only
        // ... Operating system data structure ...
        // Interrupt-redirection bitmap (eight 32-bit locations)
        // IOPB (up to 8 Kbytes)
        // ^ TSS Limit in the SEGMENT_DESCRIPTOR_LEGACY::Tss::SegmentLimit
    } Legacy;
    struct {
        unsigned int Reserved0;
        unsigned int Rsp0Lower;
        unsigned int Rsp0Upper;
        unsigned int Rsp1Lower;
        unsigned int Rsp1Upper;
        unsigned int Rsp2Lower;
        unsigned int Rsp2Upper;
        unsigned long long Reserved1;
        unsigned int Ist1Lower; // Interrupt stack table (lower part)
        unsigned int Ist1Upper; // Interrupt stack table (higher part)
        unsigned int Ist2Lower;
        unsigned int Ist2Upper;
        unsigned int Ist3Lower;
        unsigned int Ist3Upper;
        unsigned int Ist4Lower;
        unsigned int Ist4Upper;
        unsigned int Ist5Lower;
        unsigned int Ist5Upper;
        unsigned int Ist6Lower;
        unsigned int Ist6Upper;
        unsigned int Ist7Lower;
        unsigned int Ist7Upper;
        unsigned long long Reserved2;
        unsigned short Reserved3;
        unsigned short IopbBaseAddress;
        // IOPB (up to 8 Kbytes)
        // ^ TSS Limit in the SEGMENT_DESCRIPTOR_LONG::Tss::SegmentLimit
    } Long;
};
static_assert(sizeof(TSS::Legacy) == 27 * sizeof(unsigned int), "Size of TSS::Legacy != 27 * sizeof(unsigned int)");
static_assert(sizeof(TSS::Long) == 26 * sizeof(unsigned int), "Size of TSS::Long != 26 * sizeof(unsigned int)");
#pragma pack(pop)
```

`CommonTypes/VMX.h`:

```h
#pragma once

namespace VMX
{
    struct VMCS {
        union {
            unsigned int Value;
            struct {
                unsigned int VmcsRevisionId : 31;
                unsigned int ShadowVmcsIndicator : 1;
            } Bitmap;
        } RevisionId;
        unsigned int VmxAbortIndicator;
        unsigned char VmcsData[0x1000 - sizeof(RevisionId) - sizeof(VmxAbortIndicator)];
    };
    static_assert(sizeof(VMCS) == 0x1000, "Size of VMCS != 4096 bytes");

    union VMCS_COMPONENT_ENCODING {
        unsigned int Value;
        struct {
            unsigned int AccessType : 1; // 0 = full, 1 = high; must be full for 16-bit, 32-bit, and natural-width fields
            unsigned int Index : 9;
            unsigned int Type : 2; // 0 = control, 1 = VMexit information, 2 = guest state, 3 = host state
            unsigned int Reserved0 : 1; // Must be zero
            unsigned int Width : 2; // 0 = 16-bit, 1 = 64-bit, 2 = 32-bit, 3 = natural width
            unsigned int Reserved1 : 17; // Must be zero
        } Bitmap;
    };
    static_assert(sizeof(VMCS_COMPONENT_ENCODING) == sizeof(unsigned int), "Size of VMCS_COMPONENT_ENCODING != sizeof(unsigned int)");

    enum VMCS_FIELD_ENCODING : decltype(VMCS_COMPONENT_ENCODING::Value) {
        // 16-bit control fields:
        VMCS_FIELD_VIRTUAL_PROCESSOR_IDENTIFIER = 0x00000000,
        VMCS_FIELD_POSTED_INTERRUPT_NOTIFICATION_VECTOR = 0x00000002,
        VMCS_FIELD_EPTP_INDEX = 0x00000004,

        // 16-bit guest-state fields:
        VMCS_FIELD_GUEST_ES_SELECTOR = 0x00000800,
        VMCS_FIELD_GUEST_CS_SELECTOR = 0x00000802,
        VMCS_FIELD_GUEST_SS_SELECTOR = 0x00000804,
        VMCS_FIELD_GUEST_DS_SELECTOR = 0x00000806,
        VMCS_FIELD_GUEST_FS_SELECTOR = 0x00000808,
        VMCS_FIELD_GUEST_GS_SELECTOR = 0x0000080A,
        VMCS_FIELD_GUEST_LDTR_SELECTOR = 0x0000080C,
        VMCS_FIELD_GUEST_TR_SELECTOR = 0x0000080E,
        VMCS_FIELD_GUEST_INTERRUPT_STATUS = 0x00000810,
        VMCS_FIELD_PML_INDEX = 0x00000812,

        // 16-bit host-state fields:
        VMCS_FIELD_HOST_ES_SELECTOR = 0x00000C00,
        VMCS_FIELD_HOST_CS_SELECTOR = 0x00000C02,
        VMCS_FIELD_HOST_SS_SELECTOR = 0x00000C04,
        VMCS_FIELD_HOST_DS_SELECTOR = 0x00000C06,
        VMCS_FIELD_HOST_FS_SELECTOR = 0x00000C08,
        VMCS_FIELD_HOST_GS_SELECTOR = 0x00000C0A,
        VMCS_FIELD_HOST_TR_SELECTOR = 0x00000C0C,

        // 64-bit control fields:
        VMCS_FIELD_ADDRESS_OF_IO_BITMAP_A_FULL = 0x00002000,
        VMCS_FIELD_ADDRESS_OF_IO_BITMAP_A_HIGH = 0x00002001,
        VMCS_FIELD_ADDRESS_OF_IO_BITMAP_B_FULL = 0x00002002,
        VMCS_FIELD_ADDRESS_OF_IO_BITMAP_B_HIGH = 0x00002003,
        VMCS_FIELD_ADDRESS_OF_MSR_BITMAPS_FULL = 0x00002004,
        VMCS_FIELD_ADDRESS_OF_MSR_BITMAPS_HIGH = 0x00002005,
        VMCS_FIELD_VMEXIT_MSR_STORE_ADDRESS_FULL = 0x00002006,
        VMCS_FIELD_VMEXIT_MSR_STORE_ADDRESS_HIGH = 0x00002007,
        VMCS_FIELD_VMEXIT_MSR_LOAD_ADDRESS_FULL = 0x00002008,
        VMCS_FIELD_VMEXIT_MSR_LOAD_ADDRESS_HIGH = 0x00002009,
        VMCS_FIELD_VMENTRY_MSR_LOAD_ADDRESS_FULL = 0x0000200A,
        VMCS_FIELD_VMENTRY_MSR_LOAD_ADDRESS_HIGH = 0x0000200B,
        VMCS_FIELD_EXECUTIVE_VMCS_POINTER_FULL = 0x0000200C,
        VMCS_FIELD_EXECUTIVE_VMCS_POINTER_HIGH = 0x0000200D,
        VMCS_FIELD_PML_ADDRESS_FULL = 0x0000200E,
        VMCS_FIELD_PML_ADDRESS_HIGH = 0x0000200F,
        VMCS_FIELD_TSC_OFFSET_FULL = 0x00002010,
        VMCS_FIELD_TSC_OFFSET_HIGH = 0x00002011,
        VMCS_FIELD_VIRTUAL_APIC_ADDRESS_FULL = 0x00002012,
        VMCS_FIELD_VIRTUAL_APIC_ADDRESS_HIGH = 0x00002013,
        VMCS_FIELD_APIC_ACCESS_ADDRESS_FULL = 0x00002014,
        VMCS_FIELD_APIC_ACCESS_ADDRESS_HIGH = 0x00002015,
        VMCS_FIELD_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS_FULL = 0x00002016,
        VMCS_FIELD_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS_HIGH = 0x00002017,
        VMCS_FIELD_VM_FUNCTIONS_CONTROL_FULL = 0x00002018,
        VMCS_FIELD_VM_FUNCTIONS_CONTROL_HIGH = 0x00002019,
        VMCS_FIELD_EPT_POINTER_FULL = 0x0000201A,
        VMCS_FIELD_EPT_POINTER_HIGH = 0x0000201B,
        VMCS_FIELD_EOI_EXIT_BITMAP_0_FULL = 0x0000201C,
        VMCS_FIELD_EOI_EXIT_BITMAP_0_HIGH = 0x0000201D,
        VMCS_FIELD_EOI_EXIT_BITMAP_1_FULL = 0x0000201E,
        VMCS_FIELD_EOI_EXIT_BITMAP_1_HIGH = 0x0000201F,
        VMCS_FIELD_EOI_EXIT_BITMAP_2_FULL = 0x00002020,
        VMCS_FIELD_EOI_EXIT_BITMAP_2_HIGH = 0x00002021,
        VMCS_FIELD_EOI_EXIT_BITMAP_3_FULL = 0x00002022,
        VMCS_FIELD_EOI_EXIT_BITMAP_3_HIGH = 0x00002023,
        VMCS_FIELD_EPTP_LIST_ADDRESS_FULL = 0x00002024,
        VMCS_FIELD_EPTP_LIST_ADDRESS_HIGH = 0x00002025,
        VMCS_FIELD_VMREAD_BITMAP_ADDRESS_FULL = 0x00002026,
        VMCS_FIELD_VMREAD_BITMAP_ADDRESS_HIGH = 0x00002027,
        VMCS_FIELD_VMWRITE_BITMAP_ADDRESS_FULL = 0x00002028,
        VMCS_FIELD_VMWRITE_BITMAP_ADDRESS_HIGH = 0x00002029,
        VMCS_FIELD_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS_FULL = 0x0000202A,
        VMCS_FIELD_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS_HIGH = 0x0000202B,
        VMCS_FIELD_XSS_EXITING_BITMAP_FULL = 0x0000202C,
        VMCS_FIELD_XSS_EXITING_BITMAP_HIGH = 0x0000202D,
        VMCS_FIELD_ENCLS_EXITING_BITMAP_FULL = 0x0000202E,
        VMCS_FIELD_ENCLS_EXITING_BITMAP_HIGH = 0x0000202F,
        VMCS_FIELD_SUBPAGE_PERMISSION_TABLE_POINTER_FULL = 0x00002030,
        VMCS_FIELD_SUBPAGE_PERMISSION_TABLE_POINTER_HIGH = 0x00002031,
        VMCS_FIELD_TSC_MULTIPLIER_FULL = 0x00002032,
        VMCS_FIELD_TSC_MULTIPLIER_HIGH = 0x00002033,

        // 64-bit read-only data fields:
        VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_FULL = 0x00002400,
        VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_HIGH = 0x00002401,

        // 64-bit guest state fields:
        VMCS_FIELD_VMCS_LINK_POINTER_FULL = 0x00002800,
        VMCS_FIELD_VMCS_LINK_POINTER_HIGH = 0x00002801,
        VMCS_FIELD_GUEST_IA32_DEBUGCTL_FULL = 0x00002802,
        VMCS_FIELD_GUEST_IA32_DEBUGCTL_HIGH = 0x00002803,
        VMCS_FIELD_GUEST_IA32_PAT_FULL = 0x00002804,
        VMCS_FIELD_GUEST_IA32_PAT_HIGH = 0x00002805,
        VMCS_FIELD_GUEST_IA32_EFER_FULL = 0x00002806,
        VMCS_FIELD_GUEST_IA32_EFER_HIGH = 0x00002807,
        VMCS_FIELD_GUEST_IA32_PERF_GLOBAL_CTRL_FULL = 0x00002808,
        VMCS_FIELD_GUEST_IA32_PERF_GLOBAL_CTRL_HIGH = 0x00002809,
        VMCS_FIELD_GUEST_PDPTE_0_FULL = 0x0000280A,
        VMCS_FIELD_GUEST_PDPTE_0_HIGH = 0x0000280B,
        VMCS_FIELD_GUEST_PDPTE_1_FULL = 0x0000280C,
        VMCS_FIELD_GUEST_PDPTE_1_HIGH = 0x0000280D,
        VMCS_FIELD_GUEST_PDPTE_2_FULL = 0x0000280E,
        VMCS_FIELD_GUEST_PDPTE_2_HIGH = 0x0000280F,
        VMCS_FIELD_GUEST_PDPTE_3_FULL = 0x00002810,
        VMCS_FIELD_GUEST_PDPTE_3_HIGH = 0x00002811,
        VMCS_FIELD_GUEST_IA32_BNDCFGS_FULL = 0x00002812,
        VMCS_FIELD_GUEST_IA32_BNDCFGS_HIGH = 0x00002813,
        VMCS_FIELD_GUEST_IA32_RTIT_CTL_FULL = 0x00002814,
        VMCS_FIELD_GUEST_IA32_RTIT_CTL_HIGH = 0x00002815,

        // 64-bit host-state fields:
        VMCS_FIELD_HOST_IA32_PAT_FULL = 0x00002C00,
        VMCS_FIELD_HOST_IA32_PAT_HIGH = 0x00002C01,
        VMCS_FIELD_HOST_IA32_EFER_FULL = 0x00002C02,
        VMCS_FIELD_HOST_IA32_EFER_HIGH = 0x00002C03,
        VMCS_FIELD_HOST_IA32_PERF_GLOBAL_CTRL_FULL = 0x00002C04,
        VMCS_FIELD_HOST_IA32_PERF_GLOBAL_CTRL_HIGH = 0x00002C05,

        // 32-bit control fields:
        VMCS_FIELD_PIN_BASED_VM_EXECUTION_CONTROLS = 0x00004000,
        VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS = 0x00004002,
        VMCS_FIELD_EXCEPTION_BITMAP = 0x00004004,
        VMCS_FIELD_PAGE_FAULT_ERROR_CODE_MASK = 0x00004006,
        VMCS_FIELD_PAGE_FAULT_ERROR_CODE_MATCH = 0x00004008,
        VMCS_FIELD_CR3_TARGET_COUNT = 0x0000400A,
        VMCS_FIELD_VMEXIT_CONTROLS = 0x0000400C,
        VMCS_FIELD_VMEXIT_MSR_STORE_COUNT = 0x0000400E,
        VMCS_FIELD_VMEXIT_MSR_LOAD_COUNT = 0x00004010,
        VMCS_FIELD_VMENTRY_CONTROLS = 0x00004012,
        VMCS_FIELD_VMENTRY_MSR_LOAD_COUNT = 0x00004014,
        VMCS_FIELD_VMENTRY_INTERRUPTION_INFORMATION_FIELD = 0x00004016,
        VMCS_FIELD_VMENTRY_EXCEPTION_ERROR_CODE = 0x00004018,
        VMCS_FIELD_VMENTRY_INSTRUCTION_LENGTH = 0x0000401A,
        VMCS_FIELD_TPR_THRESHOLD = 0x0000401C,
        VMCS_FIELD_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS = 0x0000401E,
        VMCS_FIELD_PLE_GAP = 0x00004020,
        VMCS_FIELD_PLE_WINDOW = 0x00004022,

        // 32-bit read-only data fields:
        VMCS_FIELD_VM_INSTRUCTION_ERROR = 0x00004400,
        VMCS_FIELD_EXIT_REASON = 0x00004402,
        VMCS_FIELD_VMEXIT_INTERRUPTION_INFORMATION = 0x00004404,
        VMCS_FIELD_VMEXIT_INTERRUPTION_ERROR_CODE = 0x00004406,
        VMCS_FIELD_IDT_VECTORING_INFORMATION_FIELD = 0x00004408,
        VMCS_FIELD_IDT_VECTORING_ERROR_CODE = 0x0000440A,
        VMCS_FIELD_VMEXIT_INSTRUCTION_LENGTH = 0x0000440C,
        VMCS_FIELD_VMEXIT_INSTRUCTION_INFORMATION = 0x0000440E,

        // 32-bit guest-state fields:
        VMCS_FIELD_GUEST_ES_LIMIT = 0x00004800,
        VMCS_FIELD_GUEST_CS_LIMIT = 0x00004802,
        VMCS_FIELD_GUEST_SS_LIMIT = 0x00004804,
        VMCS_FIELD_GUEST_DS_LIMIT = 0x00004806,
        VMCS_FIELD_GUEST_FS_LIMIT = 0x00004808,
        VMCS_FIELD_GUEST_GS_LIMIT = 0x0000480A,
        VMCS_FIELD_GUEST_LDTR_LIMIT = 0x0000480C,
        VMCS_FIELD_GUEST_TR_LIMIT = 0x0000480E,
        VMCS_FIELD_GUEST_GDTR_LIMIT = 0x00004810,
        VMCS_FIELD_GUEST_IDTR_LIMIT = 0x00004812,
        VMCS_FIELD_GUEST_ES_ACCESS_RIGHTS = 0x00004814,
        VMCS_FIELD_GUEST_CS_ACCESS_RIGHTS = 0x00004816,
        VMCS_FIELD_GUEST_SS_ACCESS_RIGHTS = 0x00004818,
        VMCS_FIELD_GUEST_DS_ACCESS_RIGHTS = 0x0000481A,
        VMCS_FIELD_GUEST_FS_ACCESS_RIGHTS = 0x0000481C,
        VMCS_FIELD_GUEST_GS_ACCESS_RIGHTS = 0x0000481E,
        VMCS_FIELD_GUEST_LDTR_ACCESS_RIGHTS = 0x00004820,
        VMCS_FIELD_GUEST_TR_ACCESS_RIGHTS = 0x00004822,
        VMCS_FIELD_GUEST_INTERRUPTIBILITY_STATE = 0x00004824,
        VMCS_FIELD_GUEST_ACTIVITY_STATE = 0x00004826,
        VMCS_FIELD_GUEST_SMBASE = 0x00004828,
        VMCS_FIELD_GUEST_IA32_SYSENTER_CS = 0x0000482A,
        VMCS_FIELD_VMX_PREEMPTION_TIMER_VALUE = 0x0000482E,

        // 32-bit host-state fields:
        VMCS_FIELD_HOST_IA32_SYSENTER_CS = 0x00004C00,

        // Natural-width control fields:
        VMCS_FIELD_CR0_GUEST_HOST_MASK = 0x00006000,
        VMCS_FIELD_CR4_GUEST_HOST_MASK = 0x00006002,
        VMCS_FIELD_CR0_READ_SHADOW = 0x00006004,
        VMCS_FIELD_CR4_READ_SHADOW = 0x00006006,
        VMCS_FIELD_CR3_TARGET_VALUE_0 = 0x00006008,
        VMCS_FIELD_CR3_TARGET_VALUE_1 = 0x0000600A,
        VMCS_FIELD_CR3_TARGET_VALUE_2 = 0x0000600C,
        VMCS_FIELD_CR3_TARGET_VALUE_3 = 0x0000600E,

        // Natural-width read-only data fields:
        VMCS_FIELD_EXIT_QUALIFICATION = 0x00006400,
        VMCS_FIELD_IO_RCX = 0x00006402,
        VMCS_FIELD_IO_RSI = 0x00006404,
        VMCS_FIELD_IO_RDI = 0x00006406,
        VMCS_FIELD_IO_RIP = 0x00006408,
        VMCS_FIELD_GUEST_LINEAR_ADDRESS = 0x0000640A,

        // Natural-width guest-state fields:
        VMCS_FIELD_GUEST_CR0 = 0x00006800,
        VMCS_FIELD_GUEST_CR3 = 0x00006802,
        VMCS_FIELD_GUEST_CR4 = 0x00006804,
        VMCS_FIELD_GUEST_ES_BASE = 0x00006806,
        VMCS_FIELD_GUEST_CS_BASE = 0x00006808,
        VMCS_FIELD_GUEST_SS_BASE = 0x0000680A,
        VMCS_FIELD_GUEST_DS_BASE = 0x0000680C,
        VMCS_FIELD_GUEST_FS_BASE = 0x0000680E,
        VMCS_FIELD_GUEST_GS_BASE = 0x00006810,
        VMCS_FIELD_GUEST_LDTR_BASE = 0x00006812,
        VMCS_FIELD_GUEST_TR_BASE = 0x00006814,
        VMCS_FIELD_GUEST_GDTR_BASE = 0x00006816,
        VMCS_FIELD_GUEST_IDTR_BASE = 0x00006818,
        VMCS_FIELD_GUEST_DR7 = 0x0000681A,
        VMCS_FIELD_GUEST_RSP = 0x0000681C,
        VMCS_FIELD_GUEST_RIP = 0x0000681E,
        VMCS_FIELD_GUEST_RFLAGS = 0x00006820,
        VMCS_FIELD_GUEST_PENDING_DEBUG_EXCEPTIONS = 0x00006822,
        VMCS_FIELD_GUEST_IA32_SYSENTER_ESP = 0x00006824,
        VMCS_FIELD_GUEST_IA32_SYSENTER_EIP = 0x00006826,
        VMCS_FIELD_GUEST_IA32_S_CET = 0x00006828,
        VMCS_FIELD_GUEST_SSP = 0x0000682A,
        VMCS_FIELD_GUEST_IA32_INTERRUPT_SSP_TABLE_ADDR = 0x0000682C,

        // Natural-width host-state fields:
        VMCS_FIELD_HOST_CR0 = 0x00006C00,
        VMCS_FIELD_HOST_CR3 = 0x00006C02,
        VMCS_FIELD_HOST_CR4 = 0x00006C04,
        VMCS_FIELD_HOST_FS_BASE = 0x00006C06,
        VMCS_FIELD_HOST_GS_BASE = 0x00006C08,
        VMCS_FIELD_HOST_TR_BASE = 0x00006C0A,
        VMCS_FIELD_HOST_GDTR_BASE = 0x00006C0C,
        VMCS_FIELD_HOST_IDTR_BASE = 0x00006C0E,
        VMCS_FIELD_HOST_IA32_SYSENTER_ESP = 0x00006C10,
        VMCS_FIELD_HOST_IA32_SYSENTER_EIP = 0x00006C12,
        VMCS_FIELD_HOST_RSP = 0x00006C14,
        VMCS_FIELD_HOST_RIP = 0x00006C16,
        VMCS_FIELD_HOST_IA32_S_CET = 0x00006C18,
        VMCS_FIELD_HOST_SSP = 0x00006C1A,
        VMCS_FIELD_HOST_IA32_INTERRUPT_SSP_TABLE_ADDR = 0x00006C1C,
    };

    enum class VMX_EXIT_REASON : unsigned int {
        EXIT_REASON_EXCEPTION_OR_NMI = 0,
        EXIT_REASON_EXTERNAL_INTERRUPT = 1,
        EXIT_REASON_TRIPLE_FAULT = 2,
        EXIT_REASON_INIT_SIGNAL = 3,
        EXIT_REASON_SIPI = 4, // Startup IPI
        EXIT_REASON_IO_SMI = 5,
        EXIT_REASON_OTHER_SMI = 6,
        EXIT_REASON_INTERRUPT_WINDOW = 7,
        EXIT_REASON_NMI_WINDOW = 8,
        EXIT_REASON_TASK_SWITCH = 9,
        EXIT_REASON_CPUID = 10,
        EXIT_REASON_GETSEC = 11,
        EXIT_REASON_HLT = 12,
        EXIT_REASON_INVD = 13,
        EXIT_REASON_INVLPG = 14,
        EXIT_REASON_RDPMC = 15,
        EXIT_REASON_RDTSC = 16,
        EXIT_REASON_RSM = 17,
        EXIT_REASON_VMCALL = 18,
        EXIT_REASON_VMCLEAR = 19,
        EXIT_REASON_VMLAUNCH = 20,
        EXIT_REASON_VMPTRLD = 21,
        EXIT_REASON_VMPTRST = 22,
        EXIT_REASON_VMREAD = 23,
        EXIT_REASON_VMRESUME = 24,
        EXIT_REASON_VMWRITE = 25,
        EXIT_REASON_VMXOFF = 26,
        EXIT_REASON_VMXON = 27,
        EXIT_REASON_CR_ACCESS = 28,
        EXIT_REASON_DR_ACCESS = 29,
        EXIT_REASON_IO_INSTRUCTION = 30,
        EXIT_REASON_RDMSR = 31,
        EXIT_REASON_WRMSR = 32,
        EXIT_REASON_INVALID_GUEST_STATE = 33,
        EXIT_REASON_MSR_LOADING_FAILURE = 34,
        EXIT_REASON_MWAIT = 36,
        EXIT_REASON_MONITOR_TRAP_FLAG = 37,
        EXIT_REASON_MONITOR = 39,
        EXIT_REASON_PAUSE = 40,
        EXIT_REASON_MACHINE_CHECK_EVENT_FAILURE = 41,
        EXIT_REASON_TPR_BELOW_THRESHOLD = 43,
        EXIT_REASON_APIC_ACCESS = 44,
        EXIT_REASON_VIRTUALIZED_EOI = 45,
        EXIT_REASON_GDTR_OR_IDTR_ACCESS = 46,
        EXIT_REASON_LDTR_OR_TR_ACCESS = 47,
        EXIT_REASON_EPT_VIOLATION = 48,
        EXIT_REASON_EPT_MISCONFIGURATION = 49,
        EXIT_REASON_INVEPT = 50,
        EXIT_REASON_RDTSCP = 51,
        EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED = 52,
        EXIT_REASON_INVVPID = 53,
        EXIT_REASON_WBINVD = 54,
        EXIT_REASON_XSETBV = 55,
        EXIT_REASON_APIC_WRITE = 56,
        EXIT_REASON_RDRAND = 57,
        EXIT_REASON_INVPCID = 58,
        EXIT_REASON_VNFUNC = 59,
        EXIT_REASON_ENCLS = 60,
        EXIT_REASON_RDSEED = 61,
        EXIT_REASON_PAGE_MODIFICATION_LOG_FULL = 62,
        EXIT_REASON_XSAVES = 63,
        EXIT_REASON_XRSTORS = 64,
        EXIT_REASON_PCOMMIT = 65,
        EXIT_REASON_SPP_RELATED_EVENT = 66,
        EXIT_REASON_UMWAIT = 67,
        EXIT_REASON_TPAUSE = 68,
    };

    union MSR_BITMAP {
        unsigned char MsrBitmap[4096];
        struct {
            unsigned char Read00000000to00001FFF[1024];
            unsigned char ReadC0000000toC0001FFF[1024];
            unsigned char Write00000000to00001FFF[1024];
            unsigned char WriteC0000000toC0001FFF[1024];
        } Bitmap;
    };
    static_assert(sizeof(MSR_BITMAP) == 4096, "Size of MSR_BITMAP != 4096 bytes");

    enum VM_INSTRUCTION_ERROR : unsigned int {
        VmcallExecutedInVmxRootOperation = 1,
        VmclearWithInvalidPhysicalAddress = 2,
        VmclearWithVmxonPointer = 3,
        VmlaunchWithNonClearVmcs = 4,
        VmresumeWithNonLaunchedVmcs = 5,
        VmresumeAfterVmxoff = 6,
        VmentryWithInvalidControlFields = 7,
        VmentryWithInvalidHostStateFields = 8,
        VmptrldWithInvalidPhysicalAddress = 9,
        VmptrldWithVmxonPointer = 10,
        VmptrldWithIncorrectVmcsRevisionIdentifier = 11,
        VmreadVmwriteFromToUnsupportedVmcsComponent = 12,
        VmwriteToReadonlyVmcsComponent = 13,
        VmxonExecutedInVmxRootOperation = 15,
        VmentryWithInvalidExecutiveVmcsPointer = 16,
        VmentryWithNonLaunchedExecutiveVmcs = 17,
        VmentryWithExecutiveVmcsPointerNotVmxonPointer = 18,
        VmcallWithNonClearVmcs = 19,
        VmcallWithInvalidVmexitControlFields = 20,
        VmcallWithIncorrectMsegRevisionIdentifier = 22,
        VmxoffUnderDualMonitorTreatmentOfSmisAndSmm = 23,
        VmcallWithInvalidSmmMonitorFeatures = 24,
        VmentryWithInvalidVmExecutionControlFieldsInExecutiveVmcs = 25,
        VmentryWithEventsBlockedByMovSs = 26,
        InvalidOperandToInveptInvvpid = 28
    };

    union SEGMENT_ACCESS_RIGHTS {
        unsigned int Value;
        struct {
            unsigned int SegmentType : 4;
            unsigned int S : 1; // Descriptor type (0 = system, 1 = code or data)
            unsigned int DPL : 2; // Descriptor privilege level
            unsigned int P : 1; // Segment present
            unsigned int Reserved0 : 4;
            unsigned int AVL : 1; // Available for use by system software
            unsigned int L : 1; // Reserved except for CS, 64-bit mode active (for CS only)
            unsigned int DB : 1; // Default operation size (0 = 16-bit segment, 1 = 32-bit segment)
            unsigned int G : 1; // Granularity
            unsigned int SegmentUnusable : 1; // 0 = usable, 1 = unusable
            unsigned int Reserved1 : 15;
        } Bitmap;
    };
    static_assert(sizeof(SEGMENT_ACCESS_RIGHTS) == sizeof(unsigned int), "Size of SEGMENT_ACCESS_RIGHTS != sizeof(unsigned int)");

    // Consult with the IA32_VMX_PINBASED_CTLS and IA32_VMX_TRUE_PINBASED_CTLS
    // to determine how to set the reserved bits properly if you need it:
    union PIN_BASED_VM_EXECUTION_CONTROLS {
        unsigned int Value;
        struct {
            unsigned int ExternalInterruptExiting : 1;
            unsigned int ReservedBit1 : 1; // Must be 1
            unsigned int ReservedBit2 : 1; // Must be 1
            unsigned int NmiExiting : 1;
            unsigned int ReservedBit4 : 1; // Must be 1
            unsigned int VirtualNmis : 1;
            unsigned int ActivateVmxPreemptionTimer : 1;
            unsigned int ProcessPostedInterrupts : 1;
            unsigned int ReservedBit8 : 1;
            unsigned int ReservedBit9 : 1;
            unsigned int ReservedBit10 : 1;
            unsigned int ReservedBit11 : 1;
            unsigned int ReservedBit12 : 1;
            unsigned int ReservedBit13 : 1;
            unsigned int ReservedBit14 : 1;
            unsigned int ReservedBit15 : 1;
            unsigned int ReservedBit16 : 1;
            unsigned int ReservedBit17 : 1;
            unsigned int ReservedBit18 : 1;
            unsigned int ReservedBit19 : 1;
            unsigned int ReservedBit20 : 1;
            unsigned int ReservedBit21 : 1;
            unsigned int ReservedBit22 : 1;
            unsigned int ReservedBit23 : 1;
            unsigned int ReservedBit24 : 1;
            unsigned int ReservedBit25 : 1;
            unsigned int ReservedBit26 : 1;
            unsigned int ReservedBit27 : 1;
            unsigned int ReservedBit28 : 1;
            unsigned int ReservedBit29 : 1;
            unsigned int ReservedBit30 : 1;
            unsigned int ReservedBit31 : 1;
        } Bitmap;
    };
    static_assert(sizeof(PIN_BASED_VM_EXECUTION_CONTROLS) == sizeof(unsigned int), "Size of PIN_BASED_VM_EXECUTION_CONTROLS != sizeof(unsigned int)");

    // Consult with the IA32_VMX_PROCBASED_CTLS and IA32_VMX_TRUE_PROCBASED_CTLS
    // to determine how to set the reserved bits:
    union PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS {
        unsigned int Value;
        struct {
            unsigned int ReservedBit0 : 1;
            unsigned int ReservedBit1 : 1; // Must be 1
            unsigned int InterruptWindowExiting : 1;
            unsigned int UseTscOffsetting : 1;
            unsigned int ReservedBit4 : 1; // Must be 1
            unsigned int ReservedBit5 : 1; // Must be 1
            unsigned int ReservedBit6 : 1; // Must be 1
            unsigned int HltExiting : 1;
            unsigned int ReservedBit8 : 1; // Must be 1
            unsigned int InvlpgExiting : 1;
            unsigned int MwaitExiting : 1;
            unsigned int RdpmcExiting : 1;
            unsigned int RdtscExiting : 1;
            unsigned int ReservedBit13 : 1; // Must be 1
            unsigned int ReservedBit14 : 1; // Must be 1
            unsigned int Cr3LoadExiting : 1; // Must be 1
            unsigned int Cr3StoreExiting : 1; // Must be 1
            unsigned int ReservedBit17 : 1;
            unsigned int ReservedBit18 : 1;
            unsigned int Cr8LoadExiting : 1;
            unsigned int Cr8StoreExiting : 1;
            unsigned int UseTprShadow : 1;
            unsigned int NmiWindowExiting : 1;
            unsigned int MovDrExiting : 1;
            unsigned int UnconditionalIoExiting : 1;
            unsigned int UseIoBitmaps : 1;
            unsigned int ReservedBit26 : 1; // Must be 1
            unsigned int MonitorTrapFlag : 1;
            unsigned int UseMsrBitmaps : 1;
            unsigned int MonitorExiting : 1;
            unsigned int PauseExiting : 1;
            unsigned int ActivateSecondaryControls : 1;
        } Bitmap;
    };
    static_assert(sizeof(PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS) == sizeof(unsigned int), "Size of PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS != sizeof(unsigned int)");

    // Consult with the IA32_VMX_EXIT_CTLS and IA32_VMX_TRUE_EXIT_CTLS
    // to determine how to set the reserved bits:
    union VMEXIT_CONTROLS {
        unsigned int Value;
        struct {
            unsigned int ReservedBit0 : 1;
            unsigned int ReservedBit1 : 1;
            unsigned int SaveDebugControls : 1; // Whether DR7 and the IA32_DEBUGCTL are saved on VM exit
            unsigned int ReservedBit3 : 1;
            unsigned int ReservedBit4 : 1;
            unsigned int ReservedBit5 : 1;
            unsigned int ReservedBit6 : 1;
            unsigned int ReservedBit7 : 1;
            unsigned int ReservedBit8 : 1;
            unsigned int HostAddressSpaceSize : 1; // Whether a logical processor is in 64-bit mode after the next VM exit, its value is loaded into CS.L, IA32_EFER.LME and IA32_EFER.LMA on every VM exit
            unsigned int ReservedBit10 : 1;
            unsigned int ReservedBit11 : 1;
            unsigned int LoadIa32PerfGlobalCtrl : 1; // Whether the IA32_PERF_GLOBAL_CTL is loaded on VM exit
            unsigned int ReservedBit13 : 1;
            unsigned int ReservedBit14 : 1;
            unsigned int AcknowledgeInterruptOnExit : 1;
            unsigned int ReservedBit16 : 1;
            unsigned int ReservedBit17 : 1;
            unsigned int SaveIa32Pat : 1;
            unsigned int LoadIa32Pat : 1;
            unsigned int SaveIa32Efer : 1;
            unsigned int LoadIa32Efer : 1;
            unsigned int SaveVmxPreemptionTimerValue : 1;
            unsigned int ClearIa32Bndcfgs : 1;
            unsigned int ConcealVmxFromPt : 1;
            unsigned int ClearIa32RtitCtl : 1;
            unsigned int ReservedBit26 : 1;
            unsigned int ReservedBit27 : 1;
            unsigned int LoadCetState : 1;
            unsigned int ReservedBit29 : 1;
            unsigned int ReservedBit30 : 1;
            unsigned int ReservedBit31 : 1;
        } Bitmap;
    };
    static_assert(sizeof(VMEXIT_CONTROLS) == sizeof(unsigned int), "Size of VMEXIT_CONTROLS != sizeof(unsigned int)");

    // Consult with the IA32_VMX_ENTRY_CTLS and IA32_VMX_TRUE_ENTRY_CTLS
    // to determine how to set the reserved bits:
    union VMENTRY_CONTROLS {
        unsigned int Value;
        struct {
            unsigned int ReservedBit0 : 1;
            unsigned int ReservedBit1 : 1;
            unsigned int LoadDebugControls : 1; // Whether DR7 and the IA32_DEBUGCTL are loaded on VM entry
            unsigned int ReservedBit3 : 1;
            unsigned int ReservedBit4 : 1;
            unsigned int ReservedBit5 : 1;
            unsigned int ReservedBit6 : 1;
            unsigned int ReservedBit7 : 1;
            unsigned int ReservedBit8 : 1;
            unsigned int Ia32ModeGuest : 1; // Whether a logical processor is in IA-32e mode on VM entry, its value loaded into IA32_EFER.LMA as part of VM entry
            unsigned int EntryToSmm : 1;
            unsigned int DeactivateDualMonitorTreatment : 1;
            unsigned int ReservedBit12 : 1;
            unsigned int LoadIa32PerfGlobalCtrl : 1;
            unsigned int LoadIa32Pat : 1;
            unsigned int LoadIa32Efer : 1;
            unsigned int LoadIa32BndCfgs : 1;
            unsigned int ConcealVmxFromPt : 1;
            unsigned int LoadIa32RtitCtl : 1;
            unsigned int ReservedBit19 : 1;
            unsigned int LoadCetState : 1;
            unsigned int ReservedBit21 : 1;
            unsigned int ReservedBit22 : 1;
            unsigned int ReservedBit23 : 1;
            unsigned int ReservedBit24 : 1;
            unsigned int ReservedBit25 : 1;
            unsigned int ReservedBit26 : 1;
            unsigned int ReservedBit27 : 1;
            unsigned int ReservedBit28 : 1;
            unsigned int ReservedBit29 : 1;
            unsigned int ReservedBit30 : 1;
            unsigned int ReservedBit31 : 1;
        } Bitmap;
    };
    static_assert(sizeof(VMENTRY_CONTROLS) == sizeof(unsigned int), "Size of VMENTRY_CONTROLS != sizeof(unsigned int)");

    // Consult with the IA32_VMX_PROCBASED_CTLS2 to determine
    // which bits may be set to 1:
    union SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS {
        unsigned int Value;
        struct {
            unsigned int VirtualizeApicAccesses : 1;
            unsigned int EnableEpt : 1;
            unsigned int DescriptorTableExiting : 1;
            unsigned int EnableRdtscp : 1;
            unsigned int Virtualizex2ApicMode : 1;
            unsigned int EnableVpid : 1;
            unsigned int WbinvdExiting : 1;
            unsigned int UnrestrictedGuest : 1;
            unsigned int ApicRegisterVirtualization : 1;
            unsigned int VirtualInterruptDelivery : 1;
            unsigned int PauseLoopExiting : 1;
            unsigned int RdrandExiting : 1;
            unsigned int EnableInvpcid : 1;
            unsigned int EnableVmFunctions : 1;
            unsigned int VmcsShadowing : 1;
            unsigned int EnableEnclsExiting : 1;
            unsigned int RdseedExiting : 1;
            unsigned int EnablePml : 1;
            unsigned int EptViolation : 1;
            unsigned int ConcealVmxFromPt : 1;
            unsigned int EnableXsavesXrstors : 1;
            unsigned int ReservedBit21 : 1; // Reserved to 0
            unsigned int ModBasedExecuteControlForEpt : 1;
            unsigned int SubPageWritePermissionsForEpt : 1;
            unsigned int IntelPtUsesGuestPhysicalAddresses : 1;
            unsigned int UseTscScaling : 1;
            unsigned int EnableUserWaitAndPause : 1;
            unsigned int ReservedBit27 : 1; // Reserved to 0
            unsigned int EnableEnclvExiting : 1;
            unsigned int ReservedBit29 : 1; // Reserved to 0
            unsigned int ReservedBit30 : 1; // Reserved to 0
            unsigned int ReservedBit31 : 1; // Reserved to 0
        } Bitmap;
    };
    static_assert(sizeof(SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS) == sizeof(unsigned int), "Size of SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS != sizeof(unsigned int)");

    enum class INTERRUPTION_TYPE {
        ExternalInterrupt = 0,
        Reserved = 1,
        NonMaskableInterrupt = 2, // NMI
        HardwareException = 3, // e.g. #PF
        SoftwareInterrupt = 4, // INT n, #BP, #OF (overflow)
        PrivilegedSoftwareException = 5, // INT1 (#DB)
        SoftwareException = 6, // INT3 or INT0
        OtherEvent = 7
    };

    union VMENTRY_INTERRUPTION_INFORMATION {
        unsigned int Value;
        struct {
            unsigned int VectorOfInterruptOrException : 8; // Which entry in the IDT is used or which other event is injected
            unsigned int InterruptionType : 3; // See the INTERRUPTION_TYPE enum above
            unsigned int DeliverErrorCode : 1; // 0 - do not deliver, 1 - deliver (pushed an error code on the guest stack)
            unsigned int Reserved : 19;
            unsigned int Valid : 1;
        } Bitmap;
    };
    static_assert(sizeof(VMENTRY_INTERRUPTION_INFORMATION) == sizeof(unsigned int), "Size of VMENTRY_INTERRUPTION_INFORMATION != sizeof(unsigned int)");

    union EXIT_REASON {
        unsigned int Value;
        struct {
            unsigned int BasicExitReason : 16; // See the VMX_EXIT_REASON enum above
            unsigned int AlwaysClearedToZero : 1;
            unsigned int ReservedAsZero0 : 10;
            unsigned int VmexitWasIncidentToEnclaveMode : 1;
            unsigned int PendingMtfVmexit : 1;
            unsigned int VmexitFromVmxRootOperation : 1;
            unsigned int ReservedAsZero1 : 1;
            unsigned int VmentryFailure : 1; // 0 - true VM exit, 1 - VM-entry failure
        } Bitmap;
    };
    static_assert(sizeof(EXIT_REASON) == sizeof(unsigned int), "Size of EXIT_REASON != sizeof(unsigned int)");

    union VMEXIT_INTERRUPTION_INFORMATION {
        unsigned int Value;
        struct {
            unsigned int VectorOfInterruptOrException : 8; // Which entry in the IDT is used or which other event is injected
            unsigned int InterruptionType : 3; // See the INTERRUPTION_TYPE enum above
            unsigned int ErrorCodeValid : 1; // 0 - invalid, 1 - valid
            unsigned int NmiUnblockingDueToIret : 1;
            unsigned int Reserved : 18;
            unsigned int Valid : 1;
        } Bitmap;
    };
    static_assert(sizeof(VMEXIT_INTERRUPTION_INFORMATION) == sizeof(unsigned int), "Size of VMEXIT_INTERRUPTION_INFORMATION != sizeof(unsigned int)");

    union IDT_VECTORING_INFORMATION {
        unsigned int Value;
        struct {
            unsigned int VectorOfInterruptOrException : 8; // Which entry in the IDT is used or which other event is injected
            unsigned int InterruptionType : 3; // See the INTERRUPTION_TYPE enum above
            unsigned int Undefined : 1; // 0 - invalid, 1 - valid
            unsigned int NmiUnblockingDueToIret : 1;
            unsigned int Reserved : 18;
            unsigned int Valid : 1;
        } Bitmap;
    };
    static_assert(sizeof(IDT_VECTORING_INFORMATION) == sizeof(unsigned int), "Size of IDT_VECTORING_INFORMATION != sizeof(unsigned int)");

    union EXIT_QUALIFICATION {
        unsigned long long Value;
        struct {
            unsigned long long BreakpointConditions : 4; // B0..B3 conditions in DR7
            unsigned long long Reserved0 : 9;
            unsigned long long BD : 1; // Debug register access detected
            unsigned long long BS : 1; // Single instruction (RFLAGS.TF == 1 && IA32_DEBUGCTL.BTF == 0) or branch (RFLAGS.TF == IA32_DEBUGCTL.BTF == 1)
            unsigned long long Reserved1 : 1;
            unsigned long long RTM : 1; // #DB or #BP occured inside an RTM region
            unsigned long long Reserved2 : 47;
        } DebugExceptions;
        struct {
            unsigned long long LinearAddress;
        } Invlpg;
        struct {
            unsigned long long InstructionDisplacementField;
        } Invept, Invpcid, Invvpid,
          Lgdt, Lidt, Lldt, Ltr,
          Sgdt, Sidt, Sldt, Str,
          Vmclear, Vmptrld, Vmptrst, Vmread, Vmwrite, Vmxon,
          Xrstors, Xsaves;
        struct {
            unsigned long long SelectorOfTss : 16; // To which the guest attempted to switch
            unsigned long long Reserved0 : 14;
            unsigned long long SourceOfTaskSwitchInitiation : 2; // 0 = CALL, 1 = IRET, 2 = JMP, 3 = Task gate in IDT
            unsigned long long Reserved1 : 32;
        } TaskSwitch;
        struct {
            unsigned long long NumberOfControlRegister : 4; // 0 for CLTS and LMSW
            unsigned long long AccessType : 2; // 0 = MOV to CR, 1 = MOV from CR, 2 = CLTS, 3 = LMSW
            unsigned long long LmswOperandType : 1; // 0 = register, 1 = memory (0 for MOV CR and CLTS)
            unsigned long long Reserved0 : 1;
            unsigned long long Register : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned long long Reserved1 : 4;
            unsigned long long LmswSourceData : 16; // For CLTS and MOV CR cleared to 0
            unsigned long long Reserved2 : 32;
        } ControlRegistersAccess;
        struct {
            unsigned long long NumberOfDebugRegister : 3;
            unsigned long long Reserved0 : 1;
            unsigned long long DirectionOfAccess : 1; // 0 = MOV to DR, 1 = MOV from DR
            unsigned long long Reserved1 : 3;
            unsigned long long Register : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned long long Reserved2 : 52;
        } MovDr;
        struct {
            unsigned long long SizeOfAccess : 3; // 0 = 1-byte, 1 = 2-byte, 3 = 4-byte
            unsigned long long Direction : 1; // 0 = OUT, 1 = IN
            unsigned long long StringInstruction : 1; // 0 = not string instruction, 1 = string instruction
            unsigned long long RepPrefixed : 1; // 0 = no REP, 1 = prefixed with REP
            unsigned long long OperandEncoding : 1; // 0 = DX, 1 = immediate
            unsigned long long Reserved0 : 9;
            unsigned long long PortNumber : 16; // As specified in DX or in an immediate operand
            unsigned long long Reserved1 : 32;
        } IoInstructions;
        struct {
            unsigned long long OffsetInApicPage : 12; // Undefined if the APIC-access VM exit is due a guest-physical access
            unsigned long long AccessType : 4; // 0 = linear access for a data read during instruction execution
                                               // 1 = linear access for a data write during instruction execution
                                               // 2 = linear access for an instruction fetch
                                               // 3 = linear access (read or write) during event delivery
                                               // 10 = guest-physical access during event delivery
                                               // 15 = guest-physical access for an instruction fetch or during instruction execution
            unsigned long long AsynchronousAndNotEventDelivery : 1;
            unsigned long long Reserved0 : 47;
        } ApicAccess;
        struct {
            unsigned long long AccessedRead : 1;
            unsigned long long AccessedWrite : 1;
            unsigned long long AccessedExecute : 1;
            unsigned long long GuestPhysicalReadable : 1;
            unsigned long long GuestPhysicalWriteable : 1;
            unsigned long long GuestPhysicalExecutable : 1;
            unsigned long long GuestPhysicalUserExecutable : 1;
            unsigned long long GuestLinearAddressFieldIsValid : 1;
            unsigned long long AccessToGuestPhysicalAddress : 1; // Only valid if 'GuestLinearAddressFieldIsValid' equals 1
            unsigned long long UserModeLinearAddress : 1;
            unsigned long long TranslatesToReadWritePage : 1; // 0 = Readonly, 1 = ReadWrite
            unsigned long long TranslatesToNonExecutablePage : 1; // 0 = Executable, 1 = Non-executable
            unsigned long long NmiUnblockingDueToIret : 1;
            unsigned long long IsShadowStackAccess : 1;
            unsigned long long TranslatesToShadowStackPage : 1;
            unsigned long long Reserved0 : 1;
            unsigned long long AsynchronousAndNotEventDelivery : 1;
            unsigned long long Reserved1 : 47;
        } EptViolations;
    };
    static_assert(sizeof(EXIT_QUALIFICATION) == sizeof(unsigned long long), "Size of EXIT_QUALIFICATIOn != sizeof(unsigned long long)");

    // Extended-Page-Table Pointer:
    union EPTP {
        unsigned long long Value;
        struct {
            unsigned long long EptMemoryType : 3; // 0 = Uncacheable, 6 = Write-back, other values are reserved
            unsigned long long PageWalkLength : 3; // This value is 1 less than the EPT page-walk length
            unsigned long long AccessedAndDirtyFlagsSupport : 1; // Setting this control to 1 enables accessed and dirty flags for EPT (check IA32_VMX_EPT_VPID_CAP)
            unsigned long long EnforcementOfAccessRightsForSupervisorShadowStack : 1;
            unsigned long long Reserved0 : 4;
            unsigned long long EptPml4ePhysicalPfn : 52; // Maximum supported physical address width: CPUID(EAX = 0x80000008) -> EAX[7:0]
        } Bitmap;
    };
    static_assert(sizeof(EPTP) == sizeof(unsigned long long), "Size of EPTP != sizeof(unsigned long long)");

    // Describes 512-GByte region:
    union EPT_PML4E {
        unsigned long long Value;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Reserved0 : 5; // Must be zero
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Ignored0 : 1;
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Ignored1 : 1;
            unsigned long long EptPdptePhysicalPfn : 40; // Maximum supported physical address width: CPUID(EAX = 0x80000008) -> EAX[7:0]
            unsigned long long Ignored2 : 12;
        } Page1Gb, Page2Mb, Page4Kb, Generic;
    };
    static_assert(sizeof(EPT_PML4E) == sizeof(unsigned long long), "Size of EPT_PML4E != sizeof(unsigned long long)");

    union EPT_PDPTE {
        unsigned long long Value;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Reserved0 : 4;
            unsigned long long LargePage : 1;
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Reserved1 : 1;
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Reserved2 : 53;
        } Generic;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Type : 3;
            unsigned long long IgnorePat : 1;
            unsigned long long LargePage : 1; // Must be 1 (otherwise, this entry references an EPT page directory)
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Dirty : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Ignored0 : 1;
            unsigned long long Reserved0 : 18; // Must be zero
            unsigned long long PagePhysicalPfn : 22; // Physical address of the 1-GByte page referenced by this entry
            unsigned long long Ignored1 : 8;
            unsigned long long SupervisorShadowStackAccess : 1; // Ignored if bit 7 of EPTP is 0
            unsigned long long Ignored2 : 2;
            unsigned long long SuppressVe : 1; // Ignored if "EPT-violation #VE" VM-execution control is 0
        } Page1Gb;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Reserved0 : 5; // Must be zero
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Ignored0 : 1;
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Ignored1 : 1;
            unsigned long long EptPdePhysicalPfn : 40;
            unsigned long long Ignored2 : 12;
        } Page2Mb, Page4Kb;
    };
    static_assert(sizeof(EPT_PDPTE) == sizeof(unsigned long long), "Size of EPT_PDPTE != sizeof(unsigned long long)");

    union EPT_PDE {
        unsigned long long Value;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Reserved0 : 4; // Must be zero
            unsigned long long LargePage : 1;
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Reserved1 : 1;
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Reserved2 : 53;
        } Generic;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Type : 3;
            unsigned long long IgnorePat : 1;
            unsigned long long LargePage : 1; // Must be 1 (otherwise, this entry references an EPT page directory)
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Dirty : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Ignored0 : 1;
            unsigned long long Reserved0 : 9; // Must be zero
            unsigned long long PagePhysicalPfn : 31; // Physical address of the 2-MByte page referenced by this entry
            unsigned long long Ignored1 : 8;
            unsigned long long SupervisorShadowStackAccess : 1; // Ignored if bit 7 of EPTP is 0
            unsigned long long Ignored2 : 2;
            unsigned long long SuppressVe : 1; // Ignored if "EPT-violation #VE" VM-execution control is 0
        } Page2Mb;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Reserved0 : 4; // Must be zero
            unsigned long long LargePage : 1; // // Must be 0 (otherwise, this entry references a 2-MByte page)
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Ignored0 : 1;
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Ignored1 : 1;
            unsigned long long EptPtePhysicalPfn : 40;
            unsigned long long Ignored : 12;
        } Page4Kb;
    };
    static_assert(sizeof(EPT_PDE) == sizeof(unsigned long long), "Size of EPT_PDE != sizeof(unsigned long long)");

    union EPT_PTE {
        unsigned long long Value;
        struct {
            unsigned long long ReadAccess : 1;
            unsigned long long WriteAccess : 1;
            unsigned long long ExecuteAccess : 1;
            unsigned long long Type : 3;
            unsigned long long IgnorePat : 1;
            unsigned long long Ignored0 : 1;
            unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long Dirty : 1; // Ignored if bit 6 of EPTP is 0
            unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
            unsigned long long Ignored1 : 1;
            unsigned long long PagePhysicalPfn : 40;
            unsigned long long Ignored2 : 8;
            unsigned long long SupervisorShadowStackAccess : 1; // Ignored if bit 7 of EPTP is 0
            unsigned long long SubPageWritePermissions : 1; // Ignored if "sub-page write permissions for EPT" VM-execution control is 0
            unsigned long long Ignored3 : 1;
            unsigned long long SuppressVe : 1; // Ignored if "EPT-violation #VE" VM-execution control is 0
        } Page4Kb;
    };
    static_assert(sizeof(EPT_PTE) == sizeof(unsigned long long), "Size of EPT_PTE != sizeof(unsigned long long)");

    enum class INVEPT_TYPE : unsigned int {
        SingleContextInvalidation = 1,
        GlobalInvalidation = 2
    };

    struct INVEPT_DESCRIPTOR {
        unsigned long long Eptp;
        unsigned long long Reserved;
    };
    static_assert(sizeof(INVEPT_DESCRIPTOR) == 2 * sizeof(unsigned long long), "Size of INVEPT_DESCRIPTOR != 2 * sizeof(unsigned long long)");

    enum class INVVPID_TYPE : unsigned int {
        IndividualAddressInvalidation = 0,
        SingleContextInvalidation = 1,
        AllContextsInvalidation = 2,
        SingleContextInvalidationExceptGlobal = 3
    };

    struct INVVPID_DESCRIPTOR {
        unsigned long long Vpid : 16;
        unsigned long long Reserved : 48;
        unsigned long long LinearAddress;
    };
    static_assert(sizeof(INVVPID_DESCRIPTOR) == 2 * sizeof(unsigned long long), "Size of INVVPID_DESCRIPTOR != 2 * sizeof(unsigned long long)");

    union INSTRUCTION_INFORMATION_FIELD {
        unsigned int Value;
        struct {
            unsigned int Undefined0 : 7;
            unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int Undefined1 : 5;
            unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
            unsigned int Undefined2 : 14;
        } Ins, Outs;
        struct {
            unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
            unsigned int Undefined0 : 5;
            unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int ClearedTo0 : 1;
            unsigned int Undefined1 : 4;
            unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
            unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int Reg2 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        } Invept, Invpcid, Invvpid;
        struct {
            unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
            unsigned int Undefined0 : 5;
            unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int ClearedTo0 : 1;
            unsigned int OperandSize : 1; // 0 = 16-bit, 1 = 32-bit
            unsigned int Undefined1 : 3;
            unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
            unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int InstructionIdentity : 2; // 0 = SGDT, 1 = SIDT, 2 = LGDT, 3 = LIDT
            unsigned int Undefined2 : 2;
        } Lidt, Lgdt, Sidt, Sgdt;
        struct {
            unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
            unsigned int Undefined0 : 1;
            unsigned int Reg1 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int MemReg : 1; // 0 = Memory, 1 = Register
            unsigned int Undefined1 : 4;
            unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
            unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int InstructionIdentity : 2; // 0 = SLDT, 1 = STR, 2 = LLDT, 3 = LTR
            unsigned int Undefined2 : 2;
        } Lldt, Ltr, Sldt, Str;
        struct {
            unsigned int Undefined0 : 3;
            unsigned int OperandRegister : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int Undefined1 : 4;
            unsigned int OperandSize : 2; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int Undefined2 : 19;
        } Rdrand, Rdseed, Tpause, Umwait;
        struct {
            unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
            unsigned int Undefined0 : 5;
            unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int ClearedTo0 : 1;
            unsigned int Undefined1 : 4;
            unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
            unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int Undefined2 : 4;
        } Vmclear, Vmptrld, Vmptrst, Vmxon, Xrstors, Xsaves;
        struct {
            unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
            unsigned int Undefined0 : 1;
            unsigned int Reg1 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
            unsigned int MemReg : 1; // 0 = Memory, 1 = Register
            unsigned int Undefined1 : 4;
            unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
            unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
            unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
            unsigned int Reg2 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        } Vmread, Vmwrite;
    };
    static_assert(sizeof(INSTRUCTION_INFORMATION_FIELD) == sizeof(unsigned int), "Size of INSTRUCTION_INFORMATION_FIELD != sizeof(unsigned int)");
}
```

`Kernel-Bridge.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30114.128
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Kernel-Bridge", "Kernel-Bridge\Kernel-Bridge.vcxproj", "{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}"
	ProjectSection(ProjectDependencies) = postProject
		{88A23124-5640-35A0-B890-311D7A67A7D2} = {88A23124-5640-35A0-B890-311D7A67A7D2}
		{9379F9BC-7829-45D8-B339-90F6504FDF2B} = {9379F9BC-7829-45D8-B339-90F6504FDF2B}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "User-Bridge", "User-Bridge\User-Bridge.vcxproj", "{09805AB7-6E91-46A3-B501-A420E56458AB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Kernel-Tests", "Kernel-Tests\Kernel-Tests.vcxproj", "{95F62D20-4D68-475B-8B69-D1EB3585F3F3}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HookLib", "HookLib\HookLib\HookLib.vcxproj", "{9379F9BC-7829-45D8-B339-90F6504FDF2B}"
	ProjectSection(ProjectDependencies) = postProject
		{88A23124-5640-35A0-B890-311D7A67A7D2} = {88A23124-5640-35A0-B890-311D7A67A7D2}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Zydis", "HookLib\HookLib\Zydis\msvc\zydis\Zydis.vcxproj", "{88A23124-5640-35A0-B890-311D7A67A7D2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LoadableModule", "LoadableModule\LoadableModule.vcxproj", "{E52B479E-B60F-4254-98BA-31A18C4B1F70}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Debug|x64.ActiveCfg = Debug|x64
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Debug|x64.Build.0 = Debug|x64
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Debug|x86.ActiveCfg = Debug|Win32
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Debug|x86.Build.0 = Debug|Win32
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Debug|x86.Deploy.0 = Debug|Win32
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Release|x64.ActiveCfg = Release|x64
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Release|x64.Build.0 = Release|x64
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Release|x86.ActiveCfg = Release|Win32
		{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}.Release|x86.Build.0 = Release|Win32
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Debug|x64.ActiveCfg = Debug|x64
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Debug|x64.Build.0 = Debug|x64
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Debug|x86.ActiveCfg = Debug|Win32
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Debug|x86.Build.0 = Debug|Win32
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Release|x64.ActiveCfg = Release|x64
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Release|x64.Build.0 = Release|x64
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Release|x86.ActiveCfg = Release|Win32
		{09805AB7-6E91-46A3-B501-A420E56458AB}.Release|x86.Build.0 = Release|Win32
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Debug|x64.ActiveCfg = Debug|x64
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Debug|x64.Build.0 = Debug|x64
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Debug|x86.ActiveCfg = Debug|Win32
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Debug|x86.Build.0 = Debug|Win32
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Release|x64.ActiveCfg = Release|x64
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Release|x64.Build.0 = Release|x64
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Release|x86.ActiveCfg = Release|Win32
		{95F62D20-4D68-475B-8B69-D1EB3585F3F3}.Release|x86.Build.0 = Release|Win32
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Debug|x64.ActiveCfg = Debug Kernel|x64
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Debug|x64.Build.0 = Debug Kernel|x64
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Debug|x86.ActiveCfg = Debug Kernel|Win32
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Debug|x86.Build.0 = Debug Kernel|Win32
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Release|x64.ActiveCfg = Release Kernel|x64
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Release|x64.Build.0 = Release Kernel|x64
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Release|x86.ActiveCfg = Release Kernel|Win32
		{9379F9BC-7829-45D8-B339-90F6504FDF2B}.Release|x86.Build.0 = Release Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x64.ActiveCfg = Debug Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x64.Build.0 = Debug Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x86.ActiveCfg = Debug Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x86.Build.0 = Debug Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x86.Deploy.0 = Debug Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x64.ActiveCfg = Release Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x64.Build.0 = Release Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x86.ActiveCfg = Release Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x86.Build.0 = Release Kernel|Win32
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Debug|x64.ActiveCfg = Debug|x64
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Debug|x64.Build.0 = Debug|x64
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Debug|x64.Deploy.0 = Debug|x64
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Debug|x86.ActiveCfg = Debug|Win32
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Debug|x86.Build.0 = Debug|Win32
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Debug|x86.Deploy.0 = Debug|Win32
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Release|x64.ActiveCfg = Release|x64
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Release|x64.Build.0 = Release|x64
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Release|x64.Deploy.0 = Release|x64
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Release|x86.ActiveCfg = Release|Win32
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Release|x86.Build.0 = Release|Win32
		{E52B479E-B60F-4254-98BA-31A18C4B1F70}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {37EC3B5E-9924-4461-B0C3-E334C16528EB}
	EndGlobalSection
EndGlobal

```

`Kernel-Bridge/API/CPU.cpp`:

```cpp
extern "C" void _enable();
extern "C" void _disable();
extern "C" void __halt();
extern "C" unsigned long long __readmsr(unsigned long Index);
extern "C" void __writemsr(unsigned long Index, unsigned long long Value);
extern "C" void __cpuid(int Info[4], int FunctionIdEax);
extern "C" void __cpuidex(int Info[4], int FunctionIdEx, int SubfunctionIdEcx);
extern "C" unsigned long long __readpmc(unsigned long Counter);
extern "C" unsigned long long __rdtsc();
extern "C" unsigned long long __rdtscp(unsigned int* TscAux);
#ifdef _AMD64_
extern "C" unsigned long long __readcr0();
extern "C" void __writecr0(unsigned long long Value);
extern "C" unsigned long long __readcr4();
extern "C" void __writecr4(unsigned long long Value);
#elif _X86_
extern "C" unsigned long __readcr0();
extern "C" void __writecr0(unsigned long Value);
extern "C" unsigned long __readcr4();
extern "C" void __writecr4(unsigned long Value);
#endif

namespace CPU {
    void CLI() {
        _disable();
    }

    void STI() {
        _enable();
    }

    void HLT() {
        __halt();
    }

    void CPUID(unsigned int FunctionIdEax, int Regs[4]) {
        __cpuid(Regs, FunctionIdEax);
    }

    void CPUIDEX(unsigned int FunctionIdEax, unsigned int SubfunctionIdEcx, int Regs[4]) {
        __cpuidex(Regs, FunctionIdEax, SubfunctionIdEcx);
    }

    unsigned long long RDMSR(unsigned long Index) {
        return __readmsr(Index);
    }

    void WRMSR(unsigned long Index, unsigned long long Value) {
        __writemsr(Index, Value);
    }

    unsigned long long RDPMC(unsigned long Counter) {
        return __readpmc(Counter);
    }

    unsigned long long RDTSC() {
        return __rdtsc();
    }

    unsigned long long RDTSCP(unsigned int* TscAux) {
        return __rdtscp(TscAux);
    }

    bool IsRdtscpPresent() {
        int regs[4];
        __cpuid(regs, 0x80000001);
        return (regs[3] & (1 << 27)) != 0;
    }

    void DisableWriteProtection() {
        __writecr0(__readcr0() & ~(1 << 16));
    }

    void EnableWriteProtection() {
        __writecr0(__readcr0() | (1 << 16));
    }

    bool IsSmepPresent() {
        int regs[4];
        __cpuidex(regs, 7, 0);
        return (regs[1] & (1 << 7)) != 0;
    }

    bool IsSmapPresent() {
        int regs[4];
        __cpuidex(regs, 7, 0);
        return (regs[1] & (1 << 20)) != 0;
    }

    void DisableSmep() {
        __writecr4(__readcr4() & ~(1 << 20));
    }

    void EnableSmep() {
        __writecr4(__readcr4() | (1 << 20));
    }

    void DisableSmap() {
        __writecr4(__readcr4() & ~(1 << 21));
    }

    void EnableSmap() {
        __writecr4(__readcr4() | (1 << 21));
    }
}
```

`Kernel-Bridge/API/CPU.h`:

```h
#pragma once

namespace CPU {
    void CLI();
    void STI();
    void HLT();
    
    void CPUID(unsigned int FunctionIdEax, int Regs[4]);
    void CPUIDEX(unsigned int FunctionIdEax, unsigned int SubfunctionIdEcx, int Regs[4]);

    unsigned long long RDMSR(unsigned long Index);
    void WRMSR(unsigned long Index, unsigned long long Value);

    unsigned long long RDPMC(unsigned long Counter);
    unsigned long long RDTSC();
    unsigned long long RDTSCP(unsigned int* TscAux);
    bool IsRdtscpPresent();

    void DisableWriteProtection();
    void EnableWriteProtection();

    bool IsSmepPresent();
    bool IsSmapPresent();
    void DisableSmep();
    void EnableSmep();
    void DisableSmap();
    void EnableSmap();
}
```

`Kernel-Bridge/API/Callable.cpp`:

```cpp
#include <ntifs.h>

extern "C" NTSYSAPI VOID NTAPI KeGenericCallDpc(IN PKDEFERRED_ROUTINE Routine, IN PVOID Context);
extern "C" NTSYSAPI VOID NTAPI KeSignalCallDpcDone(IN PVOID SystemArgument1);
extern "C" NTSYSAPI BOOLEAN NTAPI KeSignalCallDpcSynchronize(IN PVOID SystemArgument2);

extern "C" NTSYSAPI NTSTATUS NTAPI ZwYieldExecution();

namespace Callable
{
    bool CallInSystemContext(bool(*Callback)(void* Arg), void* Arg, bool Wait)
    {
        HANDLE hThread = NULL;

        struct PARAMS {
            bool(*Callback)(PVOID Arg);
            PVOID Arg;
            bool Result;
        } Params = {};
        Params.Callback = Callback;
        Params.Arg = Arg;

        OBJECT_ATTRIBUTES ObjectAttributes;
        InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
        NTSTATUS Status = PsCreateSystemThread(
            &hThread,
            GENERIC_ALL,
            &ObjectAttributes,
            NULL,
            NULL,
            [](PVOID Arg)
            {
                PARAMS* Params = reinterpret_cast<PARAMS*>(Arg);
                Params->Result = Params->Callback(Params->Arg);
                PsTerminateSystemThread(STATUS_SUCCESS);
            },
            &Params
        );

        if (NT_SUCCESS(Status))
        {
            if (Wait)
            {
                ZwWaitForSingleObject(hThread, FALSE, NULL);
                ZwClose(hThread);
                return Params.Result;
            }
            else
            {
                ZwClose(hThread);
                return true;
            }
        }

        return false;
    }

    bool ForEachCpu(bool(*Callback)(void* Arg, unsigned int ProcessorNumber), void* Arg)
    {
        ULONG ProcessorsCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
        for (ULONG i = 0; i < ProcessorsCount; i++)
        {
            PROCESSOR_NUMBER ProcessorNumber = {};
            KeGetProcessorNumberFromIndex(i, &ProcessorNumber);

            GROUP_AFFINITY Affinity = {}, PreviousAffinity = {};
            Affinity.Group = ProcessorNumber.Group;
            Affinity.Mask = 1LL << ProcessorNumber.Number;
            KeSetSystemGroupAffinityThread(&Affinity, &PreviousAffinity);

            ZwYieldExecution(); // Perform the context switch to apply the affinity

            bool Status = Callback(Arg, i);

            KeRevertToUserGroupAffinityThread(&PreviousAffinity);

            if (!Status) return false;
        }
        return true;
    }

    void DpcOnEachCpu(void(*Callback)(void* Arg), void* Arg)
    {
        struct DPC_DATA
        {
            decltype(Callback) Callback;
            PVOID Arg;
        };

        DPC_DATA DpcData = { Callback, Arg };

        KeGenericCallDpc([](PKDPC Dpc, PVOID Arg, PVOID SystemArgument1, PVOID SystemArgument2)
        {
            UNREFERENCED_PARAMETER(Dpc);
            auto* DpcData = reinterpret_cast<DPC_DATA*>(Arg);
            DpcData->Callback(DpcData->Arg);
            KeSignalCallDpcSynchronize(SystemArgument2);
            KeSignalCallDpcDone(SystemArgument1);
        }, &DpcData);
    }

    void QueueDpc(bool(*Callback)(void* Arg), void* Arg, unsigned char ProcessorNumber)
    {
        struct DPC_DATA
        {
            KDPC Dpc;
            decltype(Callback) Callback;
            void* Arg;
        };

        constexpr ULONG DpcTag = 'CPDK';
        DPC_DATA* DpcData = reinterpret_cast<DPC_DATA*>(ExAllocatePoolWithTag(NonPagedPool, sizeof(*DpcData), DpcTag));
        memset(DpcData, 0, sizeof(*DpcData));
        DpcData->Callback = Callback;
        DpcData->Arg = Arg;

        KeInitializeDpc(&DpcData->Dpc, [](PKDPC Dpc, PVOID Arg, PVOID SystemArgument1, PVOID SystemArgument2)
        {
            UNREFERENCED_PARAMETER(Dpc);
            UNREFERENCED_PARAMETER(SystemArgument1);
            UNREFERENCED_PARAMETER(SystemArgument2);
            DPC_DATA* DpcData = reinterpret_cast<DPC_DATA*>(Arg);
            DpcData->Callback(DpcData->Arg);
            ExFreePoolWithTag(Dpc, DpcTag);
        }, DpcData);

        KeSetImportanceDpc(&DpcData->Dpc, HighImportance);
        KeSetTargetProcessorDpc(&DpcData->Dpc, ProcessorNumber);
        
        KeInsertQueueDpc(&DpcData->Dpc, NULL, NULL);
    }

    void QueueWaitDpc(bool(*Callback)(void* Arg), void* Arg, unsigned char ProcessorNumber)
    {
        struct DPC_DATA
        {
            decltype(Callback) Callback;
            void* Arg;
            volatile LONG Finished;
        };

        DPC_DATA DpcData = { Callback, Arg, 0 };

        constexpr ULONG DpcTag = 'CPDK';

        KDPC Dpc;
        KeInitializeDpc(&Dpc, [](PKDPC Dpc, PVOID Arg, PVOID SystemArgument1, PVOID SystemArgument2)
        {
            UNREFERENCED_PARAMETER(Dpc);
            UNREFERENCED_PARAMETER(SystemArgument1);
            UNREFERENCED_PARAMETER(SystemArgument2);
            DPC_DATA* DpcData = reinterpret_cast<DPC_DATA*>(Arg);
            DpcData->Callback(DpcData->Arg);
            InterlockedExchange(&DpcData->Finished, TRUE);
        }, &DpcData);

        KeSetImportanceDpc(&Dpc, HighImportance);
        KeSetTargetProcessorDpc(&Dpc, ProcessorNumber);

        KeInsertQueueDpc(&Dpc, NULL, NULL);

        while (InterlockedCompareExchange(&DpcData.Finished, TRUE, TRUE) != TRUE)
        {
            _mm_pause();
        }
    }

    void QueueThreadedDpc(bool(*Callback)(void* Arg), void* Arg, unsigned char ProcessorNumber)
    {
        struct DPC_DATA
        {
            KDPC Dpc;
            decltype(Callback) Callback;
            void* Arg;
        };

        constexpr ULONG DpcTag = 'CPDT'; // TDPC = Threaded DPC
        DPC_DATA* DpcData = reinterpret_cast<DPC_DATA*>(ExAllocatePoolWithTag(NonPagedPool, sizeof(*DpcData), DpcTag));
        memset(DpcData, 0, sizeof(*DpcData));
        DpcData->Callback = Callback;
        DpcData->Arg = Arg;

        KeInitializeThreadedDpc(&DpcData->Dpc, [](PKDPC Dpc, PVOID Arg, PVOID SystemArgument1, PVOID SystemArgument2)
        {
            UNREFERENCED_PARAMETER(Dpc);
            UNREFERENCED_PARAMETER(SystemArgument1);
            UNREFERENCED_PARAMETER(SystemArgument2);
            DPC_DATA* DpcData = reinterpret_cast<DPC_DATA*>(Arg);
            DpcData->Callback(DpcData->Arg);
            ExFreePoolWithTag(Dpc, DpcTag);
        }, DpcData);

        KeSetImportanceDpc(&DpcData->Dpc, HighImportance);
        KeSetTargetProcessorDpc(&DpcData->Dpc, ProcessorNumber);

        KeInsertQueueDpc(&DpcData->Dpc, NULL, NULL);
    }

    void QueueWaitThreadedDpc(bool(*Callback)(void* Arg), void* Arg, unsigned char ProcessorNumber)
    {
        struct DPC_DATA
        {
            decltype(Callback) Callback;
            void* Arg;
            volatile LONG Finished;
        };

        DPC_DATA DpcData = { Callback, Arg, 0 };

        constexpr ULONG DpcTag = 'CPDT'; // TDPC = Threaded DPC

        KDPC Dpc;
        KeInitializeThreadedDpc(&Dpc, [](PKDPC Dpc, PVOID Arg, PVOID SystemArgument1, PVOID SystemArgument2)
        {
            UNREFERENCED_PARAMETER(Dpc);
            UNREFERENCED_PARAMETER(SystemArgument1);
            UNREFERENCED_PARAMETER(SystemArgument2);
            DPC_DATA* DpcData = reinterpret_cast<DPC_DATA*>(Arg);
            DpcData->Callback(DpcData->Arg);
            InterlockedExchange(&DpcData->Finished, TRUE);
        }, &DpcData);

        KeSetImportanceDpc(&Dpc, HighImportance);
        KeSetTargetProcessorDpc(&Dpc, ProcessorNumber);

        KeInsertQueueDpc(&Dpc, NULL, NULL);

        while (InterlockedCompareExchange(&DpcData.Finished, TRUE, TRUE) != TRUE)
        {
            _mm_pause();
        }
    }

    struct STOP_PROCESSORS_DATA
    {
        volatile LONG ProcessorsStopped;
        volatile LONG NeedToResume;
        KIRQL PreviousIrql;
        KDPC Dpcs[1];
    };

    _IRQL_raises_(DISPATCH_LEVEL)
    [[nodiscard]] void* StopMachine()
    {
        ULONG ProcessorsCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
        SIZE_T StopDataSize = sizeof(STOP_PROCESSORS_DATA) + (ProcessorsCount - 2) * sizeof(KDPC); // Exclude the current CPU and one CPU is already reserved in STOP_PROCESSORS_DATA
        auto* StopData = reinterpret_cast<STOP_PROCESSORS_DATA*>(ExAllocatePoolWithTag(
            NonPagedPool,
            StopDataSize,
            'POTS'
        ));

        memset(StopData, 0, StopDataSize);

        StopData->PreviousIrql = KeRaiseIrqlToDpcLevel();

        ULONG CurrentProcessor = KeGetCurrentProcessorNumber();

        ULONG DpcIndex = 0;
        for (CCHAR i = 0; i < static_cast<CCHAR>(ProcessorsCount); ++i)
        {
            if (i == static_cast<CCHAR>(CurrentProcessor)) continue;

            auto* Dpc = &StopData->Dpcs[DpcIndex++];

            KeInitializeDpc(Dpc, [](PKDPC Dpc, PVOID Arg, PVOID SystemArgument1, PVOID SystemArgument2)
            {
                UNREFERENCED_PARAMETER(Dpc);
                UNREFERENCED_PARAMETER(SystemArgument1);
                UNREFERENCED_PARAMETER(SystemArgument2);
                STOP_PROCESSORS_DATA* StopData = reinterpret_cast<STOP_PROCESSORS_DATA*>(Arg);
                InterlockedIncrement(&StopData->ProcessorsStopped);
                while (InterlockedCompareExchange(&StopData->NeedToResume, TRUE, TRUE) == FALSE)
                {
                    _mm_pause();
                }
                InterlockedDecrement(&StopData->ProcessorsStopped);
            }, StopData);

            KeSetImportanceDpc(Dpc, HighImportance);
            KeSetTargetProcessorDpc(Dpc, i);

            KeInsertQueueDpc(Dpc, NULL, NULL);
        }

        while (InterlockedCompareExchange(
            &StopData->ProcessorsStopped,
            static_cast<LONG>(ProcessorsCount),
            static_cast<LONG>(ProcessorsCount)
        ) != static_cast<LONG>(ProcessorsCount)) {
            _mm_pause();
        }

        return StopData;
    }

    _IRQL_restores_
    void ResumeMachine(void* StopMachineData)
    {
        auto* Data = reinterpret_cast<STOP_PROCESSORS_DATA*>(StopMachineData);

        InterlockedExchange(&Data->NeedToResume, TRUE);        
        while (InterlockedCompareExchange(&Data->ProcessorsStopped, 0, 0) != 0)
        {
            _mm_pause();
        }
        KeLowerIrql(Data->PreviousIrql);
        ExFreePoolWithTag(Data, 'POTS');
    }
}
```

`Kernel-Bridge/API/Callable.h`:

```h
#pragma once

namespace Callable
{
    // Calls a callback in a system thread:
    bool CallInSystemContext(bool(*Callback)(void* Arg), void* Arg = nullptr, bool Wait = true);
    
    // Calls a callback on each CPU in a context of current thread:
    bool ForEachCpu(bool(*Callback)(void* Arg, unsigned int ProcessorNumber), void* Arg = nullptr);
    
    // Queues DPC to each CPU:
    void DpcOnEachCpu(void(*Callback)(void* Arg), void* Arg = nullptr);

    // Queues DPC to specified CPU and returns immediately:
    void QueueDpc(bool(*Callback)(void* Arg), void* Arg = nullptr, unsigned char ProcessorNumber = 0);

    // Queues DPC to specified CPU and waits until it done:
    void QueueWaitDpc(bool(*Callback)(void* Arg), void* Arg = nullptr, unsigned char ProcessorNumber = 0);

    // Queues threaded DPC to specified CPU and returns immediately:
    void QueueThreadedDpc(bool(*Callback)(void* Arg), void* Arg = nullptr, unsigned char ProcessorNumber = 0);

    // Queues treaded DPC to specified CPU and waits until it done:
    void QueueWaitThreadedDpc(bool(*Callback)(void* Arg), void* Arg = nullptr, unsigned char ProcessorNumber = 0);

    // Stops all CPUs except the current and raises IRQL of the current thread:
    _IRQL_raises_(DISPATCH_LEVEL)
    [[nodiscard]] void* StopMachine();

    // Resumes all stopped CPUs and restores IRQL of the current thread:
    _IRQL_restores_
    void ResumeMachine(void* StopMachineData);
}
```

`Kernel-Bridge/API/CommPort.cpp`:

```cpp
#include <fltKernel.h>

#include "MemoryUtils.h"

#include "Locks.h"
#include "LinkedList.h"
#include "CommPort.h"

CommPort::CommPort() 
: ParentFilter(NULL), ServerCookie({}), ServerPort(NULL), Clients(), OnMessageCallback(NULL) {}

CommPort::~CommPort() {
    StopServer();
}



NTSTATUS CommPort::StartServer(
    PFLT_FILTER Filter, 
    LPCWSTR PortName,
    _OnMessage OnMessage,
    LONG MaxConnections,
    OPTIONAL PVOID Cookie
)  {
    if (ServerPort) StopServer();

    ParentFilter = Filter;
    OnMessageCallback = OnMessage;

    ServerCookie.ServerInstance = this;
    ServerCookie.UserCookie = Cookie;

    UNICODE_STRING Name = {};
    RtlInitUnicodeString(&Name, PortName);

    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    NTSTATUS Status = FltBuildDefaultSecurityDescriptor(&SecurityDescriptor, FLT_PORT_ALL_ACCESS);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("[Kernel-Bridge]: Create security descriptor failure (0x%X)\r\n", Status));
        return Status;
    }

    OBJECT_ATTRIBUTES ObjectAttributes = {};
    InitializeObjectAttributes(&ObjectAttributes, &Name, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, SecurityDescriptor);

    Status = FltCreateCommunicationPort(
        ParentFilter,
        &ServerPort,
        &ObjectAttributes,
        &ServerCookie,
        OnConnectInternal,
        OnDisconnectInternal,
        OnMessageInternal,
        MaxConnections
    );

    FltFreeSecurityDescriptor(SecurityDescriptor);

    if (NT_SUCCESS(Status))
        KdPrint(("[Kernel-Bridge]: Comm.Port created!\r\n"));
    else
        KdPrint(("[Kernel-Bridge]: Comm.Port failure: 0x%X\r\n", Status));
    
    return Status;
}

VOID CommPort::StopServer() {
    if (ServerPort) FltCloseCommunicationPort(ServerPort);
    // Disconnecting all connected clients:
    Clients.LockExclusive();
    for (auto& Client : Clients) {
        FltCloseClientPort(ParentFilter, &Client.ClientPort);
    }
    Clients.Unlock();
}



NTSTATUS CommPort::OnConnectInternal(
    IN PFLT_PORT ClientPort,
    IN PVOID ServerPortCookie,
    IN PVOID ConnectionContext,
    IN ULONG SizeOfContext,
    OUT PVOID *ConnectionPortCookie
) {
    KdPrint(("[Kernel-Bridge]: Comm.Port OnConnect\r\n"));

    auto ServerCookie = static_cast<SERVER_COOKIE*>(ServerPortCookie);

    CLIENT_INFO Client = {};
    Client.ServerInstance = ServerCookie->ServerInstance;
    Client.ClientPort = ClientPort;
    
    if (ConnectionContext && SizeOfContext) { 
        PVOID ContextBuffer = VirtualMemory::AllocFromPool(SizeOfContext);
        RtlCopyMemory(ContextBuffer, ConnectionContext, SizeOfContext);
        Client.ConnectionContext = ContextBuffer;
        Client.SizeOfContext = SizeOfContext;
    }

    // Add 'Client' to clients list:
    auto ServerInstance = static_cast<CommPort*>(ServerCookie->ServerInstance);
    ServerInstance->Clients.LockExclusive();
    *ConnectionPortCookie = static_cast<PVOID>(ServerInstance->Clients.InsertTail(Client));
    ServerInstance->Clients.Unlock();

    return STATUS_SUCCESS;
}

VOID CommPort::OnDisconnectInternal(
    IN PVOID ConnectionContext
) {
    KdPrint(("[Kernel-Bridge]: Comm.Port OnDisconnect\r\n"));

    // Free client-specific info:
    auto ClientEntry = static_cast<ClientsList::ListEntry*>(ConnectionContext);
    if (ClientEntry->GetValue()->ClientPort) 
        FltCloseClientPort(ClientEntry->GetValue()->ServerInstance->ParentFilter, &ClientEntry->GetValue()->ClientPort);
    if (ClientEntry->GetValue()->ConnectionContext && ClientEntry->GetValue()->SizeOfContext) {
        VirtualMemory::FreePoolMemory(ClientEntry->GetValue()->ConnectionContext);
    }

    // Unlink client from clients list:
    CommPort* ServerInstance = ClientEntry->GetValue()->ServerInstance;
    ServerInstance->Clients.LockExclusive();
    ServerInstance->Clients.Remove(ClientEntry);
    ServerInstance->Clients.Unlock();
}

NTSTATUS CommPort::OnMessageInternal(
    IN PVOID PortCookie,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnOutputBufferLength
) {
    auto ClientEntry = static_cast<ClientsList::ListEntry*>(PortCookie);
    _OnMessage Handler = ClientEntry->GetValue()->ServerInstance->OnMessageCallback;
    if (Handler) { 
        CLIENT_REQUEST Request = {};
        Request.InputBuffer = InputBuffer;
        Request.InputSize = InputBufferLength;
        Request.OutputBuffer = OutputBuffer;
        Request.OutputSize = OutputBufferLength;
        return Handler(*ClientEntry->GetValue(), Request, ReturnOutputBufferLength);
    }
    return STATUS_SUCCESS;
}

NTSTATUS CommPort::Send(
    PFLT_PORT Client, 
    IN PVOID Buffer, 
    ULONG Size, 
    OUT PVOID Response, 
    ULONG ResponseSize,
    ULONG MsecTimeout
) {
    if (MsecTimeout == 0xFFFFFFFF) // Infinite wait:
        return FltSendMessage(ParentFilter, &Client, Buffer, Size, Response, &ResponseSize, NULL);

    LARGE_INTEGER _Timeout; // In 100-ns units
    _Timeout.QuadPart = - static_cast<INT64>(MsecTimeout) * 10 * 1000; // Relative time is negative!
    return FltSendMessage(ParentFilter, &Client, Buffer, Size, Response, &ResponseSize, &_Timeout);
}
```

`Kernel-Bridge/API/CommPort.h`:

```h
#pragma once

class CommPort {
public:
    using CLIENT_INFO = struct {
        CommPort* ServerInstance;
        PFLT_PORT ClientPort;
        PVOID ConnectionContext;
        ULONG SizeOfContext;
    };

    class ClientsList : public EResource, public LinkedList<CLIENT_INFO> {
    public:
        ClientsList() : EResource(), LinkedList<CLIENT_INFO>() {}
        ~ClientsList() = default;
    };
    
    using CLIENT_REQUEST = struct {
        IN PVOID InputBuffer;
        ULONG InputSize;
        OUT PVOID OutputBuffer;
        ULONG OutputSize;
    };
    
    using _OnMessage = NTSTATUS(NTAPI*)(CLIENT_INFO& Client, CLIENT_REQUEST& Request, OUT PULONG ReturnLength);

private:
    PFLT_FILTER ParentFilter;

    using SERVER_COOKIE = struct {
        CommPort* ServerInstance;
        PVOID UserCookie;
    };
    SERVER_COOKIE ServerCookie;

    PFLT_PORT ServerPort;

    ClientsList Clients;

    _OnMessage OnMessageCallback;

    static NTSTATUS OnConnectInternal(
        IN PFLT_PORT ClientPort,
        IN PVOID ServerPortCookie,
        IN PVOID ConnectionContext,
        IN ULONG SizeOfContext,
        OUT PVOID *ConnectionPortCookie    
    );

    static VOID OnDisconnectInternal(
        IN PVOID ConnectionCookie
    );

    static NTSTATUS OnMessageInternal(
        IN PVOID PortCookie,
        IN PVOID InputBuffer OPTIONAL,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer OPTIONAL,
        IN ULONG OutputBufferLength,
        OUT PULONG ReturnOutputBufferLength
    );

public:
    CommPort();
    ~CommPort();

    CommPort(const CommPort&) = delete;
    CommPort(CommPort&&) = delete;
    CommPort& operator = (const CommPort&) = delete;
    CommPort& operator = (CommPort&&) = delete;

    NTSTATUS StartServer(
        PFLT_FILTER Filter, 
        LPCWSTR PortName, 
        _OnMessage OnMessage,
        LONG MaxConnections = 128,
        OPTIONAL PVOID Cookie = NULL
    );

    VOID StopServer();

    ClientsList& GetClients() { return Clients; }

    NTSTATUS Send(
        PFLT_PORT Client, 
        IN PVOID Buffer, 
        ULONG Size, 
        OUT PVOID Response = NULL, 
        ULONG ResponseSize = 0,
        ULONG Timeout = 0
    );
};
```

`Kernel-Bridge/API/CppSupport.cpp`:

```cpp
#include <ntifs.h>

#include <exception>

using _PVFV = void (__cdecl *)(void); // PVFV = Pointer to Void Func(Void)
using _PIFV = int  (__cdecl *)(void); // PIFV = Pointer to Int Func(Void)

constexpr int max_destructors_count = 64;
static _PVFV onexitarray[max_destructors_count] = {};
static _PVFV *onexitbegin = nullptr, *onexitend = nullptr;

// C initializers:
#pragma section(".CRT$XIA", long, read)
__declspec(allocate(".CRT$XIA")) _PIFV __xi_a[] = { 0 };
#pragma section(".CRT$XIZ", long, read)
__declspec(allocate(".CRT$XIZ")) _PIFV __xi_z[] = { 0 };

// C++ initializers:
#pragma section(".CRT$XCA", long, read)
__declspec(allocate(".CRT$XCA")) _PVFV __xc_a[] = { 0 };
#pragma section(".CRT$XCZ", long, read)
__declspec(allocate(".CRT$XCZ")) _PVFV __xc_z[] = { 0 };

// C pre-terminators:
#pragma section(".CRT$XPA", long, read)
__declspec(allocate(".CRT$XPA")) _PVFV __xp_a[] = { 0 };
#pragma section(".CRT$XPZ", long, read)
__declspec(allocate(".CRT$XPZ")) _PVFV __xp_z[] = { 0 };

// C terminators:
#pragma section(".CRT$XTA", long, read)
__declspec(allocate(".CRT$XTA")) _PVFV __xt_a[] = { 0 };
#pragma section(".CRT$XTZ", long, read)
__declspec(allocate(".CRT$XTZ")) _PVFV __xt_z[] = { 0 };

#pragma data_seg()

#pragma comment(linker, "/merge:.CRT=.rdata")

extern "C" int _fltused = 0;

extern "C" int __cdecl __init_on_exit_array()
{
    onexitend = onexitbegin = onexitarray;
    *onexitbegin = 0;
    return 0;
}

extern "C" int __cdecl atexit(_PVFV fn)
{
    // ToDo: replace with dynamically allocated list of destructors!
    if (onexitend > &onexitarray[max_destructors_count - 1]) 
        return 1; // Not enough space
    *onexitend = fn;
    onexitend++;
    return 0;
}

int __cdecl _purecall()
{
    // It's abnormal execution, so we should detect it:
    __debugbreak();
    return 0;
}
 
static void execute_pvfv_array(_PVFV* begin, _PVFV* end)
{
    _PVFV* fn = begin;
    while (fn != end)
    {
        if (*fn) (**fn)();
        ++fn;
    }
}

static int execute_pifv_array(_PIFV* begin, _PIFV* end)
{
    _PIFV* fn = begin;
    while (fn != end)
    {
        if (*fn)
        {
            int result = (**begin)();
            if (result) return result;
        }
        ++fn;
    }
    return 0;
}

extern "C" int __crt_init()
{
    __init_on_exit_array();
    int result = execute_pifv_array(__xi_a, __xi_z);
    if (result) return result;
    execute_pvfv_array(__xc_a, __xc_z);
    return 0;
}

extern "C" void __crt_deinit()
{
    if (onexitbegin)
    {
        while (--onexitend >= onexitbegin)
        {
            if (*onexitend != 0)(**onexitend)();
        }
    }
    execute_pvfv_array(__xp_a, __xp_z);
    execute_pvfv_array(__xt_a, __xt_z);
}

constexpr unsigned long CrtPoolTag = 'TRC_';

void* __cdecl operator new(size_t Size)
{
    void* Pointer = ExAllocatePoolWithTag(NonPagedPool, Size, CrtPoolTag);
    if (Pointer) RtlZeroMemory(Pointer, Size);
    return Pointer;
}
 
void* __cdecl operator new(size_t Size, POOL_TYPE PoolType)
{
    void* Pointer = ExAllocatePoolWithTag(PoolType, Size, CrtPoolTag);
    if (Pointer) RtlZeroMemory(Pointer, Size);
    return Pointer;
}

void* __cdecl operator new[](size_t Size)
{
    void* Pointer = ExAllocatePoolWithTag(NonPagedPool, Size, CrtPoolTag);
    if (Pointer) RtlZeroMemory(Pointer, Size);
    return Pointer;
}
 
void* __cdecl operator new[](size_t Size, POOL_TYPE PoolType)
{
    void* Pointer = ExAllocatePoolWithTag(PoolType, Size, CrtPoolTag);
    if (Pointer) RtlZeroMemory(Pointer, Size);
    return Pointer;
}
 
void __cdecl operator delete(void* Pointer)
{
    if (!Pointer) return;
    ExFreePoolWithTag(Pointer, CrtPoolTag);
}
 
void __cdecl operator delete(void* Pointer, size_t Size)
{
    UNREFERENCED_PARAMETER(Size);
    if (!Pointer) return;
    ExFreePoolWithTag(Pointer, CrtPoolTag);
}

void __cdecl operator delete[](void* Pointer)
{
    if (!Pointer) return;
    ExFreePoolWithTag(Pointer, CrtPoolTag);
}

void __cdecl operator delete[](void* Pointer, size_t Size)
{
    UNREFERENCED_PARAMETER(Size);
    if (!Pointer) return;
    ExFreePoolWithTag(Pointer, CrtPoolTag);
}


[[noreturn]]
static void RaiseException(ULONG BugCheckCode)
{
    KdBreakPoint();
    KeBugCheck(BugCheckCode);
}

[[noreturn]]
void __cdecl _invalid_parameter_noinfo_noreturn()
{
    RaiseException(DRIVER_INVALID_CRUNTIME_PARAMETER);
}

namespace std
{
    [[noreturn]]
    void __cdecl _Xbad_alloc()
    {
        RaiseException(INSTALL_MORE_MEMORY);
    }
    
    [[noreturn]]
    void __cdecl _Xinvalid_argument(_In_z_ const char*)
    {
        RaiseException(DRIVER_INVALID_CRUNTIME_PARAMETER);
    }
    
    [[noreturn]]
    void __cdecl _Xlength_error(_In_z_ const char*)
    {
        RaiseException(KMODE_EXCEPTION_NOT_HANDLED);
    }
    
    [[noreturn]]
    void __cdecl _Xout_of_range(_In_z_ const char*)
    {
        RaiseException(DRIVER_OVERRAN_STACK_BUFFER);
    }
    
    [[noreturn]]
    void __cdecl _Xoverflow_error(_In_z_ const char*)
    {
        RaiseException(DRIVER_OVERRAN_STACK_BUFFER);
    }
   
    [[noreturn]]
    void __cdecl _Xruntime_error(_In_z_ const char*)
    {
        RaiseException(KMODE_EXCEPTION_NOT_HANDLED);
    }

    [[noreturn]]
    void __cdecl RaiseHandler(const std::exception&)
    {
        RaiseException(KMODE_EXCEPTION_NOT_HANDLED);
    }

    _Prhand _Raise_handler = &RaiseHandler;
}

[[noreturn]]
void __cdecl _invoke_watson(
    wchar_t const* const expression,
    wchar_t const* const function_name,
    wchar_t const* const file_name,
    unsigned int   const line_number,
    uintptr_t      const reserved)
{
    UNREFERENCED_PARAMETER(expression);
    UNREFERENCED_PARAMETER(function_name);
    UNREFERENCED_PARAMETER(file_name);
    UNREFERENCED_PARAMETER(line_number);
    UNREFERENCED_PARAMETER(reserved);

    KdBreakPoint();
    RaiseException(KMODE_EXCEPTION_NOT_HANDLED);
}

// For <unordered_set> and <unordered_map> support:
#ifdef _AMD64_
    #pragma function(ceilf)
    _Check_return_ float __cdecl ceilf(_In_ float _X)
    {
        int v = static_cast<int>(_X);
        return static_cast<float>(_X > static_cast<float>(v) ? v + 1 : v);
    }
#else
    #pragma function(ceil)
    _Check_return_ double __cdecl ceil(_In_ double _X)
    {
        int v = static_cast<int>(_X);
        return static_cast<double>(_X > static_cast<double>(v) ? v + 1 : v);
    }
#endif
```

`Kernel-Bridge/API/CppSupport.h`:

```h
#pragma once

extern "C" int __crt_init();
extern "C" void __crt_deinit();
```

`Kernel-Bridge/API/FilesAPI.cpp`:

```cpp
#include <fltKernel.h>
#include "FilesAPI.h"

FilesAPI::FilesAPI(
    LPCWSTR FilePath, 
    CREATE_FILE_TYPE Type, 
    ACCESS_MASK AccessMask, 
    ULONG ShareAccess
) : hFile(NULL) {

    UNICODE_STRING Path;
    RtlInitUnicodeString(&Path, FilePath);

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(
        &ObjectAttributes, 
        &Path, 
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
    );

    IO_STATUS_BLOCK IoStatusBlock = {};
    LARGE_INTEGER AllocationSize = {};

    ULONG CreateDisposition = FILE_OVERWRITE;
    switch (Type) {
    case fCreateEmpty:
        CreateDisposition = FILE_OVERWRITE_IF;
        break;
    case fOpenExisting:
        CreateDisposition = FILE_OPEN;
        break;
    case fOpenOrCreate:
        CreateDisposition = FILE_OPEN_IF;
        break;
    }

    CreationStatus = ZwCreateFile(
        &hFile, 
        AccessMask,
        &ObjectAttributes,
        &IoStatusBlock,
        &AllocationSize,
        FILE_ATTRIBUTE_NORMAL,
        ShareAccess,
        CreateDisposition,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
    );
}

NTSTATUS FilesAPI::Read(OUT PVOID Buffer, ULONG Size, OPTIONAL UINT64 Offset) const {
    IO_STATUS_BLOCK IoStatusBlock = {};
    return ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, Buffer, Size, reinterpret_cast<PLARGE_INTEGER>(&Offset), NULL);
}

NTSTATUS FilesAPI::Write(IN PVOID Buffer, ULONG Size, OPTIONAL UINT64 Offset) const {
    IO_STATUS_BLOCK IoStatusBlock = {};
    return ZwWriteFile(hFile, NULL, NULL, NULL, &IoStatusBlock, Buffer, Size, reinterpret_cast<PLARGE_INTEGER>(&Offset), NULL);
}

NTSTATUS FilesAPI::Close() {
    NTSTATUS Status = hFile ? ZwClose(hFile) : STATUS_SUCCESS;
    hFile = NULL;
    return Status;
}


NTSTATUS FilesAPI::CreateDir(LPCWSTR DirPath) {
    UNICODE_STRING Path;
    RtlInitUnicodeString(&Path, DirPath);

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(
        &ObjectAttributes, 
        &Path, 
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
    );

    IO_STATUS_BLOCK IoStatusBlock = {};
    LARGE_INTEGER AllocationSize = {};

    HANDLE hDir = NULL;
    NTSTATUS Status = ZwCreateFile(
        &hDir, 
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        &AllocationSize,
        FILE_ATTRIBUTE_NORMAL,
        0, // Non-shared access
        FILE_CREATE,
        FILE_DIRECTORY_FILE,
        NULL,
        0
    );
    if (NT_SUCCESS(Status) && hDir) ZwClose(hDir);
    return Status;
}

NTSTATUS FilesAPI::DeleteFile(LPCWSTR FilePath) {
    UNICODE_STRING Path;
    RtlInitUnicodeString(&Path, FilePath);

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(
        &ObjectAttributes, 
        &Path, 
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL
    );

    return ZwDeleteFile(&ObjectAttributes);
}
```

`Kernel-Bridge/API/FilesAPI.h`:

```h
#pragma once

class File final {
private:
    HANDLE _hFile;
public:
    File(const File&) = delete; // Copy constructor
    File(File&&) = delete; // Move constructor
    File& operator = (const File&) = delete; // Copy-assignment operator
    File& operator = (File&&) = delete; // Move-assignment operator

    explicit File(HANDLE hFile) : _hFile(hFile) {};
    ~File() { Close(); }
    NTSTATUS Close() {
        const NTSTATUS Status = _hFile ? ZwClose(_hFile) : STATUS_SUCCESS;
        _hFile = NULL;
        return Status;
    };
    HANDLE Get() const {
        return _hFile;
    }
};

class FilesAPI final {
private:
    HANDLE hFile;
    NTSTATUS CreationStatus;
public:
    enum CREATE_FILE_TYPE {
        fCreateEmpty,
        fOpenExisting,
        fOpenOrCreate
    };

    FilesAPI(
        LPCWSTR FilePath, 
        CREATE_FILE_TYPE Type, 
        ACCESS_MASK AccessMask, 
        ULONG ShareAccess
    );
    ~FilesAPI() { Close(); }

    NTSTATUS GetCreationStatus() const { return CreationStatus; }

    NTSTATUS Read(OUT PVOID Buffer, ULONG Size, OPTIONAL UINT64 Offset = 0) const;
    NTSTATUS Write(IN PVOID Buffer, ULONG Size, OPTIONAL UINT64 Offset = 0) const;
    NTSTATUS Close();

    static NTSTATUS CreateDir(LPCWSTR DirPath);
    static NTSTATUS DeleteFile(LPCWSTR FilePath);
    static NTSTATUS RenameFile(LPCWSTR OriginalFile, LPCWSTR NewName);
    static NTSTATUS MoveFile(LPCWSTR OriginalFile, LPCWSTR Destination);
    static NTSTATUS CopyFile(LPCWSTR OriginalFile, LPCWSTR Destination);
    static SIZE_T GetFileSize(LPCWSTR FilePath);
    static BOOLEAN IsFileExists(LPCWSTR FilePath);
    static BOOLEAN IsDirExists(LPCWSTR DirPath);
};
```

`Kernel-Bridge/API/Hypervisor.cpp`:

```cpp
/*
    Inspired by:
      - SimpleSvm by Satoshi Tanda: https://github.com/tandasat/SimpleSvm
      - SimpleVisor by Alex Ionescu: https://github.com/ionescu007/SimpleVisor
      - Hypervisor From Scratch tutorials: https://rayanfam.com/topics/hypervisor-from-scratch-part-1/
*/

#ifdef _AMD64_

#include <intrin.h>

#include <ntifs.h>
#include "MemoryUtils.h"
#include "Callable.h"

#include "Hypervisor.h"
#include "PTE.h"
#include "Registers.h"
#include "MSR.h"
#include "CPUID.h"
#include "Segmentation.h"
#include "Interrupts.h"
#include "Hyper-V.h"
#include "SVM.h"
#include "VMX.h"

#include <vector>
#include <unordered_set>
#include <unordered_map>

// Defined in VMM.asm:
extern "C" void _sldt(__out SEGMENT_SELECTOR* Selector);
extern "C" void _str(__out SEGMENT_SELECTOR* TaskRegister);
extern "C" void __invd();
/* VMX-only */ extern "C" void __invept(VMX::INVEPT_TYPE Type, __in VMX::INVEPT_DESCRIPTOR* Descriptor);
/* VMX-only */ extern "C" void __invvpid(VMX::INVVPID_TYPE Type, __in VMX::INVVPID_DESCRIPTOR* Descriptor);

extern "C" NTSYSAPI VOID NTAPI RtlCaptureContext(__out PCONTEXT ContextRecord);
extern "C" NTSYSAPI VOID NTAPI RtlRestoreContext(__in PCONTEXT ContextRecord, __in_opt EXCEPTION_RECORD* ExceptionRecord);

// Magic value, defined by hypervisor, triggers #VMEXIT and VMM shutdown:
constexpr unsigned int HYPER_BRIDGE_SIGNATURE = 0x1EE7C0DE;
constexpr unsigned int CPUID_VMM_SHUTDOWN = HYPER_BRIDGE_SIGNATURE;

// Exit action for the SvmVmexitHandler/VmxVmexitHandler:
enum class VMM_STATUS : bool
{
    VMM_SHUTDOWN = false, // Devirtualize the current logical processor
    VMM_CONTINUE = true   // Continue execution in the virtualized environment
};

struct GUEST_CONTEXT
{
    unsigned long long Rax;
    unsigned long long Rbx;
    unsigned long long Rcx;
    unsigned long long Rdx;
    unsigned long long Rsi;
    unsigned long long Rdi;
    unsigned long long Rbp;
    unsigned long long R8;
    unsigned long long R9;
    unsigned long long R10;
    unsigned long long R11;
    unsigned long long R12;
    unsigned long long R13;
    unsigned long long R14;
    unsigned long long R15;
};

static volatile bool g_IsVirtualized = false;

namespace Supplementation
{
    static PVOID AllocPhys(SIZE_T Size, MEMORY_CACHING_TYPE CachingType = MmCached, ULONG MaxPhysBits = 0)
    {
        PVOID64 HighestAcceptableAddress = MaxPhysBits
            ? reinterpret_cast<PVOID64>((1ULL << MaxPhysBits) - 1)
            : reinterpret_cast<PVOID64>((1ULL << 48) - 1);

        PVOID Memory = PhysicalMemory::AllocPhysicalMemorySpecifyCache(
            0,
            HighestAcceptableAddress,
            0,
            Size,
            CachingType
        );
        if (Memory) RtlSecureZeroMemory(Memory, Size);
        return Memory;
    }

    static VOID FreePhys(PVOID Memory)
    {
        PhysicalMemory::FreePhysicalMemory(Memory);
    }

    namespace FastPhys
    {
        // As is from ntoskrnl.exe disassembly (VirtualAddress may be unaligned):
        inline static unsigned long long MiGetPteAddress(unsigned long long VirtualAddress)
        {
            return 0xFFFFF680'00000000ull + ((VirtualAddress >> 9ull) & 0x7FFFFFFFF8ull);
        }

        // To fixup differences between different kernels:
        static const unsigned long long g_PteCorrective = []() -> unsigned long long
        {
            unsigned long long TestVa = reinterpret_cast<unsigned long long>(&g_PteCorrective);

            /* Manual traversal to obtain a valid PTE pointer in system memory */

            VIRTUAL_ADDRESS Va = { TestVa };

            auto Pml4ePhys = PFN_TO_PAGE(CR3{ __readcr3() }.x64.Bitmap.PML4) + Va.x64.NonPageSize.Generic.PageMapLevel4Offset * sizeof(PML4E);
            const PML4E* Pml4e = reinterpret_cast<const PML4E*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(Pml4ePhys) }));

            auto PdpePhys = PFN_TO_PAGE(Pml4e->x64.Generic.PDP) + Va.x64.NonPageSize.Generic.PageDirectoryPointerOffset * sizeof(PDPE);
            const PDPE* Pdpe = reinterpret_cast<const PDPE*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(PdpePhys) }));

            auto PdePhys = PFN_TO_PAGE(Pdpe->x64.NonPageSize.Generic.PD) + Va.x64.NonPageSize.Generic.PageDirectoryOffset * sizeof(PDE);
            const PDE* Pde = reinterpret_cast<const PDE*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(PdePhys) }));

            auto PtePhys = PFN_TO_PAGE(Pde->x64.Page4Kb.PT) + Va.x64.NonPageSize.Page4Kb.PageTableOffset * sizeof(PTE);
            const PTE* Pte = reinterpret_cast<const PTE*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(PtePhys) }));

            /* Then get a PTE pointer by MiGetPteAddress and calculate a difference */

            unsigned long long PteByMi = MiGetPteAddress(TestVa & 0xFFFFFFFFFFFFF000ull);

            return reinterpret_cast<unsigned long long>(Pte) - PteByMi;
        }();

        inline unsigned long long GetPhysAddressFast4KbUnsafe(unsigned long long Va)
        {
            return PFN_TO_PAGE(reinterpret_cast<const PTE*>(MiGetPteAddress(Va) + g_PteCorrective)->x64.Page4Kb.PhysicalPageFrameNumber) + (Va & 0xFFF);
        }

        unsigned long long GetPhysAddressFast4Kb(unsigned long long Cr3, unsigned long long VirtualAddress)
        {
            VIRTUAL_ADDRESS Va = { VirtualAddress };

            auto Pml4ePhys = PFN_TO_PAGE(CR3{ Cr3 }.x64.Bitmap.PML4) + Va.x64.NonPageSize.Generic.PageMapLevel4Offset * sizeof(PML4E);
            const PML4E* Pml4e = reinterpret_cast<const PML4E*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(Pml4ePhys) }));

            auto PdpePhys = PFN_TO_PAGE(Pml4e->x64.Generic.PDP) + Va.x64.NonPageSize.Generic.PageDirectoryPointerOffset * sizeof(PDPE);
            const PDPE* Pdpe = reinterpret_cast<const PDPE*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(PdpePhys) }));

            auto PdePhys = PFN_TO_PAGE(Pdpe->x64.NonPageSize.Generic.PD) + Va.x64.NonPageSize.Generic.PageDirectoryOffset * sizeof(PDE);
            const PDE* Pde = reinterpret_cast<const PDE*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(PdePhys) }));

            auto PtePhys = PFN_TO_PAGE(Pde->x64.Page4Kb.PT) + Va.x64.NonPageSize.Page4Kb.PageTableOffset * sizeof(PTE);
            const PTE* Pte = reinterpret_cast<const PTE*>(MmGetVirtualForPhysical(PHYSICAL_ADDRESS{ .QuadPart = static_cast<long long>(PtePhys) }));

            return PFN_TO_PAGE(Pte->x64.Page4Kb.PhysicalPageFrameNumber) + Va.x64.NonPageSize.Page4Kb.PageOffset;
        }
    }
}

namespace VMX
{
    static void FreePrivateVmData(void* Private);
}

namespace
{
    enum class CPU_VENDOR {
        cpuIntel,
        cpuAmd,
        cpuUnknown
    };

    CPU_VENDOR GetCpuVendor()
    {
        static CPU_VENDOR CpuVendor = CPU_VENDOR::cpuUnknown;
        if (CpuVendor != CPU_VENDOR::cpuUnknown)
        {
            return CpuVendor;
        }

        CPUID_REGS Regs;
        __cpuid(Regs.Raw, CPUID::Generic::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID);
        if (Regs.Regs.Ebx == 'uneG' && Regs.Regs.Edx == 'Ieni' && Regs.Regs.Ecx == 'letn')
        {
            CpuVendor = CPU_VENDOR::cpuIntel;
        }
        else if (Regs.Regs.Ebx == 'htuA' && Regs.Regs.Edx == 'itne' && Regs.Regs.Ecx == 'DMAc')
        {
            CpuVendor = CPU_VENDOR::cpuAmd;
        }
        
        return CpuVendor;
    }

    static void GetHvCpuName(
        __out unsigned long long& rbx,
        __out unsigned long long& rcx,
        __out unsigned long long& rdx
    ) {
        // RBX + RDX + RCX = "Hyper-Bridge":
        rbx = 'epyH';
        rcx = 'egdi';
        rdx = 'rB-r';
    }

    static bool DevirtualizeProcessor(__out void*& PrivateVmData)
    {
        PrivateVmData = NULL;

        // Trigger the #VMEXIT with the predefined arguments:
        CPUID_REGS Regs = {};
        __cpuid(Regs.Raw, CPUID_VMM_SHUTDOWN);
        if (Regs.Regs.Ecx != CPUID_VMM_SHUTDOWN) return false; // Processor not virtualized!

        // Processor is devirtualized now:
        //  Info.Eax -> PRIVATE_VM_DATA* Private LOW
        //  Info.Ebx -> Vmexit RIP
        //  Info.Ecx -> VMEXIT_SIGNATURE
        //  Info.Edx -> PRIVATE_VM_DATA* Private HIGH

        PrivateVmData = reinterpret_cast<void*>(
            (static_cast<UINT64>(Regs.Regs.Edx) << 32u) |
            (static_cast<UINT64>(Regs.Regs.Eax))
        );

        return true;
    }

    static bool DevirtualizeAllProcessors()
    {
        ULONG ProcessorsCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
        void** PrivateVmDataArray = VirtualMemory::AllocArray<void*>(ProcessorsCount);

        KeIpiGenericCall([](ULONG_PTR Arg) -> ULONG_PTR
        {
            void** PrivateVmDataArray = reinterpret_cast<void**>(Arg);
            ULONG CurrentProcessor = KeGetCurrentProcessorNumber();
            void* PrivateVmData = NULL;
            bool Status = DevirtualizeProcessor(OUT PrivateVmData);
            PrivateVmDataArray[CurrentProcessor] = PrivateVmData; // Data buffer to free
            return static_cast<ULONG_PTR>(Status);
        }, reinterpret_cast<ULONG_PTR>(PrivateVmDataArray));
             
        CPU_VENDOR vendor = GetCpuVendor();

        for (ULONG i = 0; i < ProcessorsCount; ++i)
        {
            if (PrivateVmDataArray[i])
            {
                if (vendor == CPU_VENDOR::cpuIntel)
                {
                    VMX::FreePrivateVmData(PrivateVmDataArray[i]);
                }
                else
                {
                    Supplementation::FreePhys(PrivateVmDataArray[i]);
                }
            }
        }

        g_IsVirtualized = false;

        return true;
    }
}

namespace SVM
{
    using namespace Supplementation;
    using namespace AMD;

    struct NESTED_PAGING_TABLES
    {
        DECLSPEC_ALIGN(PAGE_SIZE) PML4E Pml4e;
        DECLSPEC_ALIGN(PAGE_SIZE) PDPE Pdpe[512];
        DECLSPEC_ALIGN(PAGE_SIZE) PDE Pde[512][512];
    };

    static void BuildNestedPagingTables(__out NESTED_PAGING_TABLES* Npt)
    {
        using namespace PhysicalMemory;

        if (!Npt) return;

        Npt->Pml4e.x64.Page2Mb.P = TRUE; // Present
        Npt->Pml4e.x64.Page2Mb.RW = TRUE; // Writeable
        Npt->Pml4e.x64.Page2Mb.US = TRUE; // User
        Npt->Pml4e.x64.Page2Mb.PDP = PAGE_TO_PFN(reinterpret_cast<UINT64>(GetPhysicalAddress(&Npt->Pdpe[0])));

        for (int i = 0; i < _ARRAYSIZE(Npt->Pdpe); ++i)
        {
            Npt->Pdpe[i].x64.NonPageSize.Page2Mb.P = TRUE; // Present
            Npt->Pdpe[i].x64.NonPageSize.Page2Mb.RW = TRUE; // Writeable
            Npt->Pdpe[i].x64.NonPageSize.Page2Mb.US = TRUE; // User
            Npt->Pdpe[i].x64.NonPageSize.Page2Mb.PD = PAGE_TO_PFN(reinterpret_cast<UINT64>(GetPhysicalAddress(&Npt->Pde[i][0])));

            for (int j = 0; j < _ARRAYSIZE(Npt->Pde[i]); ++j)
            {
                Npt->Pde[i][j].x64.Page2Mb.P = TRUE; // Present
                Npt->Pde[i][j].x64.Page2Mb.RW = TRUE; // Writeable
                Npt->Pde[i][j].x64.Page2Mb.US = TRUE; // User
                Npt->Pde[i][j].x64.Page2Mb.PS = TRUE; // Large page
                Npt->Pde[i][j].x64.Page2Mb.PhysicalPageFrameNumber = i * _ARRAYSIZE(Npt->Pde[i]) + j;
            }
        }
    }

    // Defined in the VMM.asm:
    extern "C" void SvmVmmRun(void* InitialVmmStackPointer);

    // Unique for each processor:
    struct PRIVATE_VM_DATA
    {
        union
        {
            struct INITIAL_VMM_STACK_LAYOUT
            {
                PVOID GuestVmcbPa;
                PVOID HostVmcbPa;
                PRIVATE_VM_DATA* Private;
            };
            DECLSPEC_ALIGN(PAGE_SIZE) unsigned char VmmStack[KERNEL_STACK_SIZE];
            struct
            {
                unsigned char FreeSpace[KERNEL_STACK_SIZE - sizeof(INITIAL_VMM_STACK_LAYOUT)];
                INITIAL_VMM_STACK_LAYOUT InitialStack;
            } Layout;
        } VmmStack;
        DECLSPEC_ALIGN(PAGE_SIZE) VMCB Guest;
        DECLSPEC_ALIGN(PAGE_SIZE) VMCB Host;
        DECLSPEC_ALIGN(PAGE_SIZE) unsigned char HostStateArea[PAGE_SIZE];
        DECLSPEC_ALIGN(PAGE_SIZE) MSRPM Msrpm;
        DECLSPEC_ALIGN(PAGE_SIZE) NESTED_PAGING_TABLES Npt;
    };

    static void FillVmcbSegmentAttributes(
        _Out_ VMCB_STATE_SAVE_AREA::VMCB_SEGMENT_ATTRIBUTE* Attribute,
        const SEGMENT_SELECTOR* Selector,
        const DESCRIPTOR_TABLE_REGISTER_LONG* Gdtr
    ) {
        auto Gdt = reinterpret_cast<SEGMENT_DESCRIPTOR_LONG*>(Gdtr->BaseAddress);
        auto Descriptor = reinterpret_cast<USER_SEGMENT_DESCRIPTOR_LONG*>(&Gdt[Selector->Bitmap.SelectorIndex]);
        
        Attribute->Value = 0;
        Attribute->Bitmap.Type   = Descriptor->Generic.Type;
        Attribute->Bitmap.System = Descriptor->Generic.System;
        Attribute->Bitmap.Dpl    = Descriptor->Generic.Dpl;
        Attribute->Bitmap.Present   = Descriptor->Generic.Present;
        Attribute->Bitmap.Available = Descriptor->Generic.Available;
        Attribute->Bitmap.LongMode  = Descriptor->Generic.LongMode;
        Attribute->Bitmap.DefaultOperandSize = Descriptor->Generic.DefaultOperandSize;
        Attribute->Bitmap.Granularity = Descriptor->Generic.Granularity;
    }

    void InjectEvent(__out VMCB* Guest, unsigned char Vector, unsigned char Type, unsigned int Code)
    {
        EVENTINJ Event = {};
        Event.Bitmap.Vector = Vector;
        Event.Bitmap.Type = Type;
        Event.Bitmap.ErrorCodeValid = TRUE;
        Event.Bitmap.Valid = TRUE;
        Event.Bitmap.ErrorCode = Code;
        Guest->ControlArea.EventInjection = Event.Value;
    }

    void InjectEvent(__out VMCB* Guest, unsigned char Vector, unsigned char Type)
    {
        EVENTINJ Event = {};
        Event.Bitmap.Vector = Vector;
        Event.Bitmap.Type = Type;
        Event.Bitmap.Valid = TRUE;
        Guest->ControlArea.EventInjection = Event.Value;
    }

    extern "C" VMM_STATUS SvmVmexitHandler(PRIVATE_VM_DATA* Private, GUEST_CONTEXT* Context)
    {
        // Load the host state:
        __svm_vmload(reinterpret_cast<size_t>(Private->VmmStack.Layout.InitialStack.HostVmcbPa));
        
        // Restore the guest's RAX that was overwritten by host's RAX on #VMEXIT:
        Context->Rax = Private->Guest.StateSaveArea.Rax;

        VMM_STATUS Status = VMM_STATUS::VMM_CONTINUE;
        switch (Private->Guest.ControlArea.ExitCode)
        {
        case VMEXIT_CPUID:
        {
            CPUID_REGS Regs = {};
            int Function = static_cast<int>(Context->Rax);
            int SubLeaf = static_cast<int>(Context->Rcx);
            __cpuidex(Regs.Raw, Function, SubLeaf);

            switch (Function) {
            case CPUID_VMM_SHUTDOWN:
            {
                // Shutdown was triggered:
                Status = VMM_STATUS::VMM_SHUTDOWN;
                break;
            }
            case CPUID::Generic::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID:
            {
                // Vendor = 'Hyper-Bridge' as RBX + RDX + RCX:
                Context->Rax = Regs.Regs.Eax;
                GetHvCpuName(Context->Rbx, Context->Rcx, Context->Rdx);
                break;
            }
            default:
            {
                Context->Rax = Regs.Regs.Eax;
                Context->Rbx = Regs.Regs.Ebx;
                Context->Rcx = Regs.Regs.Ecx;
                Context->Rdx = Regs.Regs.Edx;
                break;
            }
            }
            break;
        }
        case VMEXIT_MSR:
        {
            if ((Context->Rcx & MAXUINT32) == static_cast<unsigned int>(AMD_MSR::MSR_EFER) && Private->Guest.ControlArea.ExitInfo1)
            {
                EFER Efer = {};
                Efer.Value = ((Context->Rdx & MAXUINT32) << 32) | (Context->Rax & MAXUINT32);
                if (!Efer.Bitmap.SecureVirtualMachineEnable)
                {
                    InjectEvent(&Private->Guest, 13, 3, 0); // #GP (Vector = 13, Type = Exception)
                    break;
                }
                Private->Guest.StateSaveArea.Efer = Efer.Value;
            }
            break;
        }
        case VMEXIT_VMRUN:
        {
            InjectEvent(&Private->Guest, 13, 3, 0); // #GP (Vector = 13, Type = Exception)
            break;
        }
        }

        if (Status == VMM_STATUS::VMM_SHUTDOWN)
        {
            // We should to devirtualize this processor:
            Context->Rax = reinterpret_cast<UINT64>(Private) & MAXUINT32; // Low part
            Context->Rbx = Private->Guest.ControlArea.NextRip;
            Context->Rcx = Private->Guest.StateSaveArea.Rsp;
            Context->Rdx = reinterpret_cast<UINT64>(Private) >> 32; // High part

            // Load the guest's state:
            __svm_vmload(reinterpret_cast<size_t>(Private->VmmStack.Layout.InitialStack.GuestVmcbPa));
            
            // Store the GIF - Global Interrupt Flag:
            _disable();
            __svm_stgi();

            // Disable the SVM by resetting the EFER.SVME bit:
            EFER Efer = {};
            Efer.Value = __readmsr(static_cast<unsigned long>(AMD_MSR::MSR_EFER));
            Efer.Bitmap.SecureVirtualMachineEnable = FALSE;
            __writemsr(static_cast<unsigned long>(AMD_MSR::MSR_EFER), Efer.Value);

            // Restoring the EFlags:
            __writeeflags(Private->Guest.StateSaveArea.Rflags);
        }

        Private->Guest.StateSaveArea.Rax = Context->Rax;
        
        // Go to the next instruction:
        Private->Guest.StateSaveArea.Rip = Private->Guest.ControlArea.NextRip;

        return Status;
    }

    // Virtualize the current logical processor:
    static bool VirtualizeProcessor()
    {
        using namespace PhysicalMemory;

        static volatile bool IsVirtualized = false;
        IsVirtualized = false;

        CONTEXT Context = {};
        Context.ContextFlags = CONTEXT_ALL;
        RtlCaptureContext(&Context);

        if (IsVirtualized) return true;

        // Enable the SVM by setting up the EFER.SVME bit:
        EFER Efer = {};
        Efer.Value = __readmsr(static_cast<unsigned long>(AMD_MSR::MSR_EFER));
        Efer.Bitmap.SecureVirtualMachineEnable = TRUE;
        __writemsr(static_cast<unsigned long>(AMD_MSR::MSR_EFER), Efer.Value);

        PRIVATE_VM_DATA* Private = reinterpret_cast<PRIVATE_VM_DATA*>(AllocPhys(sizeof(*Private)));

        // Interceptions:
        Private->Guest.ControlArea.InterceptCpuid = TRUE;
        Private->Guest.ControlArea.InterceptVmrun = TRUE;
        Private->Guest.ControlArea.InterceptMsr = TRUE;
        Private->Guest.ControlArea.MsrpmBasePa = reinterpret_cast<UINT64>(GetPhysicalAddress(&Private->Msrpm));

        // Guest Address Space ID:
        Private->Guest.ControlArea.GuestAsid = 1;

        // Nested paging:
        BuildNestedPagingTables(&Private->Npt);
        Private->Guest.ControlArea.NpEnable = TRUE;
        Private->Guest.ControlArea.NestedPageTableCr3 = reinterpret_cast<UINT64>(GetPhysicalAddress(&Private->Npt.Pml4e));

        DESCRIPTOR_TABLE_REGISTER_LONG Gdtr = {}, Idtr = {};
        _sgdt(&Gdtr);
        __sidt(&Idtr);

        // Setting up the initial guest state to the current system state:
        Private->Guest.StateSaveArea.Gdtr.Base  = Gdtr.BaseAddress;
        Private->Guest.StateSaveArea.Gdtr.Limit = Gdtr.Limit;
        Private->Guest.StateSaveArea.Idtr.Base  = Idtr.BaseAddress;
        Private->Guest.StateSaveArea.Idtr.Limit = Idtr.Limit;

        Private->Guest.StateSaveArea.Cs.Limit = GetSegmentLimit(Context.SegCs);
        Private->Guest.StateSaveArea.Ds.Limit = GetSegmentLimit(Context.SegDs);
        Private->Guest.StateSaveArea.Es.Limit = GetSegmentLimit(Context.SegEs);
        Private->Guest.StateSaveArea.Ss.Limit = GetSegmentLimit(Context.SegSs);
        
        Private->Guest.StateSaveArea.Cs.Selector = Context.SegCs;
        Private->Guest.StateSaveArea.Ds.Selector = Context.SegDs;
        Private->Guest.StateSaveArea.Es.Selector = Context.SegEs;
        Private->Guest.StateSaveArea.Ss.Selector = Context.SegSs;

        FillVmcbSegmentAttributes(&Private->Guest.StateSaveArea.Cs.Attrib, reinterpret_cast<const SEGMENT_SELECTOR*>(&Context.SegCs), &Gdtr);
        FillVmcbSegmentAttributes(&Private->Guest.StateSaveArea.Ds.Attrib, reinterpret_cast<const SEGMENT_SELECTOR*>(&Context.SegDs), &Gdtr);
        FillVmcbSegmentAttributes(&Private->Guest.StateSaveArea.Es.Attrib, reinterpret_cast<const SEGMENT_SELECTOR*>(&Context.SegEs), &Gdtr);
        FillVmcbSegmentAttributes(&Private->Guest.StateSaveArea.Ss.Attrib, reinterpret_cast<const SEGMENT_SELECTOR*>(&Context.SegSs), &Gdtr);

        Private->Guest.StateSaveArea.Efer = Efer.Value;
        Private->Guest.StateSaveArea.Cr0 = __readcr0();
        Private->Guest.StateSaveArea.Cr2 = __readcr2();
        Private->Guest.StateSaveArea.Cr3 = __readcr3();
        Private->Guest.StateSaveArea.Cr4 = __readcr4();
        Private->Guest.StateSaveArea.Rflags = Context.EFlags;
        Private->Guest.StateSaveArea.Rsp = Context.Rsp;
        Private->Guest.StateSaveArea.Rip = Context.Rip;
        Private->Guest.StateSaveArea.GuestPat = __readmsr(static_cast<unsigned long>(AMD_MSR::MSR_PAT));

        PVOID GuestVmcbPa = GetPhysicalAddress(&Private->Guest);
        PVOID HostVmcbPa = GetPhysicalAddress(&Private->Host);

        // Store state to the guest VMCB:
        __svm_vmsave(reinterpret_cast<size_t>(GuestVmcbPa));

        // Store the address of the HostStateArea:
        __writemsr(static_cast<unsigned long>(AMD_MSR::MSR_VM_HSAVE_PA), reinterpret_cast<UINT64>(GetPhysicalAddress(Private->HostStateArea)));

        // Store state to the host VMCB to load it after the #VMEXIT:
        __svm_vmsave(reinterpret_cast<size_t>(HostVmcbPa));

        // Ok, let's go:
        IsVirtualized = true;
        Private->VmmStack.Layout.InitialStack.GuestVmcbPa = GuestVmcbPa;
        Private->VmmStack.Layout.InitialStack.HostVmcbPa = HostVmcbPa;
        Private->VmmStack.Layout.InitialStack.Private = Private;
        SvmVmmRun(&Private->VmmStack.Layout.InitialStack);
        
        // If SvmVmmRun returns to here, something went wrong:
        FreePhys(Private);
        return false;
    }

    // Virtualize all processors:
    static bool VirtualizeAllProcessors()
    {
        using namespace Supplementation;

        // Virtualizing each processor:
        bool Status = Callable::CallInSystemContext([](void* Arg) -> bool
        {
            return Callable::ForEachCpu([](void* Arg, auto ProcessorNumber) -> bool
            {
                UNREFERENCED_PARAMETER(Arg);
                UNREFERENCED_PARAMETER(ProcessorNumber);
                return VirtualizeProcessor();
            }, Arg);
        }, NULL);

        if (!Status)
            DevirtualizeAllProcessors();

        return Status;
    }

    static bool IsSvmSupported()
    {
        CPUID_REGS Regs = {};
        
        // Check the 'AuthenticAMD' vendor name:
        __cpuid(Regs.Raw, CPUID::Generic::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID);
        if (Regs.Regs.Ebx != 'htuA' || Regs.Regs.Edx != 'itne' || Regs.Regs.Ecx != 'DMAc') return false;

        // Check the AMD SVM (AMD-V) support:
        constexpr unsigned int CPUID_FN80000001_ECX_SVM = 1 << 2;
        __cpuid(Regs.Raw, CPUID::Generic::CPUID_EXTENDED_FEATURE_INFORMATION);
        if ((Regs.Regs.Ecx & CPUID_FN80000001_ECX_SVM) == 0) return false;

        // Check the Nested Paging support (AMD-RVI):
        constexpr unsigned int CPUID_FN8000000A_EDX_NESTED_PAGING = 1 << 0;
        __cpuid(Regs.Raw, CPUID::AMD::CPUID_SVM_FEATURES);
        if ((Regs.Regs.Edx & CPUID_FN8000000A_EDX_NESTED_PAGING) == 0) return false;

        // Check that the EFER.SVME is writeable (we can enable the SVM):
        VM_CR VmCr = {};
        VmCr.Value = __readmsr(static_cast<unsigned long>(AMD_MSR::MSR_VM_CR));
        if (VmCr.Bitmap.SVMDIS) return false;

        return true;
    }
}

namespace VMX
{
    using namespace Supplementation;
    using namespace Intel;

    namespace VMCALLS
    {
        enum class VMCALL_INDEX
        {
            VmmCall
        };

        unsigned long long VmmCall(unsigned long long(*Fn)(void* Arg), void* Arg, bool SwitchToCallerAddressSpace = false)
        {
            return __kb_vmcall(
                static_cast<unsigned long long>(VMCALL_INDEX::VmmCall),
                reinterpret_cast<unsigned long long>(Fn),
                reinterpret_cast<unsigned long long>(Arg),
                static_cast<unsigned long long>(SwitchToCallerAddressSpace)
            );
        }
    }

    struct MTRR_INFO
    {
        UINT64 MaxPhysAddrBits;
        UINT64 PhysAddrMask;
        IA32_VMX_EPT_VPID_CAP EptVpidCap;
        IA32_MTRRCAP MtrrCap;
        IA32_MTRR_DEF_TYPE MtrrDefType;

        // For the first 1 megabyte of the physical address space:
        union
        {
            MTRR_FIXED_GENERIC Generic[11];
            struct {
                // 512-Kbyte range:
                IA32_MTRR_FIX64K RangeFrom00000To7FFFF;

                // Two 128-Kbyte ranges:
                IA32_MTRR_FIX16K RangeFrom80000To9FFFF;
                IA32_MTRR_FIX16K RangeFromA0000ToBFFFF;

                // Eight 32-Kbyte ranges:
                IA32_MTRR_FIX4K RangeFromC0000ToC7FFF;
                IA32_MTRR_FIX4K RangeFromC8000ToCFFFF;
                IA32_MTRR_FIX4K RangeFromD0000ToD7FFF;
                IA32_MTRR_FIX4K RangeFromD8000ToDFFFF;
                IA32_MTRR_FIX4K RangeFromE0000ToE7FFF;
                IA32_MTRR_FIX4K RangeFromE8000ToEFFFF;
                IA32_MTRR_FIX4K RangeFromF0000ToF7FFF;
                IA32_MTRR_FIX4K RangeFromF8000ToFFFFF;
            } Ranges;
        } Fixed;

        // For the memory above the first megabyte of the physical address space:
        struct
        {
            IA32_MTRR_PHYSBASE PhysBase;
            IA32_MTRR_PHYSMASK PhysMask;
        } Variable[10];

        bool IsSupported;
    };

    // E.g.: MaskLow<char>(5) -> 0b00011111:
    template <typename T>
    constexpr T MaskLow(unsigned char SignificantBits)
    {
        return static_cast<T>((1ULL << SignificantBits) - 1);
    }

    // E.g.: MaskHigh<char>(3) -> 0b11100000:
    template <typename T>
    constexpr T MaskHigh(unsigned char SignificantBits)
    {
        return MaskLow<T>(SignificantBits) << ((sizeof(T) * 8) - SignificantBits);
    }

    static void InitMtrr(__out MTRR_INFO* MtrrInfo)
    {
        *MtrrInfo = {};

        CPUID::FEATURE_INFORMATION Features = {};
        __cpuid(Features.Regs.Raw, CPUID::Intel::CPUID_FEATURE_INFORMATION);
        MtrrInfo->IsSupported = Features.Intel.MTRR;

        if (!MtrrInfo->IsSupported) return;

        CPUID::Intel::VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES MaxAddrSizes = {};
        __cpuid(MaxAddrSizes.Regs.Raw, CPUID::Intel::CPUID_VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES);
        MtrrInfo->MaxPhysAddrBits = MaxAddrSizes.Bitmap.PhysicalAddressBits;
        MtrrInfo->PhysAddrMask = ~MaskLow<unsigned long long>(static_cast<unsigned char>(MtrrInfo->MaxPhysAddrBits));

        MtrrInfo->EptVpidCap.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_EPT_VPID_CAP));
        MtrrInfo->MtrrCap.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRRCAP));
        MtrrInfo->MtrrDefType.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_DEF_TYPE));

        if (MtrrInfo->MtrrCap.Bitmap.FIX && MtrrInfo->MtrrDefType.Bitmap.FE)
        {
            // 512-Kbyte range:
            MtrrInfo->Fixed.Ranges.RangeFrom00000To7FFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX64K_00000));

            // Two 128-Kbyte ranges:
            MtrrInfo->Fixed.Ranges.RangeFrom80000To9FFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX16K_80000));
            MtrrInfo->Fixed.Ranges.RangeFromA0000ToBFFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX16K_A0000));
        
            // Eight 32-Kbyte ranges:
            MtrrInfo->Fixed.Ranges.RangeFromC0000ToC7FFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_C0000));
            MtrrInfo->Fixed.Ranges.RangeFromC8000ToCFFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_C8000));
            MtrrInfo->Fixed.Ranges.RangeFromD0000ToD7FFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_D0000));
            MtrrInfo->Fixed.Ranges.RangeFromD8000ToDFFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_D8000));
            MtrrInfo->Fixed.Ranges.RangeFromE0000ToE7FFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_E0000));
            MtrrInfo->Fixed.Ranges.RangeFromE8000ToEFFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_E8000));
            MtrrInfo->Fixed.Ranges.RangeFromF0000ToF7FFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_F0000));
            MtrrInfo->Fixed.Ranges.RangeFromF8000ToFFFFF.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_FIX4K_F8000));
        }

        for (unsigned i = 0; i < MtrrInfo->MtrrCap.Bitmap.VCNT; ++i)
        {
            if (i == ARRAYSIZE(MtrrInfo->Variable)) break;
            MtrrInfo->Variable[i].PhysBase.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_PHYSBASE0) + i * 2);
            MtrrInfo->Variable[i].PhysMask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_MTRR_PHYSMASK0) + i * 2);
        }
    }

    struct MEMORY_RANGE
    {
        unsigned long long First;
        unsigned long long Last;
    };

    static bool AreRangesIntersects(const MEMORY_RANGE& Range1, const MEMORY_RANGE& Range2)
    {
        return Range1.First <= Range2.Last && Range1.Last >= Range2.First;
    }

    static bool MixMtrrTypes(MTRR_MEMORY_TYPE Type1, MTRR_MEMORY_TYPE Type2, __out MTRR_MEMORY_TYPE& Mixed)
    {
        Mixed = MTRR_MEMORY_TYPE::Uncacheable;

        if (Type1 == MTRR_MEMORY_TYPE::Uncacheable || Type2 == MTRR_MEMORY_TYPE::Uncacheable)
        {
            Mixed = MTRR_MEMORY_TYPE::Uncacheable;
            return true;
        }

        if (Type1 == Type2)
        {
            Mixed = Type1;
            return true;
        }
        else
        {
            if ((Type1 == MTRR_MEMORY_TYPE::WriteThrough || Type1 == MTRR_MEMORY_TYPE::WriteBack)
                && (Type2 == MTRR_MEMORY_TYPE::WriteThrough || Type2 == MTRR_MEMORY_TYPE::WriteBack))
            {
                Mixed = MTRR_MEMORY_TYPE::WriteThrough;
                return true;
            }
        }

        return false; // Memory types are conflicting, returning Uncacheable
    }

    static MTRR_MEMORY_TYPE CalcMemoryTypeByFixedMtrr(
        MTRR_FIXED_GENERIC FixedMtrrGeneric,
        const MEMORY_RANGE& MtrrRange,
        const MEMORY_RANGE& PhysRange
    ) {
        bool Initialized = false;
        MTRR_MEMORY_TYPE MemType = MTRR_MEMORY_TYPE::Uncacheable;

        constexpr unsigned long long RangeBitsMask = 0b1111'1111;
        constexpr unsigned long long RangeBitsCount = 8;
        constexpr unsigned long long RangesCount = (sizeof(FixedMtrrGeneric) * 8) / RangeBitsCount;
        const unsigned long long SubrangeSize = (MtrrRange.Last - MtrrRange.First + 1) / RangeBitsCount;

        for (unsigned int i = 0; i < RangesCount; ++i)
        {
            MEMORY_RANGE Subrange;
            Subrange.First = MtrrRange.First + i * SubrangeSize;
            Subrange.Last = Subrange.First + SubrangeSize - 1;

            if (AreRangesIntersects(PhysRange, Subrange))
            {
                MTRR_MEMORY_TYPE SubrangeType = static_cast<MTRR_MEMORY_TYPE>((FixedMtrrGeneric.Value >> (i * RangeBitsCount)) & RangeBitsMask);
                if (Initialized)
                {
                    bool MixingStatus = MixMtrrTypes(MemType, SubrangeType, OUT MemType);
                    if (!MixingStatus)
                    {
                        // Cache types are conflicting in overlapped regions, returning Uncacheable:
                        MemType = MTRR_MEMORY_TYPE::Uncacheable;
                    }
                }
                else
                {
                    MemType = SubrangeType;
                    Initialized = true;
                }

                // If at least one range is Uncacheable - then
                // all overlapped ranges are Uncacheable:
                if (MemType == MTRR_MEMORY_TYPE::Uncacheable)
                {
                    break;
                }
            }
        }

        return MemType;
    }

    static const MEMORY_RANGE FixedRanges[] = {
        { 0x00000, 0x7FFFF },
        { 0x80000, 0x9FFFF },
        { 0xA0000, 0xBFFFF },
        { 0xC0000, 0xC7FFF },
        { 0xC8000, 0xCFFFF },
        { 0xD0000, 0xD7FFF },
        { 0xD8000, 0xDFFFF },
        { 0xE0000, 0xE7FFF },
        { 0xE8000, 0xEFFFF },
        { 0xF0000, 0xF7FFF },
        { 0xF8000, 0xFFFFF },
    };

    static MTRR_MEMORY_TYPE GetMtrrMemoryType(__in const MTRR_INFO* MtrrInfo, unsigned long long PhysicalAddress, unsigned int PageSize)
    {
        if (!MtrrInfo || !PageSize || !MtrrInfo->MtrrDefType.Bitmap.E)
            return MTRR_MEMORY_TYPE::Uncacheable;

        constexpr unsigned long long FIRST_MEGABYTE = 0x100000ULL;

        MEMORY_RANGE PhysRange = {};
        PhysRange.First = PhysicalAddress;
        PhysRange.Last = PhysicalAddress + PageSize - 1;

        bool IsMemTypeInitialized = false;

        // Default type:
        MTRR_MEMORY_TYPE MemType = static_cast<MTRR_MEMORY_TYPE>(MtrrInfo->MtrrDefType.Bitmap.Type);

        if (PhysicalAddress < FIRST_MEGABYTE && MtrrInfo->MtrrCap.Bitmap.FIX && MtrrInfo->MtrrDefType.Bitmap.FE)
        {
            for (unsigned int i = 0; i < ARRAYSIZE(FixedRanges); ++i)
            {
                MTRR_FIXED_GENERIC MtrrFixedGeneric = {};
                MtrrFixedGeneric.Value = MtrrInfo->Fixed.Generic[i].Value;
                if (AreRangesIntersects(PhysRange, FixedRanges[i]))
                {
                    MTRR_MEMORY_TYPE FixedMemType = CalcMemoryTypeByFixedMtrr(MtrrFixedGeneric, FixedRanges[i], PhysRange);
                    if (FixedMemType == MTRR_MEMORY_TYPE::Uncacheable) return FixedMemType;
                    if (IsMemTypeInitialized)
                    {
                        bool IsMixed = MixMtrrTypes(MemType, FixedMemType, OUT MemType);
                        if (!IsMixed)
                        {
                            return MTRR_MEMORY_TYPE::Uncacheable;
                        }
                    }
                    else
                    {
                        IsMemTypeInitialized = true;
                        MemType = FixedMemType;
                    }
                }
            }
        }

        for (unsigned int i = 0; i < MtrrInfo->MtrrCap.Bitmap.VCNT; ++i)
        {
            // If this entry is valid:
            if (!MtrrInfo->Variable[i].PhysMask.Bitmap.V) continue;
            
            unsigned long long MtrrPhysBase = PFN_TO_PAGE(MtrrInfo->Variable[i].PhysBase.Bitmap.PhysBasePfn);
            unsigned long long MtrrPhysMask = PFN_TO_PAGE(MtrrInfo->Variable[i].PhysMask.Bitmap.PhysMaskPfn) | MtrrInfo->PhysAddrMask;
            unsigned long long MaskedMtrrPhysBase = MtrrPhysBase & MtrrPhysMask;
            MTRR_MEMORY_TYPE VarMemType = MTRR_MEMORY_TYPE::Uncacheable;
            bool IsVarMemTypeInitialized = false;
            for (unsigned long long Page = PhysicalAddress; Page < PhysicalAddress + PageSize; Page += PAGE_SIZE)
            {
                if ((Page & MtrrPhysMask) == MaskedMtrrPhysBase)
                {
                    auto PageMemType = static_cast<MTRR_MEMORY_TYPE>(MtrrInfo->Variable[i].PhysBase.Bitmap.Type);
                    if (IsVarMemTypeInitialized)
                    {
                        bool IsMixed = MixMtrrTypes(VarMemType, PageMemType, OUT VarMemType);
                        if (!IsMixed)
                        {
                            return MTRR_MEMORY_TYPE::Uncacheable;
                        }
                    }
                    else
                    {
                        VarMemType = PageMemType;
                        IsVarMemTypeInitialized = true;
                    }

                    if (VarMemType == MTRR_MEMORY_TYPE::Uncacheable)
                    {
                        return MTRR_MEMORY_TYPE::Uncacheable;
                    }
                }
            }

            if (IsVarMemTypeInitialized)
            {
                if (VarMemType == MTRR_MEMORY_TYPE::Uncacheable)
                {
                    return MTRR_MEMORY_TYPE::Uncacheable;
                }

                if (IsMemTypeInitialized)
                {
                    bool IsMixed = MixMtrrTypes(MemType, VarMemType, OUT MemType);
                    if (!IsMixed)
                    {
                        return MTRR_MEMORY_TYPE::Uncacheable;
                    }
                }
                else
                {
                    MemType = VarMemType;
                    IsMemTypeInitialized = true;
                }
            }
        }

        return MemType;
    }

    // Defined in the VMM.asm:
    extern "C" void VmxVmmRun(void* InitialVmmStackLayout);

    struct EPT_TABLES
    {
        DECLSPEC_ALIGN(PAGE_SIZE) EPT_PML4E Pml4e;
        DECLSPEC_ALIGN(PAGE_SIZE) EPT_PDPTE Pdpte[512];
        DECLSPEC_ALIGN(PAGE_SIZE) EPT_PDE Pde[512][512];
        DECLSPEC_ALIGN(PAGE_SIZE) EPT_PTE PteForFirstLargePage[2 * 1048576 / 4096];
    };

    struct EPT_ENTRIES
    {
        EPT_PML4E* Pml4e;
        EPT_PDPTE* Pdpte;
        EPT_PDE* Pde;
        EPT_PTE* Pte;
    };

    struct LARGE_PAGE_LAYOUT
    {
        EPT_PTE Pte[512];
    };

    struct LARGE_PAGE_DESCRIPTOR
    {
        EPT_PDE* Pde;
        EPT_PDE OriginalPde;
        LARGE_PAGE_LAYOUT* Layout;
    };

    struct PAGE_HANDLER
    {
        EPT_PTE OnRead;
        EPT_PTE OnWrite;
        EPT_PTE OnExecute;
        EPT_PTE OnExecuteRead;
        EPT_PTE OnExecuteWrite;
    };

    struct EPT_PTE_HANDLER
    {
        EPT_PTE* Pte;
        PAGE_HANDLER Handlers;
    };

    static void InitializeEptTables(__in const MTRR_INFO* MtrrInfo, __out EPT_TABLES* Ept, __out EPTP* Eptp)
    {
        using namespace PhysicalMemory;

        memset(Ept, 0, sizeof(EPT_TABLES));
        memset(Eptp, 0, sizeof(EPTP));

        PVOID64 Pml4ePhys = GetPhysicalAddress(&Ept->Pml4e);
        Eptp->Bitmap.EptMemoryType = static_cast<unsigned char>(MTRR_MEMORY_TYPE::WriteBack);
        Eptp->Bitmap.PageWalkLength = 3;
        Eptp->Bitmap.AccessedAndDirtyFlagsSupport = FALSE;
        Eptp->Bitmap.EptPml4ePhysicalPfn = PAGE_TO_PFN(reinterpret_cast<UINT64>(Pml4ePhys));

        PVOID64 PdptePhys = GetPhysicalAddress(Ept->Pdpte);
        Ept->Pml4e.Page2Mb.ReadAccess = TRUE;
        Ept->Pml4e.Page2Mb.WriteAccess = TRUE;
        Ept->Pml4e.Page2Mb.ExecuteAccess = TRUE;
        Ept->Pml4e.Page2Mb.EptPdptePhysicalPfn = PAGE_TO_PFN(reinterpret_cast<UINT64>(PdptePhys));

        for (unsigned int i = 0; i < _ARRAYSIZE(Ept->Pdpte); ++i)
        {
            PVOID64 PdePhys = GetPhysicalAddress(Ept->Pde[i]);
            Ept->Pdpte[i].Page2Mb.ReadAccess = TRUE;
            Ept->Pdpte[i].Page2Mb.WriteAccess = TRUE;
            Ept->Pdpte[i].Page2Mb.ExecuteAccess = TRUE;
            Ept->Pdpte[i].Page2Mb.EptPdePhysicalPfn = PAGE_TO_PFN(reinterpret_cast<UINT64>(PdePhys));

            for (unsigned int j = 0; j < _ARRAYSIZE(Ept->Pde[i]); ++j)
            {
                if (i == 0 && j == 0)
                {
                    PVOID64 PtePhys = GetPhysicalAddress(Ept->PteForFirstLargePage);
                    Ept->Pde[i][j].Page4Kb.ReadAccess = TRUE;
                    Ept->Pde[i][j].Page4Kb.WriteAccess = TRUE;
                    Ept->Pde[i][j].Page4Kb.ExecuteAccess = TRUE;
                    Ept->Pde[i][j].Page4Kb.EptPtePhysicalPfn = PAGE_TO_PFN(reinterpret_cast<UINT64>(PtePhys));

                    for (unsigned int k = 0; k < _ARRAYSIZE(Ept->PteForFirstLargePage); ++k)
                    {
                        MTRR_MEMORY_TYPE MemType = MTRR_MEMORY_TYPE::Uncacheable;
                        if (MtrrInfo->IsSupported)
                        {
                            MemType = GetMtrrMemoryType(MtrrInfo, PFN_TO_PAGE(static_cast<unsigned long long>(k)), PAGE_SIZE);
                        }

                        Ept->PteForFirstLargePage[k].Page4Kb.ReadAccess = TRUE;
                        Ept->PteForFirstLargePage[k].Page4Kb.WriteAccess = TRUE;
                        Ept->PteForFirstLargePage[k].Page4Kb.ExecuteAccess = TRUE;
                        Ept->PteForFirstLargePage[k].Page4Kb.Type = static_cast<unsigned char>(MemType);
                        Ept->PteForFirstLargePage[k].Page4Kb.PagePhysicalPfn = k;
                    }
                }
                else
                {
                    unsigned long long PagePfn = i * _ARRAYSIZE(Ept->Pde[i]) + j;
                    constexpr unsigned long long LargePageSize = 2 * 1048576; // 2 Mb

                    MTRR_MEMORY_TYPE MemType = MTRR_MEMORY_TYPE::Uncacheable;
                    if (MtrrInfo->IsSupported)
                    {
                        MemType = GetMtrrMemoryType(MtrrInfo, PFN_TO_LARGE_PAGE(PagePfn), LargePageSize);
                    }

                    Ept->Pde[i][j].Page2Mb.ReadAccess = TRUE;
                    Ept->Pde[i][j].Page2Mb.WriteAccess = TRUE;
                    Ept->Pde[i][j].Page2Mb.ExecuteAccess = TRUE;
                    Ept->Pde[i][j].Page2Mb.Type = static_cast<unsigned char>(MemType);
                    Ept->Pde[i][j].Page2Mb.LargePage = TRUE;
                    Ept->Pde[i][j].Page2Mb.PagePhysicalPfn = PagePfn;
                }
            }
        }
    }

    bool GetEptEntries(unsigned long long PhysicalAddress, const EPT_TABLES& Ept, __out EPT_ENTRIES& Entries)
    {
        VIRTUAL_ADDRESS Addr;
        Addr.x64.Value = PhysicalAddress;

        // Our EPT supports only one PML4E (512 Gb of the physical address space):
        if (Addr.x64.Generic.PageMapLevel4Offset > 0)
        {
            __stosq(reinterpret_cast<unsigned long long*>(&Entries), 0, sizeof(Entries) / sizeof(unsigned long long));
            return false;
        }

        auto PdpteIndex = Addr.x64.NonPageSize.Generic.PageDirectoryPointerOffset;
        auto PdeIndex = Addr.x64.NonPageSize.Generic.PageDirectoryOffset;

        Entries.Pml4e = const_cast<EPT_PML4E*>(&Ept.Pml4e);
        Entries.Pdpte = const_cast<EPT_PDPTE*>(&Ept.Pdpte[PdpteIndex]);
        Entries.Pde = const_cast<EPT_PDE*>(&Ept.Pde[PdpteIndex][PdeIndex]);
        if (Entries.Pde->Generic.LargePage)
        {
            Entries.Pte = reinterpret_cast<EPT_PTE*>(NULL);
        }
        else
        {
            PVOID64 PtPhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Entries.Pde->Page4Kb.EptPtePhysicalPfn));
            PVOID PtVa = PhysicalMemory::GetVirtualForPhysical(PtPhys);
            Entries.Pte = &((reinterpret_cast<EPT_PTE*>(PtVa))[Addr.x64.NonPageSize.Page4Kb.PageTableOffset]);
        }

        return true;
    }

    void BuildPtesForPde(__in const EPT_PDE& Pde, __out LARGE_PAGE_LAYOUT& Ptes)
    {
        for (unsigned int i = 0; i < ARRAYSIZE(Ptes.Pte); ++i)
        {
            Ptes.Pte[i].Page4Kb.ReadAccess = TRUE;
            Ptes.Pte[i].Page4Kb.WriteAccess = TRUE;
            Ptes.Pte[i].Page4Kb.ExecuteAccess = TRUE;
            Ptes.Pte[i].Page4Kb.Type = Pde.Page2Mb.Type;
            Ptes.Pte[i].Page4Kb.PagePhysicalPfn = PAGE_TO_PFN(PFN_TO_LARGE_PAGE(Pde.Page2Mb.PagePhysicalPfn)) + i;
        }
    }

    void BuildPageHandler(MTRR_MEMORY_TYPE CacheType, UINT64 ReadPa, UINT64 WritePa, UINT64 ExecutePa, UINT64 ExecuteReadPa, UINT64 ExecuteWritePa, __out PAGE_HANDLER& Handler)
    {
        Handler.OnRead.Value = 0;
        Handler.OnWrite.Value = 0;
        Handler.OnExecute.Value = 0;
        Handler.OnExecuteRead.Value = 0;
        Handler.OnExecuteWrite.Value = 0;

        if (ReadPa)
        {
            Handler.OnRead.Page4Kb.ReadAccess = TRUE;
            Handler.OnRead.Page4Kb.Type = static_cast<unsigned long long>(CacheType);
            Handler.OnRead.Page4Kb.PagePhysicalPfn = PAGE_TO_PFN(ReadPa);
        }

        if (WritePa)
        {
            // We're unable to make a write-only page:
            Handler.OnWrite.Page4Kb.ReadAccess = TRUE; // Without it we will get the EPT_MISCONFIGURATION error
            Handler.OnWrite.Page4Kb.WriteAccess = TRUE;
            Handler.OnWrite.Page4Kb.Type = static_cast<unsigned long long>(CacheType);
            Handler.OnWrite.Page4Kb.PagePhysicalPfn = PAGE_TO_PFN(WritePa);
        }

        if (ExecutePa)
        {
            Handler.OnExecute.Page4Kb.ExecuteAccess = TRUE;
            Handler.OnExecute.Page4Kb.Type = static_cast<unsigned long long>(CacheType);
            Handler.OnExecute.Page4Kb.PagePhysicalPfn = PAGE_TO_PFN(ExecutePa);
        }

        if (ExecuteReadPa)
        {
            Handler.OnExecuteRead.Page4Kb.ReadAccess = TRUE;
            Handler.OnExecuteRead.Page4Kb.ExecuteAccess = TRUE;
            Handler.OnExecuteRead.Page4Kb.Type = static_cast<unsigned long long>(CacheType);
            Handler.OnExecuteRead.Page4Kb.PagePhysicalPfn = PAGE_TO_PFN(ExecuteReadPa);
        }

        if (ExecuteWritePa)
        {
            Handler.OnExecuteWrite.Page4Kb.ReadAccess = TRUE;
            Handler.OnExecuteWrite.Page4Kb.WriteAccess = TRUE;
            Handler.OnExecuteWrite.Page4Kb.ExecuteAccess = TRUE;
            Handler.OnExecuteWrite.Page4Kb.Type = static_cast<unsigned long long>(CacheType);
            Handler.OnExecuteWrite.Page4Kb.PagePhysicalPfn = PAGE_TO_PFN(ExecuteWritePa);
        }

        if (ReadPa && (ReadPa == WritePa))
        {
            Handler.OnRead.Page4Kb.WriteAccess = TRUE;
            Handler.OnWrite.Page4Kb.ReadAccess = TRUE;
        }

        if (WritePa && (WritePa == ExecutePa))
        {
            Handler.OnWrite.Page4Kb.ExecuteAccess = TRUE;
            Handler.OnExecute.Page4Kb.WriteAccess = TRUE;
        }

        if (ExecutePa && (ReadPa == ExecutePa))
        {
            Handler.OnRead.Page4Kb.ExecuteAccess = TRUE;
            Handler.OnExecute.Page4Kb.ReadAccess = TRUE;
        }

        if (ExecuteReadPa && (ExecuteReadPa == ExecuteWritePa))
        {
            Handler.OnExecuteRead.Page4Kb.WriteAccess = TRUE;
        }
    }

    static size_t vmread(size_t field);

    class EptHandler final
    {
    private:
        EPT_TABLES* m_Ept;
        std::unordered_map<uint64_t, LARGE_PAGE_DESCRIPTOR> m_PageDescriptors; // Guest PA (aligned by 2Mb) -> 4Kb PTEs describing a 2Mb page
        std::unordered_map<uint64_t, EPT_PTE_HANDLER> m_Handlers; // Guest PA (aligned by 4Kb) -> Page handlers (EPT entries for RWX)
        VMX::INVEPT_DESCRIPTOR m_InveptDescriptor;

        struct
        {
            const void* Rip;
            EPT_PTE* Pte;
            EPT_PTE PendingPrevEntry;
        } m_PendingHandler;

        constexpr static unsigned int PageSize = 4096;
        constexpr static unsigned int LargePageSize = 2 * 1048576;

        inline void invept()
        {
            __invept(VMX::INVEPT_TYPE::SingleContextInvalidation, &m_InveptDescriptor);
        }

    public:
        EptHandler(__in EPT_TABLES* Ept)
            : m_Ept(Ept)
            , m_PendingHandler({})
            , m_InveptDescriptor({})
        {}

        ~EptHandler()
        {
            for (auto& [_, Desc] : m_PageDescriptors)
            {
                *Desc.Pde = Desc.OriginalPde;
                Supplementation::FreePhys(Desc.Layout);
            }
        }

        void CompleteInitialization(VMX::EPTP Eptp)
        {
            m_InveptDescriptor.Eptp = Eptp.Value;
        }

        void InterceptPage(
            unsigned long long Pa,
            unsigned long long ReadPa,
            unsigned long long WritePa,
            unsigned long long ExecutePa,
            unsigned long long ExecuteReadPa,
            unsigned long long ExecuteWritePa
        ) {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto HandlerEntry = m_Handlers.find(Pa4Kb);
            if (HandlerEntry != m_Handlers.end())
            {
                PAGE_HANDLER Handler = {};
                BuildPageHandler(static_cast<MTRR_MEMORY_TYPE>(HandlerEntry->second.Handlers.OnRead.Page4Kb.Type), ReadPa, WritePa, ExecutePa, ExecuteReadPa, ExecuteWritePa, OUT Handler);
                HandlerEntry->second.Handlers = Handler;
                *HandlerEntry->second.Pte = Handler.OnRead;
                invept();
                return;
            }

            unsigned long long Pa2Mb = ALIGN_DOWN_BY(Pa, LargePageSize);
            auto DescriptorEntry = m_PageDescriptors.find(Pa2Mb);
            if (DescriptorEntry == m_PageDescriptors.end())
            {
                EPT_ENTRIES EptEntries;
                GetEptEntries(Pa2Mb, *m_Ept, OUT EptEntries);

                LARGE_PAGE_DESCRIPTOR Desc = {
                    .Pde = EptEntries.Pde,
                    .OriginalPde = *EptEntries.Pde,
                    .Layout = reinterpret_cast<LARGE_PAGE_LAYOUT*>(Supplementation::AllocPhys(sizeof(LARGE_PAGE_LAYOUT)))
                };

                BuildPtesForPde(Desc.OriginalPde, OUT *Desc.Layout);

                DescriptorEntry = m_PageDescriptors.emplace(Pa2Mb, Desc).first;
            }

            auto& Descriptor = DescriptorEntry->second;
            auto* Pde = &Descriptor.Pde->Page4Kb;
            Pde->LargePage = FALSE;
            Pde->Reserved0 = 0;
            Pde->EptPtePhysicalPfn = PAGE_TO_PFN(reinterpret_cast<uint64_t>(PhysicalMemory::GetPhysicalAddress(Descriptor.Layout)));

            unsigned long long PteIndex = (Pa - Pa2Mb) / PageSize;
            auto* Pte = &Descriptor.Layout->Pte[PteIndex];

            EPT_PTE_HANDLER Handler = {};
            BuildPageHandler(static_cast<MTRR_MEMORY_TYPE>(DescriptorEntry->second.OriginalPde.Page2Mb.Type), ReadPa, WritePa, ExecutePa, ExecuteReadPa, ExecuteWritePa, OUT Handler.Handlers);
            Handler.Pte = Pte;
            m_Handlers.emplace(Pa4Kb, Handler);

            *Pte = Handler.Handlers.OnRead;
            invept();
        }

        void DeinterceptPage(unsigned long long Pa)
        {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto HandlerEntry = m_Handlers.find(Pa4Kb);
            if (HandlerEntry != m_Handlers.end())
            {
                m_Handlers.erase(HandlerEntry);
            }

            if (m_Handlers.empty())
            {
                unsigned long long Pa2Mb = ALIGN_DOWN_BY(Pa, LargePageSize);
                auto DescriptorEntry = m_PageDescriptors.find(Pa2Mb);
                if (DescriptorEntry != m_PageDescriptors.end())
                {
                    auto& Desc = DescriptorEntry->second;
                    *Desc.Pde = Desc.OriginalPde;
                    Supplementation::FreePhys(Desc.Layout);
                    m_PageDescriptors.erase(DescriptorEntry);
                    invept();
                }
            }
        }

        bool HandleRead(unsigned long long Pa)
        {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto Handler = m_Handlers.find(Pa4Kb);
            if (Handler == m_Handlers.end())
            {
                return false;
            }

            auto& Entry = Handler->second;
            auto PteEntry = Entry.Handlers.OnRead;
            if (!PteEntry.Value)
            {
                return false;
            }

            *Entry.Pte = PteEntry;
            invept();

            return true;
        }

        bool HandleWrite(unsigned long long Pa, const void* NextInstruction)
        {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto Handler = m_Handlers.find(Pa4Kb);
            if (Handler == m_Handlers.end())
            {
                return false;
            }

            auto& HandlerEntry = Handler->second;
            if (!HandlerEntry.Handlers.OnWrite.Value)
            {
                return false;
            }

            auto* Pte = HandlerEntry.Pte;
            
            m_PendingHandler.Rip = NextInstruction;
            m_PendingHandler.Pte = Pte;
            m_PendingHandler.PendingPrevEntry = *Pte;

            *Pte = HandlerEntry.Handlers.OnWrite;
            invept();

            return true;
        }

        bool HandleExecute(unsigned long long Pa)
        {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto Handler = m_Handlers.find(Pa4Kb);
            if (Handler == m_Handlers.end())
            {
                return false;
            }

            auto& Entry = Handler->second;
            auto PteEntry = Entry.Handlers.OnExecute;
            if (!PteEntry.Value)
            {
                return false;
            }

            *Entry.Pte = PteEntry;
            invept();

            return true;
        }

        bool HandleExecuteRead(unsigned long long Pa, const void* NextInstruction)
        {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto Handler = m_Handlers.find(Pa4Kb);
            if (Handler == m_Handlers.end())
            {
                return false;
            }

            auto& HandlerEntry = Handler->second;
            if (!HandlerEntry.Handlers.OnExecuteRead.Value)
            {
                return false;
            }

            auto* Pte = HandlerEntry.Pte;

            m_PendingHandler.Rip = NextInstruction;
            m_PendingHandler.Pte = Pte;
            m_PendingHandler.PendingPrevEntry = *Pte;

            *Pte = HandlerEntry.Handlers.OnExecuteRead;
            invept();

            return true;
        }

        bool HandleExecuteWrite(unsigned long long Pa, const void* NextInstruction)
        {
            unsigned long long Pa4Kb = ALIGN_DOWN_BY(Pa, PageSize);
            auto Handler = m_Handlers.find(Pa4Kb);
            if (Handler == m_Handlers.end())
            {
                return false;
            }

            auto& HandlerEntry = Handler->second;
            if (!HandlerEntry.Handlers.OnExecuteWrite.Value)
            {
                return false;
            }

            auto* Pte = HandlerEntry.Pte;

            m_PendingHandler.Rip = NextInstruction;
            m_PendingHandler.Pte = Pte;
            m_PendingHandler.PendingPrevEntry = *Pte;

            *Pte = HandlerEntry.Handlers.OnExecuteWrite;
            invept();

            return true;
        }

        bool CompletePendingHandler(const void* Rip)
        {
            if (m_PendingHandler.Rip != Rip)
            {
                return false;
            }

            *m_PendingHandler.Pte = m_PendingHandler.PendingPrevEntry;
            m_PendingHandler.Rip = NULL;

            invept();

            return true;
        }
    };

    struct SHARED_VM_DATA;

    // Unique for each processor:
    struct PRIVATE_VM_DATA
    {
        union
        {
            DECLSPEC_ALIGN(PAGE_SIZE) unsigned char VmmStack[KERNEL_STACK_SIZE];
            struct
            {
                struct INITIAL_VMM_STACK_LAYOUT
                {
                    PVOID VmcsPa;
                    SHARED_VM_DATA* Shared;
                    PRIVATE_VM_DATA* Private;
                };
                unsigned char FreeSpace[KERNEL_STACK_SIZE - sizeof(INITIAL_VMM_STACK_LAYOUT)];
                INITIAL_VMM_STACK_LAYOUT InitialStack;
            } Layout;
        } VmmStack;

        DECLSPEC_ALIGN(PAGE_SIZE) VMCS Vmxon; // VMXON structure is the same as VMCS with the same size
        DECLSPEC_ALIGN(PAGE_SIZE) VMCS Vmcs;
        DECLSPEC_ALIGN(PAGE_SIZE) MSR_BITMAP MsrBitmap;
        DECLSPEC_ALIGN(PAGE_SIZE) EPT_TABLES Ept;
        DESCRIPTOR_TABLE_REGISTER_LONG Gdtr;
        DESCRIPTOR_TABLE_REGISTER_LONG Idtr;
        EptHandler* EptInterceptor;
    };

    struct VCPU_INFO
    {
        PRIVATE_VM_DATA* VmData;
        MTRR_INFO* MtrrInfo;
        VMX::VM_INSTRUCTION_ERROR Error;
        bool Status;
    };

    struct SHARED_VM_DATA
    {
        VCPU_INFO* Processors; // Array: VCPU_INFO Processors[ProcessorsCount]
        unsigned long long KernelCr3;
        unsigned int ProcessorsCount;
    };

    static SHARED_VM_DATA g_Shared = {};


    bool InterceptPage(
        unsigned long long PagePa,
        __in_opt unsigned long long OnReadPa,
        __in_opt unsigned long long OnWritePa,
        __in_opt unsigned long long OnExecutePa,
        __in_opt unsigned long long OnExecuteReadPa,
        __in_opt unsigned long long OnExecuteWritePa
    ) {
        struct INTERCEPT_INFO
        {
            unsigned long long Pa;
            unsigned long long R, W, X, RX, WX;
        };

        INTERCEPT_INFO Info = { PagePa, OnReadPa, OnWritePa, OnExecutePa, OnExecuteReadPa, OnExecuteWritePa };
        Callable::DpcOnEachCpu([](void* Arg)
        {
            VMCALLS::VmmCall([](void* Arg) -> unsigned long long
            {
                auto* Info = reinterpret_cast<INTERCEPT_INFO*>(Arg);
                g_Shared.Processors[KeGetCurrentProcessorNumber()].VmData->EptInterceptor->InterceptPage(Info->Pa, Info->R, Info->W, Info->X, Info->RX, Info->WX);
                return 0;
            }, Arg);
        }, &Info);

        return true;
    }

    void DeinterceptPage(unsigned long long PagePa)
    {
        Callable::DpcOnEachCpu([](void* Arg)
        {
            VMCALLS::VmmCall([](void* Arg) -> unsigned long long
            {
                auto Page = reinterpret_cast<unsigned long long>(Arg);
                g_Shared.Processors[KeGetCurrentProcessorNumber()].VmData->EptInterceptor->DeinterceptPage(Page);
                return 0;
            }, Arg);
        }, reinterpret_cast<void*>(PagePa));
    }

    static unsigned long long ExtractSegmentBaseAddress(const SEGMENT_DESCRIPTOR_LONG* SegmentDescriptor)
    {
        if (SegmentDescriptor->Generic.System == 0)
        {
            // System segment (16 bytes):
            auto* Descriptor = reinterpret_cast<const SYSTEM_SEGMENT_DESCRIPTOR_LONG*>(SegmentDescriptor);
            return (static_cast<unsigned long long>(Descriptor->Bitmap.BaseAddressHighest) << 32)
                | (static_cast<unsigned long long>(Descriptor->Bitmap.BaseAddressHigh) << 24)
                | (static_cast<unsigned long long>(Descriptor->Bitmap.BaseAddressMiddle) << 16)
                | (static_cast<unsigned long long>(Descriptor->Bitmap.BaseAddressLow));
        }
        else
        {
            // User segment (8 bytes):
            auto* Descriptor = reinterpret_cast<const USER_SEGMENT_DESCRIPTOR_LONG*>(SegmentDescriptor);
            return (static_cast<unsigned long long>(Descriptor->Generic.BaseAddressHigh) << 24)
                | (static_cast<unsigned long long>(Descriptor->Generic.BaseAddressMiddle) << 16)
                | (static_cast<unsigned long long>(Descriptor->Generic.BaseAddressLow));
        }
    }

    struct SEGMENT_INFO
    {
        unsigned long long BaseAddress;
        unsigned int Limit;
        SEGMENT_ACCESS_RIGHTS AccessRights;
        unsigned short Selector;
    };

    static void ParseSegmentInfo(
        const SEGMENT_DESCRIPTOR_LONG* Gdt,
        const SEGMENT_DESCRIPTOR_LONG* Ldt,
        unsigned short Selector,
        __out SEGMENT_INFO* Info
    ) {
        *Info = {};

        SEGMENT_SELECTOR SegmentSelector;
        SegmentSelector.Value = Selector;

        auto* SegmentDescriptor = SegmentSelector.Bitmap.TableIndicator == 0
            ? reinterpret_cast<const SEGMENT_DESCRIPTOR_LONG*>(&Gdt[SegmentSelector.Bitmap.SelectorIndex])
            : reinterpret_cast<const SEGMENT_DESCRIPTOR_LONG*>(&Ldt[SegmentSelector.Bitmap.SelectorIndex]);

        Info->BaseAddress = ExtractSegmentBaseAddress(SegmentDescriptor);
        Info->Limit = GetSegmentLimit(Selector);

        Info->AccessRights.Bitmap.SegmentType = SegmentDescriptor->Generic.Type;
        Info->AccessRights.Bitmap.S = SegmentDescriptor->Generic.System;
        Info->AccessRights.Bitmap.DPL = SegmentDescriptor->Generic.Dpl;
        Info->AccessRights.Bitmap.P = SegmentDescriptor->Generic.Present;
        Info->AccessRights.Bitmap.AVL = SegmentDescriptor->Generic.Available;
        Info->AccessRights.Bitmap.L = SegmentDescriptor->Generic.LongMode;
        Info->AccessRights.Bitmap.DB = SegmentDescriptor->Generic.System == 1 // If it is a user segment descriptor:
            ? reinterpret_cast<const USER_SEGMENT_DESCRIPTOR_LONG*>(SegmentDescriptor)->Generic.DefaultOperandSize
            : 0; // The DefaultOperandSize is not applicable to system segments and marked as reserved!
        Info->AccessRights.Bitmap.G = SegmentDescriptor->Generic.Granularity;
        Info->AccessRights.Bitmap.SegmentUnusable = static_cast<unsigned int>(!Info->AccessRights.Bitmap.P);
        
        Info->Selector = Selector;
    }

    inline unsigned long long GetVpid()
    {
        return static_cast<unsigned long long>(KeGetCurrentProcessorNumber()) + 1ull;
    }

    union CONTROLS_MASK
    {
        unsigned long long Value;
        struct
        {
            unsigned long long Allowed0Settings : 32;
            unsigned long long Allowed1Settings : 32;
        } Bitmap;
    };

    CONTROLS_MASK GetCr0Mask()
    {
        CONTROLS_MASK Mask = {};
        Mask.Bitmap.Allowed0Settings = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_CR0_FIXED0));
        Mask.Bitmap.Allowed1Settings = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_CR0_FIXED1));
        return Mask;
    }

    CONTROLS_MASK GetCr4Mask()
    {
        CONTROLS_MASK Mask = {};
        Mask.Bitmap.Allowed0Settings = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_CR4_FIXED0));
        Mask.Bitmap.Allowed1Settings = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_CR4_FIXED1));
        return Mask;
    }

    CONTROLS_MASK GetPinControlsMask(IA32_VMX_BASIC VmxBasic)
    {
        CONTROLS_MASK Mask = {};
        if (VmxBasic.Bitmap.AnyVmxControlsThatDefaultToOneMayBeZeroed) {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_TRUE_PINBASED_CTLS));
        } else {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_PINBASED_CTLS));
        }

        return Mask;
    }
    
    CONTROLS_MASK GetPrimaryControlsMask(IA32_VMX_BASIC VmxBasic)
    {
        CONTROLS_MASK Mask = {};
        if (VmxBasic.Bitmap.AnyVmxControlsThatDefaultToOneMayBeZeroed) {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_TRUE_PROCBASED_CTLS));
        } else {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_PROCBASED_CTLS));
        }
        
        return Mask;
    }

    CONTROLS_MASK GetVmexitControlsMask(IA32_VMX_BASIC VmxBasic)
    {
        CONTROLS_MASK Mask = {};
        if (VmxBasic.Bitmap.AnyVmxControlsThatDefaultToOneMayBeZeroed) {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_TRUE_EXIT_CTLS));
        } else {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_EXIT_CTLS));
        }
        
        return Mask;
    }

    CONTROLS_MASK GetVmentryControlsMask(IA32_VMX_BASIC VmxBasic)
    {
        CONTROLS_MASK Mask = {};
        if (VmxBasic.Bitmap.AnyVmxControlsThatDefaultToOneMayBeZeroed) {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_TRUE_ENTRY_CTLS));
        } else {
            Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_ENTRY_CTLS));
        }

        return Mask;
    }

    CONTROLS_MASK GetSecondaryControlsMask()
    {
        CONTROLS_MASK Mask = {};
        Mask.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_PROCBASED_CTLS2));
        return Mask;
    }
    
    template <typename T>
    static T ApplyMask(T VmxControlReg, CONTROLS_MASK Mask)
    {
        VmxControlReg.Value &= Mask.Bitmap.Allowed1Settings;
        VmxControlReg.Value |= Mask.Bitmap.Allowed0Settings;
        return VmxControlReg;
    }

    static size_t vmread(size_t field)
    {
        size_t value = 0;
        __vmx_vmread(field, &value);
        return value;
    }

    _IRQL_requires_(IPI_LEVEL)
    static bool VirtualizeProcessor(__inout SHARED_VM_DATA* Shared)
    {
        using namespace PhysicalMemory;

        volatile LONG IsVirtualized = FALSE;
        InterlockedExchange(&IsVirtualized, FALSE);

        volatile LONG ContextHasBeenRestored = FALSE;
        InterlockedExchange(&ContextHasBeenRestored, FALSE);
        
        volatile unsigned int CurrentProcessor = KeGetCurrentProcessorNumber();
        unsigned int Vpid = CurrentProcessor + 1;

        CONTEXT Context = {};
        Context.ContextFlags = CONTEXT_ALL;
        RtlCaptureContext(&Context);

        if (InterlockedCompareExchange(&IsVirtualized, TRUE, TRUE) == TRUE)
        {
            if (InterlockedCompareExchange(&ContextHasBeenRestored, FALSE, FALSE) == FALSE)
            {
                InterlockedExchange(&ContextHasBeenRestored, TRUE);
                RtlRestoreContext(&Context, NULL);
            }

            Shared->Processors[CurrentProcessor].Status = true;
            _mm_sfence();

            return true;
        }

        IA32_VMX_BASIC VmxBasicInfo = { __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_VMX_BASIC)) };

        PRIVATE_VM_DATA* Private = Shared->Processors[CurrentProcessor].VmData;
        if (!Private)
        {
            return false;
        }

        Private->Vmxon.RevisionId.Bitmap.VmcsRevisionId = VmxBasicInfo.Bitmap.VmcsRevision;
        Private->Vmcs.RevisionId.Bitmap.VmcsRevisionId = VmxBasicInfo.Bitmap.VmcsRevision;

        void* VmxonPa = GetPhysicalAddress(&Private->Vmxon);
        Private->VmmStack.Layout.InitialStack.Shared = Shared;
        Private->VmmStack.Layout.InitialStack.VmcsPa = GetPhysicalAddress(&Private->Vmcs);
        Private->VmmStack.Layout.InitialStack.Private = Private;

        CR0 Cr0 = { __readcr0() };
        Cr0 = ApplyMask(Cr0, GetCr0Mask());
        __writecr0(Cr0.Value);

        // Enable the VMX instructions set:
        CR4 Cr4 = { __readcr4() };
        Cr4.x64.Bitmap.VMXE = TRUE;
        Cr4.x64.Bitmap.PCIDE = TRUE;
        Cr4 = ApplyMask(Cr4, GetCr4Mask());
        __writecr4(Cr4.Value);

        unsigned char VmxStatus = 0;

        // Entering the VMX root-mode:
        VmxStatus =  __vmx_on(reinterpret_cast<unsigned long long*>(&VmxonPa));
        if (VmxStatus != 0)
        {
            return false;
        }

        // Resetting the guest VMCS:
        VmxStatus = __vmx_vmclear(reinterpret_cast<unsigned long long*>(&Private->VmmStack.Layout.InitialStack.VmcsPa));
        if (VmxStatus != 0)
        {
            __vmx_off();
            return false;
        }

        // Loading the VMCS as current for the processor:
        VmxStatus = __vmx_vmptrld(reinterpret_cast<unsigned long long*>(&Private->VmmStack.Layout.InitialStack.VmcsPa));
        if (VmxStatus != 0)
        {
            __vmx_off();
            return false;
        }

        __vmx_vmwrite(VMX::VMCS_FIELD_VMCS_LINK_POINTER_FULL, 0xFFFFFFFFFFFFFFFFULL);
        __vmx_vmwrite(VMX::VMCS_FIELD_VIRTUAL_PROCESSOR_IDENTIFIER, Vpid);

        /* CR0 was already read above */
        __vmx_vmwrite(VMX::VMCS_FIELD_CR0_READ_SHADOW, Cr0.x64.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CR0, Cr0.x64.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_CR0, Cr0.x64.Value);

        CR3 Cr3 = { __readcr3() };
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CR3, Cr3.x64.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_CR3, Shared->KernelCr3);

        /* CR4 was already read above */
        CR4 Cr4Mask = Cr4;
        __vmx_vmwrite(VMX::VMCS_FIELD_CR4_READ_SHADOW, Cr4.x64.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CR4, Cr4.x64.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_CR4, Cr4.x64.Value);

        DR7 Dr7 = { __readdr(7) };
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_DR7, Dr7.x64.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_IA32_DEBUGCTL_FULL, __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_DEBUGCTL)));

        __vmx_vmwrite(VMX::VMCS_FIELD_ADDRESS_OF_MSR_BITMAPS_FULL, reinterpret_cast<UINT64>(GetPhysicalAddress(Private->MsrBitmap.MsrBitmap)));

        DESCRIPTOR_TABLE_REGISTER_LONG Gdtr = {}, Idtr = {};
        _sgdt(&Gdtr);
        __sidt(&Idtr);
        Private->Gdtr = Gdtr;
        Private->Idtr = Idtr;

        SEGMENT_SELECTOR Tr = {}, Ldtr = {};
        _sldt(&Ldtr);
        _str(&Tr);

        const auto* Gdt = reinterpret_cast<const SEGMENT_DESCRIPTOR_LONG*>(Gdtr.BaseAddress);
        __assume(Gdt != nullptr);
        const auto* LdtDescriptorInGdt = reinterpret_cast<const SEGMENT_DESCRIPTOR_LONG*>(&Gdt[Ldtr.Bitmap.SelectorIndex]);
        const auto* Ldt = reinterpret_cast<const SEGMENT_DESCRIPTOR_LONG*>(ExtractSegmentBaseAddress(LdtDescriptorInGdt));

        // These fields must be zeroed in host state selector values:
        constexpr unsigned short RPL_MASK = 0b11; // Requested privilege level
        constexpr unsigned short TI_MASK = 0b100; // Table indicator
        constexpr unsigned short HOST_SELECTOR_MASK = TI_MASK | RPL_MASK;

        SEGMENT_INFO SegmentInfo = {};

        ParseSegmentInfo(Gdt, Ldt, Context.SegEs, OUT &SegmentInfo);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_ES_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_ES_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_ES_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_ES_BASE, SegmentInfo.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_ES_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);

        ParseSegmentInfo(Gdt, Ldt, Context.SegCs, OUT &SegmentInfo);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CS_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CS_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CS_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_CS_BASE, SegmentInfo.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_CS_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);

        ParseSegmentInfo(Gdt, Ldt, Context.SegSs, OUT &SegmentInfo);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_SS_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_SS_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_SS_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_SS_BASE, SegmentInfo.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_SS_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);

        ParseSegmentInfo(Gdt, Ldt, Context.SegDs, OUT &SegmentInfo);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_DS_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_DS_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_DS_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_DS_BASE, SegmentInfo.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_DS_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);

        ParseSegmentInfo(Gdt, Ldt, Context.SegFs, OUT &SegmentInfo);
        unsigned long long FsBaseAddress = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_FS_BASE));
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_FS_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_FS_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_FS_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_FS_BASE, FsBaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_FS_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_FS_BASE, FsBaseAddress);

        ParseSegmentInfo(Gdt, Ldt, Context.SegGs, OUT &SegmentInfo);
        unsigned long long GsBaseAddress = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_GS_BASE));
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_GS_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_GS_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_GS_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_GS_BASE, GsBaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_GS_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_GS_BASE, GsBaseAddress);

        ParseSegmentInfo(Gdt, Ldt, Ldtr.Value, OUT &SegmentInfo);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_LDTR_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_LDTR_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_LDTR_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_LDTR_BASE, SegmentInfo.BaseAddress);

        ParseSegmentInfo(Gdt, Ldt, Tr.Value, OUT &SegmentInfo);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_TR_SELECTOR, SegmentInfo.Selector);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_TR_LIMIT, SegmentInfo.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_TR_ACCESS_RIGHTS, SegmentInfo.AccessRights.Value);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_TR_BASE, SegmentInfo.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_TR_SELECTOR, SegmentInfo.Selector & ~HOST_SELECTOR_MASK);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_TR_BASE, SegmentInfo.BaseAddress);

        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_GDTR_LIMIT, Gdtr.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_GDTR_BASE, Gdtr.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_GDTR_BASE, Gdtr.BaseAddress);

        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_IDTR_LIMIT, Idtr.Limit);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_IDTR_BASE, Idtr.BaseAddress);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_IDTR_BASE, Idtr.BaseAddress);

        EPTP Eptp = {};
        InitializeEptTables(IN Shared->Processors[CurrentProcessor].MtrrInfo, OUT &Private->Ept, OUT &Eptp);
        __vmx_vmwrite(VMX::VMCS_FIELD_EPT_POINTER_FULL, Eptp.Value);
        Private->EptInterceptor->CompleteInitialization(Eptp);

        PIN_BASED_VM_EXECUTION_CONTROLS PinControls = {};
        PinControls = ApplyMask(PinControls, GetPinControlsMask(VmxBasicInfo));
        __vmx_vmwrite(VMX::VMCS_FIELD_PIN_BASED_VM_EXECUTION_CONTROLS, PinControls.Value);

        PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS PrimaryControls = {};
        PrimaryControls.Bitmap.UseMsrBitmaps = TRUE;
        PrimaryControls.Bitmap.ActivateSecondaryControls = TRUE;
        PrimaryControls = ApplyMask(PrimaryControls, GetPrimaryControlsMask(VmxBasicInfo));
        __vmx_vmwrite(VMX::VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS, PrimaryControls.Value);

        VMEXIT_CONTROLS VmexitControls = {};
        VmexitControls.Bitmap.SaveDebugControls = TRUE;
        VmexitControls.Bitmap.HostAddressSpaceSize = TRUE;
        VmexitControls = ApplyMask(VmexitControls, GetVmexitControlsMask(VmxBasicInfo));
        __vmx_vmwrite(VMX::VMCS_FIELD_VMEXIT_CONTROLS, VmexitControls.Value);

        VMENTRY_CONTROLS VmentryControls = {};
        VmentryControls.Bitmap.LoadDebugControls = TRUE;
        VmentryControls.Bitmap.Ia32ModeGuest = TRUE;
        VmentryControls = ApplyMask(VmentryControls, GetVmentryControlsMask(VmxBasicInfo));
        __vmx_vmwrite(VMX::VMCS_FIELD_VMENTRY_CONTROLS, VmentryControls.Value);

        SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS SecondaryControls = {};
        SecondaryControls.Bitmap.EnableEpt = TRUE;
        SecondaryControls.Bitmap.EnableRdtscp = TRUE;
        SecondaryControls.Bitmap.EnableVpid = TRUE;
        SecondaryControls.Bitmap.EnableInvpcid = TRUE;
        SecondaryControls.Bitmap.EnableVmFunctions = TRUE;
        SecondaryControls.Bitmap.EptViolation = FALSE;
        SecondaryControls.Bitmap.EnableXsavesXrstors = TRUE;
        SecondaryControls = ApplyMask(SecondaryControls, GetSecondaryControlsMask());
        __vmx_vmwrite(VMX::VMCS_FIELD_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS, SecondaryControls.Value);

        unsigned long long SysenterCs  = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_SYSENTER_CS));
        unsigned long long SysenterEsp = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_SYSENTER_ESP));
        unsigned long long SysenterEip = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_SYSENTER_EIP));

        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_IA32_SYSENTER_ESP, SysenterEsp);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_IA32_SYSENTER_EIP, SysenterEip);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RSP, Context.Rsp);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RIP, Context.Rip);
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RFLAGS, Context.EFlags);

        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_IA32_SYSENTER_CS, SysenterCs);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_IA32_SYSENTER_ESP, SysenterEsp);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_IA32_SYSENTER_EIP, SysenterEip);
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_RSP, reinterpret_cast<unsigned long long>(&Private->VmmStack.Layout.InitialStack));
        __vmx_vmwrite(VMX::VMCS_FIELD_HOST_RIP, reinterpret_cast<unsigned long long>(VmxVmmRun));

        InterlockedExchange(&IsVirtualized, TRUE);

        __vmx_vmlaunch();

        // If we're here - something went wrong:
        Shared->Processors[CurrentProcessor].Error = static_cast<VM_INSTRUCTION_ERROR>(vmread(VMX::VMCS_FIELD_VM_INSTRUCTION_ERROR));
        
        __vmx_off();
        
        return false;
    }

    void InjectEvent(INTERRUPTION_TYPE Type, INTERRUPT_VECTOR Vector, bool DeliverErrorCode, unsigned int ErrorCode)
    {
        VMENTRY_INTERRUPTION_INFORMATION Event = {};
        Event.Bitmap.VectorOfInterruptOrException = static_cast<unsigned int>(Vector) & 0xFF;
        Event.Bitmap.InterruptionType = static_cast<unsigned int>(Type) & 0b111;
        Event.Bitmap.DeliverErrorCode = DeliverErrorCode;
        Event.Bitmap.Valid = TRUE;
        __vmx_vmwrite(VMX::VMCS_FIELD_VMENTRY_INTERRUPTION_INFORMATION_FIELD, Event.Value);

        if (DeliverErrorCode)
        {
            __vmx_vmwrite(VMX::VMCS_FIELD_VMENTRY_EXCEPTION_ERROR_CODE, ErrorCode);
        }
    }

    void InjectMonitorTrapFlagVmExit()
    {
        // It is a special case of events injection:
        VMENTRY_INTERRUPTION_INFORMATION Event = {};
        Event.Bitmap.VectorOfInterruptOrException = 0;
        Event.Bitmap.InterruptionType = static_cast<unsigned int>(INTERRUPTION_TYPE::OtherEvent);
        Event.Bitmap.Valid = TRUE;
        __vmx_vmwrite(VMX::VMCS_FIELD_VMENTRY_INTERRUPTION_INFORMATION_FIELD, Event.Value);
    }

    void EnableMonitorTrapFlag()
    {
        VMX::PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS PrimaryControls = { static_cast<unsigned int>(vmread(VMX::VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS)) };
        PrimaryControls.Bitmap.MonitorTrapFlag = TRUE;
        __vmx_vmwrite(VMX::VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS, PrimaryControls.Value);
    }

    void DisableMonitorTrapFlag()
    {
        VMX::PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS PrimaryControls = { static_cast<unsigned int>(vmread(VMX::VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS)) };
        PrimaryControls.Bitmap.MonitorTrapFlag = FALSE;
        __vmx_vmwrite(VMX::VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS, PrimaryControls.Value);
    }

    void DisableGuestInterrupts()
    {
        RFLAGS Rflags = { vmread(VMX::VMCS_FIELD_GUEST_RFLAGS) };
        Rflags.Bitmap.Eflags.Bitmap.IF = FALSE;
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RFLAGS, Rflags.Value);
    }

    void EnableGuestInterrupts()
    {
        RFLAGS Rflags = { vmread(VMX::VMCS_FIELD_GUEST_RFLAGS) };
        Rflags.Bitmap.Eflags.Bitmap.IF = TRUE;
        __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RFLAGS, Rflags.Value);
    }

    bool IsMsrAllowed(unsigned int MsrIndex)
    {
        if (MsrIndex <= 0x1FFF || (MsrIndex >= 0xC0000000 && MsrIndex <= 0xC0001FFF))
        {
            // Intel MSR:
            return true;
        }
        else if (MsrIndex >= 0x40000000 && MsrIndex <= 0x4000109F)
        {
            // Hyper-V MSR:
            return true;
        }
        else
        {
            // Invalid MSR index:
            return false;
        }
    }

    // Returns NULL if RegNum is RSP:
    unsigned long long* GetRegPtr(unsigned char RegNum, __in GUEST_CONTEXT* Context)
    {
        switch (RegNum)
        {
        case 0:
            return &Context->Rax;
        case 1:
            return &Context->Rcx;
        case 2:
            return &Context->Rdx;
        case 3:
            return &Context->Rbx;
        case 4:
            // RSP (must be obtained by __vmx_vmread(VMCS_FIELD_GUEST_RSP)):
            return nullptr;
        case 5:
            return &Context->Rbp;
        case 6:
            return &Context->Rsi;
        case 7:
            return &Context->Rdi;
        case 8:
            return &Context->R8;
        case 9:
            return &Context->R9;
        case 10:
            return &Context->R10;
        case 11:
            return &Context->R11;
        case 12:
            return &Context->R12;
        case 13:
            return &Context->R13;
        case 14:
            return &Context->R14;
        case 15:
            return &Context->R15;
        default:
            return nullptr;
        }
    }

    namespace VmexitHandlers
    {
        using FnVmexitHandler = VMM_STATUS(*)(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction);

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS EmptyHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Context);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            __debugbreak();

            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS CpuidHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(RepeatInstruction);

            CPUID_REGS Regs = {};
            int Function = static_cast<int>(Context->Rax);
            if (Function == CPUID_VMM_SHUTDOWN)
            {
                Rip += vmread(VMX::VMCS_FIELD_VMEXIT_INSTRUCTION_LENGTH);

                size_t Rsp = vmread(VMX::VMCS_FIELD_GUEST_RSP);

                Context->Rax = reinterpret_cast<UINT64>(Private) & MAXUINT32; // Low part
                Context->Rbx = Rip; // Guest RIP
                Context->Rcx = Rsp; // Guest RSP
                Context->Rdx = reinterpret_cast<UINT64>(Private) >> 32; // High part

                _lgdt(&Private->Gdtr);
                __lidt(&Private->Idtr);

                CR3 Cr3 = {};
                Cr3.Value = vmread(VMX::VMCS_FIELD_GUEST_CR3);
                __writecr3(Cr3.Value);

                RFLAGS Rflags = {};
                Rflags.Value = vmread(VMX::VMCS_FIELD_GUEST_RFLAGS);
                __writeeflags(Rflags.Value);

                __vmx_off();

                RepeatInstruction = true;
                return VMM_STATUS::VMM_SHUTDOWN;
            }

            int SubLeaf = static_cast<int>(Context->Rcx);
            __cpuidex(Regs.Raw, Function, SubLeaf);

            switch (Function)
            {
            case CPUID::Generic::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID:
            {
                // Vendor = 'Hyper-Bridge' as RBX + RDX + RCX:
                Context->Rax = Regs.Regs.Eax;
                GetHvCpuName(Context->Rbx, Context->Rcx, Context->Rdx);
                break;
            }
            case 0x11223344:
            {
                // Example of events injection:
                InjectEvent(INTERRUPTION_TYPE::HardwareException, INTERRUPT_VECTOR::GeneralProtection, true, 0);
                break;
            }
            case static_cast<int>(HyperV::CPUID::MAX_LEAF_NUMBER_AND_VENDOR_ID) :
            {
                Context->Rax = static_cast<int>(HyperV::CPUID::INTERFACE_SIGNATURE);
                GetHvCpuName(Context->Rbx, Context->Rcx, Context->Rdx);
                break;
            }
            case static_cast<int>(HyperV::CPUID::INTERFACE_SIGNATURE) :
            {
                Context->Rax = '0#vH';
                Context->Rbx = 0;
                Context->Rcx = 0;
                Context->Rdx = 0;
                break;
            }
            default:
            {
                Context->Rax = Regs.Regs.Eax;
                Context->Rbx = Regs.Regs.Ebx;
                Context->Rcx = Regs.Regs.Ecx;
                Context->Rdx = Regs.Regs.Edx;
                break;
            }
            }

            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS XsetbvHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            _xsetbv(static_cast<unsigned int>(Context->Rcx), (Context->Rdx << 32u) | Context->Rax);
            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS EptViolationHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Context);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            VMX::EXIT_QUALIFICATION Info = { vmread(VMX::VMCS_FIELD_EXIT_QUALIFICATION) };
            unsigned long long AccessedPa = vmread(VMX::VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_FULL);

            if (!(Info.EptViolations.GuestPhysicalReadable || Info.EptViolations.GuestPhysicalExecutable))
            {
                // The page is neither readable nor executable (acts as not present):
                InjectEvent(VMX::INTERRUPTION_TYPE::HardwareException, INTERRUPT_VECTOR::GeneralProtection, true, 0);
                return VMM_STATUS::VMM_CONTINUE;
            }

            bool Handled = false;
            
            if (Info.EptViolations.AccessedRead)
            {
                unsigned long long RipPa;
                if (AddressRange::IsUserAddress(reinterpret_cast<void*>(Rip)))
                {
                    __writecr3(vmread(VMX::VMCS_FIELD_GUEST_CR3));
                    RipPa = Supplementation::FastPhys::GetPhysAddressFast4KbUnsafe(Rip);
                    __writecr3(g_Shared.KernelCr3);
                }
                else
                {
                    RipPa = Supplementation::FastPhys::GetPhysAddressFast4KbUnsafe(Rip);
                }

                if (ALIGN_DOWN_BY(AccessedPa, PAGE_SIZE) == ALIGN_DOWN_BY(RipPa, PAGE_SIZE))
                {
                    unsigned long long InstructionLength = vmread(VMX::VMCS_FIELD_VMEXIT_INSTRUCTION_LENGTH);
                    Handled = Private->EptInterceptor->HandleExecuteRead(AccessedPa, reinterpret_cast<void*>(Rip + InstructionLength));
                    if (Handled)
                    {
                        // Perform a single step:
                        EnableMonitorTrapFlag();
                        DisableGuestInterrupts();
                    }
                }
                else
                {
                    Handled = Private->EptInterceptor->HandleRead(AccessedPa);
                }
            }
            else if (Info.EptViolations.AccessedWrite)
            {
                unsigned long long InstructionLength = vmread(VMX::VMCS_FIELD_VMEXIT_INSTRUCTION_LENGTH);

                unsigned long long RipPa;
                if (AddressRange::IsUserAddress(reinterpret_cast<void*>(Rip)))
                {
                    __writecr3(vmread(VMX::VMCS_FIELD_GUEST_CR3));
                    RipPa = Supplementation::FastPhys::GetPhysAddressFast4KbUnsafe(Rip);
                    __writecr3(g_Shared.KernelCr3);
                }
                else
                {
                    RipPa = Supplementation::FastPhys::GetPhysAddressFast4KbUnsafe(Rip);
                }

                if (ALIGN_DOWN_BY(AccessedPa, PAGE_SIZE) == ALIGN_DOWN_BY(RipPa, PAGE_SIZE))
                {
                    Handled = Private->EptInterceptor->HandleExecuteWrite(AccessedPa, reinterpret_cast<void*>(Rip + InstructionLength));
                }
                else
                {
                    Handled = Private->EptInterceptor->HandleWrite(AccessedPa, reinterpret_cast<void*>(Rip + InstructionLength));
                }

                if (Handled)
                {
                    // Perform a single step:
                    EnableMonitorTrapFlag();
                    DisableGuestInterrupts();
                }
            }
            else if (Info.EptViolations.AccessedExecute)
            {
                Handled = Private->EptInterceptor->HandleExecute(AccessedPa);
            }

            if (Handled)
            {
                RepeatInstruction = true;
            }
            else
            {
                InjectEvent(VMX::INTERRUPTION_TYPE::HardwareException, INTERRUPT_VECTOR::GeneralProtection, true, 0);
            }

            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS EptMisconfigurationHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Context);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            unsigned long long FailedPagePa = vmread(VMX::VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_FULL);

            EPT_ENTRIES EptEntries = {};
            GetEptEntries(FailedPagePa, Private->Ept, EptEntries);

            UNREFERENCED_PARAMETER(EptEntries);

            __debugbreak();

            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS MonitorTrapFlagHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Context);

            Private->EptInterceptor->CompletePendingHandler(reinterpret_cast<void*>(Rip));
            DisableMonitorTrapFlag();
            EnableGuestInterrupts();
            RepeatInstruction = true;
            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS ExceptionOrNmiHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Context);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS VmcallHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            if (Context->R10 == HYPER_BRIDGE_SIGNATURE)
            {
                switch (static_cast<VMCALLS::VMCALL_INDEX>(Context->Rcx))
                {
                case VMCALLS::VMCALL_INDEX::VmmCall:
                {
                    unsigned long long(*Fn)(void* Arg) = reinterpret_cast<decltype(Fn)>(Context->Rdx);
                    void* Arg = reinterpret_cast<void*>(Context->R8);
                    bool SwitchToCallerAddressSpace = Context->R9 != 0;

                    unsigned long long Cr3 = 0;
                    if (SwitchToCallerAddressSpace)
                    {
                        Cr3 = __readcr3();
                        __writecr3(vmread(VMX::VMCS_FIELD_GUEST_CR3));
                    }

                    Context->Rax = Fn(Arg);

                    if (SwitchToCallerAddressSpace)
                    {
                        __writecr3(Cr3);
                    }
                    break;
                }
                default:
                {
                    Context->Rax = HYPER_BRIDGE_SIGNATURE;
                }
                }
            }
            else
            {
                HyperV::HYPERCALL_INPUT_VALUE InputValue = { Context->Rcx };
                switch (static_cast<HyperV::HYPERCALL_CODE>(InputValue.Bitmap.CallCode))
                {
                case HyperV::HYPERCALL_CODE::HvSwitchVirtualAddressSpace:
                case HyperV::HYPERCALL_CODE::HvFlushVirtualAddressSpace:
                case HyperV::HYPERCALL_CODE::HvFlushVirtualAddressList:
                case HyperV::HYPERCALL_CODE::HvCallFlushVirtualAddressSpaceEx:
                case HyperV::HYPERCALL_CODE::HvCallFlushVirtualAddressListEx:
                {
                    VMX::INVVPID_DESCRIPTOR InvvpidDesc = {};
                    __invvpid(VMX::INVVPID_TYPE::AllContextsInvalidation, &InvvpidDesc);
                    break;
                }
                case HyperV::HYPERCALL_CODE::HvCallFlushGuestPhysicalAddressSpace:
                case HyperV::HYPERCALL_CODE::HvCallFlushGuestPhysicalAddressList:
                {
                    // Acts as __invept():
                    INVEPT_DESCRIPTOR Desc = {};
                    Desc.Eptp = vmread(VMCS_FIELD_EPT_POINTER_FULL);
                    __invept(VMX::INVEPT_TYPE::GlobalInvalidation, &Desc);
                    break;
                }
                }

                // It is a Hyper-V hypercall - passing through:
                Context->Rax = __hyperv_vmcall(Context->Rcx, Context->Rdx, Context->R8, Context->R9);
            }

            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS RdmsrHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            unsigned long Msr = static_cast<unsigned long>(Context->Rcx);
            if (IsMsrAllowed(Msr))
            {
                // Allowed MSR:
                LARGE_INTEGER Value = {};
                Value.QuadPart = __readmsr(Msr);
                Context->Rdx = Value.HighPart;
                Context->Rax = Value.LowPart;
            }
            else
            {
                // It is unknown MSR (not Intel nor Hyper-V), returning 0:
                Context->Rdx = 0;
                Context->Rax = 0;
            }
            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS WrmsrHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            unsigned int Msr = static_cast<int>(Context->Rcx);
            if (IsMsrAllowed(Msr))
            {
                unsigned long long Value = (static_cast<unsigned long long>(Context->Rdx) << 32u)
                                         | (static_cast<unsigned long long>(Context->Rax));
                __writemsr(Msr, Value);
            }
            return VMM_STATUS::VMM_CONTINUE;
        }

        _IRQL_requires_same_
        _IRQL_requires_min_(DISPATCH_LEVEL)
        static VMM_STATUS VmxRelatedHandler(__inout PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context, unsigned long long Rip, __inout_opt bool& RepeatInstruction)
        {
            UNREFERENCED_PARAMETER(Private);
            UNREFERENCED_PARAMETER(Context);
            UNREFERENCED_PARAMETER(Rip);
            UNREFERENCED_PARAMETER(RepeatInstruction);

            RFLAGS Rflags = {};
            Rflags.Value = vmread(VMX::VMCS_FIELD_GUEST_RFLAGS);
            Rflags.Bitmap.Eflags.Bitmap.CF = TRUE;
            __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RFLAGS, Rflags.Value);

            return VMM_STATUS::VMM_CONTINUE;
        }

        // It is large enough to contain all possible handlers (the last handler has number 68 (EXIT_REASON_TPAUSE)):
        static FnVmexitHandler HandlersTable[72] = {};

        void InsertHandler(VMX::VMX_EXIT_REASON ExitReason, FnVmexitHandler Handler)
        {
            HandlersTable[static_cast<unsigned int>(ExitReason)] = Handler;
        }

        void InitHandlersTable()
        {
            for (auto i = 0u; i < ARRAYSIZE(HandlersTable); ++i)
            {
                HandlersTable[i] = EmptyHandler;
            }

            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_CPUID    , CpuidHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_XSETBV   , XsetbvHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_EPT_VIOLATION, EptViolationHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_EPT_MISCONFIGURATION, EptMisconfigurationHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_MONITOR_TRAP_FLAG, MonitorTrapFlagHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_EXCEPTION_OR_NMI, ExceptionOrNmiHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMCALL   , VmcallHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_RDMSR    , RdmsrHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_WRMSR    , WrmsrHandler);

            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMCLEAR , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMLAUNCH, VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMPTRLD , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMPTRST , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMREAD  , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMWRITE , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMXOFF  , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_VMXON   , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_INVVPID , VmxRelatedHandler);
            InsertHandler(VMX::VMX_EXIT_REASON::EXIT_REASON_INVEPT  , VmxRelatedHandler);

            _mm_sfence();
        }
    }

    _IRQL_requires_same_
    _IRQL_requires_min_(HIGH_LEVEL)
    extern "C" VMM_STATUS VmxVmexitHandler(PRIVATE_VM_DATA* Private, __inout GUEST_CONTEXT* Context)
    {
        /* Interrupts are locked */

        unsigned long long Rip = vmread(VMX::VMCS_FIELD_GUEST_RIP);

        EXIT_REASON ExitReason = {};
        ExitReason.Value = static_cast<unsigned int>(vmread(VMX::VMCS_FIELD_EXIT_REASON));

        bool RepeatInstruction = false;

        VMM_STATUS Status = VmexitHandlers::HandlersTable[ExitReason.Bitmap.BasicExitReason](Private, Context, Rip, RepeatInstruction);

        if (!RepeatInstruction)
        {
            // Go to the next instruction:
            Rip += vmread(VMX::VMCS_FIELD_VMEXIT_INSTRUCTION_LENGTH);
            __vmx_vmwrite(VMX::VMCS_FIELD_GUEST_RIP, Rip);
        }

        return Status;
    }

    static void DbgPrintMtrrEptCacheLayout(__in const EPT_TABLES* Ept, __in const MTRR_INFO* MtrrInfo)
    {
        auto MemTypeToStr = [](MTRR_MEMORY_TYPE MemType) -> const char*
        {
            switch (MemType)
            {
            case MTRR_MEMORY_TYPE::Uncacheable: return "Uncacheable (0)";
            case MTRR_MEMORY_TYPE::WriteCombining: return "WriteCombining (1)";
            case MTRR_MEMORY_TYPE::WriteThrough: return "WriteThrough (4)";
            case MTRR_MEMORY_TYPE::WriteProtected: return "WriteProtected (5)";
            case MTRR_MEMORY_TYPE::WriteBack: return "WriteBack (6)";
            default:
                return "Unknown";
            }
        };

        MTRR_MEMORY_TYPE CurrentRangeType = MTRR_MEMORY_TYPE::Uncacheable;
        unsigned long long RangeBeginning = 0;
        for (unsigned int i = 0; i < _ARRAYSIZE(Ept->Pdpte); ++i)
        {
            for (unsigned int j = 0; j < _ARRAYSIZE(Ept->Pde[i]); ++j)
            {
                if (i == 0 && j == 0)
                {
                    for (unsigned int k = 0; k < _ARRAYSIZE(Ept->PteForFirstLargePage); ++k)
                    {
                        auto Page = Ept->PteForFirstLargePage[k].Page4Kb;
                        MTRR_MEMORY_TYPE MemType = static_cast<MTRR_MEMORY_TYPE>(Page.Type);
                        unsigned long long PagePa = Page.PagePhysicalPfn * PAGE_SIZE;
                        if (MemType != CurrentRangeType)
                        {
                            if ((PagePa - RangeBeginning) > 0)
                            {
                                DbgPrint("Physical range [%p..%p]: %s\r\n", reinterpret_cast<void*>(RangeBeginning), reinterpret_cast<void*>(PagePa - 1), MemTypeToStr(CurrentRangeType));
                            }
                            CurrentRangeType = MemType;
                            RangeBeginning = PagePa;
                        }
                    }
                }
                else
                {
                    constexpr unsigned long long PageSize = 2 * 1048576; // 2 Mb

                    auto Page = Ept->Pde[i][j].Page2Mb;
                    MTRR_MEMORY_TYPE MemType = static_cast<MTRR_MEMORY_TYPE>(Page.Type);
                    unsigned long long PagePa = Page.PagePhysicalPfn * PageSize;
                    if (MemType != CurrentRangeType)
                    {
                        if ((PagePa - RangeBeginning) > 0)
                        {
                            DbgPrint("Physical range [%p..%p]: %s\r\n", reinterpret_cast<void*>(RangeBeginning), reinterpret_cast<void*>(PagePa - 1), MemTypeToStr(CurrentRangeType));
                        }
                        CurrentRangeType = MemType;
                        RangeBeginning = PagePa;
                    }
                }
            }
        }

        DbgPrint("Physical range [%p..%p]: %s\r\n", reinterpret_cast<void*>(RangeBeginning), reinterpret_cast<void*>(512ull * 1024ull * 1048576ull - 1ull), MemTypeToStr(CurrentRangeType));

        DbgPrint("EptVpidCap      : 0x%I64X\r\n", MtrrInfo->EptVpidCap.Value);
        DbgPrint("MaxPhysAddrBits : 0x%I64X\r\n", MtrrInfo->MaxPhysAddrBits);
        DbgPrint("MtrrCap         : 0x%I64X\r\n", MtrrInfo->MtrrCap.Value);
        DbgPrint("MtrrDefType     : 0x%I64X\r\n", MtrrInfo->MtrrDefType.Value);
        DbgPrint("PhysAddrMask    : 0x%I64X\r\n", MtrrInfo->PhysAddrMask);
        DbgPrint("MTRR.Fixed [00000..7FFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFrom00000To7FFFF.Value);
        DbgPrint("MTRR.Fixed [80000..9FFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFrom80000To9FFFF.Value);
        DbgPrint("MTRR.Fixed [A0000..BFFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromA0000ToBFFFF.Value);
        DbgPrint("MTRR.Fixed [C0000..C7FFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromC0000ToC7FFF.Value);
        DbgPrint("MTRR.Fixed [C8000..CFFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromC8000ToCFFFF.Value);
        DbgPrint("MTRR.Fixed [D0000..D7FFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromD0000ToD7FFF.Value);
        DbgPrint("MTRR.Fixed [D8000..DFFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromD8000ToDFFFF.Value);
        DbgPrint("MTRR.Fixed [E0000..E7FFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromE0000ToE7FFF.Value);
        DbgPrint("MTRR.Fixed [E8000..EFFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromE8000ToEFFFF.Value);
        DbgPrint("MTRR.Fixed [F0000..F7FFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromF0000ToF7FFF.Value);
        DbgPrint("MTRR.Fixed [F8000..FFFFF]: 0x%I64X\r\n", MtrrInfo->Fixed.Ranges.RangeFromF8000ToFFFFF.Value);

        for (unsigned int i = 0; i < _ARRAYSIZE(MtrrInfo->Variable); ++i)
        {
            DbgPrint("MTRR.Variable[%u]: Base: 0x%I64X, Mask: 0x%I64X\r\n", i, MtrrInfo->Variable[i].PhysBase.Value, MtrrInfo->Variable[i].PhysMask.Value);
        }
    }

    static bool VirtualizeAllProcessors()
    {
        if (g_IsVirtualized) return true;

        // Virtualizing each processor:
        bool Status = Callable::CallInSystemContext([](PVOID Arg) -> bool
        {
            UNREFERENCED_PARAMETER(Arg);
            auto* Shared = reinterpret_cast<SHARED_VM_DATA*>(Arg);

            Shared->KernelCr3 = __readcr3();

            // Determining the max phys size:
            CPUID::Intel::VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES MaxAddrSizes = {};
            __cpuid(MaxAddrSizes.Regs.Raw, CPUID::Intel::CPUID_VIRTUAL_AND_PHYSICAL_ADDRESS_SIZES);

            // Initializing MTRRs shared between all processors:
            MTRR_INFO MtrrInfo;
            memset(&MtrrInfo, 0, sizeof(MtrrInfo));
            InitMtrr(&MtrrInfo);

            ULONG ProcessorsCount = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
            Shared->Processors = VirtualMemory::AllocArray<VCPU_INFO>(ProcessorsCount);
            for (ULONG i = 0; i < ProcessorsCount; ++i)
            {
                auto Proc = &Shared->Processors[i];
                Proc->VmData = reinterpret_cast<PRIVATE_VM_DATA*>(AllocPhys(sizeof(PRIVATE_VM_DATA), MmCached, MaxAddrSizes.Bitmap.PhysicalAddressBits));
                if (!Shared->Processors[i].VmData)
                {
                    for (ULONG j = 0; j < ProcessorsCount; ++j)
                    {
                        if (Shared->Processors[j].VmData)
                        {
                            FreePhys(Shared->Processors[j].VmData);
                        }
                    }
                    VirtualMemory::FreePoolMemory(Shared->Processors);
                    Shared->Processors = NULL;
                    return false;
                }
                Proc->MtrrInfo = &MtrrInfo;
                Proc->VmData->EptInterceptor = new EptHandler(&Proc->VmData->Ept);
            }

            VmexitHandlers::InitHandlersTable();

            KeIpiGenericCall([](ULONG_PTR Arg) -> ULONG_PTR
            {
                auto* Shared = reinterpret_cast<SHARED_VM_DATA*>(Arg);
                VirtualizeProcessor(Shared);
                return TRUE;
            }, reinterpret_cast<ULONG_PTR>(Shared));

            bool Status = true;
            for (ULONG i = 0; i < ProcessorsCount; ++i)
            {
                Status &= Shared->Processors[i].Status;
                if (!Status)
                {
                    break;
                }
            }

            if (Status)
            {
                DbgPrintMtrrEptCacheLayout(&Shared->Processors[0].VmData->Ept, Shared->Processors[0].MtrrInfo);
            }
            else
            {
                DevirtualizeAllProcessors();
                VirtualMemory::FreePoolMemory(Shared->Processors);
                Shared->Processors = NULL;
            }

            return Status;
        }, &g_Shared);

        g_IsVirtualized = Status;

        return Status;
    }

    static void FreePrivateVmData(void* Private)
    {
        auto* Data = reinterpret_cast<VMX::PRIVATE_VM_DATA*>(Private);
        delete Data->EptInterceptor;
        Supplementation::FreePhys(Private);
    }

    static bool IsVmxSupported()
    {
        CPUID_REGS Regs = {};

        // Check the 'GenuineIntel' vendor name:
        __cpuid(Regs.Raw, CPUID::Generic::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID);
        if (Regs.Regs.Ebx != 'uneG' || Regs.Regs.Edx != 'Ieni' || Regs.Regs.Ecx != 'letn') return false;

        // Support by processor:
        __cpuid(Regs.Raw, CPUID::Intel::CPUID_FEATURE_INFORMATION);
        if (!reinterpret_cast<CPUID::FEATURE_INFORMATION*>(&Regs)->Intel.VMX) return false;

        // Check the VMX is locked in BIOS:
        IA32_FEATURE_CONTROL MsrFeatureControl = {};
        MsrFeatureControl.Value = __readmsr(static_cast<unsigned long>(INTEL_MSR::IA32_FEATURE_CONTROL));

        if (MsrFeatureControl.Bitmap.LockBit == FALSE) return false;

        return true;
    }
}
#endif


namespace Hypervisor
{
    bool IsVirtualized()
    {
#ifdef _AMD64_
        return g_IsVirtualized;
#else
        return false;
#endif
    }

    bool Virtualize()
    {
#ifdef _AMD64_
        if (IsVirtualized()) return false;

        CPU_VENDOR CpuVendor = GetCpuVendor();
        if (CpuVendor == CPU_VENDOR::cpuUnknown) return false;

        bool Status = false;

        switch (CpuVendor) {
        case CPU_VENDOR::cpuIntel:
        {
            if (!VMX::IsVmxSupported()) return false;
            Status = VMX::VirtualizeAllProcessors();
            break;
        }
        case CPU_VENDOR::cpuAmd:
        {
            if (!SVM::IsSvmSupported()) return false;
            Status = SVM::VirtualizeAllProcessors();
            break;
        }
        }

        return Status;
#else
        return false;
#endif
    }

    bool Devirtualize()
    {
#ifdef _AMD64_
        DevirtualizeAllProcessors();
        return true;
#else
        return false;
#endif
    }

    bool InterceptPage(
        unsigned long long Pa,
        unsigned long long ReadPa,
        unsigned long long WritePa,
        unsigned long long ExecutePa,
        unsigned long long ExecuteReadPa,
        unsigned long long ExecuteWritePa
    ) {
#ifdef _AMD64_
        CPU_VENDOR CpuVendor = GetCpuVendor();
        switch (CpuVendor)
        {
        case CPU_VENDOR::cpuIntel:
        {
            return VMX::InterceptPage(Pa, ReadPa, WritePa, ExecutePa, ExecuteReadPa, ExecuteWritePa);
        }
        default:
        {
            // Not supported:
            return false;
        }
        }
#else
        // Unreferenced parameters:
        Pa; ReadPa; WritePa; ExecutePa; ExecuteReadPa; ExecuteWritePa;
        return false;
#endif
    }

    bool DeinterceptPage(unsigned long long Pa)
    {
#ifdef _AMD64_
        CPU_VENDOR CpuVendor = GetCpuVendor();
        switch (CpuVendor)
        {
        case CPU_VENDOR::cpuIntel:
        {
            VMX::DeinterceptPage(Pa);
            return true;
        }
        default:
        {
            // Not supported:
            return false;
        }
        }
#else
        Pa;
        return false;
#endif
    }
}
```

`Kernel-Bridge/API/Hypervisor.h`:

```h
#pragma once

// For the Hyper-V only:
extern "C" unsigned long long __fastcall __hyperv_vmcall(
    unsigned long long Rcx,
    unsigned long long Rdx,
    unsigned long long R8,
    unsigned long long R9
);

extern "C" unsigned long long __fastcall __kb_vmcall(
    unsigned long long Rcx,
    unsigned long long Rdx,
    unsigned long long R8,
    unsigned long long R9
);

namespace Hypervisor
{
    bool IsVirtualized();
    bool Virtualize();
    bool Devirtualize();

    bool InterceptPage(
        unsigned long long Pa,
        unsigned long long ReadPa,
        unsigned long long WritePa,
        unsigned long long ExecutePa,
        unsigned long long ExecuteReadPa,
        unsigned long long ExecuteWritePa
    );

    bool DeinterceptPage(unsigned long long Pa);
}
```

`Kernel-Bridge/API/IO.cpp`:

```cpp
#include <fltKernel.h>

#ifdef _X86_
// For compatibility with C++17, because <intrin.h> contains deprecated language statements:
extern "C" unsigned char __inbyte(unsigned short PortNumber);
extern "C" unsigned short __inword(unsigned short PortNumber);
extern "C" unsigned long __indword(unsigned short PortNumber);
extern "C" void __inbytestring(unsigned short PortNumber, unsigned char* Buffer, unsigned long Count);
extern "C" void __inwordstring(unsigned short PortNumber, unsigned short* Buffer, unsigned long Count);
extern "C" void __indwordstring(unsigned short PortNumber, unsigned long* Buffer, unsigned long Count);
extern "C" void __outbyte(unsigned short PortNumber, unsigned char Data);
extern "C" void __outword(unsigned short PortNumber, unsigned short Data);
extern "C" void __outdword(unsigned short PortNumber, unsigned long Data);
extern "C" void __outbytestring(unsigned short PortNumber, unsigned char* Buffer, unsigned long Count);
extern "C" void __outwordstring(unsigned short PortNumber, unsigned short* Buffer, unsigned long Count);
extern "C" void __outdwordstring(unsigned short PortNumber, unsigned long* Buffer, unsigned long Count);
#endif

namespace IO {
    namespace IOPL {
        constexpr unsigned int IoplAccessMask = 0x3000;

#ifdef _AMD64_
        PKTRAP_FRAME GetTrapFrame() {
            return reinterpret_cast<PKTRAP_FRAME>(
                reinterpret_cast<SIZE_T>(IoGetInitialStack()) - sizeof(KTRAP_FRAME)
            );
        }

        void RaiseIopl() {
            GetTrapFrame()->EFlags |= IoplAccessMask;
        }

        void ResetIopl() {
            GetTrapFrame()->EFlags &= ~IoplAccessMask;
        }
#elif _X86_
        // Offsets from: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/ktrap_frame.htm
        constexpr unsigned char KTrapFrame32Size = 0x8C;
        constexpr unsigned char EFlagsOffsetInKTrapFrame32 = 0x70;

        PVOID GetTrapFrame() {
            return reinterpret_cast<PVOID>(
                reinterpret_cast<SIZE_T>(IoGetInitialStack()) - KTrapFrame32Size
            );
        }

        PULONG GetEFlagsPtr(PVOID KTrapFramePtr) {
            return reinterpret_cast<PULONG>(
                reinterpret_cast<SIZE_T>(KTrapFramePtr) + EFlagsOffsetInKTrapFrame32    
            );
        }

        void RaiseIopl() {
            *GetEFlagsPtr(GetTrapFrame()) |= IoplAccessMask;
        }

        void ResetIopl() {
            *GetEFlagsPtr(GetTrapFrame()) &= ~IoplAccessMask;
        }
#endif
    }

    namespace Beeper {
        void SetBeeperRegime() {
            __outbyte(0x43, 0xB6);
        }

        void StartBeeper() {
            __outbyte(0x61, __inbyte(0x61) | 3);
        }

        void StopBeeper() {
            __outbyte(0x61, __inbyte(0x61) & 252);
        }

        void SetBeeperIn() {
            __outbyte(0x61, __inbyte(0x61) & 253);
        }

        void SetBeeperOut() {
            __outbyte(0x61, __inbyte(0x61) | 2);
        }

        void SetBeeperDivider(unsigned short Divider) {
            __outbyte(0x42, static_cast<unsigned char>(Divider));
            __outbyte(0x42, static_cast<unsigned char>(Divider >> 8));
        }

        void SetBeeperFrequency(unsigned short Frequency) {
            if (!Frequency) Frequency = 1;
            SetBeeperDivider(static_cast<unsigned short>(1193182 / static_cast<unsigned long>(Frequency)));
        }
    }

    namespace RW {
        unsigned char ReadPortByte(unsigned short PortNumber) {
            return __inbyte(PortNumber);
        }

        unsigned short ReadPortWord(unsigned short PortNumber) {
            return __inword(PortNumber);
        }

        unsigned long ReadPortDword(unsigned short PortNumber) {
            return __indword(PortNumber);
        }

        void ReadPortByteString(unsigned short PortNumber, unsigned char* Buffer, unsigned long Count) {
            return __inbytestring(PortNumber, Buffer, Count);
        }

        void ReadPortWordString(unsigned short PortNumber, unsigned short* Buffer, unsigned long Count) {
            return __inwordstring(PortNumber, Buffer, Count);
        }

        void ReadPortDwordString(unsigned short PortNumber, unsigned long* Buffer, unsigned long Count) {
            return __indwordstring(PortNumber, Buffer, Count);
        }

        void WritePortByte(unsigned short PortNumber, unsigned char Data) {
            __outbyte(PortNumber, Data);
        }

        void WritePortWord(unsigned short PortNumber, unsigned short Data) {
            __outword(PortNumber, Data);
        }

        void WritePortDword(unsigned short PortNumber, unsigned long Data) {
            __outdword(PortNumber, Data);
        }

        void WritePortByteString(unsigned short PortNumber, unsigned char* Buffer, unsigned long Count) {
            __outbytestring(PortNumber, Buffer, Count);
        }

        void WritePortWordString(unsigned short PortNumber, unsigned short* Buffer, unsigned long Count) {
            __outwordstring(PortNumber, Buffer, Count);
        }

        void WritePortDwordString(unsigned short PortNumber, unsigned long* Buffer, unsigned long Count) {
            __outdwordstring(PortNumber, Buffer, Count);
        }
    }
}
```

`Kernel-Bridge/API/IO.h`:

```h
#pragma once

namespace IO {
    namespace IOPL {
        void RaiseIopl();
        void ResetIopl();
    }

    namespace Beeper {
        void SetBeeperRegime(); // Call this once before using beeper
        void StartBeeper();     // Enable beeper with setted frequency
        void StopBeeper();      // Disable beeper
        void SetBeeperIn();     // Reset voltage from beeper membrane
        void SetBeeperOut();    // Set voltage to beeper membrane
        void SetBeeperDivider(unsigned short Divider); // 1193182 Hz / Divider
        void SetBeeperFrequency(unsigned short Frequency);
    }

    namespace RW {
        unsigned char ReadPortByte(unsigned short PortNumber);
        unsigned short ReadPortWord(unsigned short PortNumber);
        unsigned long ReadPortDword(unsigned short PortNumber);
        void ReadPortByteString(unsigned short PortNumber, unsigned char* Buffer, unsigned long Count);
        void ReadPortWordString(unsigned short PortNumber, unsigned short* Buffer, unsigned long Count);
        void ReadPortDwordString(unsigned short PortNumber, unsigned long* Buffer, unsigned long Count);
        void WritePortByte(unsigned short PortNumber, unsigned char Data);
        void WritePortWord(unsigned short PortNumber, unsigned short Data);
        void WritePortDword(unsigned short PortNumber, unsigned long Data);
        void WritePortByteString(unsigned short PortNumber, unsigned char* Buffer, unsigned long Count);
        void WritePortWordString(unsigned short PortNumber, unsigned short* Buffer, unsigned long Count);
        void WritePortDwordString(unsigned short PortNumber, unsigned long* Buffer, unsigned long Count);
    }
}
```

`Kernel-Bridge/API/Importer.cpp`:

```cpp
#include <fltKernel.h>
#include "Importer.h"

namespace Importer {
    _IRQL_requires_max_(PASSIVE_LEVEL)
    PVOID NTAPI GetKernelProcAddress(LPCWSTR SystemRoutineName) {
        UNICODE_STRING Name;
        RtlInitUnicodeString(&Name, SystemRoutineName);
        return MmGetSystemRoutineAddress(&Name);
    }
}
```

`Kernel-Bridge/API/Importer.h`:

```h
#pragma once

namespace Importer {
    // Get address of function from ntoskrnl.exe and FltMgr.dll:
    _IRQL_requires_max_(PASSIVE_LEVEL)
    PVOID NTAPI GetKernelProcAddress(LPCWSTR SystemRoutineName);
}
```

`Kernel-Bridge/API/KernelShells.cpp`:

```cpp
#include <wdm.h>

#include "KernelShells.h"

#include "Importer.h"
#include "MemoryUtils.h"
#include "CPU.h"

namespace KernelShells {
    _IRQL_requires_max_(APC_LEVEL)
    ULONG ExecuteShellCode(
        _ShellCode Shell,
        OPTIONAL IN OUT PVOID Argument
    ) {
        static volatile LONG EnteringsCount = 0;
        InterlockedIncrement(&EnteringsCount);

        ULONG Result = 0;

        KFLOATING_SAVE FpuState = {};
        BOOLEAN FpuSaved = KeSaveFloatingPointState(&FpuState) == STATUS_SUCCESS;

        KAFFINITY PreviousAffinity = KeQueryActiveProcessors();
        KeSetSystemAffinityThread(1); // Executing on 1st core of 1st processor

        if (CPU::IsSmepPresent()) CPU::DisableSmep();

        __try {
            Result = Shell(Importer::GetKernelProcAddress, Argument);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Result = static_cast<ULONG>(-1);
        }

        InterlockedDecrement(&EnteringsCount);
        if (!InterlockedCompareExchange(&EnteringsCount, 0, 0) && CPU::IsSmepPresent()) CPU::EnableSmep();

        KeSetSystemAffinityThread(PreviousAffinity);

        if (FpuSaved) KeRestoreFloatingPointState(&FpuState);

        return Result;
    }

}
```

`Kernel-Bridge/API/KernelShells.h`:

```h
#pragma once

namespace KernelShells {
    using _GetKernelProcAddress = PVOID(NTAPI*)(LPCWSTR RoutineName);
    using _ShellCode = ULONG(NTAPI*)(
        _GetKernelProcAddress GetKernelProcAddress,
        OPTIONAL IN OUT PVOID Argument
    );

    // Executes specified user- or kernel-shell into SEH-section and FPU-saved context,
    // Returns -1 (0xFFFFFFFF) if exception catched:
    _IRQL_requires_max_(APC_LEVEL)
    ULONG ExecuteShellCode(
        _ShellCode Shell,
        OPTIONAL IN OUT PVOID Argument
    );
}
```

`Kernel-Bridge/API/LinkedList.h`:

```h
#pragma once

/* 
  Depends on:
   - wdm.h
*/

template <typename T>
class LinkedList {
private:
    using _Entry = struct {
        LIST_ENTRY ChainEntry;
        PVOID EntryObject;
        T Value;
    };
public:
    class ListEntry {
    private:
        _Entry Entry;
    public:
        ListEntry(const T& Value) : Entry({}) {
            InitializeListHead(&Entry.ChainEntry);
            Entry.EntryObject = this;
            Entry.Value = Value;
        }

        ~ListEntry() = default;

        PLIST_ENTRY GetChainEntry() { return &Entry.ChainEntry; }
        T* GetValue() { return &Entry.Value; }
        ListEntry* GetInstance() { return static_cast<ListEntry*>(Entry.EntryObject); }
        _Entry* GetEntry() { return &Entry; }
    };

    class ListIterator {
    private:
        PLIST_ENTRY ListHead;
        _Entry* Current;
    public:
        ListIterator() : Current(NULL) {}
        ListIterator(PLIST_ENTRY Head, ListEntry* Entry) : ListHead(Head), Current(Entry->GetEntry()) {}
        ~ListIterator() = default;

        ListEntry* GetEntry() { return static_cast<ListEntry*>(Current->EntryObject); }

        ListIterator& operator ++ () {
            Current = Current->ChainEntry.Flink != ListHead
                ? reinterpret_cast<_Entry*>(Current->ChainEntry.Flink)
                : NULL;
            return *this;
        }

        ListIterator& operator -- () {
            Current = Current->ChainEntry.Flink != ListHead
                ? reinterpret_cast<_Entry*>(Current->ChainEntry.Blink)
                : NULL;
            return *this;
        }

        T& operator * () { return Current->Value; }

        bool operator == (const ListIterator& Iterator) const {
            return !Iterator.Current || !Current
                ? Iterator.Current == Current
                : Iterator.Current->EntryObject == Current->EntryObject;
        }

        bool operator != (const ListIterator& Iterator) const {
            return !Iterator.Current || !Current
                ? Iterator.Current != Current
                : Iterator.Current->EntryObject != Current->EntryObject;
        }
    };
private:
    __declspec(align(MEMORY_ALLOCATION_ALIGNMENT)) KSPIN_LOCK SpinLock;
    __declspec(align(MEMORY_ALLOCATION_ALIGNMENT)) LIST_ENTRY Head;

    ListIterator Finalizer;
public:
    LinkedList(const LinkedList&) = delete;
    LinkedList(LinkedList&&) = delete;
    LinkedList& operator = (const LinkedList&) = delete;
    LinkedList& operator = (LinkedList&&) = delete;

    LinkedList() : Head({}), Finalizer() {
        KeInitializeSpinLock(&SpinLock);
        InitializeListHead(&Head);
    }

    ~LinkedList() {
        Clear();
    }

    void Clear() {
        if (IsEmpty()) return;
        ListIterator it = begin();
        while (it != end()) {
            auto Entry = it.GetEntry();
            ++it;
            Remove(Entry);
        }
    }

    void InterlockedInsertTail(const T& Value) {
        auto Entry = new ListEntry(Value);
        ExInterlockedInsertTailList(&Head, Entry->GetChainEntry(), &SpinLock);
    }

    void InterlockedInsertHead(const T& Value) {
        auto Entry = new ListEntry(Value);
        ExInterlockedInsertHeadList(&Head, Entry->GetChainEntry(), &SpinLock);
    }

    void InterlockedRemoveHead() {
        auto Entry = ExInterlockedRemoveHeadList(&Head, &SpinLock);
        delete Entry;
    }

    ListEntry* InsertTail(const T& Value) {
        auto Entry = new ListEntry(Value);
        InsertTailList(&Head, Entry->GetChainEntry());
        return Entry;
    }

    ListEntry* InsertHead(const T& Value) {
        auto Entry = new ListEntry(Value);
        InsertTailList(&Head, Entry->GetChainEntry());
        return Entry;
    }

    void Remove(ListEntry* Entry) {
        RemoveEntryList(Entry->GetChainEntry());
        delete Entry->GetInstance();
    }

    void RemoveHead() {
        RemoveHeadList(&Head);
    }

    void RemoveTail() {
        RemoveTailList(&Head);
    }

    bool IsEmpty() const {
        return IsListEmpty(&Head);
    }

    ListIterator begin() {
        return ListIterator(&Head, static_cast<ListEntry*>((reinterpret_cast<_Entry*>(Head.Flink))->EntryObject));
    }

    ListIterator end() {
        return Finalizer;
    }
};
```

`Kernel-Bridge/API/Locks.h`:

```h
#pragma once

// Dependencies:
// - wdm.h (or fltKernel.h)

// ENTER_***_REGION are callable from IRQL <= APC_LEVEL

// Disables delivery of user and normal kernel APC's, 
// except special kernel APCs:
#define ENTER_CRITICAL_REGION() KeEnterCriticalRegion()
#define LEAVE_CRITICAL_REGION() KeLeaveCriticalRegion()

// Disables delivery of all APCs, including special kernel:
#define ENTER_GUARDED_REGION() KeEnterGuardedRegion()
#define LEAVE_GUARDED_REGION() KeLeaveGuardedRegion()

#define ALIGNED __declspec(align(MEMORY_ALLOCATION_ALIGNMENT))

// Lock() and Unlock() raises IRQL to APC_LEVEL and acquires the mutex,
// LockAtApc() and UnlockAtApc() not raises an IRQL and assumes that thread
// is already in APC_LEVEL or in critical region or in call of FsRtlEnterFileSystem.
// TryToAcquire() raises IRQL to APC_LEVEL if acquiring was successful.

class FastMutex final {
private:
    ALIGNED FAST_MUTEX Mutex;
public:
    FastMutex(const FastMutex&) = delete;
    FastMutex(FastMutex&&) = delete;
    FastMutex& operator = (const FastMutex&) = delete;
    FastMutex& operator = (FastMutex&&) = delete;

    _IRQL_requires_max_(DISPATCH_LEVEL)
    FastMutex() : Mutex({}) {
        ExInitializeFastMutex(&Mutex);
    }

    ~FastMutex() = default;

    _IRQL_raises_(APC_LEVEL)
    _IRQL_saves_global_(OldIrql, Mutex)
    VOID Lock() {
        ExAcquireFastMutex(&Mutex);
    };

    _IRQL_requires_(APC_LEVEL)
    _IRQL_restores_global_(OldIrql, Mutex)
    VOID Unlock() {
        ExReleaseFastMutex(&Mutex);
    };

    _IRQL_requires_(APC_LEVEL)
    VOID LockAtApc() {
        ExAcquireFastMutexUnsafe(&Mutex);
    };

    _IRQL_requires_(APC_LEVEL)
    VOID UnlockFromApc() {
        ExReleaseFastMutexUnsafe(&Mutex);
    };

    _IRQL_raises_(APC_LEVEL)
    _IRQL_saves_global_(OldIrql, Mutex)
    BOOLEAN TryToAcquire() {
        return ExTryToAcquireFastMutex(&Mutex);
    }
};

class GuardedMutex final {
private:
    ALIGNED KGUARDED_MUTEX Mutex;
public:
    GuardedMutex(const GuardedMutex&) = delete;
    GuardedMutex(GuardedMutex&&) = delete;
    GuardedMutex& operator = (const GuardedMutex&) = delete;
    GuardedMutex& operator = (GuardedMutex&&) = delete;

    _IRQL_requires_max_(DISPATCH_LEVEL)
    GuardedMutex() : Mutex({}) {
        KeInitializeGuardedMutex(&Mutex);
    }

    ~GuardedMutex() = default;
    
    _IRQL_requires_max_(APC_LEVEL)
    VOID Lock() {
        KeAcquireGuardedMutex(&Mutex);
    };

    _IRQL_requires_max_(APC_LEVEL)
    VOID Unlock() {
        KeReleaseGuardedMutex(&Mutex);
    };

    _IRQL_requires_(APC_LEVEL)
    VOID LockAtApc() {
        KeAcquireGuardedMutexUnsafe(&Mutex);
    };

    _IRQL_requires_(APC_LEVEL)
    VOID UnlockFromApc() {
        KeReleaseGuardedMutexUnsafe(&Mutex);
    };

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN TryToAcquire() {
        return KeTryToAcquireGuardedMutex(&Mutex);
    }
};


// SpinLock raises IRQL to DISPATCH_LEVEL and acquires a spinlock.
// If thread is already at DISPATCH_LEVEL, you can use LockAtDpc()/UnlockFromDpc():
class SpinLock final {
private:
    ALIGNED KSPIN_LOCK Spinlock;
    KLOCK_QUEUE_HANDLE LockHandle;
public:
    SpinLock(const SpinLock&) = delete;
    SpinLock(SpinLock&&) = delete;
    SpinLock& operator = (const SpinLock&) = delete;
    SpinLock& operator = (SpinLock&&) = delete;

    SpinLock() : Spinlock(0), LockHandle({}) {
        KeInitializeSpinLock(&Spinlock);
    }

    ~SpinLock() = default;

    _IRQL_requires_max_(DISPATCH_LEVEL)
    _IRQL_saves_global_(QueuedSpinLock,LockHandle)
    _IRQL_raises_(DISPATCH_LEVEL)
    VOID Lock() {
        KeAcquireInStackQueuedSpinLock(&Spinlock, &LockHandle);
    }

    _IRQL_requires_(DISPATCH_LEVEL)
    _IRQL_restores_global_(QueuedSpinLock,LockHandle)
    VOID Unlock() {
        KeReleaseInStackQueuedSpinLock(&LockHandle);
    }

    _IRQL_requires_(DISPATCH_LEVEL)
    VOID LockAtDpc() {
        KeAcquireInStackQueuedSpinLockAtDpcLevel(&Spinlock, &LockHandle);
    }

    _IRQL_requires_(DISPATCH_LEVEL)
    VOID UnlockFromDpc() {
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    }
};


class EResource {
private:
    ERESOURCE Resource;
public:
    EResource(const EResource&) = delete;
    EResource(EResource&&) = delete;
    EResource& operator = (const EResource&) = delete;
    EResource& operator = (EResource&&) = delete;

    _IRQL_requires_max_(DISPATCH_LEVEL)
    EResource() : Resource({}) {
        ExInitializeResourceLite(&Resource);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    NTSTATUS Reinitialize() {
        return ExReinitializeResourceLite(&Resource);
    }

    _IRQL_requires_max_(APC_LEVEL)
    ~EResource() {
        ExDeleteResourceLite(&Resource);
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN LockShared(BOOLEAN Wait = TRUE) {
        ENTER_CRITICAL_REGION();
        return ExAcquireResourceSharedLite(&Resource, Wait);
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN LockExclusive(BOOLEAN Wait = TRUE) {
        ENTER_CRITICAL_REGION();
        return ExAcquireResourceExclusiveLite(&Resource, Wait);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID Unlock() {
        ExReleaseResourceLite(&Resource);
        LEAVE_CRITICAL_REGION();
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    ULONG GetOwnersCount() {
        return ExIsResourceAcquiredLite(&Resource);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    ULONG GetSharedOwnersCount() {
        return ExIsResourceAcquiredSharedLite(&Resource);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsAcquired() {
        return static_cast<BOOLEAN>(GetOwnersCount() > 0);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsAcquiredShared() {
        return static_cast<BOOLEAN>(GetSharedOwnersCount() > 0);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsAcquiredExclusive() {
        return ExIsResourceAcquiredExclusiveLite(&Resource);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    ULONG GetSharedWaiters() {
        return ExGetSharedWaiterCount(&Resource);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    ULONG GetExclusiveWaiters() {
        return ExGetExclusiveWaiterCount(&Resource);
    }

    // Converts exclusive lock to shared if current thread locked
    // ERESOURCE with exclusive access:
    _IRQL_requires_max_(APC_LEVEL)
    VOID ConvertExclusiveToShared() {
        ExConvertExclusiveToSharedLite(&Resource);
    }
};

class Atomic32 final {
private:
    volatile ALIGNED LONG AtomicValue;
public:
    Atomic32() : AtomicValue(0) {};
    explicit Atomic32(LONG InitialValue) : AtomicValue(InitialValue) {}
    ~Atomic32() = default;

    LONG Equals(LONG Value) { return Get() == Value; }

    LONG Get() { return InterlockedCompareExchange(&AtomicValue, 0, 0); }
    LONG Set(LONG Value) { return InterlockedExchange(&AtomicValue, Value); }
    LONG Add(LONG Value) { return InterlockedAdd(&AtomicValue, Value); }
    LONG Inc() { return InterlockedIncrement(&AtomicValue); }
    LONG Dec() { return InterlockedDecrement(&AtomicValue); }
    
    LONG And(LONG Value) { return InterlockedAnd(&AtomicValue, Value); }
    LONG Or(LONG Value) { return InterlockedOr(&AtomicValue, Value); }
    LONG Xor(LONG Value) { return InterlockedXor(&AtomicValue, Value); }

    // if (Atomic == Comperand) Atomic = Value:
    LONG CompareExchange(LONG Comperand, LONG Value) { return InterlockedCompareExchange(&AtomicValue, Value, Comperand); }

    // Returns a previous value of specified bit position:
    BOOLEAN BitTestAndSet(LONG Offset) { return InterlockedBitTestAndSet(&AtomicValue, Offset); }
    BOOLEAN BitTestAndReset(LONG Offset) { return InterlockedBitTestAndReset(&AtomicValue, Offset); }

    Atomic32& operator = (LONG Value) { Set(Value); return *this; }
    Atomic32& operator + (LONG Value) { Add(Value); return *this; }
    Atomic32& operator - (LONG Value) { Add(-Value); return *this; }
    Atomic32& operator ++ (int) { Inc(); return *this; }
    Atomic32& operator -- (int) { Dec(); return *this; }
    bool operator == (LONG Value) { return Equals(Value); }
    bool operator != (LONG Value) { return !Equals(Value); }
    bool operator > (LONG Value) { return Get() > Value; }
    bool operator < (LONG Value) { return Get() < Value; }
    bool operator >= (LONG Value) { return Get() >= Value; }
    bool operator <= (LONG Value) { return Get() <= Value; }
    Atomic32& operator &= (LONG Value) { And(Value); return *this; }
    Atomic32& operator |= (LONG Value) { Or(Value); return *this; }
    Atomic32& operator ^= (LONG Value) { Xor(Value); return *this; }
    operator LONG() { return Get(); }
};

class Atomic64 final {
private:
    volatile ALIGNED LONG64 AtomicValue;
public:
    Atomic64() : AtomicValue(0) {}
    explicit Atomic64(LONG64 InitialValue) : AtomicValue(InitialValue) {}
    ~Atomic64() = default;

    LONG64 Equals(LONG64 Value) { return Get() == Value; } 

    LONG64 Get() { return InterlockedCompareExchange64(&AtomicValue, 0, 0); }
    LONG64 Set(LONG64 Value) { return InterlockedExchange64(&AtomicValue, Value); }
    LONG64 Add(LONG64 Value) { return InterlockedAdd64(&AtomicValue, Value); }
    LONG64 Inc() { return InterlockedIncrement64(&AtomicValue); }
    LONG64 Dec() { return InterlockedDecrement64(&AtomicValue); }

    LONG64 And(LONG64 Value) { return InterlockedAnd64(&AtomicValue, Value); }
    LONG64 Or(LONG64 Value) { return InterlockedOr64(&AtomicValue, Value); }
    LONG64 Xor(LONG64 Value) { return InterlockedXor64(&AtomicValue, Value); }

    // if (Atomic == Comperand) Atomic = Value:
    LONG64 CompareExchange(LONG64 Comperand, LONG64 Value) { return InterlockedCompareExchange64(&AtomicValue, Value, Comperand); }

#ifdef _AMD64_
    // Returns a previous value of specified bit position:
    BOOLEAN BitTestAndSet(LONG64 Offset) { return InterlockedBitTestAndSet64(&AtomicValue, Offset); }
    BOOLEAN BitTestAndReset(LONG64 Offset) { return InterlockedBitTestAndReset64(&AtomicValue, Offset); }
#endif

    Atomic64& operator = (LONG64 Value) { Set(Value); return *this; }
    Atomic64& operator + (LONG64 Value) { Add(Value); return *this; }
    Atomic64& operator - (LONG64 Value) { Add(-Value); return *this; }
    Atomic64& operator ++ (int) { Inc(); return *this; }
    Atomic64& operator -- (int) { Dec(); return *this; }
    bool operator == (LONG64 Value) { return Equals(Value); }
    bool operator != (LONG64 Value) { return !Equals(Value); }
    bool operator > (LONG64 Value) { return Get() > Value; }
    bool operator < (LONG64 Value) { return Get() < Value; }
    bool operator >= (LONG64 Value) { return Get() >= Value; }
    bool operator <= (LONG64 Value) { return Get() <= Value; }
    Atomic64& operator &= (LONG64 Value) { And(Value); return *this; }
    Atomic64& operator |= (LONG64 Value) { Or(Value); return *this; }
    Atomic64& operator ^= (LONG64 Value) { Xor(Value); return *this; }
    operator LONG64() { return Get(); }
};

class AtomicPointer final {
private:
    volatile ALIGNED PVOID AtomicValue;
public:
    AtomicPointer(const AtomicPointer&) = delete;
    AtomicPointer(AtomicPointer&&) = delete;
    AtomicPointer& operator = (const AtomicPointer&) = delete;
    AtomicPointer& operator = (AtomicPointer&&) = delete;

    explicit AtomicPointer(PVOID InitialValue = NULL) : AtomicValue(InitialValue) {}
    ~AtomicPointer() = default;

    BOOLEAN Equals(PVOID Value) { return Get() == Value; }

    PVOID Get() { return InterlockedCompareExchangePointer(&AtomicValue, 0, 0); }
    PVOID Set(PVOID Value) { return InterlockedExchangePointer(&AtomicValue, Value); }

    AtomicPointer& operator = (PVOID Value) { Set(Value); return *this; }
    BOOLEAN operator == (PVOID Value) { return Equals(Value); }
    BOOLEAN operator != (PVOID Value) { return !Equals(Value); }
    operator PVOID() { return Get(); }
};

// Pass FastMutex or GuardedMutex to this template:
template <class T>
class CriticalSection final {
private:
    T Mutex;
    AtomicPointer Owner;
    Atomic64 LocksCount;
public:
    CriticalSection(const CriticalSection&) = delete;
    CriticalSection(CriticalSection&&) = delete;
    CriticalSection& operator = (const CriticalSection&) = delete;
    CriticalSection& operator = (CriticalSection&&) = delete;

    CriticalSection() : Owner(NULL), LocksCount(0) {}
    ~CriticalSection() = default;

    _IRQL_raises_(APC_LEVEL)
    _IRQL_saves_global_(OldIrql, Mutex)
    void Enter() {
        PETHREAD CurrentThread = PsGetCurrentThread();
        if (Owner == CurrentThread) {
            LocksCount++;
            return;
        }
        Mutex.Lock();
        Owner = CurrentThread;
        LocksCount = 1;
    }

    _IRQL_requires_(APC_LEVEL)
    _IRQL_restores_global_(OldIrql, Mutex)
    void Leave() {
        LONG64 Locks = LocksCount;
        if (Locks == 0) return;
        if (Locks == 1) {
            LocksCount = 0;
            Owner = NULL;
            Mutex.Unlock();
        } else {
            LocksCount--;
        }
    }
};

using FastCriticalSection = CriticalSection<FastMutex>;
using GuardedCriticalSection = CriticalSection<GuardedMutex>;

class SpinCriticalSection final {
private:
    SpinLock SpinMutex;
    AtomicPointer Owner;
    Atomic64 LocksCount;
public:
    SpinCriticalSection(const SpinCriticalSection&) = delete;
    SpinCriticalSection(SpinCriticalSection&&) = delete;
    SpinCriticalSection& operator = (const SpinCriticalSection&) = delete;
    SpinCriticalSection& operator = (SpinCriticalSection&&) = delete;

    SpinCriticalSection() : Owner(NULL), LocksCount(0) {}
    ~SpinCriticalSection() = default;

    _IRQL_requires_max_(DISPATCH_LEVEL)
    _IRQL_raises_(DISPATCH_LEVEL)
    _IRQL_saves_global_(QueuedSpinLock,SpinMutex)
    void Enter() {
        PETHREAD CurrentThread = PsGetCurrentThread();
        if (Owner == CurrentThread) {
            LocksCount++;
            return;
        }
        SpinMutex.Lock();
        Owner = CurrentThread;
        LocksCount = 1;
    }

    _IRQL_requires_(DISPATCH_LEVEL)
    _IRQL_restores_global_(QueuedSpinLock,SpinMutex)
    void Leave() {
        LONG64 Locks = LocksCount;
        if (Locks == 0) return;
        if (Locks == 1) {
            LocksCount = 0;
            Owner = NULL;
            SpinMutex.Unlock();
        } else {
            LocksCount--;
        }
    }
};
```

`Kernel-Bridge/API/MemoryUtils.cpp`:

```cpp
#include <fltKernel.h>

#include "PTE.h"
#include "PteUtils.h"
#include "MemoryUtils.h"

namespace VirtualMemory {
/*
    In Windows 8 NonPagedPool is deprecated, 
    so we should to use NonPagedPoolNx or NonPagedPoolExecute.
    In Windows 7 or lower we use NonPagedPool that has RWX rights.

    -> !!! NOTICE !!! <-
    To use ExDefaultNonPagedPoolType you should:
    1. Add definition POOL_NX_OPTIN=1 to global preprocessor definitions (look at project settings)
    2. Call ExInitializeDriverRuntime(DrvRtPoolNxOptIn) in your DriverEntry before all allocations
*/
    static const ULONG PoolTag = 'KBLI';

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocFromPool(SIZE_T Bytes, BOOLEAN FillByZeroes) {
        if (!Bytes) return NULL;
        VOID* CONST Address = ExAllocatePoolWithTag(
            ExDefaultNonPagedPoolType,
            Bytes, 
            PoolTag
        );
        if (!Address) return NULL;
        *static_cast<PUCHAR>(Address) = 0x00;
        *(static_cast<PUCHAR>(Address) + Bytes - 1) = 0x00;
        if (FillByZeroes) RtlZeroMemory(Address, Bytes);
        return Address;
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocFromPoolExecutable(SIZE_T Bytes) {
        if (!Bytes) return NULL;
        return ExAllocatePoolWithTag(
            NonPagedPoolExecute,
            Bytes,
            PoolTag
        );
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    LPSTR AllocAnsiString(SIZE_T Characters) {
        return static_cast<LPSTR>(AllocFromPool((Characters + 1) * sizeof(CHAR), TRUE));
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    LPWSTR AllocWideString(SIZE_T Characters) {
        return static_cast<LPWSTR>(AllocFromPool((Characters + 1) * sizeof(WCHAR), TRUE));
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocArray(SIZE_T ElementSize, SIZE_T ElementsCount) {
        return AllocFromPool(ElementSize * ElementsCount, TRUE);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID FreePoolMemory(__drv_freesMem(Mem) PVOID Address) {
        ExFreePoolWithTag(Address, PoolTag);
    }

    _IRQL_requires_max_(APC_LEVEL)
    PVOID AllocNonCachedNorInitialized(SIZE_T Bytes) {
        return MmAllocateNonCachedMemory(Bytes);
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID FreeNonCachedMemory(PVOID Address, SIZE_T Bytes) {
        MmFreeNonCachedMemory(Address, Bytes);
    }

    BOOLEAN CopyMemory(PVOID Dest, PVOID Src, SIZE_T Size, BOOLEAN Intersects, OPTIONAL BOOLEAN CheckBuffersPresence) {
        if (CheckBuffersPresence) {
            if (AddressRange::IsKernelAddress(Src) && !IsMemoryRangePresent(Src, Size)) return FALSE;
            if (AddressRange::IsKernelAddress(Dest) && !IsMemoryRangePresent(Dest, Size)) return FALSE;
        }

        switch (Size) {
        case sizeof(UCHAR): {
            *reinterpret_cast<PUCHAR>(Dest) = *reinterpret_cast<PUCHAR>(Src);
            break;
        }
        case sizeof(USHORT): {
            *reinterpret_cast<PUSHORT>(Dest) = *reinterpret_cast<PUSHORT>(Src);
            break;              
        }
        case sizeof(ULONG): {
            *reinterpret_cast<PULONG>(Dest) = *reinterpret_cast<PULONG>(Src);
            break;
        }
#ifdef _AMD64_
        case sizeof(ULONGLONG): {
            *reinterpret_cast<PULONGLONG>(Dest) = *reinterpret_cast<PULONGLONG>(Src);
            break;
        }
#endif
        default: {
            if (Intersects) {
                RtlMoveMemory(
                    reinterpret_cast<PVOID>(Dest),
                    reinterpret_cast<PVOID>(Src),
                    Size
                );
            } else {
                RtlCopyMemory(
                    reinterpret_cast<PVOID>(Dest),
                    reinterpret_cast<PVOID>(Src),
                    Size
                );
            }
        }
        }
        return TRUE;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN SecureMemory(
        __in_data_source(USER_MODE) PVOID UserAddress, 
        SIZE_T Size, 
        ULONG ProtectRights, 
        OUT PHANDLE SecureHandle
    ) {
        if (!SecureHandle || !Size || AddressRange::IsKernelAddress(UserAddress)) 
            return FALSE;
        *SecureHandle = MmSecureVirtualMemory(UserAddress, Size, ProtectRights);
        return *SecureHandle != NULL;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN SecureProcessMemory(
        PEPROCESS Process,
        __in_data_source(USER_MODE) PVOID UserAddress, 
        SIZE_T Size, 
        ULONG ProtectRights, 
        OUT PHANDLE SecureHandle
    ) {
        if (!Process || !SecureHandle) return FALSE;
        if (Process == PsGetCurrentProcess())
            return SecureMemory(UserAddress, Size, ProtectRights, SecureHandle);

        HANDLE hSecure = NULL;
        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        BOOLEAN Result = SecureMemory(UserAddress, Size, ProtectRights, &hSecure);
        KeUnstackDetachProcess(&ApcState);

        *SecureHandle = hSecure;
        return Result;
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnsecureMemory(HANDLE SecureHandle) {
        if (SecureHandle) MmUnsecureVirtualMemory(SecureHandle);
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnsecureProcessMemory(PEPROCESS Process, HANDLE SecureHandle) {
        if (!Process) return;
        if (Process == PsGetCurrentProcess())
            return UnsecureMemory(SecureHandle);
        if (SecureHandle) {
            KAPC_STATE ApcState;
            KeStackAttachProcess(Process, &ApcState);
            MmUnsecureVirtualMemory(SecureHandle);
            KeUnstackDetachProcess(&ApcState);
        }
    }

    // Check whether access to address causes page fault:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsAddressValid(PVOID Address) {
        return MmIsAddressValid(Address);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsPagePresent(PVOID Address) {
        return PhysicalMemory::GetPhysicalAddress(Address) || MmIsAddressValid(Address);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsMemoryRangePresent(PVOID Address, SIZE_T Size) {
        PVOID PageCounter = ALIGN_DOWN_POINTER_BY(Address, PAGE_SIZE);
        do {
            if (!IsPagePresent(PageCounter)) return FALSE;
            PageCounter = reinterpret_cast<PVOID>(reinterpret_cast<SIZE_T>(PageCounter) + PAGE_SIZE);
        } while (reinterpret_cast<SIZE_T>(PageCounter) < reinterpret_cast<SIZE_T>(Address) + Size);
        return TRUE;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckUserMemoryReadable(__in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size) {
        __try {
            ProbeForRead(UserAddress, Size, 1);
            return TRUE;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckProcessMemoryReadable(PEPROCESS Process, __in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size) {
        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        BOOLEAN Status = CheckUserMemoryReadable(UserAddress, Size);
        KeUnstackDetachProcess(&ApcState);
        return Status;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckUserMemoryWriteable(__in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size) {
        __try {
            ProbeForWrite(UserAddress, Size, 1);
            return TRUE;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckProcessMemoryWriteable(PEPROCESS Process, __in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size) {
        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        BOOLEAN Status = CheckUserMemoryWriteable(UserAddress, Size);
        KeUnstackDetachProcess(&ApcState);
        return Status;
    }
}

namespace Heap {
    // Creates a growable heap and returns a HeapHandle:
    _IRQL_requires_max_(APC_LEVEL)
    PVOID CreateHeap() {
        return RtlCreateHeap(
            HEAP_GROWABLE,
            NULL,
            PAGE_SIZE * 2,
            PAGE_SIZE,
            NULL,
            NULL
        );
    }

    // Allocates memory from heap and returns allocated buffer address:
    _IRQL_requires_max_(APC_LEVEL)
    PVOID AllocHeap(PVOID HeapHandle, SIZE_T Size, BOOLEAN ZeroMemory) {
        if (!HeapHandle || !Size) return NULL;
        PVOID Buffer = RtlAllocateHeap(HeapHandle, ZeroMemory ? HEAP_ZERO_MEMORY : 0, Size);
        if (Buffer && !ZeroMemory) {
            *static_cast<PUCHAR>(Buffer) = 0x00;
            *(static_cast<PUCHAR>(Buffer) + Size - 1) = 0x00;
        }
        return Buffer;
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID FreeHeap(PVOID HeapHandle, _Frees_ptr_opt_ PVOID Address) {
        if (!HeapHandle || !Address) return;
        RtlFreeHeap(HeapHandle, 0, Address);
    }

    // Free all of heap memory and destroy the heap object:
    _IRQL_requires_max_(APC_LEVEL)
    VOID DestroyHeap(PVOID HeapHandle) {
        if (HeapHandle) RtlDestroyHeap(HeapHandle);
    }


    _IRQL_requires_max_(APC_LEVEL)
    HeapObject::HeapObject() 
    : HeapHandle(CreateHeap()) {}

    _IRQL_requires_max_(APC_LEVEL)
    HeapObject::~HeapObject() {
        DestroyHeap(HeapHandle);
    }
    
    BOOLEAN HeapObject::IsHeapValid() const {
        return HeapHandle != NULL;
    }
    
    _IRQL_requires_max_(APC_LEVEL)
    PVOID HeapObject::Alloc(SIZE_T Size, BOOLEAN ZeroMemory) const {
        return AllocHeap(HeapHandle, Size, ZeroMemory);
    }
    
    _IRQL_requires_max_(APC_LEVEL)
    VOID HeapObject::Free(PVOID Address) const {
        FreeHeap(HeapHandle, Address);
    }
    
    _IRQL_requires_max_(APC_LEVEL)
    LPSTR HeapObject::AllocAnsiString(SIZE_T Characters) const {
        return static_cast<LPSTR>(AllocHeap(HeapHandle, (Characters + 1) * sizeof(CHAR)));
    }
    
    _IRQL_requires_max_(APC_LEVEL)
    LPWSTR HeapObject::AllocWideString(SIZE_T Characters) const {
        return static_cast<LPWSTR>(AllocHeap(HeapHandle, (Characters + 1) * sizeof(WCHAR)));
    }
    
    _IRQL_requires_max_(APC_LEVEL)
    PVOID HeapObject::AllocArray(SIZE_T ElementSize, SIZE_T ElementsCount) const {
        return AllocHeap(HeapHandle, ElementSize * ElementsCount);
    }
}

namespace PhysicalMemory {
    const int DMI_SIZE = 65536;

    // DMI size is 65536 bytes:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN ReadDmiMemory(OUT PVOID Buffer, SIZE_T Size) {
        PHYSICAL_ADDRESS DmiAddress;
        DmiAddress.QuadPart = 0xF0000;
        PVOID DmiMemory = MmMapIoSpace(DmiAddress, Size, MmNonCached);
        BOOLEAN Status = DmiMemory != NULL;
        if (Status) {
            RtlMoveMemory(Buffer, DmiMemory, Size);
            MmUnmapIoSpace(DmiMemory, Size);
        }
        return Status;
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocPhysicalMemory(PVOID64 HighestAcceptableAddress, SIZE_T Size) {
        return MmAllocateContiguousMemory(
            Size, 
            *reinterpret_cast<PHYSICAL_ADDRESS*>(&HighestAcceptableAddress)
        );
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocPhysicalMemorySpecifyCache(
        PVOID64 LowestAcceptableAddress,
        PVOID64 HighestAcceptableAddress,
        PVOID64 BoundaryAddressMultiple,
        SIZE_T Size,
        MEMORY_CACHING_TYPE CachingType
    ) {
        return MmAllocateContiguousMemorySpecifyCache(
            Size, 
            *reinterpret_cast<PHYSICAL_ADDRESS*>(&LowestAcceptableAddress),
            *reinterpret_cast<PHYSICAL_ADDRESS*>(&HighestAcceptableAddress),
            *reinterpret_cast<PHYSICAL_ADDRESS*>(&BoundaryAddressMultiple),
            CachingType
        );
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID FreePhysicalMemory(PVOID BaseVirtualAddress) {
        MmFreeContiguousMemory(BaseVirtualAddress);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID MapPhysicalMemory(PVOID64 PhysicalAddress, SIZE_T Size, MEMORY_CACHING_TYPE CachingType) {
        return MmMapIoSpace(*reinterpret_cast<PHYSICAL_ADDRESS*>(&PhysicalAddress), Size, CachingType);
    }

    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID UnmapPhysicalMemory(PVOID64 MappedPhysicalMemory, SIZE_T Size) {
        MmUnmapIoSpace(MappedPhysicalMemory, Size);
    }

    _IRQL_requires_max_(APC_LEVEL)
    PVOID64 GetPhysicalAddress(PVOID VirtualAddress, OPTIONAL PEPROCESS Process) {
        if (!Process || Process == PsGetCurrentProcess()) {
            return MmIsAddressValid(VirtualAddress)
                ? reinterpret_cast<PVOID64>(MmGetPhysicalAddress(VirtualAddress).QuadPart)
                : NULL;
        }

        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        PVOID64 PhysicalAddress = MmIsAddressValid(VirtualAddress)
            ? reinterpret_cast<PVOID64>(MmGetPhysicalAddress(VirtualAddress).QuadPart)
            : NULL;
        KeUnstackDetachProcess(&ApcState);
        return PhysicalAddress;
    }

    PVOID GetVirtualForPhysical(PVOID64 PhysicalAddress) {
        return MmGetVirtualForPhysical(*reinterpret_cast<PPHYSICAL_ADDRESS>(&PhysicalAddress));
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN ReadPhysicalMemory(IN PVOID64 PhysicalAddress, OUT PVOID Buffer, SIZE_T Length, MEMORY_CACHING_TYPE CachingType) {
        BOOLEAN Status;
        PVOID VirtualAddress = GetVirtualForPhysical(PhysicalAddress);
        if (VirtualAddress) {
            __try {
                VirtualMemory::CopyMemory(Buffer, VirtualAddress, Length);
                Status = TRUE;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = FALSE;
            }
        } else {
            Status = FALSE;
        }

        if (!Status) {
            PVOID MappedMemory = MapPhysicalMemory(PhysicalAddress, Length, CachingType);
            if (!MappedMemory) return FALSE;
            __try {
                VirtualMemory::CopyMemory(Buffer, MappedMemory, Length);
                Status = TRUE;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = FALSE;
            }
            UnmapPhysicalMemory(MappedMemory, Length);
        }

        return Status;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN WritePhysicalMemory(OUT PVOID64 PhysicalAddress, IN PVOID Buffer, SIZE_T Length, MEMORY_CACHING_TYPE CachingType) {
        BOOLEAN Status;
        PVOID VirtualAddress = GetVirtualForPhysical(PhysicalAddress);
        if (VirtualAddress) {
            __try {
                VirtualMemory::CopyMemory(VirtualAddress, Buffer, Length);
                Status = TRUE;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = FALSE;
            }
        } else {
            Status = FALSE;
        }

        if (!Status) {
            PVOID MappedMemory = MapPhysicalMemory(PhysicalAddress, Length, CachingType);
            if (!MappedMemory) return FALSE;
            __try {
                VirtualMemory::CopyMemory(MappedMemory, Buffer, Length);
                Status = TRUE;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = FALSE;
            }
            UnmapPhysicalMemory(MappedMemory, Length);
        }

        return Status;
    }
}

namespace Mdl {
    _IRQL_requires_max_(APC_LEVEL)
    PMDL AllocMdlAndLockPages(
        PVOID Address, 
        ULONG Size, 
        KPROCESSOR_MODE AccessMode, 
        LOCK_OPERATION Operation, 
        OPTIONAL PEPROCESS Process
    ) {
        if (!Address || !Size) return NULL;
        PMDL Mdl = IoAllocateMdl(Address, Size, FALSE, FALSE, NULL);
        if (!Mdl) return NULL;
        __try {
            if (Process && Process != PsGetCurrentProcess())
                MmProbeAndLockProcessPages(Mdl, Process, AccessMode, Operation);
            else
                MmProbeAndLockPages(Mdl, AccessMode, Operation);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            IoFreeMdl(Mdl);
            return NULL;
        }
        return Mdl;
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnlockPagesAndFreeMdl(PMDL Mdl) {
        if (!Mdl) return;
        MmUnlockPages(Mdl);
        IoFreeMdl(Mdl);
    }

    _IRQL_requires_max_(APC_LEVEL)
    NTSTATUS MapMdl(
        IN PMDL Mdl,
        OUT PVOID* MappedMemory,
        OPTIONAL PEPROCESS SrcProcess,
        OPTIONAL PEPROCESS DestProcess,
        BOOLEAN NeedProbeAndLock,
        KPROCESSOR_MODE MapToAddressSpace, 
        ULONG Protect,
        MEMORY_CACHING_TYPE CacheType,
        OPTIONAL PVOID UserRequestedAddress     
    ) {
        if (!MappedMemory) return STATUS_INVALID_PARAMETER;
        *MappedMemory = NULL;

        if (UserRequestedAddress) {
            if (
                (MapToAddressSpace == KernelMode && AddressRange::IsUserAddress(UserRequestedAddress)) ||
                (MapToAddressSpace == UserMode && AddressRange::IsKernelAddress(UserRequestedAddress))
            ) return STATUS_INVALID_PARAMETER_6; // Access mode is incompatible with UserRequestAddress!
        }

        BOOLEAN IsLocked = FALSE;
        BOOLEAN IsAttached = FALSE;
        KAPC_STATE ApcState;
        __try {
            PEPROCESS CurrentProcess = PsGetCurrentProcess();

            // Lock and prepare pages in target process:
            if (NeedProbeAndLock) {
                if (!SrcProcess || SrcProcess == CurrentProcess)
                    MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
                else
                    MmProbeAndLockProcessPages(Mdl, SrcProcess, KernelMode, IoReadAccess);
                IsLocked = TRUE;
            }

            if (DestProcess && DestProcess != CurrentProcess) {
                KeStackAttachProcess(DestProcess, &ApcState);
                IsAttached = TRUE;
            }

            // Map prepared pages to current process:
            PVOID Mapping = MmMapLockedPagesSpecifyCache(
                Mdl,
                MapToAddressSpace,
                CacheType,
                MapToAddressSpace == UserMode ? UserRequestedAddress : NULL,
                FALSE,
                NormalPagePriority
            );

            MmProtectMdlSystemAddress(Mdl, Protect);

            if (IsAttached) KeUnstackDetachProcess(&ApcState);
            *MappedMemory = Mapping;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            if (IsAttached) KeUnstackDetachProcess(&ApcState);
            if (IsLocked) MmUnlockPages(Mdl);
            return STATUS_UNSUCCESSFUL;                
        }

        return STATUS_SUCCESS;
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnmapMdl(IN PMDL Mdl, IN PVOID MappedMemory, BOOLEAN NeedUnlock) {
        MmUnmapLockedPages(MappedMemory, Mdl);
        if (NeedUnlock) MmUnlockPages(Mdl);
    }

    _IRQL_requires_max_(APC_LEVEL)
    NTSTATUS MapMemory(
        OUT PMAPPING_INFO MappingInfo,
        OPTIONAL PEPROCESS SrcProcess,
        OPTIONAL PEPROCESS DestProcess,
        IN PVOID VirtualAddress,
        ULONG Size,
        KPROCESSOR_MODE MapToAddressSpace,
        ULONG Protect,
        MEMORY_CACHING_TYPE CacheType,
        OPTIONAL PVOID UserRequestedAddress 
    ) {
        if (!Size || !MappingInfo) return STATUS_INVALID_PARAMETER;

        *MappingInfo = {};

        MappingInfo->Mdl = IoAllocateMdl(VirtualAddress, Size, FALSE, FALSE, NULL);
        if (!MappingInfo->Mdl) return STATUS_MEMORY_NOT_ALLOCATED;

        NTSTATUS Status = MapMdl(
            MappingInfo->Mdl,
            &MappingInfo->BaseAddress,
            SrcProcess,
            DestProcess,
            TRUE,
            MapToAddressSpace,
            Protect,
            CacheType,
            UserRequestedAddress
        );
        
        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_INVALID_PARAMETER_6)
                Status = STATUS_INVALID_PARAMETER_7; // Do it corresponding to current prototype
            IoFreeMdl(MappingInfo->Mdl);
            *MappingInfo = {};
        }

        return Status;
    }

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnmapMemory(IN PMAPPING_INFO MappingInfo) {
        MmUnmapLockedPages(MappingInfo->BaseAddress, MappingInfo->Mdl);
        MmUnlockPages(MappingInfo->Mdl);
        IoFreeMdl(MappingInfo->Mdl);
    }
}
```

`Kernel-Bridge/API/MemoryUtils.h`:

```h
#pragma once

namespace AddressRange {
    inline BOOLEAN IsUserAddress(PVOID Address) {
        return reinterpret_cast<SIZE_T>(Address) < (static_cast<SIZE_T>(1) << (8 * sizeof(SIZE_T) - 1));
    }

    inline BOOLEAN IsKernelAddress(PVOID Address) {
        return reinterpret_cast<SIZE_T>(Address) >= (static_cast<SIZE_T>(1) << (8 * sizeof(SIZE_T) - 1));
    }
}

namespace VirtualMemory {
    // Allocates non-paged not initialized memory from pool:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocFromPool(SIZE_T Bytes, BOOLEAN FillByZeroes = TRUE);

    // Such as AllocFromPool but with executable rights:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocFromPoolExecutable(SIZE_T Bytes);

    // Allocates zero-initialized null-terminated ANSI-string (char*):
    _IRQL_requires_max_(DISPATCH_LEVEL)
    LPSTR AllocAnsiString(SIZE_T Characters);

    // Allocates zero-initialized null-terminated Unicode string (wchar_t*);
    _IRQL_requires_max_(DISPATCH_LEVEL)
    LPWSTR AllocWideString(SIZE_T Characters);

    // Allocates zero-initialized buffer to contain an array:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocArray(SIZE_T ElementSize, SIZE_T ElementsCount);

    template <typename T>
    inline T* AllocArray(SIZE_T ElementsCount)
    {
        return reinterpret_cast<T*>(AllocArray(sizeof(T), ElementsCount));
    }

    template <typename T>
    inline T* Alloc()
    {
        return reinterpret_cast<T*>(AllocFromPool(sizeof(T)));
    }

    // Free memory allocated by Alloc[FromPool[Executable]/AnsiString/WideString/Array]:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID FreePoolMemory(__drv_freesMem(Mem) PVOID Address);

    _IRQL_requires_max_(APC_LEVEL)
    PVOID AllocNonCachedNorInitialized(SIZE_T Bytes);

    _IRQL_requires_max_(APC_LEVEL)
    VOID FreeNonCachedMemory(PVOID Address, SIZE_T Bytes);

    BOOLEAN CopyMemory(
        PVOID Dest, 
        PVOID Src, 
        SIZE_T Size, 
        BOOLEAN Intersects = FALSE, 
        OPTIONAL BOOLEAN CheckBuffersPresence = FALSE
    );

    // Secure user memory from page rights descending or memory freeing:
    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN SecureMemory(
        __in_data_source(USER_MODE) PVOID UserAddress, 
        SIZE_T Size, 
        ULONG ProtectRights, // PAGE_*** 
        OUT PHANDLE SecureHandle
    );

    // Secure user memory of specified process from page rights descending or memory freeing:
    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN SecureProcessMemory(
        PEPROCESS Process,
        __in_data_source(USER_MODE) PVOID UserAddress, 
        SIZE_T Size, 
        ULONG ProtectRights, // PAGE_*** 
        OUT PHANDLE SecureHandle
    );

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnsecureMemory(HANDLE SecureHandle);

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnsecureProcessMemory(PEPROCESS Process, HANDLE SecureHandle);

    // Check whether access to address causes page fault:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsAddressValid(PVOID Address);

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsPagePresent(PVOID Address);

    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN IsMemoryRangePresent(PVOID Address, SIZE_T Size);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckUserMemoryReadable(__in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckProcessMemoryReadable(PEPROCESS Process, __in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckUserMemoryWriteable(__in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN CheckProcessMemoryWriteable(PEPROCESS Process, __in_data_source(USER_MODE) PVOID UserAddress, SIZE_T Size);
}

namespace Heap {
    // Creates a growable heap and returns a HeapHandle:
    _IRQL_requires_max_(APC_LEVEL)
    PVOID CreateHeap();

    // Allocates memory from heap and returns allocated buffer address:
    _IRQL_requires_max_(APC_LEVEL)
    PVOID AllocHeap(PVOID HeapHandle, SIZE_T Size, BOOLEAN ZeroMemory = TRUE);

    _IRQL_requires_max_(APC_LEVEL)
    VOID FreeHeap(PVOID HeapHandle, _Frees_ptr_opt_ PVOID Address);

    // Free all of heap memory and destroy the heap object:
    _IRQL_requires_max_(APC_LEVEL)
    VOID DestroyHeap(PVOID HeapHandle);

    // Class for simplification of heap using:
    class HeapObject final {
    private:
        PVOID HeapHandle;
    public:
        _IRQL_requires_max_(APC_LEVEL)
        HeapObject();

        _IRQL_requires_max_(APC_LEVEL)
        ~HeapObject();
        
        BOOLEAN IsHeapValid() const;
        
        _IRQL_requires_max_(APC_LEVEL)
        PVOID Alloc(SIZE_T Size, BOOLEAN ZeroMemory = TRUE) const;
        
        _IRQL_requires_max_(APC_LEVEL)
        VOID Free(PVOID Address) const;
        
        _IRQL_requires_max_(APC_LEVEL)
        LPSTR AllocAnsiString(SIZE_T Characters) const;
        
        _IRQL_requires_max_(APC_LEVEL)
        LPWSTR AllocWideString(SIZE_T Characters) const;
        
        _IRQL_requires_max_(APC_LEVEL)
        PVOID AllocArray(SIZE_T ElementSize, SIZE_T ElementsCount) const;
    };
}

namespace PhysicalMemory {
    extern const int DMI_SIZE;

    // DMI/SMBIOS size is 65536 bytes (0xF0000..0xFFFFF in physical memory):
    _IRQL_requires_max_(DISPATCH_LEVEL)
    BOOLEAN ReadDmiMemory(OUT PVOID Buffer, SIZE_T Size);

    // Allocates physically-contiguous memory;
    // Highest acceptable address is a highest physical 
    // address that can be used to allocate memory:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocPhysicalMemory(PVOID64 HighestAcceptableAddress, SIZE_T Size);

    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID AllocPhysicalMemorySpecifyCache(
        PVOID64 LowestAcceptableAddress,
        PVOID64 HighestAcceptableAddress,
        PVOID64 BoundaryAddressMultiple,
        SIZE_T Size,
        MEMORY_CACHING_TYPE CachingType
    );

    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID FreePhysicalMemory(PVOID BaseVirtualAddress);

    // Map physical address-space to virtual memory:
    _IRQL_requires_max_(DISPATCH_LEVEL)
    PVOID MapPhysicalMemory(PVOID64 PhysicalAddress, SIZE_T Size, MEMORY_CACHING_TYPE CachingType);

    _IRQL_requires_max_(DISPATCH_LEVEL)
    VOID UnmapPhysicalMemory(PVOID64 MappedPhysicalMemory, SIZE_T Size);

    // Get the physical address for non-paged virtual memory:
    _IRQL_requires_max_(APC_LEVEL)
    PVOID64 GetPhysicalAddress(PVOID VirtualAddress, OPTIONAL PEPROCESS Process = NULL);

    PVOID GetVirtualForPhysical(PVOID64 PhysicalAddress);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN ReadPhysicalMemory(IN PVOID64 PhysicalAddress, OUT PVOID Buffer, SIZE_T Length, MEMORY_CACHING_TYPE CachingType);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN WritePhysicalMemory(OUT PVOID64 PhysicalAddress, IN PVOID Buffer, SIZE_T Length, MEMORY_CACHING_TYPE CachingType);
}

namespace Mdl {
    _IRQL_requires_max_(APC_LEVEL)
    PMDL AllocMdlAndLockPages(
        PVOID Address,
        ULONG Size,
        KPROCESSOR_MODE AccessMode = KernelMode,
        LOCK_OPERATION Operation = IoReadAccess,
        OPTIONAL PEPROCESS Process = NULL
    );

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnlockPagesAndFreeMdl(PMDL Mdl);

    _IRQL_requires_max_(APC_LEVEL)
    NTSTATUS MapMdl(
        IN PMDL Mdl,
        OUT PVOID* MappedMemory, // Receives the bease address of mapped memory
        OPTIONAL PEPROCESS SrcProcess, // Set NULL to use the address space of current process 
        OPTIONAL PEPROCESS DestProcess, // Set NULL to use the address space of current process
        BOOLEAN NeedProbeAndLock,
        KPROCESSOR_MODE MapToAddressSpace = KernelMode,
        ULONG Protect = PAGE_READWRITE,
        MEMORY_CACHING_TYPE CacheType = MmNonCached,
        OPTIONAL PVOID UserRequestedAddress = NULL    
    );

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnmapMdl(IN PMDL Mdl, IN PVOID MappedMemory, BOOLEAN NeedUnlock);

    // Result type of MapMemory function:
    using MAPPING_INFO = struct {
        PMDL Mdl;
        PVOID BaseAddress;
    };
    using PMAPPING_INFO = MAPPING_INFO*;

    _IRQL_requires_max_(APC_LEVEL)
    NTSTATUS MapMemory(
        OUT PMAPPING_INFO MappingInfo,
        OPTIONAL PEPROCESS SrcProcess,
        OPTIONAL PEPROCESS DestProcess,
        IN PVOID VirtualAddress, // Address in SrcProcess to map in the DestProcess
        ULONG Size,
        KPROCESSOR_MODE MapToAddressSpace = KernelMode,
        ULONG Protect = PAGE_READWRITE,
        MEMORY_CACHING_TYPE CacheType = MmNonCached,
        OPTIONAL PVOID UserRequestedAddress = NULL
    );

    _IRQL_requires_max_(APC_LEVEL)
    VOID UnmapMemory(IN PMAPPING_INFO MappingInfo);
}
```

`Kernel-Bridge/API/OSVersion.cpp`:

```cpp
#include <wdm.h>
#include "OSVersion.h"

BOOLEAN OSVersion::Initialized = FALSE;
OSVersion::_OSVersion OSVersion::Version = {};

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID OSVersion::Initialize() {
    if (Initialized) return;
    PsGetVersion(&Version.Major, &Version.Minor, NULL, NULL);
    Initialized = TRUE;
}

BOOLEAN OSVersion::IsGreaterThan(ULONG Major, ULONG Minor) {
    if (!Initialized) Initialize();
    return (Version.Major > Major) || (Version.Major == Major && Version.Minor >= Minor);
}

BOOLEAN OSVersion::IsWindowsXPOrGreater() {
    return IsGreaterThan(5, 1);
}

BOOLEAN OSVersion::IsWindowsXP64OrGreater() {
    return IsGreaterThan(5, 2);
}

BOOLEAN OSVersion::IsWindowsVistaOrGreater() {
    return IsGreaterThan(6, 0);
}

BOOLEAN OSVersion::IsWindows7OrGreater() {
    return IsGreaterThan(6, 1);
}

BOOLEAN OSVersion::IsWindows8OrGreater() {
    return IsGreaterThan(6, 2);
}

BOOLEAN OSVersion::IsWindows81OrGreater() {
    return IsGreaterThan(6, 3);
}

BOOLEAN OSVersion::IsWindows10OrGreater() {
    return IsGreaterThan(10, 0);
}
```

`Kernel-Bridge/API/OSVersion.h`:

```h
#pragma once

class OSVersion final {
private:
    using _OSVersion = struct {
        ULONG Major;
        ULONG Minor;
    };
    static BOOLEAN Initialized;
    static _OSVersion Version;
    static VOID Initialize();
public:
    static BOOLEAN IsGreaterThan(ULONG Major, ULONG Minor);
    static BOOLEAN IsWindowsXPOrGreater();
    static BOOLEAN IsWindowsXP64OrGreater();
    static BOOLEAN IsWindowsVistaOrGreater();
    static BOOLEAN IsWindows7OrGreater();
    static BOOLEAN IsWindows8OrGreater();
    static BOOLEAN IsWindows81OrGreater();
    static BOOLEAN IsWindows10OrGreater();
};
```

`Kernel-Bridge/API/ObCallbacks.cpp`:

```cpp
#include <wdm.h>

#include "ObCallbacks.h"
#include "Importer.h"

ObCallbacks::ObCallbacks() : RegistrationHandle(NULL) {
    // For the WinXP support we should import them dynamically:
    DynObRegisterCallbacks = static_cast<_ObRegisterCallbacks>(
        Importer::GetKernelProcAddress(L"ObRegisterCallbacks")
    );
    DynObUnRegisterCallbacks = static_cast<_ObUnRegisterCallbacks>(
        Importer::GetKernelProcAddress(L"ObUnRegisterCallbacks")
    );
}

ObCallbacks::ObCallbacks(
    OPTIONAL OB_PREOP_CALLBACK_STATUS(NTAPI *PreCallback)(
        PVOID RegistrationContext, 
        POB_PRE_OPERATION_INFORMATION OperationInformation
    ),
    OPTIONAL VOID (NTAPI *PostCallback)(
        PVOID RegistrationContext,
        POB_POST_OPERATION_INFORMATION OperationInformation
    ),
    OPTIONAL PVOID RegistrationContext,
    ObCallbackType CallbackType,
    OB_OPERATION OperationType
) : ObCallbacks() {
    SetupCallbacks(PreCallback, PostCallback, RegistrationContext, CallbackType, OperationType);
}

ObCallbacks::~ObCallbacks() {
    RemoveCallbacks();
}

NTSTATUS ObCallbacks::SetupCallbacks(
    OPTIONAL OB_PREOP_CALLBACK_STATUS(NTAPI *PreCallback)(
        PVOID RegistrationContext, 
        POB_PRE_OPERATION_INFORMATION OperationInformation
    ),
    OPTIONAL VOID (NTAPI *PostCallback)(
        PVOID RegistrationContext,
        POB_POST_OPERATION_INFORMATION OperationInformation
    ),
    OPTIONAL PVOID RegistrationContext,
    ObCallbackType CallbackType,
    OB_OPERATION OperationType
) {
    if (RegistrationHandle) RemoveCallbacks();

    if (!DynObRegisterCallbacks || !DynObUnRegisterCallbacks) 
        return STATUS_NOT_SUPPORTED;

    if ((CallbackType == (ctProcesses | ctThreads)) || (CallbackType == ctMaxValue)) 
        CallbackType = ctAll;

    if (!PreCallback && !PostCallback) 
        return STATUS_INVALID_PARAMETER;

    OB_OPERATION_REGISTRATION Operations[ctMaxValue - 1] = {};
    
    Operations[ctProcesses - 1].ObjectType = PsProcessType;
    Operations[ctProcesses - 1].Operations = OperationType;
    Operations[ctProcesses - 1].PreOperation = PreCallback;
    Operations[ctProcesses - 1].PostOperation = PostCallback;
    
    Operations[ctThreads - 1].ObjectType = PsThreadType;
    Operations[ctThreads - 1].Operations = OperationType;
    Operations[ctThreads - 1].PreOperation = PreCallback;
    Operations[ctThreads - 1].PostOperation = PostCallback;

    OB_CALLBACK_REGISTRATION Registration = {};
    Registration.Version = OB_FLT_REGISTRATION_VERSION;
    Registration.OperationRegistrationCount = CallbackType == ctAll 
        ? sizeof(Operations) / sizeof(*Operations) 
        : 1;
    RtlInitUnicodeString(&Registration.Altitude, L"389020");
    Registration.RegistrationContext = RegistrationContext;
    Registration.OperationRegistration = CallbackType == ctAll 
        ? reinterpret_cast<POB_OPERATION_REGISTRATION>(&Operations)
        : reinterpret_cast<POB_OPERATION_REGISTRATION>(&Operations[CallbackType - 1]);

    return DynObRegisterCallbacks(&Registration, &RegistrationHandle);
}

VOID ObCallbacks::RemoveCallbacks() {
    if (RegistrationHandle)
        DynObUnRegisterCallbacks(RegistrationHandle);
    RegistrationHandle = NULL;
}
```

`Kernel-Bridge/API/ObCallbacks.h`:

```h
#pragma once

class ObCallbacks final {
private:
    using _ObRegisterCallbacks = NTSTATUS(NTAPI*)(
        POB_CALLBACK_REGISTRATION CallbackRegistration,
        PVOID* RegistrationHandle    
    );
    using _ObUnRegisterCallbacks = NTSTATUS(NTAPI*)(
        PVOID RegistrationHandle
    );

    PVOID RegistrationHandle;
    _ObRegisterCallbacks DynObRegisterCallbacks;
    _ObUnRegisterCallbacks DynObUnRegisterCallbacks;

public:
    ObCallbacks(const ObCallbacks&) = delete;
    ObCallbacks(ObCallbacks&&) = delete;
    ObCallbacks& operator = (const ObCallbacks&) = delete;
    ObCallbacks& operator = (ObCallbacks&&) = delete;

    enum ObCallbackType {
        ctAll,
        ctProcesses,
        ctThreads,
        ctMaxValue // Same as ctAll
    };

    ObCallbacks();
    ObCallbacks(
        OPTIONAL OB_PREOP_CALLBACK_STATUS(NTAPI *PreCallback)(
            PVOID RegistrationContext, 
            POB_PRE_OPERATION_INFORMATION OperationInformation
        ),
        OPTIONAL VOID (NTAPI *PostCallback)(
            PVOID RegistrationContext,
            POB_POST_OPERATION_INFORMATION OperationInformation
        ) = NULL,
        OPTIONAL PVOID RegistrationContext = NULL,
        ObCallbackType ObjectType = ObCallbackType::ctAll,
        OB_OPERATION OperationType = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE    
    );
    ~ObCallbacks();

    NTSTATUS SetupCallbacks(
        OPTIONAL OB_PREOP_CALLBACK_STATUS(NTAPI *PreCallback)(
            PVOID RegistrationContext, 
            POB_PRE_OPERATION_INFORMATION OperationInformation
        ),
        OPTIONAL VOID (NTAPI *PostCallback)(
            PVOID RegistrationContext,
            POB_POST_OPERATION_INFORMATION OperationInformation
        ) = NULL,
        OPTIONAL PVOID RegistrationContext = NULL,
        ObCallbackType ObjectType = ObCallbackType::ctAll,
        OB_OPERATION OperationType = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE
    );
    VOID RemoveCallbacks();
};
```

`Kernel-Bridge/API/ProcessesUtils.cpp`:

```cpp
#include <fltKernel.h>
#include "Importer.h"
#include "MemoryUtils.h"
#include "PTE.h"
#include "PteUtils.h"
#include "ProcessesUtils.h"

namespace Processes {
    namespace Descriptors {
        _IRQL_requires_max_(APC_LEVEL)
        PEPROCESS GetEPROCESS(HANDLE ProcessId) {
            PEPROCESS Process;
            return NT_SUCCESS(PsLookupProcessByProcessId(ProcessId, &Process)) 
                ? Process 
                : NULL;
        }

        _IRQL_requires_max_(APC_LEVEL)
        PETHREAD GetETHREAD(HANDLE ThreadId) {
            PETHREAD Thread;
            return NT_SUCCESS(PsLookupThreadByThreadId(ThreadId, &Thread)) 
                ? Thread 
                : NULL;            
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenProcess(
            HANDLE ProcessId, 
            OUT PHANDLE hProcess, 
            ACCESS_MASK AccessMask, 
            ULONG Attributes
        ) {
            CLIENT_ID ClientId;
            ClientId.UniqueProcess = ProcessId;
            ClientId.UniqueThread  = 0;

            OBJECT_ATTRIBUTES ObjectAttributes;
            InitializeObjectAttributes(&ObjectAttributes, NULL, Attributes, NULL, NULL);

            return ZwOpenProcess(hProcess, AccessMask, &ObjectAttributes, &ClientId);
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenProcessByPointer(
            PEPROCESS Process, 
            OUT PHANDLE hProcess, 
            ACCESS_MASK AccessMask, 
            ULONG Attributes,
            KPROCESSOR_MODE ProcessorMode
        ) {
            return ObOpenObjectByPointer(
                Process,
                Attributes,
                NULL,
                AccessMask,
                *PsProcessType,
                ProcessorMode,
                hProcess
            );
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenThread(
            HANDLE ThreadId, 
            OUT PHANDLE hThread, 
            ACCESS_MASK AccessMask, 
            ULONG Attributes
        ) {
            CLIENT_ID ClientId;
            ClientId.UniqueProcess = 0;
            ClientId.UniqueThread  = ThreadId;

            OBJECT_ATTRIBUTES ObjectAttributes;
            InitializeObjectAttributes(&ObjectAttributes, NULL, Attributes, NULL, NULL);

            using _ZwOpenThread = NTSTATUS(NTAPI*)(
                OUT PHANDLE hThread,
                IN ACCESS_MASK AccessMask,
                IN POBJECT_ATTRIBUTES ObjectAttributes,
                IN PCLIENT_ID ClientId
            );

            auto ZwOpenThread = static_cast<_ZwOpenThread>(Importer::GetKernelProcAddress(L"ZwOpenThread"));
            if (!ZwOpenThread) return STATUS_NOT_IMPLEMENTED;

            return ZwOpenThread(hThread, AccessMask, &ObjectAttributes, &ClientId);
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenThreadByPointer(
            PETHREAD Thread, 
            OUT PHANDLE hThread, 
            ACCESS_MASK AccessMask, 
            ULONG Attributes,
            KPROCESSOR_MODE ProcessorMode
        ) {
            return ObOpenObjectByPointer(
                Thread,
                Attributes,
                NULL,
                AccessMask,
                *PsThreadType,
                ProcessorMode,
                hThread
            );
        }
    }

    namespace AddressSpace {
        _IRQL_requires_max_(APC_LEVEL)
        BOOLEAN AttachToProcessByPid(HANDLE ProcessId, OUT PKAPC_STATE ApcState) {
            if (!ApcState) return FALSE;
            PEPROCESS Process = Descriptors::GetEPROCESS(ProcessId);
            if (!Process) return FALSE;
            BOOLEAN Status = AttachToProcess(Process, ApcState);
            ObDereferenceObject(Process);
            return Status;
        }

        _IRQL_requires_max_(APC_LEVEL)
        BOOLEAN AttachToProcess(PEPROCESS Process, OUT PKAPC_STATE ApcState) {
            if (!Process || !ApcState) return FALSE;
            KeStackAttachProcess(Process, ApcState);
            return TRUE;
        }

        _IRQL_requires_max_(APC_LEVEL)
        VOID DetachFromProcess(IN PKAPC_STATE ApcState) {
            KeUnstackDetachProcess(ApcState);
        }
    }

    namespace Terminator {
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS TerminateProcessByPid(HANDLE ProcessId, NTSTATUS ExitStatus) {
            HANDLE hProcess = NULL;
            NTSTATUS Status = Descriptors::OpenProcess(ProcessId, &hProcess);
            if (NT_SUCCESS(Status)) {
                Status = TerminateProcess(hProcess, ExitStatus);
                ZwClose(hProcess);
            }
            return Status;
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS TerminateProcess(HANDLE hProcess, NTSTATUS ExitStatus) {
            return ZwTerminateProcess(hProcess, ExitStatus);
        }
    }

    namespace Threads {
        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS GetContextThread(IN PETHREAD Thread, OUT PCONTEXT Context, IN KPROCESSOR_MODE PreviousMode) {
            using _PsGetContextThread = NTSTATUS (NTAPI*)(
                IN PETHREAD Thread,
                OUT PCONTEXT Context,
                IN KPROCESSOR_MODE PreviousMode
            );
            static auto _GetContextThread = 
                static_cast<_PsGetContextThread>(Importer::GetKernelProcAddress(L"PsGetContextThread"));
            return _GetContextThread
                ? _GetContextThread(Thread, Context, PreviousMode)
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS SetContextThread(IN PETHREAD Thread, IN PCONTEXT Context, IN KPROCESSOR_MODE PreviousMode) {
            using _PsSetContextThread = NTSTATUS (NTAPI*)(
                IN PETHREAD Thread,
                IN PCONTEXT Context,
                IN KPROCESSOR_MODE PreviousMode
            );
            static auto _SetContextThread = 
                static_cast<_PsSetContextThread>(Importer::GetKernelProcAddress(L"PsSetContextThread"));
            return _SetContextThread
                ? _SetContextThread(Thread, Context, PreviousMode)
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS SuspendProcess(IN PEPROCESS Process) {
            using _PsSuspendProcess = NTSTATUS (NTAPI*)(
                IN PEPROCESS Process  
            );
            static auto _SuspendProcess =
                static_cast<_PsSuspendProcess>(Importer::GetKernelProcAddress(L"PsSuspendProcess"));
            return _SuspendProcess
                ? _SuspendProcess(Process)
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS ResumeProcess(IN PEPROCESS Process) {
            using _PsResumeProcess = NTSTATUS (NTAPI*)(
                IN PEPROCESS Process  
            );
            static auto _SuspendProcess =
                static_cast<_PsResumeProcess>(Importer::GetKernelProcAddress(L"PsResumeProcess"));
            return _SuspendProcess
                ? _SuspendProcess(Process)
                : STATUS_NOT_IMPLEMENTED;            
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS CreateUserThread(
            HANDLE hProcess,
            IN _UserThreadRoutine StartAddress,
            IN PVOID Argument,
            BOOLEAN CreateSuspended,
            OUT PHANDLE hThread,
            OUT PCLIENT_ID ClientId
        ) {
            using _RtlCreateUserThread = NTSTATUS (NTAPI*)(
                IN HANDLE               ProcessHandle,
                IN PSECURITY_DESCRIPTOR SecurityDescriptor,
                IN BOOLEAN              CreateSuspended,
                IN ULONG                StackZeroBits,
                IN OUT PULONG           StackReserved,
                IN OUT PULONG           StackCommit,
                IN PVOID                StartAddress,
                IN PVOID                StartParameter,
                OUT PHANDLE             ThreadHandle,
                OUT PCLIENT_ID          ClientID
            );
            static auto _CreateUserThread =
                static_cast<_RtlCreateUserThread>(Importer::GetKernelProcAddress(L"RtlCreateUserThread"));
            return _CreateUserThread
                ? _CreateUserThread(
                    hProcess,
                    NULL,
                    CreateSuspended,
                    0,
                    NULL,
                    NULL,
                    StartAddress,
                    Argument,
                    hThread,
                    ClientId
                  )
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS CreateSystemThread(
            OPTIONAL HANDLE hProcess, 
            PKSTART_ROUTINE StartAddress, 
            PVOID Argument, 
            OUT PHANDLE hThread, 
            OUT PCLIENT_ID ClientId
        ) {
            OBJECT_ATTRIBUTES ObjectAttributes;
            InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
            return PsCreateSystemThread(hThread, GENERIC_ALL, &ObjectAttributes, hProcess, ClientId, StartAddress, Argument);
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS CreateSystemThread(
            PKSTART_ROUTINE StartAddress, 
            PVOID Argument, 
            OUT PHANDLE hThread
        ) {
            OBJECT_ATTRIBUTES ObjectAttributes;
            InitializeObjectAttributes(&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
            return PsCreateSystemThread(hThread, GENERIC_ALL, &ObjectAttributes, NULL, NULL, StartAddress, Argument);
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS QueryInformationThread(
            HANDLE hThread,
            THREADINFOCLASS ThreadInformationClass,
            OUT PVOID ThreadInformation,
            ULONG ThreadInformationLength,
            OUT PULONG ReturnLength
        ) {
            using _ZwQueryInformationThread = NTSTATUS (NTAPI*)(
                HANDLE hThread,
                THREADINFOCLASS ThreadInformationClass,
                OUT PVOID ThreadInformation,
                ULONG ThreadInformationLength,
                OUT PULONG ReturnLength              
            );
            static auto _QueryInformationThread =
                static_cast<_ZwQueryInformationThread>(Importer::GetKernelProcAddress(L"ZwQueryInformationThread"));
            return _QueryInformationThread
                ? _QueryInformationThread(
                    hThread, 
                    ThreadInformationClass, 
                    ThreadInformation, 
                    ThreadInformationLength, 
                    ReturnLength
                )
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS SetInformationThread(
            HANDLE hThread,
            THREADINFOCLASS ThreadInformationClass,
            IN PVOID ThreadInformation,
            ULONG ThreadInformationLength
        ) {
            return ZwSetInformationThread(
                hThread, 
                ThreadInformationClass, 
                ThreadInformation, 
                ThreadInformationLength
            );
        }
    }

    namespace Information {
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS QueryInformationProcess(
            HANDLE hProcess,
            PROCESSINFOCLASS ProcessInformationClass,
            OUT PVOID ProcessInformation,
            ULONG ProcessInformationLength,
            OUT PULONG ReturnLength
        ) {
            using _ZwQueryInformationProcess = NTSTATUS (NTAPI*)(
                HANDLE hProcess,
                PROCESSINFOCLASS ProcessInformationClass,
                IN PVOID ProcessInformation,
                ULONG ProcessInformationLength,
                OUT PULONG ReturnLength              
            );
            static auto _QueryInformationProcess =
                static_cast<_ZwQueryInformationProcess>(Importer::GetKernelProcAddress(L"ZwQueryInformationProcess"));
            return _QueryInformationProcess
                ? _QueryInformationProcess(
                    hProcess, 
                    ProcessInformationClass, 
                    ProcessInformation, 
                    ProcessInformationLength, 
                    ReturnLength
                  )
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS SetInformationProcess(
            HANDLE hProcess,
            PROCESSINFOCLASS ProcessInformationClass,
            IN PVOID ProcessInformation,
            ULONG ProcessInformationLength
        ) {
            using _ZwSetInformationProcess = NTSTATUS (NTAPI*)(
                HANDLE hProcess,
                PROCESSINFOCLASS ProcessInformationClass,
                IN PVOID ProcessInformation,
                ULONG ProcessInformationLength         
            );
            static auto _SetInformationProcess =
                static_cast<_ZwSetInformationProcess>(Importer::GetKernelProcAddress(L"ZwSetInformationProcess"));
            return _SetInformationProcess
                ? _SetInformationProcess(
                    hProcess, 
                    ProcessInformationClass, 
                    ProcessInformation, 
                    ProcessInformationLength
                  )
                : STATUS_NOT_IMPLEMENTED;
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        BOOLEAN Is32BitProcess(HANDLE hProcess) {
#ifdef _AMD64_
            UINT64 IsWow64Process = 0;
            ULONG ReturnLength = 0;
            NTSTATUS Status = QueryInformationProcess(hProcess, ProcessWow64Information, &IsWow64Process, sizeof(IsWow64Process), &ReturnLength);
            if (!NT_SUCCESS(Status) || !ReturnLength) return FALSE;
            return IsWow64Process != 0;
#else
            UNREFERENCED_PARAMETER(hProcess);
            return TRUE;
#endif
        }
    }

    namespace MemoryManagement {
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS AllocateVirtualMemory(HANDLE hProcess, SIZE_T Size, ULONG Protect, IN OUT PVOID* BaseAddress) {
            return ZwAllocateVirtualMemory(hProcess, BaseAddress, 0, &Size, MEM_COMMIT, Protect);
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        PVOID AllocateVirtualMemory(HANDLE hProcess, SIZE_T Size, ULONG Protect) {
            PVOID BaseAddress = NULL;
            return NT_SUCCESS(ZwAllocateVirtualMemory(hProcess, &BaseAddress, 0, &Size, MEM_COMMIT, Protect)) 
                ? BaseAddress 
                : NULL;
        }

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS FreeVirtualMemory(HANDLE hProcess, PVOID BaseAddress) {
            SIZE_T RegionSize = 0;
            return ZwFreeVirtualMemory(hProcess, &BaseAddress, &RegionSize, MEM_RELEASE);
        }

        enum MEMORY_OPERATION_TYPE {
            MemRead,
            MemWrite
        };

        _IRQL_requires_max_(APC_LEVEL)
        static NTSTATUS OperateProcessMemory(
            PEPROCESS Process,
            PVOID BaseAddress,
            PVOID Buffer,
            ULONG Size,
            MEMORY_OPERATION_TYPE Operation
        ) {
            if (!Process) return STATUS_INVALID_PARAMETER_1;
            if (!BaseAddress) return STATUS_INVALID_PARAMETER_2;
            if (!Buffer) return STATUS_INVALID_PARAMETER_3;
            if (!Size) return STATUS_INVALID_PARAMETER_4;

            if (AddressRange::IsKernelAddress(BaseAddress)) {
                if (!VirtualMemory::IsMemoryRangePresent(BaseAddress, Size))
                    return STATUS_MEMORY_NOT_ALLOCATED;
            }

            if (AddressRange::IsKernelAddress(Buffer)) {
                if (!VirtualMemory::IsMemoryRangePresent(Buffer, Size))
                    return STATUS_MEMORY_NOT_ALLOCATED;
            }

            // Attempt to lock process memory from freeing:
            HANDLE hProcessSecure = NULL;
            if (AddressRange::IsUserAddress(BaseAddress)) {
                if (!VirtualMemory::SecureProcessMemory(Process, BaseAddress, Size, PAGE_READONLY, &hProcessSecure))
                    return STATUS_NOT_LOCKED;
            }

            // Attempt to lock buffer memory if it is usermode memory:
            HANDLE hBufferSecure = NULL;
            if (AddressRange::IsUserAddress(Buffer)) {
                if (!VirtualMemory::SecureMemory(Buffer, Size, PAGE_READWRITE, &hBufferSecure)) {
                    if (hProcessSecure) VirtualMemory::UnsecureProcessMemory(Process, hProcessSecure);
                    return STATUS_NOT_LOCKED;
                }
            }

            // Attempt to map process memory:
            Mdl::MAPPING_INFO ProcessMapping = {};
            NTSTATUS Status = Mdl::MapMemory(
                &ProcessMapping,
                Process,
                NULL,
                BaseAddress,
                Size
            );

            if (!NT_SUCCESS(Status)) { 
                if (hProcessSecure) VirtualMemory::UnsecureProcessMemory(Process, hProcessSecure);
                if (hBufferSecure) VirtualMemory::UnsecureMemory(hBufferSecure);
                return STATUS_NOT_MAPPED_VIEW;
            }

            // Attempt to map buffer memory:
            Mdl::MAPPING_INFO BufferMapping = {};
            Status = Mdl::MapMemory(
                &BufferMapping,
                NULL,
                NULL,
                Buffer,
                Size
            );

            if (!NT_SUCCESS(Status)) {
                Mdl::UnmapMemory(&ProcessMapping);
                if (hProcessSecure) VirtualMemory::UnsecureProcessMemory(Process, hProcessSecure);
                if (hBufferSecure) VirtualMemory::UnsecureMemory(hBufferSecure);
                return STATUS_NOT_MAPPED_VIEW;
            }

            __try {
                Status = STATUS_UNSUCCESSFUL;
                switch (Operation) {
                case MemRead:
                    VirtualMemory::CopyMemory(BufferMapping.BaseAddress, ProcessMapping.BaseAddress, Size);
                    break;
                case MemWrite:
                    VirtualMemory::CopyMemory(ProcessMapping.BaseAddress, BufferMapping.BaseAddress, Size);
                    break;
                }
                Status = STATUS_SUCCESS;
            } __finally {
                Mdl::UnmapMemory(&BufferMapping);
                Mdl::UnmapMemory(&ProcessMapping);
                if (hProcessSecure) VirtualMemory::UnsecureProcessMemory(Process, hProcessSecure);
                if (hBufferSecure) VirtualMemory::UnsecureMemory(hBufferSecure);
            }

            return Status;
        }

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS ReadProcessMemory(
            PEPROCESS Process,
            IN PVOID BaseAddress,
            OUT PVOID Buffer,
            ULONG Size
        ) {
            return OperateProcessMemory(Process, BaseAddress, Buffer, Size, MemRead);
        }

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS WriteProcessMemory(
            PEPROCESS Process,
            OUT PVOID BaseAddress,
            IN PVOID Buffer,
            ULONG Size
        ) {
            return OperateProcessMemory(Process, BaseAddress, Buffer, Size, MemWrite);
        }
    }

    namespace Apc {
        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS QueueUserApc(PETHREAD Thread, PKNORMAL_ROUTINE NormalRoutine, PVOID Argument) {

            auto KeInitializeApc  = static_cast<_KeInitializeApc>(Importer::GetKernelProcAddress(L"KeInitializeApc"));
            auto KeInsertQueueApc = static_cast<_KeInsertQueueApc>(Importer::GetKernelProcAddress(L"KeInsertQueueApc"));

            if (!KeInitializeApc || !KeInsertQueueApc) return STATUS_NOT_IMPLEMENTED;

            // Initializing user APC:
            auto UserApc = static_cast<PKAPC>(VirtualMemory::AllocFromPool(sizeof(KAPC)));
            KeInitializeApc(
                UserApc, 
                Thread, 
                OriginalApcEnvironment, 
                [](
                    PRKAPC Apc,
                    PKNORMAL_ROUTINE NormalRoutine,
                    PVOID NormalContext,
                    PVOID SystemArgument1,
                    PVOID SystemArgument2                    
                ) -> VOID {
                    UNREFERENCED_PARAMETER(SystemArgument1);
                    UNREFERENCED_PARAMETER(SystemArgument2);

                    if (PsIsThreadTerminating(PsGetCurrentThread())) return;
                    
#ifdef _AMD64_
                    // Fixing APC to Wow64-processes:
                    using _PsGetCurrentProcessWow64Process = PEPROCESS(NTAPI*)();
                    auto GetWow64Process = static_cast<_PsGetCurrentProcessWow64Process>(Importer::GetKernelProcAddress(L"PsGetCurrentProcessWow64Process"));
                    if (!GetWow64Process || GetWow64Process()) {
                        PsWrapApcWow64Thread(static_cast<PVOID*>(NormalContext), reinterpret_cast<PVOID*>(NormalRoutine));
                    }
#else
                    UNREFERENCED_PARAMETER(NormalRoutine);
                    UNREFERENCED_PARAMETER(NormalContext);
#endif

                    VirtualMemory::FreePoolMemory(Apc);
                },
                NULL,
                NormalRoutine,
                UserMode,
                Argument
            );

            // Enforcing delivery of user APCs:
            auto KernelApc = static_cast<PKAPC>(VirtualMemory::AllocFromPool(sizeof(KAPC)));
            KeInitializeApc(
                KernelApc,
                Thread,
                OriginalApcEnvironment,
                [](
                    PRKAPC Apc,
                    PKNORMAL_ROUTINE NormalRoutine,
                    PVOID NormalContext,
                    PVOID SystemArgument1,
                    PVOID SystemArgument2  
                ) -> VOID {
                    UNREFERENCED_PARAMETER(NormalRoutine);
                    UNREFERENCED_PARAMETER(NormalContext);
                    UNREFERENCED_PARAMETER(SystemArgument1);
                    UNREFERENCED_PARAMETER(SystemArgument2);

                    // Enforcing all user APCs delivery:
                    auto KeTestAlertThread = static_cast<_KeTestAlertThread>(Importer::GetKernelProcAddress(L"KeTestAlertThread"));
                    if (KeTestAlertThread) KeTestAlertThread(UserMode);

                    VirtualMemory::FreePoolMemory(Apc);
                },
                NULL,
                NULL,
                KernelMode,
                NULL
            );

            if (KeInsertQueueApc(UserApc, NULL, NULL, KernelMode)) {
                if (!KeInsertQueueApc(KernelApc, NULL, NULL, KernelMode)) {
                    VirtualMemory::FreePoolMemory(KernelApc);
                    return STATUS_UNSUCCESSFUL;
                }
            } else {
                VirtualMemory::FreePoolMemory(UserApc);
                return STATUS_UNSUCCESSFUL;
            }

            return STATUS_SUCCESS;
        }
    }
}


```

`Kernel-Bridge/API/ProcessesUtils.h`:

```h
#pragma once

namespace Processes {
    namespace Descriptors {
        // Queried PEPROCESS must be dereferenced by ObDereferenceObject:
        _IRQL_requires_max_(APC_LEVEL)
        PEPROCESS GetEPROCESS(HANDLE ProcessId);

        // Queried PETHREAD must be dereferenced by ObDereferenceObject:
        _IRQL_requires_max_(APC_LEVEL)
        PETHREAD GetETHREAD(HANDLE ThreadId);

        // Queried hProcess must be closed by ZwClose:
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenProcess(
            HANDLE ProcessId, 
            OUT PHANDLE hProcess, 
            ACCESS_MASK AccessMask = PROCESS_ALL_ACCESS, 
            ULONG Attributes = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenProcessByPointer(
            PEPROCESS Process, 
            OUT PHANDLE hProcess, 
            ACCESS_MASK AccessMask = PROCESS_ALL_ACCESS, 
            ULONG Attributes = OBJ_KERNEL_HANDLE,
            KPROCESSOR_MODE ProcessorMode = KernelMode
        );

        // Queried hThread must be closed by ZwClose:
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenThread(
            HANDLE ThreadId, 
            OUT PHANDLE hThread, 
            ACCESS_MASK AccessMask = THREAD_ALL_ACCESS, 
            ULONG Attributes = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS OpenThreadByPointer(
            PETHREAD Thread, 
            OUT PHANDLE hThread, 
            ACCESS_MASK AccessMask = THREAD_ALL_ACCESS, 
            ULONG Attributes = OBJ_KERNEL_HANDLE,
            KPROCESSOR_MODE ProcessorMode = KernelMode
        );

        // It doesn't requires dereference!
        inline PEPROCESS ThreadToProcess(PETHREAD Thread) { return IoThreadToProcess(Thread); };
    }

    namespace AddressSpace {
        // These functions switches your thread's address space
        // to address space of target process, so you can
        // access usermode memory of another process you want.

        // !!! NOTICE !!!
        // After switching of address space your own usermode memory
        // and usermode handles becomes INVALID in context of another process!

        _IRQL_requires_max_(APC_LEVEL)
        BOOLEAN AttachToProcessByPid(HANDLE ProcessId, OUT PKAPC_STATE ApcState);

        _IRQL_requires_max_(APC_LEVEL)
        BOOLEAN AttachToProcess(PEPROCESS Process, OUT PKAPC_STATE ApcState);

        _IRQL_requires_max_(APC_LEVEL)
        VOID DetachFromProcess(IN PKAPC_STATE ApcState);
    }

    namespace Terminator {
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS TerminateProcessByPid(HANDLE ProcessId, NTSTATUS ExitStatus);

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS TerminateProcess(HANDLE hProcess, NTSTATUS ExitStatus);
    }

    namespace Threads {
        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS GetContextThread(
            IN PETHREAD Thread, 
            OUT PCONTEXT Context, 
            IN KPROCESSOR_MODE PreviousMode
        );

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS SetContextThread(
            IN PETHREAD Thread, 
            IN PCONTEXT Context, 
            IN KPROCESSOR_MODE PreviousMode
        );

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS SuspendProcess(IN PEPROCESS Process);

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS ResumeProcess(IN PEPROCESS Process);

        using _UserThreadRoutine = NTSTATUS (NTAPI*)(PVOID Argument);

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS CreateUserThread(
            HANDLE hProcess,
            IN _UserThreadRoutine StartAddress,
            IN PVOID Argument,
            BOOLEAN CreateSuspended,
            OUT PHANDLE hThread,
            OUT PCLIENT_ID ClientId
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS CreateSystemThread(
            OPTIONAL HANDLE hProcess, 
            PKSTART_ROUTINE StartAddress, 
            PVOID Argument, 
            OUT PHANDLE hThread, 
            OUT PCLIENT_ID ClientId
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS CreateSystemThread(
            PKSTART_ROUTINE StartAddress, 
            PVOID Argument, 
            OUT PHANDLE hThread
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS QueryInformationThread(
            HANDLE hThread,
            THREADINFOCLASS ThreadInformationClass,
            OUT PVOID ThreadInformation,
            ULONG ThreadInformationLength,
            OUT PULONG ReturnLength
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS SetInformationThread(
            HANDLE hThread,
            THREADINFOCLASS ThreadInformationClass,
            IN PVOID ThreadInformation,
            ULONG ThreadInformationLength
        );
    }

    namespace Information {
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS QueryInformationProcess(
            HANDLE hProcess,
            PROCESSINFOCLASS ProcessInformationClass,
            OUT PVOID ProcessInformation,
            ULONG ProcessInformationLength,
            OUT PULONG ReturnLength
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS SetInformationProcess(
            HANDLE hProcess,
            PROCESSINFOCLASS ProcessInformationClass,
            IN PVOID ProcessInformation,
            ULONG ProcessInformationLength
        );

        _IRQL_requires_max_(PASSIVE_LEVEL)
        BOOLEAN Is32BitProcess(HANDLE hProcess = ZwCurrentProcess());
    }

    namespace MemoryManagement {
        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS AllocateVirtualMemory(HANDLE hProcess, SIZE_T Size, ULONG Protect, IN OUT PVOID* BaseAddress);

        _IRQL_requires_max_(PASSIVE_LEVEL)
        PVOID AllocateVirtualMemory(HANDLE hProcess, SIZE_T Size, ULONG Protect);

        _IRQL_requires_max_(PASSIVE_LEVEL)
        NTSTATUS FreeVirtualMemory(HANDLE hProcess, PVOID BaseAddress);

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS ReadProcessMemory(
            PEPROCESS Process,
            IN PVOID BaseAddress, // In the target process or kernel address
            OUT PVOID Buffer, // User or kernel address in the current process
            ULONG Size
        );

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS WriteProcessMemory(
            PEPROCESS Process,
            OUT PVOID BaseAddress, // In the target process or kernel address
            IN PVOID Buffer, // User or kernel address in the current process
            ULONG Size
        );
    }

    namespace Apc {
        enum KAPC_ENVIRONMENT {
            OriginalApcEnvironment,
            AttachedApcEnvironment,
            CurrentApcEnvironment,
            InsertApcEnvironment
        };

        using PKRUNDOWN_ROUTINE = VOID(NTAPI*)(PRKAPC Apc);

        using PKNORMAL_ROUTINE = VOID(NTAPI*)(
            PVOID NormalContext,
            PVOID SyatemArgument1,
            PVOID SystemArgument2
        );
        using PKKERNEL_ROUTINE = VOID(NTAPI*)(
            PRKAPC Apc,
            PKNORMAL_ROUTINE NormalRoutine,
            PVOID NormalContext,
            PVOID SystemArgument1,
            PVOID SystemArgument2
        );

        using _KeInitializeApc = VOID(NTAPI*)(
            IN PRKAPC Apc,
            IN PRKTHREAD Thread,
            IN KAPC_ENVIRONMENT Environment,
            IN PKKERNEL_ROUTINE KernelRoutine,
            IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
            IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
            IN KPROCESSOR_MODE ApcMode OPTIONAL,
            IN PVOID NormalContext OPTIONAL
        );

        using _KeInsertQueueApc = BOOLEAN(NTAPI*)(
            PRKAPC Apc,
            PVOID SystemArgument1,
            PVOID SystemArgument2,
            KPRIORITY PriorityBoost
        );

        using _KeTestAlertThread = BOOLEAN(NTAPI*)(KPROCESSOR_MODE AlertMode);

        _IRQL_requires_max_(APC_LEVEL)
        NTSTATUS QueueUserApc(PETHREAD Thread, PKNORMAL_ROUTINE NormalRoutine, PVOID Argument);
    }
}
```

`Kernel-Bridge/API/PsCallbacks.cpp`:

```cpp
#include <fltKernel.h>

#include "PsCallbacks.h"

PsProcessCallback::PsProcessCallback() : Callback(NULL) {}

PsProcessCallback::PsProcessCallback(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyCallback) : PsProcessCallback() {
    SetupCallback(NotifyCallback);
}

PsProcessCallback::~PsProcessCallback() {
    RemoveCallback();
}

NTSTATUS PsProcessCallback::SetupCallback(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyCallback) {
    if (!NotifyCallback) return STATUS_INVALID_PARAMETER;
    if (Callback) RemoveCallback();

    NTSTATUS Status = PsSetCreateProcessNotifyRoutine(NotifyCallback, FALSE);
    if (NT_SUCCESS(Status)) Callback = NotifyCallback;
    return Status;
}

VOID PsProcessCallback::RemoveCallback() {
    if (!Callback) return;
    PsSetCreateProcessNotifyRoutine(Callback, TRUE);
    Callback = NULL;
}



PsThreadCallback::PsThreadCallback() : Callback(NULL) {}

PsThreadCallback::PsThreadCallback(PCREATE_THREAD_NOTIFY_ROUTINE NotifyCallback) : PsThreadCallback() {
    SetupCallback(NotifyCallback);
}

PsThreadCallback::~PsThreadCallback() {
    RemoveCallback();
}

NTSTATUS PsThreadCallback::SetupCallback(PCREATE_THREAD_NOTIFY_ROUTINE NotifyCallback) {
    if (!NotifyCallback) return STATUS_INVALID_PARAMETER;
    if (Callback) RemoveCallback();

    NTSTATUS Status = PsSetCreateThreadNotifyRoutine(NotifyCallback);
    if (NT_SUCCESS(Status)) Callback = NotifyCallback;
    return Status;
}

VOID PsThreadCallback::RemoveCallback() {
    if (!Callback) return;
    PsRemoveCreateThreadNotifyRoutine(Callback);
    Callback = NULL;
}



PsImageCallback::PsImageCallback() : Callback(NULL) {}

PsImageCallback::PsImageCallback(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyCallback) : PsImageCallback() {
    SetupCallback(NotifyCallback);
}

PsImageCallback::~PsImageCallback() {
    RemoveCallback();
}

NTSTATUS PsImageCallback::SetupCallback(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyCallback) {
    if (!NotifyCallback) return STATUS_INVALID_PARAMETER;
    if (Callback) RemoveCallback();

    NTSTATUS Status = PsSetLoadImageNotifyRoutine(NotifyCallback);
    if (NT_SUCCESS(Status)) Callback = NotifyCallback;
    return Status;
}

VOID PsImageCallback::RemoveCallback() {
    if (!Callback) return;
    PsRemoveLoadImageNotifyRoutine(Callback);
    Callback = NULL;
}
```

`Kernel-Bridge/API/PsCallbacks.h`:

```h
#pragma once

class PsProcessCallback {
private:
    PCREATE_PROCESS_NOTIFY_ROUTINE Callback;
public:
    PsProcessCallback(const PsProcessCallback&) = delete;
    PsProcessCallback(PsProcessCallback&&) = delete;
    PsProcessCallback& operator = (const PsProcessCallback&) = delete;
    PsProcessCallback& operator = (PsProcessCallback&&) = delete;

    PsProcessCallback();
    PsProcessCallback(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyCallback);
    ~PsProcessCallback();

    NTSTATUS SetupCallback(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyCallback);
    VOID RemoveCallback();
};

class PsThreadCallback {
private:
    PCREATE_THREAD_NOTIFY_ROUTINE Callback;
public:
    PsThreadCallback(const PsThreadCallback&) = delete;
    PsThreadCallback(PsThreadCallback&&) = delete;
    PsThreadCallback& operator = (const PsThreadCallback&) = delete;
    PsThreadCallback& operator = (PsThreadCallback&&) = delete;

    PsThreadCallback();
    PsThreadCallback(PCREATE_THREAD_NOTIFY_ROUTINE NotifyCallback);
    ~PsThreadCallback();

    NTSTATUS SetupCallback(PCREATE_THREAD_NOTIFY_ROUTINE NotifyCallback);
    VOID RemoveCallback();
};

class PsImageCallback {
private:
    PLOAD_IMAGE_NOTIFY_ROUTINE Callback;
public:
    PsImageCallback(const PsImageCallback&) = delete;
    PsImageCallback(PsImageCallback&&) = delete;
    PsImageCallback& operator = (const PsImageCallback&) = delete;
    PsImageCallback& operator = (PsImageCallback&&) = delete;

    PsImageCallback();
    PsImageCallback(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyCallback);
    ~PsImageCallback();

    NTSTATUS SetupCallback(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyCallback);
    VOID RemoveCallback();
};
```

`Kernel-Bridge/API/PteUtils.cpp`:

```cpp
#include <ntifs.h>

#include "MemoryUtils.h"
#include "PTE.h"
#include "Registers.h"
#include "PteUtils.h"

namespace Pte {
#ifdef _AMD64_
    extern "C" unsigned long long __readcr3();
    extern "C" unsigned long long __readcr4();
    extern "C" void __invlpg(void* Page);
#else
    extern "C" unsigned long __readcr3();
    extern "C" unsigned long __readcr4();
#endif

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN GetPageTables(PVOID Address, OUT PAGE_TABLES_INFO* Info)
    {
        if (!Info) return FALSE;
        *Info = {};

        using namespace PhysicalMemory;

        VIRTUAL_ADDRESS Va = {};
        Va.Value = reinterpret_cast<unsigned long long>(Address);

        CR3 Cr3 = {};
        Cr3.Value = static_cast<unsigned long long>(__readcr3());

        CR4 Cr4 = {};
        Cr4.Value = static_cast<unsigned long long>(__readcr4());

#ifdef _AMD64_
        PVOID64 Pml4ePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Cr3.x64.Bitmap.PML4) + Va.x64.Generic.PageMapLevel4Offset * sizeof(PML4E::x64));
        Info->Pml4e = reinterpret_cast<PML4E*>(GetVirtualForPhysical(Pml4ePhys));
        if (!Info->Pml4e) return FALSE;
        if (!Info->Pml4e->x64.Generic.P) return TRUE;

        PVOID64 PdpePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pml4e->x64.Generic.PDP) + Va.x64.Generic.PageDirectoryPointerOffset * sizeof(PDPE::x64));
        Info->Pdpe = reinterpret_cast<PDPE*>(GetVirtualForPhysical(PdpePhys));
        if (!Info->Pdpe) return FALSE;
        if (Info->Pdpe->x64.Generic.PS)
        {
            // Page size = 1 Gb:
            if (!Info->Pdpe->x64.PageSize.Page1Gb.P) return FALSE;
            Info->Type = PAGE_TABLES_INFO::pt64Page1Gb;
        }
        else
        {
            PVOID64 PdePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pdpe->x64.NonPageSize.Generic.PD) + Va.x64.NonPageSize.Generic.PageDirectoryOffset * sizeof(PDE::x64));
            Info->Pde = reinterpret_cast<PDE*>(GetVirtualForPhysical(PdePhys));
            if (!Info->Pde) return FALSE;
            if (Info->Pde->x64.Generic.PS)
            {
                // Page size = 2 Mb:
                Info->Type = PAGE_TABLES_INFO::pt64Page2Mb;
            }
            else
            {
                // Page size = 4 Kb:
                Info->Type = PAGE_TABLES_INFO::pt64Page4Kb;

                PVOID64 PtePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pde->x64.Page4Kb.PT) + Va.x64.NonPageSize.Page4Kb.PageTableOffset * sizeof(PTE::x64));
                Info->Pte = reinterpret_cast<PTE*>(GetVirtualForPhysical(PtePhys));
                if (!Info->Pte) return FALSE;
            }
        }
#else
        if (Cr4.x32.Bitmap.PAE)
        {
            PVOID64 PdpePhys = reinterpret_cast<PVOID64>(PFN_TO_PDP_PAE(Cr3.x32.Pae.PDP) + Va.x32.Pae.Generic.PageDirectoryPointerOffset * sizeof(PDPE::x32));
            Info->Pdpe = reinterpret_cast<PDPE*>(GetVirtualForPhysical(PdpePhys));
            if (!Info->Pdpe) return FALSE;
            if (!Info->Pdpe->x32.Pae.Generic.P) return TRUE;

            PVOID64 PdePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pdpe->x32.Pae.Generic.PD) + Va.x32.Pae.Generic.PageDirectoryOffset * sizeof(PDE::x32));
            Info->Pde = reinterpret_cast<PDE*>(GetVirtualForPhysical(PdePhys));
            if (!Info->Pde) return FALSE;
            if (!Info->Pde->x32.Pae.Generic.PS)
            {
                // Page size = 2 Mb:
                Info->Type = PAGE_TABLES_INFO::pt32PaePage2Mb;
            }
            else
            {
                // Page size = 4 Kb:
                Info->Type = PAGE_TABLES_INFO::pt32PaePage4Kb;

                if (!Info->Pde->x32.Pae.Page4Kb.P) return TRUE;
                PVOID64 PtePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pde->x32.Pae.Page4Kb.PT) + Va.x32.Pae.Page4Kb.PageTableOffset * sizeof(PTE::x32));
                Info->Pte = reinterpret_cast<PTE*>(GetVirtualForPhysical(PtePhys));
                if (!Info->Pte) return FALSE;
            }
        }
        else
        {
            if (Cr4.x32.Bitmap.PSE)
            {
                PVOID64 PdePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Cr3.x32.NonPae.PD) + Va.x32.NonPae.Page4Kb.PageDirectoryOffset * sizeof(PDE::x32));
                Info->Pde = reinterpret_cast<PDE*>(GetVirtualForPhysical(PdePhys));
                if (!Info->Pde) return FALSE;

                if (Info->Pde->x32.NonPae.Generic.PS)
                {
                    // Page size = 4 Mb:
                    Info->Type = PAGE_TABLES_INFO::pt32NonPaePage4Mb;
                }
                else
                {
                    // Page size = 4 Kb:
                    Info->Type = PAGE_TABLES_INFO::pt32NonPaePage4Kb;

                    if (!Info->Pde->x32.NonPae.Page4Kb.P) return TRUE;

                    PVOID64 PtePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pde->x32.NonPae.Page4Kb.PT) + Va.x32.NonPae.Page4Kb.PageTableOffset * sizeof(PTE::x32));
                    Info->Pte = reinterpret_cast<PTE*>(GetVirtualForPhysical(PtePhys));
                    if (!Info->Pte) return FALSE;
                }
            }
            else
            {
                // Page size = 4 Kb:
                Info->Type = PAGE_TABLES_INFO::pt32NonPaePage4Kb;

                PVOID64 PdePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Cr3.x32.NonPae.PD) + Va.x32.NonPae.Page4Kb.PageDirectoryOffset * sizeof(PDE::x32));
                Info->Pde = reinterpret_cast<PDE*>(GetVirtualForPhysical(PdePhys));
                if (!Info->Pde) return FALSE;
                if (!Info->Pde->x32.NonPae.Page4Kb.P) return TRUE;

                PVOID64 PtePhys = reinterpret_cast<PVOID64>(PFN_TO_PAGE(Info->Pde->x32.NonPae.Page4Kb.PT) + Va.x32.NonPae.Page4Kb.PageTableOffset * sizeof(PTE::x32));
                Info->Pte = reinterpret_cast<PTE*>(GetVirtualForPhysical(PtePhys));
                if (!Info->Pte) return FALSE;
            }
        }
#endif
        return TRUE;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN TriggerCopyOnWrite(OPTIONAL PEPROCESS Process, PVOID Address, OPTIONAL OUT PULONG PageSize)
    {
        BOOLEAN NeedToAttach = Process && Process != PsGetCurrentProcess();
        KAPC_STATE ApcState;
        if (NeedToAttach)
            KeStackAttachProcess(Process, &ApcState);

        BOOLEAN Status = FALSE;
        PAGE_TABLES_INFO Info = {};
        Status = GetPageTables(Address, &Info);
        if (Status) __try
        {
            // AVL is a 3-bit field:
            //   AVL:CopyOnWrite : 1
            //   AVL:Unused : 1
            //   AVL:Write : 1;
            // We're setting the CoW bit (0b001):
            constexpr unsigned int COW_MASK = 0b001;
            constexpr unsigned int WRITE_MASK = 0b100;

            if (PageSize) *PageSize = 0;

            switch (Info.Type)
            {
            case PAGE_TABLES_INFO::pt32NonPaePage4Kb:
                // PDE -> PTE -> PA:
                if (PageSize) *PageSize = 4096;
                if (!Info.Pte->x32.NonPae.Page4Kb.P || Info.Pte->x32.NonPae.Page4Kb.D || (Info.Pte->x32.NonPae.Page4Kb.AVL & WRITE_MASK)) break;
                Info.Pte->x32.NonPae.Page4Kb.AVL = COW_MASK;
                break;
            case PAGE_TABLES_INFO::pt32NonPaePage4Mb:
                // PDE -> PA:
                if (PageSize) *PageSize = 4096 * 1024;
                if (!Info.Pde->x32.NonPae.Page4Mb.P || Info.Pde->x32.NonPae.Page4Mb.D || (Info.Pde->x32.NonPae.Page4Mb.AVL & WRITE_MASK)) break;
                Info.Pde->x32.NonPae.Page4Mb.AVL = COW_MASK;
                break;
            case PAGE_TABLES_INFO::pt32PaePage4Kb:
                // PDPE -> PDE -> PTE -> PA:
                if (PageSize) *PageSize = 4096;
                if (!Info.Pte->x32.Pae.Page4Kb.P || Info.Pte->x32.Pae.Page4Kb.D || (Info.Pte->x32.Pae.Page4Kb.AVL & WRITE_MASK)) break;
                Info.Pte->x32.Pae.Page4Kb.AVL = COW_MASK;
                break;
            case PAGE_TABLES_INFO::pt32PaePage2Mb:
                // PDPE -> PDE -> PA:
                if (PageSize) *PageSize = 2048 * 1024;
                if (!Info.Pde->x32.Pae.Page2Mb.P || Info.Pde->x32.Pae.Page2Mb.D || (Info.Pde->x32.Pae.Page2Mb.AVL & WRITE_MASK)) break;
                Info.Pde->x32.Pae.Page2Mb.AVL = COW_MASK;
                break;
            case PAGE_TABLES_INFO::pt64Page4Kb:
                // PML4E -> PDPE -> PDE -> PTE -> PA:
                if (PageSize) *PageSize = 4096;
                if (!Info.Pte->x64.Page4Kb.P || Info.Pte->x64.Page4Kb.D || (Info.Pte->x64.Page4Kb.AVL & WRITE_MASK)) break;
                Info.Pte->x64.Page4Kb.AVL = COW_MASK;
                break;
            case PAGE_TABLES_INFO::pt64Page2Mb:
                // PML4E -> PDPE -> PDE -> PA:
                if (PageSize) *PageSize = 2048 * 1024;
                if (!Info.Pde->x64.Page2Mb.P || Info.Pde->x64.Page2Mb.D || (Info.Pde->x64.Page2Mb.AVL & WRITE_MASK)) break;
                Info.Pde->x64.Page2Mb.AVL = COW_MASK;
                break;
            case PAGE_TABLES_INFO::pt64Page1Gb:
                // PML4E -> PDPE -> PA:
                if (PageSize) *PageSize = 1024 * 1024 * 1024;
                if (!Info.Pdpe->x64.PageSize.Page1Gb.P || Info.Pdpe->x64.PageSize.Page1Gb.D || (Info.Pdpe->x64.PageSize.Page1Gb.AVL & WRITE_MASK)) break;
                Info.Pdpe->x64.PageSize.Page1Gb.AVL = COW_MASK;
                break;
            }

            __invlpg(Address); // Reset the TLB

            volatile LONG* PageAddress = reinterpret_cast<volatile LONG*>(ALIGN_DOWN_POINTER_BY(Address, PAGE_SIZE));
            InterlockedExchange(PageAddress, *PageAddress);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = FALSE;
        }

        if (NeedToAttach)
            KeUnstackDetachProcess(&ApcState);

        return Status;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN IsPagePresent(PVOID Address, OPTIONAL OUT PULONG PageSize)
    {
        BOOLEAN IsPresent = FALSE;
        PAGE_TABLES_INFO Info = {};
        if (GetPageTables(Address, &Info)) __try
        {
            if (PageSize) *PageSize = 0;

            switch (Info.Type) {
            case PAGE_TABLES_INFO::pt32NonPaePage4Kb:
                // PDE -> PTE -> PA:
                if (PageSize) *PageSize = 4096;
                IsPresent = Info.Pte->x32.NonPae.Page4Kb.P;
                break;
            case PAGE_TABLES_INFO::pt32NonPaePage4Mb:
                // PDE -> PA:
                if (PageSize) *PageSize = 4096 * 1024;
                IsPresent = Info.Pde->x32.NonPae.Page4Mb.P;
                break;
            case PAGE_TABLES_INFO::pt32PaePage4Kb:
                // PDPE -> PDE -> PTE -> PA:
                if (PageSize) *PageSize = 4096;
                IsPresent = Info.Pte->x32.Pae.Page4Kb.P;
                break;
            case PAGE_TABLES_INFO::pt32PaePage2Mb:
                // PDPE -> PDE -> PA:
                if (PageSize) *PageSize = 2048 * 1024;
                IsPresent = Info.Pde->x32.Pae.Page2Mb.P;
                break;
            case PAGE_TABLES_INFO::pt64Page4Kb:
                // PML4E -> PDPE -> PDE -> PTE -> PA:
                if (PageSize) *PageSize = 4096;
                IsPresent = Info.Pte->x64.Page4Kb.P;
                break;
            case PAGE_TABLES_INFO::pt64Page2Mb:
                // PML4E -> PDPE -> PDE -> PA:
                if (PageSize) *PageSize = 2048 * 1024;
                IsPresent = Info.Pde->x64.Page2Mb.P;
                break;
            case PAGE_TABLES_INFO::pt64Page1Gb:
                // PML4E -> PDPE -> PA:
                if (PageSize) *PageSize = 1024 * 1024 * 1024;
                IsPresent = Info.Pdpe->x64.PageSize.Page1Gb.P;
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            IsPresent = FALSE;
        }

        return IsPresent;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN IsProcessPagePresent(OPTIONAL PEPROCESS Process, PVOID Address, OPTIONAL OUT PULONG PageSize)
    {
        if (!Process || Process == PsGetCurrentProcess()) 
            return IsPagePresent(Address, PageSize);
        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        BOOLEAN IsPresent = IsPagePresent(Address, PageSize);
        KeUnstackDetachProcess(&ApcState);
        return IsPresent;
    }

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN IsMemoryRangePresent(OPTIONAL PEPROCESS Process, PVOID Address, SIZE_T Size)
    {
        if (!Size) return FALSE;

        BOOLEAN NeedToAttach = Process && Process != PsGetCurrentProcess();
        KAPC_STATE ApcState;
        if (NeedToAttach)
            KeStackAttachProcess(Process, &ApcState);

        BOOLEAN IsPresent = TRUE;

        PVOID Page = Address;
        do {
            ULONG PageSize = 0;
            IsPresent = IsPagePresent(Address, &PageSize) && PageSize;
            if (!IsPresent) break;
            Page = reinterpret_cast<PVOID>(reinterpret_cast<SIZE_T>(ALIGN_DOWN_POINTER_BY(Page, PageSize)) + PageSize);
        } while (Page < reinterpret_cast<PVOID>(reinterpret_cast<SIZE_T>(Address) + Size));

        if (NeedToAttach)
            KeUnstackDetachProcess(&ApcState);

        return IsPresent;
    }
}
```

`Kernel-Bridge/API/PteUtils.h`:

```h
#pragma once

namespace Pte
{
    struct PAGE_TABLES_INFO {
        PML4E* Pml4e;
        PDPE* Pdpe;
        PDE* Pde;
        PTE* Pte;
        enum PAGE_TYPE {
            ptUnknown,
            pt32NonPaePage4Kb, // PDE -> PTE -> PA
            pt32NonPaePage4Mb, // PDE -> PA
            pt32PaePage4Kb, // PDPE -> PDE -> PTE -> PA
            pt32PaePage2Mb, // PDPE -> PDE -> PA
            pt64Page4Kb, // PML4E -> PDPE -> PDE -> PTE -> PA
            pt64Page2Mb, // PML4E -> PDPE -> PDE -> PA
            pt64Page1Gb  // PML4E -> PDPE -> PA
        } Type;
    };

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN GetPageTables(PVOID Address, OUT PAGE_TABLES_INFO* Info);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN TriggerCopyOnWrite(OPTIONAL PEPROCESS Process, PVOID Address, OPTIONAL OUT PULONG PageSize = NULL);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN IsPagePresent(PVOID Address, OPTIONAL OUT PULONG PageSize);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN IsProcessPagePresent(OPTIONAL PEPROCESS Process, PVOID Address, OPTIONAL OUT PULONG PageSize);

    _IRQL_requires_max_(APC_LEVEL)
    BOOLEAN IsMemoryRangePresent(OPTIONAL PEPROCESS Process, PVOID Address, SIZE_T Size);
}
```

`Kernel-Bridge/API/RAII.h`:

```h
#pragma once

template <typename T>
using ObjectDestructor = void (*)(T);

template <typename T>
class Object final {
private:
    T _Object;
    ObjectDestructor<T> _Destructor;
public:
    Object(const Object&) = delete;
    Object(Object&&) = delete;
    Object& operator = (const Object&) = delete;
    Object& operator = (Object&&) = delete;

    Object(T ObjectPtr, ObjectDestructor<T> Destructor) 
    : _Object(ObjectPtr), _Destructor(Destructor) {}
    ~Object() {
        if (_Destructor) _Destructor(_Object);
    }
    T Get() const { return _Object; }
};
```

`Kernel-Bridge/API/SectionsUtils.cpp`:

```cpp
#include <wdm.h>

namespace Sections {
    NTSTATUS CreateSection(
        OUT PHANDLE hSection,
        OPTIONAL LPCWSTR Name,
        UINT64 MaximumSize,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags,
        ULONG SecPageProtection,
        ULONG AllocationAttributes,
        OPTIONAL HANDLE hFile
    ) {
        UNICODE_STRING SecName = {};
        if (Name) RtlInitUnicodeString(&SecName, Name);

        OBJECT_ATTRIBUTES Attributes = {};
        
        InitializeObjectAttributes(&Attributes, Name ? &SecName : NULL, SecObjFlags, NULL, NULL);
        
        return ZwCreateSection(
            hSection,
            DesiredAccess,
            &Attributes,
            reinterpret_cast<PLARGE_INTEGER>(&MaximumSize),
            SecPageProtection,
            AllocationAttributes,
            hFile
        );
    }

    NTSTATUS OpenSection(
        OUT PHANDLE hSection,
        LPCWSTR Name,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags
    ) {
        if (!Name) return STATUS_INVALID_PARAMETER;

        UNICODE_STRING SecName = {};
        RtlInitUnicodeString(&SecName, Name);

        OBJECT_ATTRIBUTES Attributes = {};
        InitializeObjectAttributes(&Attributes, &SecName, SecObjFlags, NULL, NULL);

        return ZwOpenSection(hSection, DesiredAccess, &Attributes);
    }

    NTSTATUS MapViewOfSection(
        HANDLE hSection,
        HANDLE hProcess,
        IN OUT PVOID* BaseAddress,
        SIZE_T CommitSize,
        IN OUT OPTIONAL UINT64* SectionOffset,
        IN OUT SIZE_T* ViewSize,
        SECTION_INHERIT InheritDisposition,
        ULONG AllocationType,
        ULONG Win32Protect
    ) {
        return ZwMapViewOfSection(
            hSection,
            hProcess,
            BaseAddress,
            NULL,
            CommitSize,
            reinterpret_cast<PLARGE_INTEGER>(SectionOffset),
            ViewSize,
            InheritDisposition,
            AllocationType,
            Win32Protect
        );
    }

    NTSTATUS UnmapViewOfSection(HANDLE hProcess, PVOID BaseAddress) {
        return ZwUnmapViewOfSection(hProcess, BaseAddress);
    }
}
```

`Kernel-Bridge/API/SectionsUtils.h`:

```h
#pragma once

namespace Sections {
    NTSTATUS CreateSection(
        OUT PHANDLE hSection,
        OPTIONAL LPCWSTR Name,
        UINT64 MaximumSize,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags,
        ULONG SecPageProtection,
        ULONG AllocationAttributes,
        OPTIONAL HANDLE hFile
    );

    NTSTATUS OpenSection(
        OUT PHANDLE hSection,
        LPCWSTR Name,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags
    );

    NTSTATUS MapViewOfSection(
        HANDLE hSection,
        HANDLE hProcess,
        IN OUT PVOID* BaseAddress,
        SIZE_T CommitSize,
        IN OUT OPTIONAL UINT64* SectionOffset,
        IN OUT SIZE_T* ViewSize,
        SECTION_INHERIT InheritDisposition = ViewUnmap,
        ULONG AllocationType = MEM_RESERVE,
        ULONG Win32Protect = PAGE_READWRITE
    );

    NTSTATUS UnmapViewOfSection(HANDLE hProcess, PVOID BaseAddress);
}
```

`Kernel-Bridge/API/Signatures.cpp`:

```cpp
#include <string.h>

void* find_signature(void* memory, size_t size, const char* pattern, const char* mask) 
{
    size_t sig_length = strlen(mask);
    if (sig_length > size) return nullptr;

    for (size_t i = 0; i < size - sig_length; i++)
    {
        bool found = true;
        for (size_t j = 0; j < sig_length; j++)
            found &= mask[j] == '?' || pattern[j] == *((char*)memory + i + j);

        if (found) 
            return (char*)memory + i;
    }
    return nullptr;
}
```

`Kernel-Bridge/API/Signatures.h`:

```h
#pragma once

// pattern = "\x11\x22\x00\x33\x00\x00\x44"
// mask = "..?.??."
// finds 0x11 0x22 ?? 0x33 ?? ?? 0x44, where ?? is any byte.

void* find_signature(void* memory, size_t size, const char* pattern, const char* mask);
```

`Kernel-Bridge/API/Stopwatch.cpp`:

```cpp
#include "Stopwatch.h"

#include <ntifs.h>

Stopwatch::Stopwatch()
    : m_begin(0)
    , m_end(0)
    , m_freq(0)
{
    KeQueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&m_freq));
}

Stopwatch::Stopwatch(bool init)
    : m_begin(0)
    , m_end(0)
    , m_freq(0)
{
    if (init)
    {
        start();
    }
}

void Stopwatch::reset()
{
    m_begin = 0;
    m_end = 0;
    KeQueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&m_freq));
}

void Stopwatch::start()
{
    m_begin = KeQueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&m_freq)).QuadPart;
    m_end = m_begin;
}

float Stopwatch::stop()
{
    m_end = KeQueryPerformanceCounter(NULL).QuadPart;
    return delta();
}

float Stopwatch::delta()
{
    return static_cast<float>(m_end - m_begin) / m_freq;
}
```

`Kernel-Bridge/API/Stopwatch.h`:

```h
#pragma once

class Stopwatch
{
protected:
    unsigned long long m_begin, m_end;
    unsigned long long m_freq;

public:
    Stopwatch();
    Stopwatch(bool init);

    void reset();

    void start();
    float stop();

    float delta();
};
```

`Kernel-Bridge/API/StringsAPI.h`:

```h
#pragma once

/*
    [KM] Dependencies:
     - wdm.h/fltKernel.h
     - ntstrsafe.h
     - stdarg.h
    [UM] Dependencies:
     - Windows.h
     - cstdarg
*/

#ifndef _NTDDK_
#pragma comment(lib, "ntdll.lib")
#endif

extern "C"
{
    int __cdecl _vsnprintf_s(char* dest, size_t size, size_t max_count, const char* format, va_list args);
    int __cdecl _vsnwprintf_s(wchar_t* dest, size_t size, size_t max_count, const wchar_t* format, va_list args);
}

template<typename TChar> class String {
private:
    static const TChar NullChar = 0;

    // Small string optimization (using stack memory for small strings):
    static constexpr unsigned char SSO_SIZE = 32;
    __declspec(align(MEMORY_ALLOCATION_ALIGNMENT)) TChar SsoBuffer[SSO_SIZE];

    static constexpr unsigned short AllocationGranularity = 64;

    using STRING_INFO = struct {
        TChar* Buffer;
        size_t Length; // Symbols count without null-terminator
        size_t BufferSize; // Buffer size in bytes
        BOOLEAN SsoUsing;
    };

    STRING_INFO Data;

    static inline VOID SetupSso(OUT STRING_INFO* StringInfo, const TChar* SsoBuffer) {
        StringInfo->Buffer = const_cast<TChar*>(SsoBuffer);
        StringInfo->Length = 0;
        StringInfo->BufferSize = SSO_SIZE * sizeof(TChar);
        StringInfo->SsoUsing = TRUE;
        StringInfo->Buffer[0] = NullChar;
        StringInfo->Buffer[SSO_SIZE - 1] = NullChar;
    }

    static inline TChar* StrAllocMem(size_t Bytes) {
#ifdef _NTDDK_
#ifdef POOL_NX_OPTIN
        return static_cast<TChar*>(ExAllocatePoolWithTag(ExDefaultNonPagedPoolType, Bytes, StrPoolTag));
#else
        return static_cast<TChar*>(ExAllocatePoolWithTag(NonPagedPool, Bytes, StrPoolTag));
#endif
#else
        return reinterpret_cast<TChar*>(new BYTE[Bytes]);
#endif
    }

    static inline VOID StrFreeMem(TChar* Memory) {
#ifdef _NTDDK_
        ExFreePoolWithTag(Memory, StrPoolTag);
#else
        delete[] Memory;
#endif
    }

    static bool Alloc(OUT STRING_INFO* StringInfo, size_t Characters) {
        if (!StringInfo || !Characters) return false;
        *StringInfo = {};
        size_t Size = (Characters + 1) * sizeof(TChar); // Null-terminated buffer
        Size = ((Size / AllocationGranularity) + 1) * AllocationGranularity;
        TChar* Buffer = StrAllocMem(Size);
        if (!Buffer) return false;
        Buffer[0] = NullChar;
        Buffer[Characters] = NullChar;
        StringInfo->Buffer = Buffer;
        StringInfo->Length = Characters;
        StringInfo->BufferSize = Size;
        StringInfo->SsoUsing = FALSE;
        return true;
    }

    static VOID Free(IN OUT STRING_INFO* StringInfo) {
        if (StringInfo && StringInfo->Buffer && !StringInfo->SsoUsing) {
            StrFreeMem(StringInfo->Buffer);
        }
    }

    static VOID Copy(OUT TChar* Dest, const IN TChar* Src, size_t Characters, bool Terminate = true) {
        if (!Dest || !Src || !Characters) return;
        RtlCopyMemory(Dest, Src, Characters * sizeof(TChar));
        if (Terminate) Dest[Characters] = NullChar;
    }

    static VOID CopyCat(OUT TChar* Dest, const IN TChar* First, size_t FirstLength, const IN TChar* Second, size_t SecondLength) {
        if (!Dest) return;
        if (First && FirstLength) {
            RtlCopyMemory(Dest, First, FirstLength * sizeof(TChar));
            Dest += FirstLength;
        }
        if (Second && SecondLength) {
            RtlCopyMemory(Dest, Second, SecondLength * sizeof(TChar));
            Dest += SecondLength;
        }
        *Dest = NullChar;
    }

    bool Concat(const IN TChar* Str) {
        return Concat(Str, Length(Str));
    }

    bool Concat(const IN TChar* Str, size_t StrLength) {
        if (!StrLength) return true;
        Resize(Data.Length + StrLength);
        Copy(&Data.Buffer[Data.Length - StrLength], Str, StrLength);
        return true;
    }

    bool Concat(const IN STRING_INFO* StringInfo) {
        return Concat(StringInfo->Buffer, StringInfo->Length);
    }

    String(const IN STRING_INFO* StringInfo) : String() {
        if (StringInfo->SsoUsing) {
            Copy(SsoBuffer, StringInfo->Buffer, StringInfo->Length);
            SetupSso(&Data, SsoBuffer);
            Data.Length = StringInfo->Length;
        } else {
            Data = *StringInfo;
            // Check whether we can use SSO:
            if (Data.Length < SSO_SIZE) {
                SetupSso(&Data, SsoBuffer);
                Data.Length = StringInfo->Length;
                Copy(SsoBuffer, StringInfo->Buffer, Data.Length);
            }
        }
        
    }

public:

#ifdef _NTDDK_
    static constexpr ULONG StrPoolTag = 'RTS_';
#endif

    String() {
        SetupSso(&Data, SsoBuffer);
    };
    ~String() {
        Free(&Data);
    }
    String(const TChar* Str) : String(Str, Length(Str)) {
    }
    String(const TChar* Str, size_t StrLength) : String() {
        if (StrLength < SSO_SIZE || Alloc(&Data, StrLength))
            Copy(Data.Buffer, Str, StrLength);

        Data.Length = StrLength;
    }
    String(const String& Str) : String() {
        if (Str.Data.Length < SSO_SIZE || Alloc(&Data, Str.Data.Length))
            Copy(Data.Buffer, Str.Data.Buffer, Str.Data.Length);

        Data.Length = Str.Data.Length;
    }
    String(String&& Str) noexcept : String() {
        if (Str.Data.SsoUsing || Str.Data.Length < SSO_SIZE) {
            Copy(Data.Buffer, Str.Data.Buffer, Str.Data.Length);
        } else {
            Data = Str.Data;    
        }
        Data.Length = Str.Data.Length;
        Str.Data = {};
    }

    String operator + (const TChar* Str) {
        if (!Str) return *this;

        size_t StrLength = Length(Str);
        if (!StrLength) return *this;

        size_t SummaryLength = Data.Length + StrLength;

        STRING_INFO StringInfo = {};
        if (!Alloc(&StringInfo, SummaryLength)) 
            return *this;

        CopyCat(StringInfo.Buffer, Data.Buffer, Data.Length, Str, StrLength);
        StringInfo.Length = SummaryLength;

        return String(&StringInfo);
    }
    String operator + (String&& Str) {
        size_t StrLength = Str.GetLength();
        if (!StrLength) return *this;

        size_t SummaryLength = Data.Length + Str.Data.Length;

        STRING_INFO StringInfo = {};
        if (!Alloc(&StringInfo, SummaryLength)) 
            return *this;

        CopyCat(StringInfo.Buffer, Data.Buffer, Data.Length, Str.GetConstData(), StrLength);
        StringInfo.Length = SummaryLength;

        return String(&StringInfo);         
    }
    String operator + (const String& Str) {
        if (!Str.Data.Length) return *this;

        size_t SummaryLength = Data.Length + Str.Data.Length;

        STRING_INFO StringInfo = {};
        if (!Alloc(&StringInfo, SummaryLength)) 
            return *this;

        CopyCat(StringInfo.Buffer, Data.Buffer, Data.Length, Str.Data.Buffer, Str.Data.Length);
        StringInfo.Length = SummaryLength;

        return String(&StringInfo);        
    }
    friend String operator + (const TChar* Left, const String& Right) {
        if (!Left) return Right;

        size_t LeftLength = Length(Left);
        if (!LeftLength) return Right;

        size_t SummaryLength = Right.GetLength() + LeftLength;

        STRING_INFO StringInfo = {};
        if (!Alloc(&StringInfo, SummaryLength)) 
            return String(Left);

        CopyCat(StringInfo.Buffer, Left, LeftLength, Right.GetConstData(), Right.GetLength());
        StringInfo.Length = SummaryLength;

        return String(&StringInfo);  
    }

    String& operator += (const TChar* Str) {
        Concat(Str);
        return *this;
    }

    String& operator += (String&& Str) {
        Concat(&Str.Data);
        return *this;
    }

    String& operator += (const String& Str) {
        Concat(&Str.Data);
        return *this;
    }

    String& operator = (const TChar* Str) {
        size_t StrLength = Length(Str);
        Resize(StrLength);
        Copy(Data.Buffer, Str, StrLength);
        return *this;
    }
    String& operator = (const String& Str) {
        Resize(Str.Data.Length);
        Copy(Data.Buffer, Str.Data.Buffer, Str.Data.Length);
        return *this;
    }
    String& operator = (String&& Str) {
        Free(&Data);
        SetupSso(&Data, SsoBuffer);
        if (Str.Data.SsoUsing || Str.Data.Length < SSO_SIZE) {
            Copy(Data.Buffer, Str.Data.Buffer, Str.Data.Length);
        } else {
            Data = Str.Data;
        }
        Data.Length = Str.Data.Length;
        Str.Data = {};
        return *this;
    }

    bool operator == (const TChar* Str) {
        if (Data.Buffer == Str) return true;
        size_t StrLength = Length(Str);
        if (Data.Length != StrLength) return false;
        return RtlCompareMemory(Data.Buffer, Str, StrLength) == StrLength;
    }
    bool operator == (const String& String) {
        if (Data.Buffer == String.Data.Buffer) return true;
        if (Data.Length != String.Data.Length) return false;
        return RtlCompareMemory(Data.Buffer, String.Data.Buffer, Data.Length) == Data.Length;
    }

    bool operator != (const TChar* Str) {
        if (Data.Buffer == Str) return false;
        size_t StrLength = Length(Str);
        if (Data.Length != StrLength) return true;
        return RtlCompareMemory(Data.Buffer, Str, StrLength) != StrLength;
    }
    bool operator != (const String& String) {
        if (Data.Buffer == String.Data.Buffer) return false;
        if (Data.Length != String.Data.Length) return true;
        return RtlCompareMemory(Data.Buffer, String.Data.Buffer, Data.Length) != Data.Length;
    }

    inline operator const TChar* () const {
        return Data.Buffer;
    }

    inline operator TChar* () {
        return Data.Buffer;
    }

    inline TChar& operator [] (int Index) {
        return Data.Buffer[Index];
    }

    inline TChar operator [] (int Index) const {
        return Data.Buffer[Index];
    }

    static inline size_t Length(const TChar* String);

    inline size_t GetLength() const { return Data.Length; };
    inline size_t GetSize() const { return Data.BufferSize; }
    inline const TChar* GetConstData() const { return Data.Buffer ? Data.Buffer : &NullChar; }
    inline TChar* GetData() { return Data.Buffer ? Data.Buffer : NULL; };

    VOID Clear() {
        Free(&Data);
        SetupSso(&Data, SsoBuffer);
    }

    inline String<CHAR> GetAnsi() const;
    inline String<WCHAR> GetWide() const;

    inline String& ToLowerCase();
    inline String& ToUpperCase();

    inline String GetLowerCase() const {
        String Str(*this);
        Str.ToLowerCase();
        return Str;
    }
    inline String GetUpperCase() const {
        String Str(*this);
        Str.ToUpperCase();
        return Str;
    }

    static bool Matches(const TChar* Str, const TChar* Mask) {
        /* 
            Dr.Dobb's Algorithm:
            http://www.drdobbs.com/architecture-and-design/matching-wildcards-an-empirical-way-to-t/240169123?queryText=path%2Bmatches
        */

        const TChar* TameText = Str;
        const TChar* WildText = Mask;
        const TChar* TameBookmark = static_cast<TChar*>(0x00);
        const TChar* WildBookmark = static_cast<TChar*>(0x00);

        while (true) {
            if (*WildText == static_cast<TChar>('*')) {
                while (*(++WildText) == static_cast<TChar>('*')); // "xy" matches "x**y"
                if (!*WildText) return true; // "x" matches "*"
            
                if (*WildText != static_cast<TChar>('?')) {
                    while (*TameText != *WildText) {
                        if (!(*(++TameText)))
                            return false;  // "x" doesn't match "*y*"
                    }
                }

                WildBookmark = WildText;
                TameBookmark = TameText;
            }
            else if (*TameText != *WildText && *WildText != static_cast<TChar>('?')) {
                if (WildBookmark) {
                    if (WildText != WildBookmark) {
                        WildText = WildBookmark;

                        if (*TameText != *WildText) {
                            TameText = ++TameBookmark;
                            continue; // "xy" matches "*y"
                        }
                        else {
                            WildText++;
                        }
                    }

                    if (*TameText) {
                        TameText++;
                        continue; // "mississippi" matches "*sip*"
                    }
                }

                return false; // "xy" doesn't match "x"
            }

            TameText++;
            WildText++;

            if (!*TameText) {
                while (*WildText == static_cast<TChar>('*')) WildText++; // "x" matches "x*"

                if (!*WildText) return true; // "x" matches "x"
                return false; // "x" doesn't match "xy"
            }
        }
    }

    bool Matches(const TChar* Mask) {
        return Matches(Data.Buffer, Mask);
    }

    static inline const TChar* Find(const TChar* Str, const TChar* Substr, size_t Offset = 0);
    inline const TChar* Find(const TChar* Substring, size_t Offset = 0) const {
        if (Offset > Data.Length) return nullptr;
        return Find(Data.Buffer, Substring, Offset);
    }
    inline bool Contains(const TChar* Substring, size_t Offset = 0) const {
        return Find(Substring, Offset) != nullptr;
    }

#ifdef _AMD64_
    static constexpr size_t NoPos = ~0ULL;
#else
    static constexpr size_t NoPos = ~0UL;
#endif

    inline size_t Pos(const TChar* Substring, size_t Offset = 0, bool GetRelativePos = false) const {
        const TChar* SubstrAddr = Find(Substring, Offset);
        if (!SubstrAddr) return NoPos;
        size_t AbsPos = (reinterpret_cast<size_t>(SubstrAddr) - reinterpret_cast<size_t>(Data.Buffer)) / sizeof(TChar);
        return GetRelativePos ? AbsPos - Offset : AbsPos;
    }

    String& Delete(size_t Position, size_t Count, bool AutoShrink = false) {
        if (Position >= Data.Length) return *this;
        if (Position + Count >= Data.Length) {
            Data.Buffer[Position] = NullChar;
            Data.Length = Position;
        } else {
            Copy(&Data.Buffer[Position], &Data.Buffer[Position + Count], Data.Length - (Position + Count));
            Data.Length -= Count;
            Data.Buffer[Data.Length] = NullChar;
        }

        if (AutoShrink) Shrink();

        return *this;
    }

    String& Insert(size_t Position, const TChar* Insertion) {
        return Insert(Position, Insertion, Length(Insertion));
    }

    String& Insert(size_t Position, const String& Insertion) {
        return Insert(Position, Insertion.Data.Buffer, Insertion.Data.Length);
    }

    String& Insert(size_t Position, const String&& Insertion) {
        return Insert(Position, Insertion.Data.Buffer, Insertion.Data.Length);
    }

    String& Insert(size_t Position, const TChar* Insertion, size_t CharactersCount) {
        if (!CharactersCount) return *this;
        size_t SummaryLength = Data.Length + CharactersCount;
        size_t RequiredSize = (SummaryLength + 1) * sizeof(TChar);
        if (RequiredSize > Data.BufferSize) {
            STRING_INFO StringInfo = {};
            if (Alloc(&StringInfo, SummaryLength)) {
                Copy(StringInfo.Buffer, Data.Buffer, Position);
                Copy(&StringInfo.Buffer[Position], Insertion, CharactersCount);
                Copy(&StringInfo.Buffer[Position + CharactersCount], &Data.Buffer[Position], Data.Length - Position);
                Free(&Data);
                Data = StringInfo;
            }
        } else {
            Copy(&Data.Buffer[Position + CharactersCount], &Data.Buffer[Position], Data.Length - Position);
            Copy(&Data.Buffer[Position], Insertion, CharactersCount, false);
        }
        Data.Length += CharactersCount;
        return *this;
    } 

    String Substr(size_t Position, size_t CharactersCount = 0) const {
        if (!Data.Length || Position > Data.Length) return String();
        if (CharactersCount) {
            if (Position + CharactersCount > Data.Length) CharactersCount = Data.Length - Position;
            return String(&Data.Buffer[Position], CharactersCount);
        } else {
            return String(&Data.Buffer[Position]);
        }
    }

    String& TrimLeft(bool AutoShrink = false) {
        if (!Data.Length) return *this;
        size_t Symbol;
        for (Symbol = 0; Symbol < Data.Length; ++Symbol) {
            if (
                Data.Buffer[Symbol] != static_cast<TChar>(' ') &&
                Data.Buffer[Symbol] != static_cast<TChar>('\t')
            ) break;
        }

        if (Symbol == 0) return *this;
        
        size_t TrimmedLength = Data.Length - Symbol;

        if (!Data.SsoUsing && TrimmedLength < SSO_SIZE) {
            STRING_INFO StringInfo = {};
            SetupSso(&StringInfo, SsoBuffer);
            Copy(StringInfo.Buffer, &Data.Buffer[Symbol], TrimmedLength);
            StringInfo.Length = TrimmedLength;
            Free(&Data);
            Data = StringInfo;
            return *this;
        }

        Copy(Data.Buffer, &Data.Buffer[Symbol], TrimmedLength);
        Data.Length = TrimmedLength;

        if (AutoShrink) Shrink();
        return *this;
    }

    String& TrimRight(bool AutoShrink = false) {
        if (!Data.Length) return *this;
        size_t Symbol;
        for (Symbol = Data.Length - 1; Symbol >= 0; --Symbol) {
            if (
                Data.Buffer[Symbol] != static_cast<TChar>(' ') &&
                Data.Buffer[Symbol] != static_cast<TChar>('\t')
            ) break;
        }

        ++Symbol; // Set it to points to null-terminator
        Data.Buffer[Symbol] = NullChar;
        Data.Length = Symbol;

        if (!Data.SsoUsing && Data.Length < SSO_SIZE) {
            STRING_INFO StringInfo = {};
            SetupSso(&StringInfo, SsoBuffer);
            Copy(StringInfo.Buffer, Data.Buffer, Data.Length);
            StringInfo.Length = Data.Length;
            Free(&Data);
            Data = StringInfo;
            return *this;
        }

        if (AutoShrink) Shrink();
        return *this;
    }

    String& Trim(bool AutoShrink = false) {
        TrimLeft(false);
        TrimRight(false);
        if (AutoShrink) Shrink();
        return *this;
    }

    void Shrink() {
        if (Data.SsoUsing) return;
        size_t RequiredSize = ((((Data.Length + 1) * sizeof(TChar)) / AllocationGranularity) + 1) * AllocationGranularity;
        if (RequiredSize < Data.BufferSize) {
            STRING_INFO StringInfo = {};
            if (Data.Length < SSO_SIZE) {
                SetupSso(&StringInfo, SsoBuffer);
                Copy(StringInfo.Buffer, Data.Buffer, Data.Length);
                StringInfo.Length = Data.Length;
                Free(&Data);
                Data = StringInfo;
            } else {
                if (Alloc(&StringInfo, Data.Length)) {
                    Copy(StringInfo.Buffer, Data.Buffer, Data.Length);
                    Free(&Data);
                    Data = StringInfo;
                }
            }
        }
    }

    void Resize(size_t Characters, TChar Filler = 0, bool AutoShrink = false) {
        if (Characters == Data.Length) {
            if (AutoShrink) Shrink();
            return;
        }
        
        if (!Characters) {
            if (AutoShrink) {
                Clear();
            } else {
                Data.Buffer[0] = NullChar;
                Data.Length = 0;
            }
            return;
        }

        if (Characters > Data.Length) {
            size_t RequiredSize = (Characters + 1) * sizeof(TChar);
            if (RequiredSize <= Data.BufferSize) {
                if (Filler == 0)
                    RtlZeroMemory(&Data.Buffer[Data.Length], (Characters - Data.Length) * sizeof(TChar));
                else {
                    for (size_t Index = Data.Length; Index < Characters; ++Index)
                        Data.Buffer[Index] = Filler;
                }
                Data.Buffer[Characters] = NullChar;
                Data.Length = Characters;
                return;
            } 

            STRING_INFO StringInfo = {};            
            if (Alloc(&StringInfo, Characters)) {
                Copy(StringInfo.Buffer, Data.Buffer, Data.Length);
                if (Filler == 0)
                    RtlZeroMemory(&StringInfo.Buffer[Data.Length], (Characters - Data.Length) * sizeof(TChar));
                else {
                    for (size_t Index = Data.Length; Index < Characters; ++Index)
                        StringInfo.Buffer[Index] = Filler;
                }
                StringInfo.Buffer[Characters] = NullChar;
                StringInfo.Length = Characters;
                Free(&Data);
                Data = StringInfo;
            }
        } else {
            Data.Buffer[Characters] = NullChar;
            Data.Length = Characters;
        }
        if (AutoShrink) Shrink();
    }

    void Reserve(size_t Characters) {
        if (Characters == Data.Length) return;
        if (Characters < Data.Length) {
            Resize(Characters);
            return;
        }
        STRING_INFO StringInfo = {};
        if (Characters < SSO_SIZE) {
            if (Data.SsoUsing) return;
            SetupSso(&StringInfo, SsoBuffer);
            Copy(StringInfo.Buffer, Data.Buffer, Data.Length);
            Free(&Data);
            Data = StringInfo;
        } else {
            if (Alloc(&StringInfo, Characters)) {
                Copy(StringInfo.Buffer, Data.Buffer, Data.Length);
                Free(&Data);
                Data = StringInfo;
            }
        }
    }

    String& Replace(
        const TChar* Substr,
        const TChar* Replacer,
        bool SelectiveReplacement = false, // aXXabXXabc.Replace("a", "abc", true) == abcXXabcbXXabc
        unsigned int* ReplacementsCount = nullptr
    ) {
        unsigned int Replaced = 0;
        size_t SubstrLength = Length(Substr);
        size_t ReplacerLength = Length(Replacer);
        
        size_t Position = Pos(Substr);
        if (Position == NoPos) return *this;
        do {
            if (SelectiveReplacement)
                if (Pos(Replacer, Position) == Position) continue;
            Delete(Position, SubstrLength);
            Insert(Position, Replacer);
            Replaced++;
        } while ((Position = Pos(Substr, Position + ReplacerLength)) != NoPos);
    
        if (ReplacementsCount) *ReplacementsCount = Replaced;
        return *this;
    }

    VOID CopyTo(TChar* Buffer, size_t Characters) {
        if (Data.Length < Characters)
            Characters = Data.Length;
        RtlCopyMemory(Buffer, Data.Buffer, Characters * sizeof(TChar));
        Buffer[Characters] = 0x0000;
    }
};

class AnsiString : public String<CHAR> {
public:
    using String::String;
    AnsiString(PCANSI_STRING Ansi) : String(Ansi->Buffer, Ansi->Length / sizeof(CHAR)) {}
    AnsiString(const String& Str) : String(Str) {}
    AnsiString(String&& Str) : String(Str) {}
    AnsiString() : String() {}
};

class WideString : public String<WCHAR> {
public:
    using String::String;
    WideString(PCUNICODE_STRING Wide) : String(Wide->Buffer, Wide->Length / sizeof(WCHAR)) {}
    WideString(const String& Str) : String(Str) {}
    WideString(String&& Str) : String(Str) {}
    WideString() : String() {}
};

template<>
static inline size_t String<CHAR>::Length(const CHAR* String) {
    if (!String) return 0;
    return strlen(String);
}

template<>
static inline size_t String<WCHAR>::Length(const WCHAR* String) {
    if (!String) return 0;
    return wcslen(String);
}

template<>
inline String<CHAR> String<CHAR>::GetAnsi() const {
    return *this;
}

template<>
inline String<WCHAR> String<CHAR>::GetWide() const {
    ANSI_STRING AnsiString = {};
    RtlInitAnsiString(&AnsiString, Data.Buffer);
    UNICODE_STRING UnicodeString = {};
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    String<WCHAR> Wide(UnicodeString.Buffer, UnicodeString.Length / sizeof(WCHAR));
    RtlFreeUnicodeString(&UnicodeString);
    return Wide;
}

template<>
inline String<CHAR> String<WCHAR>::GetAnsi() const {
    UNICODE_STRING UnicodeString = {};
    RtlInitUnicodeString(&UnicodeString, Data.Buffer);
    ANSI_STRING AnsiString = {};
    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
    String<CHAR> Ansi(AnsiString.Buffer, AnsiString.Length / sizeof(CHAR));
    RtlFreeAnsiString(&AnsiString);
    return Ansi;
}

template<>
inline String<WCHAR> String<WCHAR>::GetWide() const {
    return *this;
}

template<>
inline String<CHAR>& String<CHAR>::ToLowerCase() {
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    RtlInitAnsiString(&AnsiString, Data.Buffer);
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    RtlDowncaseUnicodeString(&UnicodeString, &UnicodeString, FALSE);
    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    RtlFreeUnicodeString(&UnicodeString);
    return *this;
}

template<>
inline String<CHAR>& String<CHAR>::ToUpperCase() {
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    RtlInitAnsiString(&AnsiString, Data.Buffer);
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    RtlUpcaseUnicodeString(&UnicodeString, &UnicodeString, FALSE);
    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    RtlFreeUnicodeString(&UnicodeString);
    return *this;
}

template<>
inline String<WCHAR>& String<WCHAR>::ToLowerCase() {
    UNICODE_STRING UnicodeString;
    RtlInitUnicodeString(&UnicodeString, Data.Buffer);
    RtlDowncaseUnicodeString(&UnicodeString, &UnicodeString, FALSE);
    return *this;
}

template<>
inline String<WCHAR>& String<WCHAR>::ToUpperCase() {
    UNICODE_STRING UnicodeString;
    RtlInitUnicodeString(&UnicodeString, Data.Buffer);
    RtlUpcaseUnicodeString(&UnicodeString, &UnicodeString, FALSE);
    return *this;
}

template<>
inline const CHAR* String<CHAR>::Find(const CHAR* Str, const CHAR* Substr, size_t Offset) {
    return strstr(Str + Offset, Substr);
}

template<>
inline const WCHAR* String<WCHAR>::Find(const WCHAR* Str, const WCHAR* Substr, size_t Offset) {
    return wcsstr(Str + Offset, Substr);
}


inline String<CHAR> FormatAnsi(LPCSTR Format, ...) {
    va_list args;
    va_start(args, Format);
    constexpr int BufferSize = 64;
    CHAR Buffer[BufferSize];
    int characters = _vsnprintf_s(Buffer, BufferSize, BufferSize - 1, Format, args);
    if (characters != -1) return String<CHAR>(Buffer);
    String<CHAR> Result;
    Result.Resize(BufferSize * 2);
    while ((characters = _vsnprintf_s(
        Result.GetData(), 
        Result.GetLength() + 1, 
        Result.GetLength(), 
        Format, 
        args
    )) == -1) {
        Result.Resize(Result.GetLength() + BufferSize);
    }
    Result.Resize(characters);
    return Result;
}

inline String<WCHAR> FormatWide(LPCWSTR Format, ...) {
    va_list args;
    va_start(args, Format);
    constexpr int BufferSize = 64;
    WCHAR Buffer[BufferSize];
    int characters = _vsnwprintf_s(Buffer, BufferSize, BufferSize - 1, Format, args);
    if (characters != -1) return String<WCHAR>(Buffer);
    String<WCHAR> Result;
    Result.Resize(BufferSize * 2);
    while ((characters = _vsnwprintf_s(
        Result.GetData(), 
        Result.GetLength() + 1, 
        Result.GetLength(), 
        Format, 
        args
    )) == -1) {
        Result.Resize(Result.GetLength() + BufferSize);
    }
    Result.Resize(characters);
    return Result;
}
```

`Kernel-Bridge/API/VMM.asm`:

```asm
.CODE

EXTERN SvmVmexitHandler: PROC
EXTERN VmxVmexitHandler: PROC

; Store LDTR:
_sldt PROC PUBLIC
    sldt WORD PTR [rcx]
    ret
_sldt ENDP

; Store TR:
_str PROC PUBLIC
    str WORD PTR [rcx]
    ret
_str ENDP

__invd PROC PUBLIC
    invd
    ret
__invd ENDP

; VMX-only:
__hyperv_vmcall PROC PUBLIC
    ; RCX - HYPERCALL_INPUT_VALUE
    ; RDX - Input parameters GPA when the Fast flag is 0, otherwise input parameter
    ; R8  - Output parameters GPA when the Fast flag is 0, otherwise output parameter
    ; XMM0..XMM5 can be used in hypervisors with XMM Fast input support
    vmcall

    ; RAX - HYPERCALL_RESULT_VALUE
    ret
__hyperv_vmcall ENDP

; VMX-only:
__kb_vmcall PROC PUBLIC
    ; RCX, RDX, R8, R9 - args
    ; RAX - result
    push r10
    mov r10, 01EE7C0DEh
    vmcall
    pop r10
    ret
__kb_vmcall ENDP

GPR_CONTEXT_ENTRIES equ 15 ; rax, rbx, rcx, rdx, rsi, rdi, rbp, r8..r15
GPR_CONTEXT_SIZE    equ GPR_CONTEXT_ENTRIES * sizeof(QWORD)
XMM_CONTEXT_ENTRIES equ 6 ; xmm0..xmm5
XMM_CONTEXT_SIZE    equ XMM_CONTEXT_ENTRIES * sizeof(OWORD)

CPUID_VMM_SHUTDOWN equ 01EE7C0DEh

; Without RSP saving:
PUSHAQ MACRO
    sub rsp, GPR_CONTEXT_SIZE
    mov [rsp + 0  * sizeof(QWORD)], rax
    mov [rsp + 1  * sizeof(QWORD)], rbx
    mov [rsp + 2  * sizeof(QWORD)], rcx
    mov [rsp + 3  * sizeof(QWORD)], rdx
    mov [rsp + 4  * sizeof(QWORD)], rsi
    mov [rsp + 5  * sizeof(QWORD)], rdi
    mov [rsp + 6  * sizeof(QWORD)], rbp
    mov [rsp + 7  * sizeof(QWORD)], r8
    mov [rsp + 8  * sizeof(QWORD)], r9
    mov [rsp + 9  * sizeof(QWORD)], r10
    mov [rsp + 10 * sizeof(QWORD)], r11
    mov [rsp + 11 * sizeof(QWORD)], r12
    mov [rsp + 12 * sizeof(QWORD)], r13
    mov [rsp + 13 * sizeof(QWORD)], r14
    mov [rsp + 14 * sizeof(QWORD)], r15
ENDM

; Without RSP restoring:
POPAQ MACRO
    mov rax, [rsp + 0  * sizeof(QWORD)]
    mov rbx, [rsp + 1  * sizeof(QWORD)]
    mov rcx, [rsp + 2  * sizeof(QWORD)]
    mov rdx, [rsp + 3  * sizeof(QWORD)]
    mov rsi, [rsp + 4  * sizeof(QWORD)]
    mov rdi, [rsp + 5  * sizeof(QWORD)]
    mov rbp, [rsp + 6  * sizeof(QWORD)]
    mov r8 , [rsp + 7  * sizeof(QWORD)]
    mov r9 , [rsp + 8  * sizeof(QWORD)]
    mov r10, [rsp + 9  * sizeof(QWORD)]
    mov r11, [rsp + 10 * sizeof(QWORD)]
    mov r12, [rsp + 11 * sizeof(QWORD)]
    mov r13, [rsp + 12 * sizeof(QWORD)]
    mov r14, [rsp + 13 * sizeof(QWORD)]
    mov r15, [rsp + 14 * sizeof(QWORD)]
    add rsp, GPR_CONTEXT_SIZE
ENDM

PUSHAXMM MACRO
    sub rsp, XMM_CONTEXT_SIZE
    movaps [rsp + 0 * sizeof(OWORD)], xmm0
    movaps [rsp + 1 * sizeof(OWORD)], xmm1
    movaps [rsp + 2 * sizeof(OWORD)], xmm2
    movaps [rsp + 3 * sizeof(OWORD)], xmm3
    movaps [rsp + 4 * sizeof(OWORD)], xmm4
    movaps [rsp + 5 * sizeof(OWORD)], xmm5
ENDM

POPAXMM MACRO
    movaps xmm0, [rsp + 0 * sizeof(OWORD)]
    movaps xmm1, [rsp + 1 * sizeof(OWORD)]
    movaps xmm2, [rsp + 2 * sizeof(OWORD)]
    movaps xmm3, [rsp + 3 * sizeof(OWORD)]
    movaps xmm4, [rsp + 4 * sizeof(OWORD)]
    movaps xmm5, [rsp + 5 * sizeof(OWORD)]
    add rsp, XMM_CONTEXT_SIZE
ENDM

PROLOGUE MACRO
    push rbp
    mov rbp, rsp
    sub rsp, 32
    mov [rsp + 0 * sizeof(QWORD)], rcx
    mov [rsp + 1 * sizeof(QWORD)], rdx
    mov [rsp + 2 * sizeof(QWORD)], r8
    mov [rsp + 3 * sizeof(QWORD)], r9
ENDM

EPILOGUE MACRO
    mov rcx, [rsp + 0 * sizeof(QWORD)]
    mov rdx, [rsp + 1 * sizeof(QWORD)]
    mov r8 , [rsp + 2 * sizeof(QWORD)]
    mov r9 , [rsp + 3 * sizeof(QWORD)]
    add rsp, 32
    pop rbp
    ret
ENDM

; SvmVmmRun(INITIAL_VMM_STACK_LAYOUT* VmmStack):
SvmVmmRun PROC PUBLIC
    ; RCX - VmmStack pointer
    mov rsp, rcx ; Switch to the VMM stack

    ; RSP -> INITIAL_VMM_STACK_LAYOUT:
    ; RSP + 0  -> PVOID GuestVmcbPa
    ; RSP + 8  -> PVOID HostVmcbPa
    ; RSP + 16 -> PRIVATE_VM_DATA* Private

VmmLoop:
    mov rax, [rsp] ; RAX -> GuestVmcbPa

    vmload rax ; Load previously saved guest state
    vmrun rax

    ; Registers restored by the host's values:
    ;  RAX, RSP, RIP
    ;  GDTR, IDTR
    ;  EFER
    ;  CR0, CR3, CR4, DR7, CPL = 0
    ;  ES.sel, CS.sel, SS.sel, DS.sel

    ; #VMEXIT occured, save the guest state to the guest VMCB:
    vmsave rax ; RAX was restored to host's state (RAX -> GuestVmcbPa)

    ; On #VMEXIT we have the guest context, so save it to the stack:
    PUSHAQ
    mov rcx, [rsp + GPR_CONTEXT_SIZE + 16] ; RCX -> PRIVATE_VM_DATA* Private
    mov rdx, rsp ; RDX -> Guest context

    PUSHAXMM
    sub rsp, 32 ; Homing space for the x64 call convention
    call SvmVmexitHandler ; VMM_STATUS SvmVmexitHandler(PRIVATE_VM_DATA* Private, GUEST_CONTEXT* Context)
    add rsp, 32
    POPAXMM

    test al, al ; if (!SvmVmexitHandler(...)) break;
    jz VmmExit

    POPAQ
    jmp VmmLoop

VmmExit:
    POPAQ

    ; Exiting the virtual state:
    ; This context is setted up in the SvmVmexitHandler:
    ;  RBX -> Guest's RIP
    ;  RCX -> Guest's RSP
    ;  EDX:EAX -> Address of the PRIVATE_VM_DATA to free

    mov rsp, rcx
    mov ecx, CPUID_VMM_SHUTDOWN ; Signature that says about the VM shutdown
    jmp rbx
SvmVmmRun ENDP


__invept PROC PUBLIC
    ; RCX - INVEPT_TYPE
    ; RDX - INVEPT_DESCRIPTOR
    invept rcx, OWORD PTR [rdx]
    ret
__invept ENDP

__invvpid PROC PUBLIC
    ; RCX - INVVPID_TYPE
    ; RDX - INVVPID_DESCRIPTOR
    invvpid rcx, OWORD PTR [rdx]
    ret
__invvpid ENDP

VmxVmmRun PROC PUBLIC
    PUSHAQ
    mov rcx, [rsp + GPR_CONTEXT_SIZE + 16]
    mov rdx, rsp

    PUSHAXMM
    sub rsp, 32 ; Homing space for the x64 call convention
    call VmxVmexitHandler ; VMM_STATUS VmxVmexitHandler(PRIVATE_VM_DATA* Private, GUEST_CONTEXT* Context)
    add rsp, 32
    POPAXMM

    test al, al ; if (!SvmVmexitHandler(...)) break;
    jz VmmExit

    POPAQ
    vmresume

VmmExit:
    POPAQ

    ; Exiting the virtual state:
    ; This context is setted up in the SvmVmexitHandler:
    ;  RBX -> Guest's RIP
    ;  RCX -> Guest's RSP
    ;  EDX:EAX -> Address of the PRIVATE_VM_DATA to free

    mov rsp, rcx
    mov ecx, CPUID_VMM_SHUTDOWN ; Signature that says about the VM shutdown
    jmp rbx
VmxVmmRun ENDP

END
```

`Kernel-Bridge/Exports.def`:

```def
NAME Kernel-Bridge
EXPORTS
	DriverEntry
```

`Kernel-Bridge/Kernel-Bridge.cpp`:

```cpp
#include <fltKernel.h>
#include <dontuse.h>
#include <suppress.h>

#include "Kernel-Bridge/DriverEvents.h"
#include "Kernel-Bridge/FilterCallbacks.h"
#include "Kernel-Bridge/IOCTLHandlers.h"
#include "Kernel-Bridge/IOCTLs.h"

#include "API/CppSupport.h"

#pragma prefast(disable:__WARNING_ENCODE_MEMBER_FUNCTION_POINTER, "Not valid for kernel mode drivers")

namespace {
    UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L"\\Device\\Kernel-Bridge");
    UNICODE_STRING DeviceLink = RTL_CONSTANT_STRING(L"\\??\\Kernel-Bridge");
    PDEVICE_OBJECT DeviceInstance = NULL;
    PFLT_FILTER FilterHandle = NULL;
}

EXTERN_C_START

DRIVER_INITIALIZE DriverEntry;

static NTSTATUS SEC_ENTRY FilterInstanceSetup(
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
);

static NTSTATUS SEC_ENTRY FilterUnload(
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
);

_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
static NTSTATUS DriverControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp
);

_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CLOSE)
_Dispatch_type_(IRP_MJ_CLEANUP)
static NTSTATUS DriverStub(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp
);

static VOID PowerCallback(PVOID CallbackContext, PVOID Argument1, PVOID Argument2);

static NTSTATUS DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject
);

EXTERN_C_END

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, FilterUnload)
#pragma alloc_text(PAGE, FilterInstanceSetup)
#pragma alloc_text(PAGE, DriverStub)
#pragma alloc_text(PAGE, DriverUnload)
#endif

static PVOID PowerCallbackRegistration = NULL;

// Operations registration:
static CONST FLT_OPERATION_REGISTRATION Callbacks[] =
{
    {
        IRP_MJ_CREATE,
        0,
        reinterpret_cast<PFLT_PRE_OPERATION_CALLBACK>(FilterPreOperation),
        reinterpret_cast<PFLT_POST_OPERATION_CALLBACK>(FilterPostOperation)
    },
    {
        IRP_MJ_READ,
        0,
        reinterpret_cast<PFLT_PRE_OPERATION_CALLBACK>(FilterPreOperation),
        reinterpret_cast<PFLT_POST_OPERATION_CALLBACK>(FilterPostOperation)
    },
    {
        IRP_MJ_WRITE,
        0,
        reinterpret_cast<PFLT_PRE_OPERATION_CALLBACK>(FilterPreOperation),
        reinterpret_cast<PFLT_POST_OPERATION_CALLBACK>(FilterPostOperation)
    },
    {
        IRP_MJ_DEVICE_CONTROL,
        0,
        reinterpret_cast<PFLT_PRE_OPERATION_CALLBACK>(FilterPreOperation),
        reinterpret_cast<PFLT_POST_OPERATION_CALLBACK>(FilterPostOperation)
    },
    {
        IRP_MJ_INTERNAL_DEVICE_CONTROL,
        0,
        reinterpret_cast<PFLT_PRE_OPERATION_CALLBACK>(FilterPreOperation),
        reinterpret_cast<PFLT_POST_OPERATION_CALLBACK>(FilterPostOperation)
    },
    {
        IRP_MJ_FILE_SYSTEM_CONTROL,
        0,
        reinterpret_cast<PFLT_PRE_OPERATION_CALLBACK>(FilterPreOperation),
        reinterpret_cast<PFLT_POST_OPERATION_CALLBACK>(FilterPostOperation)
    },
    {
        IRP_MJ_OPERATION_END
    }
};

// What we want to filter:
static CONST FLT_REGISTRATION FilterRegistration = 
{
    sizeof(FLT_REGISTRATION), // Size
    FLT_REGISTRATION_VERSION, // Version
    0,                        // Flags

    NULL,      // Context
    Callbacks, // Operation callbacks

    reinterpret_cast<PFLT_FILTER_UNLOAD_CALLBACK>(FilterUnload), // MiniFilterUnload

    FilterInstanceSetup, // InstanceSetup
    NULL, // InstanceQueryTeardown
    NULL, // InstanceTeardownStart
    NULL, // InstanceTeardownComplete
    NULL, // GenerateFileName
    NULL, // GenerateDestinationFileName
    NULL, // NormalizeNameComponent
    NULL, // TransactionNotifierCallback
    NULL, // NormalizeNameComponentExCallback
};


extern "C" NTSTATUS NTAPI DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
) {
    UNREFERENCED_PARAMETER(RegistryPath);

    // Initialization of POOL_NX_OPTIN:
    ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

    __crt_init(); // Global objects initialization

    DriverObject->DriverUnload = reinterpret_cast<PDRIVER_UNLOAD>(DriverUnload);
    DriverObject->MajorFunction[IRP_MJ_CREATE]  = DriverStub;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DriverStub;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = DriverStub;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverControl;

    NTSTATUS Status = IoCreateDevice(DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DeviceInstance);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("[Kernel-Bridge]: IoCreateDevice Error!\r\n"));
        return Status;
    }

    Status = IoCreateSymbolicLink(&DeviceLink, &DeviceName);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("[Kernel-Bridge]: IoCreateSymbolicLink Error!\r\n"));
        IoDeleteDevice(DeviceInstance);
        return Status;
    }

    // We're try to register as minifilter:
    Status = FltRegisterFilter(
        DriverObject,
        &FilterRegistration,
        &FilterHandle
    );

    if (NT_SUCCESS(Status)) {
        Status = FltStartFiltering(FilterHandle);
        if (NT_SUCCESS(Status)) {
            KdPrint(("[Kernel-Bridge]: Successfully registered as filter!\r\n"));
        } else {
            KdPrint(("[Kernel-Bridge]: FltStartFiltering failure: 0x%X\r\n", Status));
            FltUnregisterFilter(FilterHandle);
            FilterHandle = NULL;
        }
    } else {
        KdPrint(("[Kernel-Bridge]: Unable to register as filter: 0x%X\r\n", Status));
    }

    // Registering the power callback to handle sleep/resume for support in VMM:
    PCALLBACK_OBJECT PowerCallbackObject = NULL;
    UNICODE_STRING PowerObjectName = RTL_CONSTANT_STRING(L"\\Callback\\PowerState");
    OBJECT_ATTRIBUTES PowerObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&PowerObjectName, OBJ_CASE_INSENSITIVE);
    Status = ExCreateCallback(&PowerCallbackObject, &PowerObjectAttributes, FALSE, TRUE);
    if (NT_SUCCESS(Status)) {
        PowerCallbackRegistration = ExRegisterCallback(PowerCallbackObject, PowerCallback, NULL);
        ObDereferenceObject(PowerCallbackObject);
        if (!PowerCallbackRegistration) {
            KdPrint(("[Kernel-Bridge]: Unable to register the power callback!\r\n"));
        }
    }
    else {
        KdPrint(("[Kernel-Bridge]: Unable to create the power callback!\r\n"));
    }

    OnDriverLoad(DriverObject, DeviceInstance, FilterHandle, RegistryPath);

    KdPrint(("[Kernel-Bridge]: Successfully loaded!\r\n"));
    return STATUS_SUCCESS;
}

static NTSTATUS SEC_ENTRY FilterInstanceSetup(
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType
) {
    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(VolumeFilesystemType);

    PAGED_CODE();

    return VolumeDeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM
        ? STATUS_FLT_DO_NOT_ATTACH
        : STATUS_SUCCESS;
}

static NTSTATUS SEC_ENTRY FilterUnload(
    _In_ FLT_FILTER_UNLOAD_FLAGS Flags
) {
    PAGED_CODE();

    OnFilterUnload(DeviceInstance, FilterHandle, Flags);
    
    if (FilterHandle) FltUnregisterFilter(FilterHandle);

    return STATUS_SUCCESS;
}

NTSTATUS CallIoctlDispatcher(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
{
    ULONG ExceptionCode = 0;
    PEXCEPTION_POINTERS ExceptionPointers = NULL;
    NTSTATUS Status;
    __try {
        Status = DispatchIOCTL(RequestInfo, ResponseLength);
    }
    __except (
        ExceptionCode = GetExceptionCode(),
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER
    ) {
        Status = ExceptionCode;
        KdPrint((
            "[Kernel-Bridge]: Exception catched in IOCTL handler!\r\n"
            "\tCode: 0x%X\r\n"
            "\tAddress: 0x%p\r\n"
            "\tCTL: 0x%X\r\n",
            ExceptionCode,
            ExceptionPointers->ExceptionRecord->ExceptionAddress,
            RequestInfo->ControlCode
        ));
    }
    return Status;
}



// IOCTLs handler:
_Function_class_(DRIVER_DISPATCH)
_Dispatch_type_(IRP_MJ_DEVICE_CONTROL)
static NTSTATUS DriverControl(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

    IOCTL_INFO RequestInfo;
    RequestInfo.ControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;
    switch (EXTRACT_CTL_METHOD(RequestInfo.ControlCode)) {
    case METHOD_BUFFERED: {
        RequestInfo.InputBuffer      = Irp->AssociatedIrp.SystemBuffer;
        RequestInfo.OutputBuffer     = Irp->AssociatedIrp.SystemBuffer;
        RequestInfo.InputBufferSize  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
        RequestInfo.OutputBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        Irp->IoStatus.Status = CallIoctlDispatcher(&RequestInfo, &Irp->IoStatus.Information);
        break;
    }
    case METHOD_NEITHER: {
        RequestInfo.InputBuffer      = IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
        RequestInfo.OutputBuffer     = Irp->UserBuffer;
        RequestInfo.InputBufferSize  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
        RequestInfo.OutputBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        Irp->IoStatus.Status = CallIoctlDispatcher(&RequestInfo, &Irp->IoStatus.Information);
        break;
    }
    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT: {
        RequestInfo.InputBuffer      = Irp->AssociatedIrp.SystemBuffer;
        RequestInfo.OutputBuffer     = Irp->MdlAddress ? MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority) : NULL;
        RequestInfo.InputBufferSize  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
        RequestInfo.OutputBufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
        Irp->IoStatus.Status = CallIoctlDispatcher(&RequestInfo, &Irp->IoStatus.Information);
        break;
    }
    default: {
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        KdPrint(("[Kernel-Bridge]: Unknown method of IRP!\r\n"));
    }
    }

    NTSTATUS Status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

_Function_class_(DRIVER_DISPATCH)
_Dispatch_type_(IRP_MJ_CREATE)
_Dispatch_type_(IRP_MJ_CLOSE)
_Dispatch_type_(IRP_MJ_CLEANUP)
static NTSTATUS DriverStub(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    PAGED_CODE();
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->MajorFunction) {
    case IRP_MJ_CREATE:
        OnDriverCreate(DeviceObject, FilterHandle, Irp, IrpStack);
        break;
    case IRP_MJ_CLEANUP:
        OnDriverCleanup(DeviceObject, FilterHandle, Irp, IrpStack);
        break;
    case IRP_MJ_CLOSE:
        OnDriverClose(DeviceObject, FilterHandle, Irp, IrpStack);
        break;
    }
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

static VOID PowerCallback(PVOID CallbackContext, PVOID Argument1, PVOID Argument2)
{
    UNREFERENCED_PARAMETER(CallbackContext);
    if (reinterpret_cast<SIZE_T>(Argument1) != PO_CB_SYSTEM_STATE_LOCK) return;

    if (Argument2) {
        OnSystemWake();
    } else {
        OnSystemSleep();
    }
}

_Function_class_(DRIVER_UNLOAD)
_IRQL_requires_(PASSIVE_LEVEL)
_IRQL_requires_same_
static NTSTATUS DriverUnload(_In_ PDRIVER_OBJECT DriverObject)
{
    PAGED_CODE();

    OnDriverUnload(DriverObject, DeviceInstance);

    __crt_deinit(); // Global objects destroying

    if (PowerCallbackRegistration)
        ExUnregisterCallback(PowerCallbackRegistration);

    IoDeleteSymbolicLink(&DeviceLink);
    IoDeleteDevice(DeviceInstance);
    
    KdPrint(("[Kernel-Bridge]: Successfully unloaded!\r\n"));
    return STATUS_SUCCESS;
}
```

`Kernel-Bridge/Kernel-Bridge.inf`:

```inf
[Version]
Signature   = "$Windows NT$"
Class       = "ActivityMonitor"                      ; This is determined by the work this filter driver does
ClassGuid   = {b86dff51-a31e-4bac-b3cf-e8cfe75c9fc2} ; This value is determined by the Load Order Group value
Provider    = %ManufacturerName%
DriverVer   = 08/12/2018,1.0.0.1
CatalogFile = Kernel-Bridge.cat
PnpLockdown = 1

[DestinationDirs]
DefaultDestDir          = 12
MiniFilter.NTX86.DriverFiles  = 12 ; %windir%\system32\drivers
MiniFilter.NTAMD64.DriverFiles  = 12 ; %windir%\system32\drivers

[DefaultInstall.NTX86]
OptionDesc = %ServiceDescription%
CopyFiles = MiniFilter.NTX86.CopyDriverFiles

[DefaultInstall.NTAMD64]
OptionDesc = %ServiceDescription%
CopyFiles = MiniFilter.NTAMD64.CopyDriverFiles

[DefaultInstall.NTX86.Services]
AddService = %ServiceName%,,MiniFilter.NTX86.Service

[DefaultInstall.NTAMD64.Services]
AddService = %ServiceName%,,MiniFilter.NTAMD64.Service

[DefaultUninstall.NTX86]
DelFiles = MiniFilter.NTX86.DelDriverFiles
LegacyUninstall = 1

[DefaultUninstall.NTAMD64]
DelFiles = MiniFilter.NTAMD64.DelDriverFiles
LegacyUninstall = 1

[DefaultUninstall.NTX86.Services]
DelService = %ServiceName%,0x200 ; Ensure service is stopped before deleting

[DefaultUninstall.NTAMD64.Services]
DelService = %ServiceName%,0x200 ; Ensure service is stopped before deleting

[MiniFilter.NTX86.Service]
DisplayName      = %ServiceName%
Description      = %ServiceDescription%
ServiceBinary    = %12%\%DriverName%.sys        ;%windir%\system32\drivers\
Dependencies     = "FltMgr"
ServiceType      = 2 ; SERVICE_FILE_SYSTEM_DRIVER
StartType        = 3 ; SERVICE_DEMAND_START
ErrorControl     = 1 ; SERVICE_ERROR_NORMAL
LoadOrderGroup   = "FSFilter Activity Monitor"
AddReg           = MiniFilter.NTX86.AddRegistry

[MiniFilter.NTAMD64.Service]
DisplayName      = %ServiceName%
Description      = %ServiceDescription%
ServiceBinary    = %12%\%DriverName%.sys        ;%windir%\system32\drivers\
Dependencies     = "FltMgr"
ServiceType      = 2 ; SERVICE_FILE_SYSTEM_DRIVER
StartType        = 3 ; SERVICE_DEMAND_START
ErrorControl     = 1 ; SERVICE_ERROR_NORMAL
LoadOrderGroup   = "FSFilter Activity Monitor"
AddReg           = MiniFilter.NTAMD64.AddRegistry

[MiniFilter.NTX86.AddRegistry]
HKR,,"DebugFlags",0x00010001,0x0
HKR,,"SupportedFeatures",0x00010001,0x3
HKR,"Instances","DefaultInstance",0x00000000,%DefaultInstance%
HKR,"Instances\"%Instance1.Name%,"Altitude",0x00000000,%Instance1.Altitude%
HKR,"Instances\"%Instance1.Name%,"Flags",0x00010001,%Instance1.Flags%

[MiniFilter.NTAMD64.AddRegistry]
HKR,,"DebugFlags",0x00010001,0x0
HKR,,"SupportedFeatures",0x00010001,0x3
HKR,"Instances","DefaultInstance",0x00000000,%DefaultInstance%
HKR,"Instances\"%Instance1.Name%,"Altitude",0x00000000,%Instance1.Altitude%
HKR,"Instances\"%Instance1.Name%,"Flags",0x00010001,%Instance1.Flags%

[MiniFilter.NTX86.CopyDriverFiles]
%DriverName%.sys

[MiniFilter.NTAMD64.CopyDriverFiles]
%DriverName%.sys

[MiniFilter.NTX86.DelDriverFiles]
%DriverName%.sys

[MiniFilter.NTAMD64.DelDriverFiles]
%DriverName%.sys

[SourceDisksFiles]
Kernel-Bridge.sys = 1,,

[SourceDisksNames]
1 = %DiskId1%,,,

[Strings]
ManufacturerName   = "Kernel-Bridge Inc."
ServiceDescription = "Kernel-Bridge Driver"
ServiceName        = "Kernel-Bridge"
DriverName         = "Kernel-Bridge"
DiskId1            = "Kernel-Bridge Device Installation Disk"

DefaultInstance    = "Kernel-Bridge Instance"
Instance1.Name     = "Kernel-Bridge Instance"
; Altitude values: https://msdn.microsoft.com/en-us/windows/hardware/drivers/ifs/load-order-groups-and-altitudes-for-minifilter-drivers
Instance1.Altitude = "260000"
Instance1.Flags    = 0x0 ; Allow all attachments

```

`Kernel-Bridge/Kernel-Bridge.rc`:

```rc
#include <windows.h>

#include <ntverp.h>

#define VER_FILETYPE    VFT_DRV
#define VER_FILESUBTYPE VFT2_DRV_SYSTEM
#define VER_FILEDESCRIPTION_STR     "Kernel-Bridge Filter Driver"
#define VER_INTERNALNAME_STR        "Kernel-Bridge.sys"

#include "common.ver"

```

`Kernel-Bridge/Kernel-Bridge.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="API\CommPort.cpp" />
    <ClCompile Include="API\CppSupport.cpp">
      <WholeProgramOptimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</WholeProgramOptimization>
    </ClCompile>
    <ClCompile Include="API\CPU.cpp" />
    <ClCompile Include="API\Hypervisor.cpp" />
    <ClCompile Include="API\Importer.cpp" />
    <ClCompile Include="API\IO.cpp" />
    <ClCompile Include="API\KernelShells.cpp" />
    <ClCompile Include="API\MemoryUtils.cpp" />
    <ClCompile Include="API\ObCallbacks.cpp" />
    <ClCompile Include="API\Callable.cpp" />
    <ClCompile Include="API\OSVersion.cpp" />
    <ClCompile Include="API\ProcessesUtils.cpp" />
    <ClCompile Include="API\PsCallbacks.cpp" />
    <ClCompile Include="API\PteUtils.cpp" />
    <ClCompile Include="API\SectionsUtils.cpp" />
    <ClCompile Include="API\Signatures.cpp" />
    <ClCompile Include="API\Stopwatch.cpp" />
    <ClCompile Include="Kernel-Bridge\DriverEvents.cpp" />
    <ClCompile Include="Kernel-Bridge\FilterCallbacks.cpp" />
    <ClCompile Include="Kernel-Bridge\IOCTLHandlers.cpp" />
    <ClCompile Include="Kernel-Bridge\LoadableModules.cpp" />
    <ResourceCompile Include="Kernel-Bridge.rc" />
    <ClCompile Include="Kernel-Bridge.cpp" />
    <Inf Include="Kernel-Bridge.inf" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9AF3F0D6-AFE5-4A4B-A50C-667126FFF1F6}</ProjectGuid>
    <TemplateGuid>{f2f62967-0815-4fd7-9b86-6eedcac766eb}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Kernel_Bridge</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>F:\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableInf2cat>true</EnableInf2cat>
    <IncludePath>../SharedTypes;../CommonTypes;$(VC_IncludePath);$(IncludePath)</IncludePath>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>F:\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableInf2cat>true</EnableInf2cat>
    <IncludePath>../SharedTypes;../CommonTypes;$(VC_IncludePath);$(IncludePath)</IncludePath>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>F:\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableInf2cat>true</EnableInf2cat>
    <IncludePath>../SharedTypes;../CommonTypes;$(VC_IncludePath);$(IncludePath)</IncludePath>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <CodeAnalysisRuleSet>F:\Windows Kits\10\CodeAnalysis\DriverRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
    <EnableInf2cat>true</EnableInf2cat>
    <IncludePath>../SharedTypes;../CommonTypes;$(VC_IncludePath);$(IncludePath)</IncludePath>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;HookLib.lib;Zydis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalLibraryDirectories>$(SolutionDir)DebugKernel\;$(SolutionDir)HookLib\HookLib\Zydis\msvc\bin\DebugX86Kernel\</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <EnablePREfast>false</EnablePREfast>
      <PreprocessorDefinitions>POOL_NX_OPTIN=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>..\HookLib\HookLib\HookLib\;..\HookLib\HookLib\Zydis\include\;$(IntDir);%(AdditionalIncludeDirectories);$(ProjectDir)</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <PostBuildEvent>
      <Command>makecab /f ../x32-debug.ddf</Command>
    </PostBuildEvent>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;HookLib.lib;Zydis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalLibraryDirectories>$(SolutionDir)ReleaseKernel\;$(SolutionDir)HookLib\HookLib\Zydis\msvc\bin\ReleaseX86Kernel\</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <EnablePREfast>false</EnablePREfast>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <PreprocessorDefinitions>POOL_NX_OPTIN=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <IntelJCCErratum>true</IntelJCCErratum>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <ExceptionHandling>false</ExceptionHandling>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>..\HookLib\HookLib\HookLib\;..\HookLib\HookLib\Zydis\include\;$(IntDir);%(AdditionalIncludeDirectories);$(ProjectDir)</AdditionalIncludeDirectories>
      <ControlFlowGuard>false</ControlFlowGuard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <PostBuildEvent>
      <Command>makecab /f ../x32-release.ddf</Command>
    </PostBuildEvent>
    <MASM>
      <UseSafeExceptionHandlers>true</UseSafeExceptionHandlers>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;HookLib.lib;Zydis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <AdditionalLibraryDirectories>$(SolutionDir)$(Platform)\DebugKernel\;$(SolutionDir)HookLib\HookLib\Zydis\msvc\bin\DebugX64Kernel\</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <SupportJustMyCode>false</SupportJustMyCode>
      <EnablePREfast>false</EnablePREfast>
      <PreprocessorDefinitions>POOL_NX_OPTIN=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>..\HookLib\HookLib\HookLib\;..\HookLib\HookLib\Zydis\include\;$(IntDir);%(AdditionalIncludeDirectories);$(ProjectDir)</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <PostBuildEvent>
      <Command>makecab /f ../x64-debug.ddf</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>fltmgr.lib;HookLib.lib;Zydis.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalLibraryDirectories>$(SolutionDir)$(Platform)\ReleaseKernel;$(SolutionDir)HookLib\HookLib\Zydis\msvc\bin\ReleaseX64Kernel\</AdditionalLibraryDirectories>
    </Link>
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <EnablePREfast>false</EnablePREfast>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <PreprocessorDefinitions>POOL_NX_OPTIN=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <IntelJCCErratum>true</IntelJCCErratum>
      <ExceptionHandling>false</ExceptionHandling>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>..\HookLib\HookLib\HookLib\;..\HookLib\HookLib\Zydis\include\;$(IntDir);%(AdditionalIncludeDirectories);$(ProjectDir)</AdditionalIncludeDirectories>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <ControlFlowGuard>false</ControlFlowGuard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <PostBuildEvent>
      <Command>makecab /f ../x64-release.ddf</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\CommonTypes\CPUID.h" />
    <ClInclude Include="..\CommonTypes\Hyper-V.h" />
    <ClInclude Include="..\CommonTypes\Interrupts.h" />
    <ClInclude Include="..\CommonTypes\MSR.h" />
    <ClInclude Include="..\CommonTypes\Segmentation.h" />
    <ClInclude Include="..\CommonTypes\PTE.h" />
    <ClInclude Include="..\CommonTypes\Registers.h" />
    <ClInclude Include="..\CommonTypes\SVM.h" />
    <ClInclude Include="..\CommonTypes\VMX.h" />
    <ClInclude Include="..\HookLib\HookLib\HookLib\HookLib.h" />
    <ClInclude Include="..\SharedTypes\CtlTypes.h" />
    <ClInclude Include="..\SharedTypes\FltTypes.h" />
    <ClInclude Include="..\SharedTypes\WdkTypes.h" />
    <ClInclude Include="API\CommPort.h" />
    <ClInclude Include="API\CppSupport.h" />
    <ClInclude Include="API\CPU.h" />
    <ClInclude Include="API\Hypervisor.h" />
    <ClInclude Include="API\Importer.h" />
    <ClInclude Include="API\IO.h" />
    <ClInclude Include="API\KernelShells.h" />
    <ClInclude Include="API\LinkedList.h" />
    <ClInclude Include="API\Locks.h" />
    <ClInclude Include="API\MemoryUtils.h" />
    <ClInclude Include="API\ObCallbacks.h" />
    <ClInclude Include="API\Callable.h" />
    <ClInclude Include="API\OSVersion.h" />
    <ClInclude Include="API\ProcessesUtils.h" />
    <ClInclude Include="API\PsCallbacks.h" />
    <ClInclude Include="API\PteUtils.h" />
    <ClInclude Include="API\RAII.h" />
    <ClInclude Include="API\SectionsUtils.h" />
    <ClInclude Include="API\Signatures.h" />
    <ClInclude Include="API\Stopwatch.h" />
    <ClInclude Include="API\StringsAPI.h" />
    <ClInclude Include="Kernel-Bridge\DriverEvents.h" />
    <ClInclude Include="Kernel-Bridge\FilterCallbacks.h" />
    <ClInclude Include="Kernel-Bridge\IOCTLHandlers.h" />
    <ClInclude Include="Kernel-Bridge\IOCTLs.h" />
    <ClInclude Include="Kernel-Bridge\LoadableModules.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="API\VMM.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`Kernel-Bridge/Kernel-Bridge.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Main">
      <UniqueIdentifier>{b5d010f1-cdbf-4439-bcf3-8d6e1cd4b642}</UniqueIdentifier>
    </Filter>
    <Filter Include="Main\Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Main\Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Main\Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Main\Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Kernel-Bridge">
      <UniqueIdentifier>{0a643a2f-5347-4505-81cf-4a8180227028}</UniqueIdentifier>
    </Filter>
    <Filter Include="API">
      <UniqueIdentifier>{54118567-cea9-4a10-9867-9e055b1c1cb4}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedTypes">
      <UniqueIdentifier>{d3a9dfce-6a9f-4eef-a3ea-0a30ace51980}</UniqueIdentifier>
    </Filter>
    <Filter Include="CommonTypes">
      <UniqueIdentifier>{1540d3f3-c5f5-44c0-a3bb-2246da568195}</UniqueIdentifier>
    </Filter>
    <Filter Include="HookLib">
      <UniqueIdentifier>{1d6d5ce4-f4f5-467c-ab9f-d21fbbac9bcd}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Kernel-Bridge.inf">
      <Filter>Main\Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Kernel-Bridge.rc">
      <Filter>Main\Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Kernel-Bridge.cpp">
      <Filter>Main\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Kernel-Bridge\FilterCallbacks.cpp">
      <Filter>Kernel-Bridge</Filter>
    </ClCompile>
    <ClCompile Include="API\MemoryUtils.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\ProcessesUtils.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\OSVersion.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\CppSupport.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\IO.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\CPU.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="Kernel-Bridge\IOCTLHandlers.cpp">
      <Filter>Kernel-Bridge</Filter>
    </ClCompile>
    <ClCompile Include="API\KernelShells.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\ObCallbacks.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="Kernel-Bridge\DriverEvents.cpp">
      <Filter>Kernel-Bridge</Filter>
    </ClCompile>
    <ClCompile Include="API\CommPort.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\PsCallbacks.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\Importer.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="Kernel-Bridge\LoadableModules.cpp">
      <Filter>Kernel-Bridge</Filter>
    </ClCompile>
    <ClCompile Include="API\Signatures.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\SectionsUtils.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\Hypervisor.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\PteUtils.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\Callable.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\Stopwatch.cpp">
      <Filter>API</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Kernel-Bridge\FilterCallbacks.h">
      <Filter>Kernel-Bridge</Filter>
    </ClInclude>
    <ClInclude Include="Kernel-Bridge\IOCTLs.h">
      <Filter>Kernel-Bridge</Filter>
    </ClInclude>
    <ClInclude Include="API\MemoryUtils.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\ProcessesUtils.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\RAII.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\OSVersion.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\Locks.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\CppSupport.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\IO.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\CPU.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="Kernel-Bridge\IOCTLHandlers.h">
      <Filter>Kernel-Bridge</Filter>
    </ClInclude>
    <ClInclude Include="..\SharedTypes\CtlTypes.h">
      <Filter>SharedTypes</Filter>
    </ClInclude>
    <ClInclude Include="API\KernelShells.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\ObCallbacks.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\LinkedList.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="Kernel-Bridge\DriverEvents.h">
      <Filter>Kernel-Bridge</Filter>
    </ClInclude>
    <ClInclude Include="API\CommPort.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="..\SharedTypes\FltTypes.h">
      <Filter>SharedTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\SharedTypes\WdkTypes.h">
      <Filter>SharedTypes</Filter>
    </ClInclude>
    <ClInclude Include="API\PsCallbacks.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\StringsAPI.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\Importer.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="Kernel-Bridge\LoadableModules.h">
      <Filter>Kernel-Bridge</Filter>
    </ClInclude>
    <ClInclude Include="API\Signatures.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\SectionsUtils.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\Hypervisor.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\PTE.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\SVM.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="API\PteUtils.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\VMX.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\Registers.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\CPUID.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\Segmentation.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\MSR.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\Interrupts.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\Hyper-V.h">
      <Filter>CommonTypes</Filter>
    </ClInclude>
    <ClInclude Include="API\Callable.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="..\HookLib\HookLib\HookLib\HookLib.h">
      <Filter>HookLib</Filter>
    </ClInclude>
    <ClInclude Include="API\Stopwatch.h">
      <Filter>API</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def">
      <Filter>Main</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="API\VMM.asm">
      <Filter>API</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Kernel-Bridge/Kernel-Bridge/DriverEvents.cpp`:

```cpp
#include <fltKernel.h>

#include "FilterCallbacks.h"
#include "../API/Hypervisor.h"

volatile LONG KbHandlesCount = 0;

VOID OnDriverLoad(
    PDRIVER_OBJECT DriverObject, 
    PDEVICE_OBJECT DeviceObject, 
    PFLT_FILTER FilterHandle,
    PUNICODE_STRING RegistryPath
) {
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    if (FilterHandle) {
        Communication::StartServer(FilterHandle);
        Status = KbCallbacks::StartObHandlesFilter();
        KdPrint(("[Kernel-Bridge]: ObHandlesFilter status: 0x%X\r\n", Status));
        Status = KbCallbacks::StartPsProcessFilter();
        KdPrint(("[Kernel-Bridge]: PsProcessFilter status: 0x%X\r\n", Status));
        Status = KbCallbacks::StartPsThreadFilter();
        KdPrint(("[Kernel-Bridge]: PsThreadFilter status: 0x%X\r\n", Status));
        Status = KbCallbacks::StartPsImageFilter();
        KdPrint(("[Kernel-Bridge]: PsImageFilter status: 0x%X\r\n", Status));
    }
}

VOID OnDriverUnload(
    PDRIVER_OBJECT DriverObject, 
    PDEVICE_OBJECT DeviceObject
) {
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(DeviceObject);
    Hypervisor::Devirtualize(); // Devirtualize processor if it is in virtualized state
}

VOID OnFilterUnload(
    PDEVICE_OBJECT DeviceObject, 
    PFLT_FILTER FilterHandle,
    FLT_FILTER_UNLOAD_FLAGS Flags
) {
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(FilterHandle);
    UNREFERENCED_PARAMETER(Flags);

    KbCallbacks::StopObHandlesFilter();
    KbCallbacks::StopPsProcessFilter();
    KbCallbacks::StopPsThreadFilter();
    KbCallbacks::StopPsImageFilter();

    Communication::StopServer();
}

VOID OnDriverCreate(
    PDEVICE_OBJECT DeviceObject,
    PFLT_FILTER FilterHandle,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
) {
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(FilterHandle);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpStack);
    InterlockedIncrement(&KbHandlesCount);
}

VOID OnDriverCleanup(
    PDEVICE_OBJECT DeviceObject,
    PFLT_FILTER FilterHandle,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
) {
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(FilterHandle);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpStack);
}

VOID OnDriverClose(
    PDEVICE_OBJECT DeviceObject,
    PFLT_FILTER FilterHandle,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
) {
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(FilterHandle);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(IrpStack);
    InterlockedDecrement(&KbHandlesCount);
}

namespace HypervisorManagement {
    static bool NeedToRevirtualizeOnWake = false;
}

VOID OnSystemSleep()
{
    using namespace HypervisorManagement;
    if (Hypervisor::IsVirtualized()) {
        NeedToRevirtualizeOnWake = true;
        Hypervisor::Devirtualize();
    }
    else {
        NeedToRevirtualizeOnWake = false;
    }
}

VOID OnSystemWake()
{
    using namespace HypervisorManagement;
    if (NeedToRevirtualizeOnWake)
        Hypervisor::Virtualize();
}

```

`Kernel-Bridge/Kernel-Bridge/DriverEvents.h`:

```h
#pragma once

VOID OnDriverLoad(
    PDRIVER_OBJECT DriverObject, 
    PDEVICE_OBJECT DeviceObject, 
    PFLT_FILTER FilterHandle,
    PUNICODE_STRING RegistryPath
);

VOID OnDriverUnload(
    PDRIVER_OBJECT DriverObject, 
    PDEVICE_OBJECT DeviceObject
);

VOID OnFilterUnload(
    PDEVICE_OBJECT DeviceObject, 
    PFLT_FILTER FilterHandle,
    FLT_FILTER_UNLOAD_FLAGS Flags
);

VOID OnDriverCreate(
    PDEVICE_OBJECT DeviceObject,
    PFLT_FILTER FilterHandle,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
);

VOID OnDriverCleanup(
    PDEVICE_OBJECT DeviceObject,
    PFLT_FILTER FilterHandle,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
);

VOID OnDriverClose(
    PDEVICE_OBJECT DeviceObject,
    PFLT_FILTER FilterHandle,
    PIRP Irp,
    PIO_STACK_LOCATION IrpStack
);

VOID OnSystemSleep();
VOID OnSystemWake();
```

`Kernel-Bridge/Kernel-Bridge/FilterCallbacks.cpp`:

```cpp
#include <fltKernel.h>
#include <stdarg.h>

#include "../API/MemoryUtils.h"
#include "../API/ProcessesUtils.h"
#include "../API/Locks.h"
#include "../API/LinkedList.h"
#include "../API/CommPort.h"
#include "../API/ObCallbacks.h"
#include "../API/PsCallbacks.h"
#include "../API/StringsAPI.h"

#include "FilterCallbacks.h"

#include "WdkTypes.h"
#include "FltTypes.h"

#include "IOCTLs.h"

namespace Communication {
    static CommPort Server;

    LPCWSTR PortName = L"\\Kernel-Bridge"; 

    NTSTATUS StartServer(PFLT_FILTER FilterHandle) {
        return Server.StartServer(
            FilterHandle, 
            PortName,
            []( // OnMessage received:
                CommPort::CLIENT_INFO& Client,
                CommPort::CLIENT_REQUEST& Request,
                OUT PULONG ReturnLength
            ) -> NTSTATUS {
                UNREFERENCED_PARAMETER(Client);
                UNREFERENCED_PARAMETER(Request);
                UNREFERENCED_PARAMETER(ReturnLength);
                KdPrint(("[Kernel-Bridge]: Message received!\r\n"));
                return STATUS_SUCCESS;
            }
        );
    }

    VOID StopServer() {
        Server.StopServer();
    }

    bool IsProcessSubscribed(CommPort::ClientsList& Clients, HANDLE ProcessId) {
        for (const auto& Client : Clients) {
            if (Client.SizeOfContext != sizeof(KB_FLT_CONTEXT)) continue;
            auto ClientContext = static_cast<PKB_FLT_CONTEXT>(Client.ConnectionContext);
            if (ClientContext->Client.ProcessId == reinterpret_cast<UINT64>(ProcessId)) return true;
        }
        return false;
    }

    bool IsClientAppropriate(const CommPort::CLIENT_INFO& Client, KbFltTypes Type, OPTIONAL HANDLE IgnoredThreadId = NULL) {
        if (Client.SizeOfContext != sizeof(KB_FLT_CONTEXT)) return false;
        auto ClientContext = static_cast<PKB_FLT_CONTEXT>(Client.ConnectionContext);
        if (ClientContext->Type != Type) return false;
        return !IgnoredThreadId || reinterpret_cast<HANDLE>(ClientContext->Client.ThreadId) != IgnoredThreadId;    
    }
}

namespace KbCallbacks {
    static ObCallbacks ObHandlesFilter;
    static PsProcessCallback PsProcessFilter;
    static PsThreadCallback PsThreadFilter;
    static PsImageCallback PsImageFilter;

    NTSTATUS StartObHandlesFilter() {
        return ObHandlesFilter.SetupCallbacks(
            [](PVOID Context, POB_PRE_OPERATION_INFORMATION Info) -> OB_PREOP_CALLBACK_STATUS {
                UNREFERENCED_PARAMETER(Context);
                KB_FLT_OB_CALLBACK_INFO FltInfo = {};
                FltInfo.Client.ProcessId = reinterpret_cast<UINT64>(PsGetCurrentProcessId());
                FltInfo.Client.ThreadId = reinterpret_cast<UINT64>(PsGetCurrentThreadId());

                if (Info->ObjectType == *PsProcessType) {
                    FltInfo.Target.ProcessId = reinterpret_cast<UINT64>(
                        PsGetProcessId(static_cast<PEPROCESS>(Info->Object))
                    );
                } else if (Info->ObjectType == *PsThreadType) {
                    FltInfo.Target.ProcessId = reinterpret_cast<UINT64>(
                        PsGetProcessId(static_cast<PEPROCESS>(IoThreadToProcess(static_cast<PETHREAD>(Info->Object))))    
                    );
                    FltInfo.Target.ThreadId = reinterpret_cast<UINT64>(
                        PsGetThreadId(static_cast<PETHREAD>(Info->Object))    
                    );
                }

                FltInfo.CreateDesiredAccess    = Info->Parameters->CreateHandleInformation.OriginalDesiredAccess;
                FltInfo.DuplicateDesiredAccess = Info->Parameters->DuplicateHandleInformation.OriginalDesiredAccess;
                FltInfo.CreateResultAccess     = Info->Parameters->CreateHandleInformation.DesiredAccess;
                FltInfo.DuplicateResultAccess  = Info->Parameters->DuplicateHandleInformation.DesiredAccess;

                using namespace Communication;
                auto& Clients = Server.GetClients();
                
                Clients.LockShared();

                // Check whether we are in context of one of filtering threads:
                for (auto& Client : Clients) {
                    if (Client.SizeOfContext != sizeof(KB_FLT_CONTEXT)) continue;
                    auto ClientContext = static_cast<PKB_FLT_CONTEXT>(Client.ConnectionContext);
                    if (FltInfo.Client.ProcessId == ClientContext->Client.ProcessId) {
                        Clients.Unlock();
                        return OB_PREOP_SUCCESS;
                    }
                }
                
                // Broadcasting:
                for (auto& Client : Clients) {
                    // Check whether the filter type is ObCallbacks:
                    if (!IsClientAppropriate(Client, KbObCallbacks)) continue;
                    
                    KB_FLT_OB_CALLBACK_INFO Request = FltInfo;
                    Server.Send(Client.ClientPort, &Request, sizeof(Request), &Request, sizeof(Request), 350);
                    FltInfo.CreateResultAccess = Request.CreateResultAccess;
                    FltInfo.DuplicateResultAccess = Request.DuplicateResultAccess;
                }

                Clients.Unlock();

                Info->Parameters->CreateHandleInformation.DesiredAccess    = FltInfo.CreateResultAccess;
                Info->Parameters->DuplicateHandleInformation.DesiredAccess = FltInfo.DuplicateResultAccess;

                return OB_PREOP_SUCCESS;
            }
        );
    }

    VOID StopObHandlesFilter() {
        ObHandlesFilter.RemoveCallbacks();
    }

    NTSTATUS StartPsProcessFilter() {
        return PsProcessFilter.SetupCallback(
            [](HANDLE ParentId, HANDLE ProcessId, BOOLEAN Created) -> VOID {
                KB_FLT_PS_PROCESS_INFO Info = {};
                Info.ParentId = reinterpret_cast<UINT64>(ParentId);
                Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
                Info.Created = Created;

                using namespace Communication;
                auto& Clients = Server.GetClients();

                HANDLE CurrentThreadId = PsGetCurrentThreadId();

                Clients.LockShared();
                for (auto& Client : Clients) {
                    if (!IsClientAppropriate(Client, KbPsProcess, CurrentThreadId)) continue;

                    // We're not waiting for response:
                    Server.Send(Client.ClientPort, &Info, sizeof(Info));
                }
                Clients.Unlock();
            }
        );
    }

    VOID StopPsProcessFilter() {
        PsProcessFilter.RemoveCallback();
    }

    NTSTATUS StartPsThreadFilter() {
        return PsThreadFilter.SetupCallback(
            [](HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Created) -> VOID {
                KB_FLT_PS_THREAD_INFO Info = {};
                Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
                Info.ThreadId = reinterpret_cast<UINT64>(ThreadId);
                Info.Created = Created;

                using namespace Communication;
                auto& Clients = Server.GetClients();

                HANDLE CurrentThreadId = PsGetCurrentThreadId();

                Clients.LockShared();
                for (auto& Client : Clients) {
                    if (!IsClientAppropriate(Client, KbPsThread, CurrentThreadId)) continue;

                    // We're not waiting for response:
                    Server.Send(Client.ClientPort, &Info, sizeof(Info));
                }
                Clients.Unlock();
            }
        );
    }

    VOID StopPsThreadFilter() {
        PsThreadFilter.RemoveCallback();
    }

    NTSTATUS StartPsImageFilter() {
        return PsImageFilter.SetupCallback(
            [](PUNICODE_STRING FullImageName, HANDLE ProcessId, PIMAGE_INFO ImageInfo) -> VOID {
                KB_FLT_PS_IMAGE_INFO Info = {};
                Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
                Info.BaseAddress = reinterpret_cast<WdkTypes::PVOID>(ImageInfo->ImageBase);
                Info.ImageSize = ImageInfo->ImageSize;
                if (FullImageName && FullImageName->Buffer && FullImageName->Length && FullImageName->MaximumLength) {
                    RtlCopyMemory(
                        Info.FullImageName, 
                        FullImageName->Buffer, 
                        FullImageName->Length >= sizeof(Info.FullImageName) 
                            ? sizeof(Info.FullImageName) - 1
                            : FullImageName->Length
                    );
                }

                using namespace Communication;
                auto& Clients = Server.GetClients();

                Clients.LockShared();
                for (auto& Client : Clients) {
                    if (Client.SizeOfContext != sizeof(KB_FLT_CONTEXT)) continue;
                    auto ClientContext = static_cast<PKB_FLT_CONTEXT>(Client.ConnectionContext);
                    if (ClientContext->Type != KbPsImage) continue;

                    // We're not waiting for response:
                    Server.Send(Client.ClientPort, &Info, sizeof(Info));
                }
                Clients.Unlock();
            }
        );
    }

    VOID StopPsImageFilter() {
        PsImageFilter.RemoveCallback();
    }
}

static WideString GetWin32Path(const PFLT_CALLBACK_DATA Data) {
    if (!Data || !Data->Iopb || !Data->Iopb->TargetFileObject) return WideString();
    const PFILE_OBJECT FileObject = Data->Iopb->TargetFileObject;
    if (!FileObject || !FileObject->DeviceObject || !FileObject->FileName.Buffer) return WideString();
    
    if (KeGetCurrentIrql() > PASSIVE_LEVEL || KeAreAllApcsDisabled())
        return WideString(&FileObject->FileName);

    UNICODE_STRING VolumeName;
    if (NT_SUCCESS(IoVolumeDeviceToDosName(FileObject->DeviceObject, &VolumeName))) {
        WideString Volume(&VolumeName);
        ExFreePool(VolumeName.Buffer);
        return Volume + WideString(&FileObject->FileName);
    }
    else {
        return WideString(&FileObject->FileName);
    }

    //POBJECT_NAME_INFORMATION Name = NULL;
    //if (NT_SUCCESS(IoQueryFileDosDeviceName(FileObject, &Name)) && Name) {
    //    WideString Path(&Name->Name);
    //    ExFreePool(Name);
    //    return Path;
    //} else {
    //    return WideString(&FileObject->FileName);
    //}
}

static WideString GetNtFileName(const PFLT_CALLBACK_DATA Data) {
    if (!Data || !Data->Iopb || !Data->Iopb->TargetFileObject) return WideString();

    PFLT_FILE_NAME_INFORMATION Info = NULL;
    NTSTATUS Status = FltGetFileNameInformation(
        Data, 
        FLT_FILE_NAME_OPENED | FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP,
        &Info
    );

    if (!NT_SUCCESS(Status) || !Info) return WideString();

    FltParseFileNameInformation(Info);
    WideString FileName(&Info->Name);

    FltReleaseFileNameInformation(Info);

    return FileName;
}

static WideString GetFilePath(const PFLT_CALLBACK_DATA Data) {
    WideString Path = GetWin32Path(Data);
    if (!Path.GetLength()) Path = GetNtFileName(Data);
    return Path;
}

namespace FltHandlers {
    enum FltDirection {
        FltPreOp,
        FltPostOp
    };

    NTSTATUS FltCreateHandler(
        FltDirection Direction,
        _Inout_ PFLT_CALLBACK_DATA Data,
        _In_ PCFLT_RELATED_OBJECTS FltObjects,
        _Flt_CompletionContext_Outptr_ PVOID* CompletionContext
    ) {
        UNREFERENCED_PARAMETER(FltObjects);
        UNREFERENCED_PARAMETER(CompletionContext);

        // Check whether MajorNumber is valid:
        if (Data->Iopb->MajorFunction != IRP_MJ_CREATE) 
            return STATUS_SUCCESS;

        KbFltTypes HandlerType = KbFltNone;
        switch (Direction) {
        case FltPreOp:
            HandlerType = KbFltPreCreate;
            break;
        case FltPostOp:
            HandlerType = KbFltPostCreate;
            break;
        default:
            return STATUS_SUCCESS; // Unknown direction
        }

        WideString Path = GetFilePath(Data);

        KB_FLT_CREATE_INFO Info = {};
        HANDLE ProcessId = PsGetCurrentProcessId();
        HANDLE ThreadId = PsGetCurrentThreadId();
        Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
        Info.ThreadId = reinterpret_cast<UINT64>(ThreadId);
        Info.AccessMask = Data->Iopb->Parameters.Create.SecurityContext->DesiredAccess;
        Path.CopyTo(Info.Path, (sizeof(Info.Path) / sizeof(Info.Path[0])) - 1);

        using namespace Communication;
        auto& Clients = Server.GetClients();

        Clients.LockShared();
        for (auto& Client : Clients) {
            if (!IsClientAppropriate(Client, HandlerType, ThreadId)) continue;

            Server.Send(Client.ClientPort, &Info, sizeof(Info), &Info, sizeof(Info), 350);

            // Restoring constant fields:
            Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
            Info.ThreadId = reinterpret_cast<UINT64>(ThreadId);
            Info.AccessMask = Data->Iopb->Parameters.Create.SecurityContext->DesiredAccess;
        }
        Clients.Unlock();

        return Info.Status;
    }

    NTSTATUS FltReadWriteHandler(
        FltDirection Direction,
        _Inout_ PFLT_CALLBACK_DATA Data,
        _In_ PCFLT_RELATED_OBJECTS FltObjects,
        _Flt_CompletionContext_Outptr_ _Inout_ PVOID* CompletionContext
    ) {
        UNREFERENCED_PARAMETER(FltObjects);
        UNREFERENCED_PARAMETER(CompletionContext);

        UCHAR IrpMjNumber = Data->Iopb->MajorFunction;
        KbFltTypes HandlerType = KbFltNone;
        switch (Direction) {
        case FltPreOp:
            switch (IrpMjNumber) {
            case IRP_MJ_READ:
                HandlerType = KbFltPreRead;
                break;
            case IRP_MJ_WRITE:
                HandlerType = KbFltPreWrite;
                break;
            default:
                return STATUS_SUCCESS; // Invalid IRP_MJ_*** for this handler
            }
            break;
        case FltPostOp:
            switch (IrpMjNumber) {
            case IRP_MJ_READ:
                HandlerType = KbFltPostRead;
                break;
            case IRP_MJ_WRITE:
                HandlerType = KbFltPostWrite;
                break;
            default:
                return STATUS_SUCCESS; // Invalid IRP_MJ_*** for this handler
            }
            break;
        default:
            return STATUS_SUCCESS; // Unknown direction
        }

        if (!NT_SUCCESS(FltLockUserBuffer(Data)))
            return STATUS_SUCCESS; // Well, we aren't filtering due to locking failure

        WideString Path = GetFilePath(Data);
        
        KB_FLT_READ_WRITE_INFO Info = {};
        HANDLE ProcessId = PsGetCurrentProcessId();
        HANDLE ThreadId = PsGetCurrentThreadId();
        PMDL Mdl = NULL;
        ULONG Size = 0;

        switch (HandlerType) {
        case KbFltPreRead:
        case KbFltPostRead:
            Mdl = Data->Iopb->Parameters.Read.MdlAddress;
            Size = Data->Iopb->Parameters.Read.Length;
            break;
        case KbFltPreWrite:
        case KbFltPostWrite:
            Mdl = Data->Iopb->Parameters.Write.MdlAddress;
            Size = Data->Iopb->Parameters.Write.Length;
            break;
        default:
            return STATUS_SUCCESS; // Invalid HandlerType fot this request
        }

        using namespace Communication;
        auto& Clients = Server.GetClients();

        Clients.LockShared();
        if (!IsProcessSubscribed(Clients, ProcessId)) for (auto& Client : Clients) {
            if (!IsClientAppropriate(Client, HandlerType, ThreadId)) continue;

            // Every iteration restoring constant fields:
            Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
            Info.ThreadId = reinterpret_cast<UINT64>(ThreadId);
            Info.LockedMdl = reinterpret_cast<WdkTypes::PMDL>(Mdl);
            Info.Size = Size;
            Path.CopyTo(Info.Path, (sizeof(Info.Path) / sizeof(Info.Path[0])) - 1);

            Server.Send(Client.ClientPort, &Info, sizeof(Info), &Info, sizeof(Info), 5000);
        }
        Clients.Unlock();

        return Info.Status;    
    }

    NTSTATUS FltDeviceControlHandler(
        FltDirection Direction,
        _Inout_ PFLT_CALLBACK_DATA Data,
        _In_ PCFLT_RELATED_OBJECTS FltObjects,
        _Flt_CompletionContext_Outptr_ _Inout_ PVOID* CompletionContext
    ) {
        UNREFERENCED_PARAMETER(FltObjects);
        UNREFERENCED_PARAMETER(CompletionContext);

        UCHAR IrpMjNumber = Data->Iopb->MajorFunction;
        KbFltTypes HandlerType = KbFltNone;
        switch (Direction) {
        case FltPreOp:
            switch (IrpMjNumber) {
            case IRP_MJ_DEVICE_CONTROL:
                HandlerType = KbFltPreDeviceControl;
                break;
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
                HandlerType = KbFltPreInternalDeviceControl;
                break;
            case IRP_MJ_FILE_SYSTEM_CONTROL:
                HandlerType = KbFltPreFileSystemControl;
                break;
            default:
                return STATUS_SUCCESS; // Invalid IRP_MJ_*** for this handler
            }
            break;
        case FltPostOp:
            switch (IrpMjNumber) {
            case IRP_MJ_DEVICE_CONTROL:
                HandlerType = KbFltPostDeviceControl;
                break;
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
                HandlerType = KbFltPostInternalDeviceControl;
                break;
            case IRP_MJ_FILE_SYSTEM_CONTROL:
                HandlerType = KbFltPostFileSystemControl;
                break;
            default:
                return STATUS_SUCCESS; // Invalid IRP_MJ_*** for this handler
            }
            break;
        default:
            return STATUS_SUCCESS; // Unknown direction
        }

        WideString Path = GetFilePath(Data);

        KB_FLT_DEVICE_CONTROL_INFO Info = {};
        HANDLE ProcessId = PsGetCurrentProcessId();
        HANDLE ThreadId = PsGetCurrentThreadId();
        ULONG Ioctl = Data->Iopb->Parameters.DeviceIoControl.Common.IoControlCode;
        ULONG InputSize = Data->Iopb->Parameters.DeviceIoControl.Common.InputBufferLength;
        ULONG OutputSize = Data->Iopb->Parameters.DeviceIoControl.Common.OutputBufferLength;
        PMDL InputMdl = NULL;
        PMDL OutputMdl = NULL;

        switch (EXTRACT_CTL_METHOD(Ioctl)) {
        case METHOD_BUFFERED: {
            PVOID SystemBuffer = Data->Iopb->Parameters.DeviceIoControl.Buffered.SystemBuffer;
            if (SystemBuffer && InputSize)
                InputMdl = Mdl::AllocMdlAndLockPages(SystemBuffer, InputSize);
            if (SystemBuffer && OutputSize)
                OutputMdl = Mdl::AllocMdlAndLockPages(SystemBuffer, InputSize, KernelMode, IoWriteAccess);
            break;
        }
        case METHOD_IN_DIRECT:
        case METHOD_OUT_DIRECT: {
            PVOID InputSystemBuffer = Data->Iopb->Parameters.DeviceIoControl.Direct.InputSystemBuffer;
            if (InputSystemBuffer && InputSize)
                InputMdl = Mdl::AllocMdlAndLockPages(InputSystemBuffer, InputSize);
            if (NT_SUCCESS(FltLockUserBuffer(Data)))
                OutputMdl = Data->Iopb->Parameters.DeviceIoControl.Direct.OutputMdlAddress;
            break;
        }
        case METHOD_NEITHER:
            PVOID InputUserBuffer = Data->Iopb->Parameters.DeviceIoControl.Neither.InputBuffer;
            if (InputUserBuffer && InputSize)
                InputMdl = Mdl::AllocMdlAndLockPages(InputUserBuffer, InputSize);
            if (NT_SUCCESS(FltLockUserBuffer(Data)))
                OutputMdl = Data->Iopb->Parameters.DeviceIoControl.Neither.OutputMdlAddress;
            break;
        }

        using namespace Communication;
        auto& Clients = Server.GetClients();

        Clients.LockShared();
        if (!IsProcessSubscribed(Clients, ProcessId)) for (auto& Client : Clients) {
            if (!IsClientAppropriate(Client, HandlerType, ThreadId)) continue;

            // Every iteration restoring constant fields:
            Info.ProcessId = reinterpret_cast<UINT64>(ProcessId);
            Info.ThreadId = reinterpret_cast<UINT64>(ThreadId);
            Info.InputLockedMdl = reinterpret_cast<WdkTypes::PMDL>(InputMdl);
            Info.OutputLockedMdl = reinterpret_cast<WdkTypes::PMDL>(OutputMdl);
            Info.InputSize = InputSize;
            Info.OutputSize = OutputSize;
            Info.Ioctl = Ioctl;
            Path.CopyTo(Info.Path, (sizeof(Info.Path) / sizeof(Info.Path[0])) - 1);

            Server.Send(Client.ClientPort, &Info, sizeof(Info), &Info, sizeof(Info), 5000);
        }
        Clients.Unlock();

        switch (EXTRACT_CTL_METHOD(Ioctl)) {
        case METHOD_BUFFERED:
            if (OutputMdl) 
                Mdl::UnlockPagesAndFreeMdl(OutputMdl);
            [[fallthrough]];
        case METHOD_IN_DIRECT:
        case METHOD_OUT_DIRECT:
        case METHOD_NEITHER:
            if (InputMdl) 
                Mdl::UnlockPagesAndFreeMdl(InputMdl);
            break;
        }

        return Info.Status;    
    }
}

FLT_PREOP_CALLBACK_STATUS
FilterPreOperation(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID* CompletionContext
) {
    // If we at DPC or greater we're unable to use communication ports...
    if (KeGetCurrentIrql() > APC_LEVEL)
        return FLT_PREOP_SUCCESS_NO_CALLBACK;

    // Check whether we have what to handle:
    if (!Data->Iopb->TargetFileObject)
        return FLT_PREOP_SUCCESS_NO_CALLBACK;

    NTSTATUS Status = STATUS_SUCCESS;
    switch (Data->Iopb->MajorFunction) {
    case IRP_MJ_CREATE:
        Status = FltHandlers::FltCreateHandler(FltHandlers::FltPreOp, Data, FltObjects, CompletionContext);
        break;
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
        Status = FltHandlers::FltReadWriteHandler(FltHandlers::FltPreOp, Data, FltObjects, CompletionContext);
        break;
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        Status = FltHandlers::FltDeviceControlHandler(FltHandlers::FltPreOp, Data, FltObjects, CompletionContext);
        break;
    }

    if (!NT_SUCCESS(Status)) {
        Data->IoStatus.Status = Status;
        return FLT_PREOP_COMPLETE;
    }

    return FLT_PREOP_SUCCESS_WITH_CALLBACK;
}

FLT_POSTOP_CALLBACK_STATUS
FilterPostOperation(
    _Inout_  PFLT_CALLBACK_DATA Data,
    _In_     PCFLT_RELATED_OBJECTS FltObjects,
    _In_opt_ PVOID CompletionContext,
    _In_     FLT_POST_OPERATION_FLAGS Flags
) {
    UNREFERENCED_PARAMETER(Flags);

    if (KeGetCurrentIrql() > APC_LEVEL)
        return FLT_POSTOP_FINISHED_PROCESSING;

    if (!Data->Iopb->TargetFileObject)
        return FLT_POSTOP_FINISHED_PROCESSING;

    NTSTATUS Status = STATUS_SUCCESS;
    switch (Data->Iopb->MajorFunction) {
    case IRP_MJ_CREATE:
        Status = FltHandlers::FltCreateHandler(FltHandlers::FltPostOp, Data, FltObjects, &CompletionContext);
        break;
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
        Status = FltHandlers::FltReadWriteHandler(FltHandlers::FltPostOp, Data, FltObjects, &CompletionContext);
        break;
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        Status = FltHandlers::FltDeviceControlHandler(FltHandlers::FltPostOp, Data, FltObjects, &CompletionContext);
        break;
    }

    if (!NT_SUCCESS(Status)) {
        Data->IoStatus.Status = Status;
        return FLT_POSTOP_FINISHED_PROCESSING;
    }

    return FLT_POSTOP_FINISHED_PROCESSING;
}

```

`Kernel-Bridge/Kernel-Bridge/FilterCallbacks.h`:

```h
#pragma once

namespace Communication {
    NTSTATUS StartServer(PFLT_FILTER FilterHandle);
    VOID StopServer();
}

namespace KbCallbacks {
    // Handles callbacks:
    NTSTATUS StartObHandlesFilter();
    VOID StopObHandlesFilter();
    
    // Processes callbacks:
    NTSTATUS StartPsProcessFilter();
    VOID StopPsProcessFilter();
    
    // Threads callbacks:
    NTSTATUS StartPsThreadFilter();
    VOID StopPsThreadFilter();
    
    // Images callbacks:
    NTSTATUS StartPsImageFilter();
    VOID StopPsImageFilter();
}

EXTERN_C_START

FLT_PREOP_CALLBACK_STATUS
FilterPreOperation(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_    PCFLT_RELATED_OBJECTS FltObjects,
    _Flt_CompletionContext_Outptr_ PVOID* CompletionContext
);

FLT_POSTOP_CALLBACK_STATUS
FilterPostOperation(
    _Inout_  PFLT_CALLBACK_DATA Data,
    _In_     PCFLT_RELATED_OBJECTS FltObjects,
    _In_opt_ PVOID CompletionContext,
    _In_     FLT_POST_OPERATION_FLAGS Flags
);

EXTERN_C_END
```

`Kernel-Bridge/Kernel-Bridge/IOCTLHandlers.cpp`:

```cpp
#include <fltKernel.h>
#include <ntstrsafe.h>
#include <stdarg.h>

#include "WdkTypes.h"
#include "CtlTypes.h"
#include "IOCTLHandlers.h"
#include "LoadableModules.h"

#include "PTE.h"

#include "../API/MemoryUtils.h"
#include "../API/PteUtils.h"
#include "../API/ProcessesUtils.h"
#include "../API/SectionsUtils.h"
#include "../API/IO.h"
#include "../API/CPU.h"
#include "../API/Importer.h"
#include "../API/KernelShells.h"
#include "../API/StringsAPI.h"
#include "../API/Signatures.h"
#include "../API/Hypervisor.h"

#include "IOCTLs.h"

#ifdef _AMD64_
extern "C" size_t __cdecl __readcr3();
extern "C" size_t __cdecl __readcr4();
#else
extern "C" unsigned long __cdecl __readcr4();
#endif

extern volatile LONG KbHandlesCount;

namespace
{
    NTSTATUS FASTCALL KbGetDriverApiVersion(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (RequestInfo->OutputBufferSize != sizeof(KB_GET_DRIVER_API_VERSION_OUT)) 
            return STATUS_INFO_LENGTH_MISMATCH;
        auto Output = reinterpret_cast<PKB_GET_DRIVER_API_VERSION_OUT>(RequestInfo->OutputBuffer);
        if (!Output) return STATUS_INVALID_PARAMETER;
        Output->Version = KB_API_VERSION;
        *ResponseLength = sizeof(*Output);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbGetHandlesCount(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (RequestInfo->OutputBufferSize != sizeof(KB_GET_HANDLES_COUNT_OUT)) 
            return STATUS_INFO_LENGTH_MISMATCH;
        auto Output = reinterpret_cast<PKB_GET_HANDLES_COUNT_OUT>(RequestInfo->OutputBuffer);
        if (!Output) return STATUS_INVALID_PARAMETER;
        Output->HandlesCount = KbHandlesCount;
        *ResponseLength = sizeof(*Output);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbSetBeeperRegime(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::Beeper::SetBeeperRegime();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbStartBeeper(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::Beeper::StartBeeper();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbStopBeeper(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::Beeper::StopBeeper();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbSetBeeperIn(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::Beeper::SetBeeperIn();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbSetBeeperOut(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::Beeper::SetBeeperOut();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbSetBeeperDivider(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);
        if (RequestInfo->InputBufferSize != sizeof(KB_SET_BEEPER_DIVIDER_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;
        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;
        IO::Beeper::SetBeeperDivider(static_cast<PKB_SET_BEEPER_DIVIDER_IN>(RequestInfo->InputBuffer)->Divider);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbSetBeeperFrequency(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);
        if (RequestInfo->InputBufferSize != sizeof(KB_SET_BEEPER_FREQUENCY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;
        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;
        IO::Beeper::SetBeeperFrequency(static_cast<PKB_SET_BEEPER_FREQUENCY_IN>(RequestInfo->InputBuffer)->Frequency);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbReadPort(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;
        
        if (RequestInfo->InputBufferSize != sizeof(KB_READ_PORT_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        switch (RequestInfo->OutputBufferSize) {
        case sizeof(UCHAR): {
            static_cast<PKB_READ_PORT_BYTE_OUT>(RequestInfo->OutputBuffer)->Value =
                IO::RW::ReadPortByte(static_cast<PKB_READ_PORT_IN>(RequestInfo->InputBuffer)->PortNumber);
            break;
        }
        case sizeof(USHORT): {
            static_cast<PKB_READ_PORT_WORD_OUT>(RequestInfo->OutputBuffer)->Value =
                IO::RW::ReadPortWord(static_cast<PKB_READ_PORT_IN>(RequestInfo->InputBuffer)->PortNumber);
            break;
        }
        case sizeof(ULONG): {
            static_cast<PKB_READ_PORT_DWORD_OUT>(RequestInfo->OutputBuffer)->Value =
                IO::RW::ReadPortDword(static_cast<PKB_READ_PORT_IN>(RequestInfo->InputBuffer)->PortNumber);
            break;
        }
        default:
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbReadPortString(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_READ_PORT_STRING_IN>(RequestInfo->InputBuffer);
        if (RequestInfo->InputBufferSize != sizeof(KB_READ_PORT_STRING_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        ULONG BytesToReadCount = Input->Count * Input->Granularity;
        if (RequestInfo->OutputBufferSize < BytesToReadCount) 
            return STATUS_INFO_LENGTH_MISMATCH;

        switch (Input->Granularity) {
        case sizeof(UCHAR): {
            IO::RW::ReadPortByteString(
                Input->PortNumber,
                static_cast<PKB_READ_PORT_STRING_OUT>(RequestInfo->OutputBuffer)->ByteString,
                Input->Count
            );
            break;
        }
        case sizeof(USHORT): {
            IO::RW::ReadPortWordString(
                Input->PortNumber,
                static_cast<PKB_READ_PORT_STRING_OUT>(RequestInfo->OutputBuffer)->WordString,
                Input->Count
            );
            break;            
        }
        case sizeof(ULONG): {
            IO::RW::ReadPortDwordString(
                Input->PortNumber,
                static_cast<PKB_READ_PORT_STRING_OUT>(RequestInfo->OutputBuffer)->DwordString,
                Input->Count
            );
            break;            
        }
        default:
            return STATUS_INVALID_PARAMETER;
        }

        *ResponseLength = BytesToReadCount;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbWritePort(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_WRITE_PORT_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_WRITE_PORT_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        switch (Input->Granularity) {
        case sizeof(UCHAR): {
            IO::RW::WritePortByte(Input->PortNumber, Input->Byte);
            break;
        }
        case sizeof(USHORT): {
            IO::RW::WritePortWord(Input->PortNumber, Input->Word);
            break;
        }
        case sizeof(ULONG): {
            IO::RW::WritePortDword(Input->PortNumber, Input->Dword);
            break;
        }
        default:
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbWritePortString(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize <= sizeof(KB_WRITE_PORT_STRING_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_WRITE_PORT_STRING_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        if (Input->BufferSize < Input->Count * Input->Granularity)
            return STATUS_INFO_LENGTH_MISMATCH;

        switch (Input->Granularity) {
        case sizeof(UCHAR): {
            IO::RW::WritePortByteString(Input->PortNumber, reinterpret_cast<unsigned char*>(Input->Buffer), Input->Count);
            break;
        }
        case sizeof(USHORT): {
            IO::RW::WritePortWordString(Input->PortNumber, reinterpret_cast<unsigned short*>(Input->Buffer), Input->Count);
            break;
        }
        case sizeof(ULONG): {
            IO::RW::WritePortDwordString(Input->PortNumber, reinterpret_cast<unsigned long*>(Input->Buffer), Input->Count);
            break;
        }
        default:
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbCli(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        CPU::CLI();
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbSti(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        CPU::STI();
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbHlt(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        CPU::HLT();
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbReadMsr(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_READ_MSR_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_READ_MSR_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        static_cast<PKB_READ_MSR_OUT>(RequestInfo->OutputBuffer)->Value =
            CPU::RDMSR(static_cast<PKB_READ_MSR_IN>(RequestInfo->InputBuffer)->Index);

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbWriteMsr(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_WRITE_MSR_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        CPU::WRMSR(
            static_cast<PKB_WRITE_MSR_IN>(RequestInfo->InputBuffer)->Index,
            static_cast<PKB_WRITE_MSR_IN>(RequestInfo->InputBuffer)->Value
        );

        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbCpuid(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_CPUID_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_CPUID_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        CPU::CPUID(
            static_cast<PKB_CPUID_IN>(RequestInfo->InputBuffer)->FunctionIdEax,
            static_cast<int*>(RequestInfo->OutputBuffer)
        );

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbCpuidEx(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_CPUIDEX_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_CPUID_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        CPU::CPUIDEX(
            static_cast<PKB_CPUIDEX_IN>(RequestInfo->InputBuffer)->FunctionIdEax,
            static_cast<PKB_CPUIDEX_IN>(RequestInfo->InputBuffer)->SubfunctionIdEcx,
            static_cast<int*>(RequestInfo->OutputBuffer)
        );

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbReadPmc(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_READ_PMC_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_READ_PMC_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        static_cast<PKB_READ_PMC_OUT>(RequestInfo->OutputBuffer)->Value =
            CPU::RDPMC(static_cast<PKB_READ_PMC_IN>(RequestInfo->InputBuffer)->Counter);

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbReadTsc(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (RequestInfo->OutputBufferSize != sizeof(KB_READ_TSC_OUT)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        static_cast<PKB_READ_TSC_OUT>(RequestInfo->OutputBuffer)->Value = CPU::RDTSC();

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbReadTscp(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (RequestInfo->OutputBufferSize != sizeof(KB_READ_TSC_OUT)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        static_cast<PKB_READ_TSCP_OUT>(RequestInfo->OutputBuffer)->Value = 
            CPU::RDTSCP(&static_cast<PKB_READ_TSCP_OUT>(RequestInfo->OutputBuffer)->TscAux);

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;        
    }

    NTSTATUS FASTCALL KbAllocKernelMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_ALLOC_KERNEL_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_ALLOC_KERNEL_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_ALLOC_KERNEL_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_ALLOC_KERNEL_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        Output->KernelAddress = reinterpret_cast<WdkTypes::PVOID>(
            Input->Executable
                ? VirtualMemory::AllocFromPoolExecutable(Input->Size)
                : VirtualMemory::AllocFromPool(Input->Size)
        );

        *ResponseLength = RequestInfo->OutputBufferSize;
        return Output->KernelAddress ? STATUS_SUCCESS : STATUS_MEMORY_NOT_ALLOCATED;        
    }

    NTSTATUS FASTCALL KbFreeKernelMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_FREE_KERNEL_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FREE_KERNEL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->KernelAddress) return STATUS_INVALID_PARAMETER;

        VirtualMemory::FreePoolMemory(reinterpret_cast<PVOID>(Input->KernelAddress));
        
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbAllocNonCachedMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_ALLOC_NON_CACHED_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_ALLOC_NON_CACHED_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_ALLOC_NON_CACHED_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_ALLOC_NON_CACHED_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        Output->KernelAddress = reinterpret_cast<WdkTypes::PVOID>(
            VirtualMemory::AllocNonCachedNorInitialized(Input->Size)
        );

        *ResponseLength = RequestInfo->OutputBufferSize;
        return Output->KernelAddress ? STATUS_SUCCESS : STATUS_MEMORY_NOT_ALLOCATED;        
    }

    NTSTATUS FASTCALL KbFreeNonCachedMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_FREE_NON_CACHED_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FREE_NON_CACHED_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->KernelAddress) return STATUS_INVALID_PARAMETER;

        VirtualMemory::FreeNonCachedMemory(reinterpret_cast<PVOID>(Input->KernelAddress), Input->Size);
        
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbCopyMoveMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_COPY_MOVE_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_COPY_MOVE_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Src || !Input->Dest) return STATUS_INVALID_PARAMETER;

        if (!Input->Size) return STATUS_SUCCESS;

        BOOLEAN Status = FALSE; 
        __try {
            Status = VirtualMemory::CopyMemory(
                reinterpret_cast<PVOID>(Input->Dest),
                reinterpret_cast<PVOID>(Input->Src),
                Input->Size,
                Input->Intersects,
                TRUE
            );
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_UNSUCCESSFUL;
        }

        return Status ? STATUS_SUCCESS : STATUS_MEMORY_NOT_ALLOCATED;
    }

    NTSTATUS FASTCALL KbFillMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_FILL_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FILL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Address) return STATUS_INVALID_PARAMETER;

        PVOID Address = reinterpret_cast<PVOID>(Input->Address);

        using namespace VirtualMemory;
        using namespace AddressRange;
        if (IsKernelAddress(Address) && !IsMemoryRangePresent(Address, Input->Size))
            return STATUS_MEMORY_NOT_ALLOCATED;

        __try {
            RtlFillMemory(reinterpret_cast<PVOID>(Input->Address), Input->Size, Input->Filler);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_UNSUCCESSFUL;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbEqualMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_EQUAL_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_EQUAL_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_EQUAL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Src || !Input->Dest || !RequestInfo->OutputBuffer) return STATUS_INVALID_PARAMETER;

        PVOID Src = reinterpret_cast<PVOID>(Input->Src);
        PVOID Dest = reinterpret_cast<PVOID>(Input->Dest);

        using namespace VirtualMemory;
        using namespace AddressRange;

        if (IsKernelAddress(Src) && !IsMemoryRangePresent(Src, Input->Size))
            return STATUS_MEMORY_NOT_ALLOCATED;

        if (IsKernelAddress(Dest) && !IsMemoryRangePresent(Dest, Input->Size))
            return STATUS_MEMORY_NOT_ALLOCATED;

        *ResponseLength = RequestInfo->OutputBufferSize;

        __try {
            static_cast<PKB_EQUAL_MEMORY_OUT>(RequestInfo->OutputBuffer)->Equals = RtlEqualMemory(
                reinterpret_cast<PVOID>(Input->Src),
                reinterpret_cast<PVOID>(Input->Dest),
                Input->Size
            );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            static_cast<PKB_EQUAL_MEMORY_OUT>(RequestInfo->OutputBuffer)->Equals = FALSE;
            return STATUS_UNSUCCESSFUL;
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbAllocateMdl(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_ALLOCATE_MDL_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_ALLOCATE_MDL_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_ALLOCATE_MDL_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_ALLOCATE_MDL_OUT>(RequestInfo->OutputBuffer);
        if (!Input || !Output || !Input->VirtualAddress || !Input->Size) return STATUS_INVALID_PARAMETER;

        Output->Mdl = reinterpret_cast<WdkTypes::PMDL>(
            IoAllocateMdl(
                reinterpret_cast<PVOID>(Input->VirtualAddress),
                Input->Size,
                FALSE,
                FALSE,
                NULL
            )
        );

        *ResponseLength = sizeof(*Output);
        return Output->Mdl ? STATUS_SUCCESS : STATUS_INVALID_ADDRESS;
    }

    NTSTATUS FASTCALL KbProbeAndLockPages(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_PROBE_AND_LOCK_PAGES_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_PROBE_AND_LOCK_PAGES_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Mdl) return STATUS_INVALID_PARAMETER;

        NTSTATUS Status = STATUS_SUCCESS;

        if (Input->ProcessId && reinterpret_cast<HANDLE>(Input->ProcessId) != PsGetCurrentProcessId()) {
            PEPROCESS Process = Processes::Descriptors::GetEPROCESS(reinterpret_cast<HANDLE>(Input->ProcessId));
            if (!Process) return STATUS_NOT_FOUND;
            __try {
                MmProbeAndLockProcessPages(
                    reinterpret_cast<PMDL>(Input->Mdl),
                    Process,
                    static_cast<KPROCESSOR_MODE>(Input->ProcessorMode),
                    static_cast<LOCK_OPERATION>(Input->LockOperation)
                );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = STATUS_UNSUCCESSFUL;
            }
            ObDereferenceObject(Process);
        } else {
            __try {
                MmProbeAndLockPages(
                    reinterpret_cast<PMDL>(Input->Mdl),
                    static_cast<KPROCESSOR_MODE>(Input->ProcessorMode),
                    static_cast<LOCK_OPERATION>(Input->LockOperation)
                );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }

        return Status;
    }

    NTSTATUS FASTCALL KbMapMdl(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_MAP_MDL_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_MAP_MDL_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_MAP_MDL_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_MAP_MDL_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        PEPROCESS SrcProcess = NULL, DestProcess = NULL;
        HANDLE CurrentProcessId = PsGetCurrentProcessId();
        
        if (Input->SrcProcessId && reinterpret_cast<HANDLE>(Input->SrcProcessId) != CurrentProcessId) { 
            SrcProcess = Processes::Descriptors::GetEPROCESS(
                reinterpret_cast<HANDLE>(Input->SrcProcessId)
            );
            if (!SrcProcess) return STATUS_NOT_FOUND;
        }

        if (Input->DestProcessId && reinterpret_cast<HANDLE>(Input->DestProcessId) != CurrentProcessId) { 
            DestProcess = Processes::Descriptors::GetEPROCESS(
                reinterpret_cast<HANDLE>(Input->DestProcessId)
            );
            if (!DestProcess) {
                if (SrcProcess) ObDereferenceObject(SrcProcess);
                return STATUS_NOT_FOUND;
            }
        }

        PVOID Mapping = NULL;
        NTSTATUS Status = Mdl::MapMdl(
            reinterpret_cast<PMDL>(Input->Mdl),
            &Mapping,
            SrcProcess,
            DestProcess,
            Input->NeedProbeAndLock,
            static_cast<KPROCESSOR_MODE>(Input->MapToAddressSpace),
            Input->Protect,
            static_cast<MEMORY_CACHING_TYPE>(Input->CacheType),
            reinterpret_cast<PVOID>(Input->UserRequestedAddress)
        );

        Output->BaseAddress = reinterpret_cast<WdkTypes::PVOID>(Mapping);

        if (SrcProcess) ObDereferenceObject(SrcProcess);
        if (DestProcess) ObDereferenceObject(DestProcess);

        if (NT_SUCCESS(Status)) {
            *ResponseLength = RequestInfo->OutputBufferSize;
        }

        return Status;
    }

    NTSTATUS FASTCALL KbProtectMappedMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_PROTECT_MAPPED_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_PROTECT_MAPPED_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Mdl) return STATUS_INVALID_PARAMETER;

        return MmProtectMdlSystemAddress(
            reinterpret_cast<PMDL>(Input->Mdl),
            Input->Protect
        );
    }

    NTSTATUS FASTCALL KbUnmapMdl(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNMAP_MDL_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_UNMAP_MDL_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Mdl || !Input->BaseAddress) return STATUS_INVALID_PARAMETER;

        Mdl::UnmapMdl(reinterpret_cast<PMDL>(Input->Mdl), reinterpret_cast<PVOID>(Input->BaseAddress), Input->NeedUnlock);
        
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbUnlockPages(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNLOCK_PAGES_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_UNLOCK_PAGES_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Mdl) return STATUS_INVALID_PARAMETER;

        MmUnlockPages(reinterpret_cast<PMDL>(Input->Mdl));

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbFreeMdl(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_FREE_MDL_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FREE_MDL_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Mdl) return STATUS_INVALID_PARAMETER;

        IoFreeMdl(reinterpret_cast<PMDL>(Input->Mdl));

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbMapMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength) 
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_MAP_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_MAP_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_MAP_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_MAP_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        PEPROCESS SrcProcess = NULL, DestProcess = NULL;
        HANDLE CurrentProcessId = PsGetCurrentProcessId();
        
        if (Input->SrcProcessId && reinterpret_cast<HANDLE>(Input->SrcProcessId) != CurrentProcessId) { 
            SrcProcess = Processes::Descriptors::GetEPROCESS(
                reinterpret_cast<HANDLE>(Input->SrcProcessId)
            );
            if (!SrcProcess) return STATUS_NOT_FOUND;
        }

        if (Input->DestProcessId && reinterpret_cast<HANDLE>(Input->DestProcessId) != CurrentProcessId) { 
            DestProcess = Processes::Descriptors::GetEPROCESS(
                reinterpret_cast<HANDLE>(Input->DestProcessId)
            );
            if (!DestProcess) {
                if (SrcProcess) ObDereferenceObject(SrcProcess);
                return STATUS_NOT_FOUND;
            }
        }

        Mdl::MAPPING_INFO MappingInfo = {};
        NTSTATUS Status = Mdl::MapMemory(
            &MappingInfo,
            SrcProcess,
            DestProcess,
            reinterpret_cast<PVOID>(Input->VirtualAddress),
            Input->Size,
            static_cast<KPROCESSOR_MODE>(Input->MapToAddressSpace),
            Input->Protect,
            static_cast<MEMORY_CACHING_TYPE>(Input->CacheType),
            reinterpret_cast<PVOID>(Input->UserRequestedAddress)
        );

        if (SrcProcess) ObDereferenceObject(SrcProcess);
        if (DestProcess) ObDereferenceObject(DestProcess);

        if (NT_SUCCESS(Status)) {
            Output->Mdl = reinterpret_cast<WdkTypes::PMDL>(MappingInfo.Mdl);
            Output->BaseAddress = reinterpret_cast<WdkTypes::PVOID>(MappingInfo.BaseAddress);
            *ResponseLength = RequestInfo->OutputBufferSize;
        }

        return Status;
    }

    NTSTATUS FASTCALL KbUnmapMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNMAP_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_UNMAP_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Mdl || !Input->BaseAddress) return STATUS_INVALID_PARAMETER;

        Mdl::MAPPING_INFO MappingInfo = {};
        MappingInfo.Mdl = reinterpret_cast<PMDL>(Input->Mdl);
        MappingInfo.BaseAddress = reinterpret_cast<PVOID>(Input->BaseAddress);
        Mdl::UnmapMemory(&MappingInfo);
        
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbAllocPhysicalMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_ALLOC_PHYSICAL_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_ALLOC_PHYSICAL_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_ALLOC_PHYSICAL_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_ALLOC_PHYSICAL_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Input->Size || !Output) return STATUS_INVALID_PARAMETER;

        Output->Address = reinterpret_cast<WdkTypes::PVOID>(PhysicalMemory::AllocPhysicalMemorySpecifyCache(
            reinterpret_cast<PVOID64>(Input->LowestAcceptableAddress),
            reinterpret_cast<PVOID64>(Input->LowestAcceptableAddress),
            reinterpret_cast<PVOID64>(Input->LowestAcceptableAddress),
            Input->Size,
            static_cast<MEMORY_CACHING_TYPE>(Input->CachingType)
        ));

        *ResponseLength = sizeof(*Output);
        return Output->Address ? STATUS_SUCCESS : STATUS_MEMORY_NOT_ALLOCATED;
    }

    NTSTATUS FASTCALL KbFreePhysicalMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_FREE_PHYSICAL_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FREE_PHYSICAL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Address) return STATUS_INVALID_PARAMETER;

        PhysicalMemory::FreePhysicalMemory(reinterpret_cast<PVOID>(Input->Address));
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbMapPhysicalMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_MAP_PHYSICAL_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_MAP_PHYSICAL_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_MAP_PHYSICAL_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_MAP_PHYSICAL_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Input->Size || !Output) return STATUS_INVALID_PARAMETER;

        Output->VirtualAddress = reinterpret_cast<WdkTypes::PVOID>(
            PhysicalMemory::MapPhysicalMemory(
                reinterpret_cast<PVOID64>(Input->PhysicalAddress),
                Input->Size,
                static_cast<MEMORY_CACHING_TYPE>(Input->CachingType)
            )
        );

        *ResponseLength = RequestInfo->OutputBufferSize;

        return Output->VirtualAddress
            ? STATUS_SUCCESS
            : STATUS_GENERIC_NOT_MAPPED;
    }

    NTSTATUS FASTCALL KbUnmapPhysicalMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNMAP_PHYSICAL_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_MAP_PHYSICAL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->PhysicalAddress || !Input->Size) return STATUS_INVALID_PARAMETER;

        PhysicalMemory::UnmapPhysicalMemory(
            reinterpret_cast<PVOID64>(Input->PhysicalAddress),
            Input->Size
        );

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbGetPhysicalAddress(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_PHYSICAL_ADDRESS_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_PHYSICAL_ADDRESS_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_PHYSICAL_ADDRESS_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_PHYSICAL_ADDRESS_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        Output->PhysicalAddress = reinterpret_cast<WdkTypes::PVOID>(
            PhysicalMemory::GetPhysicalAddress(
                reinterpret_cast<PVOID>(Input->VirtualAddress),
                reinterpret_cast<PEPROCESS>(Input->Process)
            )
        );

        *ResponseLength = RequestInfo->OutputBufferSize;

        return Output->PhysicalAddress
            ? STATUS_SUCCESS
            : STATUS_UNSUCCESSFUL;
    }

    NTSTATUS FASTCALL KbGetVirtualForPhysical(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_VIRTUAL_FOR_PHYSICAL_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_VIRTUAL_FOR_PHYSICAL_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_VIRTUAL_FOR_PHYSICAL_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_VIRTUAL_FOR_PHYSICAL_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        Output->VirtualAddress = reinterpret_cast<WdkTypes::PVOID>(
            PhysicalMemory::GetVirtualForPhysical(reinterpret_cast<PVOID64>(Input->PhysicalAddress))
        );

        *ResponseLength = sizeof(*Output);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbReadPhysicalMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        auto Input = static_cast<PKB_READ_WRITE_PHYSICAL_MEMORY_IN>(RequestInfo->InputBuffer);
        
        if (RequestInfo->InputBufferSize != sizeof(KB_READ_WRITE_PHYSICAL_MEMORY_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!Input || !Input->Buffer || !Input->Size) return STATUS_INVALID_PARAMETER;

        return PhysicalMemory::ReadPhysicalMemory(
            reinterpret_cast<PVOID64>(Input->PhysicalAddress),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size,
            static_cast<MEMORY_CACHING_TYPE>(Input->CachingType)
        ) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    NTSTATUS FASTCALL KbWritePhysicalMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize < sizeof(KB_READ_WRITE_PHYSICAL_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_READ_WRITE_PHYSICAL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Buffer || !Input->Size) return STATUS_INVALID_PARAMETER;

        return PhysicalMemory::WritePhysicalMemory(
            reinterpret_cast<PVOID64>(Input->PhysicalAddress),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size,
            static_cast<MEMORY_CACHING_TYPE>(Input->CachingType)
        ) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    NTSTATUS FASTCALL KbReadDmiMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (RequestInfo->OutputBufferSize != sizeof(KB_READ_DMI_MEMORY_OUT))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Output = static_cast<PKB_READ_DMI_MEMORY_OUT>(RequestInfo->OutputBuffer);
        if (!Output) return STATUS_INVALID_PARAMETER;

        BOOLEAN Status = PhysicalMemory::ReadDmiMemory(
            reinterpret_cast<PVOID>(Output->DmiBuffer),
            DmiSize
        );

        if (!Status) return STATUS_UNSUCCESSFUL;

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbGetEprocess(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_EPROCESS_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_EPROCESS_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer)
            return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_GET_EPROCESS_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_EPROCESS_OUT>(RequestInfo->OutputBuffer);

        Output->Process = reinterpret_cast<WdkTypes::PEPROCESS>(
            Processes::Descriptors::GetEPROCESS(reinterpret_cast<HANDLE>(Input->ProcessId))    
        );

        *ResponseLength = RequestInfo->OutputBufferSize;
        return Output->Process ? STATUS_SUCCESS : STATUS_NOT_FOUND;
    }

    NTSTATUS FASTCALL KbGetEthread(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_ETHREAD_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_ETHREAD_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer)
            return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_GET_ETHREAD_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_ETHREAD_OUT>(RequestInfo->OutputBuffer);

        Output->Thread = reinterpret_cast<WdkTypes::PEPROCESS>(
            Processes::Descriptors::GetETHREAD(reinterpret_cast<HANDLE>(Input->ThreadId))    
        );

        *ResponseLength = RequestInfo->OutputBufferSize;
        return Output->Thread ? STATUS_SUCCESS : STATUS_NOT_FOUND;        
    }

    NTSTATUS FASTCALL KbOpenProcess(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_OPEN_PROCESS_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_OPEN_PROCESS_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer)
            return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_OPEN_PROCESS_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_OPEN_PROCESS_OUT>(RequestInfo->OutputBuffer);

        HANDLE hProcess = NULL;
        NTSTATUS Status = Processes::Descriptors::OpenProcess(
            reinterpret_cast<HANDLE>(Input->ProcessId),
            &hProcess,
            Input->Access,
            Input->Attributes
        );

        if (!NT_SUCCESS(Status)) return Status;

        Output->hProcess = reinterpret_cast<WdkTypes::HANDLE>(hProcess);
        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbOpenProcessByPointer(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_OPEN_PROCESS_BY_POINTER_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_OPEN_PROCESS_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer)
            return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_OPEN_PROCESS_BY_POINTER_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_OPEN_PROCESS_OUT>(RequestInfo->OutputBuffer);

        HANDLE hProcess = NULL;
        NTSTATUS Status = Processes::Descriptors::OpenProcessByPointer(
            reinterpret_cast<PEPROCESS>(Input->Process),
            &hProcess,
            Input->Access,
            Input->Attributes,
            static_cast<KPROCESSOR_MODE>(Input->ProcessorMode)
        );

        if (!NT_SUCCESS(Status)) return Status;

        Output->hProcess = reinterpret_cast<WdkTypes::HANDLE>(hProcess);
        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbOpenThread(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_OPEN_THREAD_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_OPEN_THREAD_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer)
            return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_OPEN_THREAD_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_OPEN_THREAD_OUT>(RequestInfo->OutputBuffer);

        HANDLE hThread = NULL;
        NTSTATUS Status = Processes::Descriptors::OpenThread(
            reinterpret_cast<HANDLE>(Input->ThreadId),
            &hThread,
            Input->Access,
            Input->Attributes
        );

        if (!NT_SUCCESS(Status)) return Status;

        Output->hThread = reinterpret_cast<WdkTypes::HANDLE>(hThread);
        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbOpenThreadByPointer(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_OPEN_THREAD_BY_POINTER_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_OPEN_THREAD_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer || !RequestInfo->OutputBuffer)
            return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_OPEN_THREAD_BY_POINTER_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_OPEN_THREAD_OUT>(RequestInfo->OutputBuffer);

        HANDLE hThread = NULL;
        NTSTATUS Status = Processes::Descriptors::OpenThreadByPointer(
            reinterpret_cast<PETHREAD>(Input->Thread),
            &hThread,
            Input->Access,
            Input->Attributes,
            static_cast<KPROCESSOR_MODE>(Input->ProcessorMode)
        );

        if (!NT_SUCCESS(Status)) return Status;

        Output->hThread = reinterpret_cast<WdkTypes::HANDLE>(hThread);
        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbDereferenceObject(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_DEREFERENCE_OBJECT_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_DEREFERENCE_OBJECT_IN>(RequestInfo->InputBuffer);

        ObDereferenceObject(reinterpret_cast<PVOID>(Input->Object));
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbCloseHandle(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_CLOSE_HANDLE_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_CLOSE_HANDLE_IN>(RequestInfo->InputBuffer);

        return ZwClose(reinterpret_cast<HANDLE>(Input->Handle));        
    }

    NTSTATUS FASTCALL KbQueryInformationProcess(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_QUERY_INFORMATION_PROCESS_THREAD_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_QUERY_INFORMATION_PROCESS_THREAD_IN>(RequestInfo->InputBuffer);

        return Processes::Information::QueryInformationProcess(
            reinterpret_cast<HANDLE>(Input->Handle),
            static_cast<PROCESSINFOCLASS>(Input->InfoClass),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size,
            reinterpret_cast<PULONG>(Input->ReturnLength)
        );
    }

    NTSTATUS FASTCALL KbSetInformationProcess(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_SET_INFORMATION_PROCESS_THREAD_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_SET_INFORMATION_PROCESS_THREAD_IN>(RequestInfo->InputBuffer);

        return Processes::Information::SetInformationProcess(
            reinterpret_cast<HANDLE>(Input->Handle),
            static_cast<PROCESSINFOCLASS>(Input->InfoClass),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size
        );
    }

    NTSTATUS FASTCALL KbQueryInformationThread(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_QUERY_INFORMATION_PROCESS_THREAD_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_QUERY_INFORMATION_PROCESS_THREAD_IN>(RequestInfo->InputBuffer);

        return Processes::Threads::QueryInformationThread(
            reinterpret_cast<HANDLE>(Input->Handle),
            static_cast<THREADINFOCLASS>(Input->InfoClass),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size,
            reinterpret_cast<PULONG>(Input->ReturnLength)
        );
    }

    NTSTATUS FASTCALL KbSetInformationThread(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_SET_INFORMATION_PROCESS_THREAD_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        if (!RequestInfo->InputBuffer) return STATUS_INVALID_PARAMETER;

        auto Input = static_cast<PKB_SET_INFORMATION_PROCESS_THREAD_IN>(RequestInfo->InputBuffer);

        return Processes::Threads::SetInformationThread(
            reinterpret_cast<HANDLE>(Input->Handle),
            static_cast<THREADINFOCLASS>(Input->InfoClass),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size
        );
    }

    NTSTATUS FASTCALL KbAllocUserMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_ALLOC_USER_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_ALLOC_USER_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_ALLOC_USER_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_ALLOC_USER_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        HANDLE hProcess = ZwCurrentProcess();
        NTSTATUS Status = Input->ProcessId ? Processes::Descriptors::OpenProcess(
            reinterpret_cast<HANDLE>(Input->ProcessId),
            &hProcess
        ) : STATUS_SUCCESS;

        if (!NT_SUCCESS(Status)) return STATUS_UNSUCCESSFUL;

        PVOID BaseAddress = NULL;
        Status = Processes::MemoryManagement::AllocateVirtualMemory(
            hProcess,
            Input->Size,
            Input->Protect,
            &BaseAddress
        );

        if (hProcess && hProcess != ZwCurrentProcess()) ZwClose(hProcess);

        if (NT_SUCCESS(Status)) {
            Output->BaseAddress = reinterpret_cast<WdkTypes::PVOID>(BaseAddress);
            *ResponseLength = RequestInfo->OutputBufferSize;
        }

        return Status;
    }

    NTSTATUS FASTCALL KbFreeUserMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_FREE_USER_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FREE_USER_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        HANDLE hProcess = ZwCurrentProcess();
        NTSTATUS Status = Input->ProcessId ? Processes::Descriptors::OpenProcess(
            reinterpret_cast<HANDLE>(Input->ProcessId),
            &hProcess
        ) : STATUS_SUCCESS;

        if (!NT_SUCCESS(Status)) return STATUS_UNSUCCESSFUL;

        Status = Processes::MemoryManagement::FreeVirtualMemory(
            hProcess,
            reinterpret_cast<PVOID>(Input->BaseAddress)
        );

        if (hProcess && hProcess != ZwCurrentProcess()) ZwClose(hProcess);

        return Status;
    }

    NTSTATUS FASTCALL KbSecureVirtualMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_SECURE_VIRTUAL_MEMORY_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_SECURE_VIRTUAL_MEMORY_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_SECURE_VIRTUAL_MEMORY_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_SECURE_VIRTUAL_MEMORY_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        if (!Input->ProcessId || !Input->BaseAddress || !Input->Size)
            return STATUS_INVALID_PARAMETER;

        if (AddressRange::IsKernelAddress(reinterpret_cast<PVOID>(Input->BaseAddress)))
            return STATUS_INVALID_ADDRESS;

        HANDLE SecureHandle = NULL;
        BOOLEAN Status = FALSE;
        if (reinterpret_cast<HANDLE>(Input->ProcessId) == PsGetCurrentProcessId()) {
            Status = VirtualMemory::SecureMemory(
                reinterpret_cast<PVOID>(Input->BaseAddress),
                Input->Size,
                Input->ProtectRights,
                &SecureHandle
            );
        } else {
            PEPROCESS Process = Processes::Descriptors::GetEPROCESS(reinterpret_cast<HANDLE>(Input->ProcessId));
            if (!Process) return STATUS_NOT_FOUND;
            Status = VirtualMemory::SecureProcessMemory(
                Process,
                reinterpret_cast<PVOID>(Input->BaseAddress),
                Input->Size,
                Input->ProtectRights,
                &SecureHandle
            );
            ObDereferenceObject(Process);
        }

        if (!Status || !SecureHandle) return STATUS_UNSUCCESSFUL;

        *ResponseLength = RequestInfo->OutputBufferSize;
        Output->SecureHandle = reinterpret_cast<WdkTypes::HANDLE>(SecureHandle);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbUnsecureVirtualMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNSECURE_VIRTUAL_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_UNSECURE_VIRTUAL_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->ProcessId || !Input->SecureHandle) return STATUS_INVALID_PARAMETER;

        if (reinterpret_cast<HANDLE>(Input->ProcessId) == PsGetCurrentProcessId()) {
            VirtualMemory::UnsecureMemory(reinterpret_cast<HANDLE>(Input->SecureHandle));
        } else {
            PEPROCESS Process = Processes::Descriptors::GetEPROCESS(reinterpret_cast<HANDLE>(Input->ProcessId));
            if (!Process) return STATUS_NOT_FOUND;
            VirtualMemory::UnsecureProcessMemory(
                Process,
                reinterpret_cast<HANDLE>(Input->SecureHandle)
            );
            ObDereferenceObject(Process);
        }

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbReadProcessMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_READ_PROCESS_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_READ_PROCESS_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        HANDLE ProcessId = Input->ProcessId ? reinterpret_cast<HANDLE>(Input->ProcessId) : PsGetCurrentProcessId();
        PEPROCESS Process = Processes::Descriptors::GetEPROCESS(ProcessId);
        if (!Process) return STATUS_UNSUCCESSFUL;

        NTSTATUS Status = Processes::MemoryManagement::ReadProcessMemory(
            Process,
            reinterpret_cast<PVOID>(Input->BaseAddress),
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size
        );

        ObDereferenceObject(Process);

        return Status;
    }

    NTSTATUS FASTCALL KbWriteProcessMemory(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_WRITE_PROCESS_MEMORY_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_WRITE_PROCESS_MEMORY_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        HANDLE ProcessId = Input->ProcessId ? reinterpret_cast<HANDLE>(Input->ProcessId) : PsGetCurrentProcessId();
        PEPROCESS Process = Processes::Descriptors::GetEPROCESS(ProcessId);
        if (!Process) return STATUS_UNSUCCESSFUL;

        PVOID Address = reinterpret_cast<PVOID>(Input->BaseAddress);
        SIZE_T Size = Input->Size;
        if (Input->PerformCopyOnWrite) {
            using namespace Pte;
            PVOID PageCounter = Address;
            do {   
                ULONG PageSize = 0;
                BOOLEAN Status = TriggerCopyOnWrite(Process, PageCounter, &PageSize);
                if (!Status || !PageSize) {
                    ObDereferenceObject(Process);
                    return STATUS_PARTIAL_COPY;
                }
                PageCounter = reinterpret_cast<PVOID>(
                    reinterpret_cast<SIZE_T>(ALIGN_DOWN_POINTER_BY(PageCounter, PageSize)) + PageSize
                );
            } while (PageCounter < reinterpret_cast<PVOID>(reinterpret_cast<SIZE_T>(Address) + Size));
        }

        NTSTATUS Status = Processes::MemoryManagement::WriteProcessMemory(
            Process,
            Address,
            reinterpret_cast<PVOID>(Input->Buffer),
            Input->Size
        );

        ObDereferenceObject(Process);

        return Status; 
    }

    NTSTATUS FASTCALL KbTriggerCopyOnWrite(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_TRIGGER_COPY_ON_WRITE_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_TRIGGER_COPY_ON_WRITE_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        HANDLE ProcessId = Input->ProcessId ? reinterpret_cast<HANDLE>(Input->ProcessId) : PsGetCurrentProcessId();
        PEPROCESS Process = Processes::Descriptors::GetEPROCESS(ProcessId);
        if (!Process) return STATUS_UNSUCCESSFUL;

        BOOLEAN Status = Pte::TriggerCopyOnWrite(Process, reinterpret_cast<PVOID>(Input->PageVirtualAddress));

        ObDereferenceObject(Process);

        return Status ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    NTSTATUS FASTCALL KbSuspendProcess(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {    
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_SUSPEND_RESUME_PROCESS_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_SUSPEND_RESUME_PROCESS_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        PEPROCESS Process = Processes::Descriptors::GetEPROCESS(
            reinterpret_cast<HANDLE>(Input->ProcessId)
        );

        if (!Process) return STATUS_UNSUCCESSFUL;
        NTSTATUS Status = Processes::Threads::SuspendProcess(Process);
        ObDereferenceObject(Process);

        return Status;
    }

    NTSTATUS FASTCALL KbResumeProcess(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {    
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_SUSPEND_RESUME_PROCESS_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_SUSPEND_RESUME_PROCESS_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        PEPROCESS Process = Processes::Descriptors::GetEPROCESS(
            reinterpret_cast<HANDLE>(Input->ProcessId)
        );

        if (!Process) return STATUS_UNSUCCESSFUL;
        NTSTATUS Status = Processes::Threads::ResumeProcess(Process);
        ObDereferenceObject(Process);

        return Status;
    }

    NTSTATUS FASTCALL KbGetThreadContext(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_GET_SET_THREAD_CONTEXT_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_SET_THREAD_CONTEXT_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Context) return STATUS_INVALID_PARAMETER;

        if (Input->ContextSize != sizeof(CONTEXT)) return STATUS_INFO_LENGTH_MISMATCH;

        PETHREAD Thread = Processes::Descriptors::GetETHREAD(reinterpret_cast<HANDLE>(Input->ThreadId));
        if (!Thread) return STATUS_NOT_FOUND;

        PCONTEXT UserContext = reinterpret_cast<PCONTEXT>(Input->Context);
        HANDLE SecureHandle = NULL;
        if (!VirtualMemory::SecureMemory(UserContext, sizeof(CONTEXT), PAGE_READWRITE, &SecureHandle)) {
            ObDereferenceObject(Thread);
            return STATUS_NOT_LOCKED;
        }

        NTSTATUS Status = STATUS_SUCCESS;
        switch (Input->ProcessorMode) {
        case KernelMode: {
            PCONTEXT Context = static_cast<PCONTEXT>(VirtualMemory::AllocFromPool(sizeof(CONTEXT)));
            if (Context) {
                Context->ContextFlags = UserContext->ContextFlags;
                Status = Processes::Threads::GetContextThread(Thread, Context, KernelMode);
                if (NT_SUCCESS(Status)) {
                    __try {
                        RtlCopyMemory(UserContext, Context, sizeof(CONTEXT));
                        Status = STATUS_SUCCESS;
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
                VirtualMemory::FreePoolMemory(Context);
            } else {
                Status = STATUS_MEMORY_NOT_ALLOCATED;
            }
            break;
        }
        case UserMode: {
            Status = Processes::Threads::GetContextThread(Thread, UserContext, UserMode);
            break;
        }
        }

        VirtualMemory::UnsecureMemory(SecureHandle);
        ObDereferenceObject(Thread);

        return Status;
    }

    NTSTATUS FASTCALL KbSetThreadContext(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_GET_SET_THREAD_CONTEXT_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_SET_THREAD_CONTEXT_IN>(RequestInfo->InputBuffer);
        if (!Input || !Input->Context) return STATUS_INVALID_PARAMETER;

        if (Input->ContextSize != sizeof(CONTEXT)) return STATUS_INFO_LENGTH_MISMATCH;

        PETHREAD Thread = Processes::Descriptors::GetETHREAD(reinterpret_cast<HANDLE>(Input->ThreadId));
        if (!Thread) return STATUS_NOT_FOUND;

        PCONTEXT UserContext = reinterpret_cast<PCONTEXT>(Input->Context);
        HANDLE SecureHandle = NULL;
        if (!VirtualMemory::SecureMemory(UserContext, sizeof(CONTEXT), PAGE_READWRITE, &SecureHandle)) {
            ObDereferenceObject(Thread);
            return STATUS_NOT_LOCKED;
        }

        NTSTATUS Status = STATUS_SUCCESS;
        switch (Input->ProcessorMode) {
        case KernelMode: {
            PCONTEXT Context = static_cast<PCONTEXT>(VirtualMemory::AllocFromPool(sizeof(CONTEXT)));
            if (Context) {
                __try {
                    RtlCopyMemory(Context, UserContext, sizeof(CONTEXT));
                    Status = Processes::Threads::SetContextThread(Thread, Context, KernelMode);
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = STATUS_UNSUCCESSFUL;
                }
                VirtualMemory::FreePoolMemory(Context);
            } else {
                Status = STATUS_MEMORY_NOT_ALLOCATED;
            }
            break;
        }
        case UserMode: {
            Status = Processes::Threads::SetContextThread(Thread, UserContext, UserMode);
            break;
        }
        }

        VirtualMemory::UnsecureMemory(SecureHandle);
        ObDereferenceObject(Thread);

        return Status;
    }

    NTSTATUS FASTCALL KbCreateUserThread(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_CREATE_USER_THREAD_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_CREATE_USER_SYSTEM_THREAD_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_CREATE_USER_THREAD_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_CREATE_USER_SYSTEM_THREAD_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        HANDLE hProcess;
        NTSTATUS Status = Processes::Descriptors::OpenProcess(
            reinterpret_cast<HANDLE>(Input->ProcessId),
            &hProcess
        );

        if (!NT_SUCCESS(Status)) return STATUS_NOT_FOUND;

        HANDLE hThread = NULL;
        CLIENT_ID ClientId = {};
        Status = Processes::Threads::CreateUserThread(
            hProcess,
            reinterpret_cast<Processes::Threads::_UserThreadRoutine>(Input->ThreadRoutine),
            reinterpret_cast<PVOID>(Input->Argument),
            Input->CreateSuspended,
            &hThread,
            &ClientId
        );

        if (NT_SUCCESS(Status)) {
            Output->hThread = reinterpret_cast<WdkTypes::HANDLE>(hThread);
            Output->ClientId.ProcessId = reinterpret_cast<UINT64>(ClientId.UniqueProcess);
            Output->ClientId.ThreadId  = reinterpret_cast<UINT64>(ClientId.UniqueThread);
            *ResponseLength = RequestInfo->OutputBufferSize;
        }

        ZwClose(hProcess);

        return Status;
    }

    NTSTATUS FASTCALL KbCreateSystemThread(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_CREATE_SYSTEM_THREAD_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_CREATE_USER_SYSTEM_THREAD_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_CREATE_SYSTEM_THREAD_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_CREATE_USER_SYSTEM_THREAD_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        NTSTATUS Status = STATUS_SUCCESS;
        HANDLE hProcess = NULL;
        if (Input->AssociatedProcessId && Input->AssociatedProcessId != 4) {
            // Open process if process was specified and PID != System PID:
            Status = Processes::Descriptors::OpenProcess(
                reinterpret_cast<HANDLE>(Input->AssociatedProcessId),
                &hProcess
            );
            if (!NT_SUCCESS(Status)) return STATUS_NOT_FOUND;
        }

        using ThreadParams = struct {
            PVOID ThreadRoutine;
            PVOID Argument;
            KEVENT Event;
        };
        ThreadParams Params = {};
        Params.ThreadRoutine = reinterpret_cast<PVOID>(Input->ThreadRoutine);
        Params.Argument = reinterpret_cast<PVOID>(Input->Argument);
        KeInitializeEvent(&Params.Event, NotificationEvent, FALSE);

        HANDLE hThread = NULL;
        CLIENT_ID ClientId = {};
        Status = Processes::Threads::CreateSystemThread(
            hProcess,
            [](PVOID Argument) -> VOID {
                auto Params = static_cast<ThreadParams*>(Argument);
                
                auto ThreadRoutine = static_cast<PKSTART_ROUTINE>(Params->ThreadRoutine);
                PVOID ThreadArgument = Params->Argument;
                KeSetEvent(&Params->Event, LOW_REALTIME_PRIORITY, FALSE);

                NTSTATUS Status = STATUS_SUCCESS;
                __try {
                    ThreadRoutine(ThreadArgument);
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = STATUS_UNSUCCESSFUL;
                }

                PsTerminateSystemThread(Status);
            },
            reinterpret_cast<PVOID>(&Params),
            &hThread,
            &ClientId
        );

        KeWaitForSingleObject(&Params.Event, UserRequest, KernelMode, FALSE, NULL);

        if (NT_SUCCESS(Status)) {
            Output->hThread = reinterpret_cast<WdkTypes::HANDLE>(hThread);
            Output->ClientId.ProcessId = reinterpret_cast<UINT64>(ClientId.UniqueProcess);
            Output->ClientId.ThreadId  = reinterpret_cast<UINT64>(ClientId.UniqueThread);
            *ResponseLength = RequestInfo->OutputBufferSize;
        }

        if (hProcess) ZwClose(hProcess);

        return Status;
    }

    NTSTATUS FASTCALL KbQueueUserApc(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_QUEUE_USER_APC_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_QUEUE_USER_APC_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        PETHREAD Thread = Processes::Descriptors::GetETHREAD(reinterpret_cast<HANDLE>(Input->ThreadId));
        if (!Thread) return STATUS_NOT_FOUND;

        NTSTATUS Status = Processes::Apc::QueueUserApc(
            Thread,
            reinterpret_cast<Processes::Apc::PKNORMAL_ROUTINE>(Input->ApcProc),
            reinterpret_cast<PVOID>(Input->Argument)
        );

        ObDereferenceObject(Thread);

        return Status;
    }

    NTSTATUS FASTCALL KbRaiseIopl(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::IOPL::RaiseIopl();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbResetIopl(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        IO::IOPL::ResetIopl();
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbGetProcessCr3Cr4(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_PROCESS_CR3_CR4_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_PROCESS_CR3_CR4_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_PROCESS_CR3_CR4_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_PROCESS_CR3_CR4_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output || !Input->ProcessId) return STATUS_INVALID_PARAMETER;

        PEPROCESS Process = Processes::Descriptors::GetEPROCESS(reinterpret_cast<HANDLE>(Input->ProcessId));
        if (!Process) return STATUS_NOT_FOUND;

        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        SIZE_T Cr3 = __readcr3();
        SIZE_T Cr4 = __readcr4();
        KeUnstackDetachProcess(&ApcState);

        ObDereferenceObject(Process);

        Output->Cr3 = Cr3;
        Output->Cr4 = Cr4;

        *ResponseLength = RequestInfo->OutputBufferSize;
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbCreateSection(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_CREATE_SECTION_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_CREATE_OPEN_SECTION_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_CREATE_SECTION_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_CREATE_OPEN_SECTION_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        HANDLE hSection = NULL;
        NTSTATUS Status = Sections::CreateSection(
            &hSection,
            reinterpret_cast<LPCWSTR>(Input->Name),
            Input->MaximumSize,
            Input->DesiredAccess,
            Input->SecObjFlags,
            Input->SecPageProtection,
            Input->AllocationAttributes,
            reinterpret_cast<HANDLE>(Input->hFile)
        );

        Output->hSection = reinterpret_cast<WdkTypes::HANDLE>(hSection);
        *ResponseLength = sizeof(*Output);
        return Status;
    }

    NTSTATUS FASTCALL KbOpenSection(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_OPEN_SECTION_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_CREATE_OPEN_SECTION_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_OPEN_SECTION_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_CREATE_OPEN_SECTION_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output || !Input->Name) return STATUS_INVALID_PARAMETER;

        HANDLE hSection = NULL;
        NTSTATUS Status = Sections::OpenSection(
            &hSection,
            reinterpret_cast<LPCWSTR>(Input->Name),
            Input->DesiredAccess,
            Input->SecObjFlags
        );

        Output->hSection = reinterpret_cast<WdkTypes::HANDLE>(hSection);
        *ResponseLength = sizeof(*Output);
        return Status;
    }

    NTSTATUS FASTCALL KbMapViewOfSection(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_MAP_VIEW_OF_SECTION_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_MAP_VIEW_OF_SECTION_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_MAP_VIEW_OF_SECTION_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_MAP_VIEW_OF_SECTION_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output || !Input->hSection) return STATUS_INVALID_PARAMETER;

        PVOID BaseAddress = reinterpret_cast<PVOID>(Input->BaseAddress);
        UINT64 SectionOffset = static_cast<UINT64>(Input->SectionOffset);
        SIZE_T ViewSize = static_cast<SIZE_T>(Input->ViewSize);
        NTSTATUS Status = Sections::MapViewOfSection(
            reinterpret_cast<HANDLE>(Input->hSection),
            reinterpret_cast<HANDLE>(Input->hProcess),
            &BaseAddress,
            static_cast<SIZE_T>(Input->CommitSize),
            &SectionOffset,
            &ViewSize,
            static_cast<SECTION_INHERIT>(Input->SectionInherit),
            Input->AllocationType,
            Input->Win32Protect
        );

        Output->BaseAddress = reinterpret_cast<WdkTypes::PVOID>(BaseAddress);
        Output->SectionOffset = SectionOffset;
        Output->ViewSize = ViewSize;
        *ResponseLength = sizeof(*Output);
        return Status;
    }

    NTSTATUS FASTCALL KbUnmapViewOfSection(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNMAP_VIEW_OF_SECTION_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_UNMAP_VIEW_OF_SECTION_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        return Sections::UnmapViewOfSection(
            reinterpret_cast<HANDLE>(Input->hProcess),
            reinterpret_cast<PVOID>(Input->BaseAddress)
        );
    }

    NTSTATUS FASTCALL KbVmmEnable(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        return Hypervisor::Virtualize() ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    NTSTATUS FASTCALL KbVmmDisable(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(RequestInfo);
        UNREFERENCED_PARAMETER(ResponseLength);
        return Hypervisor::Devirtualize() ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    NTSTATUS FASTCALL KbVmmInterceptPage(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_VMM_INTERCEPT_PAGE_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_VMM_INTERCEPT_PAGE_IN>(RequestInfo->InputBuffer);
        bool Status = Hypervisor::InterceptPage(
            Input->PhysicalAddress,
            Input->OnReadPhysicalAddress,
            Input->OnWritePhysicalAddress,
            Input->OnExecutePhysicalAddress,
            Input->OnExecuteReadPhysicalAddress,
            Input->OnExecuteWritePhysicalAddress
        );

        return Status ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
    }

    NTSTATUS FASTCALL KbVmmDeinterceptPage(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_VMM_DEINTERCEPT_PAGE_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_VMM_DEINTERCEPT_PAGE_IN>(RequestInfo->InputBuffer);
        bool Status = Hypervisor::DeinterceptPage(Input->PhysicalAddress);

        return Status ? STATUS_SUCCESS : STATUS_NOT_SUPPORTED;
    }

    NTSTATUS FASTCALL KbExecuteShellCode(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_EXECUTE_SHELL_CODE_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_EXECUTE_SHELL_CODE_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_EXECUTE_SHELL_CODE_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_EXECUTE_SHELL_CODE_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output) return STATUS_INVALID_PARAMETER;

        Output->Result = KernelShells::ExecuteShellCode(
            reinterpret_cast<KernelShells::_ShellCode>(Input->Address),
            reinterpret_cast<PVOID>(Input->Argument)
        );

        *ResponseLength = sizeof(KB_EXECUTE_SHELL_CODE_OUT);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbGetKernelProcAddress(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_KERNEL_PROC_ADDRESS_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_KERNEL_PROC_ADDRESS_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_KERNEL_PROC_ADDRESS_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_KERNEL_PROC_ADDRESS_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output || !Input->RoutineName || !Input->SizeOfBufferInBytes)
            return STATUS_INVALID_PARAMETER;

        HANDLE hSecure = NULL;
        BOOLEAN SecureStatus = VirtualMemory::SecureMemory(
            reinterpret_cast<PVOID>(Input->RoutineName),
            Input->SizeOfBufferInBytes,
            PAGE_READONLY,
            &hSecure
        );

        if (!SecureStatus) return STATUS_UNSUCCESSFUL;

        LPWSTR RoutineNameKernelBuffer = 
            VirtualMemory::AllocWideString(Input->SizeOfBufferInBytes / sizeof(WCHAR));

        if (!RoutineNameKernelBuffer) {
            VirtualMemory::UnsecureMemory(hSecure);
            return STATUS_MEMORY_NOT_ALLOCATED;
        }

        NTSTATUS Status = STATUS_SUCCESS;
        PVOID KernelAddress = NULL;
        __try {
            RtlCopyMemory(RoutineNameKernelBuffer, reinterpret_cast<PVOID>(Input->RoutineName), Input->SizeOfBufferInBytes);
            KernelAddress = Importer::GetKernelProcAddress(RoutineNameKernelBuffer);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_UNSUCCESSFUL;
        }

        VirtualMemory::FreePoolMemory(RoutineNameKernelBuffer);
        VirtualMemory::UnsecureMemory(hSecure);

        if (NT_SUCCESS(Status)) {
            Output->Address = reinterpret_cast<WdkTypes::PVOID>(KernelAddress);
            *ResponseLength = RequestInfo->OutputBufferSize;
        }

        return Status;
    }

    NTSTATUS FASTCALL KbStallExecutionProcessor(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_STALL_EXECUTION_PROCESSOR_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_STALL_EXECUTION_PROCESSOR_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        KeStallExecutionProcessor(Input->Microseconds);

        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbBugCheck(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_BUG_CHECK_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_BUG_CHECK_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        KeBugCheck(Input->Status);
    }

    NTSTATUS FASTCALL KbCreateDriver(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_CREATE_DRIVER_IN))
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_CREATE_DRIVER_IN>(RequestInfo->InputBuffer);
        if (!Input) return STATUS_INVALID_PARAMETER;

        using _DriverEntry = NTSTATUS(NTAPI*)(
            _In_ PDRIVER_OBJECT DriverObject,
            _In_ PUNICODE_STRING RegistryPath
        );

        HANDLE hSecure = NULL;
        BOOLEAN SecureStatus = VirtualMemory::SecureMemory(
            reinterpret_cast<PVOID>(Input->DriverName),
            Input->DriverNameSizeInBytes,
            PAGE_READONLY,
            &hSecure
        );

        if (!SecureStatus) return STATUS_UNSUCCESSFUL;

        LPWSTR DriverNameKernelBuffer = 
            VirtualMemory::AllocWideString(Input->DriverNameSizeInBytes / sizeof(WCHAR));

        if (!DriverNameKernelBuffer) {
            VirtualMemory::UnsecureMemory(hSecure);
            return STATUS_MEMORY_NOT_ALLOCATED;
        }

        NTSTATUS Status = STATUS_SUCCESS;
        __try {
            RtlCopyMemory(DriverNameKernelBuffer, reinterpret_cast<PVOID>(Input->DriverName), Input->DriverNameSizeInBytes);
            
            using _IoCreateDriver = NTSTATUS(NTAPI*)(PUNICODE_STRING DriverName, _DriverEntry EntryPoint);
            
            using SystemThreadParams = struct {
                LPCWSTR Name;
                _DriverEntry DriverEntry;
                _IoCreateDriver IoCreateDriver;
                NTSTATUS Status;
                KEVENT Event;
            };

            SystemThreadParams Args;
            Args.Name = DriverNameKernelBuffer;
            Args.DriverEntry = reinterpret_cast<_DriverEntry>(Input->DriverEntry);
            Args.IoCreateDriver = static_cast<_IoCreateDriver>(Importer::GetKernelProcAddress(L"IoCreateDriver"));
            if (!Args.IoCreateDriver) {
                VirtualMemory::FreePoolMemory(DriverNameKernelBuffer);
                VirtualMemory::UnsecureMemory(hSecure);
                return STATUS_NOT_IMPLEMENTED;
            }

            KeInitializeEvent(&Args.Event, NotificationEvent, FALSE);

            HANDLE hThread = NULL;
            Processes::Threads::CreateSystemThread([](PVOID Argument) -> VOID {
                    auto Args = reinterpret_cast<SystemThreadParams*>(Argument);
                    UNICODE_STRING DriverName;
                    RtlInitUnicodeString(&DriverName, Args->Name);
                    __try {
                        Args->Status = Args->IoCreateDriver(&DriverName, Args->DriverEntry);
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Args->Status = STATUS_UNSUCCESSFUL;
                    }
                    KeSetEvent(&Args->Event, LOW_REALTIME_PRIORITY, FALSE);
                    PsTerminateSystemThread(Args->Status);
                }, 
                &Args,
                &hThread
            );

            // Waiting for system thread completes:
            KeWaitForSingleObject(&Args.Event, UserRequest, KernelMode, FALSE, NULL);
            ZwClose(hThread);

            Status = Args.Status;

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_UNSUCCESSFUL;
        }

        VirtualMemory::FreePoolMemory(DriverNameKernelBuffer);
        VirtualMemory::UnsecureMemory(hSecure);        

        return Status;
    }

    NTSTATUS FASTCALL KbLoadModule(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_LOAD_MODULE_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_LOAD_MODULE_IN>(RequestInfo->InputBuffer);
        
        if (!Input || !Input->hModule || !Input->ModuleName)
            return STATUS_INVALID_PARAMETER;

        LPCWSTR UserModuleName = reinterpret_cast<LPCWSTR>(Input->ModuleName);

        SIZE_T NameLength = WideString::Length(UserModuleName);
        if (!NameLength) return STATUS_INVALID_PARAMETER;

        HANDLE hSecure = NULL;
        BOOLEAN SecureStatus = VirtualMemory::SecureMemory(const_cast<LPWSTR>(UserModuleName), (NameLength + 1) * sizeof(WCHAR), PAGE_READONLY, &hSecure);
        if (!SecureStatus)
            return STATUS_UNSUCCESSFUL;

        NTSTATUS Status = LoadableModules::LoadModule(
            reinterpret_cast<PVOID>(Input->hModule),
            UserModuleName,
            reinterpret_cast<LoadableModules::_OnLoad>(Input->OnLoad),
            reinterpret_cast<LoadableModules::_OnUnload>(Input->OnUnload),
            reinterpret_cast<LoadableModules::_OnDeviceControl>(Input->OnDeviceControl)
        );

        VirtualMemory::UnsecureMemory(hSecure);

        return Status;
    }

    NTSTATUS FASTCALL KbGetModuleHandle(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_GET_MODULE_HANDLE_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_GET_MODULE_HANDLE_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_GET_MODULE_HANDLE_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_GET_MODULE_HANDLE_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output || !Input->ModuleName)
            return STATUS_INVALID_PARAMETER;

        LPCWSTR UserModuleName = reinterpret_cast<LPCWSTR>(Input->ModuleName);

        SIZE_T NameLength = WideString::Length(UserModuleName);
        if (!NameLength) return STATUS_INVALID_PARAMETER;

        HANDLE hSecure = NULL;
        BOOLEAN SecureStatus = VirtualMemory::SecureMemory(const_cast<LPWSTR>(UserModuleName), (NameLength + 1) * sizeof(WCHAR), PAGE_READONLY, &hSecure);
        if (!SecureStatus)
            return STATUS_UNSUCCESSFUL;

        Output->hModule = reinterpret_cast<WdkTypes::PVOID>(LoadableModules::GetModuleHandle(UserModuleName));

        VirtualMemory::UnsecureMemory(hSecure);

        *ResponseLength = sizeof(*Output);
        return STATUS_SUCCESS;
    }

    NTSTATUS FASTCALL KbCallModule(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_CALL_MODULE_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_CALL_MODULE_IN>(RequestInfo->InputBuffer);
        
        if (!Input || !Input->hModule)
            return STATUS_INVALID_PARAMETER;

        return LoadableModules::CallModule(
            reinterpret_cast<PVOID>(Input->hModule),
            Input->CtlCode,
            reinterpret_cast<PVOID>(Input->Argument)
        );
    }

    NTSTATUS FASTCALL KbUnloadModule(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        UNREFERENCED_PARAMETER(ResponseLength);

        if (RequestInfo->InputBufferSize != sizeof(KB_UNLOAD_MODULE_IN)) 
            return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_UNLOAD_MODULE_IN>(RequestInfo->InputBuffer);
        
        if (!Input || !Input->hModule)
            return STATUS_INVALID_PARAMETER;

        return LoadableModules::UnloadModule(reinterpret_cast<PVOID>(Input->hModule));
    }

    NTSTATUS FASTCALL KbFindSignature(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
    {
        if (
            RequestInfo->InputBufferSize != sizeof(KB_FIND_SIGNATURE_IN) || 
            RequestInfo->OutputBufferSize != sizeof(KB_FIND_SIGNATURE_OUT)
        ) return STATUS_INFO_LENGTH_MISMATCH;

        auto Input = static_cast<PKB_FIND_SIGNATURE_IN>(RequestInfo->InputBuffer);
        auto Output = static_cast<PKB_FIND_SIGNATURE_OUT>(RequestInfo->OutputBuffer);

        if (!Input || !Output || !Input->Memory || !Input->Signature || !Input->Mask)
            return STATUS_INVALID_PARAMETER;

        SIZE_T SigLength = strlen(reinterpret_cast<char*>(Input->Mask));
        LPSTR MaskBuffer = VirtualMemory::AllocAnsiString(SigLength);
        LPSTR SigBuffer = VirtualMemory::AllocAnsiString(SigLength);
        if (!MaskBuffer || !SigBuffer) {
            if (MaskBuffer) VirtualMemory::FreePoolMemory(MaskBuffer);
            if (SigBuffer) VirtualMemory::FreePoolMemory(SigBuffer);
            return STATUS_MEMORY_NOT_ALLOCATED;
        }

        __try {
            RtlCopyMemory(MaskBuffer, reinterpret_cast<char*>(Input->Mask), SigLength);
            RtlCopyMemory(SigBuffer, reinterpret_cast<char*>(Input->Signature), SigLength);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            if (MaskBuffer) VirtualMemory::FreePoolMemory(MaskBuffer);
            if (SigBuffer) VirtualMemory::FreePoolMemory(SigBuffer);
            return STATUS_UNSUCCESSFUL;
        }

        NTSTATUS Status = STATUS_SUCCESS;
        PVOID FoundAddress = NULL;
        PVOID Memory = reinterpret_cast<PVOID>(Input->Memory);
        SIZE_T Size = Input->Size;
        switch (AddressRange::IsUserAddress(Memory)) {
        case TRUE: {
            PEPROCESS CurrentProcess = PsGetCurrentProcess();
            PEPROCESS Process = NULL;
            if (Input->ProcessId != 0 && Input->ProcessId != reinterpret_cast<UINT64>(PsGetCurrentProcessId())) {
                Process = Processes::Descriptors::GetEPROCESS(reinterpret_cast<HANDLE>(Input->ProcessId));
                if (!Process) {
                    Status = STATUS_NOT_FOUND;
                    break;
                }
            }

            HANDLE hSecure = NULL;
            if (!VirtualMemory::SecureProcessMemory(Process ? Process : CurrentProcess, Memory, Size, PAGE_READONLY, &hSecure)) {
                if (Process) ObDereferenceObject(Process);
                Status = STATUS_NOT_LOCKED;
                break;
            }

            KAPC_STATE ApcState;
            __try {
                if (Process) KeStackAttachProcess(Process, &ApcState);
                FoundAddress = find_signature(Memory, Size, SigBuffer, MaskBuffer);
                Status = STATUS_SUCCESS;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = STATUS_UNSUCCESSFUL;
            }

            if (Process) KeUnstackDetachProcess(&ApcState);

            VirtualMemory::UnsecureProcessMemory(Process ? Process : CurrentProcess, hSecure);
            if (Process) ObDereferenceObject(Process);
            break;
        }
        case FALSE: {
            __try {
                FoundAddress = find_signature(Memory, Size, SigBuffer, MaskBuffer);
                Status = STATUS_SUCCESS;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = STATUS_UNSUCCESSFUL;
            }
            break;
        }
        }

        if (MaskBuffer) VirtualMemory::FreePoolMemory(MaskBuffer);
        if (SigBuffer) VirtualMemory::FreePoolMemory(SigBuffer);

        Output->Address = reinterpret_cast<WdkTypes::PVOID>(FoundAddress);
        *ResponseLength = sizeof(KB_FIND_SIGNATURE_OUT);
        return Status;
    }
}

NTSTATUS FASTCALL DispatchIOCTL(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength)
{
    using _CtlHandler = NTSTATUS(FASTCALL*)(IN PIOCTL_INFO, OUT PSIZE_T);
    static const _CtlHandler Handlers[] = {
        // Driver management:
        /* 00 */ KbGetDriverApiVersion,
        /* 01 */ KbGetHandlesCount,

        // Beeper:
        /* 02 */ KbSetBeeperRegime,
        /* 03 */ KbStartBeeper,
        /* 04 */ KbStopBeeper,
        /* 05 */ KbSetBeeperIn,
        /* 06 */ KbSetBeeperOut,
        /* 07 */ KbSetBeeperDivider,
        /* 08 */ KbSetBeeperFrequency,

        // IO-Ports:
        /* 09 */ KbReadPort,
        /* 10 */ KbReadPortString,
        /* 11 */ KbWritePort,
        /* 12 */ KbWritePortString,

        // Interrupts:
        /* 13 */ KbCli,
        /* 14 */ KbSti,
        /* 15 */ KbHlt,

        // MSR:
        /* 16 */ KbReadMsr,
        /* 17 */ KbWriteMsr,

        // CPUID:
        /* 18 */ KbCpuid,
        /* 19 */ KbCpuidEx,

        // TSC & PMC:
        /* 20 */ KbReadPmc,
        /* 21 */ KbReadTsc,
        /* 22 */ KbReadTscp,

        // Memory management:
        /* 23 */ KbAllocKernelMemory,
        /* 24 */ KbFreeKernelMemory,
        /* 25 */ KbAllocNonCachedMemory,
        /* 26 */ KbFreeNonCachedMemory,
        /* 27 */ KbCopyMoveMemory,
        /* 28 */ KbFillMemory,
        /* 29 */ KbEqualMemory,

        // Memory mappings:
        /* 30 */ KbAllocateMdl,
        /* 31 */ KbProbeAndLockPages,
        /* 32 */ KbMapMdl,
        /* 33 */ KbProtectMappedMemory,
        /* 34 */ KbUnmapMdl,
        /* 35 */ KbUnlockPages,
        /* 36 */ KbFreeMdl,
        /* 37 */ KbMapMemory,
        /* 38 */ KbUnmapMemory,

        // Physical memory:
        /* 39 */ KbAllocPhysicalMemory,
        /* 40 */ KbFreePhysicalMemory,
        /* 41 */ KbMapPhysicalMemory,
        /* 42 */ KbUnmapPhysicalMemory,
        /* 43 */ KbGetPhysicalAddress,
        /* 44 */ KbGetVirtualForPhysical,
        /* 45 */ KbReadPhysicalMemory,
        /* 46 */ KbWritePhysicalMemory,
        /* 47 */ KbReadDmiMemory,

        // Processes & Threads:
        /* 48 */ KbGetEprocess,
        /* 49 */ KbGetEthread,
        /* 50 */ KbOpenProcess,
        /* 51 */ KbOpenProcessByPointer,
        /* 52 */ KbOpenThread,
        /* 53 */ KbOpenThreadByPointer,
        /* 54 */ KbDereferenceObject,
        /* 55 */ KbCloseHandle,
        /* 56 */ KbQueryInformationProcess,
        /* 57 */ KbSetInformationProcess,
        /* 58 */ KbQueryInformationThread,
        /* 59 */ KbSetInformationThread,
        /* 60 */ KbAllocUserMemory,
        /* 61 */ KbFreeUserMemory,
        /* 62 */ KbSecureVirtualMemory,
        /* 63 */ KbUnsecureVirtualMemory,
        /* 64 */ KbReadProcessMemory,
        /* 65 */ KbWriteProcessMemory,
        /* 66 */ KbTriggerCopyOnWrite,
        /* 67 */ KbSuspendProcess,
        /* 68 */ KbResumeProcess,
        /* 69 */ KbGetThreadContext,
        /* 70 */ KbSetThreadContext,
        /* 71 */ KbCreateUserThread,
        /* 72 */ KbCreateSystemThread,
        /* 73 */ KbQueueUserApc,
        /* 74 */ KbRaiseIopl,
        /* 75 */ KbResetIopl,
        /* 76 */ KbGetProcessCr3Cr4,

        // Sections:
        /* 77 */ KbCreateSection,
        /* 78 */ KbOpenSection,
        /* 79 */ KbMapViewOfSection,
        /* 80 */ KbUnmapViewOfSection,

        // Loadable modules:
        /* 81 */ KbCreateDriver,
        /* 82 */ KbLoadModule,
        /* 83 */ KbGetModuleHandle,
        /* 84 */ KbCallModule,
        /* 85 */ KbUnloadModule,

        // Hypervisor:
        /* 86 */ KbVmmEnable,
        /* 87 */ KbVmmDisable,
        /* 88 */ KbVmmInterceptPage,
        /* 89 */ KbVmmDeinterceptPage,

        // Stuff u kn0w:
        /* 90 */ KbExecuteShellCode,
        /* 91 */ KbGetKernelProcAddress,
        /* 92 */ KbStallExecutionProcessor,
        /* 93 */ KbBugCheck,
        /* 94 */ KbFindSignature
    };

    USHORT Index = EXTRACT_CTL_CODE(RequestInfo->ControlCode) - CTL_BASE;
    return Index < sizeof(Handlers) / sizeof(Handlers[0])
        ? Handlers[Index](RequestInfo, ResponseLength)
        : STATUS_NOT_IMPLEMENTED;
}
```

`Kernel-Bridge/Kernel-Bridge/IOCTLHandlers.h`:

```h
#pragma once

typedef struct _IOCTL_INFO {
    PVOID InputBuffer;
    PVOID OutputBuffer;
    ULONG InputBufferSize;
    ULONG OutputBufferSize;
    ULONG ControlCode;
} IOCTL_INFO, *PIOCTL_INFO;

NTSTATUS FASTCALL DispatchIOCTL(IN PIOCTL_INFO RequestInfo, OUT PSIZE_T ResponseLength);
```

`Kernel-Bridge/Kernel-Bridge/IOCTLs.h`:

```h
#pragma once

#define IOCTL(Code, Method) (CTL_CODE(0x8000, (Code), Method, FILE_ANY_ACCESS))
#define EXTRACT_CTL_CODE(Ioctl)   ((unsigned short)(((Ioctl) & 0b0011111111111100) >> 2))
#define EXTRACT_CTL_METHOD(Ioctl) ((unsigned short)((Ioctl) & 0b11))

#define CTL_BASE (0x800)
```

`Kernel-Bridge/Kernel-Bridge/LoadableModules.cpp`:

```cpp
#include <fltKernel.h>
#include <stdarg.h>
#include <ntstrsafe.h>

#include "../API/Locks.h"
#include "../API/StringsAPI.h"
#include "../API/LinkedList.h"
#include "../API/MemoryUtils.h"

#include "LoadableModules.h"

//#pragma section(".storage",execute,nopage)
//
//static constexpr unsigned int STORAGE_SIZE = 640 * 1024;
//__declspec(allocate(".storage")) unsigned char Storage[STORAGE_SIZE] = {};

class ModulesStorage {
private:
    using MODULE_INFO = struct {
        WideString ModuleName;
        PVOID hModule;
        OPTIONAL LoadableModules::_OnUnload OnUnload;
        OPTIONAL LoadableModules::_OnDeviceControl OnDeviceControl;
        Atomic32 Refcount;
        PRKEVENT CompletionEvent;
        volatile bool Unloading;
    };

    FastMutex Lock;
    LinkedList<MODULE_INFO> Modules;

public:
    ModulesStorage() : Lock(), Modules() {}
    ~ModulesStorage() {
        Lock.Lock();
        if (Modules.IsEmpty()) {
            Lock.Unlock();
            return;
        }

        LinkedList<MODULE_INFO>::ListIterator it = Modules.begin();
        while (it != Modules.end()) {
            auto Entry = it.GetEntry();
            ++it;
            auto Module = Entry->GetValue();

            if (!Module->Unloading) {
                Module->Unloading = true;
                KeWaitForSingleObject(Module->CompletionEvent, Executive, KernelMode, FALSE, NULL);
                if (Module->OnUnload) Module->OnUnload();
                VirtualMemory::FreePoolMemory(Module->hModule);
                Modules.Remove(Entry);
            }
        }
        Lock.Unlock();
    }

    NTSTATUS Load(
        PVOID hModule,
        LPCWSTR ModuleName,
        OPTIONAL LoadableModules::_OnLoad OnLoad = NULL,
        OPTIONAL LoadableModules::_OnUnload OnUnload = NULL,
        OPTIONAL LoadableModules::_OnDeviceControl OnDeviceControl = NULL
    ) {
        if (!hModule || !ModuleName) return STATUS_INVALID_PARAMETER;

        WideString Name(ModuleName);
        Name.Trim().ToLowerCase();
        if (!Name.GetLength()) return STATUS_INVALID_PARAMETER;

        BOOLEAN AlreadyLoaded = FALSE;
        Lock.Lock();
        for (auto& Module : Modules) {
            AlreadyLoaded = Module.hModule == hModule || Module.ModuleName == Name;
            if (AlreadyLoaded) break;
        }
        Lock.Unlock();
        
        if (AlreadyLoaded) 
            return STATUS_ALREADY_COMPLETE;

        NTSTATUS Status = OnLoad ? OnLoad(hModule, ModuleName) : STATUS_SUCCESS;

        if (Status == STATUS_SUCCESS) {
            Lock.Lock();
            MODULE_INFO Module = {};
            Module.ModuleName = Name;
            Module.hModule = hModule;
            Module.OnUnload = OnUnload;
            Module.OnDeviceControl = OnDeviceControl;
            Module.CompletionEvent = new KEVENT;
            KeInitializeEvent(Module.CompletionEvent, NotificationEvent, TRUE);
            Modules.InsertTail(Module);
            Lock.Unlock();
        }

        return Status;
    }

    NTSTATUS Call(PVOID hModule, ULONG CtlCode, OPTIONAL PVOID Argument = NULL) {
        if (!hModule) return STATUS_INVALID_PARAMETER;

        NTSTATUS Status = STATUS_NOT_FOUND;

        MODULE_INFO* TargetModule = NULL;

        Lock.Lock();
        if (Modules.IsEmpty()) {
            Lock.Unlock();
            return STATUS_NOT_FOUND;
        }

        for (auto& Module : Modules) {
            if (Module.hModule != hModule) continue;

            if (Module.Unloading) {
                Status = STATUS_NOT_FOUND;
                break;
            }

            if (!Module.OnDeviceControl) {
                Status = STATUS_NOT_IMPLEMENTED;
                break;
            }

            // Referencing module:
            if (Module.Refcount.Get() == 0)
                KeClearEvent(Module.CompletionEvent);
            Module.Refcount++;

            TargetModule = &Module;
            break;
        }
        Lock.Unlock();

        if (!TargetModule) return Status;

        Status = TargetModule->OnDeviceControl(CtlCode, Argument);

        TargetModule->Refcount--;
        if (TargetModule->Refcount.Get() == 0)
            KeSetEvent(TargetModule->CompletionEvent, LOW_REALTIME_PRIORITY, FALSE);

        return Status;
    }

    NTSTATUS Unload(PVOID hModule) {
        if (!hModule) return STATUS_INVALID_PARAMETER;

        LinkedList<MODULE_INFO>::ListEntry* TargetEntry = NULL;
        
        Lock.Lock();
        if (Modules.IsEmpty()) {
            Lock.Unlock();
            return STATUS_NOT_FOUND;
        }

        LinkedList<MODULE_INFO>::ListIterator it = Modules.begin();
        while (it != Modules.end()) {
            auto Entry = it.GetEntry();
            ++it;
            auto Module = Entry->GetValue();

            if (Module->hModule != hModule) continue;
            if (Module->Unloading) break;

            Module->Unloading = true;
            TargetEntry = Entry;
            break;
        }
        Lock.Unlock();

        if (!TargetEntry) return STATUS_NOT_FOUND;

        MODULE_INFO* TargetModule = TargetEntry->GetValue();

        KeWaitForSingleObject(TargetModule->CompletionEvent, Executive, KernelMode, FALSE, NULL);
        if (TargetModule->OnUnload) TargetModule->OnUnload();

        Lock.Lock();
        Modules.Remove(TargetEntry);
        delete TargetModule->CompletionEvent;
        Lock.Unlock();
        
        VirtualMemory::FreePoolMemory(hModule);
        return STATUS_SUCCESS;
    }

    PVOID GetModuleHandle(LPCWSTR ModuleName) {
        WideString Name(ModuleName);
        Name.Trim().ToLowerCase();
        if (!Name.GetLength()) return NULL;

        PVOID hModule = NULL;
        Lock.Lock();
        for (auto& Module : Modules) {
            if (Module.ModuleName == Name) hModule = Module.hModule;
            if (hModule) break;
        }
        Lock.Unlock();
        return hModule;
    }
};

namespace LoadableModules {
    static ModulesStorage Modules;

    NTSTATUS LoadModule(
        PVOID hModule,
        LPCWSTR ModuleName,
        OPTIONAL _OnLoad OnLoad,
        OPTIONAL _OnUnload OnUnload,
        OPTIONAL _OnDeviceControl OnDeviceControl
    ) {
        return Modules.Load(hModule, ModuleName, OnLoad, OnUnload, OnDeviceControl);
    }

    NTSTATUS CallModule(PVOID hModule, ULONG CtlCode, OPTIONAL PVOID Argument) {
        return Modules.Call(hModule, CtlCode, Argument);
    }

    NTSTATUS UnloadModule(PVOID hModule) {
        return Modules.Unload(hModule);
    }

    PVOID GetModuleHandle(LPCWSTR ModuleName) {
        return Modules.GetModuleHandle(ModuleName);
    }
}
```

`Kernel-Bridge/Kernel-Bridge/LoadableModules.h`:

```h
#pragma once

namespace LoadableModules {
    using _OnLoad = NTSTATUS(NTAPI*)(PVOID hModule, LPCWSTR Name);
    using _OnUnload = NTSTATUS(NTAPI*)();
    using _OnDeviceControl = NTSTATUS(NTAPI*)(ULONG CtlCode, PVOID Argument);

    NTSTATUS LoadModule(
        PVOID hModule,
        LPCWSTR ModuleName,
        OPTIONAL _OnLoad OnLoad = NULL,
        OPTIONAL _OnUnload OnUnload = NULL,
        OPTIONAL _OnDeviceControl OnDeviceControl = NULL
    );

    NTSTATUS CallModule(PVOID hModule, ULONG CtlCode, OPTIONAL PVOID Argument = NULL);

    NTSTATUS UnloadModule(PVOID hModule);

    PVOID GetModuleHandle(LPCWSTR ModuleName);
}
```

`Kernel-Tests/Kernel-Tests.cpp`:

```cpp
#include "pch.h"

#include "WdkTypes.h"
#include "CtlTypes.h"
#include "User-Bridge.h"

#include "Kernel-Tests.h"

#include <intrin.h>

bool BeeperTest::RunTest() {
    using namespace IO::Beeper;
    KbSetBeeperRegime();
    KbSetBeeperFrequency(1000);
    KbStartBeeper();
    Sleep(500);
    KbStopBeeper();
    return true;
}

bool IoplTest::RunTest() {
    using namespace IO::Iopl;

    bool Status = false;
    BOOL RaisingStatus = KbRaiseIopl();
    if (!RaisingStatus) return false;
    __try {
        __outbyte(0x43, 0xB6); // Set beeper regime
        Status = true;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = false;
    }
    return KbResetIopl();
}

bool VirtualMemoryTest::RunTest() {
    using namespace VirtualMemory;

    constexpr int Size = 1048576;
    WdkTypes::PVOID Address;
    BOOL Status = KbAllocKernelMemory(Size, TRUE, &Address);
    if (!Status) Log(L"KbAllocKernelMemory == FALSE");
    if (!Address) { 
        Log(L"Address == NULL");
        return FALSE;
    }

    bool TestStatus = false;

    PVOID UserMemory = NULL;
    __try {
        UserMemory = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        Status = KbFillMemory(reinterpret_cast<WdkTypes::PVOID>(UserMemory), 0x90, Size);
        if (!Status) Log(L"KbFillMemory == FALSE");

        Status = KbCopyMoveMemory(Address, reinterpret_cast<WdkTypes::PVOID>(UserMemory), Size, FALSE);
        if (!Status) Log(L"KbCopyMoveMemory == FALSE");

        BOOLEAN Equals = FALSE;
        Status = KbEqualMemory(reinterpret_cast<WdkTypes::PVOID>(UserMemory), Address, Size, &Equals);
        if (!Status) Log(L"KbEqualMemory == FALSE");

        TestStatus = KbFreeKernelMemory(Address);
        if (!TestStatus) Log(L"KbFreeKernelMemory == FALSE");
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        TestStatus = false;
    }

    if (UserMemory) VirtualFree(UserMemory, 0, MEM_RELEASE);

    return TestStatus;
}

bool MdlTest::RunTest() {
    using namespace Mdl;

    constexpr int Size = 1048576;
    PVOID Buffer = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    bool TestStatus = false;

    Mdl::MAPPING_INFO MappingInfo = {};
    BOOL Status = KbMapMemory(&MappingInfo, 0, 0, reinterpret_cast<WdkTypes::PVOID>(Buffer), Size);
    if (!Status) Log(L"KbMapMemory == FALSE");

    if (!Status || !MappingInfo.MappedAddress || !MappingInfo.Mdl) {
        VirtualFree(Buffer, 0, MEM_RELEASE);
        return false;
    }

    PVOID Mapped = reinterpret_cast<PVOID>(MappingInfo.MappedAddress);

    BOOL Equals = FALSE;
    __try {
        FillMemory(Mapped, Size, 0xC6);
        Equals = !memcmp(Buffer, Mapped, Size);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Log(L"Filling and comparing failure!");
        Equals = FALSE;
    }

    if (!KbUnmapMemory(&MappingInfo)) Log(L"KbUnmapMemory == FALSE");
    VirtualFree(Buffer, 0, MEM_RELEASE);

    return Equals;
}

bool PhysicalMemoryTest::RunTest() {
    using namespace PhysicalMemory;
    using namespace Mdl;

    UINT64 Value = 0x1EE7C0DEC0FFEE;
    VirtualLock(&Value, sizeof(Value));

    bool TestStatus = false;

    __try {
        WdkTypes::PVOID PhysicalAddress = NULL;
        BOOL Status = KbGetPhysicalAddress(NULL, reinterpret_cast<WdkTypes::PVOID>(&Value), &PhysicalAddress);
        if (!Status) Log(L"KbGetPhysicalAddress == FALSE");
        if (!PhysicalAddress) {
            VirtualUnlock(&Value, sizeof(Value));
            return FALSE;
        }

        WdkTypes::PVOID VirtualAddress = NULL;
        Status = KbMapPhysicalMemory(PhysicalAddress, sizeof(Value), WdkTypes::MmNonCached, &VirtualAddress);
        if (!Status) Log(L"KbMapPhysicalMemory == FALSE");

        Mdl::MAPPING_INFO MappingInfo = {};
        KbMapMemory(&MappingInfo, 0, 0, VirtualAddress, sizeof(Value));

        PUINT64 Mapping = reinterpret_cast<PUINT64>(MappingInfo.MappedAddress);

        if (*Mapping != Value) {
            Log(L"*Mapping != Value");
            VirtualUnlock(&Value, sizeof(Value));
            return FALSE;                
        }

        *Mapping = 0xC0FFEE;
        if (Value != 0xC0FFEE) Log(L"Value != 0xC0FFEE");

        KbUnmapMemory(&MappingInfo);

        UINT64 Buffer = 0;
        Status = KbReadPhysicalMemory(PhysicalAddress, &Buffer, sizeof(Buffer), WdkTypes::MmNonCached);
        if (!Status) Log(L"KbReadPhysicalMemory == FALSE");

        if (Buffer != Value) Log(L"Buffer != Value");

        Buffer = 0x900DDA7E;
        Status = KbWritePhysicalMemory(PhysicalAddress, &Buffer, sizeof(Buffer), WdkTypes::MmNonCached);
        if (!Status) Log(L"KbWritePhysicalMemory == FALSE");

        if (Value != Buffer) Log(L"Value != Buffer 0x900DDA7E");

        TestStatus = true;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Log(L"Something goes wrong");
    }

    VirtualUnlock(&Value, sizeof(Value));
    return TestStatus;
}

bool ProcessesTest::RunTest() {
        
    using namespace Processes;
    using namespace Descriptors;
    using namespace Threads;
    using namespace MemoryManagement;
    using namespace Apc;

    BOOL TestStatus = true;

    ULONG ProcessId = GetCurrentProcessId();
    ULONG ThreadId = GetCurrentThreadId();

    BOOL Status = FALSE;

    WdkTypes::PEPROCESS Process = NULL;
    TestStatus &= Status = KbGetEprocess(ProcessId, &Process);
    if (!Process) Log(L"Process == NULL");

    WdkTypes::PETHREAD Thread = NULL;
    TestStatus &= Status = KbGetEthread(ThreadId, &Thread);
    if (!Process) Log(L"Thread == NULL");

    KbDereferenceObject(Process);
    KbDereferenceObject(Thread);

    WdkTypes::HANDLE hProcess = NULL;
    TestStatus &= Status = KbOpenProcess(ProcessId, &hProcess);
    if (!Status) Log(L"KbOpenProcess == FALSE");

    KbCloseHandle(hProcess);

    constexpr int Size = 1048576;
    WdkTypes::PVOID Buffer = NULL;
    TestStatus &= Status = KbAllocUserMemory(ProcessId, PAGE_READWRITE, Size, &Buffer);
    if (!Status) Log(L"KbAllocUserMemory == FALSE");

    if (Status) {
        PVOID uBuffer = reinterpret_cast<PVOID>(Buffer);
        FillMemory(uBuffer, Size, 0x90);

        UINT64 Data = 0;
        TestStatus &= Status = KbReadProcessMemory(ProcessId, Buffer, &Data, sizeof(Data));
        if (!Status) Log(L"KbReadProcessMemory == FALSE");
        if (Data != 0x9090909090909090) Log(L"Data != 0x9090909090909090");

        Data = 0x1122334455667788;
        TestStatus &= Status = KbWriteProcessMemory(ProcessId, Buffer, &Data, sizeof(Data));
        if (!Status) Log(L"KbWriteProcessMemory == FALSE");
        Data = 0;
        TestStatus &= Status = KbReadProcessMemory(ProcessId, Buffer, &Data, sizeof(Data));
        if (!Status) Log(L"KbReadProcessMemory == FALSE");
        if (Data != 0x1122334455667788) Log(L"Data != 0x1122334455667788");

        TestStatus &= Status = KbFreeUserMemory(ProcessId, Buffer);
        if (!Status) Log(L"KbFreeUserMemory == FALSE");
    }

    _ApcProc Apc = [](PVOID Arg) -> VOID {
        std::cout << " > Called from APC: " << Arg << std::endl;
    };

    TestStatus &= KbQueueUserApc(
        ThreadId, 
        reinterpret_cast<WdkTypes::PVOID>(Apc),
        static_cast<WdkTypes::PVOID>(0x12345)
    );

    return static_cast<bool>(TestStatus);
}

bool ShellTest::RunTest() {
    using namespace KernelShells;
    ULONG Result = 1337;
    KbExecuteShellCode(
        [](KernelShells::_GetKernelProcAddress GetKernelProcAddress, PVOID Argument) -> ULONG {
            ULONG Value = *static_cast<PULONG>(Argument);
            using _KeStallExecutionProcessor = VOID(WINAPI*)(ULONG Microseconds);
            auto Stall = reinterpret_cast<_KeStallExecutionProcessor>(GetKernelProcAddress(L"KeStallExecutionProcessor"));
            Stall(1);
            return Value == 1337 ? 10 : 0;
        },
        &Result,
        &Result
    );
    return Result == 10;
}

bool StuffTest::RunTest() {
    using namespace Stuff;

    BOOL TestStatus = TRUE;
    BOOL Status = FALSE;

    WdkTypes::PVOID KernelAddress = NULL;
    TestStatus &= Status = KbGetKernelProcAddress(L"KeStallExecutionProcessor", &KernelAddress);
    if (!Status) Log(L"KbGetKernelProcAddress == FALSE");
    if (!KernelAddress) Log(L"KernelAddress == NULL");

    return static_cast<bool>(Status);
}
```

`Kernel-Tests/Kernel-Tests.h`:

```h
#pragma once

class KernelTests {
private:
    std::wstring TestName;
protected:
    bool Passed;
public:
    virtual bool RunTest() {
        std::wcout << L"Null test" << std::endl;
        return true;
    }

    KernelTests(LPCWSTR Name) : TestName(Name), Passed(false) {
    }

    ~KernelTests() = default;

    void Log(LPCWSTR Text) {
        std::wcout << L"\t[ " << TestName << L" ]: " << Text << std::endl; 
    }

    void PrintStatus() {
        if (!Passed) std::wcout << std::endl;
        std::wcout << L"[ " << (Passed ? L"PASSED" : L"FAILED") << L" ] " << TestName << std::endl; 
    }
};

class BeeperTest : public KernelTests {
public:
    BeeperTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class IoplTest : KernelTests {
public:
    IoplTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class VirtualMemoryTest : KernelTests {
public:
    VirtualMemoryTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class MdlTest : KernelTests {
public:
    MdlTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class PhysicalMemoryTest : KernelTests {
public:
    PhysicalMemoryTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class ProcessesTest : KernelTests {
public:
    ProcessesTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class ShellTest : KernelTests {
public:
    ShellTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};

class StuffTest : KernelTests {
public:
    StuffTest(LPCWSTR Name) : KernelTests(Name) { Passed = RunTest(); PrintStatus(); }
    bool RunTest() override;
};
```

`Kernel-Tests/Kernel-Tests.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{95F62D20-4D68-475B-8B69-D1EB3585F3F3}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>KernelTests</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>../User-Bridge/API;../SharedTypes;../CommonTypes;../User-Bridge/API/PEUtils;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>../User-Bridge/API;../SharedTypes;../CommonTypes;../User-Bridge/API/PEUtils;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>../User-Bridge/API;../SharedTypes;../CommonTypes;../User-Bridge/API/PEUtils;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>../User-Bridge/API;../SharedTypes;../CommonTypes;../User-Bridge/API/PEUtils;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ExceptionHandling>Sync</ExceptionHandling>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ExceptionHandling>Sync</ExceptionHandling>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\CommonTypes\PTE.h" />
    <ClInclude Include="Kernel-Tests.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\User-Bridge\API\CommPort.cpp" />
    <ClCompile Include="..\User-Bridge\API\DriversUtils.cpp" />
    <ClCompile Include="..\User-Bridge\API\PEUtils\PEAnalyzer.cpp" />
    <ClCompile Include="..\User-Bridge\API\PEUtils\PELoader.cpp" />
    <ClCompile Include="..\User-Bridge\API\Rtl-Bridge.cpp" />
    <ClCompile Include="..\User-Bridge\API\SymParser.cpp" />
    <ClCompile Include="..\User-Bridge\API\User-Bridge.cpp" />
    <ClCompile Include="Kernel-Tests.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Kernel-Tests/Kernel-Tests.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Kernel-Tests.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\CommonTypes\PTE.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Kernel-Tests.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\DriversUtils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\User-Bridge.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\Rtl-Bridge.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\PEUtils\PELoader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\PEUtils\PEAnalyzer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\CommPort.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\User-Bridge\API\SymParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Kernel-Tests/Main.cpp`:

```cpp
#include "pch.h"

#include "WdkTypes.h"
#include "CtlTypes.h"
#include "FltTypes.h"
#include "User-Bridge.h"
#include "Rtl-Bridge.h"

#include <fltUser.h>
#include "CommPort.h"
#include "Flt-Bridge.h"

#include "Kernel-Tests.h"

#include <vector>
#include <string>
#include <iostream>
#include <set>
#include <fstream>

#define _NO_CVCONST_H
#include <dbghelp.h>
#include "SymParser.h"

#include <PTE.h>
#include <Registers.h>
#include <VMX.h>

#include <intrin.h>

void RunTests() {
    BeeperTest tBeeper(L"Beeper");
    IoplTest tIopl(L"IOPL");
    VirtualMemoryTest tVirtualMemory(L"VirtualMemory");
    MdlTest tMdl(L"Mdl");
    PhysicalMemoryTest tPhysicalMemory(L"PhysicalMemory");
    ProcessesTest tProcesses(L"Processes");
    ShellTest tShell(L"Shells");
    StuffTest tStuff(L"Stuff");
}

void TranslationTest(PVOID Address)
{
    using namespace VirtualMemory;
    using namespace PhysicalMemory;
    using namespace KernelShells;
    using namespace Processes::MemoryManagement;
    using namespace KbRtl;

    VIRTUAL_ADDRESS Va = {};
    Va.Value = reinterpret_cast<SIZE_T>(Address);

    printf("Target VA: %p\r\n", Address);

    VirtualLock(Address, 1);

    using REGS = struct {
        CR3 Cr3;
        CR4 Cr4;
    };
    REGS Regs = {};

    KbExecuteShellCode([](auto GetKernelProcAddress, auto Argument) -> ULONG {
        REGS* Regs = (REGS*)Argument;
        Regs->Cr3.Value = __readcr3();
        Regs->Cr4.Value = __readcr4();
        return 0;
    }, &Regs);

    PML4E Pml4e = {};
    PDPE Pdpe = {};
    PDE Pde = {};
    PTE Pte = {};

    try {
        WdkTypes::PVOID pPml4e = PFN_TO_PAGE(Regs.Cr3.x64.Bitmap.PML4) + Va.x64.NonPageSize.Page4Kb.PageMapLevel4Offset * sizeof(Pml4e);
        WdkTypes::PVOID VirtPml4e = PhysMem::GetVirtualForPhysical(pPml4e);
        Pml4e.x64.Value = VirtMem::ReadQword(VirtPml4e);
        printf("PML4E: VA = %p, PA = %p\r\n", (PVOID)VirtPml4e, (PVOID)pPml4e);
        //Pml4e.x64.Page4Kb.US = 1;
        //VirtMem::WriteQword(VirtPml4e, Pml4e.x64.Value);

        WdkTypes::PVOID pPdpe = PFN_TO_PAGE(Pml4e.x64.Page4Kb.PDP) + Va.x64.NonPageSize.Page4Kb.PageDirectoryPointerOffset * sizeof(Pdpe);
        WdkTypes::PVOID VirtPdpe = PhysMem::GetVirtualForPhysical(pPdpe);
        Pdpe.x64.Value = VirtMem::ReadQword(VirtPdpe);
        printf("PDPE: VA = %p, PA = %p\r\n", (PVOID)VirtPdpe, (PVOID)pPdpe);
        //Pdpe.x64.Page4Kb.US = 1;
        //VirtMem::WriteQword(VirtPdpe, Pdpe.x64.Value);

        WdkTypes::PVOID pPde = PFN_TO_PAGE(Pdpe.x64.NonPageSize.Page4Kb.PD) + Va.x64.NonPageSize.Page4Kb.PageDirectoryOffset * sizeof(Pde);
        WdkTypes::PVOID VirtPde = PhysMem::GetVirtualForPhysical(pPde);
        Pde.x64.Value = VirtMem::ReadQword(VirtPde);
        printf("PDE: VA = %p, PA = %p\r\n", (PVOID)VirtPde, (PVOID)pPde);
        //Pde.x64.Page4Kb.US = 1;
        //VirtMem::WriteQword(VirtPde, Pde.x64.Value);

        WdkTypes::PVOID pPte = PFN_TO_PAGE(Pde.x64.Page4Kb.PT) + Va.x64.NonPageSize.Page4Kb.PageTableOffset * sizeof(Pte);
        WdkTypes::PVOID VirtPte = PhysMem::GetVirtualForPhysical(pPte);
        Pte.x64.Value = VirtMem::ReadQword(VirtPte);
        printf("PTE: VA = %p, PA = %p\r\n", (PVOID)VirtPte, (PVOID)pPte);
        //Pte.x64.Page4Kb.US = 1;
        printf("> AVL: %i, G: %i, A: %i, D: %i\n", (int)Pte.x64.Page4Kb.AVL, (int)Pte.x64.Page4Kb.G, (int)Pte.x64.Page4Kb.A, (int)Pte.x64.Page4Kb.D);
        //Pte.x64.Page4Kb.AVL = 0b101; // Trigger CoW
        //VirtMem::WriteQword(VirtPte, Pte.x64.Value);

        WdkTypes::PVOID PhysicalAddress = PFN_TO_PAGE(Pte.x64.Page4Kb.PhysicalPageFrameNumber) + Va.x64.NonPageSize.Page4Kb.PageOffset;
        WdkTypes::PVOID ValidPhysicalAddress = PhysMem::GetPhysAddress(Va.Value);
        printf("PA = 0x%llX, VPA = 0x%llX\n", PhysicalAddress, ValidPhysicalAddress);

        //PULONG KMem = (PULONG)Address;
        //*KMem = *KMem;

        PhysicalAddress = PFN_TO_PAGE(Pte.x64.Page4Kb.PhysicalPageFrameNumber) + Va.x64.NonPageSize.Page4Kb.PageOffset;
        ValidPhysicalAddress = PhysMem::GetPhysAddress(Va.Value);
        printf("PA = 0x%llX, VPA = 0x%llX\n", PhysicalAddress, ValidPhysicalAddress);

        if (PhysicalAddress == ValidPhysicalAddress)
            printf("Addresses are matches, PA = 0x%llX\n", PhysicalAddress);
        
    } catch (DWORD LastError) {
        printf("LE: 0x%X\r\n", LastError);
    }

    //KbFreeNonCachedMemory(KernelMemory, 4096);
}

void SmmTest() {
    SetThreadAffinityMask(GetCurrentThread(), 1);

    UINT64 MsrBaseAddress = 0x30000;
    CPU::KbReadMsr(0xC0010111, &MsrBaseAddress);

    union SMM_ADDR {
        unsigned long long Value;
        struct {
            unsigned long long Reserved0 : 17;
            unsigned long long Base : 35;
            unsigned long long Reserved1 : 12;
        } Bitmap;
    };

    union SMM_MASK {
        unsigned long long Value;
        struct {
            unsigned long long AE : 1;
            unsigned long long TE : 1;
            unsigned long long Reserved0 : 15;
            unsigned long long Base : 35;
            unsigned long long Reserved1 : 12;
        } Bitmap;
    };

    SMM_ADDR MsrProtectedBase = {};
    CPU::KbReadMsr(0xC0010112, &MsrProtectedBase.Value);

    SMM_MASK MsrProtectedMask = {};
    CPU::KbReadMsr(0xC0010113, &MsrProtectedMask.Value);

    __debugbreak();
}

void print_cpuid() {
    int regs[4] = {};
    __cpuid(regs, 0);
    char str[13] = {};
    // CPUID Vendor = RBX + RDX + RCX:
    *(int*)(str + 0) = regs[1]; // RBX
    *(int*)(str + 4) = regs[3]; // RDX
    *(int*)(str + 8) = regs[2]; // RCX
    printf("CPU: %s\r\n", str);
}

void RandomRpmTest() {
    using namespace VirtualMemory;
    using namespace Processes::MemoryManagement;

    PVOID Buffer = VirtualAlloc(NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    VirtualLock(Buffer, 4096);

    const WdkTypes::PVOID Base = 0xFFFFFFFFFFFFFFFF;
    for (auto i = Base; i >= 0x7FFFFFFFFFFFFFFF; i -= 4096) {
        BOOL Status = KbReadProcessMemory(GetCurrentProcessId(), Base, Buffer, 4096);
        if (Status) {
            printf("[%p] OK\r\n", (PVOID)i);
            break;
        }
    }

    VirtualFree(Buffer, 4096, MEM_FREE);
    printf("Random RPM OK\r\n");
}

//#define FLT_TEST

#ifdef FLT_TEST
CommPortListener<KB_FLT_OB_CALLBACK_INFO, KbObCallbacks> ObCallbacks;

void TestObCallbacks()
{
    // Prevent to open our process with PROCESS_VM_READ rights:
    BOOL Status = ObCallbacks.Subscribe([](CommPort & Port, MessagePacket<KB_FLT_OB_CALLBACK_INFO> & Message) -> VOID {
        auto Data = static_cast<PKB_FLT_OB_CALLBACK_INFO>(Message.GetData());
        if (Data->Target.ProcessId == GetCurrentProcessId()) {
            Data->CreateResultAccess &= ~(PROCESS_VM_READ | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME);
            Data->DuplicateResultAccess &= ~(PROCESS_VM_READ | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME);
            printf("Access attempted from %i\r\n", static_cast<int>(Data->Client.ProcessId));
        }
        ReplyPacket<KB_FLT_OB_CALLBACK_INFO> Reply(Message, ERROR_SUCCESS, *Data);
        Port.Reply(Reply); // Reply info to driver
    });

    MSG Msg;
    while (GetMessage(&Msg, NULL, 0, 0)) {
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
}

#endif


DWORD GetPidByName(LPCWSTR Name)
{
    DWORD ProcessId = 0xFFFFFFFF;
    
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return ProcessId;

    PROCESSENTRY32 ProcessEntry = {};
    ProcessEntry.dwSize = sizeof(ProcessEntry);
    if (Process32First(hSnapshot, &ProcessEntry)) do {
        if (wcsstr(ProcessEntry.szExeFile, Name)) {
            ProcessId = ProcessEntry.th32ProcessID;
            break;
        }
    } while (Process32Next(hSnapshot, &ProcessEntry));

    CloseHandle(hSnapshot);
    return ProcessId;
}

VOID ThreadingTests()
{
    using namespace Processes;
    DWORD ExplorerPid = GetPidByName(L"explorer.exe");
    printf("PID of explorer.exe is %u\r\n", ExplorerPid);
    PVOID Proc = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "Sleep");
    WdkTypes::CLIENT_ID ClientId = {};
    WdkTypes::HANDLE hThread = NULL;
    printf("Creating a thread...\r\n");
    BOOL Status = Threads::KbCreateUserThread(ExplorerPid, reinterpret_cast<WdkTypes::PVOID>(Proc), 10000, FALSE, &ClientId, &hThread);
    if (Status) {
        printf("PID:%I64u, TID:%I64u, hThread = 0x%I64X\r\n", ClientId.ProcessId, ClientId.ThreadId, hThread);
        WaitForSingleObject(reinterpret_cast<HANDLE>(hThread), INFINITE);
        printf("Thread is finished!\r\n");
        Descriptors::KbCloseHandle(hThread);
        printf("Handle is closed!\r\n");
    }
    else {
        printf("Unable to create a thread!\r\n");
    }
}

void* GetFuncPtr(const void* Func)
{
    if (!Func) return nullptr;
    const auto* FuncDataPtr = reinterpret_cast<const unsigned char*>(Func);
    if (*FuncDataPtr == 0xE9)
    {
        auto Offset = *reinterpret_cast<const int*>(FuncDataPtr + 1);
        return const_cast<unsigned char*>((FuncDataPtr + 5) + Offset);
    }
    else
    {
        return const_cast<void*>(Func);
    }
}

#pragma section(".hidden", read, execute, nopage)
__declspec(code_seg(".hidden")) unsigned int HiddenFunc()
{
    printf("Called from hidden func!\n");
    for (unsigned int i = 0; i < 100; ++i)
    {
        volatile BYTE* Self = reinterpret_cast<PBYTE>(GetFuncPtr(HiddenFunc));
        *Self = 0x55;
    }
    return 0x1EE7C0DE;
}

VOID TestHvPageInterception()
{
    using namespace Hypervisor;
    using namespace PhysicalMemory;

    constexpr unsigned int PageSize = 4096;

    volatile PBYTE Read = reinterpret_cast<PBYTE>(VirtualAlloc(NULL, PageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE));
    volatile PBYTE Write = reinterpret_cast<PBYTE>(VirtualAlloc(NULL, PageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE));
    volatile PBYTE WriteExecute = reinterpret_cast<PBYTE>(VirtualAlloc(NULL, PageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE));
    volatile PBYTE Execute = reinterpret_cast<PBYTE>(GetFuncPtr(HiddenFunc));

    __assume(Read != 0);
    __assume(Write != 0);
    __assume(WriteExecute != 0);

    VirtualLock(Read, PageSize);
    VirtualLock(Write, PageSize);
    VirtualLock(Execute, PageSize);
    VirtualLock(WriteExecute, PageSize);

    memset(Read, 0xFF, PageSize);
    memset(Write, 0xEE, PageSize);
    memcpy(WriteExecute, Execute, PageSize);

    DWORD OldProtect = 0;
    VirtualProtect(Execute, PageSize, PAGE_EXECUTE_READWRITE, &OldProtect);
    *Execute = *Execute;

    WdkTypes::PVOID64 ReadPa = 0, WritePa = 0, WriteExecutePa = 0, ExecutePa = 0;
    KbGetPhysicalAddress(NULL, reinterpret_cast<WdkTypes::PVOID>(Read), &ReadPa);
    KbGetPhysicalAddress(NULL, reinterpret_cast<WdkTypes::PVOID>(Write), &WritePa);
    KbGetPhysicalAddress(NULL, reinterpret_cast<WdkTypes::PVOID>(WriteExecute), &WriteExecutePa);
    KbGetPhysicalAddress(NULL, reinterpret_cast<WdkTypes::PVOID>(Execute), &ExecutePa);
    
    printf("Original bytes: 0x%X\n", static_cast<unsigned int>(*Execute));

    KbVmmInterceptPage(ExecutePa, ReadPa, WritePa, ExecutePa, ExecutePa, WriteExecutePa);    
    printf("Bytes after intercept: 0x%X\n", static_cast<unsigned int>(*Execute));
    *Execute = 0x40;
    HiddenFunc();
    printf("Bytes after call: 0x%X\n", static_cast<unsigned int>(*Execute));
    printf("Write-interceptor: W:0x%X WX:0x%X\n", static_cast<unsigned int>(*Write), static_cast<unsigned int>(*WriteExecute));
    KbVmmDeinterceptPage(ExecutePa);

    printf("Bytes after deintercept: 0x%X\n", static_cast<unsigned int>(*Execute));

    VirtualUnlock(Execute, PageSize);
    VirtualUnlock(Write, PageSize);
    VirtualUnlock(Read, PageSize);

    VirtualFree(Write, 0, MEM_RELEASE);
    VirtualFree(Read, 0, MEM_RELEASE);
}

WdkTypes::PVOID GetPhysAddr(OPTIONAL WdkTypes::PEPROCESS Process, PVOID VirtualAddress)
{
    using namespace PhysicalMemory;
    WdkTypes::PVOID64 Pa = 0;
    KbGetPhysicalAddress(Process, reinterpret_cast<WdkTypes::PVOID>(VirtualAddress), &Pa);
    return Pa;
}

VOID VirtualMemoryTests()
{
    using namespace Processes::MemoryManagement;

    HMODULE hModule = GetModuleHandle(L"ntdll.dll");
    __assume(hModule != 0);
    PVOID Address = GetProcAddress(hModule, "NtTestAlert");

    printf("NtTestAlert: VA:%p, PA:0x%I64X\n", Address, GetPhysAddr(NULL, Address));
    KbTriggerCopyOnWrite(0, reinterpret_cast<WdkTypes::PVOID>(Address));
    printf("NtTestAlert: CoW-PA:0x%I64X\n", GetPhysAddr(NULL, Address));

    KbTriggerCopyOnWrite(0, reinterpret_cast<WdkTypes::PVOID>(Address));
    printf("NtTestAlert: Double CoW-PA:0x%I64X\n", GetPhysAddr(NULL, Address));

    for (unsigned long long i = 0; i < 100000; ++i)
    {
        KbTriggerCopyOnWrite(0, reinterpret_cast<WdkTypes::PVOID>(Address) + i * 4096ull);
    }
}

VOID RunAllTests()
{
    VirtualMemoryTests();
    return;

    //ThreadingTests();
    //return;

#ifdef FLT_TEST
    TestObCallbacks();
#endif

    //RunTests();
    //RandomRpmTest();

    //PVOID Addr = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "SetLastError");
    //TranslationTest(Addr);

    if (Hypervisor::KbVmmEnable())
    {
        printf("VMM enabled!\r\n");

        TestHvPageInterception();

        printf(
            "Commands:\n"
            "  exit: disable the hypervisor and exit\n"
        );
        while (true)
        {
            std::wstring Command;
            std::wcin >> Command;
            if (Command == L"exit")
            {
                break;
            }
            else
            {
                printf("Unknown command!\n");
            }
        }
        Hypervisor::KbVmmDisable();
        printf("VMM disabled!\r\n");
        print_cpuid();
    }
    else
    {
        printf("Unable to start VMM!\r\n");
    }
}

std::wstring GetCurrentFolder()
{
    WCHAR Path[MAX_PATH] = {};
    DWORD PathLength = ARRAYSIZE(Path);
    BOOL Status = QueryFullProcessImageName(GetCurrentProcess(), 0, Path, &PathLength);
    return Status ? std::wstring(Path, PathLength) : std::wstring();
}

int main()
{
    std::wstring CurrentFolder = GetCurrentFolder();
    if (CurrentFolder.empty())
    {
        printf("Unable to determine current directory!\n");
        return 0;
    }

    printf("[Kernel-Tests]: PID: %i, TID: %i\r\n", GetCurrentProcessId(), GetCurrentThreadId());

    if (KbLoader::KbLoadAsFilter(
        L"C:\\Temp\\Kernel-Bridge\\Kernel-Bridge.sys",
        L"260000" // Altitude of minifilter
    )) {
        RunAllTests();
        KbLoader::KbUnload();
    } else {
        std::wcout << L"Unable to load driver! LastError: 0x" << std::hex << GetLastError() << std::endl;
    }

    std::wcout << L"Press any key to exit..." << std::endl;
    std::cin.get();

    return 0;
}
```

`Kernel-Tests/pch.cpp`:

```cpp
// pch.cpp: исходный файл, соответствующий предкомпилированному заголовку; нужен для компиляции

#include "pch.h"

// В целом этот файл можно пропустить, но не удаляйте его, если вы используете предкомпилированные заголовки.

```

`Kernel-Tests/pch.h`:

```h
#ifndef PCH_H
#define PCH_H

#define _SCL_SECURE_NO_WARNINGS
#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING

#include <SDKDDKVer.h>

#include <Windows.h>
#include <winternl.h>
#include <Tlhelp32.h>

#include <iostream>
#include <string>
#include <functional>

#endif //PCH_H

```

`Kernel-Tests/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Manifest.rc

// Следующие стандартные значения для новых объектов
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Kernel-Toolkit/Kernel-Toolkit/Kernel-Toolkit.pro`:

```pro
QT += core gui widgets

TARGET = Kernel-Toolkit
TEMPLATE = app

DEFINES += QT_DEPRECATED_WARNINGS

CONFIG += c++17 static static-runtime
QMAKE_LFLAGS_RELEASE += -static -static-runtime

INCLUDEPATH += \
    ../../SharedTypes \
    ../../User-Bridge/API/ \
    ../../User-Bridge/API/PEUtils/

LIBS += \
    -lAdvapi32

SOURCES += \
    ObjectsStorage.cpp \
    MainWindow.cpp \
    Main.cpp \
    ../../User-Bridge/API/PEUtils/PEAnalyzer.cpp \
    ../../User-Bridge/API/PEUtils/PELoader.cpp \
    ../../User-Bridge/API/CommPort.cpp \
    ../../User-Bridge/API/DriversUtils.cpp \
    ../../User-Bridge/API/Rtl-Bridge.cpp \
    ../../User-Bridge/API/User-Bridge.cpp

HEADERS += \
    ObjectsStorage.h \
    MainWindow.h \
    ../../SharedTypes/CtlTypes.h \
    ../../SharedTypes/FltTypes.h \
    ../../SharedTypes/WdkTypes.h \
    ../../User-Bridge/API/PEUtils/PEAnalyzer.h \
    ../../User-Bridge/API/PEUtils/PELoader.h \
    ../../User-Bridge/API/CommPort.h \
    ../../User-Bridge/API/DriversUtils.h \
    ../../User-Bridge/API/Flt-Bridge.h \
    ../../User-Bridge/API/Rtl-Bridge.h \
    ../../User-Bridge/API/User-Bridge.h

FORMS += \
    MainWindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

DISTFILES +=

RESOURCES +=

```

`Kernel-Toolkit/Kernel-Toolkit/Main.cpp`:

```cpp
#include "MainWindow.h"
#include <QApplication>

#include <QFontDatabase>
#include <qmessagebox.h>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}

```

`Kernel-Toolkit/Kernel-Toolkit/MainWindow.cpp`:

```cpp
#include "MainWindow.h"
#include "ui_MainWindow.h"

#include <qmessagebox.h>
#include <qgraphicseffect.h>
#include <qdesktopwidget.h>

MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow), objectsStorage()
{
    ui->setupUi(this);
    BOOL Status = KbLoader::KbLoadAsFilter(L"C:\\Temp\\Kernel-Bridge\\Kernel-Bridge.sys", L"260000");
    if (!Status) {
        QMessageBox msg;
        msg.critical(ui->MainForm, "Error!", "Unable to load driver!\r\nEnsure to run it as Administrator!");
    }
}

MainWindow::~MainWindow()
{
    KbLoader::KbUnload();
    delete ui;
}

bool MainWindow::isHex(const QString& string) {
    return string.startsWith("0x") || string.startsWith("$");
}

int MainWindow::getInt(const QString& string) {
    bool Status = false;
    return isHex(string) ? string.toInt(&Status, 16) : string.toInt();
}

long long MainWindow::getInt64(const QString& string) {
    bool Status = false;
    return isHex(string) ? string.toLongLong(&Status, 16) : string.toLongLong();
}

unsigned int MainWindow::getUInt(const QString& string) {
    bool Status = false;
    return isHex(string) ? string.toUInt(&Status, 16) : string.toUInt();
}

unsigned long long MainWindow::getUInt64(const QString& string) {
    bool Status = false;
    return isHex(string) ? string.toULongLong(&Status, 16) : string.toULongLong();
}

void MainWindow::on_EnableBeeperButton_clicked()
{
    static BOOL Enabled = FALSE;
    Enabled = !Enabled;

    if (Enabled) {
        IO::Beeper::KbSetBeeperRegime();
        unsigned short Frequency = ui->FreqEdit->text().toUShort();
        if (Frequency <= 0) Frequency = 1;
        if (Frequency > 20000) Frequency = 20000;
        IO::Beeper::KbSetBeeperFrequency(Frequency);
        IO::Beeper::KbStartBeeper();
        ui->EnableBeeperButton->setText("Disable beeper");
    } else {
        IO::Beeper::KbStopBeeper();
        ui->EnableBeeperButton->setText("Enable beeper");
    }
}

void MainWindow::on_FreqSlider_valueChanged(int value)
{
    ui->FreqEdit->setText(QString::number(value));
    ui->FreqEdit->editingFinished();
}

void MainWindow::on_FreqEdit_editingFinished()
{
    unsigned short Frequency = ui->FreqEdit->text().toUShort();
    if (Frequency <= 0) Frequency = 1;
    if (Frequency > 20000) Frequency = 20000;
    ui->FreqEdit->setText(QString::number(Frequency));
    IO::Beeper::KbSetBeeperFrequency(Frequency);
}

void MainWindow::on_ReadPortButton_clicked()
{
    unsigned int Value = 0;
    unsigned int PortNumber = getUInt(ui->PortNumberEdit->text());

    if (PortNumber > 255) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Port number must be in [0..255] interval!");
        return;
    }

    unsigned char CheckedPortNumber = static_cast<unsigned char>(PortNumber);

    BOOL Status = FALSE;
    if (ui->ByteRadioButton->isChecked()) {
        unsigned char CharValue = 0;
        Status = IO::RW::KbReadPortByte(CheckedPortNumber, &CharValue);
        Value = CharValue;
    } else if (ui->WordRadioButton->isChecked()) {
        unsigned short WordValue = 0;
        Status = IO::RW::KbReadPortWord(CheckedPortNumber, &WordValue);
        Value = WordValue;
    } else if (ui->DwordRadioButton->isChecked()) {
        unsigned long DwordValue = 0;
        Status = IO::RW::KbReadPortDword(CheckedPortNumber, &DwordValue);
        Value = DwordValue;
    }

    if (!Status) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Error in read port!");
    }

    ui->PortValueEdit->setText(QString::number(Value));
}

void MainWindow::on_WritePortButton_clicked()
{
    unsigned int Value = getUInt(ui->PortValueEdit->text());
    unsigned int PortNumber = getUInt(ui->PortNumberEdit->text());

    if (Value > 255 || PortNumber > 255) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Port number and value must be in [0..255] interval!");
        return;
    }

    unsigned char CheckedPortNumber = static_cast<unsigned char>(PortNumber);

    BOOL Status = FALSE;
    if (ui->ByteRadioButton->isChecked()) {
        Status = IO::RW::KbWritePortByte(CheckedPortNumber, static_cast<unsigned char>(Value));
    } else if (ui->WordRadioButton->isChecked()) {
        Status = IO::RW::KbWritePortWord(CheckedPortNumber, static_cast<unsigned short>(Value));
    } else if (ui->DwordRadioButton->isChecked()) {
        Status = IO::RW::KbWritePortDword(CheckedPortNumber, static_cast<unsigned long>(Value));
    }

    if (!Status) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Error in write port!");
    }
}

void MainWindow::on_CliButton_clicked()
{
    CPU::KbCli();
}

void MainWindow::on_StiButton_clicked()
{
    CPU::KbSti();
    static int counter = 0;
    counter++;
    ui->FreqEdit->setText(QString::number(counter));
}

void MainWindow::on_HltButton_clicked()
{
    CPU::KbHlt();
}

void MainWindow::on_RdmsrButton_clicked()
{
    unsigned int MsrIndex = getUInt(ui->MsrPmcIndexEdit->text());
    unsigned long long Value = 0;
    BOOL Status = FALSE;

    Status = CPU::KbReadMsr(MsrIndex, &Value);

    if (!Status) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Error in read MSR!");
        return;
    }

    ui->MsrPmcValueEdit->setText("0x" + QString::number(Value, 16).toUpper());
}

void MainWindow::on_WrmsrButton_clicked()
{
    unsigned int MsrIndex = getUInt(ui->MsrPmcIndexEdit->text());
    unsigned long long Value = getUInt64(ui->MsrPmcValueEdit->text());
    BOOL Status = FALSE;

    Status = CPU::KbWriteMsr(MsrIndex, Value);

    if (!Status) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Error in write MSR!");
        return;
    }
}

void MainWindow::on_RdpmcButton_clicked()
{
    unsigned int PmcIndex = getUInt(ui->MsrPmcIndexEdit->text());
    unsigned long long Value = 0;
    BOOL Status = FALSE;

    Status = CPU::KbReadPmc(PmcIndex, &Value);

    if (!Status) {
        QMessageBox msgBox;
        msgBox.critical(ui->MainForm, "Error!", "Error in read PMC!");
        return;
    }

    ui->MsrPmcValueEdit->setText("0x" + QString::number(Value, 16).toUpper());
}

```

`Kernel-Toolkit/Kernel-Toolkit/MainWindow.h`:

```h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include "ObjectsStorage.h"

namespace Ui {
    class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void on_EnableBeeperButton_clicked();

    void on_FreqSlider_valueChanged(int value);

    void on_FreqEdit_editingFinished();

    void on_ReadPortButton_clicked();

    void on_WritePortButton_clicked();

    void on_CliButton_clicked();

    void on_StiButton_clicked();

    void on_HltButton_clicked();

    void on_RdmsrButton_clicked();

    void on_WrmsrButton_clicked();

    void on_RdpmcButton_clicked();

private:
    Ui::MainWindow *ui;
    ObjectsStorage objectsStorage;
    bool isHex(const QString& string);
    int getInt(const QString& string);
    long long getInt64(const QString& string);
    unsigned int getUInt(const QString& string);
    unsigned long long getUInt64(const QString& string);
};

#endif // MAINWINDOW_H

```

`Kernel-Toolkit/Kernel-Toolkit/MainWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>850</width>
    <height>552</height>
   </rect>
  </property>
  <property name="palette">
   <palette>
    <active>
     <colorrole role="Button">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
     <colorrole role="Base">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
     <colorrole role="Window">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
    </active>
    <inactive>
     <colorrole role="Button">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
     <colorrole role="Base">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
     <colorrole role="Window">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
    </inactive>
    <disabled>
     <colorrole role="Button">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
     <colorrole role="Base">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
     <colorrole role="Window">
      <brush brushstyle="SolidPattern">
       <color alpha="255">
        <red>239</red>
        <green>239</green>
        <blue>239</blue>
       </color>
      </brush>
     </colorrole>
    </disabled>
   </palette>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <property name="windowOpacity">
   <double>1.000000000000000</double>
  </property>
  <property name="styleSheet">
   <string notr="true">/*
QWidget {
	background-color: rgb(239, 239, 239);
}
*/

QWidget#widget {
    border-style: solid;
    border-top-style: none;
    border-width: 1px;
    border-color: rgb(0, 100, 150);
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    background-color: transparent;
}

QLineEdit {
	background-color: white;
	border: 1px solid rgb(218, 218, 218);
	color: black;
}

QLabel {
	background-color: none;
	color: black;
}

/* Buttons */

QPushButton {
	border: 1px solid rgb(218, 218, 218);
	border-radius: 4px;
	background-color: white;
	color: black;
}

QPushButton::hover {
	background-color: qlineargradient(spread:pad, x1:0.5, y1:1, x2:0.5, y2:0, stop:0 rgb(10, 126, 255), stop:1 rgb(108, 179, 251));
	border: 1px solid rgb(155, 198, 242);
	color: white;
}

QPushButton::pressed {
	background-color: qlineargradient(spread:pad, x1:0.5, y1:1, x2:0.5, y2:0, stop:0 rgb(108, 179, 251), stop:1 rgb(10, 126, 255));
	border: 1px solid rgb(155, 198, 242);
	color: white;
}

/* Radiobuttons */

QRadioButton {
	background: none;
	color: black;
}

/* Slider */

QSlider::groove:horizontal {
    border: 1px solid rgb(218, 218, 218);
    height: 1px;
    background: white;
    margin: 2px 0;
}

QSlider::handle:horizontal {
	background-color: white;
    border: 1px solid rgb(218, 218, 218);
	border-radius: 1px;
    width: 10px;
    margin: -13px 0;
}

QSlider::handle::hover {
	background-color: rgb(194, 255, 204);
}

QSlider::handle::pressed {
	background-color: rgb(0, 255, 0);
}

/* TextEdit */

QTextEdit {
	background-color: white;
	border: 1px solid rgb(218, 218, 218);
	color: white;
	font-family: &quot;Courier New&quot;;
}

/* Tabs */

QTabWidget::pane {
	border-radius: 2px;
    border: 1px solid rgb(218, 218, 218);
	top: -0.9em;
}

QTabWidget::tab-bar {
	alignment: center;
}

QTabBar::tab {
    background-color: white;
    border: 1px solid rgb(218, 218, 218);

    min-width: 72px;
	min-height: 17px;

    padding-left: 9px;
	padding-right: 9px;
	padding-top: 2px;
	padding-bottom: 2px;

	margin-left: -1px;

	color: black;
}

QTabBar::tab:first {
	border-top-left-radius: 4px;
	border-bottom-left-radius: 4px;
}

QTabBar::tab:last {
	border-top-right-radius: 4px;
	border-bottom-right-radius: 4px;
}

QTabBar::tab:selected {
	background-color: qlineargradient(spread:pad, x1:0.5, y1:1, x2:0.5, y2:0, stop:0 rgb(10, 126, 255), stop:1 rgb(108, 179, 251));
	border: 1px solid rgb(155, 198, 242);
	color: white;
}

/* MessageBox */

QMessageBox QPushButton {
	padding-left: 11px;
	padding-right: 11px;
	padding-top: 3px;
	padding-bottom: 3px;
	border-radius: 2px;
	border-color: rgb(0, 143, 220);
	background-color: rgb(0, 128, 197);
	color: white;
}

QMessageBox QPushButton::hover {
	background-color: white;
	color: black;
}

QMessageBox QPushButton::pressed {
	background-color: rgb(0, 255, 0);
	color: black;
}</string>
  </property>
  <widget class="QWidget" name="MainForm">
   <widget class="QTabWidget" name="TabWidget">
    <property name="geometry">
     <rect>
      <x>7</x>
      <y>6</y>
      <width>834</width>
      <height>539</height>
     </rect>
    </property>
    <property name="styleSheet">
     <string notr="true">QTabWidget {
	background-color: rgb(226, 226, 226);
}</string>
    </property>
    <property name="currentIndex">
     <number>0</number>
    </property>
    <property name="usesScrollButtons">
     <bool>true</bool>
    </property>
    <widget class="QWidget" name="IoCpuTab">
     <attribute name="title">
      <string>IO/CPU</string>
     </attribute>
     <widget class="QPushButton" name="EnableBeeperButton">
      <property name="geometry">
       <rect>
        <x>209</x>
        <y>90</y>
        <width>97</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>Enable beeper</string>
      </property>
     </widget>
     <widget class="QLineEdit" name="FreqEdit">
      <property name="geometry">
       <rect>
        <x>160</x>
        <y>91</y>
        <width>47</width>
        <height>21</height>
       </rect>
      </property>
      <property name="text">
       <string>1000</string>
      </property>
      <property name="maxLength">
       <number>5</number>
      </property>
      <property name="frame">
       <bool>true</bool>
      </property>
      <property name="clearButtonEnabled">
       <bool>false</bool>
      </property>
     </widget>
     <widget class="QLabel" name="FreqLabel">
      <property name="geometry">
       <rect>
        <x>80</x>
        <y>92</y>
        <width>81</width>
        <height>17</height>
       </rect>
      </property>
      <property name="text">
       <string>Frequency, Hz:</string>
      </property>
     </widget>
     <widget class="QSlider" name="FreqSlider">
      <property name="geometry">
       <rect>
        <x>80</x>
        <y>116</y>
        <width>227</width>
        <height>27</height>
       </rect>
      </property>
      <property name="minimum">
       <number>1</number>
      </property>
      <property name="maximum">
       <number>10000</number>
      </property>
      <property name="value">
       <number>1000</number>
      </property>
      <property name="sliderPosition">
       <number>1000</number>
      </property>
      <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
     </widget>
     <widget class="QLineEdit" name="PortNumberEdit">
      <property name="geometry">
       <rect>
        <x>393</x>
        <y>92</y>
        <width>45</width>
        <height>20</height>
       </rect>
      </property>
      <property name="text">
       <string>0</string>
      </property>
      <property name="maxLength">
       <number>4</number>
      </property>
     </widget>
     <widget class="QLineEdit" name="PortValueEdit">
      <property name="geometry">
       <rect>
        <x>483</x>
        <y>92</y>
        <width>91</width>
        <height>20</height>
       </rect>
      </property>
      <property name="text">
       <string>0xFF</string>
      </property>
      <property name="maxLength">
       <number>11</number>
      </property>
     </widget>
     <widget class="QLabel" name="PortNumberLabel">
      <property name="geometry">
       <rect>
        <x>364</x>
        <y>94</y>
        <width>35</width>
        <height>16</height>
       </rect>
      </property>
      <property name="text">
       <string>Port:</string>
      </property>
     </widget>
     <widget class="QLabel" name="PortValueLabel">
      <property name="geometry">
       <rect>
        <x>446</x>
        <y>94</y>
        <width>50</width>
        <height>16</height>
       </rect>
      </property>
      <property name="text">
       <string>Value:</string>
      </property>
     </widget>
     <widget class="QPushButton" name="ReadPortButton">
      <property name="geometry">
       <rect>
        <x>363</x>
        <y>116</y>
        <width>104</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>Read from port</string>
      </property>
     </widget>
     <widget class="QPushButton" name="WritePortButton">
      <property name="geometry">
       <rect>
        <x>471</x>
        <y>116</y>
        <width>104</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>Write to port</string>
      </property>
     </widget>
     <widget class="QRadioButton" name="ByteRadioButton">
      <property name="geometry">
       <rect>
        <x>363</x>
        <y>74</y>
        <width>46</width>
        <height>18</height>
       </rect>
      </property>
      <property name="text">
       <string>Byte</string>
      </property>
      <property name="checked">
       <bool>false</bool>
      </property>
     </widget>
     <widget class="QRadioButton" name="WordRadioButton">
      <property name="geometry">
       <rect>
        <x>414</x>
        <y>74</y>
        <width>52</width>
        <height>17</height>
       </rect>
      </property>
      <property name="text">
       <string>Word</string>
      </property>
      <property name="checked">
       <bool>false</bool>
      </property>
     </widget>
     <widget class="QRadioButton" name="DwordRadioButton">
      <property name="geometry">
       <rect>
        <x>464</x>
        <y>74</y>
        <width>80</width>
        <height>17</height>
       </rect>
      </property>
      <property name="text">
       <string>Dword</string>
      </property>
     </widget>
     <widget class="QPushButton" name="CliButton">
      <property name="geometry">
       <rect>
        <x>237</x>
        <y>184</y>
        <width>59</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>CLI</string>
      </property>
     </widget>
     <widget class="QPushButton" name="StiButton">
      <property name="geometry">
       <rect>
        <x>299</x>
        <y>184</y>
        <width>59</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>STI</string>
      </property>
      <property name="checkable">
       <bool>false</bool>
      </property>
      <property name="checked">
       <bool>false</bool>
      </property>
      <property name="autoExclusive">
       <bool>false</bool>
      </property>
      <property name="autoDefault">
       <bool>false</bool>
      </property>
      <property name="default">
       <bool>false</bool>
      </property>
      <property name="flat">
       <bool>false</bool>
      </property>
     </widget>
     <widget class="QPushButton" name="HltButton">
      <property name="geometry">
       <rect>
        <x>361</x>
        <y>184</y>
        <width>59</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>HLT</string>
      </property>
     </widget>
     <widget class="QPushButton" name="RdmsrButton">
      <property name="geometry">
       <rect>
        <x>77</x>
        <y>278</y>
        <width>85</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>RDMSR</string>
      </property>
     </widget>
     <widget class="QPushButton" name="WrmsrButton">
      <property name="geometry">
       <rect>
        <x>169</x>
        <y>278</y>
        <width>85</width>
        <height>23</height>
       </rect>
      </property>
      <property name="text">
       <string>WRMSR</string>
      </property>
     </widget>
     <widget class="QPushButton" name="RdpmcButton">
      <property name="geometry">
       <rect>
        <x>261</x>
        <y>278</y>
        <width>85</width>
        <height>23</height>
       </rect>
      </property>
      <property name="styleSheet">
       <string notr="true"/>
      </property>
      <property name="text">
       <string>RDPMC</string>
      </property>
     </widget>
     <widget class="QLabel" name="MsrPmcIndexLabel">
      <property name="geometry">
       <rect>
        <x>78</x>
        <y>248</y>
        <width>84</width>
        <height>16</height>
       </rect>
      </property>
      <property name="text">
       <string>MSR/PMC Index:</string>
      </property>
     </widget>
     <widget class="QLabel" name="MsrPmcValueLabel">
      <property name="geometry">
       <rect>
        <x>241</x>
        <y>248</y>
        <width>33</width>
        <height>16</height>
       </rect>
      </property>
      <property name="text">
       <string>Value:</string>
      </property>
     </widget>
     <widget class="QLineEdit" name="MsrPmcIndexEdit">
      <property name="geometry">
       <rect>
        <x>162</x>
        <y>247</y>
        <width>70</width>
        <height>20</height>
       </rect>
      </property>
      <property name="text">
       <string>0x00000000</string>
      </property>
      <property name="maxLength">
       <number>10</number>
      </property>
     </widget>
     <widget class="QLineEdit" name="MsrPmcValueEdit">
      <property name="geometry">
       <rect>
        <x>275</x>
        <y>247</y>
        <width>120</width>
        <height>20</height>
       </rect>
      </property>
      <property name="text">
       <string>0x0000000000000000</string>
      </property>
      <property name="maxLength">
       <number>18</number>
      </property>
     </widget>
     <widget class="QTableWidget" name="tableWidget">
      <property name="geometry">
       <rect>
        <x>245</x>
        <y>320</y>
        <width>531</width>
        <height>192</height>
       </rect>
      </property>
      <property name="rowCount">
       <number>5</number>
      </property>
      <property name="columnCount">
       <number>5</number>
      </property>
      <row/>
      <row/>
      <row/>
      <row/>
      <row/>
      <column/>
      <column/>
      <column/>
      <column/>
      <column/>
     </widget>
    </widget>
    <widget class="QWidget" name="VmTab">
     <attribute name="title">
      <string>Virtual/Physical Memory</string>
     </attribute>
     <widget class="QTextEdit" name="MemoryTextEdit">
      <property name="geometry">
       <rect>
        <x>185</x>
        <y>15</y>
        <width>649</width>
        <height>500</height>
       </rect>
      </property>
      <property name="html">
       <string>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;
&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;
p, li { white-space: pre-wrap; }
&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:'Courier New'; font-size:8.25pt; font-weight:400; font-style:normal;&quot;&gt;
&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;0x1122334455667788 | 00 11 22 33 44 55 66 77  88 99 AA BB CC DD EE FF | 0123456789abcdef&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
      </property>
     </widget>
    </widget>
    <widget class="QWidget" name="PsTab">
     <attribute name="title">
      <string>Processes</string>
     </attribute>
    </widget>
    <widget class="QWidget" name="ShellsTab">
     <attribute name="title">
      <string>Ring0 Shells</string>
     </attribute>
    </widget>
   </widget>
  </widget>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`Kernel-Toolkit/Kernel-Toolkit/ObjectsStorage.cpp`:

```cpp
#include "ObjectsStorage.h"

ObjectsStorage::ObjectsStorage() : ReferencedObjects(), Handles(), AllocatedMemory(), Mappings()
{

}

ObjectsStorage::~ObjectsStorage()
{
    using namespace VirtualMemory;
    using namespace Mdl;
    using namespace Processes::Descriptors;
    for (const auto& Entry : ReferencedObjects) {
        if (Entry) KbDereferenceObject(Entry);
    }
    for (const auto& Entry : Handles) {
        if (Entry) KbCloseHandle(Entry);
    }
    for (const auto& Entry : AllocatedMemory) {
        if (Entry) KbFreeKernelMemory(Entry);
    }
    for (const auto& Entry : Mappings) {
        KbUnmapMemory(const_cast<Mdl::PMAPPING_INFO>(&Entry));
    }
}

void ObjectsStorage::AddReferencedObject(WdkTypes::PVOID Object)
{
    ReferencedObjects.emplace_back(Object);
}

void ObjectsStorage::AddHandle(WdkTypes::HANDLE Handle)
{
    Handles.emplace_back(Handle);
}

void ObjectsStorage::AddAllocatedMemory(WdkTypes::PVOID BaseAddress)
{
    AllocatedMemory.emplace_back(BaseAddress);
}

void ObjectsStorage::AddMapping(const Mdl::MAPPING_INFO& Mapping)
{
    Mappings.emplace_back(Mapping);
}

```

`Kernel-Toolkit/Kernel-Toolkit/ObjectsStorage.h`:

```h
#ifndef OBJECTSSTORAGE_H
#define OBJECTSSTORAGE_H

#include <Windows.h>

#include <WdkTypes.h>
#include <CtlTypes.h>
#include <User-Bridge.h>

#include <list>

class ObjectsStorage {
private:
    std::list<WdkTypes::PVOID> ReferencedObjects;
    std::list<WdkTypes::HANDLE> Handles;
    std::list<WdkTypes::PVOID> AllocatedMemory;
    std::list<Mdl::MAPPING_INFO> Mappings;
public:
    ObjectsStorage();
    ~ObjectsStorage();
    void AddReferencedObject(WdkTypes::PVOID Object);
    void AddHandle(WdkTypes::HANDLE Handle);
    void AddAllocatedMemory(WdkTypes::PVOID BaseAddress);
    void AddMapping(const Mdl::MAPPING_INFO& Mapping);
};

#endif // OBJECTSSTORAGE_H

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`LoadableModule/Exports.def`:

```def
NAME LoadableModule
EXPORTS
	OnLoad
	OnUnload
	OnDeviceControl
```

`LoadableModule/LoadableModule.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E52B479E-B60F-4254-98BA-31A18C4B1F70}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>LoadableModule</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
    <ProjectName>LoadableModule</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <_NT_TARGET_VERSION>0x0601</_NT_TARGET_VERSION>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ConfigurationType>Driver</ConfigurationType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <EntryPointSymbol>GsDriverEntry@8</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
    <ClCompile />
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <EntryPointSymbol>GsDriverEntry@8</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
    <ClCompile />
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <EntryPointSymbol>GsDriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
    <ClCompile />
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>GsDriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
    <ClCompile />
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`LoadableModule/LoadableModule.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`LoadableModule/Main.cpp`:

```cpp
#include <wdm.h>

NTSTATUS NTAPI OnLoad(PVOID hModule, LPCWSTR ModuleName)
{
    DbgPrint("[LOADABLE]: OnLoad %ws 0x%p\r\n", ModuleName, hModule);
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI OnUnload()
{
    DbgPrint("[LOADABLE]: OnUnload\r\n");
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI OnDeviceControl(ULONG CtlCode, OPTIONAL PVOID Argument)
{
    DbgPrint("[LOADABLE]: OnDeviceControl: 0x%X, 0x%p\r\n", CtlCode, Argument);
    return STATUS_SUCCESS;
}

extern "C" NTSTATUS NTAPI DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
) {
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);
    return STATUS_SUCCESS;
}
```

`MakeBundle.bat`:

```bat
if not exist ".\Bundle" mkdir ".\Bundle"
if not exist ".\Bundle\i386" mkdir ".\Bundle\i386"
if not exist ".\Bundle\i386\Debug" mkdir ".\Bundle\i386\Debug"
if not exist ".\Bundle\i386\Release" mkdir ".\Bundle\i386\Release"
if not exist ".\Bundle\x64" mkdir ".\Bundle\x64"
if not exist ".\Bundle\x64\Debug" mkdir ".\Bundle\x64\Debug"
if not exist ".\Bundle\x64\Release" mkdir ".\Bundle\x64\Release"

copy /Y /B ".\Debug\User-Bridge.pdb" ".\Bundle\i386\Debug\User-Bridge.pdb"
copy /Y /B ".\Debug\User-Bridge.lib" ".\Bundle\i386\Debug\User-Bridge.lib"
copy /Y /B ".\Debug\User-Bridge.dll" ".\Bundle\i386\Debug\User-Bridge.dll"
copy /Y /B ".\Debug\Kernel-Bridge.sys" ".\Bundle\i386\Debug\Kernel-Bridge.sys"
copy /Y /B ".\Debug\Kernel-Bridge.pdb" ".\Bundle\i386\Debug\Kernel-Bridge.pdb"
copy /Y /B ".\Debug\Kernel-Bridge.inf" ".\Bundle\i386\Debug\Kernel-Bridge.inf"

copy /Y /B ".\Release\User-Bridge.pdb" ".\Bundle\i386\Release\User-Bridge.pdb"
copy /Y /B ".\Release\User-Bridge.lib" ".\Bundle\i386\Release\User-Bridge.lib"
copy /Y /B ".\Release\User-Bridge.dll" ".\Bundle\i386\Release\User-Bridge.dll"
copy /Y /B ".\Release\Kernel-Bridge.sys" ".\Bundle\i386\Release\Kernel-Bridge.sys"
copy /Y /B ".\Release\Kernel-Bridge.pdb" ".\Bundle\i386\Release\Kernel-Bridge.pdb"
copy /Y /B ".\Release\Kernel-Bridge.inf" ".\Bundle\i386\Release\Kernel-Bridge.inf"

copy /Y /B ".\x64\Debug\User-Bridge.pdb" ".\Bundle\x64\Debug\User-Bridge.pdb"
copy /Y /B ".\x64\Debug\User-Bridge.lib" ".\Bundle\x64\Debug\User-Bridge.lib"
copy /Y /B ".\x64\Debug\User-Bridge.dll" ".\Bundle\x64\Debug\User-Bridge.dll"
copy /Y /B ".\x64\Debug\Kernel-Bridge.sys" ".\Bundle\x64\Debug\Kernel-Bridge.sys"
copy /Y /B ".\x64\Debug\Kernel-Bridge.pdb" ".\Bundle\x64\Debug\Kernel-Bridge.pdb"
copy /Y /B ".\x64\Debug\Kernel-Bridge.inf" ".\Bundle\x64\Debug\Kernel-Bridge.inf"

copy /Y /B ".\x64\Release\User-Bridge.pdb" ".\Bundle\x64\Release\User-Bridge.pdb"
copy /Y /B ".\x64\Release\User-Bridge.lib" ".\Bundle\x64\Release\User-Bridge.lib"
copy /Y /B ".\x64\Release\User-Bridge.dll" ".\Bundle\x64\Release\User-Bridge.dll"
copy /Y /B ".\x64\Release\Kernel-Bridge.sys" ".\Bundle\x64\Release\Kernel-Bridge.sys"
copy /Y /B ".\x64\Release\Kernel-Bridge.pdb" ".\Bundle\x64\Release\Kernel-Bridge.pdb"
copy /Y /B ".\x64\Release\Kernel-Bridge.inf" ".\Bundle\x64\Release\Kernel-Bridge.inf"
```

`Python-Bridge/Python-Bridge.py`:

```py
# Ensure to run it as Administrator!

import enum
from ctypes import *


class KernelBridge:
    __api_version = 8

    class KProcessorMode(enum.Enum):
        kernel_mode = 0
        user_mode = 1
        maximum_mode = 2

    class LockOperation(enum.Enum):
        io_read_access = 0
        io_write_access = 1
        io_modify_access = 2

    class MemoryCachingTypeOrig(enum.Enum):
        mm_frame_buffer_cached = 2

    class MemoryCachingType(enum.Enum):
        mm_non_cached = 0
        mm_cached = 1
        mm_write_combined = 2
        mm_hardware_coherent_cached = 3
        mm_non_cached_unordered = 4
        mm_uswc_cached = 5
        mm_maximum_cache_type = 6
        mm_non_mapped = -1

    class SectionInherit(enum.Enum):
        view_share = 1
        view_unmap = 2

    class ObjFlags(enum.Enum):
        obj_inherit = 0x00000002
        obj_permanent = 0x00000010
        obj_exclusive = 0x00000020
        obj_case_insensitive = 0x00000040
        obj_openif = 0x00000080
        obj_openlink = 0x00000100
        obj_kernel_handle = 0x00000200
        obj_force_access_check = 0x00000400
        obj_ignore_impersonated_devicemap = 0x00000800
        obj_dont_reparse = 0x00001000
        obj_valid_attributes = 0x00001FF2

    class ClientId(Structure):
        _fields_ = [("ProcessId", c_uint64),
                    ("ThreadId", c_uint64)]

    class Beeper:
        def __init__(self, kb):
            self.__kb = kb

        def set_beeper_regime(self):
            return self.__kb.KbSetBeeperRegime()

        def start_beeper(self):
            return self.__kb.KbStartBeeper()

        def stop_beeper(self):
            return self.__kb.KbStopBeeper()

        def set_beeper_in(self):
            return self.__kb.KbSetBeeperIn()

        def set_beeper_out(self):
            return self.__kb.KbSetBeeperOut()

        def set_beeper_divider(self, divider):
            return self.__kb.KbSetBeeperDivider(c_ushort(divider))

        def set_beeper_frequency(self, frequency):
            return self.__kb.KbSetBeeperFrequency(c_ushort(frequency))

    class IO:
        def __init__(self, kb):
            self.__kb = kb

        def read_port_byte(self, port_number):
            value = c_byte()
            status = self.__kb.KbReadPortByte(c_ushort(port_number), byref(value))
            return status, value

        def read_port_word(self, port_number):
            value = c_ushort()
            status = self.__kb.KbReadPortWord(c_ushort(port_number), byref(value))
            return status, value

        def read_port_dword(self, port_number):
            value = c_uint()
            status = self.__kb.KbReadPortDword(c_ushort(port_number), byref(value))
            return status, value

        def write_port_byte(self, port_number, byte_value):
            return self.__kb.KbWritePortByte(c_ushort(port_number), c_byte(byte_value))

        def write_port_word(self, port_number, word_value):
            return self.__kb.KbWritePortWord(c_ushort(port_number), c_byte(word_value))

        def write_port_dword(self, port_number, dword_value):
            return self.__kb.KbWritePortDword(c_ushort(port_number), c_byte(dword_value))

    class Iopl:
        def __init__(self, kb):
            self.__kb = kb

        def raise_iopl(self):
            return self.__kb.KbRaiseIopl()

        def reset_iopl(self):
            return self.__kb.KbResetIopl()

    class CPU:
        class CpuidInfo(Structure):
            _fields_ = [("EAX", c_uint),
                        ("EBX", c_uint),
                        ("ECX", c_uint),
                        ("EDX", c_uint)]

        def __init__(self, kb):
            self.__kb = kb

        def cli(self):
            return self.__kb.KbCli()

        def sti(self):
            return self.__kb.KbSti()

        def hlt(self):
            return self.__kb.KbHlt()

        def rdmsr(self, index):
            value = c_uint64()
            status = self.__kb.KbReadMsr(c_uint(index), byref(value))
            return status, value

        def wrmsr(self, index, value):
            return self.__kb.KbWriteMsr(c_uint(index), c_uint64(value))

        def cpuid(self, function_id_eax):
            info = self.CpuidInfo()
            status = self.__kb.KbCpuid(c_uint(function_id_eax), byref(info))
            return status, info

        def cpuidex(self, function_id_eax, subfunction_id_ecx):
            info = self.CpuidInfo()
            status = self.__kb.KbCpuidEx(c_uint(function_id_eax), c_uint(subfunction_id_ecx), byref(info))
            return status, info

        def rdpmc(self, index):
            value = c_uint64()
            status = self.__kb.KbReadPmc(c_uint(index), byref(value))
            return status, value

        def rdtsc(self):
            value = c_uint64()
            status = self.__kb.KbReadTsc(byref(value))
            return status, value

        def rdtscp(self):
            value = c_uint64()
            aux = c_uint()
            status = self.__kb.KbReadTsc(byref(value), byref(aux))
            return status, value, aux

    class VirtualMemory:
        def __init__(self, kb):
            self.__kb = kb

        def alloc_kernel_memory(self, size, executable):
            ptr = c_uint64()
            status = self.__kb.KbAllocKernelMemory(c_uint(size), c_byte(executable), byref(ptr))
            return status, ptr

        def free_kernel_memory(self, ptr):
            return self.__kb.KbFreeKernelMemory(c_uint64(ptr))

        def alloc_non_cached_memory(self, size):
            ptr = c_uint64()
            status = self.__kb.KbAllocNonCachedMemory(c_uint(size), byref(ptr))
            return status, ptr

        def free_non_cached_memory(self, ptr, size):
            return self.__kb.KbFreeNonCachedMemory(c_uint64(ptr), c_uint(size))

        def copy_move_memory(self, dst, src, size, intersects):
            return self.__kb.KbCopyMoveMemory(c_uint64(dst), c_uint64(src), c_uint(size), c_byte(intersects))

        def fill_memory(self, ptr, filler, size):
            return self.__kb.KbFillMemory(c_uint64(ptr), c_byte(filler), c_uint(size))

        def equal_memory(self, src, dst, size):
            equals = c_byte()
            status = self.__kb.KbEqualMemory(c_uint64(src), c_uint64(dst), c_uint(size), byref(equals))
            return status, equals

    class Mdl:
        def __init__(self, kb):
            self.__kb = kb

        def allocate_mdl(self, virtual_address, size):
            mdl = c_uint64()
            status = self.__kb.KbAllocateMdl(c_uint64(virtual_address), c_uint(size), byref(mdl))
            return status, mdl

        def probe_and_lock_pages(self, pid, mdl, processor_mode, lock_operation):
            return self.__kb.KbProbeAndLockPages(
                c_uint(pid),
                c_uint64(mdl),
                c_uint(processor_mode),
                c_uint(lock_operation)
            )

        def map_mdl(self, src_pid, dst_pid, mdl, need_probe_and_lock, map_to_address_space,
                    protect, cache_type, user_requested_address):
            ptr = c_uint64()
            status = self.__kb.KbMapMdl(
                byref(ptr),
                c_uint64(src_pid),
                c_uint64(dst_pid),
                c_uint64(mdl),
                c_byte(need_probe_and_lock),
                c_uint(map_to_address_space),
                c_uint(protect),
                c_uint(cache_type),
                c_uint64(user_requested_address)
            )
            return status, ptr

        def protect_mapped_memory(self, mdl, protect):
            return self.__kb.KbProtectMappedMemory(c_uint64(mdl), c_uint(protect))

        def unmap_mdl(self, mdl, mapped_memory, need_unlock):
            return self.__kb.KbUnmapMdl(c_uint64(mdl), c_uint64(mapped_memory), c_byte(need_unlock))

        def unlock_pages(self, mdl):
            return self.__kb.KbUnlockPages(c_uint64(mdl))

        def free_mdl(self, mdl):
            return self.__kb.KbFreeMdl(c_uint64(mdl))

        class MappingInfo(Structure):
            _fields_ = [("MappedAddress", c_uint64),
                        ("Mdl", c_uint64)]

        def map_memory(self, src_pid, dst_pid, virtual_address, size, map_to_address_space,
                       protect, cache_type, user_requested_address):
            mapping_info = self.MappingInfo()
            status = self.__kb.KbMapMemory(
                byref(mapping_info),
                c_uint64(src_pid),
                c_uint64(dst_pid),
                c_uint64(virtual_address),
                c_uint(size),
                c_uint(map_to_address_space),
                c_uint(protect),
                c_uint(cache_type),
                c_uint64(user_requested_address)
            )
            return status, mapping_info

        def unmap_memory(self, mapping_info):
            return self.__kb.KbUnmapMemory(byref(mapping_info))

    class PhysicalMemory:
        def __init__(self, kb):
            self.__kb = kb

        def alloc_physical_memory(self, lowest_acceptable, highest_acceptable, boundary_multiple, size, caching_type):
            ptr = c_uint64()
            status = self.__kb.KbAllocPhysicalMemory(
                c_uint64(lowest_acceptable),
                c_uint64(highest_acceptable),
                c_uint64(boundary_multiple),
                c_uint(size),
                c_uint(caching_type)
            )
            return status, ptr

        def free_physical_memory(self, address):
            return self.__kb.KbFreePhysicalMemory(c_uint64(address))

        def map_physical_memory(self, physical_address, size, caching_type):
            ptr = c_uint64()
            status = self.__kb.KbMapPhysicalMemory(c_uint64(physical_address), c_uint(size), c_uint(caching_type))
            return status, ptr

        def unmap_physical_memory(self, virtual_address, size):
            return self.__kb.KbUnmapPhysicalMemory(c_uint64(virtual_address), c_uint(size))

        def get_physical_address(self, process, virtual_address):
            ptr = c_uint64()
            status = self.__kb.KbGetPhysicalAddress(c_uint64(process), c_uint64(virtual_address), byref(ptr))
            return status, ptr

        def get_virtual_for_physical(self, physical_address):
            ptr = c_uint64()
            status = self.__kb.KbGetVirtualForPhysical(c_uint64(physical_address), byref(ptr))
            return status, ptr

        def read_physical_memory(self, physical_address, buffer, size, caching_type):
            return self.__kb.KbReadPhysicalMemory(
                c_uint64(physical_address),
                c_void_p(buffer),
                c_uint(size),
                c_uint(caching_type)
            )

        def write_physical_memory(self, physical_address, buffer, size, caching_type):
            return self.__kb.KbWritePhysicalMemory(
                c_uint64(physical_address),
                c_void_p(buffer),
                c_uint(size),
                c_uint(caching_type)
            )

        def read_dmi_memory(self, buffer, size):
            return self.__kb.KbReadDmiMemory(c_void_p(buffer), c_uint(size))

    class Processes:
        def __init__(self, kb):
            self.__kb = kb

        def get_eprocess(self, pid):
            peprocess = c_uint64()
            status = self.__kb.KbGetEprocess(c_uint64(pid), byref(peprocess))
            return status, peprocess

        def get_ethread(self, pid):
            pethread = c_uint64()
            status = self.__kb.KbGetEthread(c_uint64(pid), byref(pethread))
            return status, pethread

        def open_process(self, pid, access_mask, obj_attributes):
            handle = c_uint64()
            status = self.__kb.KbOpenProcess(c_uint64(pid), byref(handle), c_uint(access_mask), c_uint(obj_attributes))
            return status, handle

        def open_process_by_ptr(self, peprocess, access_mask, obj_attributes, processor_mode):
            handle = c_uint64()
            status = self.__kb.KbOpenProcessByPointer(
                c_uint64(peprocess),
                byref(handle),
                c_uint(access_mask),
                c_uint(obj_attributes),
                c_uint(processor_mode)
            )
            return status, handle

        def open_thread(self, tid, access_mask, obj_attributes):
            handle = c_uint64()
            status = self.__kb.KbOpenThread(c_uint64(tid), byref(handle), c_uint(access_mask), c_uint(obj_attributes))
            return status, handle

        def open_thread_by_ptr(self, pethread, access_mask, obj_attributes, processor_mode):
            handle = c_uint64()
            status = self.__kb.KbOpenThreadByPointer(
                c_uint64(pethread),
                byref(handle),
                c_uint(access_mask),
                c_uint(obj_attributes),
                c_uint(processor_mode)
            )
            return status, handle

        def dereference_object(self, object_ptr):
            return self.__kb.KbDereferenceObject(c_uint64(object_ptr))

        def close_handle(self, handle):
            return self.__kb.KbCloseHandle(c_uint64(handle))

        def query_information_process(self, handle, info_class, buffer, size, return_length):
            return self.__kb.KbQueryInformationProcess(
                c_uint64(handle),
                c_uint(info_class),
                c_void_p(buffer),
                c_uint(size),
                byref(return_length)
            )

        def set_information_process(self, handle, info_class, buffer, size):
            return self.__kb.KbSetInformationProcess(
                c_uint64(handle),
                c_uint(info_class),
                c_void_p(buffer),
                c_uint(size)
            )

        def query_information_thread(self, handle, info_class, buffer, size, return_length):
            return self.__kb.KbQueryInformationThread(
                c_uint64(handle),
                c_uint(info_class),
                c_void_p(buffer),
                c_uint(size),
                byref(return_length)
            )

        def set_information_thread(self, handle, info_class, buffer, size):
            return self.__kb.KbSetInformationThread(
                c_uint64(handle),
                c_uint(info_class),
                c_void_p(buffer),
                c_uint(size)
            )

        def create_user_thread(self, pid, routine, arg, create_suspended):
            client = KernelBridge.ClientId()
            handle = c_uint64()
            status = self.__kb.KbCreateUserThread(
                c_uint(pid),
                c_uint64(routine),
                c_uint64(arg),
                c_uint(create_suspended),
                byref(client),
                byref(handle)
            )
            return status, client, handle

        def create_system_thread(self, pid, routine, arg):
            client = KernelBridge.ClientId()
            handle = c_uint64()
            status = self.__kb.KbCreateSystemThread(
                c_uint(pid),
                c_uint64(routine),
                c_uint64(arg),
                byref(client),
                byref(handle)
            )
            return status, client, handle

        def suspend_process(self, pid):
            return self.__kb.KbSuspendProcess(c_uint(pid))

        def resume_process(self, pid):
            return self.__kb.KbResumeProcess(c_uint(pid))

        def get_thread_context(self, tid, context, context_size, processor_mode):
            return self.__kb.KbGetThreadContext(
                c_uint(tid),
                c_void_p(context),
                c_uint(context_size),
                c_uint(processor_mode)
            )

        def set_thread_context(self, tid, context, context_size, processor_mode):
            return self.__kb.KbSetThreadContext(
                c_uint(tid),
                c_void_p(context),
                c_uint(context_size),
                c_uint(processor_mode)
            )

        def alloc_user_memory(self, pid, protect, size):
            ptr = c_uint64()
            status = self.__kb.KbAllocUserMemory(c_uint(pid), c_uint(protect), c_uint(size), byref(ptr))
            return status, ptr

        def free_user_memory(self, pid, ptr):
            return self.__kb.KbFreeUserMemory(c_uint(pid), c_uint64(ptr))

        def secure_virtual_memory(self, pid, ptr, size, protect):
            handle = c_uint64()
            status = self.__kb.KbSecureVirtualMemory(
                c_uint(pid),
                c_uint64(ptr),
                c_uint(size),
                c_uint(protect),
                byref(handle)
            )
            return status, handle

        def unsecure_virtual_memory(self, pid, secure_handle):
            return self.__kb.KbUnsecureVirtualMemory(c_uint(pid), c_uint64(secure_handle))

        def read_process_memory(self, pid, address, buffer, size, access_mode):
            return self.__kb.KbReadProcessMemory(
                c_uint(pid),
                c_uint64(address),
                c_void_p(buffer),
                c_uint(size),
                c_uint(access_mode)
            )

        def write_process_memory(self, pid, address, buffer, size, access_mode, perform_copy_on_write):
            return self.__kb.KbWriteProcessMemory(
                c_uint(pid),
                c_uint64(address),
                c_void_p(buffer),
                c_uint(size),
                c_uint(access_mode),
                c_byte(perform_copy_on_write)
            )

        def get_process_cr3_cr4(self, pid):
            cr3 = c_uint64()
            cr4 = c_uint64()
            status = self.__kb.KbGetProcessCr3Cr4(c_uint(pid), byref(cr3), byref(cr4))
            return status, cr3, cr4

        def queue_user_apc(self, tid, routine, arg):
            return self.__kb.KbQueueUserApc(c_uint(tid), c_uint64(routine), c_uint64(arg))

    class Sections:
        def __init__(self, kb):
            self.__kb = kb

        def create_section(self, name, max_size, access, obj_flags, protection, allocation_attributes, hfile):
            handle = c_uint64()
            status = self.__kb.KbCreateSection(
                byref(handle),
                c_wchar_p(name),
                c_uint64(max_size),
                c_uint(access),
                c_uint(obj_flags),
                c_uint(protection),
                c_uint(allocation_attributes),
                c_uint64(hfile)
            )
            return status, handle

        def open_section(self, name, access, obj_flags):
            handle = c_uint64()
            status = self.__kb.KbOpenSection(byref(handle), c_wchar_p(name), c_uint(access), c_uint(obj_flags))
            return status, handle

        def map_view_of_section(
                self,
                hsection,
                hprocess,
                desired_base_address,
                commit_size,
                desired_section_offset,
                desired_view_size,
                section_inherit,
                allocation_type,
                protect
        ):
            ptr = c_uint64(desired_base_address)
            offset = c_uint64(desired_section_offset)
            view_size = c_uint64(desired_view_size)
            status = self.__kb.KbMapViewOfSection(
                c_uint64(hsection),
                c_uint64(hprocess),
                byref(ptr),
                c_uint(commit_size),
                byref(offset),
                byref(view_size),
                c_uint(section_inherit),
                c_uint(allocation_type),
                c_uint(protect)
            )
            return status, ptr, offset, view_size

        def unmap_view_of_section(self, hprocess, base_address):
            return self.__kb.KbUnmapViewOfSection(c_uint64(hprocess), c_uint64(base_address))

    class KernelShells:
        def __init__(self, kb):
            self.__kb = kb

        def execute_shell_code(self, routine, arg):
            result = c_uint()
            status = self.__kb.KbExecuteShellCode(c_void_p(routine), c_void_p(arg), byref(result))
            return status, result

    class LoadableModules:
        def __init__(self, kb):
            self.__kb = kb

        def create_driver(self, driver_name, driver_entry):
            return self.__kb.KbCreateDriver(c_wchar_p(driver_name), c_uint64(driver_entry))

        def load_module(self, hmodule, module_name, on_load, on_unload, on_device_control):
            return self.__kb.KbLoadModule(
                c_uint64(hmodule),
                c_wchar_p(module_name),
                c_uint64(on_load),
                c_uint64(on_unload),
                c_uint64(on_device_control)
            )

        def unload_module(self, hmodule):
            return self.__kb.KbUnloadModule(c_uint64(hmodule))

        def get_module_handle(self, module_name):
            hmodule = c_uint64()
            status = self.__kb.KbGetModuleHandle(c_wchar_p(module_name), byref(hmodule))
            return status, hmodule

        def call_module(self, hmodule, ctl_code, arg):
            return self.__kb.KbCallModule(c_uint64(hmodule), c_uint(ctl_code), c_uint64(arg))

    class Pci:
        def __init__(self, kb):
            self.__kb = kb

        def read_pci_config(self, pci_address, pci_offset, buffer, size):
            bytes_read = c_uint()
            status = self.__kb.KbReadPciConfig(
                c_uint(pci_address),
                c_uint(pci_offset),
                c_void_p(buffer),
                c_uint(size),
                byref(bytes_read)
            )
            return status, bytes_read

        def write_pci_config(self, pci_address, pci_offset, buffer, size):
            bytes_written = c_uint()
            status = self.__kb.KbWritePciConfig(
                c_uint(pci_address),
                c_uint(pci_offset),
                c_void_p(buffer),
                c_uint(size),
                byref(bytes_written)
            )
            return status, bytes_written

    class Hypervisor:
        def __init__(self, kb):
            self.__kb = kb

        def vmm_enable(self):
            return self.__kb.KbVmmEnable()

        def vmm_disable(self):
            return self.__kb.KbVmmDisable()

    class Stuff:
        def __init__(self, kb):
            self.__kb = kb

        def get_kernel_proc_address(self, routine_name):
            ptr = c_uint64()
            status = self.__kb.KbGetKernelProcAddress(c_wchar_p(routine_name), byref(ptr))
            return status, ptr

        def stall_execution_processor(self, microseconds):
            return self.__kb.KbStallExecutionProcessor(c_uint(microseconds))

        def bugcheck(self, error_code):
            return self.__kb.KbBugCheck(c_uint(error_code))

        def find_signature(self, pid, memory, size, sig, mask):
            found_address = c_uint64()
            status = self.__kb.KbFindSignature(
                c_uint(pid),
                c_uint64(memory),
                c_uint(size),
                c_char_p(sig),
                c_char_p(mask),
                byref(found_address)
            )
            return status, found_address

    def __init__(self, dll="User-Bridge.dll"):
        self.__kb = WinDLL(dll)
        self.beeper = self.Beeper(self.__kb)
        self.io = self.IO(self.__kb)
        self.iopl = self.Iopl(self.__kb)
        self.cpu = self.CPU(self.__kb)
        self.virtual_memory = self.VirtualMemory(self.__kb)
        self.mdl = self.Mdl(self.__kb)
        self.physical_memory = self.PhysicalMemory(self.__kb)
        self.processes = self.Processes(self.__kb)
        self.sections = self.Sections(self.__kb)
        self.kernel_shells = self.KernelShells(self.__kb)
        self.loadable_modules = self.LoadableModules(self.__kb)
        self.pci = self.Pci(self.__kb)
        self.hypervisor = self.Hypervisor(self.__kb)
        self.stuff = self.Stuff(self.__kb)

    def load_as_driver(self, driver_path):
        return self.__kb.KbLoadAsDriver(c_wchar_p(driver_path))

    def load_as_filter(self, driver_path, altitude='260000'):
        return self.__kb.KbLoadAsFilter(c_wchar_p(driver_path), c_wchar_p(altitude))

    def unload(self):
        return self.__kb.KbUnload()

    def get_driver_api_version(self):
        return self.__kb.KbGetDriverApiVersion()

    def get_user_api_version(self):
        return self.__kb.KbGetUserApiVersion()

    def get_python_api_version(self):
        return self.__api_version

    def get_handles_count(self):
        count = c_uint()
        status = self.__kb.KbGetHandlesCount(byref(count))
        return status, count

```

`README.md`:

```md
# The Kernel-Bridge Framework
The "Kernel-Bridge" project is a C++20-ready Windows kernel driver template, development framework and
kernel-mode API and wrappers.  
  
[Precompiled and signed binaries with the SecureBoot support](https://github.com/HoShiMin/Kernel-Bridge/releases)  
[Delphi bindings](https://github.com/diversenok/Kernel-Bridge-Delphi-Connector)
  
### ✔ Capabilities:
* Hypervisor (both Intel VT-x/EPT and AMD-V/RVI) with the Hyper-V support
* Extremely fast hypervisor-based memory interceptions and hiding (+ support of Write-only pages), VT-x only
* Support of [HookLib](https://github.com/HoShiMin/HookLib) and [Zydis](https://github.com/zyantific/zydis)
* IO-ports (+ 'in/out/cli/sti' usermode forwarding by IOPL)
* System beeper
* MSRs, CPUID, TSC and performance counters (RDPMC)
* DMI/SMBIOS memory reading
* Physical memory (allocations, RW, mappings)
* Kernel memory management (allocations, mappings, transitions)
* Usermode memory management (allocations in processes etc.)
* Direct UM->KM and KM->UM memory transitions
* Direct PTE-based memory management
* Direct MDL management
* Obtaining processes/threads handles from kernel
* Reading and writing memory of another processes
* Suspending/resuming/termination processes
* Creating kernel and usermode threads
* Memory mappings between usermode and kernel
* Remote code execution (APCs delivery)
* Execution of custom usermode shellcodes
* Unsigned drivers mapping
* Processes, threads, handles and modules usermode callbacks (`ObRegisterCallbacks` & `PsSet***NotifyRoutine`)
* Minifilter with usermode callbacks
* PDB parsing
* Signatures and patterns scanning
* Sections management (to map `\\Device\PhysicalMemory` and more)
* Python binding
  
### ➰ In development and plans:
* Qt-based GUI for the kernel-hacking and memory researching framework
* Kernel WinSock support
* Extensions for the RTL: hooks, injections, disassembling
* Kernel loadable modules with SEH support
  
Driver template has full support of C++ static and global initializers and all of C++20 features (without C++ exceptions). All of API modules are easy-to-use and have no external dependiencies, so you can include them to your own C++ drivers. All of API functions are grouped into a logical categories into namespaces, so you can quickly find all functions you want.
  
### 💦 Driver template has:
* Support of METHOD_BUFFERED, METHOD_IN/OUT_DIRECT and METHOD_NEITHER
* Minifilter loading and filtering routines templates
* SAL-annotations and self-documented API
* Ready-to-use IOCTLs handling routine
* Out-of-box STL support
* Static Driver Verifier tests passing
  
### 💨 Building and using:  
Download [Microsoft Visual Studio Community](https://visualstudio.microsoft.com/downloads/) and [Windows Driver Kit](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk).  
For driver testing use [VMware Player](https://my.vmware.com/en/web/vmware/free#desktop_end_user_computing/vmware_workstation_player/14_0).  
For load an unsigned drivers you should to enable Test-mode of Windows and disable signs checkings:
```
- Disable signatures checkings (allow to install unsigned drivers):
bcdedit.exe /set loadoptions DISABLE_INTEGRITY_CHECKS
bcdedit.exe /set TESTSIGNING ON

- Enable signatures checkings (deny to install unsigned drivers):
bcdedit.exe /set loadoptions ENABLE_INTEGRITY_CHECKS
bcdedit.exe /set TESTSIGNING OFF

- Enable support of kernel debugger (WinDbg and Kernel Debugger from WDK):
bcdedit.exe /debug on   -  enable support of kernel debugging
bcdedit.exe /debug off  -  disable it
```
  
#### Communication with usermode apps:  
For communication with usermode you should use "User-Bridge" wrappers as standalone \*.cpp/\*.h modules or as \*.dll.  
All required headers are `WdkTypes.h`, `CtlTypes.h` and `User-Bridge.h`. For using an extended features like minifilter callbacks, you should also use `FltTypes.h`, `CommPort.h` and `Flt-Bridge.h`. Some of ready-to-use RTL-functions (like an unsigned drivers mapping) you can find in `Rtl-Bridge.h`.
  
#### Files hierarchy:
`/User-Bridge/API/` - usermode API and wrappers for all functions of KB  
`/Kernel-Bridge/API/` - standalone kernel API for using in C++ drivers  
`/Kernel-Bridge/Kernel-Bridge/` - driver template files  
`/SharedTypes/` - shared types headers required for UM and KM modules  
`/CommonTypes/` - common user- and kernelmode headers and types  
`/Python-Bridge/` - Python binding  
`/Kernel-Tests/` - unit-tests for UM and KM modules and common functions  
  
#### Example (using of KbReadProcessMemory):
```cpp
#include <Windows.h>

#include "WdkTypes.h"
#include "CtlTypes.h"
#include "User-Bridge.h"

using namespace Processes::MemoryManagement;

...

// Loading as minifilter (it allows to use extended features):
KbLoader::KbLoadAsFilter(L"N:\\Folder\\Kernel-Bridge.sys", L"260000");

constexpr int Size = 64;
UCHAR Buffer[Size] = {};
 
BOOL Status = KbReadProcessMemory(
    ProcessId,
    0x7FFF0000, // Desired address in context of ProcessId
    &Buffer,
    Size
);

KbLoader::KbUnload();
```

```

`SharedTypes/CtlTypes.h`:

```h
#pragma once

constexpr int KB_API_VERSION = 8;

namespace Ctls
{
    enum KbCtlIndices {
        // Driver management:
        /* 00 */ KbGetDriverApiVersion,
        /* 01 */ KbGetHandlesCount,

        // Beeper:
        /* 02 */ KbSetBeeperRegime,
        /* 03 */ KbStartBeeper,
        /* 04 */ KbStopBeeper,
        /* 05 */ KbSetBeeperIn,
        /* 06 */ KbSetBeeperOut,
        /* 07 */ KbSetBeeperDivider,
        /* 08 */ KbSetBeeperFrequency,

        // IO-Ports:
        /* 09 */ KbReadPort,
        /* 10 */ KbReadPortString,
        /* 11 */ KbWritePort,
        /* 12 */ KbWritePortString,

        // Interrupts:
        /* 13 */ KbCli,
        /* 14 */ KbSti,
        /* 15 */ KbHlt,

        // MSR:
        /* 16 */ KbReadMsr,
        /* 17 */ KbWriteMsr,

        // CPUID:
        /* 18 */ KbCpuid,
        /* 19 */ KbCpuidEx,

        // TSC & PMC:
        /* 20 */ KbReadPmc,
        /* 21 */ KbReadTsc,
        /* 22 */ KbReadTscp,

        // Memory management:
        /* 23 */ KbAllocKernelMemory,
        /* 24 */ KbFreeKernelMemory,
        /* 25 */ KbAllocNonCachedMemory,
        /* 26 */ KbFreeNonCachedMemory,
        /* 27 */ KbCopyMoveMemory,
        /* 28 */ KbFillMemory,
        /* 29 */ KbEqualMemory,

        // Memory mappings:
        /* 30 */ KbAllocateMdl,
        /* 31 */ KbProbeAndLockPages,
        /* 32 */ KbMapMdl,
        /* 33 */ KbProtectMappedMemory,
        /* 34 */ KbUnmapMdl,
        /* 35 */ KbUnlockPages,
        /* 36 */ KbFreeMdl,
        /* 37 */ KbMapMemory,
        /* 38 */ KbUnmapMemory,

        // Physical memory:
        /* 39 */ KbAllocPhysicalMemory,
        /* 40 */ KbFreePhysicalMemory,
        /* 41 */ KbMapPhysicalMemory,
        /* 42 */ KbUnmapPhysicalMemory,
        /* 43 */ KbGetPhysicalAddress,
        /* 44 */ KbGetVirtualForPhysical,
        /* 45 */ KbReadPhysicalMemory,
        /* 46 */ KbWritePhysicalMemory,
        /* 47 */ KbReadDmiMemory,

        // Processes & Threads:
        /* 48 */ KbGetEprocess,
        /* 49 */ KbGetEthread,
        /* 50 */ KbOpenProcess,
        /* 51 */ KbOpenProcessByPointer,
        /* 52 */ KbOpenThread,
        /* 53 */ KbOpenThreadByPointer,
        /* 54 */ KbDereferenceObject,
        /* 55 */ KbCloseHandle,
        /* 56 */ KbQueryInformationProcess,
        /* 57 */ KbSetInformationProcess,
        /* 58 */ KbQueryInformationThread,
        /* 59 */ KbSetInformationThread,
        /* 60 */ KbAllocUserMemory,
        /* 61 */ KbFreeUserMemory,
        /* 62 */ KbSecureVirtualMemory,
        /* 63 */ KbUnsecureVirtualMemory,
        /* 64 */ KbReadProcessMemory,
        /* 65 */ KbWriteProcessMemory,
        /* 66 */ KbTriggerCopyOnWrite,
        /* 67 */ KbSuspendProcess,
        /* 68 */ KbResumeProcess,
        /* 69 */ KbGetThreadContext,
        /* 70 */ KbSetThreadContext,
        /* 71 */ KbCreateUserThread,
        /* 72 */ KbCreateSystemThread,
        /* 73 */ KbQueueUserApc,
        /* 74 */ KbRaiseIopl,
        /* 75 */ KbResetIopl,
        /* 76 */ KbGetProcessCr3Cr4,

        // Sections:
        /* 77 */ KbCreateSection,
        /* 78 */ KbOpenSection,
        /* 79 */ KbMapViewOfSection,
        /* 80 */ KbUnmapViewOfSection,

        // Loadable modules:
        /* 81 */ KbCreateDriver,
        /* 82 */ KbLoadModule,
        /* 83 */ KbGetModuleHandle,
        /* 84 */ KbCallModule,
        /* 85 */ KbUnloadModule,

        // Hypervisor:
        /* 86 */ KbVmmEnable,
        /* 87 */ KbVmmDisable,
        /* 88 */ KbVmmInterceptPage,
        /* 89 */ KbVmmDeinterceptPage,

        // Stuff u kn0w:
        /* 90 */ KbExecuteShellCode,
        /* 91 */ KbGetKernelProcAddress,
        /* 92 */ KbStallExecutionProcessor,
        /* 93 */ KbBugCheck,
        /* 94 */ KbFindSignature
    };
}

DECLARE_STRUCT(KB_GET_DRIVER_API_VERSION_OUT, {
    ULONG Version;
});

DECLARE_STRUCT(KB_GET_HANDLES_COUNT_OUT, {
    ULONG HandlesCount;
});

DECLARE_STRUCT(KB_SET_BEEPER_DIVIDER_IN, { 
    USHORT Divider; 
});

DECLARE_STRUCT(KB_SET_BEEPER_FREQUENCY_IN, { 
    USHORT Frequency;
});

DECLARE_STRUCT(KB_READ_PORT_IN, {
    USHORT PortNumber;
});

DECLARE_STRUCT(KB_READ_PORT_BYTE_OUT, {
    UCHAR Value;
});

DECLARE_STRUCT(KB_READ_PORT_WORD_OUT, {
    USHORT Value;
});

DECLARE_STRUCT(KB_READ_PORT_DWORD_OUT, {
    ULONG Value;
});

DECLARE_STRUCT(KB_READ_PORT_STRING_IN, {
    USHORT PortNumber;
    USHORT Granularity; // sizeof(UCHAR/USHORT/ULONG)
    ULONG Count; // Will be write 'Count' times of 'Granularity' bytes
});

DECLARE_STRUCT(KB_READ_PORT_STRING_OUT, {
    union {
        UCHAR ByteString[1];
        USHORT WordString[1];
        ULONG DwordString[1];
    };    
});

DECLARE_STRUCT(KB_WRITE_PORT_IN, {
    USHORT PortNumber;
    USHORT Granularity;
    union {
        UCHAR Byte;
        USHORT Word;
        ULONG Dword;
    };   
});

DECLARE_STRUCT(KB_WRITE_PORT_STRING_IN, {
    USHORT PortNumber;
    USHORT Granularity; // sizeof(UCHAR/USHORT/ULONG)
    ULONG Count; // Will be write 'Count' times of 'Granularity' bytes
    ULONG BufferSize;
    WdkTypes::PVOID Buffer;
});

DECLARE_STRUCT(KB_READ_MSR_IN, {
    ULONG Index;
});

DECLARE_STRUCT(KB_READ_MSR_OUT, {
    UINT64 Value;
});

DECLARE_STRUCT(KB_WRITE_MSR_IN, {
    UINT64 Value;
    ULONG Index;
});

DECLARE_STRUCT(KB_CPUID_IN, {
    ULONG FunctionIdEax;
});

DECLARE_STRUCT(KB_CPUIDEX_IN, {
    ULONG FunctionIdEax;
    ULONG SubfunctionIdEcx;
});

DECLARE_STRUCT(KB_CPUID_OUT, {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
});

DECLARE_STRUCT(KB_READ_PMC_IN, {
    ULONG Counter;
});

DECLARE_STRUCT(KB_READ_PMC_OUT, {
    UINT64 Value;
});

DECLARE_STRUCT(KB_READ_TSC_OUT, {
    UINT64 Value;
});

DECLARE_STRUCT(KB_READ_TSCP_OUT, {
    UINT64 Value;
    UINT32 TscAux;
});

DECLARE_STRUCT(KB_ALLOC_KERNEL_MEMORY_IN, {
    ULONG Size;
    BOOLEAN Executable;
});

DECLARE_STRUCT(KB_ALLOC_KERNEL_MEMORY_OUT, {
    WdkTypes::PVOID KernelAddress;
});

DECLARE_STRUCT(KB_FREE_KERNEL_MEMORY_IN, {
    WdkTypes::PVOID KernelAddress;
});

DECLARE_STRUCT(KB_ALLOC_NON_CACHED_MEMORY_IN, {
    ULONG Size;
});

DECLARE_STRUCT(KB_ALLOC_NON_CACHED_MEMORY_OUT, {
    WdkTypes::PVOID KernelAddress;
});

DECLARE_STRUCT(KB_FREE_NON_CACHED_MEMORY_IN, {
    WdkTypes::PVOID KernelAddress;
    ULONG Size;
});

DECLARE_STRUCT(KB_COPY_MOVE_MEMORY_IN, {
    WdkTypes::PVOID Src;
    WdkTypes::PVOID Dest;
    ULONG Size;
    BOOLEAN Intersects; // Whether Src and Dest intersects (use memmove if true)
});

DECLARE_STRUCT(KB_FILL_MEMORY_IN, {
    WdkTypes::PVOID Address;
    ULONG Size;
    UCHAR Filler;
});

DECLARE_STRUCT(KB_EQUAL_MEMORY_IN, {
    WdkTypes::PVOID Src;
    WdkTypes::PVOID Dest;
    ULONG Size;
});

DECLARE_STRUCT(KB_EQUAL_MEMORY_OUT, {
    BOOLEAN Equals;
});

DECLARE_STRUCT(KB_ALLOCATE_MDL_IN, {
    WdkTypes::PVOID VirtualAddress;
    ULONG Size;
});

DECLARE_STRUCT(KB_ALLOCATE_MDL_OUT, {
    WdkTypes::PMDL Mdl;    
});

DECLARE_STRUCT(KB_PROBE_AND_LOCK_PAGES_IN, {
    OPTIONAL UINT64 ProcessId;
    WdkTypes::PMDL Mdl;
    WdkTypes::KPROCESSOR_MODE ProcessorMode;
    WdkTypes::LOCK_OPERATION LockOperation;
});

DECLARE_STRUCT(KB_MAP_MDL_IN, {
    OPTIONAL UINT64 SrcProcessId;
    OPTIONAL UINT64 DestProcessId;
    WdkTypes::PMDL Mdl;
    BOOLEAN NeedProbeAndLock;
    WdkTypes::KPROCESSOR_MODE MapToAddressSpace;
    ULONG Protect;
    WdkTypes::MEMORY_CACHING_TYPE CacheType;
    OPTIONAL WdkTypes::PVOID UserRequestedAddress;
});

DECLARE_STRUCT(KB_MAP_MDL_OUT, {
    WdkTypes::PVOID BaseAddress;
});

DECLARE_STRUCT(KB_MAP_MEMORY_IN, {
    OPTIONAL UINT64 SrcProcessId;
    OPTIONAL UINT64 DestProcessId;
    WdkTypes::PVOID VirtualAddress;
    ULONG Size;
    WdkTypes::KPROCESSOR_MODE MapToAddressSpace;
    ULONG Protect;
    WdkTypes::MEMORY_CACHING_TYPE CacheType;
    OPTIONAL WdkTypes::PVOID UserRequestedAddress;
});

DECLARE_STRUCT(KB_MAP_MEMORY_OUT, {
    WdkTypes::PVOID BaseAddress;
    WdkTypes::PMDL Mdl; // Necessary for unmapping, don't change!
});

DECLARE_STRUCT(KB_PROTECT_MAPPED_MEMORY_IN, {
    WdkTypes::PMDL Mdl;
    ULONG Protect;
});

DECLARE_STRUCT(KB_UNMAP_MDL_IN, {
    WdkTypes::PVOID BaseAddress;
    WdkTypes::PMDL Mdl;
    BOOLEAN NeedUnlock;
});

DECLARE_STRUCT(KB_UNLOCK_PAGES_IN, {
    WdkTypes::PMDL Mdl;    
});

DECLARE_STRUCT(KB_FREE_MDL_IN, {
    WdkTypes::PMDL Mdl;    
});

DECLARE_STRUCT(KB_UNMAP_MEMORY_IN, {
    WdkTypes::PVOID BaseAddress;
    WdkTypes::PMDL Mdl;
});

DECLARE_STRUCT(KB_ALLOC_PHYSICAL_MEMORY_IN, {
    WdkTypes::PVOID LowestAcceptableAddress;
    WdkTypes::PVOID HighestAcceptableAddress;
    WdkTypes::PVOID BoundaryAddressMultiple;
    ULONG Size;
    WdkTypes::MEMORY_CACHING_TYPE CachingType;
});

DECLARE_STRUCT(KB_ALLOC_PHYSICAL_MEMORY_OUT, {
    WdkTypes::PVOID Address;
});

DECLARE_STRUCT(KB_FREE_PHYSICAL_MEMORY_IN, {
    WdkTypes::PVOID Address;    
});

DECLARE_STRUCT(KB_MAP_PHYSICAL_MEMORY_IN, {
    WdkTypes::PVOID PhysicalAddress;
    ULONG Size;
    WdkTypes::MEMORY_CACHING_TYPE CachingType;
});

DECLARE_STRUCT(KB_MAP_PHYSICAL_MEMORY_OUT, {
    WdkTypes::PVOID VirtualAddress; 
});

DECLARE_STRUCT(KB_UNMAP_PHYSICAL_MEMORY_IN, {
    WdkTypes::PVOID VirtualAddress;
    ULONG Size;
});

DECLARE_STRUCT(KB_GET_PHYSICAL_ADDRESS_IN, {
    WdkTypes::PEPROCESS Process;
    WdkTypes::PVOID VirtualAddress;
});

DECLARE_STRUCT(KB_GET_PHYSICAL_ADDRESS_OUT, {
    WdkTypes::PVOID PhysicalAddress;
});

DECLARE_STRUCT(KB_GET_VIRTUAL_FOR_PHYSICAL_IN, {
    WdkTypes::PVOID PhysicalAddress; 
});

DECLARE_STRUCT(KB_GET_VIRTUAL_FOR_PHYSICAL_OUT, {
    WdkTypes::PVOID VirtualAddress;
});

DECLARE_STRUCT(KB_READ_WRITE_PHYSICAL_MEMORY_IN, {
    WdkTypes::PVOID PhysicalAddress;
    WdkTypes::PVOID Buffer;
    ULONG Size;
    WdkTypes::MEMORY_CACHING_TYPE CachingType;
});

constexpr int DmiSize = 65536;

DECLARE_STRUCT(KB_READ_DMI_MEMORY_OUT, {
    UCHAR DmiBuffer[DmiSize];
});

DECLARE_STRUCT(KB_GET_EPROCESS_IN, {
    UINT64 ProcessId;
});

DECLARE_STRUCT(KB_GET_EPROCESS_OUT, {
    WdkTypes::PEPROCESS Process;
});

DECLARE_STRUCT(KB_GET_ETHREAD_IN, {
    UINT64 ThreadId;    
});

DECLARE_STRUCT(KB_GET_ETHREAD_OUT, {
    WdkTypes::PETHREAD Thread;
});

DECLARE_STRUCT(KB_OPEN_PROCESS_IN, {
    UINT64 ProcessId;
    ACCESS_MASK Access;
    ULONG Attributes;
});

DECLARE_STRUCT(KB_OPEN_PROCESS_BY_POINTER_IN, {
    WdkTypes::PEPROCESS Process;
    ACCESS_MASK Access;
    ULONG Attributes;
    WdkTypes::KPROCESSOR_MODE ProcessorMode;
});

DECLARE_STRUCT(KB_OPEN_PROCESS_OUT, {
    WdkTypes::HANDLE hProcess;
});

DECLARE_STRUCT(KB_OPEN_THREAD_IN, {
    UINT64 ThreadId;
    ACCESS_MASK Access;
    ULONG Attributes;
});

DECLARE_STRUCT(KB_OPEN_THREAD_BY_POINTER_IN, {
    WdkTypes::PETHREAD Thread;
    ACCESS_MASK Access;
    ULONG Attributes;
    WdkTypes::KPROCESSOR_MODE ProcessorMode;
});

DECLARE_STRUCT(KB_OPEN_THREAD_OUT, {
    WdkTypes::HANDLE hThread;
});

DECLARE_STRUCT(KB_DEREFERENCE_OBJECT_IN, {
    WdkTypes::PVOID Object;
});

DECLARE_STRUCT(KB_CLOSE_HANDLE_IN, {
    WdkTypes::HANDLE Handle;
});

DECLARE_STRUCT(KB_QUERY_INFORMATION_PROCESS_THREAD_IN, {
    WdkTypes::HANDLE Handle;
    WdkTypes::PVOID Buffer;
    WdkTypes::PULONG ReturnLength;
    ULONG InfoClass;
    ULONG Size;
});

DECLARE_STRUCT(KB_SET_INFORMATION_PROCESS_THREAD_IN, {
    WdkTypes::HANDLE Handle;
    WdkTypes::PVOID Buffer;
    ULONG InfoClass;
    ULONG Size;
});

DECLARE_STRUCT(KB_ALLOC_USER_MEMORY_IN, {
    UINT64 ProcessId;
    ULONG Size;
    ULONG Protect;
});

DECLARE_STRUCT(KB_ALLOC_USER_MEMORY_OUT, {
    WdkTypes::PVOID BaseAddress;
});

DECLARE_STRUCT(KB_FREE_USER_MEMORY_IN, {
    UINT64 ProcessId;
    WdkTypes::PVOID BaseAddress;
});

DECLARE_STRUCT(KB_SECURE_VIRTUAL_MEMORY_IN, {
    ULONG ProcessId;
    ULONG ProtectRights;
    WdkTypes::PVOID BaseAddress;
    ULONG Size;
});

DECLARE_STRUCT(KB_SECURE_VIRTUAL_MEMORY_OUT, {
    WdkTypes::HANDLE SecureHandle;    
});

DECLARE_STRUCT(KB_UNSECURE_VIRTUAL_MEMORY_IN, {
    WdkTypes::HANDLE SecureHandle; 
    ULONG ProcessId;
});

DECLARE_STRUCT(KB_READ_PROCESS_MEMORY_IN, {
    OPTIONAL UINT64 ProcessId;
    WdkTypes::PVOID BaseAddress;
    WdkTypes::PVOID Buffer;
    ULONG Size;
});

DECLARE_STRUCT(KB_WRITE_PROCESS_MEMORY_IN, {
    OPTIONAL UINT64 ProcessId;
    WdkTypes::PVOID BaseAddress;
    WdkTypes::PVOID Buffer;
    ULONG Size;
    BOOLEAN PerformCopyOnWrite;
});

DECLARE_STRUCT(KB_TRIGGER_COPY_ON_WRITE_IN, {
    OPTIONAL UINT64 ProcessId;
    WdkTypes::PVOID PageVirtualAddress;
});

DECLARE_STRUCT(KB_SUSPEND_RESUME_PROCESS_IN, {
    UINT64 ProcessId;
});

DECLARE_STRUCT(KB_GET_SET_THREAD_CONTEXT_IN, {
    UINT64 ThreadId;
    ULONG ContextSize; // Must be size of native CONTEXT struct
    WdkTypes::KPROCESSOR_MODE ProcessorMode;
    WdkTypes::PVOID Context; // Pointer to native CONTEXT struct
});

DECLARE_STRUCT(KB_CREATE_USER_THREAD_IN, {
    UINT64 ProcessId;
    WdkTypes::PVOID ThreadRoutine;
    WdkTypes::PVOID Argument;
    BOOLEAN CreateSuspended;
});

DECLARE_STRUCT(KB_CREATE_SYSTEM_THREAD_IN, {
    OPTIONAL UINT64 AssociatedProcessId;
    WdkTypes::PVOID ThreadRoutine;
    WdkTypes::PVOID Argument;
});

DECLARE_STRUCT(KB_CREATE_USER_SYSTEM_THREAD_OUT, {
    WdkTypes::HANDLE hThread;
    WdkTypes::CLIENT_ID ClientId;
});

DECLARE_STRUCT(KB_QUEUE_USER_APC_IN, {
    UINT64 ThreadId;
    WdkTypes::PVOID ApcProc;
    WdkTypes::PVOID Argument;
});

DECLARE_STRUCT(KB_GET_PROCESS_CR3_CR4_IN, {
    UINT64 ProcessId;
});

DECLARE_STRUCT(KB_GET_PROCESS_CR3_CR4_OUT, {
    UINT64 Cr3;
    UINT64 Cr4;
});

DECLARE_STRUCT(KB_CREATE_SECTION_IN, {
    OPTIONAL WdkTypes::LPCWSTR Name;
    UINT64 MaximumSize;
    ACCESS_MASK DesiredAccess;
    ULONG SecObjFlags; // OBJ_***
    ULONG SecPageProtection;
    ULONG AllocationAttributes;
    OPTIONAL WdkTypes::HANDLE hFile;
});

DECLARE_STRUCT(KB_OPEN_SECTION_IN, {
    WdkTypes::LPCWSTR Name;
    ACCESS_MASK DesiredAccess;
    ULONG SecObjFlags; // OBJ_***
});

DECLARE_STRUCT(KB_CREATE_OPEN_SECTION_OUT, {
    WdkTypes::HANDLE hSection;
});

DECLARE_STRUCT(KB_MAP_VIEW_OF_SECTION_IN, {
    WdkTypes::HANDLE hSection;
    WdkTypes::HANDLE hProcess;
    IN WdkTypes::PVOID BaseAddress;
    ULONG CommitSize;
    UINT64 SectionOffset;
    UINT64 ViewSize;
    WdkTypes::SECTION_INHERIT SectionInherit;
    ULONG AllocationType;
    ULONG Win32Protect;
});

DECLARE_STRUCT(KB_MAP_VIEW_OF_SECTION_OUT, {
    WdkTypes::PVOID BaseAddress;
    UINT64 SectionOffset;
    UINT64 ViewSize;
});

DECLARE_STRUCT(KB_UNMAP_VIEW_OF_SECTION_IN, {
    WdkTypes::HANDLE hProcess;
    WdkTypes::PVOID BaseAddress;
});

DECLARE_STRUCT(KB_VMM_INTERCEPT_PAGE_IN, {
    IN WdkTypes::PVOID64 PhysicalAddress;
    IN OPTIONAL WdkTypes::PVOID64 OnReadPhysicalAddress;
    IN OPTIONAL WdkTypes::PVOID64 OnWritePhysicalAddress;
    IN OPTIONAL WdkTypes::PVOID64 OnExecutePhysicalAddress;
    IN OPTIONAL WdkTypes::PVOID64 OnExecuteReadPhysicalAddress;
    IN OPTIONAL WdkTypes::PVOID64 OnExecuteWritePhysicalAddress;
});

DECLARE_STRUCT(KB_VMM_DEINTERCEPT_PAGE_IN, {
    IN WdkTypes::PVOID64 PhysicalAddress;
});

DECLARE_STRUCT(KB_EXECUTE_SHELL_CODE_IN, {
    WdkTypes::PVOID Address;
    WdkTypes::PVOID Argument;
});

DECLARE_STRUCT(KB_EXECUTE_SHELL_CODE_OUT, {
    ULONG Result;    
});

DECLARE_STRUCT(KB_GET_KERNEL_PROC_ADDRESS_IN, {
    WdkTypes::LPCWSTR RoutineName;
    ULONG SizeOfBufferInBytes;
});

DECLARE_STRUCT(KB_GET_KERNEL_PROC_ADDRESS_OUT, {
    WdkTypes::PVOID Address;
});

DECLARE_STRUCT(KB_STALL_EXECUTION_PROCESSOR_IN, {
    ULONG Microseconds;
});

DECLARE_STRUCT(KB_BUG_CHECK_IN, {
    ULONG Status;
});

DECLARE_STRUCT(KB_CREATE_DRIVER_IN, {
    WdkTypes::PVOID DriverEntry;
    WdkTypes::LPCWSTR DriverName;
    ULONG DriverNameSizeInBytes;
});

DECLARE_STRUCT(KB_LOAD_MODULE_IN, {
    WdkTypes::HMODULE hModule;
    WdkTypes::LPCWSTR ModuleName;
    WdkTypes::PVOID OnLoad;
    WdkTypes::PVOID OnUnload;
    WdkTypes::PVOID OnDeviceControl;
});

DECLARE_STRUCT(KB_GET_MODULE_HANDLE_IN, {
    WdkTypes::LPCWSTR ModuleName;    
});

DECLARE_STRUCT(KB_GET_MODULE_HANDLE_OUT, {
    WdkTypes::HMODULE hModule;    
});

DECLARE_STRUCT(KB_CALL_MODULE_IN, {
    WdkTypes::HMODULE hModule;
    WdkTypes::PVOID Argument;
    ULONG CtlCode;
});

DECLARE_STRUCT(KB_UNLOAD_MODULE_IN, {
    WdkTypes::HMODULE hModule;    
});

DECLARE_STRUCT(KB_FIND_SIGNATURE_IN, {
    OPTIONAL UINT64 ProcessId;
    WdkTypes::PVOID Memory;
    ULONG Size;
    WdkTypes::LPCSTR Signature;
    WdkTypes::LPCSTR Mask;
});

DECLARE_STRUCT(KB_FIND_SIGNATURE_OUT, {
    WdkTypes::PVOID Address;    
});
```

`SharedTypes/FltTypes.h`:

```h
#pragma once

enum KbFltTypes {
    KbObCallbacks,
    KbPsProcess,
    KbPsThread,
    KbPsImage,
    KbFltPreCreate,
    KbFltPostCreate,
    KbFltPreRead,
    KbFltPostRead,
    KbFltPreWrite,
    KbFltPostWrite,
    KbFltPreDeviceControl,
    KbFltPostDeviceControl,
    KbFltPreInternalDeviceControl,
    KbFltPostInternalDeviceControl,
    KbFltPreFileSystemControl,
    KbFltPostFileSystemControl,
    KbFltNone
};

DECLARE_STRUCT(KB_FLT_CONTEXT, {
    KbFltTypes Type;
    WdkTypes::CLIENT_ID Client;    
});

DECLARE_STRUCT(KB_FLT_OB_CALLBACK_INFO, {
    WdkTypes::CLIENT_ID Client;
    WdkTypes::CLIENT_ID Target;
    ACCESS_MASK CreateDesiredAccess;
    ACCESS_MASK DuplicateDesiredAccess;
    ACCESS_MASK CreateResultAccess;
    ACCESS_MASK DuplicateResultAccess;
});

DECLARE_STRUCT(KB_FLT_PS_PROCESS_INFO, {
    UINT64 ParentId;
    UINT64 ProcessId;
    BOOLEAN Created;
});

DECLARE_STRUCT(KB_FLT_PS_THREAD_INFO, {
    UINT64 ProcessId;
    UINT64 ThreadId;
    BOOLEAN Created;
});

DECLARE_STRUCT(KB_FLT_PS_IMAGE_INFO, {
    UINT64 ProcessId;
    WdkTypes::PVOID BaseAddress;
    UINT64 ImageSize;
    WCHAR FullImageName[384]; // Fixed size! Enough for paths.
});

DECLARE_STRUCT(KB_FLT_CREATE_INFO, {
    UINT64 ProcessId;
    UINT64 ThreadId;
    ACCESS_MASK AccessMask;
    WdkTypes::NTSTATUS Status;
    WCHAR Path[384]; // Fixed size! Enough for paths.
});

DECLARE_STRUCT(KB_FLT_READ_WRITE_INFO, {
    UINT64 ProcessId;
    UINT64 ThreadId; 
    WdkTypes::PMDL LockedMdl;
    ULONG Size;
    WdkTypes::NTSTATUS Status;
    WCHAR Path[384];
});

DECLARE_STRUCT(KB_FLT_DEVICE_CONTROL_INFO, {
    UINT64 ProcessId;
    UINT64 ThreadId; 
    WdkTypes::PMDL InputLockedMdl;
    WdkTypes::PMDL OutputLockedMdl;
    ULONG InputSize;
    ULONG OutputSize;
    ULONG Ioctl;
    WdkTypes::NTSTATUS Status;
    WCHAR Path[384];
});
```

`SharedTypes/WdkTypes.h`:

```h
#pragma once

#define DECLARE_STRUCT(Name, Fields) \
    using Name = struct Fields;      \
    using P##Name = Name*

// Direct WDK types port for use in usermode:
namespace WdkTypes {
    enum KPROCESSOR_MODE {
        KernelMode,
        UserMode,
        MaximumMode
    };

    enum LOCK_OPERATION {
        IoReadAccess,
        IoWriteAccess,
        IoModifyAccess
    };

    enum MEMORY_CACHING_TYPE_ORIG {
        MmFrameBufferCached = 2        
    };

    enum MEMORY_CACHING_TYPE {
        MmNonCached = FALSE,
        MmCached = TRUE,
        MmWriteCombined = MmFrameBufferCached,
        MmHardwareCoherentCached,
        MmNonCachedUnordered, // IA64
        MmUSWCCached,
        MmMaximumCacheType,
        MmNotMapped = -1
    };

    enum SECTION_INHERIT {
        ViewShare = 1,
        ViewUnmap = 2
    };

    // Using universal x64 types for compatibility with x32 and x64:
    using NTSTATUS  = unsigned int;
    using HANDLE    = unsigned long long;
    using PVOID     = unsigned long long;
    using PVOID64   = unsigned long long;
    using PEPROCESS = PVOID;
    using PETHREAD  = PVOID;
    using PMDL      = PVOID;
    using HMODULE   = PVOID;
    using LPCWSTR   = PVOID;
    using LPWSTR    = PVOID;
    using LPCSTR    = PVOID;
    using LPSTR     = PVOID;
    using PBYTE     = PVOID;
    using PSHORT    = PVOID;
    using PULONG    = PVOID;
    using PDWORD    = PVOID;
    using PUINT64   = PVOID;

    using CLIENT_ID = struct {
        UINT64 ProcessId;
        UINT64 ThreadId;
    };
}

namespace ObjFlags {
    enum ObjFlags {
        _OBJ_INHERIT                        = 0x00000002L,
        _OBJ_PERMANENT                      = 0x00000010L,
        _OBJ_EXCLUSIVE                      = 0x00000020L,
        _OBJ_CASE_INSENSITIVE               = 0x00000040L,
        _OBJ_OPENIF                         = 0x00000080L,
        _OBJ_OPENLINK                       = 0x00000100L,
        _OBJ_KERNEL_HANDLE                  = 0x00000200L,
        _OBJ_FORCE_ACCESS_CHECK             = 0x00000400L,
        _OBJ_IGNORE_IMPERSONATED_DEVICEMAP  = 0x00000800L,
        _OBJ_DONT_REPARSE                   = 0x00001000L,
        _OBJ_VALID_ATTRIBUTES               = 0x00001FF2L,
    };
}

namespace NtTypes {
    enum PROCESSINFOCLASS {
        ProcessBasicInformation, // 0, q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
        ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
        ProcessIoCounters, // q: IO_COUNTERS
        ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
        ProcessTimes, // q: KERNEL_USER_TIMES
        ProcessBasePriority, // s: KPRIORITY
        ProcessRaisePriority, // s: ULONG
        ProcessDebugPort, // q: HANDLE
        ProcessExceptionPort, // s: HANDLE
        ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
        ProcessLdtInformation, // 10, qs: PROCESS_LDT_INFORMATION
        ProcessLdtSize, // s: PROCESS_LDT_SIZE
        ProcessDefaultHardErrorMode, // qs: ULONG
        ProcessIoPortHandlers, // (kernel-mode only)
        ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
        ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
        ProcessUserModeIOPL,
        ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
        ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
        ProcessWx86Information,
        ProcessHandleCount, // 20, q: ULONG, PROCESS_HANDLE_INFORMATION
        ProcessAffinityMask, // s: KAFFINITY
        ProcessPriorityBoost, // qs: ULONG
        ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
        ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
        ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
        ProcessWow64Information, // q: ULONG_PTR
        ProcessImageFileName, // q: UNICODE_STRING
        ProcessLUIDDeviceMapsEnabled, // q: ULONG
        ProcessBreakOnTermination, // qs: ULONG
        ProcessDebugObjectHandle, // 30, q: HANDLE
        ProcessDebugFlags, // qs: ULONG
        ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
        ProcessIoPriority, // qs: ULONG
        ProcessExecuteFlags, // qs: ULONG
        ProcessResourceManagement,
        ProcessCookie, // q: ULONG
        ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
        ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
        ProcessPagePriority, // q: ULONG
        ProcessInstrumentationCallback, // 40
        ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
        ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
        ProcessImageFileNameWin32, // q: UNICODE_STRING
        ProcessImageFileMapping, // q: HANDLE (input)
        ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
        ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
        ProcessGroupInformation, // q: USHORT[]
        ProcessTokenVirtualizationEnabled, // s: ULONG
        ProcessConsoleHostProcess, // q: ULONG_PTR
        ProcessWindowInformation, // 50, q: PROCESS_WINDOW_INFORMATION
        ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
        ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
        ProcessDynamicFunctionTableInformation,
        ProcessHandleCheckingMode,
        ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
        ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
        ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
        ProcessHandleTable, // since WINBLUE
        ProcessCheckStackExtentsMode,
        ProcessCommandLineInformation, // 60, q: UNICODE_STRING
        ProcessProtectionInformation, // q: PS_PROTECTION
        ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
        ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
        ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
        ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
        ProcessDefaultCpuSetsInformation,
        ProcessAllowedCpuSetsInformation,
        ProcessReserved1Information,
        ProcessReserved2Information,
        ProcessSubsystemProcess, // 70
        ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
        MaxProcessInfoClass
    };

    enum THREADINFOCLASS {
        ThreadBasicInformation, // q: THREAD_BASIC_INFORMATION
        ThreadTimes, // q: KERNEL_USER_TIMES
        ThreadPriority, // s: KPRIORITY
        ThreadBasePriority, // s: LONG
        ThreadAffinityMask, // s: KAFFINITY
        ThreadImpersonationToken, // s: HANDLE
        ThreadDescriptorTableEntry, // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
        ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
        ThreadEventPair,
        ThreadQuerySetWin32StartAddress, // q: PVOID
        ThreadZeroTlsCell, // 10
        ThreadPerformanceCount, // q: LARGE_INTEGER
        ThreadAmILastThread, // q: ULONG
        ThreadIdealProcessor, // s: ULONG
        ThreadPriorityBoost, // qs: ULONG
        ThreadSetTlsArrayAddress,
        ThreadIsIoPending, // q: ULONG
        ThreadHideFromDebugger, // s: void
        ThreadBreakOnTermination, // qs: ULONG
        ThreadSwitchLegacyState,
        ThreadIsTerminated, // 20, q: ULONG
        ThreadLastSystemCall, // q: THREAD_LAST_SYSCALL_INFORMATION
        ThreadIoPriority, // qs: ULONG
        ThreadCycleTime, // q: THREAD_CYCLE_TIME_INFORMATION
        ThreadPagePriority, // q: ULONG
        ThreadActualBasePriority,
        ThreadTebInformation, // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
        ThreadCSwitchMon,
        ThreadCSwitchPmu,
        ThreadWow64Context, // q: WOW64_CONTEXT
        ThreadGroupInformation, // 30, q: GROUP_AFFINITY
        ThreadUmsInformation,
        ThreadCounterProfiling,
        ThreadIdealProcessorEx, // q: PROCESSOR_NUMBER
        ThreadCpuAccountingInformation, // since WIN8
        ThreadSuspendCount, // since WINBLUE
        ThreadHeterogeneousCpuPolicy, // KHETERO_CPU_POLICY // since THRESHOLD
        ThreadContainerId,
        ThreadNameInformation,
        ThreadProperty,
        ThreadSelectedCpuSets,
        ThreadSystemThreadInformation,
        MaxThreadInfoClass
    };
}
```

`User-Bridge/API/CommPort.cpp`:

```cpp
#include <Windows.h>
#include <fltUser.h>

#pragma comment(lib, "FltLib.lib")

#include "CommPort.h"

CommPort::CommPort() : hPort(NULL), Connected(FALSE) {}

CommPort::~CommPort() {
    Disconnect();
}

HRESULT CommPort::Connect(LPCWSTR PortName, PVOID Context, WORD SizeOfContext) {
    HRESULT Status = FilterConnectCommunicationPort(
        PortName,
        0,
        Context,
        SizeOfContext,
        NULL,
        &hPort
    );
    Connected = Status == S_OK;
    return Status;
}

VOID CommPort::Disconnect() {
    if (hPort) CloseHandle(hPort);
}

HRESULT CommPort::Send(
    IN PVOID Input, 
    DWORD InputSize, 
    OUT PVOID Output, 
    DWORD OutputSize, 
    OUT OPTIONAL PULONG ReturnLength
) {
    DWORD Returned = 0;
    HRESULT Status = FilterSendMessage(hPort, Input, InputSize, Output, OutputSize, &Returned);
    if (ReturnLength) *ReturnLength = Returned;
    return Status;
}

HRESULT CommPort::Recv(_Out_ CommPortPacket& ReceivedMessage) {
    return FilterGetMessage(
        hPort,
        static_cast<PFILTER_MESSAGE_HEADER>(ReceivedMessage.GetHeader()),
        ReceivedMessage.GetSize(),
        NULL
    );
}

HRESULT CommPort::Reply(_In_ CommPortPacket& ReplyMessage) {
    return FilterReplyMessage(hPort, static_cast<PFILTER_REPLY_HEADER>(ReplyMessage.GetHeader()), ReplyMessage.GetSize());
}

```

`User-Bridge/API/CommPort.h`:

```h
#pragma once

class CommPortPacket {
public:
    CommPortPacket() = default;
    ~CommPortPacket() = default;
    virtual PVOID GetHeader() = 0;
    virtual PVOID GetData() = 0;
    virtual ULONG GetSize() const = 0;
};

template <typename T>
class MessagePacket : public CommPortPacket {
private:
    struct {
        FILTER_MESSAGE_HEADER Header;
        T Data;
    } Packet;
public:
    MessagePacket() : Packet({}) {}
    ~MessagePacket() {}

    PVOID GetHeader() override { return static_cast<PVOID>(&Packet.Header); }
    PVOID GetData() override { return static_cast<PVOID>(&Packet.Data); }
    ULONG GetSize() const override { return sizeof(Packet); }

    ULONG GetReplyLength() const { return Packet.Header.ReplyLength; }
    ULONGLONG GetMessageId() const { return Packet.Header.MessageId; }
};

template <typename T>
class ReplyPacket : public CommPortPacket {
private:
    struct {
        FILTER_REPLY_HEADER Header;
        T Data;
    } Packet;
public:
    ReplyPacket() : CommPortPacket(), Packet({}) {}
    ReplyPacket(CommPortPacket& Message, ULONG Status) : ReplyPacket() {
        SetMessageId(static_cast<PFILTER_MESSAGE_HEADER>(Message.GetHeader())->MessageId);
        SetReplyStatus(Status);
    }
    ReplyPacket(CommPortPacket& Message, ULONG Status, const T& Data) : ReplyPacket(Message, Status) {
        SetData(Data);
    }
    ~ReplyPacket() {}
    
    PVOID GetData() override { return static_cast<PVOID>(&Packet.Data); }
    PVOID GetHeader() override { return static_cast<PVOID>(&Packet.Header); }
    ULONG GetSize() const override { return sizeof(Packet); }
    
    VOID SetData(const T& Data) { Packet.Data = Data; }
    VOID SetReplyStatus(NTSTATUS Status) { Packet.Header.Status = Status; }
    VOID SetMessageId(ULONGLONG MessageId) { Packet.Header.MessageId = MessageId; }
};

class CommPort {
private:
    HANDLE hPort;
    BOOL Connected;
public:
    CommPort();
    ~CommPort();

    HRESULT Connect(LPCWSTR PortName, PVOID Context, WORD SizeOfContext);
    VOID Disconnect();

    HRESULT Send(
        IN PVOID Input, 
        DWORD InputSize, 
        OUT PVOID Output, 
        DWORD OutputSize, 
        OUT OPTIONAL PULONG ReturnLength = NULL
    );
    HRESULT Recv(_Out_ CommPortPacket& ReceivedMessage);
    HRESULT Reply(_In_ CommPortPacket& ReplyMessage);
};
```

`User-Bridge/API/DriversUtils.cpp`:

```cpp
#include <Windows.h>

#include "DriversUtils.h"

BOOL InstallDriver(LPCWSTR FilePath, LPCWSTR DriverName, DWORD DriverType) 
{
    SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    if (hSCManager == NULL) return FALSE;
    
    SC_HANDLE hService = CreateService(
        hSCManager, DriverName, DriverName, 
        SERVICE_ALL_ACCESS, DriverType, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, FilePath, 
        NULL, NULL, NULL, NULL, NULL
    );

    if (hService == NULL) {
        CloseServiceHandle(hSCManager);
        return FALSE;
    }

    LPCWSTR Arguments = NULL;
    BOOL Status = StartService(hService, 0, &Arguments);
    
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    
    return Status;
}

BOOL SetupFilterInstance(LPCWSTR DriverName, LPCWSTR InstanceName, LPCWSTR Altitude, DWORD Flags, BOOL SetAsDefaultInstance)
{
    WCHAR PathBuffer[MAX_PATH] = {};
    wcscpy_s(PathBuffer, MAX_PATH, L"System\\CurrentControlSet\\Services\\");
    wcscat_s(PathBuffer, MAX_PATH, DriverName);

    // Registering an instance with specified flags and altitude:
    HKEY hKey = NULL;
    LSTATUS RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PathBuffer, 0, KEY_ALL_ACCESS, &hKey);
    if (RegStatus != ERROR_SUCCESS) return FALSE;

    HKEY hInstancesKey = NULL;
    DWORD Disposition = 0;
    RegStatus = RegCreateKeyEx(hKey, L"Instances", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hInstancesKey, &Disposition);
    RegCloseKey(hKey);
    if (RegStatus != ERROR_SUCCESS) return FALSE;
    
    if (SetAsDefaultInstance) {
        RegStatus = RegSetValueEx(
            hInstancesKey, 
            L"DefaultInstance", 
            0, 
            REG_SZ, 
            reinterpret_cast<const BYTE*>(InstanceName), 
            (static_cast<DWORD>(wcsnlen_s(InstanceName, MAX_PATH)) + 1) * sizeof(WCHAR)
        );

        if (RegStatus != ERROR_SUCCESS) {
            RegCloseKey(hInstancesKey);
            return FALSE;
        }
    }

    HKEY hInstanceKey = NULL;
    RegStatus = RegCreateKeyEx(hInstancesKey, InstanceName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hInstanceKey, &Disposition);
    if (RegStatus != ERROR_SUCCESS) {
        RegCloseKey(hInstancesKey);
        return FALSE;
    }
    RegCloseKey(hInstancesKey);

    RegStatus = RegSetValueEx(
        hInstanceKey, 
        L"Altitude", 
        0, 
        REG_SZ, 
        reinterpret_cast<const BYTE*>(Altitude), 
        (static_cast<DWORD>(wcsnlen_s(Altitude, MAX_PATH)) + 1) * sizeof(WCHAR)
    );

    if (RegStatus != ERROR_SUCCESS) {
        RegCloseKey(hInstanceKey);
        return FALSE;
    }

    RegStatus = RegSetValueEx(
        hInstanceKey, 
        L"Flags", 
        0, 
        REG_DWORD, 
        reinterpret_cast<const BYTE*>(&Flags), 
        sizeof(Flags)
    );

    RegCloseKey(hInstanceKey);

    return RegStatus == ERROR_SUCCESS;
}

BOOL InstallMinifilter(LPCWSTR FilePath, LPCWSTR DriverName, LPCWSTR Altitude) 
{
    SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    if (hSCManager == NULL) return FALSE;
    
    SC_HANDLE hService = CreateService(
        hSCManager, DriverName, DriverName, 
        SERVICE_ALL_ACCESS, SERVICE_FILE_SYSTEM_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, 
        FilePath, 
        L"FSFilter Activity Monitor", 
        NULL, 
        NULL,
        NULL, 
        NULL
    );

    CloseServiceHandle(hSCManager);

    if (hService == NULL) return FALSE;

    if (!SetupFilterInstance(DriverName, L"DefInst", Altitude, 0, TRUE)) {
        CloseServiceHandle(hService);
        return FALSE;
    }

    LPCWSTR Arguments = NULL;
    BOOL Status = StartService(hService, 0, &Arguments);

    CloseServiceHandle(hService);
   
    return Status;
}

BOOL DeleteDriver(LPCWSTR DriverName) 
{
    SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (hSCManager == NULL) return FALSE;

    SC_HANDLE hService = OpenService(hSCManager, DriverName, SERVICE_ALL_ACCESS);
    if (hService == NULL) {
        CloseServiceHandle(hSCManager);
        return FALSE;
    }

    SERVICE_STATUS ServiceStatus;
    ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);
    BOOL Status = DeleteService(hService);

    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);

    return Status;
}

HANDLE OpenDevice(LPCWSTR NativeDeviceName) 
{
    return CreateFile(
        NativeDeviceName, 
        0, 
        FILE_SHARE_READ | FILE_SHARE_WRITE, 
        NULL, 
        OPEN_EXISTING, 
        FILE_ATTRIBUTE_SYSTEM, 
        NULL
    );
}

BOOL SendIOCTL(
    IN HANDLE hDevice,
    IN DWORD Ioctl,
    IN PVOID InputBuffer,
    IN ULONG InputBufferSize,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OPTIONAL OUT PDWORD BytesReturned,
    OPTIONAL IN DWORD Method
) {
    DWORD RawIoctl = CTL_CODE(0x8000, Ioctl, Method, FILE_ANY_ACCESS);
    DWORD Returned = 0;
    BOOL Status = DeviceIoControl(hDevice, RawIoctl, InputBuffer, InputBufferSize, OutputBuffer, OutputBufferSize, &Returned, NULL);
    if (BytesReturned) *BytesReturned = Returned;
    return Status;
}

BOOL SendRawIOCTL(
    IN HANDLE hDevice,
    IN DWORD Ioctl,
    IN PVOID InputBuffer,
    IN ULONG InputBufferSize,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OPTIONAL OUT PDWORD BytesReturned
) {
    DWORD Returned = 0;
    BOOL Status = DeviceIoControl(hDevice, Ioctl, InputBuffer, InputBufferSize, OutputBuffer, OutputBufferSize, &Returned, NULL);
    if (BytesReturned) *BytesReturned = Returned;
    return Status;
}

```

`User-Bridge/API/DriversUtils.h`:

```h
#pragma once

#define IOCTL(Code, Method) (CTL_CODE(0x8000, (Code), Method, FILE_ANY_ACCESS))
#define EXTRACT_CTL_CODE(Ioctl)   ((unsigned short)(((Ioctl) & 0b0011111111111100) >> 2))
#define EXTRACT_CTL_METHOD(Ioctl) ((unsigned short)((Ioctl) & 0b11))

#define CTL_BASE (0x800)

BOOL InstallDriver(LPCWSTR FilePath, LPCWSTR DriverName, DWORD DriverType = SERVICE_KERNEL_DRIVER);
BOOL InstallMinifilter(LPCWSTR FilePath, LPCWSTR DriverName, LPCWSTR Altitude);
BOOL DeleteDriver(LPCWSTR DriverName);

HANDLE OpenDevice(LPCWSTR DeviceName);

BOOL SendIOCTL(
    IN HANDLE hDevice,
    IN DWORD Ioctl,
    IN PVOID InputBuffer,
    IN ULONG InputBufferSize,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OPTIONAL OUT PDWORD BytesReturned = NULL,
    OPTIONAL IN DWORD Method = METHOD_NEITHER
);

BOOL SendRawIOCTL(
    IN HANDLE hDevice,
    IN DWORD Ioctl,
    IN PVOID InputBuffer,
    IN ULONG InputBufferSize,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OPTIONAL OUT PDWORD BytesReturned = NULL
);

```

`User-Bridge/API/Flt-Bridge.h`:

```h
#pragma once

/*
    Depends on:
    - Windows.h
    - fltUser.h
    - functional
    - WdkTypes.h
    - FltTypes.h
    - CommPort.h
*/

template <typename PacketDataType, KbFltTypes PacketType>
class CommPortListener {
public:
    using _Callback = std::function<void(CommPort& Port, MessagePacket<PacketDataType>& Message)>;
private:
    CommPort Port;
    HANDLE hThread;
    _Callback Callback;

    HRESULT ConnectStatus;
    HANDLE hSubscriptionEvent;

    static bool CallCallbackSafe(CommPortListener* Self, MessagePacket<PacketDataType>& Message) {
        if (Self->Callback) {
            __try {
                Self->Callback(Self->Port, Message);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                return false;
            }
        }
        return true;
    }

    static VOID WINAPI ListenerThread(CommPortListener* Self) {
        KB_FLT_CONTEXT Context = {};
        Context.Type = PacketType;
        Context.Client.ProcessId = GetCurrentProcessId();
        Context.Client.ThreadId = GetCurrentThreadId();

        static LPCWSTR PortName = L"\\Kernel-Bridge";
        Self->ConnectStatus = Self->Port.Connect(PortName, &Context, sizeof(Context));
        SetEvent(Self->hSubscriptionEvent);
        if (!SUCCEEDED(Self->ConnectStatus)) ExitThread(0);

        HRESULT Status;
        do {
            MessagePacket<PacketDataType> Message;
            Status = Self->Port.Recv(*reinterpret_cast<CommPortPacket*>(&Message));
            if (SUCCEEDED(Status)) {
                CallCallbackSafe(Self, Message);
            }
        } while (SUCCEEDED(Status));
        ExitThread(0);    
    }
public:
    CommPortListener() : Port(), hThread(NULL), Callback(NULL), ConnectStatus(ERROR_SUCCESS) {
        hSubscriptionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    }
    ~CommPortListener() {
        Unsubscribe();
        CloseHandle(hSubscriptionEvent);    
    } 

    BOOL Subscribe(_Callback Listener) {
        if (hThread != NULL || !Listener) return FALSE;
        Callback = Listener;
        hThread = CreateThread(NULL, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(ListenerThread), this, 0, NULL);
        if (!hThread) return FALSE;
        WaitForSingleObject(hSubscriptionEvent, INFINITE);
        if (!SUCCEEDED(ConnectStatus)) {
            CloseHandle(hThread);
            hThread = NULL;
            return FALSE;
        }
        ResetEvent(hSubscriptionEvent);

        return SUCCEEDED(ConnectStatus);    
    }

    VOID Unsubscribe() {
        if (!hThread) return;
        Port.Disconnect();
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
        hThread = NULL;    
    }
};
```

`User-Bridge/API/PEUtils/PEAnalyzer.cpp`:

```cpp
#include "PEAnalyzer.h"

constexpr unsigned int RELOCS_OFFSET_MASK = 0b0000111111111111; /* Low 12 bit */

constexpr unsigned short FORCED_FILE_ALIGNMENT = 0x200;
constexpr unsigned short MINIMAL_SECTION_ALIGNMENT = 0x1000;

constexpr unsigned short MZ_SIGNATURE = 0x5A4D; // MZ
constexpr unsigned short PE_SIGNATURE = 0x4550; // PE

constexpr unsigned short PE32_SIGNATURE = 0x010B;
constexpr unsigned short PE64_SIGNATURE = 0x020B;

size_t inline alignDown(size_t value, size_t factor)
{
    return value & ~(factor - 1);
}

size_t inline alignUp(size_t value, size_t factor)
{
    return alignDown(value - 1, factor) + factor;
}

SIZE_T PEAnalyzer::rvaToOffset(SIZE_T rva) const
{
    if (!m_isRawModule) return rva;
/*
    Offset = SectionRAW + (rva - SectionRVA)
    1. Find a section that contains the specified rva
    2. Calculate offset from beginning of section
    3. Add offset to the physical address of section in file
*/
    for (const auto& section : m_sections)
    {
        SIZE_T sectionBase, sectionSize, sectionOffset;
        if (m_needToAlign)
        {
            sectionBase = alignDown(static_cast<SIZE_T>(section.offsetInMemory), m_sectionAlignment);
            SIZE_T alignedFileSize, alignedSectionSize;
            alignedFileSize    = alignUp(section.sizeOnDisk, m_fileAlignment);
            alignedSectionSize = alignUp(section.sizeInMemory, m_sectionAlignment);
            sectionSize        = alignedFileSize > alignedSectionSize ? alignedSectionSize : alignedFileSize;
            sectionOffset      = alignDown(section.offsetInFile, FORCED_FILE_ALIGNMENT);
        }
        else
        {
            sectionBase = static_cast<SIZE_T>(section.offsetInMemory);
            sectionSize = section.sizeOnDisk > section.sizeInMemory ? section.sizeInMemory : section.sizeOnDisk;
            sectionOffset = section.offsetInFile;
        }

        if ((rva >= sectionBase) && (rva < sectionBase + sectionSize))
        {
            return (sectionOffset + (rva - sectionBase));
        }
    }

    return 0;
}

void PEAnalyzer::fillSectionsInfo()
{
    m_sections.clear();
    WORD numberOfSections = m_ntHeaders->FileHeader.NumberOfSections;
    PIMAGE_SECTION_HEADER sectionHeader = IMAGE_FIRST_SECTION(m_ntHeaders);
    for (unsigned short i = 0; i < numberOfSections; ++i, ++sectionHeader)
    {
        SECTION_INFO sectionInfo = {};
        sectionInfo.offsetInMemory = sectionHeader->VirtualAddress;
        sectionInfo.offsetInFile = sectionHeader->PointerToRawData;
        sectionInfo.sizeInMemory = sectionHeader->Misc.VirtualSize;
        sectionInfo.sizeOnDisk = sectionHeader->SizeOfRawData;
        sectionInfo.characteristics = sectionHeader->Characteristics;
        sectionInfo.numberOfRelocs = sectionHeader->NumberOfRelocations;
        memcpy(&sectionInfo.name, &sectionHeader->Name, SEC_NAME_SIZE);
        sectionInfo.name[SEC_NAME_SIZE] = NULL; // Null-terminator
        m_sections.push_back(sectionInfo);
    }
}

void PEAnalyzer::fillRelocsInfo()
{
    m_relocs.clear();
    auto relocsDir = reinterpret_cast<PIMAGE_DATA_DIRECTORY>(&m_optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);

    if (!relocsDir->Size) return;

    auto relocs = reinterpret_cast<PIMAGE_BASE_RELOCATION>((reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(relocsDir->VirtualAddress)));
    auto relocsFinalAddress = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<PBYTE>(relocs) + relocsDir->Size);
    while (relocs < relocsFinalAddress)
    {
        DWORD relocsRva = relocs->VirtualAddress;

        DWORD relocsCount = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        auto relocEntry = reinterpret_cast<PWORD>((reinterpret_cast<PBYTE>(relocs) + sizeof(IMAGE_BASE_RELOCATION)));
        for (unsigned int i = 0; i < relocsCount; ++i, ++relocEntry)
        {
            WORD reloc = *relocEntry;
            RELOC_INFO relocInfo = {};
            relocInfo.rva = relocsRva + (reloc & RELOCS_OFFSET_MASK);
            relocInfo.relocType = static_cast<BYTE>(reloc >> 12u);
            m_relocs.push_back(relocInfo);
        }

        relocs = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<PBYTE>(relocs) + relocs->SizeOfBlock);
    }
}

void PEAnalyzer::fillImportsSet(
    __in PIMAGE_THUNK_DATA thunk,
    __in PIMAGE_THUNK_DATA originalThunk,
    __out IMPORTS_SET& importsSet)
{
    importsSet.clear();
    while (thunk->u1.AddressOfData)
    {
        auto namedImport = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(originalThunk->u1.AddressOfData));

        constexpr SIZE_T ordinalPresentMask = static_cast<SIZE_T>(0x80) << static_cast<SIZE_T>((sizeof(SIZE_T) - 1) * 8);
        constexpr SIZE_T ordinalMask = ordinalPresentMask - 1;

        IMPORT_INFO importInfo;
        importInfo.ft = reinterpret_cast<PVOID>(thunk->u1.Function);
        importInfo.oft = reinterpret_cast<PVOID>(originalThunk->u1.Function);
        importInfo.isOrdinalImport = (reinterpret_cast<SIZE_T>(importInfo.oft) & ordinalPresentMask) == ordinalPresentMask;
        if (importInfo.isOrdinalImport)
        {
            importInfo.ordinal = reinterpret_cast<SIZE_T>(importInfo.oft) & ordinalMask;
            importInfo.hint = 0;
        }
        else
        {
            importInfo.ordinal = 0;
            importInfo.hint = namedImport->Hint;
            importInfo.name = namedImport->Name;
        }

        importsSet.push_back(importInfo);

        ++thunk;
        ++originalThunk;
    }
}

void PEAnalyzer::fillImportsInfo()
{
    m_imports.clear();
    auto importDir = reinterpret_cast<PIMAGE_DATA_DIRECTORY>(&m_optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);

    if (!importDir->Size) return;

    auto imports = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>((reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(importDir->VirtualAddress)));
    while (imports->FirstThunk)
    {
        auto libraryName = reinterpret_cast<LPCSTR>(m_localBase) + rvaToOffset(imports->Name);

        IMPORTS_SET importsSet;

        auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(imports->FirstThunk));
        auto originalThunk = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(imports->OriginalFirstThunk));
        fillImportsSet(thunk, originalThunk, importsSet);

        m_imports.emplace(libraryName, importsSet);
        ++imports;
    }
}

void PEAnalyzer::fillDelayedImportsInfo()
{
    m_delayedImports.clear();
    auto delayedImportDir = reinterpret_cast<PIMAGE_DATA_DIRECTORY>(&m_optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]);

    if (!delayedImportDir->Size) return;

    auto delayedImports = reinterpret_cast<PIMAGE_DELAYLOAD_DESCRIPTOR>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(delayedImportDir->VirtualAddress));
    while (delayedImports->DllNameRVA)
    {
        auto libraryName = reinterpret_cast<LPCSTR>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(delayedImports->DllNameRVA));

        DELAYED_IMPORT_INFO delayedImportInfo;
        delayedImportInfo.attributes = delayedImports->Attributes.AllAttributes;
        delayedImportInfo.hModule = *reinterpret_cast<HMODULE*>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(delayedImports->ModuleHandleRVA));
        delayedImportInfo.dllName = libraryName;

        auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(delayedImports->ImportAddressTableRVA));
        auto originalThunk = reinterpret_cast<PIMAGE_THUNK_DATA>(reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(delayedImports->ImportNameTableRVA));
        fillImportsSet(thunk, originalThunk, delayedImportInfo.imports);

        m_delayedImports.push_back(delayedImportInfo);
        ++delayedImports;
    }
}

void PEAnalyzer::fillExportsInfo()
{
    m_exports.timeStamp = 0;
    m_exports.numberOfNames = 0;

    m_exports.name.clear();
    m_exports.exports.clear();
    auto exportDir = reinterpret_cast<PIMAGE_DATA_DIRECTORY>(&m_optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);

    if (!exportDir->Size) return;

    auto exports = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>((reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(exportDir->VirtualAddress)));

    this->m_exports.timeStamp = exports->TimeDateStamp;
    this->m_exports.numberOfNames = exports->NumberOfNames;
    this->m_exports.numberOfFunctions = exports->NumberOfFunctions;
    this->m_exports.name = reinterpret_cast<LPCSTR>(m_localBase) + rvaToOffset(exports->Name);

    auto ordinalsArray = reinterpret_cast<PWORD>((reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(exports->AddressOfNameOrdinals)));

    auto namesArray = reinterpret_cast<PDWORD>((reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(exports->AddressOfNames)));
    auto functionsArray = reinterpret_cast<PDWORD>((reinterpret_cast<PBYTE>(m_localBase) + rvaToOffset(exports->AddressOfFunctions)));

    std::unordered_map<WORD, unsigned int> ordinalsMap; // ordinal -> ordinal index
    ordinalsMap.reserve(exports->NumberOfNames);
    for (unsigned int nameNumber = 0; nameNumber < exports->NumberOfNames; ++nameNumber)
    {
        ordinalsMap.emplace(*(ordinalsArray + nameNumber), nameNumber);
    }

    for (unsigned int functionNumber = 0; functionNumber < exports->NumberOfFunctions; ++functionNumber)
    {
        DWORD functionAddress = *(functionsArray + functionNumber);

        EXPORT_INFO exportInfo;
        exportInfo.va = reinterpret_cast<PBYTE>(m_localBase) + functionAddress;
        exportInfo.rva = functionAddress;
        exportInfo.ordinal = exports->Base + functionNumber;

        auto ordinalEntry = ordinalsMap.find(functionNumber);
        exportInfo.ordinalExport = ordinalEntry == ordinalsMap.end();
        if (!exportInfo.ordinalExport)
        {
            unsigned int nameNumber = ordinalEntry->second;
            auto functionName = reinterpret_cast<LPCSTR>(m_localBase) + rvaToOffset(*(namesArray + nameNumber));
            exportInfo.name = functionName;
        }

        m_exports.exports.push_back(exportInfo);
    }
}

PEAnalyzer::PEAnalyzer()
    : m_isRawModule(false)
    , m_areValidPeSignatures(false)
    , m_dosHeader(nullptr)
    , m_ntHeaders(nullptr)
    , m_optionalHeader(nullptr)
    , m_imageSize(0)
    , m_localBase(nullptr)
    , m_imageBase(nullptr)
    , m_entryPoint(nullptr)
    , m_needToAlign(0)
    , m_fileAlignment(0)
    , m_sectionAlignment(0)
    , m_sections()
    , m_relocs()
    , m_imports()
    , m_delayedImports()
    , m_exports()
{}


PEAnalyzer::PEAnalyzer(HMODULE hModule, bool isRawModule)
    : m_isRawModule(false)
    , m_areValidPeSignatures(false)
    , m_dosHeader(nullptr)
    , m_ntHeaders(nullptr)
    , m_optionalHeader(nullptr)
    , m_imageSize(0)
    , m_localBase(nullptr)
    , m_imageBase(nullptr)
    , m_entryPoint(nullptr)
    , m_needToAlign(0)
    , m_fileAlignment(0)
    , m_sectionAlignment(0)
    , m_sections()
    , m_relocs()
    , m_imports()
    , m_delayedImports()
    , m_exports()
{
    load(hModule, isRawModule);
}

PEAnalyzer::~PEAnalyzer()
{
    clear();
}

bool PEAnalyzer::load(HMODULE hModule, bool isRawModule)
{
    clear();

    if (!hModule) return false;

    m_isRawModule = isRawModule;

    m_dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(hModule);
    m_ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>((reinterpret_cast<PBYTE>(hModule) + m_dosHeader->e_lfanew));

    if (!validatePeSignatures())
    {
        clear();
        return false;
    }

    m_optionalHeader = &m_ntHeaders->OptionalHeader;

#ifdef _WIN64
    if (m_optionalHeader->Magic != PE64_SIGNATURE)
        throw std::exception("PE image must be 64-bit!");
#elif _WIN32
    if (m_optionalHeader->Magic != PE32_SIGNATURE)
        throw std::exception("PE image must be 32-bit!");
#endif

    m_imageSize = m_optionalHeader->SizeOfImage;

    m_localBase = hModule;

    m_imageBase = reinterpret_cast<PVOID>(m_optionalHeader->ImageBase);
    m_entryPoint = reinterpret_cast<PBYTE>(m_imageBase) + m_optionalHeader->AddressOfEntryPoint;

    m_fileAlignment = m_optionalHeader->FileAlignment;
    m_sectionAlignment = m_optionalHeader->SectionAlignment;
    m_needToAlign = m_sectionAlignment >= MINIMAL_SECTION_ALIGNMENT;

    fillSectionsInfo();
    fillRelocsInfo();
    fillImportsInfo();
    fillDelayedImportsInfo();
    fillExportsInfo();

    return true;
}

void PEAnalyzer::clear()
{
    m_isRawModule = false;
    m_areValidPeSignatures = false;
    m_dosHeader = nullptr;
    m_ntHeaders = nullptr;
    m_optionalHeader = nullptr;
    m_localBase = nullptr;
    m_imageBase = nullptr;
    m_imageSize = 0;
    m_entryPoint = nullptr;
    m_needToAlign = false;
    m_fileAlignment = 0;
    m_sectionAlignment = 0;
    m_sections.clear();
    m_relocs.clear();
    m_imports.clear();
    m_delayedImports.clear();
    m_exports.timeStamp = 0;
    m_exports.numberOfNames = 0;
    m_exports.numberOfFunctions = 0;
    m_exports.name.clear();
    m_exports.exports.clear();
}

bool PEAnalyzer::validatePeSignatures()
{
    return m_areValidPeSignatures = (m_dosHeader->e_magic == MZ_SIGNATURE) && (m_ntHeaders->Signature == PE_SIGNATURE);
}
```

`User-Bridge/API/PEUtils/PEAnalyzer.h`:

```h
#pragma once

#include <vector>
#include <unordered_map>
#include <Windows.h>

/*
    RAW or Offset - offset from the beginning of file
    RVA - offset in the loaded module (in memory)
    VA = ImageBase + RVA - real address of something in memory of the module
    RVA -> Offset: SectionRAW + (RVA - SectionRVA)
                                            ^- In section's header
*/

constexpr int SEC_NAME_SIZE = 8;

struct SECTION_INFO
{
    DWORD offsetInMemory;
    DWORD offsetInFile;
    DWORD sizeInMemory;
    DWORD sizeOnDisk;
    DWORD characteristics;
    WORD numberOfRelocs;
    CHAR name[SEC_NAME_SIZE + 1];
};

typedef std::vector<SECTION_INFO> SECTIONS_SET;

struct RELOC_INFO
{
    DWORD rva; // Page RVA + Offset
    BYTE relocType;
};

typedef std::vector<RELOC_INFO> RELOCS_SET;

struct IMPORT_INFO
{
    PVOID oft; // OFT = OriginalFirstThunk
    PVOID ft; // FT = FirstThunk, адрес в IAT (реальный адрес в памяти)
    bool isOrdinalImport;
    SIZE_T ordinal;
    WORD hint;
    std::string name;
};

typedef std::vector<IMPORT_INFO> IMPORTS_SET;
typedef std::unordered_map<std::string, IMPORTS_SET> IMPORTS_MAP; // LibName -> imports

struct DELAYED_IMPORT_INFO
{
    DWORD attributes;
    HMODULE hModule;
    std::string dllName;
    IMPORTS_SET imports;
};

typedef std::vector<DELAYED_IMPORT_INFO> DELAYED_IMPORTS_SET;

struct EXPORT_INFO
{
    PVOID va;
    DWORD rva;
    DWORD ordinal;
    bool ordinalExport;
    std::string name;
};

typedef std::vector<EXPORT_INFO> EXPORTS_SET;

struct EXPORTS_INFO
{
    DWORD timeStamp;
    DWORD numberOfNames;
    DWORD numberOfFunctions;
    std::string name;
    EXPORTS_SET exports;
};

class PEAnalyzer
{
private:
    bool m_isRawModule;
    bool m_areValidPeSignatures;

    PIMAGE_DOS_HEADER m_dosHeader;
    PIMAGE_NT_HEADERS m_ntHeaders;
    PIMAGE_OPTIONAL_HEADER m_optionalHeader;

    ULONG m_imageSize;

    PVOID m_localBase;

    PVOID m_imageBase;
    PVOID m_entryPoint;

    BOOL m_needToAlign;
    DWORD m_fileAlignment;
    DWORD m_sectionAlignment;

    SECTIONS_SET m_sections;
    RELOCS_SET m_relocs;
    IMPORTS_MAP m_imports;
    DELAYED_IMPORTS_SET m_delayedImports;
    EXPORTS_INFO m_exports;

    bool validatePeSignatures();

    void fillSectionsInfo();
    void fillRelocsInfo();
    void fillImportsInfo();
    void fillDelayedImportsInfo();
    void fillExportsInfo();

    void fillImportsSet(__in PIMAGE_THUNK_DATA thunk, __in PIMAGE_THUNK_DATA originalThunk, __out IMPORTS_SET& importsSet);

public:
    PEAnalyzer();
    PEAnalyzer(HMODULE hModule, bool isRawModule);
    ~PEAnalyzer();

    bool load(HMODULE hModule, bool isRawModule);

    void clear();

    [[nodiscard]] const SECTIONS_SET& getSectionsInfo() const { return m_sections; }
    [[nodiscard]] const RELOCS_SET& getRelocsInfo() const { return m_relocs; }
    [[nodiscard]] const IMPORTS_MAP& getImportsInfo() const { return m_imports; }
    [[nodiscard]] const DELAYED_IMPORTS_SET& getDelayedImports() const { return m_delayedImports; }
    [[nodiscard]] const EXPORTS_INFO& getExportsInfo() const { return m_exports; }

    [[nodiscard]] ULONG getImageSize() const { return m_imageSize; }
    [[nodiscard]] PVOID getImageBase() const { return m_imageBase; }
    [[nodiscard]] PVOID getLocalBase() const { return m_localBase; }
    [[nodiscard]] PVOID getEntryPoint() const { return m_entryPoint; }

    [[nodiscard]] PIMAGE_DOS_HEADER getDosHeader() const { return m_dosHeader; }
    [[nodiscard]] PIMAGE_NT_HEADERS getNtHeaders() const { return m_ntHeaders; }
    [[nodiscard]] PIMAGE_OPTIONAL_HEADER getOptionalHeader() const { return m_optionalHeader; }

    [[nodiscard]] bool isValidPe() const { return m_areValidPeSignatures; };

    [[nodiscard]] SIZE_T rvaToOffset(SIZE_T rva) const;
};
```

`User-Bridge/API/PEUtils/PELoader.cpp`:

```cpp
#include <Windows.h>
#include "PEAnalyzer.h"
#include "PELoader.h"

#include <stdexcept>

PELoader::PELoader(
    HMODULE rawModule,
    ImportNameCallback importNameCallback,
    ImportOrdinalCallback importOrdinalCallback)
{
    PEAnalyzer pe(rawModule, true);

    m_deployedSize = pe.getImageSize();
    m_hModule = static_cast<PBYTE>(VirtualAlloc(NULL, m_deployedSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE));
    if (!m_hModule) 
        throw std::runtime_error("Unable to allocate memory");

    // Copying of headers:
    CopyMemory(m_hModule, rawModule, pe.getOptionalHeader()->SizeOfHeaders);

    // Copying of sections:
    for (const auto& sec : pe.getSectionsInfo())
    {
        CopyMemory(
            m_hModule + sec.offsetInMemory,
            reinterpret_cast<PBYTE>(rawModule) + sec.offsetInFile,
            sec.sizeOnDisk
        );
    }

    m_dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(m_hModule);
    m_ntHeaders = reinterpret_cast<PIMAGE_NT_HEADERS>(m_hModule + m_dosHeader->e_lfanew);
    m_optionalHeader = static_cast<PIMAGE_OPTIONAL_HEADER>(&m_ntHeaders->OptionalHeader);

    m_originalImageBase = m_optionalHeader->ImageBase;

    // Filling imports and exports:
    fillImports(importNameCallback, importOrdinalCallback);

    // Relocating to current memory block:
    m_previousLoadDelta = 0;
    relocate(reinterpret_cast<HMODULE>(m_hModule));
}

void PELoader::fillImports(
    ImportNameCallback importNameCallback,
    ImportOrdinalCallback importOrdinalCallback)
{
    auto importDir = reinterpret_cast<PIMAGE_DATA_DIRECTORY>(
        &m_optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
    );

    if (importDir->Size == 0) return;

    auto imports = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(m_hModule + importDir->VirtualAddress);
    while (imports->FirstThunk)
    {
        LPCSTR libName = reinterpret_cast<LPCSTR>(m_hModule + imports->Name);
        auto thunk = reinterpret_cast<PIMAGE_THUNK_DATA>(m_hModule + imports->FirstThunk);
        auto originalThunk = reinterpret_cast<PIMAGE_THUNK_DATA>(m_hModule + imports->OriginalFirstThunk);
        
        while (thunk->u1.AddressOfData)
        {
            auto namedImport = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(m_hModule + originalThunk->u1.AddressOfData);

            const SIZE_T OrdinalPresentMask = (SIZE_T)0x80 << (SIZE_T)((sizeof(SIZE_T) - 1) * 8);
            const SIZE_T OrdinalMask = OrdinalPresentMask - 1;

            if ((thunk->u1.Function & OrdinalMask) == OrdinalMask)
            {
                thunk->u1.Function = reinterpret_cast<SIZE_T>(
                    importOrdinalCallback(libName, static_cast<WORD>(thunk->u1.Function & OrdinalMask))
                );
            }
            else
            {
                thunk->u1.Function = reinterpret_cast<SIZE_T>(
                    importNameCallback(libName, namedImport->Name)
                );
            }

            ++thunk;
            ++originalThunk;
        }

        ++imports;
    }
}

void PELoader::relocate(HMODULE base)
{
    // Check whether we have (or have no) relocs:
    if (m_ntHeaders->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) return;

    auto relocsDir = static_cast<PIMAGE_DATA_DIRECTORY>(
        &m_optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]
    );

    if (relocsDir->Size == 0) return;

    m_optionalHeader->ImageBase = reinterpret_cast<SIZE_T>(base);
    SIZE_T loadDelta = reinterpret_cast<SIZE_T>(base) - m_originalImageBase;

    auto relocs = reinterpret_cast<PIMAGE_BASE_RELOCATION>(m_hModule + relocsDir->VirtualAddress);
    auto relocsFinalAddress = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<PBYTE>(relocs) + relocsDir->Size);
    while (relocs < relocsFinalAddress)
    {
        DWORD relocsRva = relocs->VirtualAddress;

        DWORD relocsCount = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        PWORD relocEntry = reinterpret_cast<PWORD>(reinterpret_cast<PBYTE>(relocs) + sizeof(IMAGE_BASE_RELOCATION));
        
        for (unsigned int i = 0; i < relocsCount; ++i, ++relocEntry)
        {
            WORD reloc = *relocEntry;

            constexpr DWORD relocsOffsetMask = 0b0000111111111111; // Lower 12 bits
            DWORD relocRva = relocsRva + (reloc & relocsOffsetMask);
            BYTE type = static_cast<BYTE>(reloc >> 12);
            
            PVOID relocAddress = reinterpret_cast<PWORD>(m_hModule + relocRva);

            switch (type) {
            case IMAGE_REL_BASED_HIGH: {
                *static_cast<PWORD>(relocAddress) += HIWORD(loadDelta) - HIWORD(m_previousLoadDelta);
                break;
            }
            case IMAGE_REL_BASED_LOW: {
                *static_cast<PWORD>(relocAddress) += LOWORD(loadDelta) - LOWORD(m_previousLoadDelta);
                break;
            }
            case IMAGE_REL_BASED_HIGHLOW: {
                *static_cast<PSIZE_T>(relocAddress) += loadDelta - m_previousLoadDelta;
                break;
            }
            case IMAGE_REL_BASED_DIR64: {
                *static_cast<UNALIGNED DWORD_PTR*>(relocAddress) += loadDelta - m_previousLoadDelta;
                break;
            }
            case IMAGE_REL_BASED_ABSOLUTE:
            case IMAGE_REL_BASED_HIGHADJ:
                break;
            }
        }

        relocs = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<PBYTE>(relocs) + relocs->SizeOfBlock);
    }

    m_previousLoadDelta = loadDelta;
}
```

`User-Bridge/API/PEUtils/PELoader.h`:

```h
#pragma once

using ImportNameCallback = PVOID(*)(LPCSTR LibName, LPCSTR FunctionName);
using ImportOrdinalCallback = PVOID(*)(LPCSTR LibName, WORD Ordinal);
using EntryPoint = BOOL(WINAPI*)(HMODULE hModule, DWORD dwReason, LPCONTEXT lpContext);

class PELoader
{
private:
    PBYTE m_hModule;
    ULONG m_deployedSize;

    SIZE_T m_originalImageBase;
    SIZE_T m_previousLoadDelta;

    PIMAGE_DOS_HEADER m_dosHeader;
    PIMAGE_NT_HEADERS m_ntHeaders;
    PIMAGE_OPTIONAL_HEADER m_optionalHeader;

    void fillImports(ImportNameCallback importNameCallback, ImportOrdinalCallback importOrdinalCallback);
public:
    PELoader(HMODULE rawModule, ImportNameCallback importNameCallback, ImportOrdinalCallback importOrdinalCallback);
    ~PELoader() { if (m_hModule) VirtualFree(m_hModule, 0, MEM_RELEASE); };
    
    void relocate(HMODULE Base);

    HMODULE get() const
    {
        return reinterpret_cast<HMODULE>(m_hModule);
    }

    ULONG getDeployedSize() const
    {
        return m_deployedSize;
    }
    EntryPoint getEntryPoint() const {
        return reinterpret_cast<EntryPoint>(m_hModule + m_optionalHeader->AddressOfEntryPoint);
    }
    EntryPoint getBaseRelativeEntryPoint(HMODULE base) const {
        return reinterpret_cast<EntryPoint>(reinterpret_cast<PBYTE>(base) + m_optionalHeader->AddressOfEntryPoint);
    }
};
```

`User-Bridge/API/Rtl-Bridge.cpp`:

```cpp
#include <Windows.h>

// User-Bridge types:
#include <WdkTypes.h>
#include <CtlTypes.h>
#include <User-Bridge.h>
#include "Rtl-Bridge.h"

// PEUtils modules:
#include <PEAnalyzer.h>
#include <PELoader.h>

#include <string>

namespace KbRtl {

    static PVOID GetKernelProcAddress(LPCSTR FunctionName)
    {
        // Converting ANSI-name to Unicode-name:
        ULONG SymbolsCount = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, FunctionName, -1, NULL, 0);
        std::wstring WideName(SymbolsCount, static_cast<WCHAR>(0x0000));
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, FunctionName, -1, const_cast<LPWSTR>(WideName.c_str()), SymbolsCount - 1);

        // Getting the actual kernel address:
        WdkTypes::PVOID KernelAddress = NULL;
        BOOL Status = Stuff::KbGetKernelProcAddress(WideName.c_str(), &KernelAddress);
        return Status ? reinterpret_cast<PVOID>(KernelAddress) : NULL;
    }

    class FileReader {
    private:
        PVOID Memory;
        ULONG Size;
    public:
        FileReader() : Memory(NULL) {
        
        }
        ~FileReader() {
            Free();
        }

        BOOL Load(LPCWSTR Path) {
            HANDLE hFile = CreateFile(Path, FILE_READ_ACCESS, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile == INVALID_HANDLE_VALUE) return FALSE;

            Size = GetFileSize(hFile, NULL);
            if (!Size) {
                CloseHandle(hFile);
                return FALSE;
            }

            Memory = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            ULONG BytesRead = 0;
            if (!Memory || !ReadFile(hFile, Memory, Size, &BytesRead, NULL) || BytesRead != Size) {
                if (Memory) VirtualFree(Memory, 0, MEM_RELEASE);
                CloseHandle(hFile);
                Memory = NULL;
                Size = 0;
                return FALSE;
            }

            CloseHandle(hFile);
            return TRUE;
        }

        VOID Free() {
            if (Memory) VirtualFree(Memory, 0, MEM_RELEASE);
            Memory = NULL;
            Size = 0;
        }

        PVOID GetMemory() { return Memory; }
        ULONG GetSize() const { return Size; }
    };

    KbLdrStatus WINAPI KbRtlMapDriverMemory(PVOID DriverImage, LPCWSTR DriverName)
    {
        try {
            PELoader Loader(
                static_cast<HMODULE>(DriverImage),
                [](LPCSTR LibName, LPCSTR FunctionName) -> PVOID {
                    PVOID Address = GetKernelProcAddress(FunctionName);
                    if (!Address) throw KbLdrImportNotResolved;
                    return Address;
                },
                [](LPCSTR LibName, WORD Ordinal) -> PVOID {
                    throw KbLdrOrdinalImportNotSupported;
                }
            );

            WdkTypes::PVOID KImageAddress = NULL;
            BOOL Status = VirtualMemory::KbAllocKernelMemory(Loader.getDeployedSize(), TRUE, &KImageAddress);
            if (!Status) throw KbLdrKernelMemoryNotAllocated;

            Loader.relocate(reinterpret_cast<HMODULE>(KImageAddress));

            Status = VirtualMemory::KbCopyMoveMemory(
                KImageAddress, 
                reinterpret_cast<WdkTypes::PVOID>(Loader.get()), 
                Loader.getDeployedSize(), 
                FALSE
            );

            if (!Status) {
                VirtualMemory::KbFreeKernelMemory(KImageAddress);
                return KbLdrTransitionFailure;
            }

            return LoadableModules::KbCreateDriver(
                DriverName,
                reinterpret_cast<WdkTypes::PVOID>(
                    Loader.getBaseRelativeEntryPoint(reinterpret_cast<HMODULE>(KImageAddress))
                )
            ) ? KbLdrSuccess : KbLdrCreationFailure;
        } 
        catch (KbLdrStatus Status) {
            return Status;
        }
    }

    KbLdrStatus WINAPI KbRtlMapDriverFile(LPCWSTR DriverPath, LPCWSTR DriverName)
    {
        FileReader Reader;
        if (!Reader.Load(DriverPath)) return KbLdrCreationFailure;
        return KbRtlMapDriverMemory(Reader.GetMemory(), DriverName);
    }

    KbLdrStatus WINAPI KbRtlLoadModuleMemory(PVOID DriverImage, LPCWSTR ModuleName, OUT WdkTypes::HMODULE* ImageBase)
    {
        try {
            PELoader Loader(
                static_cast<HMODULE>(DriverImage),
                [](LPCSTR LibName, LPCSTR FunctionName) -> PVOID {
                    PVOID Address = GetKernelProcAddress(FunctionName);
                    if (!Address) throw KbLdrImportNotResolved;
                    return Address;
                },
                [](LPCSTR LibName, WORD Ordinal) -> PVOID {
                    throw KbLdrOrdinalImportNotSupported;
                }
            );

            PEAnalyzer Module(Loader.get(), FALSE);

            WdkTypes::HMODULE hModule = NULL;
            BOOL Status = VirtualMemory::KbAllocKernelMemory(Loader.getDeployedSize(), TRUE, &hModule);
            if (!Status) throw KbLdrKernelMemoryNotAllocated;

            Loader.relocate(reinterpret_cast<HMODULE>(hModule));

            Status = VirtualMemory::KbCopyMoveMemory(
                hModule, 
                reinterpret_cast<WdkTypes::PVOID>(Loader.get()), 
                Loader.getDeployedSize(), 
                FALSE
            );

            if (!Status) {
                VirtualMemory::KbFreeKernelMemory(hModule);
                return KbLdrTransitionFailure;
            }

            WdkTypes::PVOID ModuleBase = reinterpret_cast<WdkTypes::PVOID>(Module.getImageBase());
            WdkTypes::PVOID OnLoad = NULL, OnUnload = NULL, OnDeviceControl = NULL;
            const auto& Exports = Module.getExportsInfo();
            for (const auto& Export : Exports.exports) {
                WdkTypes::PVOID VA = hModule + static_cast<WdkTypes::PVOID>(Export.rva);
                if (Export.name == "OnLoad") {
                    OnLoad = VA;
                } else if (Export.name == "OnUnload") {
                    OnUnload = VA;
                } else if (Export.name == "OnDeviceControl") {
                    OnDeviceControl = VA;
                }
            }

            Status = LoadableModules::KbLoadModule(
                hModule,
                ModuleName,
                OnLoad,
                OnUnload,
                OnDeviceControl
            );

            if (!Status) {
                VirtualMemory::KbFreeKernelMemory(hModule);
                return KbLdrCreationFailure;
            }

            *ImageBase = hModule;
            return KbLdrSuccess;
        } 
        catch (KbLdrStatus Status) {
            return Status;
        }
    }

    KbLdrStatus WINAPI KbRtlLoadModuleFile(LPCWSTR ModulePath, LPCWSTR ModuleName, OUT WdkTypes::HMODULE* hModule)
    {
        FileReader Reader;
        if (!Reader.Load(ModulePath)) return KbLdrCreationFailure;
        return KbRtlLoadModuleMemory(Reader.GetMemory(), ModuleName, hModule);
    }
}
```

`User-Bridge/API/Rtl-Bridge.h`:

```h
#pragma once

/*
    Depends on:
    - Windows.h
    - WdkTypes.h
    - CtlTypes.h
    - User-Bridge.h
*/

namespace KbRtl {
    enum KbLdrStatus {
        KbLdrSuccess,
        KbLdrImportNotResolved,
        KbLdrOrdinalImportNotSupported,
        KbLdrKernelMemoryNotAllocated,
        KbLdrTransitionFailure,
        KbLdrCreationFailure
    };

    // 'DriverImage' is a raw *.sys file data
    // 'DriverName' is a system name of driver in format L"\\Driver\\YourDriverName"
    KbLdrStatus WINAPI KbRtlMapDriverMemory(PVOID DriverImage, LPCWSTR DriverName);
    KbLdrStatus WINAPI KbRtlMapDriverFile(LPCWSTR DriverPath, LPCWSTR DriverName);

    // 'ModuleImage' is a raw *.sys file data
    // 'ModuleName' is a custom unique name for the loadable module
    KbLdrStatus WINAPI KbRtlLoadModuleMemory(PVOID ModuleImage, LPCWSTR ModuleName, OUT WdkTypes::HMODULE* hModule);
    KbLdrStatus WINAPI KbRtlLoadModuleFile(LPCWSTR ModulePath, LPCWSTR ModuleName, OUT WdkTypes::HMODULE* hModule);

    class PhysMem {
    public:
        static VOID Read(WdkTypes::PVOID Address, OUT PVOID Buffer, ULONG Size, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            if (!PhysicalMemory::KbReadPhysicalMemory(Address, Buffer, Size, CachingType))
                throw GetLastError();
        }

        static VOID Write(WdkTypes::PVOID Address, IN PVOID Buffer, ULONG Size, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            if (!PhysicalMemory::KbWritePhysicalMemory(Address, Buffer, Size, CachingType))
                throw GetLastError();
        }

        static BYTE ReadByte(WdkTypes::PVOID PhysicalAddress, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            BYTE Buffer = 0;
            Read(PhysicalAddress, &Buffer, sizeof(Buffer), CachingType);
            return Buffer;
        }

        static WORD ReadWord(WdkTypes::PVOID PhysicalAddress, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            WORD Buffer = 0;
            Read(PhysicalAddress, &Buffer, sizeof(Buffer), CachingType);
            return Buffer;
        }

        static DWORD ReadDword(WdkTypes::PVOID PhysicalAddress, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            DWORD Buffer = 0;
            Read(PhysicalAddress, &Buffer, sizeof(Buffer), CachingType);
            return Buffer;
        }

        static DWORD64 ReadQword(WdkTypes::PVOID PhysicalAddress, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            DWORD64 Buffer = 0;
            Read(PhysicalAddress, &Buffer, sizeof(Buffer), CachingType);
            return Buffer;
        }

        static VOID WriteByte(WdkTypes::PVOID PhysicalAddress, BYTE Value, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            Write(PhysicalAddress, &Value, sizeof(Value), CachingType);
        }

        static VOID WriteWord(WdkTypes::PVOID PhysicalAddress, WORD Value, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            Write(PhysicalAddress, &Value, sizeof(Value), CachingType);
        }

        static VOID WriteDword(WdkTypes::PVOID PhysicalAddress, DWORD Value, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            Write(PhysicalAddress, &Value, sizeof(Value), CachingType);
        }

        static VOID WriteQword(WdkTypes::PVOID PhysicalAddress, DWORD64 Value, WdkTypes::MEMORY_CACHING_TYPE CachingType) {
            Write(PhysicalAddress, &Value, sizeof(Value), CachingType);
        }

        static WdkTypes::PVOID GetPhysAddress(WdkTypes::PVOID Address) {
            WdkTypes::PVOID PA = NULL;
            if (!PhysicalMemory::KbGetPhysicalAddress(NULL, Address, &PA))
                throw GetLastError();
            return PA;
        }

        static WdkTypes::PVOID GetVirtualForPhysical(WdkTypes::PVOID PhysicalAddress) {
            WdkTypes::PVOID VirtualAddress = NULL;
            PhysicalMemory::KbGetVirtualForPhysical(PhysicalAddress, &VirtualAddress);
            return VirtualAddress;
        }
    };

    class VirtMem {
    public:
        static VOID Read(WdkTypes::PVOID Dest, WdkTypes::PVOID Src, ULONG Size) {
            if (!VirtualMemory::KbCopyMoveMemory(Dest, Src, Size, FALSE))
                throw GetLastError();
        }

        static VOID Write(WdkTypes::PVOID Dest, WdkTypes::PVOID Src, ULONG Size) {
            if (!VirtualMemory::KbCopyMoveMemory(Dest, Src, Size, FALSE))
                throw GetLastError();
        }

        static BYTE ReadByte(WdkTypes::PVOID VirtualAddress) {
            BYTE Buffer = 0;
            Read(reinterpret_cast<WdkTypes::PVOID>(&Buffer), VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        static WORD ReadWord(WdkTypes::PVOID VirtualAddress) {
            WORD Buffer = 0;
            Read(reinterpret_cast<WdkTypes::PVOID>(&Buffer), VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        static DWORD ReadDword(WdkTypes::PVOID VirtualAddress) {
            DWORD Buffer = 0;
            Read(reinterpret_cast<WdkTypes::PVOID>(&Buffer), VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        static DWORD64 ReadQword(WdkTypes::PVOID VirtualAddress) {
            DWORD64 Buffer = 0;
            Read(reinterpret_cast<WdkTypes::PVOID>(&Buffer), VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        static VOID WriteByte(WdkTypes::PVOID VirtualAddress, BYTE Value) {
            Write(VirtualAddress, reinterpret_cast<WdkTypes::PVOID>(&Value), sizeof(Value));
        }

        static VOID WriteWord(WdkTypes::PVOID VirtualAddress, WORD Value) {
            Write(VirtualAddress, reinterpret_cast<WdkTypes::PVOID>(&Value), sizeof(Value));
        }

        static VOID WriteDword(WdkTypes::PVOID VirtualAddress, DWORD Value) {
            Write(VirtualAddress, reinterpret_cast<WdkTypes::PVOID>(&Value), sizeof(Value));
        }

        static VOID WriteQword(WdkTypes::PVOID VirtualAddress, DWORD64 Value) {
            Write(VirtualAddress, reinterpret_cast<WdkTypes::PVOID>(&Value), sizeof(Value));
        }
    };

    class ProcMem {
        ULONG Pid;
    public:
        ProcMem(ULONG ProcessId) : Pid(ProcessId) {}
        
        VOID Attach(ULONG ProcessId) {
            Pid = ProcessId;
        }

        static WdkTypes::PVOID Alloc(ULONG ProcessId, ULONG Size, ULONG Protect = PAGE_EXECUTE_READWRITE) {
            WdkTypes::PVOID BaseAddress = NULL;
            if (!Processes::MemoryManagement::KbAllocUserMemory(ProcessId, Protect, Size, &BaseAddress))
                throw GetLastError();
            return BaseAddress;
        }

        WdkTypes::PVOID Alloc(ULONG Size, ULONG Protect = PAGE_EXECUTE_READWRITE) {
            return Alloc(Pid, Size, Protect);
        }

        static VOID Free(ULONG ProcessId, WdkTypes::PVOID BaseAddress) {
            if (Processes::MemoryManagement::KbFreeUserMemory(ProcessId, BaseAddress))
                throw GetLastError();
        }

        VOID Free(WdkTypes::PVOID BaseAddress) {
            Free(Pid, BaseAddress);
        }

        static VOID Read(ULONG ProcessId, PVOID Dest, WdkTypes::PVOID Src, ULONG Size) {
            if (!Processes::MemoryManagement::KbReadProcessMemory(ProcessId, Src, Dest, Size))
                throw GetLastError();
        }

        VOID Read(PVOID Dest, WdkTypes::PVOID Src, ULONG Size) const {
            Read(Pid, Dest, Src, Size);
        }

        static VOID Write(ULONG ProcessId, WdkTypes::PVOID Dest, PVOID Src, ULONG Size, BOOLEAN PerformCopyOnWrite = TRUE) {
            if (!Processes::MemoryManagement::KbWriteProcessMemory(ProcessId, Dest, Src, Size, PerformCopyOnWrite))
                throw GetLastError();
        }

        VOID Write(WdkTypes::PVOID Dest, PVOID Src, ULONG Size, BOOLEAN PerformCopyOnWrite = TRUE) {
            Write(Pid, Dest, Src, Size, PerformCopyOnWrite);
        }

        static BYTE ReadByte(ULONG ProcessId, WdkTypes::PVOID VirtualAddress) {
            BYTE Buffer = 0;
            Read(ProcessId, &Buffer, VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        BYTE ReadByte(WdkTypes::PVOID VirtualAddress) const {
            return ReadByte(Pid, VirtualAddress);
        }

        static WORD ReadWord(ULONG ProcessId, WdkTypes::PVOID VirtualAddress) {
            WORD Buffer = 0;
            Read(ProcessId, &Buffer, VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        WORD ReadWord(WdkTypes::PVOID VirtualAddress) const {
            return ReadWord(Pid, VirtualAddress);
        }

        static DWORD ReadDword(ULONG ProcessId, WdkTypes::PVOID VirtualAddress) {
            DWORD Buffer = 0;
            Read(ProcessId, &Buffer, VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        DWORD ReadDword(WdkTypes::PVOID VirtualAddress) const {
            return ReadDword(Pid, VirtualAddress);
        }

        static DWORD64 ReadQword(ULONG ProcessId, WdkTypes::PVOID VirtualAddress) {
            DWORD64 Buffer = 0;
            Read(ProcessId, &Buffer, VirtualAddress, sizeof(Buffer));
            return Buffer;
        }

        DWORD64 ReadQword(WdkTypes::PVOID VirtualAddress) const {
            return ReadQword(Pid, VirtualAddress);
        }

        static VOID WriteByte(ULONG ProcessId, WdkTypes::PVOID VirtualAddress, BYTE Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            Write(ProcessId, VirtualAddress, &Value, sizeof(Value), PerformCopyOnWrite);
        }

        VOID WriteByte(WdkTypes::PVOID VirtualAddress, BYTE Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            WriteByte(Pid, VirtualAddress, Value, PerformCopyOnWrite);
        }

        static VOID WriteWord(ULONG ProcessId, WdkTypes::PVOID VirtualAddress, WORD Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            Write(ProcessId, VirtualAddress, &Value, sizeof(Value), PerformCopyOnWrite);
        }

        VOID WriteWord(WdkTypes::PVOID VirtualAddress, WORD Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            WriteWord(Pid, VirtualAddress, Value, PerformCopyOnWrite);
        }

        static VOID WriteDword(ULONG ProcessId, WdkTypes::PVOID VirtualAddress, DWORD Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            Write(ProcessId, VirtualAddress, &Value, sizeof(Value), PerformCopyOnWrite);
        }

        VOID WriteDword(WdkTypes::PVOID VirtualAddress, DWORD Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            WriteDword(Pid, VirtualAddress, Value, PerformCopyOnWrite);
        }

        static VOID WriteQword(ULONG ProcessId, WdkTypes::PVOID VirtualAddress, DWORD64 Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            Write(ProcessId, VirtualAddress, &Value, sizeof(Value), PerformCopyOnWrite);
        }

        VOID WriteQword(WdkTypes::PVOID VirtualAddress, DWORD64 Value, BOOLEAN PerformCopyOnWrite = TRUE) {
            WriteQword(Pid, VirtualAddress, Value, PerformCopyOnWrite);
        }
    };
}
```

`User-Bridge/API/SymParser.cpp`:

```cpp
#include <windows.h>
#include <vector>
#include <string>
#include "SymParser.h"

// Using Wide-versions of DbgHelp functions:
#define DBGHELP_TRANSLATE_TCHAR

// Expose additional declarations from DbgHelp.h:
#define _NO_CVCONST_H 

#include <dbghelp.h>
#pragma comment(lib, "dbghelp.lib")

SymParser::SymParser(OPTIONAL LPCWSTR SymbolsPath) 
    : Initialized(FALSE), hProcess(GetCurrentProcess()), ModuleBase(NULL) 
{
    Initialized = SymInitialize(
        hProcess, 
        SymbolsPath ? SymbolsPath : DefaultSymbolsPath, 
        FALSE
    );
}

SymParser::~SymParser() {
    if (Initialized) SymCleanup(hProcess);
}


BOOL SymParser::LoadModule(LPCWSTR ModulePath, OPTIONAL DWORD64 ImageBase, OPTIONAL DWORD ImageSize) {
    ModuleBase = SymLoadModuleEx(hProcess, NULL, ModulePath, NULL, ImageBase, ImageSize, NULL, 0);
    return ModuleBase != NULL;
}


std::wstring SymParser::GetSymName(ULONG Index, OPTIONAL OUT PBOOL Status) {
    LPCWSTR Name = NULL;
    if (SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_SYMNAME, &Name) && Name) {
        std::wstring SymName = Name;
        VirtualFree(const_cast<LPWSTR>(Name), 0, MEM_RELEASE);
        if (Status) *Status = TRUE;
        return SymName;
    }
    if (Status) *Status = FALSE;
    return L"";
}

std::wstring SymParser::GetSymTypeName(ULONG Index, OPTIONAL OUT PUINT64 BaseTypeSize, OPTIONAL OUT PBOOL Status) {
    if (!Index) return L"";
    
    UINT64 SymSize = GetSymSize(Index, Status);
    if (BaseTypeSize) *BaseTypeSize = SymSize;
    std::wstring TypeName = GetSymName(Index, Status);
    if (!TypeName.empty()) return TypeName;

    enum SymTagEnum Tag = GetSymTag(Index, Status);
    switch (Tag) {
    case SymTagBaseType: {
        enum SymParser::BasicType Type = GetSymBaseType(Index, Status);
        switch (Type) {
        case btNoType: 
            TypeName = L"NO_TYPE";
            break;
        case btVoid:
            TypeName = L"VOID";
            break;
        case btChar:
            TypeName = L"CHAR";
            break;
        case btWChar:
            TypeName = L"WCHAR";
            break;
        case btInt:
            TypeName = SymSize == sizeof(INT64) ? L"INT64" : L"INT";
            break;
        case btUInt:
            TypeName = SymSize == sizeof(UINT64) ? L"UINT64" : L"UINT";
            break;
        case btFloat:
            TypeName = L"float";
            break;
        case btBCD:
            TypeName = L"BCD"; // Binary-coded decimal
            break;
        case btBool:
            TypeName = L"BOOL";
            break;
        case btLong:
            TypeName = SymSize == sizeof(LONGLONG) ? L"LONGLONG" : L"LONG";
            break;
        case btULong:
            TypeName = SymSize == sizeof(ULONGLONG) ? L"ULONGLONG" : L"ULONG";
            break;
        case btCurrency:
            TypeName = L"CurrencyType"; // ???
            break;
        case btDate:
            TypeName = L"DateType"; // ???
            break;
        case btVariant:
            TypeName = L"VariantType"; // ???
            break;
        case btComplex:
            TypeName = L"ComplexType"; // ???
            break;
        case btBit:
            TypeName = L"Bit";
            break;
        case btBSTR:
            TypeName = L"BSTR"; // Binary string
            break;
        case btHresult:
            TypeName = L"HRESULT";
            break;
        }
        break;
    }
    case SymTagPointerType: {
        ULONG Type = GetSymType(Index, Status);
        TypeName = GetSymTypeName(Type, BaseTypeSize, Status) + L"*";
        break;
    }
    case SymTagArrayType: {
        ULONG Type = GetSymArrayTypeId(Index, Status);
        TypeName = GetSymTypeName(Type, BaseTypeSize, Status);
        break;
    }
    default: {
        ULONG Type = GetSymType(Index, Status);
        TypeName = GetSymTypeName(Type, BaseTypeSize, Status);
    }
    }

    return TypeName;
}

UINT64 SymParser::GetSymSize(ULONG Index, OPTIONAL OUT PBOOL Status) {
    UINT64 Size = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_LENGTH, &Size);
    if (Status) *Status = SymStatus;
    return Size;
}

ULONG SymParser::GetSymOffset(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Offset = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_OFFSET, &Offset);
    if (Status) *Status = SymStatus;
    return Offset;
}

ULONG SymParser::GetSymAddressOffset(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Offset = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_ADDRESSOFFSET, &Offset);
    if (Status) *Status = SymStatus;
    return Offset;
}

ULONG SymParser::GetSymBitPosition(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG BitPosition = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_BITPOSITION, &BitPosition);
    if (Status) *Status = SymStatus;
    return BitPosition;
}

ULONG SymParser::GetSymTypeId(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG TypeId = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_TYPEID, &TypeId);
    if (Status) *Status = SymStatus;
    return TypeId;
}

ULONG SymParser::GetSymArrayTypeId(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG TypeId = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_ARRAYINDEXTYPEID, &TypeId);
    if (Status) *Status = SymStatus;
    return TypeId;
}

enum SymTagEnum SymParser::GetSymTag(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Tag = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_SYMTAG, &Tag);
    if (Status) *Status = SymStatus;
    return static_cast<enum SymTagEnum>(Tag);
}

enum SymParser::BasicType SymParser::GetSymType(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Type = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_TYPE, &Type);
    if (Status) *Status = SymStatus;
    return static_cast<enum BasicType>(Type);
}

enum SymParser::BasicType SymParser::GetSymBaseType(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG BasicType = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_BASETYPE, &BasicType);
    if (Status) *Status = SymStatus;
    return static_cast<enum BasicType>(BasicType);
}


BOOL SymParser::DumpSymbol(LPCWSTR SymbolName, OUT SYM_INFO& SymInfo) {
    SymInfo = {};

    // Obtaining root symbol:
    const ULONG SymNameLength = 128;
    const ULONG SymInfoSize = sizeof(SYMBOL_INFO) + SymNameLength * sizeof(WCHAR);
    std::vector<BYTE> RootSymbolInfoBuffer(SymInfoSize);
    auto RootSymbolInfo = reinterpret_cast<PSYMBOL_INFO>(&RootSymbolInfoBuffer[0]);
    RootSymbolInfo->SizeOfStruct = SymInfoSize;
    BOOL Status = SymGetTypeFromName(hProcess, ModuleBase, SymbolName, RootSymbolInfo);
    if (!Status) return FALSE;

    ULONG RootIndex = RootSymbolInfo->Index;

    SymInfo.Name = GetSymName(RootIndex);
    SymInfo.Size = GetSymSize(RootIndex);
    SymInfo.Offset = GetSymOffset(RootIndex, &Status);
    if (!Status) SymInfo.Offset = GetSymAddressOffset(RootIndex);

    // Obtaining root symbol children count:
    ULONG ChildrenCount = 0;
    Status = SymGetTypeInfo(hProcess, ModuleBase, RootIndex, TI_GET_CHILDRENCOUNT, &ChildrenCount);
    if (!Status) return FALSE;

    SymInfo.Name = SymbolName;
    SymGetTypeInfo(hProcess, ModuleBase, RootIndex, TI_GET_LENGTH, &SymInfo.Size);

    if (ChildrenCount) {
        // Obtaining children indices:
        std::vector<BYTE> FindChildrenParamsBuffer(sizeof(TI_FINDCHILDREN_PARAMS) + ChildrenCount * sizeof(ULONG));
        auto Children = reinterpret_cast<TI_FINDCHILDREN_PARAMS*>(&FindChildrenParamsBuffer[0]);
        Children->Count = ChildrenCount;
        Status = SymGetTypeInfo(hProcess, ModuleBase, RootIndex, TI_FINDCHILDREN, Children);
        if (!Status) return FALSE;

        for (unsigned int i = 0; i < ChildrenCount; i++) {
            SYM_CHILD_ENTRY Entry = {};
            ULONG ChildIndex = Children->ChildId[i];
            ULONG TypeId = GetSymTypeId(ChildIndex);
            Entry.Name = GetSymName(ChildIndex);
            Entry.Size = GetSymSize(TypeId);
            Entry.Offset = GetSymOffset(ChildIndex);
            Entry.BitPosition = GetSymBitPosition(ChildIndex, &Entry.IsBitField);
            UINT64 BaseTypeSize = 0;
            Entry.TypeName = GetSymTypeName(TypeId, &BaseTypeSize);
            Entry.ElementsCount = BaseTypeSize != 0 ? Entry.Size / BaseTypeSize : 1;

            if (Entry.Name.empty()) Entry.Name = L"UNKNOWN_NAME";
            if (Entry.TypeName.empty()) Entry.TypeName = L"UNKNOWN_TYPE";

            SymInfo.Entries.emplace_back(Entry);
        }
    }

    return TRUE;
}
```

`User-Bridge/API/SymParser.h`:

```h
#pragma once

class SymParser {
private:
    // From cvconst.h:
    enum BasicType {   
        btNoType   = 0,  
        btVoid     = 1,  
        btChar     = 2,  
        btWChar    = 3,  
        btInt      = 6,  
        btUInt     = 7,  
        btFloat    = 8,  
        btBCD      = 9,  
        btBool     = 10,  
        btLong     = 13,  
        btULong    = 14,  
        btCurrency = 25,  
        btDate     = 26,  
        btVariant  = 27,  
        btComplex  = 28,  
        btBit      = 29,  
        btBSTR     = 30,  
        btHresult  = 31  
    };

    BOOL Initialized;
    HANDLE hProcess;
    DWORD64 ModuleBase;
    LPCWSTR DefaultSymbolsPath = L"srv*C:\\Symbols*https://msdl.microsoft.com/download/symbols";

    std::wstring GetSymName(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    std::wstring GetSymTypeName(ULONG Index, OPTIONAL OUT PUINT64 BaseTypeSize = NULL, OPTIONAL OUT PBOOL Status = NULL);
    UINT64 GetSymSize(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymOffset(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymAddressOffset(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymBitPosition(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymTypeId(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymArrayTypeId(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    enum SymTagEnum GetSymTag(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    enum BasicType GetSymType(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    enum BasicType GetSymBaseType(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
public:
    using SYM_CHILD_ENTRY = struct {
        std::wstring Name;
        std::wstring TypeName;
        UINT64 ElementsCount;
        UINT64 Size;
        ULONG Offset;
        BOOL IsBitField;
        ULONG BitPosition;
    };
    using SYM_INFO = struct {
        std::wstring Name;
        UINT64 Size;
        ULONG Offset;
        std::vector<SYM_CHILD_ENTRY> Entries;
    };

    SymParser(OPTIONAL LPCWSTR SymbolsPath = NULL);
    ~SymParser();

    BOOL IsInitialized() const { return Initialized; }

    // Load symbols for specified module (*.exe/*.dll/*.sys etc.):
    BOOL LoadModule(LPCWSTR ModulePath, OPTIONAL DWORD64 ImageBase = NULL, OPTIONAL DWORD ImageSize = 0);

    BOOL DumpSymbol(LPCWSTR SymbolName, OUT SYM_INFO& SymInfo);
};
```

`User-Bridge/API/User-Bridge.cpp`:

```cpp
#include <Windows.h>

#include "WdkTypes.h"
#include "CtlTypes.h"
#include "User-Bridge.h"

#include "DriversUtils.h"

namespace KbLoader
{
    static constexpr LPCWSTR KbDriverName = L"Kernel-Bridge";
    static constexpr LPCWSTR KbDeviceName = L"\\\\.\\Kernel-Bridge";
    static HANDLE hDriver = INVALID_HANDLE_VALUE;
}

static inline BOOL WINAPI KbSendRequest(
    Ctls::KbCtlIndices Index, 
    IN PVOID Input = NULL, 
    ULONG InputSize = 0, 
    OUT PVOID Output = NULL, 
    ULONG OutputSize = 0
) {
    return SendIOCTL(KbLoader::hDriver, CTL_BASE + Index, Input, InputSize, Output, OutputSize);
}

namespace KbLoader
{
    BOOL WINAPI KbLoadAsDriver(LPCWSTR DriverPath)
    {
        // Check whether the Kernel-Bridge is already loaded:
        if (hDriver != INVALID_HANDLE_VALUE) return TRUE;
        hDriver = OpenDevice(KbDeviceName);
        if (hDriver != INVALID_HANDLE_VALUE) {
            ULONG DriverApiVersion = KbGetDriverApiVersion();
            if (KbGetUserApiVersion() == DriverApiVersion) return TRUE;
            
            ULONG HandlesCount = 0;
            if (!KbGetHandlesCount(&HandlesCount) || HandlesCount > 1) {
                CloseHandle(hDriver);
                hDriver = INVALID_HANDLE_VALUE;
                return FALSE;
            }

            CloseHandle(hDriver);
            hDriver = INVALID_HANDLE_VALUE;
        }

        // Removing tails from previous installation:
        DeleteDriver(KbDriverName);

        // Installing driver:
        BOOL Status = InstallDriver(DriverPath, KbDriverName);
        if (!Status) return FALSE;

        // Obtaining it's handle:
        hDriver = OpenDevice(KbDeviceName);
        if (hDriver == INVALID_HANDLE_VALUE) {
            DeleteDriver(KbDriverName);
            return FALSE;
        }

        return TRUE;
    }

    BOOL WINAPI KbLoadAsFilter(
        LPCWSTR DriverPath,
        LPCWSTR Altitude
    ) {
        // Check whether the Kernel-Bridge is already loaded:
        if (hDriver != INVALID_HANDLE_VALUE) return TRUE;
        hDriver = OpenDevice(KbDeviceName);
        if (hDriver != INVALID_HANDLE_VALUE) {
            ULONG DriverApiVersion = KbGetDriverApiVersion();
            if (KbGetUserApiVersion() == DriverApiVersion) return TRUE;
            
            ULONG HandlesCount = 0;
            if (!KbGetHandlesCount(&HandlesCount) || HandlesCount > 1) {
                CloseHandle(hDriver);
                hDriver = INVALID_HANDLE_VALUE;
                return FALSE;
            }

            CloseHandle(hDriver);
            hDriver = INVALID_HANDLE_VALUE;
        }

        // Removing tails from previous installation:
        DeleteDriver(KbDriverName);

        BOOL Status = InstallMinifilter(DriverPath, KbDriverName, Altitude);
        if (!Status) return FALSE;

        // Obtaining it's handle:
        hDriver = OpenDevice(KbDeviceName);
        if (hDriver == INVALID_HANDLE_VALUE) {
            DeleteDriver(KbDriverName);
            return FALSE;
        }

        return TRUE;
    }

    BOOL WINAPI KbUnload()
    {
        if (hDriver == INVALID_HANDLE_VALUE) return TRUE;
        
        ULONG HandlesCount = 0;
        if (KbGetHandlesCount(&HandlesCount) && HandlesCount > 1) {
            CloseHandle(hDriver);
            hDriver = INVALID_HANDLE_VALUE;
            return TRUE;
        }

        CloseHandle(hDriver);
        hDriver = INVALID_HANDLE_VALUE;
        return DeleteDriver(KbDriverName);
    }

    ULONG WINAPI KbGetDriverApiVersion()
    {
        if (hDriver == INVALID_HANDLE_VALUE) return 0;
        KB_GET_DRIVER_API_VERSION_OUT Output = {};
        KbSendRequest(Ctls::KbGetDriverApiVersion, NULL, 0, &Output, sizeof(Output));
        return Output.Version;
    }

    ULONG WINAPI KbGetUserApiVersion()
    {
        return KB_API_VERSION;
    }

    BOOL WINAPI KbGetHandlesCount(OUT PULONG Count)
    {
        if (!Count) return FALSE;
        KB_GET_HANDLES_COUNT_OUT Output = {};
        BOOL Status = KbSendRequest(Ctls::KbGetHandlesCount, NULL, 0, &Output, sizeof(Output));
        *Count = Output.HandlesCount;
        return Status;
    }
}

namespace IO
{
    namespace Beeper
    {
        BOOL WINAPI KbSetBeeperRegime()
        {
            return KbSendRequest(Ctls::KbSetBeeperRegime);
        }

        BOOL WINAPI KbStartBeeper()
        {
            return KbSendRequest(Ctls::KbStartBeeper);
        }

        BOOL WINAPI KbStopBeeper()
        {
            return KbSendRequest(Ctls::KbStopBeeper);
        }

        BOOL WINAPI KbSetBeeperIn()
        {
            return KbSendRequest(Ctls::KbSetBeeperIn);
        }

        BOOL WINAPI KbSetBeeperOut()
        {
            return KbSendRequest(Ctls::KbSetBeeperOut);
        }

        BOOL WINAPI KbSetBeeperDivider(USHORT Divider)
        {
            KB_SET_BEEPER_DIVIDER_IN Input = {};
            Input.Divider = Divider;
            return KbSendRequest(Ctls::KbSetBeeperDivider, &Input, sizeof(Input));
        }

        BOOL WINAPI KbSetBeeperFrequency(USHORT Frequency)
        {
            KB_SET_BEEPER_FREQUENCY_IN Input = {};
            Input.Frequency = Frequency;
            return KbSendRequest(Ctls::KbSetBeeperFrequency, &Input, sizeof(Input));
        }
    }

    namespace RW
    {
        BOOL WINAPI KbReadPortByte(USHORT PortNumber, OUT PUCHAR Value)
        {
            if (!Value) return FALSE;
            KB_READ_PORT_IN Input = {};
            KB_READ_PORT_BYTE_OUT Output = {};
            Input.PortNumber = PortNumber;
            BOOLEAN Status = KbSendRequest(Ctls::KbReadPort, &Input, sizeof(Input), &Output, sizeof(Output));
            *Value = Output.Value;
            return Status;
        }

        BOOL WINAPI KbReadPortWord(USHORT PortNumber, OUT PUSHORT Value)
        {
            if (!Value) return FALSE;
            KB_READ_PORT_IN Input = {};
            KB_READ_PORT_WORD_OUT Output = {};
            Input.PortNumber = PortNumber;
            BOOLEAN Status = KbSendRequest(Ctls::KbReadPort, &Input, sizeof(Input), &Output, sizeof(Output));
            *Value = Output.Value;
            return Status;
        }

        BOOL WINAPI KbReadPortDword(USHORT PortNumber, OUT PULONG Value)
        {
            if (!Value) return FALSE;
            KB_READ_PORT_IN Input = {};
            KB_READ_PORT_DWORD_OUT Output = {};
            Input.PortNumber = PortNumber;
            BOOLEAN Status = KbSendRequest(Ctls::KbReadPort, &Input, sizeof(Input), &Output, sizeof(Output));
            *Value = Output.Value;
            return Status;
        }

        BOOL WINAPI KbReadPortByteString(USHORT PortNumber, ULONG Count, OUT PUCHAR ByteString, ULONG ByteStringSizeInBytes)
        {
            if (!Count || !ByteString || !ByteStringSizeInBytes) return FALSE;
            KB_READ_PORT_STRING_IN Input = {};
            auto Output = reinterpret_cast<PKB_READ_PORT_STRING_OUT>(ByteString);
            Input.PortNumber = PortNumber;
            return KbSendRequest(Ctls::KbReadPortString, &Input, sizeof(Input), Output, ByteStringSizeInBytes);
        }

        BOOL WINAPI KbReadPortWordString(USHORT PortNumber, ULONG Count, OUT PUSHORT WordString, ULONG WordStringSizeInBytes)
        {
            if (!Count || !WordString || !WordStringSizeInBytes) return FALSE;
            KB_READ_PORT_STRING_IN Input = {};
            auto Output = reinterpret_cast<PKB_READ_PORT_STRING_OUT>(WordString);
            Input.PortNumber = PortNumber;
            return KbSendRequest(Ctls::KbReadPortString, &Input, sizeof(Input), Output, WordStringSizeInBytes);
        }

        BOOL WINAPI KbReadPortDwordString(USHORT PortNumber, ULONG Count, OUT PULONG DwordString, ULONG DwordStringSizeInBytes)
        {
            if (!Count || !DwordString || !DwordStringSizeInBytes) return FALSE;
            KB_READ_PORT_STRING_IN Input = {};
            auto Output = reinterpret_cast<PKB_READ_PORT_STRING_OUT>(DwordString);
            Input.PortNumber = PortNumber;
            return KbSendRequest(Ctls::KbReadPortString, &Input, sizeof(Input), Output, DwordStringSizeInBytes);
        }

        BOOL WINAPI KbWritePortByte(USHORT PortNumber, UCHAR Value)
        {
            KB_WRITE_PORT_IN Input = {};
            Input.PortNumber = PortNumber;
            Input.Granularity = sizeof(Value);
            Input.Byte = Value;
            return KbSendRequest(Ctls::KbWritePort, &Input, sizeof(Input));
        }

        BOOL WINAPI KbWritePortWord(USHORT PortNumber, USHORT Value)
        {
            KB_WRITE_PORT_IN Input = {};
            Input.PortNumber = PortNumber;
            Input.Granularity = sizeof(Value);
            Input.Word = Value;
            return KbSendRequest(Ctls::KbWritePort, &Input, sizeof(Input));
        }

        BOOL WINAPI KbWritePortDword(USHORT PortNumber, ULONG Value)
        {
            KB_WRITE_PORT_IN Input = {};
            Input.PortNumber = PortNumber;
            Input.Granularity = sizeof(Value);
            Input.Dword = Value;
            return KbSendRequest(Ctls::KbWritePort, &Input, sizeof(Input));
        }

        BOOL WINAPI KbWritePortByteString(USHORT PortNumber, ULONG Count, IN PUCHAR ByteString, ULONG ByteStringSizeInBytes)
        {
            if (!ByteString || ByteStringSizeInBytes < Count * sizeof(*ByteString)) return FALSE;
            KB_WRITE_PORT_STRING_IN Input = {};
            Input.PortNumber = PortNumber;
            Input.Granularity = sizeof(*ByteString);
            Input.Count = Count;
            Input.BufferSize = ByteStringSizeInBytes;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(ByteString);
            return KbSendRequest(Ctls::KbWritePortString, &Input, sizeof(Input));
        }

        BOOL WINAPI KbWritePortWordString(USHORT PortNumber, ULONG Count, IN PUSHORT WordString, ULONG WordStringSizeInBytes)
        {
            if (!WordString || WordStringSizeInBytes < Count * sizeof(*WordString)) return FALSE;
            KB_WRITE_PORT_STRING_IN Input = {};
            Input.PortNumber = PortNumber;
            Input.Granularity = sizeof(*WordString);
            Input.Count = Count;
            Input.BufferSize = WordStringSizeInBytes;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(WordString);
            return KbSendRequest(Ctls::KbWritePortString, &Input, sizeof(Input));
        }

        BOOL WINAPI KbWritePortDwordString(USHORT PortNumber, ULONG Count, IN PULONG DwordString, ULONG DwordStringSizeInBytes)
        {
            if (!DwordString || DwordStringSizeInBytes < Count * sizeof(*DwordString)) return FALSE;
            KB_WRITE_PORT_STRING_IN Input = {};
            Input.PortNumber = PortNumber;
            Input.Granularity = sizeof(*DwordString);
            Input.Count = Count;
            Input.BufferSize = DwordStringSizeInBytes;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(DwordString);
            return KbSendRequest(Ctls::KbWritePortString, &Input, sizeof(Input));
        }
    }

    namespace Iopl
    {
        BOOL WINAPI KbRaiseIopl()
        {
            return KbSendRequest(Ctls::KbRaiseIopl);
        }

        BOOL WINAPI KbResetIopl()
        {
            return KbSendRequest(Ctls::KbResetIopl);
        }    
    }
}

namespace CPU
{
    BOOL WINAPI KbCli()
    {
        return KbSendRequest(Ctls::KbCli);
    }

    BOOL WINAPI KbSti()
    {
        return KbSendRequest(Ctls::KbSti);
    }    

    BOOL WINAPI KbHlt()
    {
        return KbSendRequest(Ctls::KbHlt);
    }    

    BOOL WINAPI KbReadMsr(ULONG Index, OUT PUINT64 MsrValue)
    {
        if (!MsrValue) return FALSE;
        KB_READ_MSR_IN Input = {};
        KB_READ_MSR_OUT Output = {};
        Input.Index = Index;
        BOOL Status = KbSendRequest(Ctls::KbReadMsr, &Input, sizeof(Input), &Output, sizeof(Output));
        *MsrValue = Output.Value;
        return Status;
    }

    BOOL WINAPI KbWriteMsr(ULONG Index, IN UINT64 MsrValue)
    {
        KB_WRITE_MSR_IN Input = {};
        Input.Index = Index;
        Input.Value = MsrValue;
        return KbSendRequest(Ctls::KbWriteMsr, &Input, sizeof(Input));
    }

    BOOL WINAPI KbCpuid(ULONG FunctionIdEax, OUT PCPUID_INFO CpuidInfo)
    {
        if (!CpuidInfo) return FALSE;
        KB_CPUID_IN Input = {};
        KB_CPUID_OUT Output = {};
        Input.FunctionIdEax = FunctionIdEax;
        BOOL Status = KbSendRequest(Ctls::KbCpuid, &Input, sizeof(Input), &Output, sizeof(Output));
        CpuidInfo->Eax = Output.Eax;
        CpuidInfo->Ebx = Output.Ebx;
        CpuidInfo->Ecx = Output.Ecx;
        CpuidInfo->Edx = Output.Edx;
        return Status;
    }

    BOOL WINAPI KbCpuidEx(ULONG FunctionIdEax, ULONG SubfunctionIdEcx, OUT PCPUID_INFO CpuidInfo)
    {
        if (!CpuidInfo) return FALSE;
        KB_CPUIDEX_IN Input = {};
        KB_CPUID_OUT Output = {};
        Input.FunctionIdEax = FunctionIdEax;
        Input.SubfunctionIdEcx = SubfunctionIdEcx;
        BOOL Status = KbSendRequest(Ctls::KbCpuidEx, &Input, sizeof(Input), &Output, sizeof(Output));
        CpuidInfo->Eax = Output.Eax;
        CpuidInfo->Ebx = Output.Ebx;
        CpuidInfo->Ecx = Output.Ecx;
        CpuidInfo->Edx = Output.Edx;
        return Status;
    }

    BOOL WINAPI KbReadPmc(ULONG Counter, OUT PUINT64 PmcValue)
    {
        if (!PmcValue) return FALSE;
        KB_READ_PMC_IN Input = {};
        KB_READ_PMC_OUT Output = {};
        Input.Counter = Counter;
        BOOL Status = KbSendRequest(Ctls::KbReadPmc, &Input, sizeof(Input), &Output, sizeof(Output));
        *PmcValue = Output.Value;
        return Status;
    }

    BOOL WINAPI KbReadTsc(OUT PUINT64 TscValue)
    {
        if (!TscValue) return FALSE;
        KB_READ_TSC_OUT Output = {};
        BOOL Status = KbSendRequest(Ctls::KbReadTsc, NULL, 0, &Output, sizeof(Output));
        *TscValue = Output.Value;
        return Status;
    }

    BOOL WINAPI KbReadTscp(OUT PUINT64 TscValue, OUT OPTIONAL PULONG TscAux)
    {
        if (!TscValue) return FALSE;
        KB_READ_TSCP_OUT Output = {};
        BOOL Status = KbSendRequest(Ctls::KbReadTscp, NULL, 0, &Output, sizeof(Output));
        *TscValue = Output.Value;
        if (TscAux) *TscAux = Output.TscAux;
        return Status;
    }
}

namespace VirtualMemory
{
    BOOL WINAPI KbAllocKernelMemory(ULONG Size, BOOLEAN Executable, OUT WdkTypes::PVOID* KernelAddress)
    {
        if (!Size || !KernelAddress) return FALSE;
        KB_ALLOC_KERNEL_MEMORY_IN Input = {};
        KB_ALLOC_KERNEL_MEMORY_OUT Output = {};
        Input.Size = Size;
        Input.Executable = Executable;
        BOOL Status = KbSendRequest(Ctls::KbAllocKernelMemory, &Input, sizeof(Input), &Output, sizeof(Output));
        *KernelAddress = Output.KernelAddress;
        return Status;
    }

    BOOL WINAPI KbFreeKernelMemory(IN WdkTypes::PVOID KernelAddress)
    {
        if (!KernelAddress) return FALSE;
        KB_FREE_KERNEL_MEMORY_IN Input = {};
        Input.KernelAddress = KernelAddress;
        BOOL Status = KbSendRequest(Ctls::KbFreeKernelMemory, &Input, sizeof(Input));
        DWORD LE = GetLastError();
        return Status;
    }

    BOOL WINAPI KbAllocNonCachedMemory(ULONG Size, OUT WdkTypes::PVOID* KernelAddress)
    {
        if (!Size || !KernelAddress) return FALSE;
        KB_ALLOC_NON_CACHED_MEMORY_IN Input = {};
        KB_ALLOC_NON_CACHED_MEMORY_OUT Output = {};
        Input.Size = Size;
        BOOL Status = KbSendRequest(Ctls::KbAllocNonCachedMemory, &Input, sizeof(Input), &Output, sizeof(Output));
        *KernelAddress = Output.KernelAddress;
        return Status;
    }

    BOOL WINAPI KbFreeNonCachedMemory(WdkTypes::PVOID KernelAddress, ULONG Size)
    {
        if (!KernelAddress) return FALSE;
        KB_FREE_NON_CACHED_MEMORY_IN Input = {};
        Input.KernelAddress = KernelAddress;
        Input.Size = Size;
        return KbSendRequest(Ctls::KbFreeNonCachedMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbCopyMoveMemory(OUT WdkTypes::PVOID Dest, IN WdkTypes::PVOID Src, ULONG Size, BOOLEAN Intersects)
    {
        if (!Dest || !Src || !Size) return FALSE;
        KB_COPY_MOVE_MEMORY_IN Input = {};
        Input.Src = Src;
        Input.Dest = Dest;
        Input.Size = Size;
        Input.Intersects = Intersects;
        return KbSendRequest(Ctls::KbCopyMoveMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbFillMemory(IN WdkTypes::PVOID Address, UCHAR Filler, ULONG Size)
    {
        if (!Address || !Size) return FALSE;
        KB_FILL_MEMORY_IN Input = {};
        Input.Address = Address;
        Input.Size = Size;
        Input.Filler = Filler;
        return KbSendRequest(Ctls::KbFillMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbEqualMemory(IN WdkTypes::PVOID Src, IN WdkTypes::PVOID Dest, ULONG Size, OUT PBOOLEAN Equals)
    {
        if (!Src || !Dest || !Size || !Equals) return FALSE;
        KB_EQUAL_MEMORY_IN Input = {};
        KB_EQUAL_MEMORY_OUT Output = {};
        Input.Src = Src;
        Input.Dest = Dest;
        Input.Size = Size;
        BOOL Status = KbSendRequest(Ctls::KbEqualMemory, &Input, sizeof(Input), &Output, sizeof(Output));
        *Equals = Output.Equals;
        return Status;
    }
}

namespace Mdl
{
    BOOL WINAPI KbAllocateMdl(
        WdkTypes::PVOID VirtualAddress,
        ULONG Size,
        OUT WdkTypes::PMDL* Mdl
    ) {
        if (!VirtualAddress || !Size || !Mdl) return FALSE;
        KB_ALLOCATE_MDL_IN Input = {};
        KB_ALLOCATE_MDL_OUT Output = {};
        Input.VirtualAddress = VirtualAddress;
        Input.Size = Size;
        BOOL Status = KbSendRequest(Ctls::KbAllocateMdl, &Input, sizeof(Input), &Output, sizeof(Output));
        *Mdl = Output.Mdl;
        return Status;
    }

    BOOL WINAPI KbProbeAndLockPages(
        OPTIONAL ULONG ProcessId,
        WdkTypes::PMDL Mdl,
        WdkTypes::KPROCESSOR_MODE ProcessorMode,
        WdkTypes::LOCK_OPERATION LockOperation
    ) {
        if (!Mdl) return FALSE;
        KB_PROBE_AND_LOCK_PAGES_IN Input = {};
        Input.ProcessId = ProcessId;
        Input.Mdl = Mdl;
        Input.ProcessorMode = ProcessorMode;
        Input.LockOperation = LockOperation;
        return KbSendRequest(Ctls::KbProbeAndLockPages, &Input, sizeof(Input));
    }

    BOOL WINAPI KbMapMdl(
        OUT WdkTypes::PVOID* MappedMemory,
        OPTIONAL UINT64 SrcProcessId,
        OPTIONAL UINT64 DestProcessId,
        WdkTypes::PMDL Mdl,
        BOOLEAN NeedProbeAndLock,
        WdkTypes::KPROCESSOR_MODE MapToAddressSpace,
        ULONG Protect,
        WdkTypes::MEMORY_CACHING_TYPE CacheType,
        OPTIONAL WdkTypes::PVOID UserRequestedAddress
    ) {
        if (!MappedMemory) return FALSE;
        KB_MAP_MDL_IN Input = {};
        KB_MAP_MDL_OUT Output = {};
        Input.SrcProcessId = SrcProcessId;
        Input.DestProcessId = DestProcessId;
        Input.Mdl = Mdl;
        Input.NeedProbeAndLock = NeedProbeAndLock;
        Input.MapToAddressSpace = MapToAddressSpace;
        Input.Protect = Protect;
        Input.CacheType = CacheType;
        Input.UserRequestedAddress = UserRequestedAddress;
        BOOL Status = KbSendRequest(Ctls::KbMapMdl, &Input, sizeof(Input), &Output, sizeof(Output));
        *MappedMemory = Output.BaseAddress;
        return Status;
    }

    BOOL WINAPI KbProtectMappedMemory(IN WdkTypes::PMDL Mdl, ULONG Protect)
    {
        if (!Mdl) return FALSE;
        KB_PROTECT_MAPPED_MEMORY_IN Input = {};
        Input.Mdl = Mdl;
        Input.Protect = Protect;
        return KbSendRequest(Ctls::KbProtectMappedMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbUnmapMdl(IN WdkTypes::PMDL Mdl, IN WdkTypes::PVOID MappedMemory, BOOLEAN NeedUnlock)
    {
        if (!Mdl || !MappedMemory) return FALSE;
        KB_UNMAP_MDL_IN Input = {};
        Input.Mdl = Mdl;
        Input.BaseAddress = MappedMemory;
        Input.NeedUnlock = NeedUnlock;
        return KbSendRequest(Ctls::KbUnmapMdl, &Input, sizeof(Input));
    }

    BOOL WINAPI KbUnlockPages(WdkTypes::PMDL Mdl)
    {
        if (!Mdl) return FALSE;
        KB_UNLOCK_PAGES_IN Input = {};
        Input.Mdl = Mdl;
        return KbSendRequest(Ctls::KbUnlockPages, &Input, sizeof(Input));
    }

    BOOL WINAPI KbFreeMdl(WdkTypes::PMDL Mdl)
    {
        if (!Mdl) return FALSE;
        KB_FREE_MDL_IN Input = {};
        Input.Mdl = Mdl;
        return KbSendRequest(Ctls::KbFreeMdl, &Input, sizeof(Input));
    }

    BOOL WINAPI KbMapMemory(
        OUT PMAPPING_INFO MappingInfo,
        OPTIONAL UINT64 SrcProcessId,
        OPTIONAL UINT64 DestProcessId,
        WdkTypes::PVOID VirtualAddress,
        ULONG Size,
        WdkTypes::KPROCESSOR_MODE MapToAddressSpace,
        ULONG Protect,
        WdkTypes::MEMORY_CACHING_TYPE CacheType,
        OPTIONAL WdkTypes::PVOID UserRequestedAddress
    ) {
        if (!MappingInfo || !Size) return FALSE;
        KB_MAP_MEMORY_IN Input = {};
        KB_MAP_MEMORY_OUT Output = {};
        Input.SrcProcessId = SrcProcessId;
        Input.DestProcessId = DestProcessId;
        Input.VirtualAddress = VirtualAddress;
        Input.Size = Size;
        Input.MapToAddressSpace = MapToAddressSpace;
        Input.Protect = Protect;
        Input.CacheType = CacheType;
        Input.UserRequestedAddress = UserRequestedAddress;
        BOOL Status = KbSendRequest(Ctls::KbMapMemory, &Input, sizeof(Input), &Output, sizeof(Output));
        MappingInfo->MappedAddress = Output.BaseAddress;
        MappingInfo->Mdl = Output.Mdl;
        return Status;
    }

    BOOL WINAPI KbUnmapMemory(IN PMAPPING_INFO MappingInfo)
    {
        if (!MappingInfo || !MappingInfo->Mdl) return FALSE;
        KB_UNMAP_MEMORY_IN Input = {};
        Input.Mdl = MappingInfo->Mdl;
        Input.BaseAddress = MappingInfo->MappedAddress;
        return KbSendRequest(Ctls::KbUnmapMemory, &Input, sizeof(Input));
    }
}

namespace PhysicalMemory
{
    BOOL WINAPI KbAllocPhysicalMemory(
        WdkTypes::PVOID LowestAcceptableAddress,
        WdkTypes::PVOID HighestAcceptableAddress,
        WdkTypes::PVOID BoundaryAddressMultiple,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType,
        OUT WdkTypes::PVOID* Address
    ) {
        if (!Size || !Address) return FALSE;
        KB_ALLOC_PHYSICAL_MEMORY_IN Input = {};
        KB_ALLOC_PHYSICAL_MEMORY_OUT Output = {};
        Input.LowestAcceptableAddress = LowestAcceptableAddress;
        Input.HighestAcceptableAddress = HighestAcceptableAddress;
        Input.BoundaryAddressMultiple = BoundaryAddressMultiple;
        Input.Size = Size;
        Input.CachingType = CachingType;
        BOOL Status = KbSendRequest(Ctls::KbAllocPhysicalMemory, &Input, sizeof(Input), &Output, sizeof(Output));
        *Address = Output.Address;
        return Status;
    }

    BOOL WINAPI KbFreePhysicalMemory(WdkTypes::PVOID Address)
    {
        if (!Address) return FALSE;
        KB_FREE_PHYSICAL_MEMORY_IN Input = {};
        Input.Address = Address;
        return KbSendRequest(Ctls::KbFreePhysicalMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbMapPhysicalMemory(
        IN WdkTypes::PVOID PhysicalAddress, 
        ULONG Size, 
        WdkTypes::MEMORY_CACHING_TYPE CachingType,
        OUT WdkTypes::PVOID* VirtualAddress
    ) {
        if (!Size || !VirtualAddress) return FALSE;
        KB_MAP_PHYSICAL_MEMORY_IN Input = {};
        KB_MAP_PHYSICAL_MEMORY_OUT Output = {};
        Input.PhysicalAddress = PhysicalAddress;
        Input.Size = Size;
        Input.CachingType = CachingType;
        BOOL Status = KbSendRequest(Ctls::KbMapPhysicalMemory, &Input, sizeof(Input), &Output, sizeof(Output));
        *VirtualAddress = Output.VirtualAddress;
        return Status;
    }

    BOOL WINAPI KbUnmapPhysicalMemory(IN WdkTypes::PVOID VirtualAddress, ULONG Size)
    {
        if (!VirtualAddress || !Size) return FALSE;
        KB_UNMAP_PHYSICAL_MEMORY_IN Input = {};
        Input.VirtualAddress = VirtualAddress;
        Input.Size = Size;
        return KbSendRequest(Ctls::KbUnmapPhysicalMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbGetPhysicalAddress(
        IN OPTIONAL WdkTypes::PEPROCESS Process, 
        IN WdkTypes::PVOID VirtualAddress,
        OUT WdkTypes::PVOID* PhysicalAddress
    ) {
        if (!PhysicalAddress) return FALSE;
        KB_GET_PHYSICAL_ADDRESS_IN Input = {};
        KB_GET_PHYSICAL_ADDRESS_OUT Output = {};
        Input.Process = Process;
        Input.VirtualAddress = VirtualAddress;
        BOOL Status = KbSendRequest(Ctls::KbGetPhysicalAddress, &Input, sizeof(Input), &Output, sizeof(Output));
        *PhysicalAddress = Output.PhysicalAddress;
        return Status;
    }

    BOOL WINAPI KbGetVirtualForPhysical(
        IN WdkTypes::PVOID PhysicalAddress, 
        OUT WdkTypes::PVOID* VirtualAddress    
    ) {
        if (!VirtualAddress) return FALSE;
        KB_GET_VIRTUAL_FOR_PHYSICAL_IN Input = {};
        KB_GET_VIRTUAL_FOR_PHYSICAL_OUT Output = {};
        Input.PhysicalAddress = PhysicalAddress;
        BOOL Status = KbSendRequest(Ctls::KbGetVirtualForPhysical, &Input, sizeof(Input), &Output, sizeof(Output));
        *VirtualAddress = Output.VirtualAddress;
        return Status;
    }

    BOOL WINAPI KbReadPhysicalMemory(
        WdkTypes::PVOID64 PhysicalAddress,
        OUT PVOID Buffer,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType
    ) {
        if (!Buffer || !Size) return FALSE;
        KB_READ_WRITE_PHYSICAL_MEMORY_IN Input = {};
        Input.PhysicalAddress = PhysicalAddress;
        Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
        Input.Size = Size;
        Input.CachingType = CachingType;
        return KbSendRequest(Ctls::KbReadPhysicalMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbWritePhysicalMemory(
        WdkTypes::PVOID64 PhysicalAddress,
        IN PVOID Buffer,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType
    ) {
        if (!Buffer || !Size) return FALSE;
        KB_READ_WRITE_PHYSICAL_MEMORY_IN Input = {};
        Input.PhysicalAddress = PhysicalAddress;
        Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
        Input.Size = Size;
        Input.CachingType = CachingType;
        return KbSendRequest(Ctls::KbWritePhysicalMemory, &Input, sizeof(Input));
    }

    BOOL WINAPI KbReadDmiMemory(OUT UCHAR DmiMemory[DmiSize], ULONG BufferSize)
    {
        if (BufferSize != DmiSize) return FALSE;
        return KbSendRequest(Ctls::KbReadDmiMemory, NULL, 0, reinterpret_cast<PKB_READ_DMI_MEMORY_OUT>(DmiMemory), BufferSize);
    }
}

namespace Processes
{
    namespace Descriptors
    {
        BOOL WINAPI KbGetEprocess(ULONG ProcessId, OUT WdkTypes::PEPROCESS* Process)
        {
            if (!Process) return FALSE;
            KB_GET_EPROCESS_IN Input = {};
            KB_GET_EPROCESS_OUT Output = {};
            Input.ProcessId = ProcessId;
            BOOL Status = KbSendRequest(Ctls::KbGetEprocess, &Input, sizeof(Input), &Output, sizeof(Output));
            *Process = Output.Process;
            return Status;
        }

        BOOL WINAPI KbGetEthread(ULONG ThreadId, OUT WdkTypes::PETHREAD* Thread)
        {
            if (!Thread) return FALSE;
            KB_GET_ETHREAD_IN Input = {};
            KB_GET_ETHREAD_OUT Output = {};
            Input.ThreadId = ThreadId;
            BOOL Status = KbSendRequest(Ctls::KbGetEthread, &Input, sizeof(Input), &Output, sizeof(Output));
            *Thread = Output.Thread;
            return Status;
        }

        BOOL WINAPI KbOpenProcess(ULONG ProcessId, OUT WdkTypes::HANDLE* hProcess, OPTIONAL ACCESS_MASK Access, OPTIONAL ULONG Attributes)
        {
            if (!hProcess) return FALSE;
            KB_OPEN_PROCESS_IN Input = {};
            KB_OPEN_PROCESS_OUT Output = {};
            Input.ProcessId = ProcessId;
            Input.Access = Access;
            Input.Attributes = Attributes;
            BOOL Status = KbSendRequest(Ctls::KbOpenProcess, &Input, sizeof(Input), &Output, sizeof(Output));
            *hProcess = Output.hProcess;
            return Status;
        }

        BOOL WINAPI KbOpenProcessByPointer(
            WdkTypes::PEPROCESS Process, 
            OUT WdkTypes::HANDLE* hProcess, 
            OPTIONAL ACCESS_MASK Access, 
            OPTIONAL ULONG Attributes,
            OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode
        ) {
            if (!hProcess) return FALSE;
            KB_OPEN_PROCESS_BY_POINTER_IN Input = {};
            KB_OPEN_PROCESS_OUT Output = {};
            Input.Process = Process;
            Input.Access = Access;
            Input.Attributes = Attributes;
            Input.ProcessorMode = ProcessorMode;
            BOOL Status = KbSendRequest(Ctls::KbOpenProcessByPointer, &Input, sizeof(Input), &Output, sizeof(Output));
            *hProcess = Output.hProcess;
            return Status;
        }

        BOOL WINAPI KbOpenThread(ULONG ThreadId, OUT WdkTypes::HANDLE* hThread, OPTIONAL ACCESS_MASK Access, OPTIONAL ULONG Attributes)
        {
            if (!hThread) return FALSE;
            KB_OPEN_THREAD_IN Input = {};
            KB_OPEN_THREAD_OUT Output = {};
            Input.ThreadId = ThreadId;
            Input.Access = Access;
            Input.Attributes = Attributes;
            BOOL Status = KbSendRequest(Ctls::KbOpenThread, &Input, sizeof(Input), &Output, sizeof(Output));
            *hThread = Output.hThread;
            return Status;
        }

        BOOL WINAPI KbOpenThreadByPointer(
            WdkTypes::PETHREAD Thread, 
            OUT WdkTypes::HANDLE* hThread, 
            OPTIONAL ACCESS_MASK Access, 
            OPTIONAL ULONG Attributes,
            OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode
        ) {
            if (!hThread) return FALSE;
            KB_OPEN_THREAD_BY_POINTER_IN Input = {};
            KB_OPEN_THREAD_OUT Output = {};
            Input.Thread = Thread;
            Input.Access = Access;
            Input.Attributes = Attributes;
            Input.ProcessorMode = ProcessorMode;
            BOOL Status = KbSendRequest(Ctls::KbOpenThreadByPointer, &Input, sizeof(Input), &Output, sizeof(Output));
            *hThread = Output.hThread;
            return Status;
        }

        BOOL WINAPI KbDereferenceObject(WdkTypes::PVOID Object)
        {
            if (!Object) return FALSE;
            KB_DEREFERENCE_OBJECT_IN Input = {};
            Input.Object = Object;
            return KbSendRequest(Ctls::KbDereferenceObject, &Input, sizeof(Input));
        }

        BOOL WINAPI KbCloseHandle(WdkTypes::HANDLE Handle)
        {
            if (!Handle) return FALSE;
            KB_CLOSE_HANDLE_IN Input = {};
            Input.Handle = Handle;
            return KbSendRequest(Ctls::KbCloseHandle, &Input, sizeof(Input));
        }
    }

    namespace Information
    {
        BOOL WINAPI KbQueryInformationProcess(
            WdkTypes::HANDLE hProcess,
            NtTypes::PROCESSINFOCLASS ProcessInfoClass,
            OUT PVOID Buffer,
            ULONG Size,
            OPTIONAL OUT PULONG ReturnLength
        ) {
            ULONG RetLength = 0;
            KB_QUERY_INFORMATION_PROCESS_THREAD_IN Input = {};
            Input.Handle = hProcess;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
            Input.ReturnLength = reinterpret_cast<WdkTypes::PVOID>(&RetLength);
            Input.InfoClass = static_cast<ULONG>(ProcessInfoClass);
            Input.Size = Size;
            BOOL Status = KbSendRequest(Ctls::KbQueryInformationProcess, &Input, sizeof(Input));
            if (ReturnLength) *ReturnLength = RetLength;
            return Status;
        }

        BOOL WINAPI KbSetInformationProcess(
            WdkTypes::HANDLE hProcess,
            NtTypes::PROCESSINFOCLASS ProcessInfoClass,
            IN PVOID Buffer,
            ULONG Size
        ) {
            KB_SET_INFORMATION_PROCESS_THREAD_IN Input = {};
            Input.Handle = hProcess;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
            Input.InfoClass = static_cast<ULONG>(ProcessInfoClass);
            Input.Size = Size;
            return KbSendRequest(Ctls::KbSetInformationProcess, &Input, sizeof(Input));
        }

        BOOL WINAPI KbQueryInformationThread(
            WdkTypes::HANDLE hThread,
            NtTypes::THREADINFOCLASS ThreadInfoClass,
            OUT PVOID Buffer,
            ULONG Size,
            OPTIONAL OUT PULONG ReturnLength
        ) {
            ULONG RetLength = 0;
            KB_QUERY_INFORMATION_PROCESS_THREAD_IN Input = {};
            Input.Handle = hThread;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
            Input.ReturnLength = reinterpret_cast<WdkTypes::PVOID>(&RetLength);
            Input.InfoClass = static_cast<ULONG>(ThreadInfoClass);
            Input.Size = Size;
            BOOL Status = KbSendRequest(Ctls::KbQueryInformationThread, &Input, sizeof(Input));
            if (ReturnLength) *ReturnLength = RetLength;
            return Status;
        }

        BOOL WINAPI KbSetInformationThread(
            WdkTypes::HANDLE hThread,
            NtTypes::THREADINFOCLASS ThreadInfoClass,
            IN PVOID Buffer,
            ULONG Size
        ) {
            KB_SET_INFORMATION_PROCESS_THREAD_IN Input = {};
            Input.Handle = hThread;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
            Input.InfoClass = static_cast<ULONG>(ThreadInfoClass);
            Input.Size = Size;
            return KbSendRequest(Ctls::KbSetInformationProcess, &Input, sizeof(Input));
        }
    }

    namespace Threads
    {
        BOOL WINAPI KbCreateUserThread(
            ULONG ProcessId, 
            WdkTypes::PVOID ThreadRoutine, 
            WdkTypes::PVOID Argument, 
            BOOL CreateSuspended,
            OUT OPTIONAL WdkTypes::CLIENT_ID* ClientId,
            OUT OPTIONAL WdkTypes::HANDLE* hThread
        ) {
            if (!ProcessId) return FALSE;
            KB_CREATE_USER_THREAD_IN Input = {};
            KB_CREATE_USER_SYSTEM_THREAD_OUT Output = {};
            Input.ProcessId = ProcessId;
            Input.ThreadRoutine = ThreadRoutine;
            Input.Argument = Argument;
            Input.CreateSuspended = CreateSuspended;
            BOOL Status = KbSendRequest(Ctls::KbCreateUserThread, &Input, sizeof(Input), &Output, sizeof(Output));
            if (ClientId) *ClientId = Output.ClientId;
            if (hThread) 
                *hThread = Output.hThread;
            else
                Descriptors::KbCloseHandle(Output.hThread);
            return Status;
        }

        BOOL WINAPI KbCreateSystemThread(
            ULONG ProcessId, 
            WdkTypes::PVOID ThreadRoutine, 
            WdkTypes::PVOID Argument,
            OUT OPTIONAL WdkTypes::CLIENT_ID* ClientId,
            OUT OPTIONAL WdkTypes::HANDLE* hThread
        ) {
            if (!ProcessId) return FALSE;
            KB_CREATE_SYSTEM_THREAD_IN Input = {};
            KB_CREATE_USER_SYSTEM_THREAD_OUT Output = {};
            Input.AssociatedProcessId = ProcessId;
            Input.ThreadRoutine = ThreadRoutine;
            Input.Argument = Argument;
            BOOL Status = KbSendRequest(Ctls::KbCreateSystemThread, &Input, sizeof(Input), &Output, sizeof(Output));
            if (ClientId) *ClientId = Output.ClientId;
            if (hThread) 
                *hThread = Output.hThread;
            else
                Descriptors::KbCloseHandle(Output.hThread);
            return Status;
        }

        BOOL WINAPI KbSuspendProcess(ULONG ProcessId)
        {
            KB_SUSPEND_RESUME_PROCESS_IN Input = {};
            Input.ProcessId = ProcessId;
            return KbSendRequest(Ctls::KbSuspendProcess, &Input, sizeof(Input));
        }

        BOOL WINAPI KbResumeProcess(ULONG ProcessId)
        {
            KB_SUSPEND_RESUME_PROCESS_IN Input = {};
            Input.ProcessId = ProcessId;
            return KbSendRequest(Ctls::KbResumeProcess, &Input, sizeof(Input));
        }

        BOOL WINAPI KbGetThreadContext(ULONG ThreadId, OUT PCONTEXT Context, ULONG ContextSize, OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode)
        {
            KB_GET_SET_THREAD_CONTEXT_IN Input = {};
            Input.ThreadId = ThreadId;
            Input.ContextSize = ContextSize;
            Input.ProcessorMode = ProcessorMode;
            Input.Context = reinterpret_cast<WdkTypes::PVOID>(Context);
            return KbSendRequest(Ctls::KbGetThreadContext, &Input, sizeof(Input));
        }

        BOOL WINAPI KbSetThreadContext(ULONG ThreadId, IN PCONTEXT Context, ULONG ContextSize, OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode)
        {
            KB_GET_SET_THREAD_CONTEXT_IN Input = {};
            Input.ThreadId = ThreadId;
            Input.ContextSize = ContextSize;
            Input.ProcessorMode = ProcessorMode;
            Input.Context = reinterpret_cast<WdkTypes::PVOID>(Context);
            return KbSendRequest(Ctls::KbSetThreadContext, &Input, sizeof(Input));
        }
    }

    namespace MemoryManagement
    {
        BOOL WINAPI KbAllocUserMemory(ULONG ProcessId, ULONG Protect, ULONG Size, OUT WdkTypes::PVOID* BaseAddress)
        {
            if (!ProcessId || !Size || !BaseAddress) return FALSE;
            KB_ALLOC_USER_MEMORY_IN Input = {};
            KB_ALLOC_USER_MEMORY_OUT Output = {};
            Input.ProcessId = ProcessId;
            Input.Protect = Protect;
            Input.Size = Size;
            BOOL Status = KbSendRequest(Ctls::KbAllocUserMemory, &Input, sizeof(Input), &Output, sizeof(Output));
            *BaseAddress = Output.BaseAddress;
            return Status;
        }

        BOOL WINAPI KbFreeUserMemory(ULONG ProcessId, WdkTypes::PVOID BaseAddress)
        {
            if (!ProcessId || !BaseAddress) return FALSE;
            KB_FREE_USER_MEMORY_IN Input = {};
            Input.ProcessId = ProcessId;
            Input.BaseAddress = BaseAddress;
            return KbSendRequest(Ctls::KbFreeUserMemory, &Input, sizeof(Input));
        }

        BOOL WINAPI KbSecureVirtualMemory(
            ULONG ProcessId,
            WdkTypes::PVOID BaseAddress,
            ULONG Size,
            ULONG ProtectRights,
            OUT WdkTypes::HANDLE* SecureHandle
        ) {
            if (!ProcessId || !BaseAddress || !Size || !SecureHandle) return FALSE;
            KB_SECURE_VIRTUAL_MEMORY_IN Input = {};
            KB_SECURE_VIRTUAL_MEMORY_OUT Output = {};
            Input.ProcessId = ProcessId;
            Input.ProtectRights = ProtectRights;
            Input.BaseAddress = BaseAddress;
            Input.Size = Size;
            BOOL Status = KbSendRequest(Ctls::KbSecureVirtualMemory, &Input, sizeof(Input), &Output, sizeof(Output));
            *SecureHandle = Output.SecureHandle;
            return Status;
        }

        BOOL WINAPI KbUnsecureVirtualMemory(
            ULONG ProcessId,
            WdkTypes::HANDLE SecureHandle
        ) {
            if (!ProcessId || !SecureHandle) return FALSE;
            KB_UNSECURE_VIRTUAL_MEMORY_IN Input = {};
            Input.ProcessId = ProcessId;
            Input.SecureHandle = SecureHandle;
            return KbSendRequest(Ctls::KbUnsecureVirtualMemory, &Input, sizeof(Input));
        }

        BOOL WINAPI KbReadProcessMemory(
            ULONG ProcessId,
            IN WdkTypes::PVOID BaseAddress,
            OUT PVOID Buffer,
            ULONG Size
        ) {
            if (!ProcessId || !BaseAddress || !Buffer || !Size) return FALSE;
            KB_READ_PROCESS_MEMORY_IN Input = {};
            Input.ProcessId = ProcessId;
            Input.BaseAddress = BaseAddress;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
            Input.Size = Size;
            return KbSendRequest(Ctls::KbReadProcessMemory, &Input, sizeof(Input));
        }

        BOOL WINAPI KbWriteProcessMemory(
            ULONG ProcessId,
            OUT WdkTypes::PVOID BaseAddress,
            IN PVOID Buffer,
            ULONG Size,
            BOOLEAN PerformCopyOnWrite
        ) {
            if (!ProcessId || !BaseAddress || !Buffer || !Size) return FALSE;
            KB_WRITE_PROCESS_MEMORY_IN Input = {};
            Input.ProcessId = ProcessId;
            Input.BaseAddress = BaseAddress;
            Input.Buffer = reinterpret_cast<WdkTypes::PVOID>(Buffer);
            Input.Size = Size;
            Input.PerformCopyOnWrite = PerformCopyOnWrite;
            return KbSendRequest(Ctls::KbWriteProcessMemory, &Input, sizeof(Input));
        }

        BOOL WINAPI KbTriggerCopyOnWrite(ULONG ProcessId, IN WdkTypes::PVOID PageVirtualAddress)
        {
            if (!PageVirtualAddress) return FALSE;
            KB_TRIGGER_COPY_ON_WRITE_IN Input = {};
            Input.ProcessId = ProcessId;
            Input.PageVirtualAddress = PageVirtualAddress;
            return KbSendRequest(Ctls::KbTriggerCopyOnWrite, &Input, sizeof(Input));
        }

        BOOL WINAPI KbGetProcessCr3Cr4(ULONG ProcessId, OUT OPTIONAL PUINT64 Cr3, OUT OPTIONAL PUINT64 Cr4)
        {
            if (!ProcessId) return FALSE;
            KB_GET_PROCESS_CR3_CR4_IN Input = {};
            KB_GET_PROCESS_CR3_CR4_OUT Output = {};
            Input.ProcessId = ProcessId;
            BOOL Status = KbSendRequest(Ctls::KbGetProcessCr3Cr4, &Input, sizeof(Input), &Output, sizeof(Output));
            if (Cr3) *Cr3 = Output.Cr3;
            if (Cr4) *Cr4 = Output.Cr4;
            return Status;
        }
    }

    namespace Apc
    {
        BOOL WINAPI KbQueueUserApc(ULONG ThreadId, WdkTypes::PVOID ApcProc, WdkTypes::PVOID Argument)
        {
            KB_QUEUE_USER_APC_IN Input = {};
            Input.ThreadId = ThreadId;
            Input.ApcProc = ApcProc;
            Input.Argument = Argument;
            return KbSendRequest(Ctls::KbQueueUserApc, &Input, sizeof(Input));
        }
    }
}

namespace Sections
{
    BOOL WINAPI KbCreateSection(
        OUT WdkTypes::HANDLE* hSection,
        OPTIONAL LPCWSTR Name,
        UINT64 MaximumSize,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags, // OBJ_***
        ULONG SecPageProtection,
        ULONG AllocationAttributes,
        OPTIONAL WdkTypes::HANDLE hFile
    ) {
        if (!hSection) return FALSE;
        KB_CREATE_SECTION_IN Input = {};
        KB_CREATE_OPEN_SECTION_OUT Output = {};
        Input.Name = reinterpret_cast<WdkTypes::LPCWSTR>(Name);
        Input.MaximumSize = MaximumSize;
        Input.DesiredAccess = DesiredAccess;
        Input.SecObjFlags = SecObjFlags;
        Input.SecPageProtection = SecPageProtection;
        Input.AllocationAttributes = AllocationAttributes;
        Input.hFile = hFile;
        BOOL Status = KbSendRequest(Ctls::KbCreateSection, &Input, sizeof(Input), &Output, sizeof(Output));
        *hSection = Output.hSection;
        return Status;
    }

    BOOL WINAPI KbOpenSection(
        OUT WdkTypes::HANDLE* hSection,
        LPCWSTR Name,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags // OBJ_***
    ) {
        if (!hSection) return FALSE;
        KB_OPEN_SECTION_IN Input = {};
        KB_CREATE_OPEN_SECTION_OUT Output = {};
        Input.Name = reinterpret_cast<WdkTypes::LPCWSTR>(Name);
        Input.DesiredAccess = DesiredAccess;
        Input.SecObjFlags = SecObjFlags;
        BOOL Status = KbSendRequest(Ctls::KbOpenSection, &Input, sizeof(Input), &Output, sizeof(Output));
        *hSection = Output.hSection;
        return Status;
    }

    BOOL WINAPI KbMapViewOfSection(
        WdkTypes::HANDLE hSection,
        WdkTypes::HANDLE hProcess,
        IN OUT WdkTypes::PVOID* BaseAddress,
        ULONG CommitSize,
        IN OUT OPTIONAL UINT64* SectionOffset,
        IN OUT OPTIONAL UINT64* ViewSize,
        WdkTypes::SECTION_INHERIT SectionInherit,
        ULONG AllocationType,
        ULONG Win32Protect
    ) {
        if (!hSection || !BaseAddress) return FALSE;
        KB_MAP_VIEW_OF_SECTION_IN Input = {};
        KB_MAP_VIEW_OF_SECTION_OUT Output = {};
        Input.hSection = hSection;
        Input.hProcess = hProcess;
        Input.BaseAddress = *BaseAddress;
        Input.CommitSize = CommitSize;
        Input.SectionOffset = SectionOffset ? *SectionOffset : 0;
        Input.ViewSize = ViewSize ? *ViewSize : 0;
        Input.SectionInherit = SectionInherit;
        Input.AllocationType = AllocationType;
        Input.Win32Protect = Win32Protect;
        BOOL Status = KbSendRequest(Ctls::KbMapViewOfSection, &Input, sizeof(Input), &Output, sizeof(Output));
        *BaseAddress = Output.BaseAddress;
        if (SectionOffset) *SectionOffset = Output.SectionOffset;
        if (ViewSize) *ViewSize = Output.ViewSize;
        return Status;
    }

    BOOL WINAPI KbUnmapViewOfSection(
        WdkTypes::HANDLE hProcess,
        WdkTypes::PVOID BaseAddress
    ) {
        KB_UNMAP_VIEW_OF_SECTION_IN Input = {};
        Input.hProcess = hProcess;
        Input.BaseAddress = BaseAddress;
        return KbSendRequest(Ctls::KbUnmapViewOfSection, &Input, sizeof(Input));
    }
}

namespace KernelShells
{
    BOOL WINAPI KbExecuteShellCode(_ShellCode ShellCode, PVOID Argument, OUT OPTIONAL PULONG Result)
    {
        KB_EXECUTE_SHELL_CODE_IN Input = {};
        KB_EXECUTE_SHELL_CODE_OUT Output = {};
        Input.Address = reinterpret_cast<WdkTypes::PVOID>(ShellCode);
        Input.Argument = reinterpret_cast<WdkTypes::PVOID>(Argument);
        BOOL Status = KbSendRequest(Ctls::KbExecuteShellCode, &Input, sizeof(Input), &Output, sizeof(Output));
        if (Result) *Result = Output.Result;
        return Status;
    }
}

namespace LoadableModules
{
    BOOL WINAPI KbCreateDriver(LPCWSTR DriverName, WdkTypes::PVOID DriverEntry)
    {
        KB_CREATE_DRIVER_IN Input = {};
        SIZE_T NameLength = 0;
        __try {
            NameLength = wcslen(DriverName);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
        if (NameLength > 64) {
            SetLastError(ERROR_INVALID_NAME);
            return FALSE; // Very long name, seems like invalid data buffer
        }
        Input.DriverEntry = DriverEntry;
        Input.DriverName = reinterpret_cast<WdkTypes::PVOID>(DriverName);
        Input.DriverNameSizeInBytes = static_cast<ULONG>(NameLength) * sizeof(WCHAR); // We're sure that Length <= 64
        return KbSendRequest(Ctls::KbCreateDriver, &Input, sizeof(Input));
    }

    BOOL WINAPI KbLoadModule(
        WdkTypes::HMODULE hModule,
        LPCWSTR ModuleName,
        OPTIONAL WdkTypes::PVOID OnLoad,
        OPTIONAL WdkTypes::PVOID OnUnload,
        OPTIONAL WdkTypes::PVOID OnDeviceControl
    ) {
        if (!hModule || !ModuleName) return FALSE;
        KB_LOAD_MODULE_IN Input = {};
        Input.hModule = hModule;
        Input.ModuleName = reinterpret_cast<WdkTypes::LPCWSTR>(ModuleName);
        Input.OnLoad = OnLoad;
        Input.OnUnload = OnUnload;
        Input.OnDeviceControl = OnDeviceControl;
        return KbSendRequest(Ctls::KbLoadModule, &Input, sizeof(Input));
    }

    BOOL WINAPI KbUnloadModule(WdkTypes::HMODULE hModule)
    {
        if (!hModule) return FALSE;
        KB_UNLOAD_MODULE_IN Input = {};
        Input.hModule = hModule;
        return KbSendRequest(Ctls::KbUnloadModule, &Input, sizeof(Input));
    }

    BOOL WINAPI KbGetModuleHandle(LPCWSTR ModuleName, OUT WdkTypes::HMODULE* hModule)
    {
        if (!ModuleName || !hModule) return FALSE;
        KB_GET_MODULE_HANDLE_IN Input = {};
        KB_GET_MODULE_HANDLE_OUT Output = {};
        Input.ModuleName = reinterpret_cast<WdkTypes::LPCWSTR>(ModuleName);
        BOOL Status = KbSendRequest(Ctls::KbGetModuleHandle, &Input, sizeof(Input), &Output, sizeof(Output));
        *hModule = Output.hModule;
        return Status;
    }

    BOOL WINAPI KbCallModule(WdkTypes::HMODULE hModule, ULONG CtlCode, OPTIONAL WdkTypes::PVOID Argument)
    {
        if (!hModule) return FALSE;
        KB_CALL_MODULE_IN Input = {};
        Input.hModule = hModule;
        Input.CtlCode = CtlCode;
        Input.Argument = Argument;
        return KbSendRequest(Ctls::KbCallModule, &Input, sizeof(Input));
    }
}

namespace Hypervisor
{
    BOOL WINAPI KbVmmEnable()
    {
        return KbSendRequest(Ctls::KbVmmEnable);
    }

    BOOL WINAPI KbVmmDisable()
    {
        return KbSendRequest(Ctls::KbVmmDisable);
    }

    BOOL WINAPI KbVmmInterceptPage(
        IN OPTIONAL WdkTypes::PVOID64 PhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnReadPhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnWritePhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnExecutePhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnExecuteReadPhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnExecuteWritePhysicalAddress
    ) {
        KB_VMM_INTERCEPT_PAGE_IN Input = {};
        Input.PhysicalAddress = PhysicalAddress;
        Input.OnReadPhysicalAddress = OnReadPhysicalAddress;
        Input.OnWritePhysicalAddress = OnWritePhysicalAddress;
        Input.OnExecutePhysicalAddress = OnExecutePhysicalAddress;
        Input.OnExecuteReadPhysicalAddress = OnExecuteReadPhysicalAddress;
        Input.OnExecuteWritePhysicalAddress = OnExecuteWritePhysicalAddress;
        return KbSendRequest(Ctls::KbVmmInterceptPage, &Input, sizeof(Input));
    }

    BOOL WINAPI KbVmmDeinterceptPage(IN OPTIONAL WdkTypes::PVOID64 PhysicalAddress)
    {
        KB_VMM_DEINTERCEPT_PAGE_IN Input = {};
        Input.PhysicalAddress = PhysicalAddress;
        return KbSendRequest(Ctls::KbVmmDeinterceptPage, &Input, sizeof(Input));
    }
}

namespace Stuff
{
    BOOL WINAPI KbGetKernelProcAddress(LPCWSTR RoutineName, WdkTypes::PVOID* KernelAddress)
    {
        if (!RoutineName || !KernelAddress) return FALSE;
        SIZE_T NameLength = 0;
        __try {
            NameLength = wcslen(RoutineName);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
        if (NameLength > 64) {
            SetLastError(ERROR_INVALID_NAME);
            return FALSE; // Very long name, seems like invalid data buffer
        }
        KB_GET_KERNEL_PROC_ADDRESS_IN Input = {};
        KB_GET_KERNEL_PROC_ADDRESS_OUT Output = {};
        Input.RoutineName = reinterpret_cast<WdkTypes::LPCWSTR>(RoutineName);
        Input.SizeOfBufferInBytes = static_cast<ULONG>(NameLength) * sizeof(WCHAR); // We're sure that Length <= 64
        BOOL Status = KbSendRequest(Ctls::KbGetKernelProcAddress, &Input, sizeof(Input), &Output, sizeof(Output));
        *KernelAddress = Output.Address;
        return Status;
    }

    BOOL WINAPI KbStallExecutionProcessor(ULONG Microseconds)
    {
        KB_STALL_EXECUTION_PROCESSOR_IN Input = {};
        Input.Microseconds = Microseconds;
        return KbSendRequest(Ctls::KbStallExecutionProcessor, &Input, sizeof(Input));
    }

    BOOL WINAPI KbBugCheck(ULONG Status)
    {
        KB_BUG_CHECK_IN Input = {};
        Input.Status = Status;
        return KbSendRequest(Ctls::KbBugCheck, &Input, sizeof(Input));
    }

    BOOL WINAPI KbFindSignature(
        OPTIONAL ULONG ProcessId,
        WdkTypes::PVOID Memory,
        ULONG Size,
        LPCSTR Signature,
        LPCSTR Mask, 
        OUT WdkTypes::PVOID* FoundAddress
    ) {
        if (!FoundAddress) return FALSE;
        KB_FIND_SIGNATURE_IN Input = {};
        KB_FIND_SIGNATURE_OUT Output = {};
        Input.ProcessId = ProcessId;
        Input.Memory = Memory;
        Input.Size = Size;
        Input.Signature = reinterpret_cast<WdkTypes::LPCSTR>(Signature);
        Input.Mask = reinterpret_cast<WdkTypes::LPCSTR>(Mask);
        BOOL Status = KbSendRequest(Ctls::KbFindSignature, &Input, sizeof(Input), &Output, sizeof(Output));
        *FoundAddress = Output.Address;
        return Status;
    }
}

```

`User-Bridge/API/User-Bridge.h`:

```h
#pragma once

namespace KbLoader
{
    BOOL WINAPI KbLoadAsDriver(LPCWSTR DriverPath);
    BOOL WINAPI KbLoadAsFilter(LPCWSTR DriverPath, LPCWSTR Altitude);
    BOOL WINAPI KbUnload();
    ULONG WINAPI KbGetDriverApiVersion();
    ULONG WINAPI KbGetUserApiVersion();
    BOOL WINAPI KbGetHandlesCount(OUT PULONG Count);
}

namespace AddressRange
{
    inline BOOLEAN IsUserAddress(PVOID Address)
    {
        return reinterpret_cast<SIZE_T>(Address) < (static_cast<SIZE_T>(1) << (8 * sizeof(SIZE_T) - 1));
    }

    inline BOOLEAN IsKernelAddress(PVOID Address)
    {
        return reinterpret_cast<SIZE_T>(Address) >= (static_cast<SIZE_T>(1) << (8 * sizeof(SIZE_T) - 1));
    }

    inline BOOLEAN IsUserAddressIa32(UINT64 Address)
    {
        return Address < 0x80000000;
    }

    inline BOOLEAN IsUserAddressAmd64(UINT64 Address)
    {
        return Address < 0x8000000000000000;
    }

    inline BOOLEAN IsKernelAddressIa32(UINT64 Address)
    {
        return Address > 0x7FFFFFFF;
    }

    inline BOOLEAN IsKernelAddressAmd64(UINT64 Address)
    {
        return Address > 0x7FFFFFFFFFFFFFFF;
    }
}

namespace IO
{
    namespace Beeper
    {
        BOOL WINAPI KbSetBeeperRegime();
        BOOL WINAPI KbStartBeeper();
        BOOL WINAPI KbStopBeeper();
        BOOL WINAPI KbSetBeeperIn();
        BOOL WINAPI KbSetBeeperOut();
        BOOL WINAPI KbSetBeeperDivider(USHORT Divider);
        BOOL WINAPI KbSetBeeperFrequency(USHORT Frequency);
    }

    namespace RW
    {
        BOOL WINAPI KbReadPortByte(USHORT PortNumber, OUT PUCHAR Value);
        BOOL WINAPI KbReadPortWord(USHORT PortNumber, OUT PUSHORT Value);
        BOOL WINAPI KbReadPortDword(USHORT PortNumber, OUT PULONG Value);
        
        BOOL WINAPI KbReadPortByteString(USHORT PortNumber, ULONG Count, OUT PUCHAR ByteString, ULONG ByteStringSizeInBytes);
        BOOL WINAPI KbReadPortWordString(USHORT PortNumber, ULONG Count, OUT PUSHORT WordString, ULONG WordStringSizeInBytes);
        BOOL WINAPI KbReadPortDwordString(USHORT PortNumber, ULONG Count, OUT PULONG DwordString, ULONG DwordStringSizeInBytes);
        
        BOOL WINAPI KbWritePortByte(USHORT PortNumber, UCHAR Value);
        BOOL WINAPI KbWritePortWord(USHORT PortNumber, USHORT Value);
        BOOL WINAPI KbWritePortDword(USHORT PortNumber, ULONG Value);
        
        BOOL WINAPI KbWritePortByteString(USHORT PortNumber, ULONG Count, IN PUCHAR ByteString, ULONG ByteStringSizeInBytes);
        BOOL WINAPI KbWritePortWordString(USHORT PortNumber, ULONG Count, IN PUSHORT WordString, ULONG WordStringSizeInBytes);
        BOOL WINAPI KbWritePortDwordString(USHORT PortNumber, ULONG Count, IN PULONG DwordString, ULONG DwordStringSizeInBytes);
    }

    namespace Iopl
    {
        // Allows to use 'in/out/cli/sti' in usermode:
        BOOL WINAPI KbRaiseIopl();
        BOOL WINAPI KbResetIopl();
    }
}

namespace CPU
{
    BOOL WINAPI KbCli();
    BOOL WINAPI KbSti();
    BOOL WINAPI KbHlt();

    BOOL WINAPI KbReadMsr(ULONG Index, OUT PUINT64 MsrValue);
    BOOL WINAPI KbWriteMsr(ULONG Index, IN UINT64 MsrValue);

    using CPUID_INFO = struct
    {
        ULONG Eax;
        ULONG Ebx;
        ULONG Ecx;
        ULONG Edx;
    };
    using PCPUID_INFO = CPUID_INFO*;

    BOOL WINAPI KbCpuid(ULONG FunctionIdEax, OUT PCPUID_INFO CpuidInfo);
    BOOL WINAPI KbCpuidEx(ULONG FunctionIdEax, ULONG SubfunctionIdEcx, OUT PCPUID_INFO CpuidInfo);

    BOOL WINAPI KbReadPmc(ULONG Counter, OUT PUINT64 PmcValue);
    BOOL WINAPI KbReadTsc(OUT PUINT64 TscValue);
    BOOL WINAPI KbReadTscp(OUT PUINT64 TscValue, OUT OPTIONAL PULONG TscAux);
}

namespace VirtualMemory
{
    // Supports both user- and kernel-memory in context of current process:
    BOOL WINAPI KbAllocKernelMemory(ULONG Size, BOOLEAN Executable, OUT WdkTypes::PVOID* KernelAddress);
    BOOL WINAPI KbFreeKernelMemory(IN WdkTypes::PVOID KernelAddress);
    BOOL WINAPI KbAllocNonCachedMemory(ULONG Size, OUT WdkTypes::PVOID* KernelAddress);
    BOOL WINAPI KbFreeNonCachedMemory(WdkTypes::PVOID KernelAddress, ULONG Size);
    BOOL WINAPI KbCopyMoveMemory(OUT WdkTypes::PVOID Dest, IN WdkTypes::PVOID Src, ULONG Size, BOOLEAN Intersects);
    BOOL WINAPI KbFillMemory(IN WdkTypes::PVOID Address, UCHAR Filler, ULONG Size);
    BOOL WINAPI KbEqualMemory(IN WdkTypes::PVOID Src, IN WdkTypes::PVOID Dest, ULONG Size, OUT PBOOLEAN Equals);
}

namespace Mdl
{
    BOOL WINAPI KbAllocateMdl(
        WdkTypes::PVOID VirtualAddress,
        ULONG Size,
        OUT WdkTypes::PMDL* Mdl
    );

    BOOL WINAPI KbProbeAndLockPages(
        OPTIONAL ULONG ProcessId,
        WdkTypes::PMDL Mdl,
        WdkTypes::KPROCESSOR_MODE ProcessorMode,
        WdkTypes::LOCK_OPERATION LockOperation
    );

    BOOL WINAPI KbMapMdl(
        OUT WdkTypes::PVOID* MappedMemory,
        OPTIONAL UINT64 SrcProcessId,
        OPTIONAL UINT64 DestProcessId,
        WdkTypes::PMDL Mdl,
        BOOLEAN NeedProbeAndLock,
        WdkTypes::KPROCESSOR_MODE MapToAddressSpace = WdkTypes::UserMode,
        ULONG Protect = PAGE_READWRITE,
        WdkTypes::MEMORY_CACHING_TYPE CacheType = WdkTypes::MmNonCached,
        OPTIONAL WdkTypes::PVOID UserRequestedAddress = NULL
    );

    BOOL WINAPI KbProtectMappedMemory(IN WdkTypes::PMDL Mdl, ULONG Protect);
    BOOL WINAPI KbUnmapMdl(IN WdkTypes::PMDL Mdl, IN WdkTypes::PVOID MappedMemory, BOOLEAN NeedUnlock);
    BOOL WINAPI KbUnlockPages(WdkTypes::PMDL Mdl);
    BOOL WINAPI KbFreeMdl(WdkTypes::PMDL Mdl);

    using MAPPING_INFO = struct
    {
        WdkTypes::PVOID MappedAddress;
        WdkTypes::PVOID Mdl;
    };
    using PMAPPING_INFO = MAPPING_INFO*;

    BOOL WINAPI KbMapMemory(
        OUT PMAPPING_INFO MappingInfo,
        OPTIONAL UINT64 SrcProcessId,
        OPTIONAL UINT64 DestProcessId,
        WdkTypes::PVOID VirtualAddress,
        ULONG Size,
        WdkTypes::KPROCESSOR_MODE MapToAddressSpace = WdkTypes::UserMode,
        ULONG Protect = PAGE_READWRITE,
        WdkTypes::MEMORY_CACHING_TYPE CacheType = WdkTypes::MmNonCached,
        OPTIONAL WdkTypes::PVOID UserRequestedAddress = NULL
    );
    BOOL WINAPI KbUnmapMemory(IN PMAPPING_INFO MappingInfo);
}

namespace PhysicalMemory
{
    // Allocates contiguous physical memory in the specified range:
    BOOL WINAPI KbAllocPhysicalMemory(
        WdkTypes::PVOID LowestAcceptableAddress,
        WdkTypes::PVOID HighestAcceptableAddress,
        WdkTypes::PVOID BoundaryAddressMultiple,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType,
        OUT WdkTypes::PVOID* Address
    );

    BOOL WINAPI KbFreePhysicalMemory(WdkTypes::PVOID Address);

    // Maps physical memory to a KERNEL address-space, so if you
    // wants to work with it in usermode, you should map it to usermode
    // by Mdl::MapMemory:
    BOOL WINAPI KbMapPhysicalMemory(
        IN WdkTypes::PVOID PhysicalAddress,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType,
        OUT WdkTypes::PVOID* VirtualAddress
    );
    BOOL WINAPI KbUnmapPhysicalMemory(IN WdkTypes::PVOID VirtualAddress, ULONG Size);
    
    // Obtains physical address for specified virtual address 
    // in context of target process:
    BOOL WINAPI KbGetPhysicalAddress(
        IN OPTIONAL WdkTypes::PEPROCESS Process, 
        IN WdkTypes::PVOID VirtualAddress,
        OUT WdkTypes::PVOID* PhysicalAddress
    );

    BOOL WINAPI KbGetVirtualForPhysical(
        IN WdkTypes::PVOID PhysicalAddress, 
        OUT WdkTypes::PVOID* VirtualAddress    
    );

    // Reads and writes raw physical memory to buffer in context of current process:
    BOOL WINAPI KbReadPhysicalMemory(
        WdkTypes::PVOID64 PhysicalAddress,
        OUT PVOID Buffer,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType = WdkTypes::MmNonCached
    );
    BOOL WINAPI KbWritePhysicalMemory(
        WdkTypes::PVOID64 PhysicalAddress,
        IN PVOID Buffer,
        ULONG Size,
        WdkTypes::MEMORY_CACHING_TYPE CachingType = WdkTypes::MmNonCached
    );
    
    BOOL WINAPI KbReadDmiMemory(OUT UCHAR DmiMemory[DmiSize], ULONG BufferSize);
}

namespace Processes
{
    namespace Descriptors
    {
        // EPROCESS/ETHREAD must be dereferenced by KbDereferenceObject,
        // HANDLE must be closed by KbCloseHandle:
        BOOL WINAPI KbGetEprocess(ULONG ProcessId, OUT WdkTypes::PEPROCESS* Process);
        BOOL WINAPI KbGetEthread(ULONG ThreadId, OUT WdkTypes::PETHREAD* Thread);
        BOOL WINAPI KbOpenProcess(
            ULONG ProcessId, 
            OUT WdkTypes::HANDLE* hProcess, 
            OPTIONAL ACCESS_MASK Access = PROCESS_ALL_ACCESS, 
            OPTIONAL ULONG Attributes = ObjFlags::_OBJ_CASE_INSENSITIVE | ObjFlags::_OBJ_KERNEL_HANDLE
        );
        BOOL WINAPI KbOpenProcessByPointer(
            WdkTypes::PEPROCESS Process, 
            OUT WdkTypes::HANDLE* hProcess, 
            OPTIONAL ACCESS_MASK Access = PROCESS_ALL_ACCESS, 
            OPTIONAL ULONG Attributes = ObjFlags::_OBJ_CASE_INSENSITIVE | ObjFlags::_OBJ_KERNEL_HANDLE,
            OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode = WdkTypes::KernelMode
        );
        BOOL WINAPI KbOpenThread(
            ULONG ThreadId, 
            OUT WdkTypes::HANDLE* hThread, 
            OPTIONAL ACCESS_MASK Access = THREAD_ALL_ACCESS, 
            OPTIONAL ULONG Attributes = ObjFlags::_OBJ_CASE_INSENSITIVE | ObjFlags::_OBJ_KERNEL_HANDLE
        );
        BOOL WINAPI KbOpenThreadByPointer(
            WdkTypes::PETHREAD Thread, 
            OUT WdkTypes::HANDLE* hThread, 
            OPTIONAL ACCESS_MASK Access = THREAD_ALL_ACCESS, 
            OPTIONAL ULONG Attributes = ObjFlags::_OBJ_CASE_INSENSITIVE | ObjFlags::_OBJ_KERNEL_HANDLE,
            OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode = WdkTypes::KernelMode
        );
        BOOL WINAPI KbDereferenceObject(WdkTypes::PVOID Object);
        BOOL WINAPI KbCloseHandle(WdkTypes::HANDLE Handle);

    }

    namespace Information
    {
        BOOL WINAPI KbQueryInformationProcess(
            WdkTypes::HANDLE hProcess,
            NtTypes::PROCESSINFOCLASS ProcessInfoClass,
            OUT PVOID Buffer,
            ULONG Size,
            OPTIONAL OUT PULONG ReturnLength = NULL
        );
        BOOL WINAPI KbSetInformationProcess(
            WdkTypes::HANDLE hProcess,
            NtTypes::PROCESSINFOCLASS ProcessInfoClass,
            IN PVOID Buffer,
            ULONG Size
        );
        BOOL WINAPI KbQueryInformationThread(
            WdkTypes::HANDLE hThread,
            NtTypes::THREADINFOCLASS ThreadInfoClass,
            OUT PVOID Buffer,
            ULONG Size,
            OPTIONAL OUT PULONG ReturnLength = NULL
        );
        BOOL WINAPI KbSetInformationThread(
            WdkTypes::HANDLE hThread,
            NtTypes::THREADINFOCLASS ThreadInfoClass,
            IN PVOID Buffer,
            ULONG Size
        );
    }

    namespace Threads
    {
        using NTSTATUS = ULONG;
        using _ThreadRoutine = NTSTATUS (NTAPI*)(PVOID Argument);

        BOOL WINAPI KbCreateUserThread(
            ULONG ProcessId, 
            WdkTypes::PVOID ThreadRoutine, 
            WdkTypes::PVOID Argument, 
            BOOL CreateSuspended,
            OUT OPTIONAL WdkTypes::CLIENT_ID* ClientId,
            OUT OPTIONAL WdkTypes::HANDLE* hThread
        );

        BOOL WINAPI KbCreateSystemThread(
            ULONG ProcessId, 
            WdkTypes::PVOID ThreadRoutine, 
            WdkTypes::PVOID Argument,
            OUT OPTIONAL WdkTypes::CLIENT_ID* ClientId,
            OUT OPTIONAL WdkTypes::HANDLE* hThread
        );

        BOOL WINAPI KbSuspendProcess(ULONG ProcessId);
        BOOL WINAPI KbResumeProcess(ULONG ProcessId);

        BOOL WINAPI KbGetThreadContext(ULONG ThreadId, OUT PCONTEXT Context, ULONG ContextSize, OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode = WdkTypes::UserMode);
        BOOL WINAPI KbSetThreadContext(ULONG ThreadId, IN PCONTEXT Context, ULONG ContextSize, OPTIONAL WdkTypes::KPROCESSOR_MODE ProcessorMode = WdkTypes::UserMode);
    }

    namespace MemoryManagement
    {
        BOOL WINAPI KbAllocUserMemory(ULONG ProcessId, ULONG Protect, ULONG Size, OUT WdkTypes::PVOID* BaseAddress);
        BOOL WINAPI KbFreeUserMemory(ULONG ProcessId, WdkTypes::PVOID BaseAddress);
        
        BOOL WINAPI KbSecureVirtualMemory(
            ULONG ProcessId,
            WdkTypes::PVOID BaseAddress,
            ULONG Size,
            ULONG ProtectRights,
            OUT WdkTypes::HANDLE* SecureHandle
        );

        BOOL WINAPI KbUnsecureVirtualMemory(
            ULONG ProcessId,
            WdkTypes::HANDLE SecureHandle
        );

        BOOL WINAPI KbReadProcessMemory(
            ULONG ProcessId,
            IN WdkTypes::PVOID BaseAddress,
            OUT PVOID Buffer,
            ULONG Size
        );

        BOOL WINAPI KbWriteProcessMemory(
            ULONG ProcessId,
            OUT WdkTypes::PVOID BaseAddress,
            IN PVOID Buffer,
            ULONG Size,
            BOOLEAN PerformCopyOnWrite = TRUE
        );

        BOOL WINAPI KbTriggerCopyOnWrite(ULONG ProcessId, IN WdkTypes::PVOID PageVirtualAddress);

        BOOL WINAPI KbGetProcessCr3Cr4(ULONG ProcessId, OUT OPTIONAL PUINT64 Cr3, OUT OPTIONAL PUINT64 Cr4);
    }

    namespace Apc
    {
        using _ApcProc = VOID(WINAPI*)(PVOID Argument);
        BOOL WINAPI KbQueueUserApc(ULONG ThreadId, WdkTypes::PVOID ApcProc, WdkTypes::PVOID Argument);
    }
}

namespace Sections
{
    BOOL WINAPI KbCreateSection(
        OUT WdkTypes::HANDLE* hSection,
        OPTIONAL LPCWSTR Name,
        UINT64 MaximumSize,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags, // OBJ_***
        ULONG SecPageProtection, // SEC_***
        ULONG AllocationAttributes,
        OPTIONAL WdkTypes::HANDLE hFile
    );

    BOOL WINAPI KbOpenSection(
        OUT WdkTypes::HANDLE* hSection,
        LPCWSTR Name,
        ACCESS_MASK DesiredAccess,
        ULONG SecObjFlags // OBJ_***
    );

    BOOL WINAPI KbMapViewOfSection(
        WdkTypes::HANDLE hSection,
        WdkTypes::HANDLE hProcess,
        IN OUT WdkTypes::PVOID* BaseAddress,
        ULONG CommitSize,
        IN OUT OPTIONAL UINT64* SectionOffset = NULL,
        IN OUT OPTIONAL UINT64* ViewSize = NULL,
        WdkTypes::SECTION_INHERIT SectionInherit = WdkTypes::ViewUnmap,
        ULONG AllocationType = MEM_RESERVE,
        ULONG Win32Protect = PAGE_READWRITE
    );

    BOOL WINAPI KbUnmapViewOfSection(
        WdkTypes::HANDLE hProcess,
        WdkTypes::PVOID BaseAddress
    );
}

namespace KernelShells
{
    using _GetKernelProcAddress = PVOID(WINAPI*)(LPCWSTR RoutineName);
    using _ShellCode = ULONG(WINAPI*)(
        _GetKernelProcAddress GetKernelProcAddress, // You can obtain any function address from ntoskrnl.exe/hal.dll
        OPTIONAL IN OUT PVOID Argument
    );
    // Execute specified function in Ring0 
    // into SEH-section with FPU-safe context 
    // in context of current process:
    BOOL WINAPI KbExecuteShellCode(_ShellCode ShellCode, PVOID Argument = NULL, OUT OPTIONAL PULONG Result = NULL);
}

namespace LoadableModules
{
    BOOL WINAPI KbCreateDriver(LPCWSTR DriverName, WdkTypes::PVOID DriverEntry);
    BOOL WINAPI KbLoadModule(
        WdkTypes::HMODULE hModule,
        LPCWSTR ModuleName,
        OPTIONAL WdkTypes::PVOID OnLoad = NULL,
        OPTIONAL WdkTypes::PVOID OnUnload = NULL,
        OPTIONAL WdkTypes::PVOID OnDeviceControl = NULL
    );
    BOOL WINAPI KbUnloadModule(WdkTypes::HMODULE hModule);
    BOOL WINAPI KbGetModuleHandle(LPCWSTR ModuleName, OUT WdkTypes::HMODULE* hModule);
    BOOL WINAPI KbCallModule(WdkTypes::HMODULE hModule, ULONG CtlCode, OPTIONAL WdkTypes::PVOID Argument = NULL);
}

namespace Hypervisor
{
    BOOL WINAPI KbVmmEnable();
    BOOL WINAPI KbVmmDisable();
    BOOL WINAPI KbVmmInterceptPage(
        IN OPTIONAL WdkTypes::PVOID64 PhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnReadPhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnWritePhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnExecutePhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnExecuteReadPhysicalAddress,
        IN OPTIONAL WdkTypes::PVOID64 OnExecuteWritePhysicalAddress
    );
    BOOL WINAPI KbVmmDeinterceptPage(IN OPTIONAL WdkTypes::PVOID64 PhysicalAddress);
}

namespace Stuff
{
    BOOL WINAPI KbGetKernelProcAddress(LPCWSTR RoutineName, WdkTypes::PVOID* KernelAddress);
    BOOL WINAPI KbStallExecutionProcessor(ULONG Microseconds);
    BOOL WINAPI KbBugCheck(ULONG Status);
    BOOL WINAPI KbFindSignature(
        OPTIONAL ULONG ProcessId,
        WdkTypes::PVOID Memory, // Both user and kernel
        ULONG Size,
        LPCSTR Signature, // "\x11\x22\x33\x00\x44"
        LPCSTR Mask, // "...?."
        OUT WdkTypes::PVOID* FoundAddress
    );
}
```

`User-Bridge/Exports.def`:

```def
LIBRARY User-Bridge
EXPORTS
	KbLoadAsDriver
	KbLoadAsFilter
	KbUnload
	KbGetDriverApiVersion
	KbGetUserApiVersion
	KbGetHandlesCount

	KbSetBeeperRegime
	KbStartBeeper
	KbStopBeeper
	KbSetBeeperIn
	KbSetBeeperOut
	KbSetBeeperDivider
	KbSetBeeperFrequency

	KbReadPortByte
	KbReadPortWord
	KbReadPortDword
	KbReadPortByteString
	KbReadPortWordString
	KbReadPortDwordString
	KbWritePortByte
	KbWritePortWord
	KbWritePortDword
	KbWritePortByteString
	KbWritePortWordString
	KbWritePortDwordString

	KbRaiseIopl
	KbResetIopl

	KbCli
	KbSti
	KbHlt

	KbReadMsr
	KbWriteMsr

	KbCpuid
	KbCpuidEx

	KbReadPmc
	KbReadTsc
	KbReadTscp

	KbAllocKernelMemory
	KbFreeKernelMemory
	KbAllocNonCachedMemory
	KbFreeNonCachedMemory
	KbCopyMoveMemory
	KbFillMemory
	KbEqualMemory

	KbAllocateMdl
	KbProbeAndLockPages
	KbMapMdl
	KbProtectMappedMemory
	KbUnmapMdl
	KbUnlockPages
	KbFreeMdl
	KbMapMemory
	KbUnmapMemory
	
	KbAllocPhysicalMemory
	KbFreePhysicalMemory
	KbMapPhysicalMemory
	KbUnmapPhysicalMemory
	KbGetPhysicalAddress
	KbGetVirtualForPhysical
	KbReadPhysicalMemory
	KbWritePhysicalMemory
	KbReadDmiMemory

	KbGetEprocess
	KbGetEthread
	KbOpenProcess
	KbOpenProcessByPointer
	KbOpenThread
	KbOpenThreadByPointer
	KbDereferenceObject
	KbCloseHandle
	KbQueryInformationProcess
	KbSetInformationProcess
	KbQueryInformationThread
	KbSetInformationThread
	KbCreateUserThread
	KbCreateSystemThread
	KbSuspendProcess
	KbResumeProcess
	KbGetThreadContext
	KbSetThreadContext
	KbAllocUserMemory
	KbFreeUserMemory
	KbSecureVirtualMemory
	KbUnsecureVirtualMemory
	KbReadProcessMemory
	KbWriteProcessMemory
	KbGetProcessCr3Cr4
	KbQueueUserApc

	KbCreateSection
	KbOpenSection
	KbMapViewOfSection
	KbUnmapViewOfSection

	KbExecuteShellCode

	KbCreateDriver
	KbLoadModule
	KbUnloadModule
	KbGetModuleHandle
	KbCallModule

	KbRtlMapDriverMemory
	KbRtlMapDriverFile
	KbRtlLoadModuleMemory
	KbRtlLoadModuleFile

    KbVmmEnable
    KbVmmDisable
	KbVmmInterceptPage
	KbVmmDeinterceptPage

	KbGetKernelProcAddress
	KbStallExecutionProcessor
	KbBugCheck
	KbFindSignature
```

`User-Bridge/Main.cpp`:

```cpp
#include <SDKDDKVer.h>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPCONTEXT lpContext)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

`User-Bridge/User-Bridge.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{09805AB7-6E91-46A3-B501-A420E56458AB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>UserBridge</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>./API/PEUtils;./API;../SharedTypes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>./API/PEUtils;./API;../SharedTypes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>./API/PEUtils;./API;../SharedTypes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>./API/PEUtils;./API;../SharedTypes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;USERBRIDGE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;USERBRIDGE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;USERBRIDGE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;USERBRIDGE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\SharedTypes\CtlTypes.h" />
    <ClInclude Include="..\SharedTypes\FltTypes.h" />
    <ClInclude Include="..\SharedTypes\WdkTypes.h" />
    <ClInclude Include="API\CommPort.h" />
    <ClInclude Include="API\DriversUtils.h" />
    <ClInclude Include="API\Flt-Bridge.h" />
    <ClInclude Include="API\PEUtils\PEAnalyzer.h" />
    <ClInclude Include="API\PEUtils\PELoader.h" />
    <ClInclude Include="API\Rtl-Bridge.h" />
    <ClInclude Include="API\User-Bridge.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="API\CommPort.cpp" />
    <ClCompile Include="API\DriversUtils.cpp" />
    <ClCompile Include="API\PEUtils\PEAnalyzer.cpp" />
    <ClCompile Include="API\PEUtils\PELoader.cpp" />
    <ClCompile Include="API\Rtl-Bridge.cpp" />
    <ClCompile Include="API\User-Bridge.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`User-Bridge/User-Bridge.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Main">
      <UniqueIdentifier>{edd61105-dcb8-4c04-b050-5d8d1b91ae6b}</UniqueIdentifier>
    </Filter>
    <Filter Include="API">
      <UniqueIdentifier>{62eb9047-d1c0-4981-a9b7-b578b342fcda}</UniqueIdentifier>
    </Filter>
    <Filter Include="SharedTypes">
      <UniqueIdentifier>{9e1ef5e3-399c-452c-8091-9142deb2d845}</UniqueIdentifier>
    </Filter>
    <Filter Include="Main\Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Main\Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="API\PEUtils">
      <UniqueIdentifier>{3d4daa8d-6ad7-4f20-99ef-5bf36c120bb7}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="API\DriversUtils.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\User-Bridge.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="..\SharedTypes\CtlTypes.h">
      <Filter>SharedTypes</Filter>
    </ClInclude>
    <ClInclude Include="API\PEUtils\PEAnalyzer.h">
      <Filter>API\PEUtils</Filter>
    </ClInclude>
    <ClInclude Include="API\PEUtils\PELoader.h">
      <Filter>API\PEUtils</Filter>
    </ClInclude>
    <ClInclude Include="API\Rtl-Bridge.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="API\CommPort.h">
      <Filter>API</Filter>
    </ClInclude>
    <ClInclude Include="..\SharedTypes\FltTypes.h">
      <Filter>SharedTypes</Filter>
    </ClInclude>
    <ClInclude Include="..\SharedTypes\WdkTypes.h">
      <Filter>SharedTypes</Filter>
    </ClInclude>
    <ClInclude Include="API\Flt-Bridge.h">
      <Filter>API</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="API\DriversUtils.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\User-Bridge.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Main\Source Files</Filter>
    </ClCompile>
    <ClCompile Include="API\PEUtils\PEAnalyzer.cpp">
      <Filter>API\PEUtils</Filter>
    </ClCompile>
    <ClCompile Include="API\PEUtils\PELoader.cpp">
      <Filter>API\PEUtils</Filter>
    </ClCompile>
    <ClCompile Include="API\Rtl-Bridge.cpp">
      <Filter>API</Filter>
    </ClCompile>
    <ClCompile Include="API\CommPort.cpp">
      <Filter>API</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def">
      <Filter>Main</Filter>
    </None>
  </ItemGroup>
</Project>
```

`x32-debug.ddf`:

```ddf
.OPTION EXPLICIT
.Set CabinetFileCountThreshold=0
.Set FolderFileCountThreshold=0
.Set FolderSizeThreshold=0
.Set MaxCabinetSize=0
.Set MaxDiskFileCount=0
.Set MaxDiskSize=0
.Set CompressionType=MSZIP
.Set Cabinet=on
.Set Compress=on
.Set CabinetNameTemplate=Kernel-Bridge.cab
.Set DiskDirectoryTemplate=../Debug
.Set DestinationDir=Kernel-Bridge
../Debug/Kernel-Bridge.sys
../Debug/Kernel-Bridge.inf
```

`x32-release.ddf`:

```ddf
.OPTION EXPLICIT
.Set CabinetFileCountThreshold=0
.Set FolderFileCountThreshold=0
.Set FolderSizeThreshold=0
.Set MaxCabinetSize=0
.Set MaxDiskFileCount=0
.Set MaxDiskSize=0
.Set CompressionType=MSZIP
.Set Cabinet=on
.Set Compress=on
.Set CabinetNameTemplate=Kernel-Bridge.cab
.Set DiskDirectoryTemplate=../Release
.Set DestinationDir=Kernel-Bridge
../Release/Kernel-Bridge.sys
../Release/Kernel-Bridge.inf
```

`x64-debug.ddf`:

```ddf
.OPTION EXPLICIT
.Set CabinetFileCountThreshold=0
.Set FolderFileCountThreshold=0
.Set FolderSizeThreshold=0
.Set MaxCabinetSize=0
.Set MaxDiskFileCount=0
.Set MaxDiskSize=0
.Set CompressionType=MSZIP
.Set Cabinet=on
.Set Compress=on
.Set CabinetNameTemplate=Kernel-Bridge.cab
.Set DiskDirectoryTemplate=../x64/Debug
.Set DestinationDir=Kernel-Bridge
../x64/Debug/Kernel-Bridge.sys
../x64/Debug/Kernel-Bridge.inf
```

`x64-release.ddf`:

```ddf
.OPTION EXPLICIT
.Set CabinetFileCountThreshold=0
.Set FolderFileCountThreshold=0
.Set FolderSizeThreshold=0
.Set MaxCabinetSize=0
.Set MaxDiskFileCount=0
.Set MaxDiskSize=0
.Set CompressionType=MSZIP
.Set Cabinet=on
.Set Compress=on
.Set CabinetNameTemplate=Kernel-Bridge.cab
.Set DiskDirectoryTemplate=../x64/Release
.Set DestinationDir=Kernel-Bridge
../x64/Release/Kernel-Bridge.sys
../x64/Release/Kernel-Bridge.inf
```