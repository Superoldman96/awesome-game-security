Project Path: arc_gmh5225_ValveGen_cc__ctsr

Source Tree:

```txt
arc_gmh5225_ValveGen_cc__ctsr
├── LICENSE
├── README.md
├── ValveGen
│   ├── ValveGen.vcxproj
│   ├── ValveGen.vcxproj.filters
│   ├── classbuilder.cpp
│   ├── classbuilder.h
│   ├── classnode.cpp
│   ├── classnode.h
│   ├── client.cpp
│   ├── client.h
│   ├── dataelement.cpp
│   ├── dataelement.h
│   ├── dllmain.cpp
│   ├── required.h
│   └── singleton.h
├── ValveGen.sln
└── csgo_sdk_2016_08_16.7z

```

`LICENSE`:

```
MIT License

Copyright (c) 2016 CallumCVM

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ValveGen
An SDK Generator for Valve's Source Engine

```

`ValveGen.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ValveGen", "ValveGen\ValveGen.vcxproj", "{FEFEEC7D-2900-4125-AFD8-39539347DB3D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Debug|x64.ActiveCfg = Debug|x64
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Debug|x64.Build.0 = Debug|x64
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Debug|x86.ActiveCfg = Debug|Win32
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Debug|x86.Build.0 = Debug|Win32
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Release|x64.ActiveCfg = Release|x64
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Release|x64.Build.0 = Release|x64
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Release|x86.ActiveCfg = Release|Win32
		{FEFEEC7D-2900-4125-AFD8-39539347DB3D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`ValveGen/ValveGen.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FEFEEC7D-2900-4125-AFD8-39539347DB3D}</ProjectGuid>
    <RootNamespace>ValveGen</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <PostBuildEvent>
      <Command>copy "$(TargetPath)" "$(SolutionDir)..\..\bin\$(PlatformTarget)\$(ConfigurationName)\$(TargetFileName)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="classbuilder.h" />
    <ClInclude Include="classnode.h" />
    <ClInclude Include="client.h" />
    <ClInclude Include="dataelement.h" />
    <ClInclude Include="required.h" />
    <ClInclude Include="singleton.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="classbuilder.cpp" />
    <ClCompile Include="classnode.cpp" />
    <ClCompile Include="client.cpp" />
    <ClCompile Include="dataelement.cpp" />
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ValveGen/ValveGen.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="required.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="client.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="classnode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="singleton.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="classbuilder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dataelement.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="client.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="classbuilder.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="classnode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dataelement.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`ValveGen/classbuilder.cpp`:

```cpp

#include "classbuilder.h"
#include "client.h"

namespace valvegen
{
    ClassBuilder::ClassBuilder()
    {}

    void ClassBuilder::Cleanup()
    {
        for ( auto& n : nodes_ )
        {
            if ( n )
            {
                n->Cleanup();
                delete n;
                n = NULL;
            }
        }

        nodes_.clear();
    }

    bool ClassBuilder::CreateClasses( HINSTANCE module_instance )
    {
        auto class_head = Client::Instance()->GetAllClasses();

        if ( class_head == nullptr )
            return false;

        for ( ; class_head != nullptr; class_head = class_head->m_pNext )
        {
            CreateNodes( class_head->m_pRecvTable , nullptr );
        }

        CreateSDK( module_instance );

        return true;
    }

    ClassNode* ClassBuilder::CreateNode( RecvTable* instance , ClassNode* parent /*= nullptr*/ )
    {
        std::string fixed_name = instance->m_pNetTableName;

        if ( fixed_name.find( "DT_" ) == 0 )
            fixed_name.replace( fixed_name.begin() , fixed_name.begin() + 3 , "C" );

        for ( auto& n : nodes_ )
        {
            if ( n->GetBaseName() == fixed_name )
            {
                if ( parent )
                    parent->SetParent( n );

                return n;
            }
        }
        auto node = new ClassNode();
        nodes_.push_back( node );

        return node;
    }

    void ClassBuilder::AddElement( RecvProp* prop , ClassNode* current_node )
    {
        std::string sName = prop->m_pVarName;

        // Now let's make the c++ compiler able to read the networked variables, if you don't want to end up with big errors when you compile...
        int iPos;

        // Replace [ by _.
        while ( true )
        {
            iPos = sName.find( TEXT( "[" ) );

            if ( iPos != std::string::npos )
            {
                sName[ iPos ] = TEXT( '_' );
            }
            else
            {
                break;
            }
        }

        // delete ] from networked variables
        while ( true )
        {
            iPos = sName.find( TEXT( "]" ) );

            if ( iPos != std::string::npos )
            {
                sName.erase( iPos );
            }
            else
            {
                break;
            }
        }

        // delete . from networked variables.
        while ( true )
        {
            iPos = sName.find( TEXT( "." ) );

            if ( iPos != std::string::npos )
            {
                sName[ iPos ] = TEXT( '_' );
            }
            else
            {
                break;
            }
        }

        // delete " from networked variables.
        while ( true )
        {
            iPos = sName.find( TEXT( "\"" ) );

            if ( iPos != std::string::npos )
            {
                sName[ iPos ] = TEXT( '_' );
            }
            else
            {
                break;
            }
        }

        if ( prop->m_RecvType == CLASS )
        {
            if ( !strcmp( prop->m_pVarName , "baseclass" ) )
                CreateNodes( prop->m_pDataTable , current_node );
            else
            {
                if ( prop->m_pDataTable->m_pProps->m_pVarName[ 0 ] == '0' )
                {
                    DWORD last_array_offset = 0;
                    int num_array_elements = 0;
                    DataElement* array_member = nullptr;

                    for ( auto i = 0; i < prop->m_pDataTable->m_nProps; ++i )
                    {
                        DWORD stride = prop->m_pDataTable->m_pProps[ i ].m_Offset - last_array_offset;

                        array_member = current_node->CreateDataElement( prop->m_Offset , sName.c_str() , DATA_TYPE::ARRAY , stride );

                        last_array_offset = prop->m_pDataTable->m_pProps[ i ].m_Offset;

                        num_array_elements++;
                    }

                    array_member->array_size_ = num_array_elements - 1;
                }
                else
                {
                    CreateNodes( prop->m_pDataTable );

                    current_node->CreateDataElementClassInstance( prop->m_Offset , prop->m_pDataTable->m_pNetTableName , sName.c_str() , static_cast< DATA_TYPE >( prop->m_RecvType ) );
                }

            }
        }
        else
        {
            /* Create a new variable */
            current_node->CreateDataElement( prop->m_Offset , sName.c_str() , static_cast< DATA_TYPE >( prop->m_RecvType ) );
        }
    }

    void ClassBuilder::CreateNodes( RecvTable* head , ClassNode* parent /*= nullptr*/ )
    {
        ClassNode* current_node = CreateNode( head , parent );

        // it has already been created so ignore it
        if ( !current_node )
            return;

        current_node->SetClassName( head->m_pNetTableName );

        if ( head->m_pProps != nullptr )
        {
            for ( auto i = 0; i < head->m_nProps; ++i )
            {
                auto prop = &head->m_pProps[ i ];

                if ( prop == nullptr )
                    continue;

                AddElement( prop , current_node );
            }

            /* Shuffle the members so that they are in offset order */
            current_node->ShuffleMembers();
        }
    }

    void ClassBuilder::CreateSDK( HINSTANCE module_instance )
    {
        if ( nodes_.size() == 0 )
            return;

        /* Create SDK directory */
        char module_path[ MAX_PATH ];
        if ( !GetModuleFileName( reinterpret_cast< HMODULE >( module_instance ) , module_path , sizeof( module_path ) ) )
            return;

        std::string sdk_path = module_path;
        size_t pos = sdk_path.find_last_of( '\\' );
        if ( pos != std::string::npos )
        {
            sdk_path = sdk_path.substr( 0 , pos + 1 );
        }

        sdk_path.append( "ValveGen\\" );

        if ( GetFileAttributes( sdk_path.c_str() ) == INVALID_FILE_ATTRIBUTES )
        {
            CreateDirectory( sdk_path.c_str() , nullptr );
        }

        for ( auto& n : nodes_ )
        {
            std::string output_file = n->GetBaseName() + ".h";

            std::ofstream of( sdk_path + output_file , std::ios::out );

            if ( !of.is_open() )
                continue;

            n->OuputHeader( of );

            n->ShuffleParents();

            n->ResolveIncludes( of );

            of << "#pragma pack(push,1)" << std::endl;

            /* classname */
            of << "\tclass " << n->GetBaseName();

            DWORD inherited_size = 0;

            if ( n->HasInheritence() )
            {
                of << " : " << std::endl;

                UINT number_of_parents = n->GetNumParents();
                for ( UINT i = 0; i < number_of_parents; ++i )
                {
                    if ( number_of_parents > 1 && i < number_of_parents - 1 )
                        of << "\t\t public " << n->GetInheritedClassName( i ) << ", // 0x" << std::hex << n->GetInheritedClassSize( i ) << std::endl;
                    else
                        of << "\t\t public " << n->GetInheritedClassName( i ) << " // 0x" << std::hex << n->GetInheritedClassSize( i ) << std::endl;

                    /* make note of the inherited size so we can pad to it */
                    if ( i == number_of_parents - 1 )
                        inherited_size = n->GetInheritedClassSize( i );
                }
            }
            else
            {
                of << std::endl;
            }

            of << "\t{" << std::endl << "\tpublic:" << std::endl;

            DWORD last_offset = inherited_size;

            for ( unsigned int i = 0; i < n->GetDataElements().size(); ++i )
            {
                auto e = n->GetDataElements().at( i );

                /* check for padding */
                if ( e->offset_ > last_offset )
                {
                    DWORD padding = e->offset_ - last_offset;

                    of << "\t\tunsigned char _0x" << std::hex << last_offset << "[0x" << std::hex << padding << "];" << std::endl;
                }

                of << "\t\t" << e->GetTypeName() << "\t" << e->name_ << e->GetArrayTerminator() << "; // 0x" << std::hex << e->offset_ << std::endl;

                last_offset = e->offset_ + e->GetElementSize();
            }

            of << "\t};" << std::endl;

            of << "#pragma pack(pop)" << std::endl;

            of.close();
        }

        std::string sdkheader = "#pragma once;\n\n";
        for ( auto& n : nodes_ )
        {
            sdkheader += "#include \"";
            sdkheader += n->GetBaseName() + ".h\"\n";
        }

        std::ofstream of( sdk_path + "GeneratedSDK.h" , std::ios::out );

        if ( !of.is_open() )
            return;

        of << sdkheader;

        of.close();
    }

    ClassNode* ClassBuilder::FindNode( std::string name )
    {
        for ( auto& n : nodes_ )
        {
            if ( n->GetBaseName() == name )
                return n;
        }
        return nullptr;
    }
}

```

`ValveGen/classbuilder.h`:

```h


#pragma once

#include "required.h"
#include "singleton.h"
#include "classnode.h"
#include "client.h"

namespace valvegen
{
	/// <summary>
	/// Class ClassBuilder. 
	/// Responsible for creating the class nodes and compiling the SDK.
	/// </summary>
	/// <seealso cref="Singleton{ClassBuilder}" />
	class ClassBuilder : public Singleton<ClassBuilder>
	{
		friend class Singleton<ClassBuilder>;

	private:
		/// <summary>
		/// Prevents a default instance of the <see cref="ClassBuilder"/> class from being created.
		/// </summary>
		ClassBuilder();

	public:
		/// <summary>
		/// Cleans up this instance.
		/// </summary>
		void Cleanup();

		/// <summary>
		/// Creates the classes by iterating a list of ClientClass returned from the game egine.
		/// </summary>
		/// <returns>bool.</returns>
		bool CreateClasses(HINSTANCE module_instance);

		/// <summary>
		/// Creates the nodes recursively
		/// </summary>
		/// <param name="head">The head.</param>
		/// <param name="parent">The parent.</param>
		void CreateNodes(RecvTable* head, ClassNode* parent = nullptr);

		/// <summary>
		/// Creates a single node and set the parent accordingly (if there is one)
		/// </summary>
		/// <param name="instance">The instance.</param>
		/// <param name="parent">The parent.</param>
		/// <returns>valvegen.ClassNode *.</returns>
		ClassNode* CreateNode(RecvTable* instance, ClassNode* parent = nullptr);

		/// <summary>
		/// Finds a node by name
		/// </summary>
		/// <param name="name">The name.</param>
		/// <returns>valvegen.ClassNode *.</returns>
		ClassNode* FindNode(std::string name);

		/// <summary>
		/// Compiles all the class nodes into an SDK on disk.
		/// </summary>
		void CreateSDK(HINSTANCE module_instance);

		/// <summary>
		/// Adds a data element to a class node
		/// </summary>
		/// <param name="prop">The property.</param>
		/// <param name="current_node">The current_node.</param>
		void AddElement(RecvProp* prop, ClassNode* current_node);

	private:
		/// <summary>
		/// The vector of nodes_ we have created
		/// </summary>
		std::vector<ClassNode*> nodes_;
	};
}

```

`ValveGen/classnode.cpp`:

```cpp

#include "classnode.h"
#include "classbuilder.h"

/// <summary>
/// The valvegen namespace.
/// </summary>
namespace valvegen
{
	

	ClassNode::ClassNode()
	{}

	void ClassNode::Cleanup()
	{
		for (auto& e : data_elements_)
		{
			if (e)
			{
				delete e;
				e = NULL;
			}
		}

		data_elements_.clear();
	}

	void ClassNode::SetClassName(std::string name)
	{
		if (name.find("DT_") == 0)
			name.replace(name.begin(), name.begin() + 3, "C");

		class_name_ = name;
	}

	DataElement* ClassNode::CreateDataElement(DWORD offset, std::string name, DATA_TYPE dtype, DWORD stride /*= 0*/)
	{
		for (auto& e : data_elements_)
		{
			if (e->name_ == name)
			{
				if (e->dtype_ == ARRAY)
				{
					e->array_stride_ = stride;
				}
				return e;
			}

			/* avoid adding multiple members at the same offset e.g. "movecollide" */
			if (e->offset_ == offset)
				return e;
		}

		DataElement* element = new DataElement();
		element->name_		= name;
		element->offset_	= offset;
		element->dtype_		= dtype;

		data_elements_.push_back(element);

		return element;
	}

	DataElement* ClassNode::CreateDataElementClassInstance(DWORD offset, std::string name, std::string varname, DATA_TYPE dtype)
	{
		if (name.find("DT_") == 0)
			name.replace(name.begin(), name.begin() + 3, "C");

		for (auto& e : data_elements_)
		{
			if (e->name_ == varname)
			{
				if (e->dtype_ == ARRAY)
				{
					/* calculate the stride */
					if (e->offset_ == 0)
						e->array_stride_ = offset - e->offset_;

					e->array_size_++;
				}
				return e;
			}
		}		

		DataElement* element = new DataElement();
		element->name_ = varname;
		element->instance_name_ = name;
		element->offset_ = offset;
		element->dtype_ = dtype;

		data_elements_.push_back(element);

		return element;
	}

	std::string ClassNode::GetBaseName()
	{
		return class_name_;
	}

	void ClassNode::ShuffleMembers()
	{
		std::sort(data_elements_.begin(), data_elements_.end(), [](DataElement const* a, DataElement const* b) { return (a->offset_ < b->offset_); });
	}

	void ClassNode::OuputHeader(std::ofstream& of)
	{
		of << "//***********************************************" << std::endl;
		of << "// SDK Generated by ValveGen (written by Chod)" << std::endl;
		of << "// File: " << GetBaseName() + ".h" << std::endl;
		of << "//***********************************************" << std::endl << std::endl;
		of << "#pragma once" << std::endl << std::endl;
	}

	void ClassNode::ResolveIncludes(std::ofstream& of)
	{
		if (HasInheritence())
		{
			/* resolve inheritence first of all */
			for (UINT i = 0; i < GetNumParents(); ++i)
			{
				of << "#include \"" << GetInheritedClassName(i) << ".h\"" << std::endl;
			}			
		}

		/* then resolve data elements, if there are any */
		for (auto& e : data_elements_)
		{
			if (e->dtype_ == CLASS)
			{
				of << "#include \"" << e->instance_name_ << ".h\"" << std::endl;
			}
		}

		of << std::endl;
	}

	bool ClassNode::HasInheritence()
	{
		return (parents_.size() > 0);
	}

	void ClassNode::SetParent(ClassNode* parent)
	{
		for (auto& p : parents_)
		{
			if (p->GetBaseName() == parent->GetBaseName())
				return;
		}
		parents_.push_back(parent);
	}

	std::string ClassNode::GetInheritedClassName(UINT index /*= 0*/)
	{
		if (HasInheritence())
			return parents_.at(index)->GetBaseName();
		return "";
	}

	UINT ClassNode::GetNumParents()
	{
		return parents_.size();
	}

	ClassNode* ClassNode::GetParent(UINT index /*= 0*/)
	{
		if (index < 0 || index >= parents_.size())
			return nullptr;

		return parents_.at(index);
	}

	std::vector<DataElement*>& ClassNode::GetDataElements()
	{
		return data_elements_;
	}

	DWORD ClassNode::GetInheritedClassSize(UINT index /*= 0*/)
	{
		DWORD class_size = 0;

		if (HasInheritence())
		{
			ClassNode* parent = GetParent(index);

			if(parent)
				class_size += parent->GetClassSize();
		}		

		return class_size;
	}

	DWORD ClassNode::GetClassSize() const
	{
		if (data_elements_.size() > 0)
		{
			DataElement* last_element = data_elements_.at(data_elements_.size() - 1);

			if (last_element)
			{
				DWORD size = last_element->offset_;

				size += last_element->GetElementSize();

				return size;
			}
		}

		return 0;
	}

	void ClassNode::ShuffleParents()
	{
		std::sort(parents_.begin(), parents_.end(), [](ClassNode const* a, ClassNode const* b) { return (a->GetClassSize() < b->GetClassSize()); });

		/* this is a hacky fix for classes such as CBaseCombatWeapon where CLocalActiveWeaponData are actually in the middle of the class */
		if (data_elements_.size())
		{
			for (UINT i = 0; i < GetDataElements().size(); ++i)
			{
				DataElement* element = GetDataElements().at(i);

				/* check for inline classes */
				if (element->dtype_ == CLASS && element->offset_ == 0)
				{
					ClassNode* instance = ClassBuilder::Instance()->FindNode(element->instance_name_);

					if (instance)
					{
						bool found = false;

						for (UINT j = 0; j < instance->GetDataElements().size(); ++j)
						{
							DataElement* child_element = instance->GetDataElements().at(j);

							for (UINT k = 0; k < GetDataElements().size(); ++k)
							{
								// skip ourselves
								if (k == i)
									continue;

								DataElement* other_element = GetDataElements().at(k);

								/* does the offset clash with other members */
								if (child_element->offset_ >= other_element->offset_)
								{
									/* insert the variables from the inline class back into the parent class and sort them */
									data_elements_.insert(data_elements_.end(), instance->GetDataElements().begin(), instance->GetDataElements().end());
									ShuffleMembers();

									/* delete the inline class now that we have taken the members out */
									GetDataElements().erase(GetDataElements().begin() + i);
									i--;
									found = true;

									break;
								}
							}

							if (found)
								break;
						}
					}
				}				
			}

			/* remove duplicates by offset value (can sometimes happen) */
			data_elements_.erase(std::unique(data_elements_.begin(), data_elements_.end(),
				[](DataElement const* a, DataElement const* b) { return (a->offset_ == b->offset_); }), data_elements_.end());
		}
	}
}
```

`ValveGen/classnode.h`:

```h

#pragma once

#include "required.h"
#include "client.h"
#include "dataelement.h"

namespace valvegen
{
	/// <summary>
	/// Class ClassNode.
	/// Represents a class in memory and all its data alements (member variables)
	/// </summary>
	class ClassNode
	{
	public:
		/// <summary>
		/// Initializes a new instance of the <see cref="ClassNode"/> class.
		/// </summary>
		ClassNode();

		/// <summary>
		/// Cleans up this instance.
		/// </summary>
		void Cleanup();

		/// <summary>
		/// Sets the parent.
		/// </summary>
		/// <param name="parent">The parent.</param>
		void SetParent(ClassNode* parent);

		/// <summary>
		/// Sets the name of the class.
		/// </summary>
		/// <param name="name">The name.</param>
		void SetClassName(std::string name);

		/// <summary>
		/// Creates a data element (member variable)
		/// </summary>
		/// <param name="offset">The offset.</param>
		/// <param name="name">The name.</param>
		/// <param name="dtype">The dtype.</param>
		/// <param name="stride">The stride.</param>
		/// <returns>valvegen.DataElement *.</returns>
		DataElement* CreateDataElement(DWORD offset, std::string name, DATA_TYPE dtype, DWORD stride = 0);

		/// <summary>
		/// Creates the data element class instance.
		/// </summary>
		/// <param name="offset">The offset.</param>
		/// <param name="name">The name.</param>
		/// <param name="varname">The varname.</param>
		/// <param name="dtype">The dtype.</param>
		/// <returns>valvegen.DataElement *.</returns>
		DataElement* CreateDataElementClassInstance(DWORD offset, std::string name, std::string varname, DATA_TYPE dtype);

		/// <summary>
		/// Gets the name of the class
		/// </summary>
		/// <returns>std.string.</returns>
		std::string GetBaseName();

		/// <summary>
		/// Reorder the members by offset value
		/// </summary>
		void ShuffleMembers();

		/// <summary>
		/// Ouputs the header.
		/// </summary>
		/// <param name="of">The of.</param>
		void OuputHeader(std::ofstream& of);

		/// <summary>
		/// Resolves the includes.
		/// </summary>
		/// <param name="of">The of.</param>
		void ResolveIncludes(std::ofstream& of);

		/// <summary>
		/// Determines whether this instance has inheritence.
		/// </summary>
		/// <returns>bool.</returns>
		bool HasInheritence();

		/// <summary>
		/// Gets the name of the inherited class.
		/// </summary>
		/// <param name="index">The index.</param>
		/// <returns>std.string.</returns>
		std::string GetInheritedClassName(UINT index = 0);

		/// <summary>
		/// Gets the number of parent (inherited) class.
		/// </summary>
		/// <returns>UINT.</returns>
		UINT GetNumParents();

		/// <summary>
		/// Gets the parent at an index.
		/// </summary>
		/// <param name="index">The index.</param>
		/// <returns>valvegen.ClassNode *.</returns>
		ClassNode* GetParent(UINT index = 0);

		/// <summary>
		/// Gets the data elements.
		/// </summary>
		/// <returns>std.vector&lt;DataElement*&gt;&.</returns>
		std::vector<DataElement*>& GetDataElements();

		/// <summary>
		/// Gets the size of the inherited class.
		/// </summary>
		/// <param name="index">The index.</param>
		/// <returns>DWORD.</returns>
		DWORD GetInheritedClassSize(UINT index = 0);

		/// <summary>
		/// Gets the size of the class.
		/// </summary>
		/// <returns>DWORD.</returns>
		DWORD GetClassSize() const;

		/// <summary>
		/// Shuffles the parents.
		/// </summary>
		void ShuffleParents();

	private:
		/// <summary>
		/// The parents_
		/// </summary>
		std::vector<ClassNode*> parents_;

		/// <summary>
		/// The class_name_
		/// </summary>
		std::string class_name_;

		/// <summary>
		/// The data_elements_
		/// </summary>
		std::vector<DataElement*> data_elements_;
	};
}

```

`ValveGen/client.cpp`:

```cpp


#include "client.h"

namespace valvegen
{
	inline void**& getvtable(void* inst, size_t offset = 0)
	{
		return *reinterpret_cast<void***>((size_t)inst + offset);
	}
	inline const void** getvtable(const void* inst, size_t offset = 0)
	{
		return *reinterpret_cast<const void***>((size_t)inst + offset);
	}
	template< typename Fn >
	inline Fn getvfunc(const void* inst, size_t index, size_t offset = 0)
	{
		return reinterpret_cast<Fn>(getvtable(inst, offset)[index]);
	}


	Client::Client() :
		client_dll_handle_(nullptr)
	{}



	void Client::WaitForClientToBecomeReady()
	{
		HMODULE client_dll = nullptr;
		
		do
		{
			client_dll = GetModuleHandle("client.dll");
		} while (client_dll == nullptr);

		client_dll_handle_ = client_dll;
	}



	bool Client::InitClientInterface()
	{
		if (!client_dll_handle_)
			return false;

		FARPROC create_interface_fn = GetProcAddress(client_dll_handle_, "CreateInterface");

		if (!create_interface_fn)
			return false;

		auto FindListAddress = [](FARPROC function_address) -> DWORD
		{
			const BYTE OPCODE_JMP = 0xE9;

			DWORD start_address = reinterpret_cast<DWORD>(function_address);

			PBYTE opcode_info = reinterpret_cast<PBYTE>(start_address);

			if (opcode_info[4] != OPCODE_JMP)
				return 0;

			DWORD jmp_address = *reinterpret_cast<DWORD*>(start_address + 5);
			DWORD list_address = start_address + 4 + jmp_address + 5;

			return *reinterpret_cast<DWORD*>(list_address + 6);
		};

		DWORD list_address = FindListAddress(create_interface_fn);

		if (list_address == NULL)
			return false;

		EngineInterface* interface_list = *reinterpret_cast<EngineInterface**>(list_address);

		if (!interface_list)
			return false;

		bool found_interface = false;

		while (interface_list)
		{
			std::string interface_name = interface_list->name;

			for (size_t i = interface_name.length() - 1; i > 0; i--)
			{
				if (isdigit(interface_name[i]))
					interface_name.erase(interface_name.length() - 1, 1);
				else
					break;
			}

			if (interface_name == "VClient")
			{
				found_interface = true;
				break;
			}

			interface_list = interface_list->next;
		}

		if (!found_interface)
			return false;

		class_ptr_ = ((LPVOID(*)(void))interface_list->callback)();

		if (!class_ptr_)
			return false;

		return true;
	}



	ClientClass* Client::GetAllClasses()
	{
		int index = -1;

		for (int i = 0; i < 16; i++)
		{
			auto pdwClient = *(PDWORD_PTR*)class_ptr_;
			std::uint8_t* function = (std::uint8_t*)pdwClient[i];

			if (function[0] == 0xA1 && function[5] == 0xC3)
			{
				index = i;
				break;
			}
		}
		
		if(index == -1)
			return nullptr;

		typedef ClientClass* (__thiscall *tGetAllClasses)(void*);
		tGetAllClasses pGetAllClasses = getvfunc<tGetAllClasses>(class_ptr_, index);

		if (!pGetAllClasses)
			return nullptr;

		return pGetAllClasses(class_ptr_);
	}
}

```

`ValveGen/client.h`:

```h

#pragma once

#include "required.h"
#include "singleton.h"

namespace valvegen
{
	struct EngineInterface
	{
		LPVOID				callback;
		PCHAR				name;
		EngineInterface*	next;
	};

	class DVariant
	{
	public:
		union
		{
			float	m_Float;
			long	m_Int;
			char	*m_pString;
			void	*m_pData;
			float	m_Vector[3];
			__int64	m_Int64;
		};
		int	m_Type;
	};

	struct RecvProp;

	class CRecvProxyData
	{
	public:
		const RecvProp	*m_pRecvProp;
		DVariant		m_Value;
		int				m_iElement;
		int				m_ObjectID;
	};


	typedef void(*RecvVarProxyFn)(const CRecvProxyData *pData, void *pStruct, void *pOut);

	struct RecvTable
	{
		RecvProp		*m_pProps;
		int				m_nProps;
		void			*m_pDecoder;
		char			*m_pNetTableName;
		bool			m_bInitialized;
		bool			m_bInMainList;
	};

	struct RecvProp
	{
		char					*m_pVarName;
		int						m_RecvType;
		int						m_Flags;
		int						m_StringBufferSize;
		bool					m_bInsideArray;
		const void				*m_pExtraData;
		RecvProp				*m_pArrayProp;
		void*					m_ArrayLengthProxy;
		void*					m_ProxyFn;
		void*					m_DataTableProxyFn;
		RecvTable				*m_pDataTable;
		int						m_Offset;
		int						m_ElementStride;
		int						m_nElements;
		const char				*m_pParentArrayPropName;
	};

	struct ClientClass
	{
		void*			m_pCreateFn;
		void*			m_pCreateEventFn;
		char			*m_pNetworkName;
		RecvTable		*m_pRecvTable;
		ClientClass		*m_pNext;
		int				m_ClassID;
	};

	/// <summary>
	/// Class Client.
	/// </summary>
	/// <seealso cref="Singleton{Client}" />
	class Client : public Singleton<Client>
	{
		friend class Singleton<Client>;
	private:
		/// <summary>
		/// Prevents a default instance of the <see cref="Client"/> class from being created.
		/// </summary>
		Client();

	public:
		/// <summary>
		/// Waits for client to become ready.
		/// </summary>
		void WaitForClientToBecomeReady();

		/// <summary>
		/// Initializes the client interface.
		/// </summary>
		/// <returns>bool.</returns>
		bool InitClientInterface();

		/// <summary>
		/// Gets all classes.
		/// </summary>
		/// <returns>valvegen.ClientClass *.</returns>
		ClientClass* GetAllClasses();

	private:
		/// <summary>
		/// The client_dll_handle_
		/// </summary>
		HMODULE client_dll_handle_;
		/// <summary>
		/// The class_ptr_
		/// </summary>
		LPVOID class_ptr_;
	};
}

```

`ValveGen/dataelement.cpp`:

```cpp


#include "dataelement.h"
#include "classbuilder.h"

namespace valvegen
{
	DataElement::DataElement() :
		dtype_(UNKNOWN),
		array_size_(0),
		array_stride_(0)
	{}

	std::string DataElement::GetArrayTerminator()
	{
		if (dtype_ != ARRAY)
			return "";

		std::stringstream ss;
		ss << "[" << (array_size_ + 1) << "]";
		return ss.str();
	}

	std::string DataElement::GetTypeName()
	{
		switch (dtype_)
		{
		case INT:
			return "int    ";

		case FLOAT:
			return "float  ";

		case VECTOR:
			return "vector3";

		case VECTORXY:
			return "vector2";

		case STRING:
			return "char*  ";

		case ARRAY:
		{
			/* guess the type name from the field size (hacky) */
			switch (array_stride_)
			{
			default:
			case 1: return "bool   ";
			case 2: return "short  ";
			case 4: return "int    ";
			case 8: return "__int64";
			}
		}

		case CLASS:
			return instance_name_;

		default:
			return "";
		}
	}

	int DataElement::GetElementSize()
	{
		DWORD size = 0;

		switch (dtype_)
		{
		case INT:
		case FLOAT:
			size += sizeof(int);
			break;

		case STRING:
			size += sizeof(PCHAR);
			break;

		case VECTOR:
			size += sizeof(float) * 3;
			break;

		case VECTORXY:
			size += sizeof(float) * 2;
			break;

		case ARRAY:
			size += (array_size_ + 1) * array_stride_;
			break;

		case CLASS:
		{
			ClassNode* class_descriptor = valvegen::ClassBuilder::Instance()->FindNode(instance_name_);

			if (class_descriptor)
				size += class_descriptor->GetClassSize();
			break;
		}
		}

		return size;
	}
}
```

`ValveGen/dataelement.h`:

```h

#pragma once

#include "required.h"

namespace valvegen
{
	/* matches dt_common.h */
	enum DATA_TYPE
	{
		INT,
		FLOAT,
		VECTOR,
		VECTORXY,
		STRING,
		ARRAY,
		CLASS,
		UNKNOWN
	};

	/// <summary>
	/// Class DataElement. Represents a member variable
	/// </summary>
	class DataElement
	{
	public:
		/// <summary>
		/// Initializes a new instance of the <see cref="DataElement"/> class.
		/// </summary>
		DataElement();

		/// <summary>
		/// Gets the array terminator.
		/// </summary>
		/// <returns>std.string.</returns>
		std::string GetArrayTerminator();

		/// <summary>
		/// Gets the name of the type.
		/// </summary>
		/// <returns>std.string.</returns>
		std::string GetTypeName();

		/// <summary>
		/// Gets the size of the element.
		/// </summary>
		/// <returns>int.</returns>
		int GetElementSize();

	public:
		/// <summary>
		/// The dtype_
		/// </summary>
		DATA_TYPE dtype_;
		/// <summary>
		/// The offset_
		/// </summary>
		DWORD offset_;
		/// <summary>
		/// The name_
		/// </summary>
		std::string name_;
		/// <summary>
		/// The array_size_
		/// </summary>
		int array_size_;
		/// <summary>
		/// The array_stride_
		/// </summary>
		int array_stride_;
		/// <summary>
		/// The instance_name_
		/// </summary>
		std::string instance_name_; // for class instances
	};
}

```

`ValveGen/dllmain.cpp`:

```cpp


#include "required.h"
#include "client.h"
#include "classbuilder.h"

DWORD WINAPI Begin(LPVOID param)
{
	valvegen::Client* client = valvegen::Client::Instance();

	client->WaitForClientToBecomeReady();

	if (!client->InitClientInterface())
		return EXIT_FAILURE;

	HINSTANCE module_instance = param ? reinterpret_cast<HINSTANCE>(param) : nullptr;

	valvegen::ClassBuilder::Instance()->CreateClasses(module_instance);

	return EXIT_SUCCESS;
}

BOOL WINAPI DllMain(
	_In_ HINSTANCE hinstDLL,
	_In_ DWORD     fdwReason,
	_In_ LPVOID    lpvReserved
	)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)&Begin, hinstDLL, 0, nullptr);
	}
	else if (fdwReason == DLL_PROCESS_DETACH)
	{
		valvegen::ClassBuilder::Instance()->Cleanup();
	}
	return TRUE;
}
```

`ValveGen/required.h`:

```h


#pragma once

#include <Windows.h>
#include <string>
#include <vector>
#include <algorithm>
#include <fstream>
#include <sstream>

```

`ValveGen/singleton.h`:

```h

#pragma once

#include "required.h"

namespace valvegen
{
	template <typename T>
	class Singleton
	{
	public:
		static T* Instance()
		{
			static T instance;
			return &instance;
		}

	protected:
		inline explicit Singleton() {}
		virtual ~Singleton() {}
	};
}

```