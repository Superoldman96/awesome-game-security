Project Path: arc_gmh5225_NMIStackWalk_wfbu_meh

Source Tree:

```txt
arc_gmh5225_NMIStackWalk_wfbu_meh
├── README.md
├── TestNMICallback.inf
├── TestNMICallback.sln
├── TestNMICallback.vcxproj
├── TestNMICallback.vcxproj.filters
├── hal.c
├── helper.c
├── main.c
└── stuff.h

```

`README.md`:

```md
# NMIStackWalk  
检测无模块驱动  
原理： 
发NMI，然后在注册的NMI回调内做栈回溯，代码没在全系统测试

```

`TestNMICallback.inf`:

```inf
;
; TestNMICallback.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=TestNMICallback.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
TestNMICallback_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
TestNMICallback.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%TestNMICallback.DeviceDesc%=TestNMICallback_Device, Root\TestNMICallback ; TODO: edit hw-id

[TestNMICallback_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
TestNMICallback.sys

;-------------- Service installation
[TestNMICallback_Device.NT.Services]
AddService = TestNMICallback,%SPSVCINST_ASSOCSERVICE%, TestNMICallback_Service_Inst

; -------------- TestNMICallback driver install sections
[TestNMICallback_Service_Inst]
DisplayName    = %TestNMICallback.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\TestNMICallback.sys

;
;--- TestNMICallback_Device Coinstaller installation ------
;

[TestNMICallback_Device.NT.CoInstallers]
AddReg=TestNMICallback_Device_CoInstaller_AddReg
CopyFiles=TestNMICallback_Device_CoInstaller_CopyFiles

[TestNMICallback_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[TestNMICallback_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[TestNMICallback_Device.NT.Wdf]
KmdfService =  TestNMICallback, TestNMICallback_wdfsect
[TestNMICallback_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "TestNMICallback Installation Disk"
TestNMICallback.DeviceDesc = "TestNMICallback Device"
TestNMICallback.SVCDESC = "TestNMICallback Service"

```

`TestNMICallback.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32602.291
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestNMICallback", "TestNMICallback.vcxproj", "{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.ActiveCfg = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.Build.0 = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.Deploy.0 = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.Build.0 = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.ActiveCfg = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.Build.0 = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.Deploy.0 = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.ActiveCfg = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.Build.0 = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.Deploy.0 = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.ActiveCfg = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.Build.0 = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.Deploy.0 = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.ActiveCfg = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.Build.0 = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.Deploy.0 = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.ActiveCfg = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.Build.0 = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.Deploy.0 = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.ActiveCfg = Release|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.Build.0 = Release|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {340E45E7-F88E-4806-896E-6B37B6B05EAC}
	EndGlobalSection
EndGlobal

```

`TestNMICallback.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TestNMICallback</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <TimeStampServer>http://timestamp.globalsign.com/scripts/timstamp.dll</TimeStampServer>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA1</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="TestNMICallback.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hal.c" />
    <ClCompile Include="helper.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stuff.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TestNMICallback.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="TestNMICallback.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hal.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="helper.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stuff.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`hal.c`:

```c
#include "stuff.h"

VOID HalSendNMI(PKAFFINITY_EX affinity)
{
	PVOID addr;
	UNICODE_STRING routineName;

	RtlInitUnicodeString(&routineName, L"HalSendNMI");
	addr = MmGetSystemRoutineAddress(&routineName);

	if (!addr) __debugbreak();

	( (VOID(__fastcall*)(PKAFFINITY_EX))addr )(affinity);
}

```

`helper.c`:

```c
#include "stuff.h"

INT64 HLP_SecInNs(INT64 ms)
{
	return (ms * 10000);
}

VOID HLP_DelayExecutionThread(INT64 ms)
{
	LARGE_INTEGER nDelay;
	memset(&nDelay, 0, sizeof(nDelay));

	nDelay.QuadPart -= HLP_SecInNs(ms);

	KeDelayExecutionThread(KernelMode, FALSE, &nDelay);
}

BOOLEAN HLP_FireNMI(INT core, PKAFFINITY_EX affinity)
{
	KeInitializeAffinityEx(affinity);
	KeAddProcessorAffinityEx(affinity, core);

	HalSendNMI(affinity);

	return TRUE;
}




```

`main.c`:

```c
#include "stuff.h"

PVOID g_NmiCallbackHandle;
PKAFFINITY_EX g_NmiAffinity;
PNMI_CONTEXT g_NmiContext;
BOOLEAN StopDriver;
HANDLE SendNMIThreadHandle;
PVOID g_PageOfpStackWalkResult;

VOID SendNMIKernelRoutine(PVOID StartContext)
{
	UNREFERENCED_PARAMETER(StartContext);

	ULONG numCores = KeQueryActiveProcessorCountEx(0);

	while (!StopDriver)
	{
		for (ULONG i = 0; i < numCores; i++)
		{
			HLP_FireNMI(i, g_NmiAffinity); /* this will fire an NMI on CPU #i */
			HLP_DelayExecutionThread(200); /* can adjust this delay, it's been arbitrarily chosen. */
		}
		
		//have data in the stack walk record
		if (((DWORD64*)g_PageOfpStackWalkResult)[0] != 0)
		{
			PSYSTEM_MODULE_INFORMATION pSystemInfoBuffer = NULL;
			ULONG SystemInfoBufferSize = 0;
			NTSTATUS status = STATUS_SUCCESS;

			for (int i = 0; i < 0x1000 / 0x10; i += 2)
			{
				if (((DWORD64*)g_PageOfpStackWalkResult)[i] != 0)
				{
					//__debugbreak();
					if (MmIsAddressValid(((PVOID*)g_PageOfpStackWalkResult)[i]) && ((DWORD64*)g_PageOfpStackWalkResult)[i + 1])
					{
						// get all driver imagebase and size
						if (!pSystemInfoBuffer)
						{
							status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &SystemInfoBufferSize);
							if (!SystemInfoBufferSize)
							{
								__debugbreak();
							}

							pSystemInfoBuffer = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, (SIZE_T)SystemInfoBufferSize * 2, NMI_CB_POOL_TAG);
							if (!pSystemInfoBuffer)
							{
								__debugbreak();
							}

							memset(pSystemInfoBuffer, 0, (SIZE_T)SystemInfoBufferSize * 2);
							status = ZwQuerySystemInformation(SystemModuleInformation, pSystemInfoBuffer, (SIZE_T)SystemInfoBufferSize * 2, &SystemInfoBufferSize);
							if (!NT_SUCCESS(status))
							{
								__debugbreak();
							}
						}

						//iteriate through all frames in this stack record
						SIZE_T j = 0;
						for (j = 0; i < ((DWORD64*)g_PageOfpStackWalkResult)[i + 1]; j++)
						{
							BOOLEAN IsFrameInLegitModule = FALSE;
							ULONG64 CurrentFrameValue = (((DWORD64**)g_PageOfpStackWalkResult)[i])[j];

							// not kernel mode addr, skip
							if (CurrentFrameValue < 0xFFFF000000000000)
							{
								break;
							}

							//check and see if it is in a driver module
							for (ULONG ModuleCount = 0; ModuleCount < pSystemInfoBuffer->Count; ModuleCount++)
							{
								if (CurrentFrameValue >= (ULONG64)pSystemInfoBuffer->Module[ModuleCount].ImageBase &&
									CurrentFrameValue <= (ULONG64)pSystemInfoBuffer->Module[ModuleCount].ImageBase + pSystemInfoBuffer->Module[ModuleCount].ImageSize)
								{
									//this stack frame is legal
									IsFrameInLegitModule = TRUE;
									break;
								}
							}

							if (!IsFrameInLegitModule)
							{
								//report, todo: identiy PG's context
								//todo: verify more frame and check present of sensitive function
								DbgPrintEx(0, 0, "Detect shellcode outside of kernel module addr=%llx", CurrentFrameValue);

								if (!MmIsAddressValid(CurrentFrameValue))
								{
									DbgPrintEx(0, 0, ", shellcode address is not valid, maybe it is a PG context\n");
								}
								else
								{
									DbgPrintEx(0, 0, "\n");
								}

							}

						}
						
						ExFreePoolWithTag(((PVOID*)g_PageOfpStackWalkResult)[i], NMI_CB_POOL_TAG);
						((DWORD64*)g_PageOfpStackWalkResult)[i] = 0;
						((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = 0;

					}
					else
					{
						((DWORD64*)g_PageOfpStackWalkResult)[i] = 0;
						((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = 0;
					}
				}
			}

			if (pSystemInfoBuffer)
				ExFreePoolWithTag(pSystemInfoBuffer, NMI_CB_POOL_TAG);

		}

	}

	PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID WaitThreadTerminate(HANDLE ThreadHandle)
{
	if (ThreadHandle != NULL) {
		PETHREAD ThreadObject;

		if (NT_SUCCESS(ObReferenceObjectByHandle(ThreadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID*)(&ThreadObject), NULL)))
		{
			KeWaitForSingleObject((PVOID)(ThreadObject), Executive, KernelMode, FALSE, NULL);
			ObDereferenceObject((PVOID)(ThreadObject));
		}
	}
}

BOOLEAN StopDetectionThread() {
	StopDriver = TRUE;
	WaitThreadTerminate(SendNMIThreadHandle);
	return TRUE;
}

BOOLEAN NmiCallback(PVOID context, BOOLEAN handled)
{
	UNREFERENCED_PARAMETER(handled);
	
	PVOID* stackTrace = ExAllocatePoolWithTag(NonPagedPool, 0x1000, NMI_CB_POOL_TAG);
	if (!stackTrace)
	{
		__debugbreak();
		return TRUE;
	}

	USHORT capturedFrames = 0;
	capturedFrames = RtlCaptureStackBackTrace(0, 0x1000 / 8, stackTrace, NULL);

	BOOLEAN MmCopyFound = FALSE;
	MmCopyFound = TRUE;

	//for (USHORT i = 0; i < capturedFrames; i++)
	//{
	//	// in MmCopyVirtualMemory, todo determine the size
	//	if ((ULONG64)stackTrace[i] - *(ULONG64*)((ULONG64)context + 0x444) <= 0xE4B)
	//	{
	//		MmCopyFound = TRUE;
	//		break;
	//	}
	//}

	if (MmCopyFound)
	{
		//DbgPrintEx(0, 0, "Found MmCopy, insert into list\n");
		
		for (int i = 0; i < 0x1000 / 0x10; i += 2)
		{			
			if (((DWORD64*)g_PageOfpStackWalkResult)[i] == 0)
			{
				((DWORD64*)g_PageOfpStackWalkResult)[i] = (ULONG64)stackTrace;
				((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = capturedFrames;
				break;
			}
		}
	}
	else
		ExFreePoolWithTag(stackTrace, NMI_CB_POOL_TAG);


	PNMI_CONTEXT cpuContext = &((PNMI_CONTEXT)context)[KeGetCurrentProcessorNumberEx(0)];
	++cpuContext->NumFired;

	return TRUE;
}

VOID DriverUnload(PDRIVER_OBJECT drvObj)
{
	UNREFERENCED_PARAMETER(drvObj);

	DbgPrintEx(0, 0, "[nmi_cb]  unload\n");

	ULONG numCores = KeQueryActiveProcessorCountEx(0);

	for (ULONG i = 0; i < numCores; i++)
	{
		PNMI_CONTEXT cpuContext = &g_NmiContext[i];

		DbgPrintEx(0, 0, "[nmi_cb]  CPU#%i NmiCallbackInvokes=%i\n", i, cpuContext->NumFired);
	}

	StopDetectionThread();

	if (g_NmiCallbackHandle) KeDeregisterNmiCallback(g_NmiCallbackHandle);
	if (g_NmiAffinity) ExFreePoolWithTag(g_NmiAffinity, NMI_CB_POOL_TAG);
	if (g_NmiContext) ExFreePoolWithTag(g_NmiContext, NMI_CB_POOL_TAG);
	if (g_PageOfpStackWalkResult) ExFreePoolWithTag(g_PageOfpStackWalkResult, NMI_CB_POOL_TAG);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT drvObj, PUNICODE_STRING regPath)
{
	UNREFERENCED_PARAMETER(regPath);

	DbgPrintEx(0, 0, "\n[nmi_cb]  entry\n");

	drvObj->DriverUnload = DriverUnload;

	ULONG numCores = KeQueryActiveProcessorCountEx(0);
	ULONG nmiContextLength = numCores * sizeof(NMI_CONTEXT);

	g_NmiContext = (PNMI_CONTEXT)ExAllocatePoolWithTag(NonPagedPool, nmiContextLength, NMI_CB_POOL_TAG);

	g_NmiAffinity = ExAllocatePoolWithTag(NonPagedPool, sizeof(KAFFINITY_EX), NMI_CB_POOL_TAG);
	g_PageOfpStackWalkResult = ExAllocatePoolWithTag(NonPagedPool, 0x1000, NMI_CB_POOL_TAG);

	g_NmiCallbackHandle = KeRegisterNmiCallback(NmiCallback, g_NmiContext);

	if (!g_NmiAffinity || !g_NmiContext || !g_NmiCallbackHandle || !g_PageOfpStackWalkResult)
		return STATUS_FAILED_DRIVER_ENTRY;

	memset(g_NmiContext, 0, nmiContextLength);
	memset(g_PageOfpStackWalkResult, 0, 0x1000);

	UNICODE_STRING FunName;
	RtlInitUnicodeString(&FunName, L"MmCopyVirtualMemory");
	*(ULONG64*)((ULONG64)g_NmiContext + 0x444) = (ULONG64)MmGetSystemRoutineAddress(&FunName);

	StopDriver = FALSE;
	PsCreateSystemThread(&SendNMIThreadHandle, 0, NULL, NULL, NULL, &SendNMIKernelRoutine, NULL);

	return STATUS_SUCCESS;
}

```

`stuff.h`:

```h
#pragma once

#include <intrin.h>

#include <ntifs.h>

#define NMI_CB_POOL_TAG 'BCmN'

//0xa8 bytes (sizeof)
typedef struct _KAFFINITY_EX
{
    USHORT Count;                                                           //0x0
    USHORT Size;                                                            //0x2
    ULONG Reserved;                                                         //0x4
    ULONGLONG Bitmap[20];                                                   //0x8
} KAFFINITY_EX, *PKAFFINITY_EX;

typedef struct _NMI_CONTEXT
{
    INT NumFired;
} NMI_CONTEXT, *PNMI_CONTEXT;

EXTERN_C INT64 HLP_SecInNs(INT64 ms);
EXTERN_C VOID HLP_DelayExecutionThread(INT64 ms);
EXTERN_C BOOLEAN HLP_FireNMI(INT core, PKAFFINITY_EX affinity);

EXTERN_C VOID KeInitializeAffinityEx(PKAFFINITY_EX affinity);
EXTERN_C VOID KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);

EXTERN_C VOID HalSendNMI(PKAFFINITY_EX affinity);
EXTERN_C NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS SourceProcess,PVOID SourceAddress,PEPROCESS TargetProcess,PVOID TargetAddress,SIZE_T BufferSize,KPROCESSOR_MODE PreviousMode,PSIZE_T ReturnSize);
EXTERN_C __int64 __fastcall PsGetProcessSectionBaseAddress(__int64 a1);
EXTERN_C NTSTATUS NTAPI ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);


typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_ENTRY
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

#pragma warning(disable:4200)
typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[0];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;


```