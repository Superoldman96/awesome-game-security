Project Path: arc_gmh5225_HiveWE_7itr7rji

Source Tree:

```txt
arc_gmh5225_HiveWE_7itr7rji
├── CMakeLists.txt
├── CMakeSettings.json
├── Data
│   ├── Icons
│   │   ├── Brush
│   │   │   ├── circle.png
│   │   │   ├── diamond.png
│   │   │   └── square.png
│   │   ├── ObjectEditor
│   │   │   └── background.png
│   │   ├── Ribbon
│   │   │   ├── VARIATION32X32.png
│   │   │   ├── WarIII32x32.ico
│   │   │   ├── brush32x32.png
│   │   │   ├── changeheight32x32.png
│   │   │   ├── copy32x32.ico
│   │   │   ├── debug32x32.png
│   │   │   ├── description32x32.png
│   │   │   ├── doodads32x32.png
│   │   │   ├── exit32x32.ico
│   │   │   ├── height.png
│   │   │   ├── heightmap32x32.png
│   │   │   ├── importmanager32x32.png
│   │   │   ├── lighting32x32.png
│   │   │   ├── loading32x32.png
│   │   │   ├── lock.png
│   │   │   ├── minimap32x32.png
│   │   │   ├── new32x32.ico
│   │   │   ├── objecteditor32x32.png
│   │   │   ├── open32x32.png
│   │   │   ├── options32x32.png
│   │   │   ├── paste32x32.ico
│   │   │   ├── pathing32x32.png
│   │   │   ├── redo32x32.ico
│   │   │   ├── redo32x32.png
│   │   │   ├── reset32x32.png
│   │   │   ├── rock32x32.png
│   │   │   ├── save32x32.png
│   │   │   ├── saveas32x32.png
│   │   │   ├── scale32x32.png
│   │   │   ├── select32x32.png
│   │   │   ├── sizebounds32x32.png
│   │   │   ├── switch32x32.png
│   │   │   ├── test32x32.ico
│   │   │   ├── tileset32x32.png
│   │   │   ├── triggereditor32x32.png
│   │   │   ├── undo32x32.ico
│   │   │   ├── undo32x32.png
│   │   │   ├── units32x32.png
│   │   │   ├── water32x32.png
│   │   │   └── wireframe32x32.png
│   │   ├── Terrain
│   │   │   ├── boundary_place.png
│   │   │   ├── boundary_remove.png
│   │   │   ├── brush_lower.png
│   │   │   ├── brush_plateau.png
│   │   │   ├── brush_raise.png
│   │   │   ├── brush_ripple.png
│   │   │   ├── brush_smooth.png
│   │   │   ├── deep_water.png
│   │   │   ├── level.png
│   │   │   ├── lower1.png
│   │   │   ├── lower2.png
│   │   │   ├── raise1.png
│   │   │   ├── raise2.png
│   │   │   ├── ramp.png
│   │   │   └── shallow_water.png
│   │   ├── TriggerEditor
│   │   │   └── validate.png
│   │   ├── buildable.png
│   │   ├── check.png
│   │   ├── flyable.png
│   │   └── walkable.png
│   ├── Shaders
│   │   ├── brush.fs
│   │   ├── brush.vs
│   │   ├── cliff.fs
│   │   ├── cliff.vs
│   │   ├── editable_mesh_hd.fs
│   │   ├── editable_mesh_hd.vs
│   │   ├── physics_debug.fs
│   │   ├── physics_debug.vs
│   │   ├── selection.fs
│   │   ├── selection.vs
│   │   ├── selection_circle.fs
│   │   ├── selection_circle.vs
│   │   ├── skinned_mesh_hd.fs
│   │   ├── skinned_mesh_hd.vs
│   │   ├── skinned_mesh_instance_color_coded.fs
│   │   ├── skinned_mesh_instance_color_coded.vs
│   │   ├── skinned_mesh_instanced_hd.fs
│   │   ├── skinned_mesh_instanced_hd.vs
│   │   ├── skinned_mesh_instanced_sd.fs
│   │   ├── skinned_mesh_instanced_sd.vs
│   │   ├── skinned_mesh_sd.fs
│   │   ├── skinned_mesh_sd.vs
│   │   ├── static_mesh_color_coded.fs
│   │   ├── static_mesh_color_coded.vs
│   │   ├── static_mesh_hd.fs
│   │   ├── static_mesh_hd.vs
│   │   ├── static_mesh_instanced_hd.fs
│   │   ├── static_mesh_instanced_hd.vs
│   │   ├── static_mesh_instanced_sd.fs
│   │   ├── static_mesh_instanced_sd.vs
│   │   ├── static_mesh_sd.fs
│   │   ├── static_mesh_sd.vs
│   │   ├── terrain.fs
│   │   ├── terrain.vs
│   │   ├── test.fs
│   │   ├── test.vs
│   │   ├── water.fs
│   │   └── water.vs
│   ├── Test Map
│   │   ├── Crystal.mdx
│   │   ├── conversation.json
│   │   ├── war3map.doo
│   │   ├── war3map.imp
│   │   ├── war3map.mmp
│   │   ├── war3map.w3a
│   │   ├── war3map.w3b
│   │   ├── war3map.w3d
│   │   ├── war3map.w3e
│   │   ├── war3map.w3h
│   │   ├── war3map.w3i
│   │   ├── war3map.w3q
│   │   ├── war3map.w3r
│   │   ├── war3map.w3t
│   │   ├── war3map.w3u
│   │   ├── war3map.wct
│   │   ├── war3map.wpm
│   │   ├── war3map.wtg
│   │   ├── war3map.wts
│   │   ├── war3mapMap.blp
│   │   ├── war3mapSkin.w3a
│   │   ├── war3mapSkin.w3b
│   │   ├── war3mapSkin.w3d
│   │   ├── war3mapSkin.w3h
│   │   ├── war3mapSkin.w3q
│   │   ├── war3mapSkin.w3t
│   │   ├── war3mapSkin.w3u
│   │   └── war3mapUnits.doo
│   ├── Themes
│   │   ├── Dark.qss
│   │   └── Light.qss
│   ├── Tools
│   │   ├── bin
│   │   │   └── sfmpq.dll
│   │   ├── clijasshelper.exe
│   │   ├── jasshelper.conf
│   │   ├── pjass.exe
│   │   └── sfmpq.dll
│   └── Warcraft
│       ├── CityCliffs.slk
│       ├── Cliffs.slk
│       ├── DestructableSkin.txt
│       ├── ItemMetaData.slk
│       ├── UnitMetaData.slk
│       └── icon_tags.json
├── LICENSE
├── README.md
├── Screenshots
│   ├── GlobalPathingEditing.png
│   ├── HiveWE.png
│   ├── ObjectEditor.png
│   └── PathingEditing.png
├── src
│   ├── Base
│   │   ├── BinaryReader.ixx
│   │   ├── BinaryWriter.ixx
│   │   ├── Camera.cpp
│   │   ├── Camera.h
│   │   ├── Doodads.cpp
│   │   ├── Doodads.h
│   │   ├── FlowLayout.cpp
│   │   ├── FlowLayout.h
│   │   ├── GameCameras.ixx
│   │   ├── Hierarchy.ixx
│   │   ├── Imports.ixx
│   │   ├── InputHandler.cpp
│   │   ├── InputHandler.h
│   │   ├── Map.cpp
│   │   ├── Map.h
│   │   ├── MapInfo.ixx
│   │   ├── MathOperations.ixx
│   │   ├── PathingMap.cpp
│   │   ├── PathingMap.h
│   │   ├── Physics.cpp
│   │   ├── Physics.h
│   │   ├── Regions.cpp
│   │   ├── Regions.h
│   │   ├── RenderManager.cpp
│   │   ├── RenderManager.h
│   │   ├── ResourceManager.ixx
│   │   ├── ShadowMap.cpp
│   │   ├── ShadowMap.h
│   │   ├── Sounds.cpp
│   │   ├── Sounds.h
│   │   ├── Sounds.ixx
│   │   ├── Terrain.cpp
│   │   ├── Terrain.h
│   │   ├── TerrainUndo.cpp
│   │   ├── TerrainUndo.h
│   │   ├── TriggerStrings.cpp
│   │   ├── TriggerStrings.h
│   │   ├── Triggers.cpp
│   │   ├── Triggers.h
│   │   ├── Units.cpp
│   │   ├── Units.h
│   │   ├── WindowHandler.h
│   │   └── no_init_allocator.ixx
│   ├── Brush
│   │   ├── Brush.cpp
│   │   ├── Brush.h
│   │   ├── DoodadBrush.cpp
│   │   ├── DoodadBrush.h
│   │   ├── PathingBrush.cpp
│   │   ├── PathingBrush.h
│   │   ├── TerrainBrush.cpp
│   │   ├── TerrainBrush.h
│   │   ├── UnitBrush.cpp
│   │   └── UnitBrush.h
│   ├── CMakeLists.txt
│   ├── Custom Widgets
│   │   ├── AspectRatioPixmapLabel.cpp
│   │   ├── AspectRatioPixmapLabel.h
│   │   ├── ColorButton.cpp
│   │   ├── ColorButton.h
│   │   ├── FlowLayout.cpp
│   │   ├── FlowLayout.h
│   │   ├── GenericSelectorList.cpp
│   │   ├── GenericSelectorList.h
│   │   ├── IconView.cpp
│   │   ├── IconView.h
│   │   ├── QRibbon.cpp
│   │   ├── QRibbon.h
│   │   ├── UnitSelector.cpp
│   │   └── UnitSelector.h
│   ├── File Formats
│   │   ├── BLP.ixx
│   │   ├── CASC.ixx
│   │   ├── INI.cpp
│   │   ├── INI.h
│   │   ├── JSON.ixx
│   │   ├── MDX
│   │   │   ├── MDLReader.cpp
│   │   │   ├── MDLWriter.cpp
│   │   │   ├── MDX.ixx
│   │   │   ├── MDXReader.cpp
│   │   │   └── MDXWriter.cpp
│   │   ├── MPQ.ixx
│   │   ├── SLK.cpp
│   │   ├── SLK.h
│   │   └── SLK.ixx
│   ├── Globals.h
│   ├── MainWindow
│   │   ├── GLWidget.cpp
│   │   ├── GLWidget.h
│   │   ├── HiveWE.cpp
│   │   ├── HiveWE.h
│   │   ├── HiveWE.ico
│   │   ├── HiveWE.qrc
│   │   ├── HiveWE.rc
│   │   ├── HiveWE.ui
│   │   ├── MainRibbon.cpp
│   │   └── MainRibbon.h
│   ├── Menus
│   │   ├── DoodadPalette.cpp
│   │   ├── DoodadPalette.h
│   │   ├── DoodadPalette.ui
│   │   ├── MapInfoEditor.cpp
│   │   ├── MapInfoEditor.h
│   │   ├── MapInfoEditor.ui
│   │   ├── Minimap.cpp
│   │   ├── Minimap.h
│   │   ├── Minimap.ui
│   │   ├── ObjectEditor.cpp
│   │   ├── ObjectEditor.h
│   │   ├── ObjectEditor.ui
│   │   ├── Palette.cpp
│   │   ├── Palette.h
│   │   ├── PathingPalette.cpp
│   │   ├── PathingPalette.h
│   │   ├── PathingPalette.ui
│   │   ├── Selections.cpp
│   │   ├── Selections.h
│   │   ├── Selections.ui
│   │   ├── SettingsEditor.cpp
│   │   ├── SettingsEditor.h
│   │   ├── SettingsEditor.ui
│   │   ├── TerrainPalette.cpp
│   │   ├── TerrainPalette.h
│   │   ├── TerrainPalette.ui
│   │   ├── TilePather.cpp
│   │   ├── TilePather.h
│   │   ├── TilePather.ui
│   │   ├── TilePicker.cpp
│   │   ├── TilePicker.h
│   │   ├── TilePicker.ui
│   │   ├── TileSetter.cpp
│   │   ├── TileSetter.h
│   │   ├── TileSetter.ui
│   │   ├── UnitPalette.cpp
│   │   ├── UnitPalette.h
│   │   └── UnitPalette.ui
│   ├── ModelEditor
│   │   ├── ModelEditor.cpp
│   │   ├── ModelEditor.h
│   │   ├── ModelEditor.ui
│   │   ├── ModelEditorCamera.cpp
│   │   ├── ModelEditorCamera.h
│   │   ├── ModelEditorGLWidget.cpp
│   │   └── ModelEditorGLWidget.h
│   ├── Models
│   │   ├── AbilityTreeModel.cpp
│   │   ├── AbilityTreeModel.h
│   │   ├── BaseTreeModel.cpp
│   │   ├── BaseTreeModel.h
│   │   ├── BuffTreeModel.cpp
│   │   ├── BuffTreeModel.h
│   │   ├── DestructableListModel.cpp
│   │   ├── DestructableListModel.h
│   │   ├── DestructibleTreeModel.cpp
│   │   ├── DestructibleTreeModel.h
│   │   ├── DoodadListModel.cpp
│   │   ├── DoodadListModel.h
│   │   ├── DoodadTreeModel.cpp
│   │   ├── DoodadTreeModel.h
│   │   ├── ItemTreeModel.cpp
│   │   ├── ItemTreeModel.h
│   │   ├── SingleModel.cpp
│   │   ├── SingleModel.h
│   │   ├── TableModel.cpp
│   │   ├── TableModel.h
│   │   ├── UnitListModel.cpp
│   │   ├── UnitListModel.h
│   │   ├── UnitTreeModel.cpp
│   │   ├── UnitTreeModel.h
│   │   ├── UpgradeTreeModel.cpp
│   │   └── UpgradeTreeModel.h
│   ├── QtImgui
│   │   ├── ImGuiRenderer.cpp
│   │   ├── ImGuiRenderer.h
│   │   ├── QtImGui.cpp
│   │   └── QtImGui.h
│   ├── Resources
│   │   ├── CliffMesh.cpp
│   │   ├── CliffMesh.h
│   │   ├── EditableMesh.cpp
│   │   ├── EditableMesh.h
│   │   ├── GPUTexture.cpp
│   │   ├── GPUTexture.h
│   │   ├── GroundTexture.cpp
│   │   ├── GroundTexture.h
│   │   ├── PathingTexture.ixx
│   │   ├── QIconResource.cpp
│   │   ├── QIconResource.h
│   │   ├── Shader.cpp
│   │   ├── Shader.h
│   │   ├── SkinnedMesh
│   │   │   ├── RenderNode.ixx
│   │   │   ├── SkeletalModelInstance.cpp
│   │   │   ├── SkeletalModelInstance.h
│   │   │   └── SkeletalModelInstance.ixx
│   │   ├── SkinnedMesh.cpp
│   │   ├── SkinnedMesh.h
│   │   └── Texture.ixx
│   ├── Utilities
│   │   ├── ModificationTables.ixx
│   │   ├── OpenGLUtilities.cpp
│   │   ├── OpenGLUtilities.h
│   │   ├── Timer.ixx
│   │   └── Utilities.ixx
│   ├── Utilities.cpp
│   ├── Utilities.h
│   ├── main.cpp
│   ├── resource.h
│   ├── test.cpp
│   └── test.h
├── tabs.editorconfig
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
if (DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)
	set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake" CACHE STRING "")
endif ()

cmake_minimum_required(VERSION 3.22)
project (HiveWE CXX)

set(CMAKE_INCLUDE_CURRENT_DIR ON)

find_package(Qt6 COMPONENTS Core Gui Widgets OpenGL OpenGLWidgets REQUIRED)
find_package(Bullet CONFIG REQUIRED)
find_package(glm CONFIG REQUIRED)
find_package(glad CONFIG REQUIRED)
find_package(soil2 CONFIG REQUIRED)
find_package(stormlib CONFIG REQUIRED)
find_package(CascLib CONFIG REQUIRED)
find_package(JPEG REQUIRED)
find_package(qtadvanceddocking CONFIG REQUIRED)
find_package(absl CONFIG REQUIRED)
find_package(fmt CONFIG REQUIRED)
find_package(TBB CONFIG REQUIRED)
find_package(libjpeg-turbo CONFIG REQUIRED)
find_package(imgui CONFIG REQUIRED)
find_package(outcome CONFIG REQUIRED)

qt_standard_project_setup()

add_executable(HiveWE 
	${QT_RESOURCES}
)

add_subdirectory(src)

target_include_directories(HiveWE PRIVATE 
	"src" 
	"src/Base" 
	"src/Brush" 
	"src/Custom Widgets" 
	"src/File Formats" 
	"src/Menus" 
	"src/Models"
	"src/Resources" 
	"src/Resources/SkinnedMesh" 
	"src/Utilities"

	${BULLET_INCLUDE_DIR}
)

target_link_libraries(HiveWE PUBLIC
	Qt6::Gui
	Qt6::Widgets
	Qt6::OpenGL
	Qt6::OpenGLWidgets
	glm::glm
	glad::glad
	soil2
	stormlib::stormlib
	libjpeg-turbo::jpeg
	libjpeg-turbo::turbojpeg
	ads::qtadvanceddocking
	Bullet3Common
	BulletDynamics
	BulletSoftBody
	BulletInverseDynamics
	BulletCollision
	LinearMath
	absl::flat_hash_map
	absl::flat_hash_set
	fmt::fmt
	fmt::fmt-header-only
	TBB::tbb
	imgui::imgui
	outcome::hl
)

#target_compile_options(HiveWE PRIVATE
#  $<$<CXX_COMPILER_ID:MSVC>:/Zc:__cplusplus /W4 /WX /sdl /permissive->
#  $<$<CXX_COMPILER_ID:Clang>: -Wextra -Wpedantic -Werror>
#  $<$<CXX_COMPILER_ID:GNU>:-Wall -Wextra -Wpedantic -Werror>
#)

if(WIN32)
	target_compile_definitions(HiveWE PUBLIC UNICODE _UNICODE)

	if (MSVC)
		# Properly sets the __cplusplus macro to the newest version. Might not be needed anymore in vsNext. Last checked 25/05/2021
		target_compile_options(HiveWE PUBLIC "/Zc:__cplusplus; /MP")
	endif()

	target_link_options(HiveWE PUBLIC /PROFILE)

	target_link_libraries(HiveWE PUBLIC CascLib::casc)
else()
	target_compile_definitions(HiveWE PUBLIC TBB_SUPPRESS_DEPRECATED_MESSAGES)

	target_compile_options(HiveWE PUBLIC "-Wno-multichar")

	target_link_libraries(HiveWE PUBLIC CascLib::casc_static)
endif()

target_compile_features(HiveWE PUBLIC cxx_std_20)

add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
	COMMAND ${CMAKE_COMMAND}
	-E
	create_symlink "${PROJECT_SOURCE_DIR}/Data"
	"${CMAKE_CURRENT_BINARY_DIR}/Data"
	DEPENDS "${CMAKE_CURRENT_BINARY_DIR}/Data"
)

install(TARGETS HiveWE
    BUNDLE  DESTINATION .
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

qt_generate_deploy_app_script(
    TARGET HiveWE
    FILENAME_VARIABLE deploy_script
    NO_UNSUPPORTED_PLATFORM_ERROR
)

install(SCRIPT ${deploy_script})
```

`CMakeSettings.json`:

```json
{
  "configurations": [
    {
      "name": "x64-Debug",
      "generator": "Visual Studio 17 2022 Win64",
      "configurationType": "Debug",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
      "installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "enableClangTidyCodeAnalysis": true,
      "clangTidyChecks": "-*,cppcoreguidelines-*"
    },
    {
      "name": "x64-RelWithDebInfo",
      "generator": "Visual Studio 17 2022 Win64",
      "configurationType": "RelWithDebInfo",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
      "installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    },
    {
      "name": "x64-Release",
      "generator": "Visual Studio 17 2022 Win64",
      "configurationType": "Release",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
      "installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    },
    {
      "name": "x64-Clang-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
      "installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "clang_cl_x64_x64" ]
    },
    {
      "name": "x64-Clang-Release",
      "generator": "Ninja",
      "configurationType": "Release",
      "buildRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\build\\${name}",
      "installRoot": "${env.USERPROFILE}\\CMakeBuilds\\${workspaceHash}\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "clang_cl_x64_x64" ]
    }
  ]
}
```

`Data/Shaders/brush.fs`:

```fs
#version 450 core

layout (binding = 1) uniform sampler2D brush;

in vec2 UV;

out vec4 color;

void main() {
	if (UV.x < 0.f || UV.y < 0.f || UV.x > 1.f || UV.y > 1.f) {
		color = vec4(0, 0, 0, 0);
	} else {
		color = texture(brush, UV);
	}
}
```

`Data/Shaders/brush.vs`:

```vs
#version 450 core

layout (location = 0) in vec2 vPosition;

layout (location = 1) uniform mat4 MVP;
layout (location = 2) uniform vec2 offset;
layout (location = 3) uniform vec2 uv_offset;
layout (location = 4) uniform int cells;

layout (binding = 0) uniform sampler2D height_texture;
layout (binding = 1) uniform sampler2D brush;

out vec2 UV;

void main() {
	vec2 size_brush = textureSize(brush, 0) / 4.f;

	vec2 local_pos = vec2(gl_InstanceID % cells, gl_InstanceID / cells);
	vec2 pos = offset + vPosition + local_pos;

	vec4 height = texture(height_texture, (pos + 1) / textureSize(height_texture, 0));

	gl_Position = MVP * vec4(pos, height.r, 1);

	UV = (vPosition + local_pos - uv_offset * 0.25f ) / size_brush;
}
```

`Data/Shaders/cliff.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2DArray cliff_textures;
layout (binding = 2) uniform usampler2D pathing_map_static;

layout (location = 1) uniform bool show_pathing_map_static;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;

layout (location = 0) in vec3 UV;
layout (location = 1) in vec3 Normal;
layout (location = 2) in vec2 pathing_map_uv;

out vec4 color;

void main() {
	color = texture(cliff_textures, UV);

	if (show_lighting) {
		color.rgb *= (dot(-light_direction, Normal) + 1.f) * 0.5f;
	}

	uvec4 byte = texelFetch(pathing_map_static, ivec2(pathing_map_uv), 0);
	if (show_pathing_map_static) {
		vec4 pathing_color = vec4(min(byte.r & 2, 1), min(byte.r & 4, 1), min(byte.r & 8, 1), 0.25);
		color = length(pathing_color.rgb) > 0 ? color * 0.75 + pathing_color * 0.5 : color;
	}
}
```

`Data/Shaders/cliff.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vOffset;

layout (location = 0) uniform mat4 MVP;

layout (binding = 1) uniform sampler2D height_texture;

layout (location = 0) out vec3 UV;
layout (location = 1) out vec3 Normal;
layout (location = 2) out vec2 pathing_map_uv;

void main() {
	// WC3 cliff meshes seem to be rotated by 90 degrees so we unrotate
	const vec3 rotated_world_position = vec3(vPosition.y, -vPosition.x, vPosition.z) / 128.f + vOffset.xyz;

	const ivec2 size = textureSize(height_texture, 0);
	const float height = texture(height_texture, (rotated_world_position.xy + 0.5f) / vec2(size)).r;

	const ivec2 height_pos = ivec2(rotated_world_position.xy);
	const ivec3 off = ivec3(1, 1, 0);
	const float hL = texelFetch(height_texture, height_pos - off.xz, 0).r;
	const float hR = texelFetch(height_texture, height_pos + off.xz, 0).r;
	const float hD = texelFetch(height_texture, height_pos - off.zy, 0).r;
	const float hU = texelFetch(height_texture, height_pos + off.zy, 0).r;
	const vec3 terrain_normal = normalize(vec3(hL - hR, hD - hU, 2.0));

	gl_Position = MVP * vec4(rotated_world_position.xy, rotated_world_position.z + height, 1);

	pathing_map_uv = rotated_world_position.xy * 4;
	UV = vec3(vUV, vOffset.a);

	const vec3 rotated_normal = vec3(vNormal.y, -vNormal.x, vNormal.z);
	Normal = normalize(vec3(rotated_normal.xy + terrain_normal.xy, rotated_normal.z * terrain_normal.z));
}
```

`Data/Shaders/editable_mesh_hd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;
layout (binding = 1) uniform sampler2D normal;
layout (binding = 2) uniform sampler2D orm;
layout (binding = 3) uniform sampler2D emissive;
layout (binding = 4) uniform sampler2D teamColor;
layout (binding = 5) uniform sampler2D environment;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;

in vec2 UV;
in vec3 tangent_light_direction;
in vec4 vertexColor;

out vec4 color;

void main() {
	// color = vec4(1.f, 1.f, 1.f, 1.f);
	color = texture(diffuse, UV) * vertexColor;
	
	if (show_lighting) {
		vec3 emissive_texel = texture(emissive, UV).rgb;
		vec4 orm_texel = texture(orm, UV);
		vec3 tc_texel = texture(teamColor, UV).rgb;
		color.rgb = (color.rgb * (1 - orm_texel.w) + color.rgb * tc_texel * orm_texel.w);

		// normal is a 2 channel normal map so we have to deduce the 3rd value
		vec2 normal_texel = texture(normal, UV).xy * 2.0 - 1.0;
		vec3 normal = vec3(normal_texel, sqrt(1.0 - dot(normal_texel, normal_texel)));

		float lambert = clamp(dot(normal, -tangent_light_direction), 0.f, 1.f);
		color.rgb *= clamp(lambert + 0.1, 0.f, 1.f);
		color.rgb += emissive_texel;
	}


	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/editable_mesh_hd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vTangent;
layout (location = 4) in uvec2 vSkin;

layout (location = 0) uniform mat4 MVP;
layout (location = 3) uniform int bone_count;
layout (location = 4) uniform mat4 model;
layout (location = 5) uniform vec4 layer_color;
layout (location = 6) uniform vec3 light_direction;
layout (location = 8) uniform mat4 bones[217]; // Thats a lotta boners. max 200 because the shader compiler issues an error when going higher

out vec2 UV;
out vec3 tangent_light_direction;
out vec4 vertexColor;

void main() {
	const mat4 b0 = bones[int(vSkin.x & 0x000000FF)];
	const mat4 b1 = bones[int(vSkin.x & 0x0000FF00) >> 8];
	const mat4 b2 = bones[int(vSkin.x & 0x00FF0000) >> 16];
	const mat4 b3 = bones[int(vSkin.x & 0xFF000000) >> 24];
	const float w0 = (vSkin.y & 0x000000FF) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000) >> 24) / 255.f;
	mat4 skinMatrix = model * (b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3);
	
	gl_Position = MVP * skinMatrix * vec4(vPosition, 1.f);
	// gl_Position = MVP * vec4(vPosition, 1.f);

	mat3 model = mat3(skinMatrix);
	vec3 T = normalize(model * vTangent.xyz);
	vec3 N = normalize(model * vNormal);
	vec3 B = cross(N, T) * vTangent.w; // to fix handedness
	mat3 TBN = transpose(mat3(T, B, N));

	UV = vUV;
	tangent_light_direction = normalize(TBN * light_direction);
	vertexColor = layer_color;
}
```

`Data/Shaders/physics_debug.fs`:

```fs
#version 450 core

out vec4 color;

void main() {
	color = vec4(0, 1, 0, 1);
}
```

`Data/Shaders/physics_debug.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) uniform mat4 MVP;

void main() {
	gl_Position = MVP * vec4(vPosition, 1);
}
```

`Data/Shaders/selection.fs`:

```fs
#version 450 core

out vec4 color;

void main() {
	color = vec4(0, 1, 0, 1);
}
```

`Data/Shaders/selection.vs`:

```vs
#version 450 core

layout (location = 0) in vec2 vPosition;
layout (location = 1) uniform mat4 MVP;

void main() {
	gl_Position = MVP * vec4(vPosition, 0, 1);
}
```

`Data/Shaders/selection_circle.fs`:

```fs
#version 450 core

out vec4 color;

in vec2 uv;

void main() {
	float R = 1.0; 
	float R2 = 0.93; 
	float dist = sqrt(dot(uv * 2.f - 1.f, uv * 2.f - 1.f));
	if (dist >= R || dist <= R2)
	{ discard; } 
	color = vec4(0, 1, 0, 0.75);
}
```

`Data/Shaders/selection_circle.vs`:

```vs
#version 450 core

layout (location = 0) in vec2 vPosition;
layout (location = 1) uniform mat4 MVP;

out vec2 uv;

void main() {
	uv = vPosition;
	gl_Position = MVP * vec4(vPosition, 0, 1);
}
```

`Data/Shaders/skinned_mesh_hd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D albedo;
layout (binding = 1) uniform sampler2D normal;
layout (binding = 2) uniform sampler2D orm;
layout (binding = 3) uniform sampler2D emissive;
layout (binding = 4) uniform sampler2D teamColor;
layout (binding = 5) uniform sampler2D environment;

layout (location = 2) uniform bool show_lighting;

in vec2 UV;
in vec3 tangent_light_direction;
in vec4 vertexColor;

out vec4 color;

void main() {
	color = texture(albedo, UV) * vertexColor;
	
	if (show_lighting) {
		vec3 emissive_texel = texture(emissive, UV).rgb;
		vec4 orm_texel = texture(orm, UV);
		vec3 tc_texel = texture(teamColor, UV).rgb;
		color.rgb = (color.rgb * (1 - orm_texel.w) + color.rgb * tc_texel * orm_texel.w);

		// normal is a 2 channel normal map so we have to deduce the 3rd value
		vec2 normal_texel = texture(normal, UV).xy * 2.0 - 1.0;
		vec3 normal = vec3(normal_texel, sqrt(1.0 - dot(normal_texel, normal_texel)));

		float lambert = clamp(dot(normal, -tangent_light_direction), 0.f, 1.f);
		color.rgb *= clamp(lambert + 0.1, 0.f, 1.f);
		color.rgb += emissive_texel;
	}
}
```

`Data/Shaders/skinned_mesh_hd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vTangent;
layout (location = 4) in uvec2 vSkin;

// Should match the uniform locations in skinned_mesh_sd.vs
layout (location = 0) uniform mat4 MVP;
layout (location = 3) uniform int bone_count;
layout (location = 4) uniform int instanceID;
layout (location = 5) uniform mat4 M;
layout (location = 6) uniform int layer_skip_count;
layout (location = 7) uniform int layer_index;
layout (location = 8) uniform vec3 light_direction;

layout(std430, binding = 0) buffer layoutName {
    vec4 layer_colors[];
};

layout (binding = 5) uniform samplerBuffer nodeMatrices;

out vec2 UV;
out vec3 tangent_light_direction;
out vec4 vertexColor;

mat4 fetchMatrix(int bone_index) {
	return mat4(
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4),
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4 + 1),
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4 + 2),
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4 + 3));
}

void main() {
	const mat4 b0 = fetchMatrix(int(vSkin.x & 0x000000FF));
	const mat4 b1 = fetchMatrix(int(vSkin.x & 0x0000FF00) >> 8);
	const mat4 b2 = fetchMatrix(int(vSkin.x & 0x00FF0000) >> 16);
	const mat4 b3 = fetchMatrix(int(vSkin.x & 0xFF000000) >> 24);
	const float w0 = (vSkin.y & 0x000000FF) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000) >> 24) / 255.f;
	mat4 skinMatrix = b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3;
	
	gl_Position = MVP * skinMatrix * vec4(vPosition, 1.f);

	mat3 model = mat3(M * skinMatrix);
	vec3 T = normalize(model * vTangent.xyz);
	vec3 N = normalize(model * vNormal);
	vec3 B = cross(N, T) * vTangent.w; // to fix handedness
	mat3 TBN = transpose(mat3(T, B, N));

	UV = vUV;
	tangent_light_direction = TBN * light_direction;
	vertexColor = layer_colors[instanceID * layer_skip_count + layer_index];
}
```

`Data/Shaders/skinned_mesh_instance_color_coded.fs`:

```fs
#version 450 core

layout (location = 1) uniform float alpha_test;

out vec4 color;

layout (location = 7) uniform int color_id;

void main() {
	color = vec4((color_id & 0xFF) / 255.f, ((color_id & 0xFF00) >> 8) / 255.f, ((color_id & 0xFF0000) >> 16) / 255.f, 1.f);
	//outColor = vec4(color_id * 0.5f, 0.f, 1.f, 1.f);
	// if (outColor.a < alpha_test) {
	// 	discard;
	// }
}
```

`Data/Shaders/skinned_mesh_instance_color_coded.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 4) in uvec2 vSkin;

layout (location = 0) uniform mat4 MVP;
layout (location = 3) uniform int bone_count;
layout (location = 4) uniform vec3 geoset_color;
layout (location = 5) uniform float layer_alpha;
layout (location = 8) uniform mat4 bones[217]; // Thats a lotta boners. max 200 because the shader compiler issues an error when going higher

void main() {
	const mat4 b0 = bones[int(vSkin.x & 0x000000FF)];
	const mat4 b1 = bones[int(vSkin.x & 0x0000FF00) >> 8];
	const mat4 b2 = bones[int(vSkin.x & 0x00FF0000) >> 16];
	const mat4 b3 = bones[int(vSkin.x & 0xFF000000) >> 24];
	const float w0 = (vSkin.y & 0x000000FF) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000) >> 24) / 255.f;
	
	vec4 position = vec4(vPosition, 1.f);
	position = b0 * position * w0 + b1 * position * w1 + b2 * position * w2 + b3 * position * w3;
	position.w = 1.f;

	gl_Position = MVP * position;
	
	vec4 vertexColor = vec4(geoset_color, layer_alpha);
}
```

`Data/Shaders/skinned_mesh_instanced_hd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;
layout (binding = 1) uniform sampler2D normal;
layout (binding = 2) uniform sampler2D orm;
layout (binding = 3) uniform sampler2D emissive;
layout (binding = 4) uniform sampler2D teamColor;
layout (binding = 5) uniform sampler2D environment;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;

in vec2 UV;
in vec3 tangent_light_direction;
in vec4 vertexColor;

out vec4 color;

void main() {
	color = texture(diffuse, UV) * vertexColor;
	
	if (show_lighting) {
		vec3 emissive_texel = texture(emissive, UV).rgb;
		vec4 orm_texel = texture(orm, UV);
		vec3 tc_texel = texture(teamColor, UV).rgb;
		color.rgb = (color.rgb * (1 - orm_texel.w) + color.rgb * tc_texel * orm_texel.w);

		// normal is a 2 channel normal map so we have to deduce the 3rd value
		vec2 normal_texel = texture(normal, UV).xy * 2.0 - 1.0;
		vec3 normal = vec3(normal_texel, sqrt(1.0 - dot(normal_texel, normal_texel)));

		float lambert = clamp(dot(normal, -tangent_light_direction), 0.f, 1.f);
		color.rgb *= clamp(lambert + 0.1, 0.f, 1.f);
		color.rgb += emissive_texel;
	}


	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/skinned_mesh_instanced_hd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vTangent;
layout (location = 4) in uvec2 vSkin;
layout (location = 5) in mat4 vInstance;

layout (location = 0) uniform mat4 VP;
layout (location = 3) uniform int bone_count;
layout (location = 4) uniform int layer_skip_count;
layout (location = 5) uniform int layer_index;
layout (location = 6) uniform vec3 light_direction;

layout(std430, binding = 0) buffer layoutName {
    vec4 layer_colors[];
};

layout (binding = 5) uniform samplerBuffer nodeMatrices;

out vec2 UV;
out vec3 tangent_light_direction;
out vec4 vertexColor;

mat4 fetchMatrix(int bone_index) {
	return mat4(
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4),
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4 + 1),
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4 + 2),
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4 + 3));
}

void main() {
	const mat4 b0 = fetchMatrix(int(vSkin.x & 0x000000FF));
	const mat4 b1 = fetchMatrix(int(vSkin.x & 0x0000FF00) >> 8);
	const mat4 b2 = fetchMatrix(int(vSkin.x & 0x00FF0000) >> 16);
	const mat4 b3 = fetchMatrix(int(vSkin.x & 0xFF000000) >> 24);
	const float w0 = (vSkin.y & 0x000000FF) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000) >> 24) / 255.f;
	mat4 skinMatrix = vInstance * (b0 * w0 + b1 * w1 + b2 * w2 + b3 * w3);
	
	gl_Position = VP * skinMatrix * vec4(vPosition, 1.f);

	mat3 model = mat3(skinMatrix);
	vec3 T = normalize(model * vTangent.xyz);
	vec3 N = normalize(model * vNormal);
	vec3 B = cross(N, T) * vTangent.w; // to fix handedness
	mat3 TBN = transpose(mat3(T, B, N));

	UV = vUV;
	tangent_light_direction = normalize(TBN * light_direction);
	vertexColor = layer_colors[gl_InstanceID * layer_skip_count + layer_index];
}
```

`Data/Shaders/skinned_mesh_instanced_sd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D image;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;
layout (location = 6) uniform vec3 light_direction;

in vec2 UV;
in vec3 Normal;
in vec4 vertexColor;

out vec4 color;

void main() {
	color = texture(image, UV) * vertexColor;

	if (show_lighting) {
		float contribution = (dot(Normal, -light_direction) + 1.f) * 0.5f;
		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/skinned_mesh_instanced_sd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 4) in uvec2 vSkin;
layout (location = 5) in mat4 vInstance;

layout (location = 0) uniform mat4 VP;
layout (location = 3) uniform int bone_count;
layout (location = 4) uniform int layer_skip_count;
layout (location = 5) uniform int layer_index;

layout(std430, binding = 0) buffer layoutName {
    vec4 layer_colors[];
};

layout (binding = 5) uniform samplerBuffer nodeMatrices;

out vec2 UV;
out vec3 Normal;
out vec4 vertexColor;

mat4 fetchMatrix(int bone_index) {
	return mat4(
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4),
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4 + 1),
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4 + 2),
		texelFetch(nodeMatrices, gl_InstanceID * bone_count * 4 + bone_index * 4 + 3));
}

void main() {
	const mat4 b0 = fetchMatrix(int(vSkin.x & 0x000000FF));
	const mat4 b1 = fetchMatrix(int(vSkin.x & 0x0000FF00) >> 8);
	const mat4 b2 = fetchMatrix(int(vSkin.x & 0x00FF0000) >> 16);
	const mat4 b3 = fetchMatrix(int(vSkin.x & 0xFF000000) >> 24);
	const float w0 = (vSkin.y & 0x000000FF) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000) >> 24) / 255.f;
	
	vec4 position = vec4(vPosition, 1.f);
	position = b0 * position * w0 + b1 * position * w1 + b2 * position * w2 + b3 * position * w3;
	position.w = 1.f;

	gl_Position = VP * vInstance * position;

	UV = vUV;
	Normal = normalize(mat3(vInstance) * vNormal);
	vertexColor = layer_colors[gl_InstanceID * layer_skip_count + layer_index];
}
```

`Data/Shaders/skinned_mesh_sd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;

layout (location = 2) uniform bool show_lighting;
layout (location = 8) uniform vec3 light_direction;

in vec2 UV;
in vec3 Normal;
in vec4 vertexColor;

out vec4 color;

void main() {
	color = texture(diffuse, UV) * vertexColor;

	if (show_lighting) {
		float contribution = (dot(Normal, -light_direction) + 1.f) * 0.5f;
		color.rgb *= clamp(contribution, 0.f, 1.f);
	}
}
```

`Data/Shaders/skinned_mesh_sd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 4) in uvec2 vSkin;

// Should match the uniform locations in skinned_mesh_hd.vs
layout (location = 0) uniform mat4 MVP;
layout (location = 3) uniform int bone_count;
layout (location = 4) uniform int instanceID;
layout (location = 6) uniform int layer_skip_count;
layout (location = 7) uniform int layer_index;

layout(std430, binding = 0) buffer layoutName {
    vec4 layer_colors[];
};

layout (binding = 5) uniform samplerBuffer nodeMatrices;

out vec2 UV;
out vec3 Normal;
out vec4 vertexColor;

mat4 fetchMatrix(int bone_index) {
	return mat4(
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4),
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4 + 1),
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4 + 2),
		texelFetch(nodeMatrices, instanceID * bone_count * 4 + bone_index * 4 + 3));
}

void main() {
	const mat4 b0 = fetchMatrix(int(vSkin.x & 0x000000FF));
	const mat4 b1 = fetchMatrix(int(vSkin.x & 0x0000FF00) >> 8);
	const mat4 b2 = fetchMatrix(int(vSkin.x & 0x00FF0000) >> 16);
	const mat4 b3 = fetchMatrix(int(vSkin.x & 0xFF000000) >> 24);
	const float w0 = (vSkin.y & 0x000000FF) / 255.f;
	const float w1 = ((vSkin.y & 0x0000FF00) >> 8) / 255.f;
	const float w2 = ((vSkin.y & 0x00FF0000) >> 16) / 255.f;
	const float w3 = ((vSkin.y & 0xFF000000) >> 24) / 255.f;
	
	vec4 position = vec4(vPosition, 1.f);
	position = b0 * position * w0 + b1 * position * w1 + b2 * position * w2 + b3 * position * w3;
	position.w = 1.f;

	gl_Position = MVP * position;
	
	UV = vUV;
	Normal = vNormal;
	vertexColor = layer_colors[instanceID * layer_skip_count + layer_index];
}
```

`Data/Shaders/static_mesh_color_coded.fs`:

```fs
#version 450 core

out vec4 color;

layout (location = 7) uniform int color_id;

void main() {
	color = vec4((color_id & 0xFF) / 255.f, ((color_id & 0xFF00) >> 8) / 255.f, ((color_id & 0xFF0000) >> 16) / 255.f, 1.f);
}
```

`Data/Shaders/static_mesh_color_coded.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in uvec2 vSkin;

layout (location = 0) uniform mat4 VP;
layout (location = 3) uniform mat4 M;

void main() {
	gl_Position = VP * M * vec4(vPosition, 1);
}
```

`Data/Shaders/static_mesh_hd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;
layout (binding = 1) uniform sampler2D normal;
layout (binding = 2) uniform sampler2D orm;
layout (binding = 3) uniform sampler2D emissive;
layout (binding = 4) uniform sampler2D teamColor;
layout (binding = 5) uniform sampler2D environment;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;

in vec2 UV;
in vec3 tangent_light_direction;

out vec4 color;

void main() {
	color = texture(diffuse, UV);
	
	// normal is a 2 channel normal map so we have to deduce the 3rd value
	if (show_lighting) {
		vec3 emissive_texel = texture(emissive, UV).rgb;
		vec4 orm_texel = texture(orm, UV);
		vec3 tc_texel = texture(teamColor, UV).rgb;
		color.rgb = (color.rgb * (1 - orm_texel.w) + color.rgb * tc_texel * orm_texel.w);

		// normal is a 2 channel normal map so we have to deduce the 3rd value
		vec2 normal_texel = texture(normal, UV).xy * 2.0 - 1.0;
		vec3 normal = vec3(normal_texel, sqrt(1.0 - dot(normal_texel, normal_texel)));

		float lambert = clamp(dot(normal, -tangent_light_direction), 0.f, 1.f);
		color.rgb *= clamp(lambert + 0.1, 0.f, 1.f);
		color.rgb += emissive_texel;
	}

	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/static_mesh_hd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vTangent;

layout (location = 0) uniform mat4 VP;
layout (location = 3) uniform mat4 M;
layout (location = 4) uniform vec3 light_direction;

out vec2 UV;
out vec3 tangent_light_direction;

void main() {
	gl_Position = VP * M * vec4(vPosition, 1);
	UV = vUV;

	mat3 model = mat3(M);
	vec3 T = normalize(model * vTangent.xyz);
	vec3 N = normalize(model * vNormal);
	vec3 B = cross(N, T) * vTangent.w; // to fix handedness
	mat3 TBN = transpose(mat3(T, B, N));

	tangent_light_direction = TBN * light_direction;
}
```

`Data/Shaders/static_mesh_instanced_hd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;
layout (binding = 1) uniform sampler2D normal;
layout (binding = 2) uniform sampler2D orm;
layout (binding = 3) uniform sampler2D emissive;
layout (binding = 4) uniform sampler2D teamColor;
layout (binding = 5) uniform sampler2D environment;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;

in vec2 UV;
in vec3 tangent_light_direction;
in vec3 vertexColor;

out vec4 color;

void main() {
	color = texture(diffuse, UV) * vec4(vertexColor, 1.f);
	
	if (show_lighting) {
		vec3 emissive_texel = texture(emissive, UV).rgb;
		vec4 orm_texel = texture(orm, UV);
		vec3 tc_texel = texture(teamColor, UV).rgb;
		color.rgb = (color.rgb * (1 - orm_texel.w) + color.rgb * tc_texel * orm_texel.w);

		// normal is a 2 channel normal map so we have to deduce the 3rd value
		vec2 normal_texel = texture(normal, UV).xy * 2.0 - 1.0;
		vec3 normal = vec3(normal_texel, sqrt(1.0 - dot(normal_texel, normal_texel)));

		float lambert = clamp(dot(normal, -tangent_light_direction), 0.f, 1.f);
		color.rgb *= clamp(lambert + 0.1, 0.f, 1.f);
		color.rgb += emissive_texel;
	}


	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/static_mesh_instanced_hd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 3) in vec4 vTangent;
layout (location = 4) in mat4 vInstance;
layout (location = 8) in vec3 vGeosetColor;

layout (location = 0) uniform mat4 VP;

layout (location = 3) uniform vec3 light_direction;

out vec2 UV;
out vec3 tangent_light_direction;
out vec3 vertexColor;

void main() {
	gl_Position = VP * vInstance * vec4(vPosition, 1.f);
	UV = vUV;

	mat3 model = mat3(vInstance);
	vec3 T = normalize(model * vTangent.xyz);
	vec3 N = normalize(model * vNormal);
	vec3 B = cross(N, T) * vTangent.w; // to fix handedness
	mat3 TBN = transpose(mat3(T, B, N));

	tangent_light_direction = normalize(TBN * light_direction);
	vertexColor = vGeosetColor;
}
```

`Data/Shaders/static_mesh_instanced_sd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D diffuse;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;

in vec2 UV;
in vec3 Normal;

out vec4 color;

void main() {
	color = texture(diffuse, UV);
	
	if (show_lighting) {
		float contribution = (dot(Normal, -light_direction) + 1.f) * 0.5f;
		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/static_mesh_instanced_sd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;
layout (location = 4) in mat4 vInstance;

layout (location = 0) uniform mat4 VP;

out vec2 UV;
out vec3 Normal;

void main() {
	gl_Position = VP * vInstance * vec4(vPosition, 1);
	UV = vUV;
	Normal = normalize(mat3(vInstance) * vNormal);
}
```

`Data/Shaders/static_mesh_sd.fs`:

```fs
#version 450 core

layout (binding = 0) uniform sampler2D image;

layout (location = 1) uniform float alpha_test;
layout (location = 2) uniform bool show_lighting;
layout (location = 3) uniform vec3 light_direction;

in vec2 UV;
in vec3 Normal;

out vec4 color;

void main() {
	color = texture(image, UV);

	if (show_lighting) {
		float contribution = (dot(Normal, -light_direction) + 1.f) * 0.5f;
		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	if (color.a < alpha_test) {
		discard;
	}
}
```

`Data/Shaders/static_mesh_sd.vs`:

```vs
#version 450 core

layout (location = 0) in vec3 vPosition;
layout (location = 1) in vec2 vUV;
layout (location = 2) in vec3 vNormal;

layout (location = 0) uniform mat4 MVP;

out vec2 UV;
out vec3 Normal;

void main() {
	gl_Position = MVP * vec4(vPosition, 1);
	UV = vUV;
	Normal = vNormal;
}
```

`Data/Shaders/terrain.fs`:

```fs
#version 450 core

layout (location = 2) uniform bool show_pathing_map;
layout (location = 3) uniform bool show_lighting;
layout (location = 4) uniform vec3 light_direction;

layout (binding = 3) uniform sampler2DArray sample0;
layout (binding = 4) uniform sampler2DArray sample1;
layout (binding = 5) uniform sampler2DArray sample2;
layout (binding = 6) uniform sampler2DArray sample3;
layout (binding = 7) uniform sampler2DArray sample4;
layout (binding = 8) uniform sampler2DArray sample5;
layout (binding = 9) uniform sampler2DArray sample6;
layout (binding = 10) uniform sampler2DArray sample7;
layout (binding = 11) uniform sampler2DArray sample8;
layout (binding = 12) uniform sampler2DArray sample9;
layout (binding = 13) uniform sampler2DArray sample10;
layout (binding = 14) uniform sampler2DArray sample11;
layout (binding = 15) uniform sampler2DArray sample12;
layout (binding = 16) uniform sampler2DArray sample13;
layout (binding = 17) uniform sampler2DArray sample14;
layout (binding = 18) uniform sampler2DArray sample15;
layout (binding = 19) uniform sampler2DArray sample16;

layout (binding = 20) uniform usampler2D pathing_map_static;
layout (binding = 21) uniform usampler2D pathing_map_dynamic;

layout (location = 0) in vec2 UV;
layout (location = 1) in flat uvec4 texture_indices;
layout (location = 2) in vec2 pathing_map_uv;
layout (location = 3) in vec3 normal;

layout (location = 0) out vec4 color;
layout (location = 1) out vec4 position;

vec4 get_fragment(uint id, vec3 uv) {
	vec2 dx = dFdx(uv.xy);
	vec2 dy = dFdy(uv.xy);

	switch(id) {
		case 0:
			return textureGrad(sample0, uv, dx, dy);
		case 1:
			return textureGrad(sample1, uv, dx, dy);
		case 2:
			return textureGrad(sample2, uv, dx, dy);
		case 3:
			return textureGrad(sample3, uv, dx, dy);
		case 4:
			return textureGrad(sample4, uv, dx, dy);
		case 5:
			return textureGrad(sample5, uv, dx, dy);
		case 6:
			return textureGrad(sample6, uv, dx, dy);
		case 7:
			return textureGrad(sample7, uv, dx, dy);
		case 8:
			return textureGrad(sample8, uv, dx, dy);
		case 9:
			return textureGrad(sample9, uv, dx, dy);
		case 10:
			return textureGrad(sample10, uv, dx, dy);
		case 11:
			return textureGrad(sample11, uv, dx, dy);
		case 12:
			return textureGrad(sample12, uv, dx, dy);
		case 13:
			return textureGrad(sample13, uv, dx, dy);
		case 14:
			return textureGrad(sample14, uv, dx, dy);
		case 15:
			return textureGrad(sample15, uv, dx, dy);
		case 16:
			return textureGrad(sample16, uv, dx, dy);
		case 17:
			return vec4(0, 0, 0, 0);
	}
}


void main() {
	color = get_fragment(texture_indices.a & 31, vec3(UV, texture_indices.a >> 5));
	color = mix(get_fragment(texture_indices.b & 31, vec3(UV, texture_indices.b >> 5)), color, color.a);
	color = mix(get_fragment(texture_indices.g & 31, vec3(UV, texture_indices.g >> 5)), color, color.a);
	color = mix(get_fragment(texture_indices.r & 31, vec3(UV, texture_indices.r >> 5)), color, color.a);

	if (show_lighting) {
		// vec3 light_direction = vec3(-1.f, -1.f, -2.f);
		// light_direction = normalize(light_direction);

		float contribution = (dot(-light_direction, normal) + 1.f) * 0.5f;

		color.rgb *= clamp(contribution, 0.f, 1.f);
	}

	uint byte_static = texelFetch(pathing_map_static, ivec2(pathing_map_uv), 0).r;
	uint byte_dynamic = texelFetch(pathing_map_dynamic, ivec2(pathing_map_uv), 0).r;
	if (show_pathing_map) {
		uint final = byte_static.r | byte_dynamic.r;

		vec4 pathing_static_color = vec4((final & 2) >> 1, (final & 4) >> 2, (final & 8) >> 3, 0.25f);

		color = length(pathing_static_color.rgb) > 0 ? color * 0.75f + pathing_static_color * 0.5f : color;
	}
}
```

`Data/Shaders/terrain.vs`:

```vs
#version 450 core

layout (location = 0) in vec2 vPosition;
layout (location = 1) uniform mat4 MVP;

layout (binding = 0) uniform sampler2D height_texture;
layout (binding = 1) uniform sampler2D height_cliff_texture;
layout (binding = 2) uniform usampler2D terrain_texture_list;
layout (binding = 22) uniform sampler2D terrain_exists_texture;

layout (location = 0) out vec2 UV;
layout (location = 1) out flat uvec4 texture_indices;
layout (location = 2) out vec2 pathing_map_uv;
layout (location = 3) out vec3 normal;

void main() { 
	const ivec2 size = textureSize(terrain_texture_list, 0);
	const ivec2 pos = ivec2(gl_InstanceID % size.x, gl_InstanceID / size.x);

	const ivec2 height_pos = ivec2(vPosition + pos);
	const vec4 height = texelFetch(height_cliff_texture, height_pos, 0);

	const ivec3 offset = ivec3(1, 1, 0);
	const float hL = texelFetch(height_texture, height_pos - offset.xz, 0).r;
	const float hR = texelFetch(height_texture, height_pos + offset.xz, 0).r;
	const float hD = texelFetch(height_texture, height_pos - offset.zy, 0).r;
	const float hU = texelFetch(height_texture, height_pos + offset.zy, 0).r;
	normal = normalize(vec3(hL - hR, hD - hU, 2.0));

	UV = vec2(vPosition.x, 1 - vPosition.y);
	texture_indices = texelFetch(terrain_texture_list, pos, 0);
	pathing_map_uv = (vPosition + pos) * 4;	

	const ivec2 pos2 = ivec2(gl_InstanceID % (size.x + 1), gl_InstanceID / (size.x + 1));
	const bool is_ground = texelFetch(terrain_exists_texture, pos2, 0).r > 0;

	gl_Position = is_ground ? MVP * vec4(vPosition + pos, height.r, 1) : vec4(2.0, 0.0, 0.0, 1.0);
}
```

`Data/Shaders/test.fs`:

```fs
#version 450 core

out vec4 outColor;

void main() {
	outColor = vec4(1.f, 1.f, 1.f, 1.f);
}
```

`Data/Shaders/test.vs`:

```vs
#version 450 core

layout (location = 0) in vec2 vPosition;

void main() { 
	gl_Position = vec4(vPosition, 1.f, 1.f);
}
```

`Data/Shaders/water.fs`:

```fs
#version 450 core

layout (binding = 3) uniform sampler2DArray water_textures;
layout (binding = 2) uniform sampler2D water_exists_texture;


layout (location = 6) uniform int current_texture;

in vec2 UV;
in vec4 Color;

out vec4 outColor;

void main() {
	outColor = texture(water_textures, vec3(UV, current_texture)) * Color;
}
```

`Data/Shaders/water.vs`:

```vs
#version 450 core

layout (location = 0) in vec2 vPosition;

layout (binding = 0) uniform sampler2D water_height_texture;
layout (binding = 1) uniform sampler2D ground_height_texture;
layout (binding = 2) uniform sampler2D water_exists_texture;

layout (location = 0) uniform mat4 MVP;
layout (location = 1) uniform vec4 shallow_color_min;
layout (location = 2) uniform vec4 shallow_color_max;
layout (location = 3) uniform vec4 deep_color_min;
layout (location = 4) uniform vec4 deep_color_max;
layout (location = 5) uniform float water_offset;

out vec2 UV;
out vec4 Color;

const float min_depth = 10.f / 128;
const float deeplevel = 64.f / 128;
const float maxdepth = 72.f / 128;

void main() { 
	ivec2 size = textureSize(water_height_texture, 0) - 1;
	ivec2 pos = ivec2(gl_InstanceID % size.x, gl_InstanceID / size.x);
	ivec2 height_pos = ivec2(vPosition + pos);
	float water_height = texelFetch(water_height_texture, height_pos, 0).r + water_offset;

	bool is_water = texelFetch(water_exists_texture, pos, 0).r > 0
	 || texelFetch(water_exists_texture, pos + ivec2(1, 0), 0).r > 0
	 || texelFetch(water_exists_texture, pos + ivec2(1, 1), 0).r > 0
	 || texelFetch(water_exists_texture, pos + ivec2(0, 1), 0).r > 0;

	gl_Position = is_water ? MVP * vec4(vPosition + pos, water_height, 1) : vec4(2.0, 0.0, 0.0, 1.0);

	UV = vec2(vPosition.x, 1 - vPosition.y);

	float ground_height = texelFetch(ground_height_texture, height_pos, 0).r;
	float value = clamp(water_height - ground_height, 0.f, 1.f);
	if (value <= deeplevel) {
		value = max(0.f, value - min_depth) / (deeplevel - min_depth);
		Color = shallow_color_min * (1.f - value) + shallow_color_max * value;
	} else {
		value = clamp(value - deeplevel, 0.f, maxdepth - deeplevel) / (maxdepth - deeplevel);
		Color = deep_color_min * (1.f - value) + deep_color_max * value;
	}
 }
```

`Data/Test Map/conversation.json`:

```json
{
    "stringTablePath": "war3map.wts",
    "conversation": {}
}
```

`Data/Test Map/war3map.wts`:

```wts
STRING 001
{
Player 1
}

STRING 002
{
Force 1
}


```

`Data/Themes/Dark.qss`:

```qss
/* http://doc.qt.io/qt-5/stylesheet-syntax.html */
/* http://doc.qt.io/qt-5/stylesheet-customizing.html */

/******************************************************/
/* QRibbon */

QRibbon {
	max-height: 121px;
}

QRibbon QWidget {
	font: 8pt "Segoe UI";
	color: white;
}

QWidget#centralWidget {
	background-color: rgb(53, 53, 53);
}

QRibbon::pane {
	border-top: 1px solid rgb(38, 38, 38);
	border-bottom: 1px solid rgb(38, 38, 38);
	margin-top: -1;
	margin-bottom: -0;
}

QRibbon QTabBar::tab { 
	height: 22px;
	background-color: rgb(53, 53, 53);
	border: 1px solid rgb(53, 53, 53);
	border-bottom-width: 0px;

	padding-top: -1px;
	padding-left: 14px;
	padding-right: 14px;
	margin-right: 1px;
}

QRibbon QTabBar::tab::hover {
	background-color: rgb(77, 77, 77);
	border-color: rgb(38, 38, 38);
	height: 23px;
}

QRibbon QTabBar::tab::selected {
	background-color: rgb(67, 67, 67);
	border-color: rgb(38, 38, 38);
	padding-bottom: 2px;
}

/******************************************************/
.QRibbonFileButton {
	border: 1px solid transparent;
	background-color: rgb(38, 109, 132);
	height: 23px;
	color: white;
	padding-left: 14px;
	padding-right: 13px;
	qproperty-popupMode: InstantPopup;
}

QRibbonFileButton::hover {
	background-color: rgb(41, 140, 225);
}

QRibbonFileButton::pressed {
	background-color: rgb(18, 104, 179);
}

QRibbonFileButton::menu-indicator { 
	image: none; 
} 

/******************************************************/
/* QRibbonMenu */
QRibbonMenu {
	color: black;
	background-color: rgb(251, 252, 253);
	border: 1px solid rgb(132, 146, 166);
}

QRibbonMenu QToolButton {
	border: 1px solid transparent;
	background-color: rgb(251, 252, 253);
	height: 44px;
	width: 216px;
	color: black;
}

QRibbonMenu QToolButton::hover {
	border-color: rgb(168, 210, 253);
	background-color: rgb(237, 244, 252);
}

QRibbonMenu QFrame#verticalSeperator {
	border: none;
	max-width: 0px;
	background-color: gray;
	border-left: 1px solid rgb(220, 221, 222);
	border-right: 1px solid rgb(254, 254, 255);
	qproperty-frameShape: VLine;
}

QRibbonMenu QFrame#horizontalSeperator {
	border: none;
	background-color: rgb(220, 221, 222);
	max-height: 1px;
	margin-left: 44px;
	qproperty-frameShape: HLine;
}

/******************************************************/
/* QRibbonTab */
QRibbonTab {
	background-color: rgb(67, 67, 67);
}

QRibbonTab QFrame#seperator {
	border: none;
	max-width: 1px;
	background-color: rgb(38, 38, 38);
	qproperty-frameShape: VLine;
}

/******************************************************/
/* QRibbonContainer */
QRibbonContainer {
	border: 1px solid rgb(38, 38, 38);
	background-color: rgb(42, 42, 42);
}

/******************************************************/
/* QRibbonButton */
QRibbonButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
	qproperty-iconSize: 30px 30px;
	qproperty-toolButtonStyle: ToolButtonTextUnderIcon;
}

QRibbonButton::hover {
	background-color: rgb(85, 85, 85);
}

QRibbonButton::pressed {
	background-color: rgb(100, 100, 100);
}

QRibbonButton::checked {
	background-color: rgb(100, 100, 100);
}

QRibbonButton::checked:hover {
	border: 1px solid rgb(120, 120, 120);
}

QRibbon QLineEdit {
	height: 21px;
	max-width: 50px;
	border: 1px solid rgb(100, 100, 100);
}

QRibbon QLineEdit::hover {
	background-color: rgb(75, 75, 75);
}

QRibbon QLineEdit::focus {
	border: 1px solid rgb(100, 150, 255);
}

QRibbon QLineEdit::disabled {
	background-color: rgb(67, 67, 67);
}

QRibbonButton::menu-indicator {
    top: -3;
}

QRibbonButton QMenu {
	border: 1px solid rgb(100, 100, 100);
}

QRibbonButton QMenu::item {
	height: 28px;
	padding-left: 30px;
    padding-right: 30px;
    margin: 1px;
}

QRibbonButton QMenu::item:selected {
	background-color: rgb(85, 85, 85);
}

QSmallRibbonButton {
	height: 23;
	max-height: 23;
	qproperty-iconSize: 16px 16px;
	qproperty-toolButtonStyle: ToolButtonTextBesideIcon;
}

/******************************************************/
/* Docking */

ads--CDockWidgetTab {
    background: palette(window);
    border-style: solid;
    border-width: 0px 0 0;
    padding: 0;
    qproperty-iconSize: 23px;
}

ads--CDockWidgetTab[activeTab="true"] {
    background: palette(highlight);
    border-color: palette(highlight);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:hover {
	background: rgba(255, 255, 255, 48);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:pressed {
	background: rgba(255, 255, 255, 92);
}

ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid transparent;
	padding-bottom: 0px;
}

ads--CDockAreaWidget[focused="true"] ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid palette(highlight);
	padding-bottom: 0px;
}

QScrollArea#dockWidgetScrollArea {
    padding: 0px;
    border: none;
}

#tabCloseButton {
	margin-top: 2px;
	background: none;
	border: none;
	padding: 0px -2px;
}

#tabCloseButton::hover {
	border: 1px solid rgba(0, 0, 0, 32);
	background: rgba(64, 64, 64, 255);
}

#tabCloseButton::pressed {
	border: 1px solid rgb(98, 162, 228);
	background: rgba(128, 128, 128, 255);
}


/******************************************************/
/* General */

QPushButton {
	border: 1px solid transparent;
}

QPushButton::hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

QPushButton::pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QPushButton::checked {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QDialogButtonBox QPushButton {
	border: 1px solid rgb(100, 100, 100);
	padding: 5;
}

JassEditor QFrame {
	background-color: palette(window);
}

QTableView::indicator {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(60, 60, 60);
}

QTableView::indicator:hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

QTableView::indicator:pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QTableView::indicator:checked{
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
	image: url("Data/Icons/check.png");
}

/******************************************************/
/* Object Editor */

ObjectEditor QLineEdit {
	background-color: rgb(66, 66, 66);
}

IconButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
}

IconButton::hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

IconButton::pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

IconButton::checked {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}
```

`Data/Themes/Light.qss`:

```qss
/* http://doc.qt.io/qt-5/stylesheet-syntax.html */
/* http://doc.qt.io/qt-5/stylesheet-customizing.html */

/******************************************************/
/* QRibbon */

QRibbon {
	max-height: 121px;
}

QRibbon QWidget {
	font: 8pt "Segoe UI";
	color: black;
}

QWidget#centralWidget {
	background-color: white;
}

QRibbon::pane {
	border-top: 1px solid rgb(218, 219, 220);
	border-bottom: 1px solid rgb(218, 219, 220);
	margin-top: -1;
	margin-bottom: -0;
}

QRibbon QTabBar::tab { 
	height: 22px;
	background-color: rgb(255, 255, 255);
	border: 1px solid white;
	border-bottom-width: 0px;

	padding-top: -1px;
	padding-left: 14px;
	padding-right: 14px;
	margin-right: 1px;
}

QRibbon QTabBar::tab::hover {
	background-color: rgb(253, 253, 255);
	border-color: rgb(235, 236, 236);
	height: 23px;
}

QRibbon QTabBar::tab::selected {
	background-color: rgb(245, 246, 247);
	border-color: rgb(218, 219, 220);
	padding-bottom: 2px;
}

/******************************************************/
.QRibbonFileButton {
	border: 1px solid transparent;
	background-color: rgb(25, 121, 202);
	height: 23px;
	color: white;
	padding-left: 14px;
	padding-right: 13px;
	qproperty-popupMode: InstantPopup;
}

QRibbonFileButton::hover {
	background-color: rgb(41, 140, 225);
}

QRibbonFileButton::pressed {
	background-color: rgb(18, 104, 179);
}

QRibbonFileButton::menu-indicator { 
	image: none; 
} 

/******************************************************/
/* QRibbonMenu */
QRibbonMenu {
	color: black;
	background-color: rgb(251, 252, 253);
	border: 1px solid rgb(132, 146, 166);
}

QRibbonMenu QToolButton {
	border: 1px solid transparent;
	background-color: rgb(251, 252, 253);
	height: 44px;
	width: 216px;
	color: black;
}

QRibbonMenu QToolButton::hover {
	border-color: rgb(168, 210, 253);
	background-color: rgb(237, 244, 252);
}

QRibbonMenu QFrame#verticalSeperator {
	border: none;
	max-width: 0px;
	background-color: gray;
	border-left: 1px solid rgb(220, 221, 222);
	border-right: 1px solid rgb(254, 254, 255);
	qproperty-frameShape: VLine;
}

QRibbonMenu QFrame#horizontalSeperator {
	border: none;
	background-color: rgb(220, 221, 222);
	max-height: 1px;
	margin-left: 44px;
	qproperty-frameShape: HLine;
}

/******************************************************/
/* QRibbonTab */
QRibbonTab {
	background-color: rgb(245, 246, 247);
}

QRibbonTab QFrame#seperator {
	border: none;
	max-width: 1px;
	background-color: rgb(226, 227, 228);
	qproperty-frameShape: VLine;
}

/******************************************************/
/* QRibbonContainer */
QRibbonContainer {
	border: 1px solid rgb(219, 220, 221);
	background-color: rgb(250, 251, 252);
}

/******************************************************/
/* QRibbonButton */
QRibbonButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
	qproperty-iconSize: 30px 30px;
	qproperty-toolButtonStyle: ToolButtonTextUnderIcon;
}

QRibbonButton::hover {
	background-color: rgb(232, 239, 247);
}

QRibbonButton::pressed {
	background-color: rgb(201, 224, 247);
}

QRibbonButton::checked {
	background-color: rgb(201, 224, 247);
}

QRibbonButton::checked:hover {
	border: 1px solid rgb(120, 120, 120);
}

QRibbon QLineEdit {
	height: 21px;
	max-width: 50px;
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(255, 255, 255);
	color: rgb(0, 0, 0);
}

QRibbon QLineEdit::hover {
	/*background-color: rgb(75, 75, 75);*/
}

QRibbon QLineEdit::focus {
	/*border: 1px solid rgb(100, 150, 255);*/
}

QRibbon QLineEdit::disabled {
	/*background-color: rgb(67, 67, 67);*/
}

QRibbonButton::menu-indicator {
    top: -3;
}

QRibbonButton QMenu {
	/*border: 1px solid rgb(100, 100, 100);*/
}

QRibbonButton QMenu::item {
	height: 28px;
	padding-left: 30px;
    padding-right: 30px;
    margin: 1px;
}

QRibbonButton QMenu::item:selected {
	background-color: rgb(85, 85, 85);
}

QSmallRibbonButton {
	height: 23;
	max-height: 23;
	qproperty-iconSize: 16px 16px;
	qproperty-toolButtonStyle: ToolButtonTextBesideIcon;
}

/******************************************************/
/* Docking */

ads--CDockWidgetTab {
    background: palette(window);
    border-style: solid;
    border-width: 0px 0 0;
    padding: 0 0px;

}

ads--CDockWidgetTab[activeTab="true"] {
    background: palette(highlight);
    border-color: palette(highlight);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:hover {
	background: rgba(255, 255, 255, 48);
}

ads--CDockWidgetTab[focused="true"]>#tabCloseButton:pressed {
	background: rgba(255, 255, 255, 92);
}

ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid transparent;
	padding-bottom: 0px;
}

ads--CDockAreaWidget[focused="true"] ads--CDockAreaTitleBar {
	background: transparent;
	border-bottom: 2px solid palette(highlight);
	padding-bottom: 0px;
}

QScrollArea#dockWidgetScrollArea {
    padding: 0px;
    border: none;
}

#tabCloseButton {
	margin-top: 2px;
	background: none;
	border: none;
	padding: 0px -2px;
}

#tabCloseButton:hover {
	border: 1px solid rgb(164, 206, 249);
	background-color: rgb(232, 239, 247);
}

#tabCloseButton:pressed {
	border: 1px solid rgb(98, 162, 228);
	background-color: rgb(201, 224, 247);
}


/******************************************************/
/* General */

QPushButton {
	border: 1px solid transparent;
}

QPushButton::hover {
	border: 1px solid rgb(164, 206, 249);
	background-color: rgb(232, 239, 247);
}

QPushButton::pressed {
	border: 1px solid rgb(98, 162, 228);
	background-color: rgb(201, 224, 247);
}

QPushButton::checked {
	border: 1px solid rgb(98, 162, 228);
	background-color: rgb(201, 224, 247);
}

QDialogButtonBox QPushButton {
	border: 1px solid rgb(100, 100, 100);
	padding: 5;
}

JassEditor QFrame {
	background-color: palette(window);
}

QTableView::indicator {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(60, 60, 60);
}

QTableView::indicator:hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

QTableView::indicator:pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

QTableView::indicator:checked{
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
	image: url("Data/Icons/check.png");
}

/******************************************************/
/* Object Editor */

ObjectEditor QLineEdit {
	background-color: rgb(66, 66, 66);
}

IconButton {
	border: 1px solid transparent;
	padding-left: 3px;
	padding-right: 2px;
}

IconButton::hover {
	border: 1px solid rgb(100, 100, 100);
	background-color: rgb(85, 85, 85);
}

IconButton::pressed {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}

IconButton::checked {
	border: 1px solid rgb(120, 120, 120);
	background-color: rgb(100, 100, 100);
}
```

`Data/Tools/jasshelper.conf`:

```conf
[lookupfolders]
// Just type the folders where //! import would look for if relative paths where used, include the final \
// embed them in quotes
// example: "c:\"
// The order determines priority:
".\jass\"

[jasscompiler]
//this is to specify what compiler to use, normally pjass.exe, you may also want to use JassParserCLI.exe ...
"pjass.exe"
//the following line specifies the way the jass syntax checker's arguments are used ...
"$COMMONJ $BLIZZARDJ $WAR3MAPJ"

[externaltools]
// this is for //! external NAME args the syntax is "NAME","executable path"
// example:
//"OBJMERGE","c:\kool.exe"

//To enable automatic .evaluate of methods that are called from above their declaration
// add a line containing: [automethodevaluate]
//this is enabled by default, to disable it
// add a line containing: [forcemethodevaluate]
//To disable the "implicit this" feature that was added in 0.A.0.0
// add a line containing: [noimplicitthis]

```

`Data/Warcraft/CityCliffs.slk`:

```slk
ID;PWXL;N;E
B;Y65;X2;
C;Y1;X1;K"cliffID"
C;X2;K"variations"
C;Y2;X1;K"AAAB"
C;X2;K2
C;Y3;X1;K"AAAC"
C;X2;K1
C;Y4;X1;K"AABA"
C;X2;K1
C;Y5;X1;K"AABB"
C;X2;K3
C;Y6;X1;K"AABC"
C;X2;K0
C;Y7;X1;K"AACA"
C;X2;K1
C;Y8;X1;K"AACB"
C;X2;K0
C;Y9;X1;K"AACC"
C;X2;K3
C;Y10;X1;K"ABAA"
C;X2;K1
C;Y11;X1;K"ABAB"
C;X2;K2
C;Y12;X1;K"ABAC"
C;X2;K0
C;Y13;X1;K"ABBA"
C;X2;K3
C;Y14;X1;K"ABBB"
C;X2;K0
C;Y15;X1;K"ABBC"
C;X2;K0
C;Y16;X1;K"ABCA"
C;X2;K0
C;Y17;X1;K"ABCB"
C;X2;K0
C;Y18;X1;K"ABCC"
C;X2;K0
C;Y19;X1;K"ACAA"
C;X2;K1
C;Y20;X1;K"ACAB"
C;X2;K0
C;Y21;X1;K"ACAC"
C;X2;K2
C;Y22;X1;K"ACBA"
C;X2;K0
C;Y23;X1;K"ACBB"
C;X2;K0
C;Y24;X1;K"ACBC"
C;X2;K0
C;Y25;X1;K"ACCA"
C;X2;K3
C;Y26;X1;K"ACCB"
C;X2;K0
C;Y27;X1;K"ACCC"
C;X2;K1
C;Y28;X1;K"BAAA"
C;X2;K1
C;Y29;X1;K"BAAB"
C;X2;K3
C;Y30;X1;K"BAAC"
C;X2;K0
C;Y31;X1;K"BABA"
C;X2;K2
C;Y32;X1;K"BABB"
C;X2;K0
C;Y33;X1;K"BABC"
C;X2;K0
C;Y34;X1;K"BACA"
C;X2;K0
C;Y35;X1;K"BACB"
C;X2;K0
C;Y36;X1;K"BACC"
C;X2;K0
C;Y37;X1;K"BBAA"
C;X2;K3
C;Y38;X1;K"BBAB"
C;X2;K1
C;Y39;X1;K"BBAC"
C;X2;K0
C;Y40;X1;K"BBBA"
C;X2;K1
C;Y41;X1;K"BBCA"
C;X2;K0
C;Y42;X1;K"BCAA"
C;X2;K0
C;Y43;X1;K"BCAB"
C;X2;K0
C;Y44;X1;K"BCAC"
C;X2;K0
C;Y45;X1;K"BCBA"
C;X2;K0
C;Y46;X1;K"BCCA"
C;X2;K0
C;Y47;X1;K"CAAA"
C;X2;K1
C;Y48;X1;K"CAAB"
C;X2;K0
C;Y49;X1;K"CAAC"
C;X2;K3
C;Y50;X1;K"CABA"
C;X2;K0
C;Y51;X1;K"CABB"
C;X2;K0
C;Y52;X1;K"CABC"
C;X2;K0
C;Y53;X1;K"CACA"
C;X2;K2
C;Y54;X1;K"CACB"
C;X2;K0
C;Y55;X1;K"CACC"
C;X2;K1
C;Y56;X1;K"CBAA"
C;X2;K0
C;Y57;X1;K"CBAB"
C;X2;K0
C;Y58;X1;K"CBAC"
C;X2;K0
C;Y59;X1;K"CBBA"
C;X2;K0
C;Y60;X1;K"CBCA"
C;X2;K0
C;Y61;X1;K"CCAA"
C;X2;K3
C;Y62;X1;K"CCAB"
C;X2;K0
C;Y63;X1;K"CCAC"
C;X2;K1
C;Y64;X1;K"CCBA"
C;X2;K0
C;Y65;X1;K"CCCA"
C;X2;K1
E

```

`Data/Warcraft/Cliffs.slk`:

```slk
ID;PWXL;N;E
B;Y65;X2;
C;Y1;X1;K"cliffID"
C;X2;K"variations"
C;Y2;X1;K"AAAB"
C;X2;K1
C;Y3;X1;K"AAAC"
C;X2;K1
C;Y4;X1;K"AABA"
C;X2;K1
C;Y5;X1;K"AABB"
C;X2;K2
C;Y6;X1;K"AABC"
C;X2;K0
C;Y7;X1;K"AACA"
C;X2;K1
C;Y8;X1;K"AACB"
C;X2;K0
C;Y9;X1;K"AACC"
C;X2;K1
C;Y10;X1;K"ABAA"
C;X2;K1
C;Y11;X1;K"ABAB"
C;X2;K1
C;Y12;X1;K"ABAC"
C;X2;K0
C;Y13;X1;K"ABBA"
C;X2;K2
C;Y14;X1;K"ABBB"
C;X2;K1
C;Y15;X1;K"ABBC"
C;X2;K0
C;Y16;X1;K"ABCA"
C;X2;K0
C;Y17;X1;K"ABCB"
C;X2;K0
C;Y18;X1;K"ABCC"
C;X2;K0
C;Y19;X1;K"ACAA"
C;X2;K1
C;Y20;X1;K"ACAB"
C;X2;K0
C;Y21;X1;K"ACAC"
C;X2;K1
C;Y22;X1;K"ACBA"
C;X2;K0
C;Y23;X1;K"ACBB"
C;X2;K0
C;Y24;X1;K"ACBC"
C;X2;K0
C;Y25;X1;K"ACCA"
C;X2;K1
C;Y26;X1;K"ACCB"
C;X2;K0
C;Y27;X1;K"ACCC"
C;X2;K1
C;Y28;X1;K"BAAA"
C;X2;K1
C;Y29;X1;K"BAAB"
C;X2;K1
C;Y30;X1;K"BAAC"
C;X2;K0
C;Y31;X1;K"BABA"
C;X2;K1
C;Y32;X1;K"BABB"
C;X2;K1
C;Y33;X1;K"BABC"
C;X2;K0
C;Y34;X1;K"BACA"
C;X2;K0
C;Y35;X1;K"BACB"
C;X2;K0
C;Y36;X1;K"BACC"
C;X2;K0
C;Y37;X1;K"BBAA"
C;X2;K1
C;Y38;X1;K"BBAB"
C;X2;K1
C;Y39;X1;K"BBAC"
C;X2;K0
C;Y40;X1;K"BBBA"
C;X2;K1
C;Y41;X1;K"BBCA"
C;X2;K0
C;Y42;X1;K"BCAA"
C;X2;K0
C;Y43;X1;K"BCAB"
C;X2;K0
C;Y44;X1;K"BCAC"
C;X2;K0
C;Y45;X1;K"BCBA"
C;X2;K0
C;Y46;X1;K"BCCA"
C;X2;K0
C;Y47;X1;K"CAAA"
C;X2;K1
C;Y48;X1;K"CAAB"
C;X2;K0
C;Y49;X1;K"CAAC"
C;X2;K1
C;Y50;X1;K"CABA"
C;X2;K0
C;Y51;X1;K"CABB"
C;X2;K0
C;Y52;X1;K"CABC"
C;X2;K0
C;Y53;X1;K"CACA"
C;X2;K1
C;Y54;X1;K"CACB"
C;X2;K0
C;Y55;X1;K"CACC"
C;X2;K1
C;Y56;X1;K"CBAA"
C;X2;K0
C;Y57;X1;K"CBAB"
C;X2;K0
C;Y58;X1;K"CBAC"
C;X2;K0
C;Y59;X1;K"CBBA"
C;X2;K0
C;Y60;X1;K"CBCA"
C;X2;K0
C;Y61;X1;K"CCAA"
C;X2;K1
C;Y62;X1;K"CCAB"
C;X2;K0
C;Y63;X1;K"CCAC"
C;X2;K1
C;Y64;X1;K"CCBA"
C;X2;K0
C;Y65;X1;K"CCCA"
C;X2;K1
E

```

`Data/Warcraft/DestructableSkin.txt`:

```txt
[Ytsc]
skinType=destructable
numVar=10
skinnableID=Ytsc
colorB=255
Name=WESTRING_DEST_SCORCHED_TREE_WALL
colorG=255
selcircsize=128
armor=Wood
colorR=255
deathSnd=TreeWallDeath
maxScale=1.2
texID=34
texFile=ReplaceableTextures\NorthrendTree\NorthTree
file=Doodads\Terrain\NorthrendTree\NorthrendTree
texFile:hd=ReplaceableTextures\ScorchedTree\ScorchedTree
file:hd=Doodads\Terrain\ScorchedTree\ScorchedTree
selSize=0
canPlaceRandScale=1
lightweight=1
lightweight:hd=0
fixedRot=270
minScale=0.8
shadow=ShadowCityTree
```

`Data/Warcraft/ItemMetaData.slk`:

```slk
ID;PWXL;N;E
B;Y43;X23;D0 0 42 22
C;Y1;X1;K"ID"
C;X2;K"field"
C;X3;K"slk"
C;X4;K"index"
C;X5;K"category"
C;X6;K"displayName"
C;X7;K"sort"
C;X8;K"type"
C;X9;K"changeFlags"
C;X10;K"importType"
C;X11;K"stringExt"
C;X12;K"caseSens"
C;X13;K"canBeEmpty"
C;X14;K"minVal"
C;X15;K"maxVal"
C;X16;K"forceNonNeg"
C;X17;K"useHero"
C;X18;K"useUnit"
C;X19;K"useBuilding"
C;X20;K"useItem"
C;X21;K"useSpecific"
C;X22;K"version"
C;X23;K"section"
C;Y2;X1;K"iabi"
C;X2;K"abilList"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_IABI"
C;X7;K"c6c00"
C;X8;K"abilityList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K4
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y3;X1;K"iarm"
C;X2;K"armor"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_IARM"
C;X7;K"c5b03"
C;X8;K"armorType"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y4;X1;K"icla"
C;X2;K"class"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ICLA"
C;X7;K"c1a03"
C;X8;K"itemClass"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y5;X1;K"iclb"
C;X2;K"colorB"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ICLB"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y6;X1;K"iclg"
C;X2;K"colorG"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ICLG"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y7;X1;K"iclr"
C;X2;K"colorR"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ICLR"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y8;X1;K"icid"
C;X2;K"cooldownID"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ICID"
C;X7;K"c6c01"
C;X8;K"abilCode"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y9;X1;K"idrp"
C;X2;K"drop"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IDRP"
C;X7;K"c9a06"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y10;X1;K"idro"
C;X2;K"droppable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IDRO"
C;X7;K"c9a05"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y11;X1;K"ifil"
C;X2;K"file"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_IFIL"
C;X7;K"c1a01"
C;X8;K"model"
C;X9;K"m"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y12;X1;K"igol"
C;X2;K"goldcost"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IGOL"
C;X7;K"c2a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y13;X1;K"ihtp"
C;X2;K"HP"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IHTP"
C;X7;K"c3a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K500000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y14;X1;K"iicd"
C;X2;K"ignoreCD"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IICD"
C;X7;K"c5a000"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y15;X1;K"ilev"
C;X2;K"Level"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ILEV"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K8
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y16;X1;K"ilum"
C;X2;K"lumbercost"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ILUM"
C;X7;K"c2a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y17;X1;K"imor"
C;X2;K"morph"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IMOR"
C;X7;K"c9a07"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y18;X1;K"ilvo"
C;X2;K"oldLevel"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ILVO"
C;X7;K"c1a04a"
C;X8;K"int"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y19;X1;K"iper"
C;X2;K"perishable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPER"
C;X7;K"c9a04"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y20;X1;K"iprn"
C;X2;K"pickRandom"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPRN"
C;X7;K"c9a05"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y21;X1;K"ipow"
C;X2;K"powerup"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPOW"
C;X7;K"c9a06"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y22;X1;K"ipri"
C;X2;K"prio"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPRI"
C;X7;K"c4a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y23;X1;K"isca"
C;X2;K"scale"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ISCA"
C;X7;K"c1a03"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K10
C;X16;K1
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y24;X1;K"issc"
C;X2;K"selSize"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ISSC"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y25;X1;K"isel"
C;X2;K"sellable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISEL"
C;X7;K"c6c02"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y26;X1;K"ipaw"
C;X2;K"pawnable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IPAW"
C;X7;K"c6c02a"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y27;X1;K"isto"
C;X2;K"stockMax"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISTO"
C;X7;K"c9a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y28;X1;K"istr"
C;X2;K"stockRegen"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISTR"
C;X7;K"c9a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y29;X1;K"isst"
C;X2;K"stockStart"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISST"
C;X7;K"c9a000"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y30;X1;K"isit"
C;X2;K"stockInitial"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISIT"
C;X7;K"c9a000"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K1
C;Y31;X1;K"iusa"
C;X2;K"usable"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IUSA"
C;X7;K"c9a03"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y32;X1;K"iuse"
C;X2;K"uses"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_IUSE"
C;X7;K"c9a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y33;X1;K"ista"
C;X2;K"stackMax"
C;X3;K"ItemData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ISTA"
C;X7;K"c9a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y34;X1;K"iico"
C;X2;K"Art"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_IICO"
C;X7;K"c1a02"
C;X8;K"icon"
C;X9;K"i"
C;X10;K"Image"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K0
C;X20;K1
C;X22;K0
C;Y35;X1;K"ides"
C;X2;K"Description"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_IDES"
C;X7;K"d0a05"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y36;X1;K"ubpx"
C;X2;K"Buttonpos"
C;X3;K"Profile"
C;X4;K0
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03x"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y37;X1;K"ubpy"
C;X2;K"Buttonpos2"
C;X3;K"Profile"
C;X4;K0
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03y"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y38;X1;K"ureq"
C;X2;K"Requires"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UREQ"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y39;X1;K"urqa"
C;X2;K"Requiresamount"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQA"
C;X7;K"c5a00a"
C;X8;K"intList"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y40;X1;K"uhot"
C;X2;K"Hotkey"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UHOT"
C;X7;K"d0a01"
C;X8;K"char"
C;X11;K1
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y41;X1;K"unam"
C;X2;K"Name"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UNAM"
C;X7;K"c1a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K"TTName"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y42;X1;K"utip"
C;X2;K"Tip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTIP"
C;X7;K"d0a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y43;X1;K"utub"
C;X2;K"Ubertip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTUB"
C;X7;K"d0a03"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTUber"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
E

```

`Data/Warcraft/UnitMetaData.slk`:

```slk
ID;PWXL;N;E
B;Y240;X23;D0 0 239 22
F;W2 2 18
C;Y1;X1;K"ID"
C;X2;K"field"
C;X3;K"slk"
C;X4;K"index"
C;X5;K"category"
C;X6;K"displayName"
C;X7;K"sort"
C;X8;K"type"
C;X9;K"changeFlags"
C;X10;K"importType"
C;X11;K"stringExt"
C;X12;K"caseSens"
C;X13;K"canBeEmpty"
C;X14;K"minVal"
C;X15;K"maxVal"
C;X16;K"forceNonNeg"
C;X17;K"useHero"
C;X18;K"useUnit"
C;X19;K"useBuilding"
C;X20;K"useItem"
C;X21;K"useSpecific"
C;X22;K"version"
C;X23;K"section"
C;Y2;X1;K"uani"
C;X2;K"animProps"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UANI"
C;X7;K"c1a010"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y3;X1;K"uico"
C;X2;K"Art"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UICO"
C;X7;K"c1a02"
C;X8;K"icon"
C;X9;K"i"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y4;X1;K"uaap"
C;X2;K"Attachmentanimprops"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UAAP"
C;X7;K"c1a010a"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y5;X1;K"ualp"
C;X2;K"Attachmentlinkprops"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UALP"
C;X7;K"c1a010b"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y6;X1;K"uawt"
C;X2;K"Awakentip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UAWT"
C;X7;K"d0a02a"
C;X8;K"string"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y7;X1;K"ubpr"
C;X2;K"Boneprops"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPR"
C;X7;K"c1a010c"
C;X8;K"stringList"
C;X11;K0
C;X12;K0
C;X13;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y8;X1;K"ubsl"
C;X2;K"BuildingSoundLabel"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_UBSL"
C;X7;K"d8b00"
C;X8;K"soundLabel"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y9;X1;K"ubui"
C;X2;K"Builds"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UBUI"
C;X7;K"c5a010"
C;X8;K"unitList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y10;X1;K"ubpx"
C;X2;K"Buttonpos"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03x"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y11;X1;K"ubpy"
C;X2;K"Buttonpos2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBPX"
C;X7;K"c2a03y"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y12;X1;K"ucua"
C;X2;K"Casterupgradeart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCUA"
C;X7;K"c6c03"
C;X8;K"icon"
C;X10;K"Image"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y13;X1;K"ucun"
C;X2;K"Casterupgradename"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UCUN"
C;X7;K"c6c01"
C;X8;K"stringList"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K32
C;X16;K0
C;X17;K0
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y14;X1;K"ucut"
C;X2;K"Casterupgradetip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UCUT"
C;X7;K"c6c02"
C;X8;K"stringList"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K0
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y15;X1;K"udep"
C;X2;K"DependencyOr"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UDEP"
C;X7;K"c5a00a"
C;X8;K"unitList"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y16;X1;K"unsf"
C;X2;K"EditorSuffix"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UNSF"
C;X7;K"c1a000"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K50
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y17;X1;K"uhot"
C;X2;K"Hotkey"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UHOT"
C;X7;K"d0a01"
C;X8;K"char"
C;X11;K1
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y18;X1;K"ulfi"
C;X2;K"LoopingSoundFadeIn"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_ULFI"
C;X7;K"d8b03"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K1
C;X14;K0
C;X15;K12700
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y19;X1;K"ulfo"
C;X2;K"LoopingSoundFadeOut"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_ULFO"
C;X7;K"d8b04"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K1
C;X14;K0
C;X15;K12700
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y20;X1;K"umki"
C;X2;K"Makeitems"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UMKI"
C;X7;K"c5a05a"
C;X8;K"itemList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y21;X1;K"uma1"
C;X2;K"Missilearc"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMA1"
C;X7;K"c6a06a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y22;X1;K"uma2"
C;X2;K"Missilearc2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMA2"
C;X7;K"c6b06a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y23;X1;K"ua1m"
C;X2;K"Missileart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1M"
C;X7;K"c6a05"
C;X8;K"model"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y24;X1;K"ua2m"
C;X2;K"Missileart2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2M"
C;X7;K"c6b05"
C;X8;K"model"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y25;X1;K"umh1"
C;X2;K"MissileHoming"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMH1"
C;X7;K"c6a06b"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y26;X1;K"umh2"
C;X2;K"MissileHoming2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UMH2"
C;X7;K"c6b06b"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y27;X1;K"ua1z"
C;X2;K"Missilespeed"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1Z"
C;X7;K"c6a06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y28;X1;K"ua2z"
C;X2;K"Missilespeed2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2Z"
C;X7;K"c6b06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y29;X1;K"umsl"
C;X2;K"MovementSoundLabel"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_UMSL"
C;X7;K"d8b01"
C;X8;K"soundLabel"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y30;X1;K"unam"
C;X2;K"Name"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UNAM"
C;X7;K"c1a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K"TTName"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y31;X1;K"upro"
C;X2;K"Propernames"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UPRO"
C;X7;K"c1a001"
C;X8;K"stringList"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K0
C;X15;K32
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y32;X1;K"ursl"
C;X2;K"RandomSoundLabel"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_URSL"
C;X7;K"d8b02"
C;X8;K"soundLabel"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y33;X1;K"urqc"
C;X2;K"Requirescount"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQC"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K1
C;X15;K9
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y34;X1;K"ureq"
C;X2;K"Requires"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UREQ"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y35;X1;K"urq1"
C;X2;K"Requires1"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ1"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y36;X1;K"urq2"
C;X2;K"Requires2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ2"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y37;X1;K"urq3"
C;X2;K"Requires3"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ3"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y38;X1;K"urq4"
C;X2;K"Requires4"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ4"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y39;X1;K"urq5"
C;X2;K"Requires5"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ5"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y40;X1;K"urq6"
C;X2;K"Requires6"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ6"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y41;X1;K"urq7"
C;X2;K"Requires7"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ7"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y42;X1;K"urq8"
C;X2;K"Requires8"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQ8"
C;X7;K"c5a00"
C;X8;K"techList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y43;X1;K"urqa"
C;X2;K"Requiresamount"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URQA"
C;X7;K"c5a00a"
C;X8;K"intList"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K1
C;Y44;X1;K"ures"
C;X2;K"Researches"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URES"
C;X7;K"c5a03"
C;X8;K"upgradeList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y45;X1;K"urev"
C;X2;K"Revive"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UREV"
C;X7;K"c5a000"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y46;X1;K"utpr"
C;X2;K"Revivetip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTPR"
C;X7;K"d0a02"
C;X8;K"string"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y47;X1;K"ussi"
C;X2;K"ScoreScreenIcon"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USSI"
C;X7;K"c1a02a"
C;X8;K"icon"
C;X10;K"Image"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y48;X1;K"usei"
C;X2;K"Sellitems"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_USEI"
C;X7;K"c5a05"
C;X8;K"itemList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y49;X1;K"useu"
C;X2;K"Sellunits"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_USEU"
C;X7;K"c5a04"
C;X8;K"unitList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y50;X1;K"uspa"
C;X2;K"Specialart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USPA"
C;X7;K"d9b00"
C;X8;K"modelList"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y51;X1;K"utaa"
C;X2;K"Targetart"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UTAA"
C;X7;K"d9b01"
C;X8;K"modelList"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y52;X1;K"utip"
C;X2;K"Tip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTIP"
C;X7;K"d0a00"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y53;X1;K"utra"
C;X2;K"Trains"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UTRA"
C;X7;K"c5a01"
C;X8;K"unitList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y54;X1;K"urva"
C;X2;K"Reviveat"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_URVA"
C;X7;K"c5a01"
C;X8;K"unitList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y55;X1;K"utub"
C;X2;K"Ubertip"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UTUB"
C;X7;K"d0a03"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTUber"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
C;Y56;X1;K"uupt"
C;X2;K"Upgrade"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UUPT"
C;X7;K"c5a000"
C;X8;K"unitList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K12
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y57;X1;K"uabi"
C;X2;K"abilList"
C;X3;K"UnitAbilities"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UABI"
C;X7;K"c6c00"
C;X8;K"abilityList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y58;X1;K"udaa"
C;X2;K"auto"
C;X3;K"UnitAbilities"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UDAA"
C;X7;K"c6c01"
C;X8;K"abilCode"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y59;X1;K"uhab"
C;X2;K"heroAbilList"
C;X3;K"UnitAbilities"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UHAB"
C;X7;K"c6c00"
C;X8;K"heroAbilityList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X15;K5
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y60;X1;K"uagi"
C;X2;K"AGI"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UAGI"
C;X7;K"c3a05"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y61;X1;K"uagp"
C;X2;K"AGIplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UAGP"
C;X7;K"c3a06"
C;X8;K"unreal"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y62;X1;K"ubld"
C;X2;K"bldtm"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBLD"
C;X7;K"c2a06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K298
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y63;X1;K"ubdi"
C;X2;K"bountydice"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBDI"
C;X7;K"c8a08"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y64;X1;K"ubba"
C;X2;K"bountyplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBBA"
C;X7;K"c8a07"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y65;X1;K"ubsi"
C;X2;K"bountysides"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBSI"
C;X7;K"c8a09"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y66;X1;K"ulbd"
C;X2;K"lumberbountydice"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULBD"
C;X7;K"c8a10"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y67;X1;K"ulba"
C;X2;K"lumberbountyplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULBA"
C;X7;K"c8a11"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y68;X1;K"ulbs"
C;X2;K"lumberbountysides"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULBS"
C;X7;K"c8a12"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y69;X1;K"ucol"
C;X2;K"collision"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UCOL"
C;X7;K"c1a07"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1024
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y70;X1;K"udef"
C;X2;K"def"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDEF"
C;X7;K"c5b00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y71;X1;K"udty"
C;X2;K"defType"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDTY"
C;X7;K"c5b02"
C;X8;K"defenseType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y72;X1;K"udup"
C;X2;K"defUp"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDUP"
C;X7;K"c5b01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y73;X1;K"ufma"
C;X2;K"fmade"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFMA"
C;X7;K"c2a030"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K300
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y74;X1;K"ufoo"
C;X2;K"fused"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFOO"
C;X7;K"c2a03"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K300
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y75;X1;K"ugol"
C;X2;K"goldcost"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UGOL"
C;X7;K"c2a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y76;X1;K"ugor"
C;X2;K"goldRep"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UGOR"
C;X7;K"c2a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y77;X1;K"uhpm"
C;X2;K"HP"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHPM"
C;X7;K"c4a00"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K500000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y78;X1;K"uint"
C;X2;K"INT"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UINT"
C;X7;K"c3a03"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y79;X1;K"uinp"
C;X2;K"INTplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UINP"
C;X7;K"c3a04"
C;X8;K"unreal"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y80;X1;K"ubdg"
C;X2;K"isbldg"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UBDG"
C;X7;K"c1a001a"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y81;X1;K"ulev"
C;X2;K"level"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULEV"
C;X7;K"c8a04"
C;X8;K"int"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y82;X1;K"ulum"
C;X2;K"lumbercost"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULUM"
C;X7;K"c2a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y83;X1;K"ulur"
C;X2;K"lumberRep"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_ULUR"
C;X7;K"c2a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y84;X1;K"umpi"
C;X2;K"mana0"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UMPI"
C;X7;K"c4a05"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y85;X1;K"umpm"
C;X2;K"manaN"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UMPM"
C;X7;K"c4a03"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y86;X1;K"umas"
C;X2;K"maxSpd"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMAS"
C;X7;K"c7a03b"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K522
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y87;X1;K"umis"
C;X2;K"minSpd"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMIS"
C;X7;K"c7a03a"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K522
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y88;X1;K"unbr"
C;X2;K"nbrandom"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UNBR"
C;X7;K"c1c00"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y89;X1;K"usin"
C;X2;K"nsight"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USIN"
C;X7;K"c8a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1800
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y90;X1;K"upap"
C;X2;K"preventPlace"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAP"
C;X7;K"c1a09a"
C;X8;K"pathingListPrevent"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y91;X1;K"upra"
C;X2;K"Primary"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UPRA"
C;X7;K"c3a00"
C;X8;K"attributeType"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y92;X1;K"uhpr"
C;X2;K"regenHP"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHPR"
C;X7;K"c4a01"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y93;X1;K"umpr"
C;X2;K"regenMana"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UMPR"
C;X7;K"c4a04"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y94;X1;K"uhrt"
C;X2;K"regenType"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHRT"
C;X7;K"c4a02"
C;X8;K"regenType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y95;X1;K"urtm"
C;X2;K"reptm"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_URTM"
C;X7;K"c2a07"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y96;X1;K"urpo"
C;X2;K"repulse"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPO"
C;X7;K"d7b00"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y97;X1;K"urpg"
C;X2;K"repulseGroup"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPG"
C;X7;K"d7b02"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K1024
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y98;X1;K"urpp"
C;X2;K"repulseParam"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPP"
C;X7;K"d7b01"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K4
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y99;X1;K"urpr"
C;X2;K"repulsePrio"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_URPR"
C;X7;K"d7b03"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K1
C;Y100;X1;K"upar"
C;X2;K"requirePlace"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAR"
C;X7;K"c1a09b"
C;X8;K"pathingListRequire"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y101;X1;K"usid"
C;X2;K"sight"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USID"
C;X7;K"c8a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1800
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y102;X1;K"umvs"
C;X2;K"spd"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVS"
C;X7;K"c7a03"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K522
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y103;X1;K"usma"
C;X2;K"stockMax"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USMA"
C;X7;K"c9a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K32
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y104;X1;K"usrg"
C;X2;K"stockRegen"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USRG"
C;X7;K"c9a01"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y105;X1;K"usst"
C;X2;K"stockStart"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USST"
C;X7;K"c9a000"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y106;X1;K"usit"
C;X2;K"stockInitial"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USIT"
C;X7;K"c9a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K32
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y107;X1;K"ustr"
C;X2;K"STR"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USTR"
C;X7;K"c3a01"
C;X8;K"int"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y108;X1;K"ustp"
C;X2;K"STRplus"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USTP"
C;X7;K"c3a02"
C;X8;K"unreal"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K0
C;Y109;X1;K"util"
C;X2;K"tilesets"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UTIL"
C;X7;K"c1a06c"
C;X8;K"tilesetList"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y110;X1;K"utyp"
C;X2;K"type"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UTYP"
C;X7;K"c2a04"
C;X8;K"unitClass"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y111;X1;K"upgr"
C;X2;K"upgrades"
C;X3;K"UnitBalance"
C;X4;K-1
C;X5;K"tech"
C;X6;K"WESTRING_UEVAL_UPGR"
C;X7;K"c5a02"
C;X8;K"upgradeList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y112;X1;K"uabr"
C;X2;K"buffRadius"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UABR"
C;X7;K"d4b01"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K24
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y113;X1;K"uabt"
C;X2;K"buffType"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UABT"
C;X7;K"d4b00"
C;X8;K"aiBuffer"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y114;X1;K"ucbo"
C;X2;K"canBuildOn"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UCBO"
C;X7;K"c7a07"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y115;X1;K"ufle"
C;X2;K"canFlee"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFLE"
C;X7;K"c8a031"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y116;X1;K"usle"
C;X2;K"canSleep"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_USLE"
C;X7;K"c8a030"
C;X8;K"bool"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y117;X1;K"ucar"
C;X2;K"cargoSize"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UCAR"
C;X7;K"c8a03"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K8
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y118;X1;K"udtm"
C;X2;K"death"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UDTM"
C;X7;K"c1b10"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0.1
C;X15;K20
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y119;X1;K"udea"
C;X2;K"deathType"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDEA"
C;X7;K"c1b09"
C;X8;K"deathType"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y120;X1;K"ulos"
C;X2;K"fatLOS"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULOS"
C;X7;K"d3b00"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y121;X1;K"ufor"
C;X2;K"formation"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UFOR"
C;X7;K"c7a05"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K9
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K0
C;X20;K0
C;X22;K0
C;Y122;X1;K"uibo"
C;X2;K"isBuildOn"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UIBO"
C;X7;K"c7a06"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y123;X1;K"umvf"
C;X2;K"moveFloor"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVF"
C;X7;K"c7a02a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y124;X1;K"umvh"
C;X2;K"moveHeight"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVH"
C;X7;K"c7a02"
C;X8;K"unreal"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y125;X1;K"umvt"
C;X2;K"movetp"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVT"
C;X7;K"c7a01"
C;X8;K"moveType"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y126;X1;K"upru"
C;X2;K"nameCount"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_UPRU"
C;X7;K"c1a001a"
C;X8;K"int"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y127;X1;K"uori"
C;X2;K"orientInterp"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UORI"
C;X7;K"c7a04b"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K8
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y128;X1;K"upat"
C;X2;K"pathTex"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAT"
C;X7;K"c1a09"
C;X8;K"pathingTexture"
C;X9;K"m"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K0
C;Y129;X1;K"upoi"
C;X2;K"points"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UPOI"
C;X7;K"c8a05"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y130;X1;K"upri"
C;X2;K"prio"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UPRI"
C;X7;K"c8a06"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y131;X1;K"uprw"
C;X2;K"propWin"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UPRW"
C;X7;K"c7a04a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K1
C;X15;K180
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y132;X1;K"urac"
C;X2;K"race"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_URAC"
C;X7;K"c1a001"
C;X8;K"unitRace"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y133;X1;K"upaw"
C;X2;K"requireWaterRadius"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"path"
C;X6;K"WESTRING_UEVAL_UPAW"
C;X7;K"c1a09c"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y134;X1;K"utar"
C;X2;K"targType"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UTAR"
C;X7;K"c7a00"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y135;X1;K"umvr"
C;X2;K"turnRate"
C;X3;K"UnitData"
C;X4;K-1
C;X5;K"move"
C;X6;K"WESTRING_UEVAL_UMVR"
C;X7;K"c7a04"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K3
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y136;X1;K"uarm"
C;X2;K"armor"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UARM"
C;X7;K"c5b03"
C;X8;K"armorType"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y137;X1;K"uble"
C;X2;K"blend"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UBLE"
C;X7;K"c7a04c"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y138;X1;K"uclb"
C;X2;K"blue"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCLB"
C;X7;K"c1a06"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y139;X1;K"ushb"
C;X2;K"buildingShadow"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHB"
C;X7;K"c1a10a"
C;X8;K"shadowTexture"
C;X9;K"m"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y140;X1;K"ucam"
C;X2;K"campaign"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UCAM"
C;X7;K"c1a06f"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y141;X1;K"utcc"
C;X2;K"customTeamColor"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UTCC"
C;X7;K"c1a06b"
C;X8;K"bool"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y142;X1;K"udro"
C;X2;K"dropItems"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UDRO"
C;X7;K"c1a06g"
C;X8;K"bool"
C;X9;K"s"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y143;X1;K"uept"
C;X2;K"elevPts"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UEPT"
C;X7;K"d5c00"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K4
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y144;X1;K"uerd"
C;X2;K"elevRad"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UERD"
C;X7;K"d5c01"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y145;X1;K"umdl"
C;X2;K"file"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UMDL"
C;X7;K"c1a01"
C;X8;K"model"
C;X9;K"m"
C;X10;K"Model"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y146;X1;K"uver"
C;X2;K"fileVerFlags"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UVER"
C;X7;K"c1a01a"
C;X8;K"versionFlags"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K3
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y147;X1;K"ufrd"
C;X2;K"fogRad"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UFRD"
C;X7;K"d5c02"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y148;X1;K"uclg"
C;X2;K"green"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCLG"
C;X7;K"c1a05"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y149;X1;K"uhos"
C;X2;K"hostilePal"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UHOS"
C;X7;K"c8a10"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y150;X1;K"uine"
C;X2;K"inEditor"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UINE"
C;X7;K"c1a06d0"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y151;X1;K"umxp"
C;X2;K"maxPitch"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UMXP"
C;X7;K"d5b00"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K180
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y152;X1;K"umxr"
C;X2;K"maxRoll"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UMXR"
C;X7;K"d5b01"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K180
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y153;X1;K"usca"
C;X2;K"modelScale"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USCA"
C;X7;K"c1a03"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y154;X1;K"unbm"
C;X2;K"nbmmIcon"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UNBM"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y155;X1;K"uhhb"
C;X2;K"hideHeroBar"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHHB"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y156;X1;K"uhhm"
C;X2;K"hideHeroMinimap"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHHM"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y157;X1;K"uhhd"
C;X2;K"hideHeroDeathMsg"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHHD"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K0
C;X19;K0
C;X20;K0
C;X22;K1
C;Y158;X1;K"uhom"
C;X2;K"hideOnMinimap"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"stats"
C;X6;K"WESTRING_UEVAL_UHOM"
C;X7;K"c1c01"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y159;X1;K"uocc"
C;X2;K"occH"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UOCC"
C;X7;K"d6c03"
C;X8;K"unreal"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y160;X1;K"uclr"
C;X2;K"red"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCLR"
C;X7;K"c1a04"
C;X8;K"int"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K255
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y161;X1;K"urun"
C;X2;K"run"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_URUN"
C;X7;K"d6c01"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y162;X1;K"ussc"
C;X2;K"scale"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USSC"
C;X7;K"c1a08"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0.1
C;X15;K20
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y163;X1;K"uscb"
C;X2;K"scaleBull"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USCB"
C;X7;K"c1a08a"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y164;X1;K"usew"
C;X2;K"selCircOnWater"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USEW"
C;X7;K"c1a12"
C;X8;K"bool"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y165;X1;K"uslz"
C;X2;K"selZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USLZ"
C;X7;K"d6c02"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y166;X1;K"ushh"
C;X2;K"shadowH"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHH"
C;X7;K"c1a11b"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y167;X1;K"ushr"
C;X2;K"shadowOnWater"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHR"
C;X7;K"c1a11e"
C;X8;K"bool"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y168;X1;K"ushw"
C;X2;K"shadowW"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHW"
C;X7;K"c1a11a"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y169;X1;K"ushx"
C;X2;K"shadowX"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHX"
C;X7;K"c1a11c"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y170;X1;K"ushy"
C;X2;K"shadowY"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHY"
C;X7;K"c1a11d"
C;X8;K"real"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2048
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y171;X1;K"uspe"
C;X2;K"special"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_USPE"
C;X7;K"c1a06e"
C;X8;K"bool"
C;X9;K"c"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y172;X1;K"utco"
C;X2;K"teamColor"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UTCO"
C;X7;K"c1a06a"
C;X8;K"teamColor"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y173;X1;K"utss"
C;X2;K"tilesetSpecific"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UTSS"
C;X7;K"c1a06d"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y174;X1;K"uubs"
C;X2;K"uberSplat"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UUBS"
C;X7;K"c1a10"
C;X8;K"uberSplat"
C;X9;K"m"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K0
C;X18;K0
C;X19;K1
C;X20;K0
C;X22;K1
C;Y175;X1;K"ushu"
C;X2;K"unitShadow"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_USHU"
C;X7;K"c1a11"
C;X8;K"shadowImage"
C;X9;K"m"
C;X10;K"Image"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y176;X1;K"usnd"
C;X2;K"unitSound"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"sound"
C;X6;K"WESTRING_UEVAL_USND"
C;X7;K"c1a10"
C;X8;K"unitSound"
C;X11;K0
C;X12;K0
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y177;X1;K"uuch"
C;X2;K"useClickHelper"
C;X3;K"UnitUI"
C;X4;K-1
C;X5;K"editor"
C;X6;K"WESTRING_UEVAL_UUCH"
C;X7;K"c1c02"
C;X8;K"bool"
C;X9;K"m"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y178;X1;K"uwal"
C;X2;K"walk"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UWAL"
C;X7;K"d6c00"
C;X8;K"real"
C;X11;K0
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y179;X1;K"uacq"
C;X2;K"acquire"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UACQ"
C;X7;K"c8a00"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y180;X1;K"ua1t"
C;X2;K"atkType1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1T"
C;X7;K"c6a03"
C;X8;K"attackType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y181;X1;K"ua2t"
C;X2;K"atkType2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2T"
C;X7;K"c6b03"
C;X8;K"attackType"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y182;X1;K"ubs1"
C;X2;K"backSw1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UBS1"
C;X7;K"c6a08a"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y183;X1;K"ubs2"
C;X2;K"backSw2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UBS2"
C;X7;K"c6b08a"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y184;X1;K"ucbs"
C;X2;K"castbsw"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCBS"
C;X7;K"d2b01"
C;X8;K"unreal"
C;X11;K3
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y185;X1;K"ucpt"
C;X2;K"castpt"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UCPT"
C;X7;K"d2b00"
C;X8;K"unreal"
C;X11;K3
C;X12;K0
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y186;X1;K"ua1c"
C;X2;K"cool1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1C"
C;X7;K"c6a08"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y187;X1;K"ua2c"
C;X2;K"cool2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2C"
C;X7;K"c6b08"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K3600
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y188;X1;K"udl1"
C;X2;K"damageLoss1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDL1"
C;X7;K"c6a12a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y189;X1;K"udl2"
C;X2;K"damageLoss2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDL2"
C;X7;K"c6b12a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y190;X1;K"ua1d"
C;X2;K"dice1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1D"
C;X7;K"c6a071"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y191;X1;K"ua2d"
C;X2;K"dice2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2D"
C;X7;K"c6b071"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y192;X1;K"ua1b"
C;X2;K"dmgplus1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1B"
C;X7;K"c6a070"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K500000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y193;X1;K"ua2b"
C;X2;K"dmgplus2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2B"
C;X7;K"c6b070"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K500000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y194;X1;K"udp1"
C;X2;K"dmgpt1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDP1"
C;X7;K"c6a08"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y195;X1;K"udp2"
C;X2;K"dmgpt2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDP2"
C;X7;K"c6b08"
C;X8;K"unreal"
C;X11;K3
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y196;X1;K"udu1"
C;X2;K"dmgUp1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDU1"
C;X7;K"c6a073"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y197;X1;K"udu2"
C;X2;K"dmgUp2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UDU2"
C;X7;K"c6b073"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y198;X1;K"ua1f"
C;X2;K"Farea1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1F"
C;X7;K"c6a09"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y199;X1;K"ua2f"
C;X2;K"Farea2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2F"
C;X7;K"c6b09"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y200;X1;K"ua1h"
C;X2;K"Harea1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1H"
C;X7;K"c6a10"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y201;X1;K"ua2h"
C;X2;K"Harea2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2H"
C;X7;K"c6b10"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y202;X1;K"uhd1"
C;X2;K"Hfact1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UHD1"
C;X7;K"c6a10a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y203;X1;K"uhd2"
C;X2;K"Hfact2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UHD2"
C;X7;K"c6b10a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y204;X1;K"uisz"
C;X2;K"impactSwimZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UISZ"
C;X7;K"c5a04a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y205;X1;K"uimz"
C;X2;K"impactZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_UIMZ"
C;X7;K"c5a04"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y206;X1;K"ulsz"
C;X2;K"launchSwimZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULSZ"
C;X7;K"c5a03d"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y207;X1;K"ulpx"
C;X2;K"launchX"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULPX"
C;X7;K"c5a03a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y208;X1;K"ulpy"
C;X2;K"launchY"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULPY"
C;X7;K"c5a03b"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y209;X1;K"ulpz"
C;X2;K"launchZ"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"art"
C;X6;K"WESTRING_UEVAL_ULPZ"
C;X7;K"c5a03c"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K-1000
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y210;X1;K"uamn"
C;X2;K"minRange"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UAMN"
C;X7;K"c6a00"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y211;X1;K"ua1q"
C;X2;K"Qarea1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1Q"
C;X7;K"c6a11"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y212;X1;K"ua2q"
C;X2;K"Qarea2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2Q"
C;X7;K"c6b11"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K1000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y213;X1;K"uqd1"
C;X2;K"Qfact1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UQD1"
C;X7;K"c6a11a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y214;X1;K"uqd2"
C;X2;K"Qfact2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UQD2"
C;X7;K"c6b11a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y215;X1;K"ua1r"
C;X2;K"rangeN1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1R"
C;X7;K"c6a02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y216;X1;K"ua2r"
C;X2;K"rangeN2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2R"
C;X7;K"c6b02"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K20000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y217;X1;K"urb1"
C;X2;K"RngBuff1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_URB1"
C;X7;K"c6a02a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y218;X1;K"urb2"
C;X2;K"RngBuff2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_URB2"
C;X7;K"c6b02a"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K2000
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y219;X1;K"uwu1"
C;X2;K"showUI1"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UWU1"
C;X7;K"c6a01a"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y220;X1;K"uwu2"
C;X2;K"showUI2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UWU2"
C;X7;K"c6b01a"
C;X8;K"bool"
C;X11;K0
C;X12;K0
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y221;X1;K"ua1s"
C;X2;K"sides1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1S"
C;X7;K"c6a072"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y222;X1;K"ua2s"
C;X2;K"sides2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2S"
C;X7;K"c6b072"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y223;X1;K"usd1"
C;X2;K"spillDist1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USD1"
C;X7;K"c6a12b"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y224;X1;K"usd2"
C;X2;K"spillDist2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USD2"
C;X7;K"c6b12b"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y225;X1;K"usr1"
C;X2;K"spillRadius1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USR1"
C;X7;K"c6a12c"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y226;X1;K"usr2"
C;X2;K"spillRadius2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_USR2"
C;X7;K"c6b12c"
C;X8;K"unreal"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K10000
C;X16;K1
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y227;X1;K"ua1p"
C;X2;K"splashTargs1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1P"
C;X7;K"c6a12"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y228;X1;K"ua2p"
C;X2;K"splashTargs2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2P"
C;X7;K"c6b12"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y229;X1;K"utc1"
C;X2;K"targCount1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UTC1"
C;X7;K"c6a7a"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y230;X1;K"utc2"
C;X2;K"targCount2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UTC2"
C;X7;K"c6b7a"
C;X8;K"int"
C;X11;K0
C;X12;K1
C;X13;K0
C;X14;K0
C;X15;K100
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y231;X1;K"ua1g"
C;X2;K"targs1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1G"
C;X7;K"c6a07"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y232;X1;K"ua2g"
C;X2;K"targs2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2G"
C;X7;K"c6b07"
C;X8;K"targetList"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y233;X1;K"uaen"
C;X2;K"weapsOn"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UAEN"
C;X7;K"c6a01"
C;X8;K"attackBits"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y234;X1;K"ua1w"
C;X2;K"weapTp1"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA1W"
C;X7;K"c6a04"
C;X8;K"weaponType"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y235;X1;K"ua2w"
C;X2;K"weapTp2"
C;X3;K"UnitWeapons"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UA2W"
C;X7;K"c6b04"
C;X8;K"weaponType"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y236;X1;K"ucs1"
C;X2;K"weapType1"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UCS1"
C;X7;K"c6a04a"
C;X8;K"combatSound"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y237;X1;K"ucs2"
C;X2;K"weapType2"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"combat"
C;X6;K"WESTRING_UEVAL_UCS2"
C;X7;K"c6b04a"
C;X8;K"combatSound"
C;X11;K0
C;X12;K1
C;X13;K1
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K1
C;Y238;X1;K"uabs"
C;X2;K"abilSkinList"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UABS"
C;X7;K"c6c00"
C;X8;K"abilitySkinList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y239;X1;K"uhas"
C;X2;K"heroAbilSkinList"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"abil"
C;X6;K"WESTRING_UEVAL_UHAS"
C;X7;K"c6c00"
C;X8;K"abilitySkinList"
C;X9;K"s"
C;X11;K0
C;X12;K1
C;X13;K0
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K0
C;X22;K0
C;Y240;X1;K"ides"
C;X2;K"Description"
C;X3;K"Profile"
C;X4;K-1
C;X5;K"text"
C;X6;K"WESTRING_UEVAL_IDES"
C;X7;K"d0a05"
C;X8;K"string"
C;X9;K"t"
C;X11;K1
C;X12;K1
C;X13;K1
C;X15;K"TTDesc"
C;X16;K0
C;X17;K1
C;X18;K1
C;X19;K1
C;X20;K1
C;X22;K0
E

```

`Data/Warcraft/icon_tags.json`:

```json
[
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdragonroost",
        "tags": [
            "Black Dragon Roost",
            "Nether Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedragon",
        "tags": [
            "Bronze Drake",
            "Bronze Dragon",
            "Bronze Dragon Whelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdeathon",
        "tags": [
            "Orb of Annihilation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofregeneration",
        "tags": [
            "scrollofregeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndiablocar",
        "tags": [
            "Diablo Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpywitch",
        "tags": [
            "Harpy Windwitch",
            "Harpy Storm-hag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbeastmaster",
        "tags": [
            "Beastmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishhealthon",
        "tags": [
            "Essence of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnroguewizard",
        "tags": [
            "roguewizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherodemonhunter",
        "tags": [
            "Demon Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwareagle",
        "tags": [
            "Spirit Hawk",
            "Thunder Hawk",
            "Summon Hawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollhut1",
        "tags": [
            "icetrollhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorboflightning",
        "tags": [
            "Orb of Lightning",
            "Melee Lightning Damage Bonus",
            "Item Attack Lightning Bonus (new)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenguardtower",
        "tags": [
            "Earth-Fury Tower",
            "High Elven Guard Tower",
            "Sky-Fury Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaosgrunt",
        "tags": [
            "Fel Orc Grunt"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnmarkoffire",
        "tags": [
            "Phoenix"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthoriummelee",
        "tags": [
            "Frostguard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenvenomedspear",
        "tags": [
            "Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulbloodgill",
        "tags": [
            "Mur'gul Marauder",
            "Mur'gul Blood-Gill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnriderlesshorse",
        "tags": [
            "Pack Horse",
            "Riderless Horse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkobold",
        "tags": [
            "Kobold Tunneler",
            "Kobold Taskmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstoneform",
        "tags": [
            "Stone Form Gargoyle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazorback",
        "tags": [
            "Quillboar",
            "Spirit Pig",
            "Quillboar Hunter",
            "Razormane Brute",
            "Razormane Scout",
            "Feral Spirit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofdepths",
        "tags": [
            "Altar of the Depths"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyr",
        "tags": [
            "Satyr Soulstealer",
            "Satyr Hellcaller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseal",
        "tags": [
            "Seal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswarlord",
        "tags": [
            "Mathog",
            "Orc Warchief"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenfarm",
        "tags": [
            "High Elven Farm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmechanicalcritter",
        "tags": [
            "Mechanical Critter"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnbash",
        "tags": [
            "Bash",
            "Maul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollshaman",
        "tags": [
            "Ice Troll High Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodmage2",
        "tags": [
            "Blood Mage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantskeletonwarrior",
        "tags": [
            "giantskeletonwarrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwitchdoctoradept",
        "tags": [
            "Scepter of the Sea"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnammodump",
        "tags": [
            "Goblin Laboratory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpenguin",
        "tags": [
            "Penguin",
            "Clockwork Penguin",
            "Penguin Squeek"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumandestroyer",
        "tags": [
            "Human Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadshrine",
        "tags": [
            "Shrine",
            "Phat Lewt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenericcreepbuilding",
        "tags": [
            "Ice Troll Hut",
            "Gnoll Hut",
            "Mur'gul Hut",
            "Centaur Tent",
            "Murloc Hut",
            "Harpy Nest",
            "Furbolg Hut",
            "Forest Troll Hut"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostmourne",
        "tags": [
            "Frostmourne Pedestal",
            "Life Steal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenerichumanbuilding",
        "tags": [
            "City Building",
            "Infected Granary",
            "Grain Warehouse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfootman",
        "tags": [
            "Footman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodlust",
        "tags": [
            "Frenzy",
            "Bloodlust"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncancel",
        "tags": [
            "cancel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdragonroost",
        "tags": [
            "netherdragonroost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanlumberupgrade2",
        "tags": [
            "humanlumberupgrade2"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnresistantskin",
        "tags": [
            "Resistant Skin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarblack",
        "tags": [
            "Tuskarr Chieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlockhermit",
        "tags": [
            "orcwarlockhermit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinzeppelin",
        "tags": [
            "Zeppelin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndoomguard",
        "tags": [
            "Doom Guard",
            "Demonic Figurine",
            "Item Doom Guard Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemolisher",
        "tags": [
            "Demolisher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonarcher",
        "tags": [
            "Burning Archer",
            "Skeleton Archer",
            "Skeletal Marksman"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnthornshield",
        "tags": [
            "Spiked Shell",
            "Spiked Carapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreant",
        "tags": [
            "Ancient Protector"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndirewolf",
        "tags": [
            "Dire Wolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbandit",
        "tags": [
            "Bandit",
            "Rogue",
            "Enforcer",
            "Jailor Kassan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesservoidwalker",
        "tags": [
            "lesservoidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedvial",
        "tags": [
            "enchantedvial"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmannoroth",
        "tags": [
            "Pit Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthornshield",
        "tags": [
            "Spiked Carapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanitearmor",
        "tags": [
            "Arcanite Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshandris",
        "tags": [
            "Shandris"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspinycrab",
        "tags": [
            "Crab"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealoff",
        "tags": [
            "healoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdragon",
        "tags": [
            "Nether Dragon",
            "Nether Dragon Hatchling",
            "Nether Drake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmetamorphosis",
        "tags": [
            "Demon Hunter",
            "Metamorphosis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaunburrow",
        "tags": [
            "nagaunburrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthecaptain",
        "tags": [
            "Master Swordsman",
            "Captain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserkfortrolls",
        "tags": [
            "Berserk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillage",
        "tags": [
            "Night Elf Fishing Village"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaelemental",
        "tags": [
            "Sea Elemental",
            "Reef Elemental",
            "Summon Sea Elemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdrake",
        "tags": [
            "blackdrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhauntedmine",
        "tags": [
            "hauntedmine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizardsalamander",
        "tags": [
            "Salamander",
            "Salamander Lord",
            "Salamander Hatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanditmage",
        "tags": [
            "Chaplain",
            "Dark Wizard",
            "Apprentice Wizard",
            "Rogue Wizard",
            "Renegade Wizard",
            "Blood Wizard",
            "Emissary",
            "Hydromancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgultidewarrior",
        "tags": [
            "Watery Minion",
            "Mur'gul Cliffrunner",
            "Mur'gul Tidewarrior",
            "Mur'gul Reaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagekid",
        "tags": [
            "villagekid"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelguard",
        "tags": [
            "Bloodfiend",
            "Felguard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnoneheadedogremagi",
        "tags": [
            "oneheadedogremagi"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecropolis",
        "tags": [
            "Necropolis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmammoth",
        "tags": [
            "Icetusk Mammoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenfarm3",
        "tags": [
            "elvenfarm3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadshipyard",
        "tags": [
            "Undead Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbearden",
        "tags": [
            "Barrow Den"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedtreeofeternity",
        "tags": [
            "corruptedtreeofeternity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolg",
        "tags": [
            "Polar Furbolg",
            "Polar Furbolg Champion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreeofeternity",
        "tags": [
            "Tree of Eternity",
            "Corrupted Tree of Eternity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcmeleeuptwo",
        "tags": [
            "orcmeleeuptwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavatar",
        "tags": [
            "Avatar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgpanda",
        "tags": [
            "Primal Pandaren"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadcaptureflag",
        "tags": [
            "Undead Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritofvengeance",
        "tags": [
            "Avatar of Vengeance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndefend",
        "tags": [
            "Defend",
            "Defend",
            "Passive Defense"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluedragonspawn",
        "tags": [
            "Blue Dragonspawn Meddler",
            "Blue Dragonspawn Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagasummoner",
        "tags": [
            "Summoner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagnataur",
        "tags": [
            "Magnataur Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnregenerationaura",
        "tags": [
            "Aura of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghostofkelthuzad",
        "tags": [
            "Kel'Thuzad"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnhardenedskin",
        "tags": [
            "Hardened Skin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelflieutenant",
        "tags": [
            "bloodelflieutenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherofarseer",
        "tags": [
            "Far Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflyingsheep",
        "tags": [
            "flyingsheep"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngargoyle",
        "tags": [
            "Gargoyle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnapdragon",
        "tags": [
            "Submerged Snap Dragon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrolltrapper",
        "tags": [
            "Dark Troll Warlord",
            "Dark Troll Trapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsludgecreature",
        "tags": [
            "Sludge Monstrosity",
            "Sludge Flinger",
            "Sludge Minion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianziggurat",
        "tags": [
            "Nerubian Ziggurat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbundleofgift",
        "tags": [
            "bundleofgift"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndestroyer",
        "tags": [
            "Destroyer",
            "Destroyer Form "
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrizzlybear",
        "tags": [
            "Misha",
            "Spirit Bear",
            "Raging Bear",
            "Summon Bear",
            "Summon Misha"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollwarden",
        "tags": [
            "Gnoll Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnessenceofaszune",
        "tags": [
            "essenceofaszune"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsentryward",
        "tags": [
            "Watcher Ward",
            "Sentry Ward",
            "Sentry Wards",
            "Rune of the Watcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlichversion2",
        "tags": [
            "Lich"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnloaddwarf",
        "tags": [
            "loaddwarf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjunglebeast",
        "tags": [
            "Jungle Stalker",
            "Elder Jungle Stalker",
            "Enraged Jungle Stalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktroll",
        "tags": [
            "Dark Troll Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanadrain",
        "tags": [
            "Siphon Mana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormbrewmaster",
        "tags": [
            "Storm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunbrokenrager",
        "tags": [
            "unbrokenrager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphaseshift",
        "tags": [
            "Phase Shift"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvolcanus",
        "tags": [
            "volcanus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfallenpriest",
        "tags": [
            "fallenpriest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelboar",
        "tags": [
            "Fel Boar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalartifact",
        "tags": [
            "skeletalartifact"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherodeathknight",
        "tags": [
            "Death Knight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoralbed",
        "tags": [
            "Coral Bed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmindstaff",
        "tags": [
            "mindstaff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaosblademaster",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncastle",
        "tags": [
            "Castle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerkid",
        "tags": [
            "Child"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwisphealon",
        "tags": [
            "Renew"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwateryminion",
        "tags": [
            "wateryminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfarm",
        "tags": [
            "Farm",
            "Tiny Farm",
            "Build Tiny Farm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherobloodelfprince",
        "tags": [
            "Blood Mage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrocktower",
        "tags": [
            "Boulder Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientofwonders",
        "tags": [
            "Ancient of Wonders"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollking",
        "tags": [
            "Gnoll Overseer",
            "Snarlmane the Bloodgorger",
            "Gnoll Warlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnupgrademoonglaive",
        "tags": [
            "upgrademoonglaive"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnabomination",
        "tags": [
            "Abomination"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglacier",
        "tags": [
            "Frost Nova"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaterelementallv3",
        "tags": [
            "waterelementallv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkeep",
        "tags": [
            "Keep"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragondevour",
        "tags": [
            "Devour"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntombofrelics",
        "tags": [
            "Tomb of Relics"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgshaman",
        "tags": [
            "Furbolg Elder Shaman",
            "Furbolg Shaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnusedsoulgem",
        "tags": [
            "Orb of Kil'jaeden",
            "Celestial Orb of Souls",
            "Soul Theft",
            "Item Soul Possession"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngryphonaviary",
        "tags": [
            "Gryphon Aviary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollbeserker",
        "tags": [
            "Ice Troll Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornofcenarius",
        "tags": [
            "Horn of Cenarius Pedestal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerkid2",
        "tags": [
            "Child"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillboarhunter",
        "tags": [
            "quillboarhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoldmine",
        "tags": [
            "Haunted Gold Mine",
            "Entangled Gold Mine",
            "Entangle Gold Mine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntransmute",
        "tags": [
            "Scepter of Avarice",
            "Transmute",
            "Item Transmute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanditlord",
        "tags": [
            "Bandit Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalkerethereal",
        "tags": [
            "spiritwalkerethereal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarbrown",
        "tags": [
            "Tuskarr Healer",
            "Tuskarr Warrior",
            "Tuskarr Sorcerer",
            "Tuskarr Fighter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttroll",
        "tags": [
            "Forest Troll",
            "Forest Troll Warlord",
            "Forest Troll Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnabsorbmagic",
        "tags": [
            "Absorb Mana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrexxar",
        "tags": [
            "Beastmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhuntress",
        "tags": [
            "Sentry",
            "Naisha",
            "Huntress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstarwand",
        "tags": [
            "Wand of Lightning Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshrineofaszhara",
        "tags": [
            "Shrine of Azshara"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanbarracks",
        "tags": [
            "Barracks",
            "Tiny Barracks",
            "Build Tiny Barracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluedemoness",
        "tags": [
            "Vile Tormentor",
            "Queen of Suffering",
            "Maiden of Pain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonroost",
        "tags": [
            "Bronze Dragon Roost",
            "Red Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndruidofthetalon",
        "tags": [
            "Druid of the Talon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowhunter",
        "tags": [
            "Shadow Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagamyrmidonroyalguard",
        "tags": [
            "Naga Royal Guard",
            "Submerged Naga Royal Guard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonwarrior",
        "tags": [
            "Giant Skeleton Warrior",
            "Greater Dark Minion",
            "Lesser Dark Minion",
            "Skeletal Minion",
            "Item Skeleton Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwisp",
        "tags": [
            "Wisp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnperiapt",
        "tags": [
            "Periapt of Vitality"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnziggurat",
        "tags": [
            "Ziggurat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecromancer",
        "tags": [
            "Necromancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwalloffire",
        "tags": [
            "Flame Strike",
            "Burning Oil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheropaladin",
        "tags": [
            "Paladin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingwave",
        "tags": [
            "Healing Wave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhermitcrab",
        "tags": [
            "Hermit Crab"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrshadowdancer",
        "tags": [
            "satyrshadowdancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfbattlecruiser",
        "tags": [
            "Night Elf Battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingassassin",
        "tags": [
            "avengingassassin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroarchmage",
        "tags": [
            "Archmage",
            "High Elf Archmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofdarkness",
        "tags": [
            "Altar of Darkness"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheromountainking",
        "tags": [
            "Mountain King"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeast",
        "tags": [
            "Quilbeast",
            "Raging Quilbeast",
            "Dire Quilbeast",
            "Berserk Quilbeast",
            "Summon Quilbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagetower",
        "tags": [
            "High Elven Barracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandskull",
        "tags": [
            "Staff of Reanimation",
            "Wand of Negation",
            "Item Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncagedillidan",
        "tags": [
            "Prison Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslaughterhouse",
        "tags": [
            "Slaughterhouse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriest",
        "tags": [
            "Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreeoflife",
        "tags": [
            "Tree of Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntotemofmight",
        "tags": [
            "totemofmight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalorcgrunt",
        "tags": [
            "Skeletal Orc Grunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbookofsummoning",
        "tags": [
            "Book of Summoning Pedestal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryaddispelmagicoff",
        "tags": [
            "dryaddispelmagicoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanbattleship",
        "tags": [
            "Human Battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraider",
        "tags": [
            "Raider",
            "Nazgrel",
            "Slave Master"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrum",
        "tags": [
            "Warsong Battle Drums",
            "War Drums"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionbluesmall",
        "tags": [
            "Potion of Mana",
            "Item Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulshadowcaster",
        "tags": [
            "Mur'gul Shadowcaster",
            "Mur'gul Snarecaster",
            "Watery Minion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalaranmutant",
        "tags": [
            "Dalaran Mutant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingwatcheron",
        "tags": [
            "Spirit of Vengeance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchenstormstout",
        "tags": [
            "chenstormstout"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonspawnsorcerer",
        "tags": [
            "greendragonspawnsorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngranitegolem",
        "tags": [
            "granitegolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeeplordrevenant",
        "tags": [
            "Deeplord Revenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnship",
        "tags": [
            "Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiderblack",
        "tags": [
            "Black Spider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmisha",
        "tags": [
            "misha"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrtrickster",
        "tags": [
            "Satyr Trickster",
            "Satyr Shadowdancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarmorgolem",
        "tags": [
            "Battle Golem",
            "Siege Golem",
            "War Golem",
            "Bladebane Armor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbasicstruct",
        "tags": [
            "Build (Naga)",
            "Build (Orc)",
            "Build (Neutral)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathcoil",
        "tags": [
            "Death Coil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnacolyte",
        "tags": [
            "Acolyte",
            "Deceiver",
            "Heretic",
            "Fallen Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathid",
        "tags": [
            "Barbed Arachnathid",
            "Burrowed Barbed Arachnathid",
            "Arachnathid Earth-borer "
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnduneworm",
        "tags": [
            "Dune Worm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlscoutlv3",
        "tags": [
            "owlscoutlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostwyrm",
        "tags": [
            "Sapphiron",
            "Frost Wyrm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanshee",
        "tags": [
            "Banshee"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofelders",
        "tags": [
            "Altar of Elders"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaursorcerer",
        "tags": [
            "centaursorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmaidenofpain",
        "tags": [
            "maidenofpain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathidpurple",
        "tags": [
            "Overlord Arachnathid"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreenhydra",
        "tags": [
            "Ancient Hydra",
            "Hydra Hatchling",
            "Elder Hydra"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsleep",
        "tags": [
            "Sleep (Stun)",
            "Soul Preservation",
            "Sleep (Pause)",
            "Dark Conversion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnevilillidan",
        "tags": [
            "Demon Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnplaguecloud",
        "tags": [
            "Disease"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgshaman",
        "tags": [
            "Polar Furbolg Elder Shaman",
            "Polar Furbolg Shaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfemaleelfvillager",
        "tags": [
            "High Elf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalcannon",
        "tags": [
            "Infernal Machine",
            "Infernal Contraption"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryad",
        "tags": [
            "Dryad"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmountaingiant",
        "tags": [
            "Mountain Giant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherotaurenchieftain",
        "tags": [
            "Tauren Chieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshaman",
        "tags": [
            "Shaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaturesblessings",
        "tags": [
            "naturesblessings"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaygate",
        "tags": [
            "Way Gate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomebrown",
        "tags": [
            "Tome of Experience",
            "Item Experience Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlionhorn",
        "tags": [
            "The Lion Horn of Stormwind"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicytreasurebox",
        "tags": [
            "Icy Treasure Box"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntheblackarrowonoff",
        "tags": [
            "Black Arrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatchancient",
        "tags": [
            "sasquatchancient"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnalbatross",
        "tags": [
            "Albatross"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrifleman",
        "tags": [
            "Rifleman",
            "Marine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpig",
        "tags": [
            "Pig"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwargolem",
        "tags": [
            "wargolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostbear",
        "tags": [
            "Polar Bear",
            "Giant Polar Bear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjuggernaut",
        "tags": [
            "Orc Juggernaught"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurkhan",
        "tags": [
            "Centaur Sorcerer",
            "Centaur Khan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrost",
        "tags": [
            "Slowed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnentanglingroots",
        "tags": [
            "Entangling Roots"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedmoonarmor",
        "tags": [
            "improvedmoonarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpeasant",
        "tags": [
            "Peasant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbreaker",
        "tags": [
            "High King",
            "Blood Elf Lieutenant",
            "Spellbreaker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsheep",
        "tags": [
            "Flying Sheep"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwyvern",
        "tags": [
            "Wind Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelfvillager",
        "tags": [
            "Worker",
            "Runner",
            "High Elf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngem",
        "tags": [
            "Gem Fragment",
            "Gem of True Seeing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinlandmine",
        "tags": [
            "Goblin Land Mine",
            "Goblin Land Mines",
            "Item Area tree/wall damage",
            "Item Place Goblin Land Mine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforge",
        "tags": [
            "War Mill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwindwalkon",
        "tags": [
            "Wind Walk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishhealth",
        "tags": [
            "Essence of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishmanaon",
        "tags": [
            "Spirit Touch",
            "Replenish Mana"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtntrueshot",
        "tags": [
            "Trueshot Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnracoon",
        "tags": [
            "Raccoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseawitch",
        "tags": [
            "Naga Siren"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdeath",
        "tags": [
            "orbofdeath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowstrike",
        "tags": [
            "Shadow Strike"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpowergenerator",
        "tags": [
            "Power Generator"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkoboldgeomancer",
        "tags": [
            "Kobold Geomancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjunkgolem",
        "tags": [
            "Goblin Blaster",
            "Shredder"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizard",
        "tags": [
            "Thunder Lizard",
            "Lightning Lizard",
            "Storm Wyrm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglaivethrower",
        "tags": [
            "Glaive Thrower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubian",
        "tags": [
            "Nerubian Warrior",
            "Spiderling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaunt",
        "tags": [
            "Taunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdragonwhelp",
        "tags": [
            "blackdragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderbloombulb",
        "tags": [
            "thunderbloombulb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfortress",
        "tags": [
            "Fortress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpoisonarrow",
        "tags": [
            "poisonarrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseigeenginewithmissles",
        "tags": [
            "Siege Engine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmeatwagon",
        "tags": [
            "Meat Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarrel",
        "tags": [
            "Keg of Ale",
            "Keg of Thunderwater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemoness",
        "tags": [
            "Succubus",
            "Vile Temptress"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnsunderingblades",
        "tags": [
            "Sundering Blades"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnflakcannons",
        "tags": [
            "Flak Cannons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavataron",
        "tags": [
            "Avatar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemist",
        "tags": [
            "Alchemist"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroblademaster",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmonsterlure",
        "tags": [
            "Monster Lure",
            "Shimmerglaze Roast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigo",
        "tags": [
            "Wendigo",
            "Wendigo Shaman",
            "Ancient Wendigo",
            "Elder Wendigo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnacidbomb",
        "tags": [
            "Acid Bomb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntentacle",
        "tags": [
            "Tentacle",
            "Spawn Tentacle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocnightcrawler",
        "tags": [
            "Murloc Nightcrawler",
            "Murloc Sorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslow",
        "tags": [
            "Slow",
            "Item Slow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientofthemoon",
        "tags": [
            "Ancient of Wind"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphatlewt",
        "tags": [
            "phatlewt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedfrosttower",
        "tags": [
            "Advanced Cold Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagicvault",
        "tags": [
            "Magic Vault"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndoom",
        "tags": [
            "Doom"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgtracker",
        "tags": [
            "Furbolg Tracker",
            "Idol of the Wild",
            "Item Furbolg Tracker Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserinvisibility",
        "tags": [
            "Potion of Invisibility",
            "Item Temporary Invisibility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcishtransport",
        "tags": [
            "Orc Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwindwalkoff",
        "tags": [
            "windwalkoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishmanaoff",
        "tags": [
            "replenishmanaoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblacksmith",
        "tags": [
            "Blacksmith",
            "Tiny Blacksmith",
            "Build Tiny Blacksmith"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrolltrapper",
        "tags": [
            "Forest Troll Trapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaterelementallv2",
        "tags": [
            "waterelementallv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzergling",
        "tags": [
            "Zergling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaturetouchgrow",
        "tags": [
            "Ironwood Branch",
            "Vine of Purification"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\pasbtnengineeringupgrade",
        "tags": [
            "Engineering Upgrade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntome",
        "tags": [
            "Tome of Intelligence",
            "Tome of Agility",
            "Tome of Strength +2",
            "Tome of Agility +2",
            "Tome of Intelligence +2",
            "Item Agility Gain",
            "Item Strength Gain",
            "Item Intelligence Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmercenarycamp",
        "tags": [
            "Mercenary Camp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaplain",
        "tags": [
            "chaplain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrolloftownportal",
        "tags": [
            "Scroll of Healing",
            "Powerup Area Healing ",
            "Item Area Healing",
            "Powerup Area Healing Lesser",
            "Powerup Area Healing Greater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoskotobeast",
        "tags": [
            "Fel Orc Kodo Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlscoutlv2",
        "tags": [
            "owlscoutlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpyqueen",
        "tags": [
            "Harpy Queen"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaweaponup3",
        "tags": [
            "nagaweaponup3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarksummoning",
        "tags": [
            "Diamond of Summoning",
            "Dark Summoning"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseigeengine",
        "tags": [
            "Siege Engine",
            "War Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolghut1",
        "tags": [
            "furbolghut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadbattleship",
        "tags": [
            "Undead Battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmove",
        "tags": [
            "move"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedenergytower",
        "tags": [
            "Advanced Energy Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgalslave",
        "tags": [
            "Mur'gul Slave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdarkness",
        "tags": [
            "Shadow Orb +2",
            "Orb of Darkness",
            "Shadow Orb +5",
            "Shadow Orb Fragment",
            "Shadow Orb +4",
            "Shadow Orb +1",
            "Shadow Orb +3",
            "Shadow Orb +9",
            "Shadow Orb +7",
            "Shadow Orb +8",
            "Shadow Orb +6",
            "Shadow Orb +10",
            "Item Attack Black Arrow Bonus",
            "Shadow Orb Ability"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocplaguebearer",
        "tags": [
            "murlocplaguebearer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollwarlord",
        "tags": [
            "foresttrollwarlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogremagi",
        "tags": [
            "Ogre Magi"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfeedback",
        "tags": [
            "Feedback"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreincarnation",
        "tags": [
            "Item Reincarnation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchimaeraroost",
        "tags": [
            "Chimaera Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanwatchtower",
        "tags": [
            "Scout Tower",
            "Ivory Tower",
            "Build Tiny Scout Tower "
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntransport",
        "tags": [
            "Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmaskofdeath",
        "tags": [
            "Mask of Death",
            "Item Life Steal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumantransport",
        "tags": [
            "Human Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkgreen",
        "tags": [
            "Makrura Deepseer",
            "Makrura Tidecaller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthrall",
        "tags": [
            "Far Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsylvanuswindrunner",
        "tags": [
            "Ranger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkblue",
        "tags": [
            "Makrura Tidal Lord"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnpoisonsting",
        "tags": [
            "Poison Sting"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspider",
        "tags": [
            "Giant Spider",
            "Spiderling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarkoffire",
        "tags": [
            "Phoenix",
            "Phoenix Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-speedup",
        "tags": [
            "replay-speedup"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscout",
        "tags": [
            "Owl Scout"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntichondrius",
        "tags": [
            "Dreadlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurenhut",
        "tags": [
            "Tauren Tent"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurentotem",
        "tags": [
            "Tauren Totem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaweaponup1",
        "tags": [
            "nagaweaponup1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonmage",
        "tags": [
            "Skeletal Mage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrockgolem",
        "tags": [
            "Moss Covered Granite Golem",
            "Rock Golem",
            "Mud Golem",
            "Guardian Golem",
            "Defender Golem",
            "Stone Token",
            "Item Rock Golem Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofdivinity",
        "tags": [
            "Potion of Divinity",
            "Item Temporary Invulnerability",
            "Item Divine Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbattleroar",
        "tags": [
            "Roar",
            "Battle Roar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheal",
        "tags": [
            "Heal",
            "Mana Regeneration",
            "Life Regeneration Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsupportbeam",
        "tags": [
            "Support Column"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunbroken",
        "tags": [
            "Unbroken Darkhunter",
            "Unbroken Darkweaver",
            "Unbroken Rager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncryptfiend",
        "tags": [
            "Crypt Fiend",
            "Burrowed Crypt Fiend"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntimberwolf",
        "tags": [
            "Giant Wolf",
            "Giant Frost Wolf",
            "Dire Frost Wolf",
            "Timber Wolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwirtsotherleg",
        "tags": [
            "Wirt's Other Leg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrunt",
        "tags": [
            "Gar'thok",
            "Grunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstag",
        "tags": [
            "Stag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnboneyard",
        "tags": [
            "Boneyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpeon",
        "tags": [
            "Peon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblizzard",
        "tags": [
            "Blizzard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguardtower",
        "tags": [
            "Guard Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanesanctum",
        "tags": [
            "Arcane Sanctum"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvoodoolounge",
        "tags": [
            "Voodoo Lounge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntrollbatrider",
        "tags": [
            "Batrider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarcanetower",
        "tags": [
            "Arcane Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpitlord",
        "tags": [
            "Pit Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluemagnataur",
        "tags": [
            "Magnataur Destroyer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncyclone",
        "tags": [
            "Cyclone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobogoblin",
        "tags": [
            "Robo-Goblin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfworker",
        "tags": [
            "bloodelfworker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnent",
        "tags": [
            "Treant",
            "Force of Nature"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlbear",
        "tags": [
            "Wildkin",
            "Enraged Wildkin",
            "Berserk Wildkin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkred",
        "tags": [
            "Summoned Prawn",
            "Makrura Prawn",
            "Makrura Pooldweller",
            "Makrura Snapper",
            "Summon Prawns"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcher",
        "tags": [
            "Archer",
            "Dismount"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalker",
        "tags": [
            "Spirit Walker",
            "Baine",
            "Corporeal Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestmaster",
        "tags": [
            "priestmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbrilliance",
        "tags": [
            "Mindstaff",
            "Brilliance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncheese",
        "tags": [
            "Cheese"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghost",
        "tags": [
            "Wraith",
            "Sylvanas Windrunner",
            "Ghost",
            "Sea Witch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollshadowpriest",
        "tags": [
            "Ice Troll Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwellspring",
        "tags": [
            "wellspring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolg",
        "tags": [
            "Furbolg",
            "Furbolg Champion",
            "Item Blue Dragonspawn Overseer Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaihut",
        "tags": [
            "Draenei Barracks",
            "Draenei Hut",
            "Seer's Den"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorccaptureflag",
        "tags": [
            "Orc Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguldan",
        "tags": [
            "Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcdestroyer",
        "tags": [
            "Orc Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedrake",
        "tags": [
            "bronzedrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagroththedefender",
        "tags": [
            "magroththedefender"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaur",
        "tags": [
            "Centaur Drudge",
            "Centaur Outrunner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneattree",
        "tags": [
            "Eat Tree"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelguardblue",
        "tags": [
            "Overlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsludgeflinger",
        "tags": [
            "sludgeflinger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurplefelhound",
        "tags": [
            "Fel Beast",
            "Fel Ravager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofvenom",
        "tags": [
            "Orb of Venom",
            "Item Attack Poison Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntower",
        "tags": [
            "tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv3",
        "tags": [
            "mishalv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrevenant",
        "tags": [
            "Fire Revenant",
            "Lich King",
            "Frost Revenant",
            "Revenant of the Seas",
            "Revenant of the Depths",
            "Revenant of the Tides",
            "Ice Revenant",
            "Death Revenant",
            "Lightning Revenant",
            "Crown of the Deathlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncreaturecarapace",
        "tags": [
            "creaturecarapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidercrab",
        "tags": [
            "Spider Crab Limbripper",
            "Spider Crab Shorecrawler",
            "Spider Crab Behemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirebolt",
        "tags": [
            "Firebolt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsludgemontrosity",
        "tags": [
            "sludgemontrosity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage",
        "tags": [
            "Wind Rider Cage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofshadowsight",
        "tags": [
            "Wand of Shadowsight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthickfur",
        "tags": [
            "thickfur"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazuredragon",
        "tags": [
            "Blue Dragon",
            "Blue Drake",
            "Sapphiron",
            "Blue Dragon Whelp",
            "Blue Drake Egg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedgemstoneobelisk",
        "tags": [
            "enchantedgemstoneobelisk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscroll",
        "tags": [
            "Scroll of Protection",
            "Item Temporary Area Armor Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsirenmaster",
        "tags": [
            "sirenmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedent",
        "tags": [
            "Plague Treant",
            "Corrupted Treant",
            "Poison Treant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpy",
        "tags": [
            "Harpy Scout",
            "Harpy Rogue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrabtree",
        "tags": [
            "War Club"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzombie",
        "tags": [
            "Zombie"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrosttower",
        "tags": [
            "Nerubian Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurpledragonspawn",
        "tags": [
            "Blue Dragonspawn Overseer",
            "Engraved Scale"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarwarlockpurple",
        "tags": [
            "Eredar Diabolist",
            "Eredar Sorcerer",
            "Eredar Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedunholyarmor",
        "tags": [
            "improvedunholyarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollshadowpriest",
        "tags": [
            "Dark Troll Shadow Priest",
            "Dark Troll High Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanlumbermill",
        "tags": [
            "Lumber Mill",
            "Tiny Lumber Mill",
            "Build Tiny Lumber Mill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunsummonbuilding",
        "tags": [
            "Unsummon",
            "Unsummon Building"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnearthbrewmaster",
        "tags": [
            "Earth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinsapper",
        "tags": [
            "Engineer Gazlowe",
            "Sapper"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnflyingmachinetruesight",
        "tags": [
            "True Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkwizard",
        "tags": [
            "darkwizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranai",
        "tags": [
            "Draenei Stalker",
            "Draenei Guardian",
            "Draenei Laborer",
            "Draenei Vindicator",
            "Draenei Darkslayer",
            "Draenei Protector",
            "Draenei Watcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlockred",
        "tags": [
            "Drak'thul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostarmoron",
        "tags": [
            "Frost Armor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriedragon",
        "tags": [
            "Faerie Dragon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvarimathras",
        "tags": [
            "varimathras"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlordnicholasbuzan",
        "tags": [
            "lordnicholasbuzan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofcyclone",
        "tags": [
            "Wand of the Wind"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflyingmachine",
        "tags": [
            "Flying Machine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackdragon",
        "tags": [
            "Black Dragon",
            "Searinox",
            "Black Dragon Whelp",
            "Black Drake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerman1",
        "tags": [
            "Villager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnportal",
        "tags": [
            "Zone Indicator",
            "Portal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofvampirism",
        "tags": [
            "Vampiric Potion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizardvizier",
        "tags": [
            "Salamander",
            "Salamander Vizier"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseersden",
        "tags": [
            "seersden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelvenarcher",
        "tags": [
            "Archer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizardegg",
        "tags": [
            "Thunder Phoenix Egg",
            "Thunder Lizard Egg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaburrow",
        "tags": [
            "Submerge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianqueen",
        "tags": [
            "Nerubian Webspinner",
            "Nerubian Queen"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarine",
        "tags": [
            "Terran Marine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwispsplode",
        "tags": [
            "Detonate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpigfarm",
        "tags": [
            "Pig Farm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidergreen",
        "tags": [
            "Forest Spider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionpurple",
        "tags": [
            "potionpurple"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnplagueent",
        "tags": [
            "plagueent"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzigguratupgrade",
        "tags": [
            "Spirit Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarnomad",
        "tags": [
            "tuskaarnomad"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagnataurbrown",
        "tags": [
            "Magnataur Reaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherodreadlord",
        "tags": [
            "Dreadlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswolfrider",
        "tags": [
            "Fel Orc Raider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreathall",
        "tags": [
            "Great Hall",
            "Tiny Great Hall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadtransport",
        "tags": [
            "Undead Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedunholystrength",
        "tags": [
            "Runed Gauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedtreeoflife",
        "tags": [
            "Corrupted Tree of Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpocketfactory",
        "tags": [
            "Pocket Factory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcaniteranged",
        "tags": [
            "arcaniteranged"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntreeofages",
        "tags": [
            "Tree of Ages",
            "Corrupted Tree of Ages"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkeeperofthegrove",
        "tags": [
            "Keeper of the Grove",
            "Demigod"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsunkey",
        "tags": [
            "Sun Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollshadowpriest",
        "tags": [
            "Forest Troll Shadow Priest",
            "Forest Troll High Priest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragon",
        "tags": [
            "Red Dragon Whelp",
            "Red Drake",
            "Red Drake Egg",
            "Item Blue Drake Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabs",
        "tags": [
            "Carrion Beetle",
            "Burrowed Carrion Beetle",
            "Carrion Beetles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncurseon",
        "tags": [
            "Curse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunstableconcoction",
        "tags": [
            "Unstable Concoction"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsamuro",
        "tags": [
            "samuro"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhallofthedead",
        "tags": [
            "Halls of the Dead"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnplaguecloud",
        "tags": [
            "Disease Cloud"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlock",
        "tags": [
            "Stormreaver Warlock",
            "Stormreaver Necrolyte",
            "Stormreaver Apprentice",
            "Stormreaver Hermit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreen",
        "tags": [
            "Gargantuan Sea Turtle",
            "Giant Sea Turtle",
            "Sea Turtle Hatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskink",
        "tags": [
            "Skink"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbluedragonroost",
        "tags": [
            "Blue Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendrake",
        "tags": [
            "greendrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncop",
        "tags": [
            "Circle of Power"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvulture",
        "tags": [
            "Vulture"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngryphonrider",
        "tags": [
            "Gryphon Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpandarenbrewmaster",
        "tags": [
            "Brewmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmalfurionwithoutstag",
        "tags": [
            "Keeper of the Grove"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfpeasant",
        "tags": [
            "Blood Elf Engineer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiderblue",
        "tags": [
            "Spitting Spider",
            "Brood Mother"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndruidoftheclaw",
        "tags": [
            "Druid of the Claw"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedancientprotector",
        "tags": [
            "Corrupted Ancient Protector"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedmoonwell",
        "tags": [
            "Corrupted Moon Well"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerman",
        "tags": [
            "Villager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancestralspirit",
        "tags": [
            "Ancestral Spirit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlered",
        "tags": [
            "Dragon Turtle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntrollburrow",
        "tags": [
            "Burrow",
            "Fel Burrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnentrapmentward",
        "tags": [
            "Shamanic Totem",
            "Totem of Might",
            "Item Purge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedrocktower",
        "tags": [
            "Advanced Boulder Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncritterchicken",
        "tags": [
            "Chicken"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhuntershall",
        "tags": [
            "Hunter's Hall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglyph",
        "tags": [
            "Glyph of Omniscience",
            "Glyph of Purification",
            "Glyph of Ultravision",
            "Sacred Relic",
            "Glyph of Fortification"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflametower",
        "tags": [
            "Flame Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnoll",
        "tags": [
            "Gnoll Brute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflare",
        "tags": [
            "Flare Gun"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalstone",
        "tags": [
            "Inferno Stone",
            "Rain of Chaos"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagamyrmidon",
        "tags": [
            "Submerged Naga Myrmidon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-loop",
        "tags": [
            "replay-loop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenragedjunglebeast",
        "tags": [
            "enragedjunglebeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchimaera",
        "tags": [
            "Chimaera"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninnerfire",
        "tags": [
            "Inner Fire"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndrum",
        "tags": [
            "War Drums"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaisha",
        "tags": [
            "naisha"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholyaura",
        "tags": [
            "Helm of Battlethirst",
            "Unholy Aura"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnscout",
        "tags": [
            "True Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbeastiary",
        "tags": [
            "Beastiary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrypt",
        "tags": [
            "Crypt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenergytower",
        "tags": [
            "Energy Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofprotection",
        "tags": [
            "Scroll of Mana",
            "Note to Jaina Proudmoore",
            "Item Area Mana Regain",
            "Rune Area Mana Regain",
            "Rune Area Mana Regain Greater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarmoredoge",
        "tags": [
            "Stonemaul Warchief"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncloakofflames",
        "tags": [
            "Cloak of Flames",
            "Item Immolation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv4",
        "tags": [
            "mishalv4"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndwarfcar",
        "tags": [
            "Dwarf Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingward",
        "tags": [
            "Healing Ward",
            "Healing Wards",
            "Healing Ward Aura",
            "Regeneration Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncirclet",
        "tags": [
            "Circlet of Nobility",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvoidwalker",
        "tags": [
            "Lesser Voidwalker",
            "Greater Voidwalker",
            "Elder Voidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfarsight",
        "tags": [
            "Far Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnladyvashj",
        "tags": [
            "ladyvashj"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkportal",
        "tags": [
            "Dimensional Gate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnravenform",
        "tags": [
            "Medivh",
            "Druid of the Talon",
            "Storm Crow Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathidgreen",
        "tags": [
            "Crystal Arachnathid",
            "Warrior Arachnathid"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfragmentationbombs",
        "tags": [
            "Fragmentation Shards"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecklace",
        "tags": [
            "Necklace of Spell Immunity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntent3",
        "tags": [
            "tent3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazormanechief",
        "tags": [
            "Razormane Medicine Man",
            "Razormane Chieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwhirlwind",
        "tags": [
            "Bladestorm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackmammoth",
        "tags": [
            "Dire Mammoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritlodge",
        "tags": [
            "Spirit Lodge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofnegation",
        "tags": [
            "Staff of Negation",
            "Item Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirebrewmaster",
        "tags": [
            "Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimpale",
        "tags": [
            "Impale"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazuredragonwhelp",
        "tags": [
            "azuredragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsoulburn",
        "tags": [
            "Soul Burn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvanceddeathtower",
        "tags": [
            "Advanced Death Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofmanasteal",
        "tags": [
            "Wand of Mana Stealing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdrake",
        "tags": [
            "netherdrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofhaste",
        "tags": [
            "Scroll of Speed",
            "Scroll of Haste",
            "Rune of Speed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhalahkthelifebringer",
        "tags": [
            "halahkthelifebringer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofstorms",
        "tags": [
            "Altar of Storms"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgelder",
        "tags": [
            "Furbolg Ursa Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorctower",
        "tags": [
            "Watch Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholyfrenzy",
        "tags": [
            "Unholy Frenzy",
            "Incite Unholy Frenzy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnantonidas",
        "tags": [
            "antonidas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbansheeranger",
        "tags": [
            "Dark Ranger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanish",
        "tags": [
            "Banish"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsunderingblades",
        "tags": [
            "sunderingblades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbash",
        "tags": [
            "bash"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhippogriffrider",
        "tags": [
            "Hippogryph Rider",
            "Mount Hippogryph",
            "Pick up Archer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwandofneutralization",
        "tags": [
            "Wand of Neutralization",
            "Ray of Disruption",
            "Item Chain Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrolloftheunholylegion",
        "tags": [
            "scrolloftheunholylegion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnamulet",
        "tags": [
            "Amulet of Recall",
            "Item Recall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalorcchampion",
        "tags": [
            "Skeletal Orc Champion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghostmage",
        "tags": [
            "Ghostly Archmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcbattlestandard",
        "tags": [
            "Battle Standard",
            "Item Orcish Battle Standard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainoflife",
        "tags": [
            "Fountain of Mana",
            "Fountain of Health",
            "Fountain of Power"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillboar",
        "tags": [
            "quillboar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninnerfireon",
        "tags": [
            "Inner Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntauren",
        "tags": [
            "Tauren"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorpseexplode",
        "tags": [
            "Finger of Death",
            "Finger of Pain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressmaster",
        "tags": [
            "Drek'thar's Spellbook",
            "Gerard's Lost Ledger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaidemolisher",
        "tags": [
            "dranaidemolisher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarden2",
        "tags": [
            "Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbanditspearthrower",
        "tags": [
            "Brigand",
            "Assassin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhelmofbattlethirst",
        "tags": [
            "helmofbattlethirst"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmassteleport",
        "tags": [
            "Mass Teleport"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonspawn",
        "tags": [
            "Blue Dragonspawn Apprentice",
            "Blue Dragonspawn Sorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarstomp",
        "tags": [
            "War Stomp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngarithos",
        "tags": [
            "Dark Knight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmilitia",
        "tags": [
            "Militia"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjaina",
        "tags": [
            "Archmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglexchange",
        "tags": [
            "glexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranailaborer",
        "tags": [
            "dranailaborer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfleshgolem",
        "tags": [
            "Flesh Golem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntyrande",
        "tags": [
            "tyrande"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurion",
        "tags": [
            "Keeper of the Grove"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrificialpit",
        "tags": [
            "Sacrificial Pit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfrunner",
        "tags": [
            "Night Elf Runner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanasteriansunstrider",
        "tags": [
            "anasteriansunstrider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspawninggrounds",
        "tags": [
            "Spawning Grounds"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgelder",
        "tags": [
            "Polar Furbolg Ursa Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathrevenant",
        "tags": [
            "deathrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserclaritypotion",
        "tags": [
            "Lesser Clarity Potion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwyvernrider",
        "tags": [
            "Wind Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrolluber",
        "tags": [
            "Scroll of Town Portal",
            "Item Town Portal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherowarden",
        "tags": [
            "Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaosgrom",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnantimagicshell",
        "tags": [
            "Anti-magic Shell",
            "Summoning Ritual"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathtower",
        "tags": [
            "Death Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresistmagic",
        "tags": [
            "resistmagic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaargold",
        "tags": [
            "Tuskarr Trapper",
            "Tuskarr Spearman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlavaspawn",
        "tags": [
            "Lava Spawn",
            "Summon Lava Spawn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsummonwaterelemental",
        "tags": [
            "Enraged Elemental",
            "Water Elemental",
            "Berserk Elemental",
            "Summon Water Elemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntemp",
        "tags": [
            "Sammy!",
            "Kobold Shoveler",
            "Mind Rot",
            "Ethereal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedflametower",
        "tags": [
            "Advanced Flame Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestessofthemoon",
        "tags": [
            "Priestess of the Moon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidersilkbroach",
        "tags": [
            "Spider Silk Broach"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhex",
        "tags": [
            "Frog",
            "Hex"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragon",
        "tags": [
            "Green Drake",
            "Green Dragon Whelp",
            "Tharifas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastlv2",
        "tags": [
            "quillbeastlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurloc",
        "tags": [
            "Murloc Tiderunner",
            "Murloc Huntsman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetroll",
        "tags": [
            "Ice Troll Trapper",
            "Ice Troll Warlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntempleofthedamned",
        "tags": [
            "Temple of the Damned"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancestralstaff",
        "tags": [
            "ancestralstaff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntempleoftides",
        "tags": [
            "Temple of Tides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnazgrel",
        "tags": [
            "nazgrel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetuskmammoth",
        "tags": [
            "icetuskmammoth"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnskeletonmage",
        "tags": [
            "Skeletal Mastery"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfemaleelfvillage",
        "tags": [
            "femaleelfvillage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollarcher",
        "tags": [
            "Gnoll Assassin",
            "Gnoll Poacher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagicalsentry",
        "tags": [
            "magicalsentry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarracks",
        "tags": [
            "Barracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernal",
        "tags": [
            "Infernal",
            "Inferno"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnakama",
        "tags": [
            "akama"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaseawitch",
        "tags": [
            "Sea Witch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhelmutpurple",
        "tags": [
            "Crown of Kings +5",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaospeon",
        "tags": [
            "Fel Peon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillspray",
        "tags": [
            "Quill Spray"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiakama",
        "tags": [
            "Elder Sage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmirrorimage",
        "tags": [
            "Mirror Image"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswarlockgreen",
        "tags": [
            "Orc Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarthas",
        "tags": [
            "Paladin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfelhound",
        "tags": [
            "Spirit Beast",
            "Lesser Spirit Beast",
            "Fel Stalker",
            "Greater Spirit Beast",
            "Spiked Collar",
            "Item Fel Stalker Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnuproot",
        "tags": [
            "uproot"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinshipyard",
        "tags": [
            "Goblin Shipyard",
            "Orc Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforgottenone",
        "tags": [
            "Forgotten One"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedbows",
        "tags": [
            "improvedbows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnholybolt",
        "tags": [
            "Holy Light"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherocryptlord",
        "tags": [
            "Crypt Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraisedeadon",
        "tags": [
            "Raise Dead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingblade",
        "tags": [
            "searingblade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulreaver",
        "tags": [
            "murgulreaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaimage",
        "tags": [
            "Draenei Harbinger",
            "Draenei Disciple",
            "Draenei Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblood&ghostkey",
        "tags": [
            "Magic Key Chain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-pause",
        "tags": [
            "replay-pause"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogrelord",
        "tags": [
            "Ogre Lord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadairbarge",
        "tags": [
            "Sky Barge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstasistrap",
        "tags": [
            "Stasis Trap"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawk",
        "tags": [
            "Dragonhawk Rider",
            "Dragon Hawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagerwoman",
        "tags": [
            "Villager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedgemstone",
        "tags": [
            "Enchanted Gemstone Obelisk",
            "Thunderlizard Diamond"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagiclariet",
        "tags": [
            "Aerial Shackles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalaranreject",
        "tags": [
            "Dalaran Reject"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedancientofwar",
        "tags": [
            "Corrupted Ancient of War"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaichiefhut",
        "tags": [
            "Draenei Haven",
            "Draenei Chieftain's Hut"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurarcher",
        "tags": [
            "Centaur Archer",
            "Centaur Impaler"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnstormhammer",
        "tags": [
            "Storm Hammers"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntalisman",
        "tags": [
            "Talisman of Evasion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgtracker",
        "tags": [
            "Polar Furbolg Tracker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedstrengthofthewild",
        "tags": [
            "advancedstrengthofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheadhunterberserker",
        "tags": [
            "Berserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowwolflv3",
        "tags": [
            "shadowwolflv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurge",
        "tags": [
            "Purge",
            "Item Purge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocflesheater",
        "tags": [
            "Murloc Flesheater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatch",
        "tags": [
            "Sasquatch Oracle",
            "Ancient Sasquatch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnglove",
        "tags": [
            "Gloves of Haste",
            "Item Attack Speed Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntinycastle",
        "tags": [
            "Tiny Castle",
            "Build Tiny Castle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelftransport",
        "tags": [
            "Night Elf Transport Ship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurimpaler",
        "tags": [
            "centaurimpaler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclockwerkgoblin",
        "tags": [
            "Clockwerk Goblin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbearform",
        "tags": [
            "Druid of the Claw",
            "Bear Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarksmanship",
        "tags": [
            "Marksmanship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbattleship",
        "tags": [
            "battleship"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemongate",
        "tags": [
            "Demon Gate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfacelessone",
        "tags": [
            "Faceless One Terror",
            "Faceless One Deathbringer",
            "Faceless One Trickster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletonminion",
        "tags": [
            "skeletonminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmarketplace",
        "tags": [
            "Fruit Stand"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianspiderlord",
        "tags": [
            "Nerubian Spider Lord",
            "Nerubian Seer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncatapult",
        "tags": [
            "Draenei Demolisher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalflamecannon",
        "tags": [
            "Infernal Juggernaut"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-play",
        "tags": [
            "replay-play"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfdestroyer",
        "tags": [
            "Night Elf Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiant",
        "tags": [
            "Sea Giant",
            "Sea Giant Behemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndaggerofescape",
        "tags": [
            "Kelen's Dagger of Escape",
            "Assassin's Blade",
            "Slow Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstronghold",
        "tags": [
            "Stronghold"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrejuvenation",
        "tags": [
            "Rejuvenation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncryptfiendunburrow",
        "tags": [
            "cryptfiendunburrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwolf",
        "tags": [
            "Dog",
            "Guard Dog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspy",
        "tags": [
            "Mogrin's Report"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmortarteam",
        "tags": [
            "Mortar Team"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzebowl",
        "tags": [
            "bronzebowl"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydralisk",
        "tags": [
            "Hydralisk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghoul",
        "tags": [
            "Ghoul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollhut1",
        "tags": [
            "gnollhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncannontower",
        "tags": [
            "Cannon Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnowowl",
        "tags": [
            "Snowy Owl"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnknight",
        "tags": [
            "Knight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldarrowson",
        "tags": [
            "Frost Arrows",
            "Cold Arrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnobsidianstatue",
        "tags": [
            "Obsidian Statue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnoneheadedogre",
        "tags": [
            "Stonemaul Ogre",
            "Stonemaul Magi"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanitearchitecture",
        "tags": [
            "arcanitearchitecture"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkminion",
        "tags": [
            "darkminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientoftheearth",
        "tags": [
            "Ancient of War"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpickupitem",
        "tags": [
            "pickupitem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainoflifeblood",
        "tags": [
            "Fountain of Blood"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngloveofspellmastery",
        "tags": [
            "gloveofspellmastery"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnengineeringupgrade",
        "tags": [
            "Engineering Upgrade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantgreen",
        "tags": [
            "Sea Giant Hunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpocketfactorylv3",
        "tags": [
            "pocketfactorylv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclawsofattack",
        "tags": [
            "Claws of Attack +9",
            "Claws of Attack +6",
            "Claws of Attack +3",
            "Claws of Attack +15",
            "Claws of Attack +12",
            "Item Damage Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresstone",
        "tags": [
            "Resurrection Stone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalorc",
        "tags": [
            "Skeletal Orc"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntidalguardian",
        "tags": [
            "Tidal Guardian"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainoflifedefiled",
        "tags": [
            "Defiled Fountain of Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnroot",
        "tags": [
            "Root"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroavatarofflame",
        "tags": [
            "Firelord"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnscatterrockets",
        "tags": [
            "Barrage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnevasion",
        "tags": [
            "Evasion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldtower",
        "tags": [
            "Cold Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunloadpeon",
        "tags": [
            "unloadpeon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnworkshop",
        "tags": [
            "Workshop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnswordsman_v1",
        "tags": [
            "swordsman_v1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwitchdoctor",
        "tags": [
            "Vol'jin",
            "Witch Doctor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceress",
        "tags": [
            "Sorceress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanshipyard",
        "tags": [
            "Human Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotiongreensmall",
        "tags": [
            "Potion of Healing",
            "Item Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressadept",
        "tags": [
            "sorceressadept"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollhut2",
        "tags": [
            "gnollhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicecrownobelisk",
        "tags": [
            "Icecrown Obelisk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterinvulneralbility",
        "tags": [
            "Potion of Invulnerability",
            "Item Temporary Invulnerability"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadcar",
        "tags": [
            "Undead Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingwatcher",
        "tags": [
            "Spirit of Vengeance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbox",
        "tags": [
            "box"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbreathoffire",
        "tags": [
            "Breath of Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncritterrabbit",
        "tags": [
            "Rabbit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanual3",
        "tags": [
            "Tome of Greater Experience",
            "Item Experience Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstasistrapskill",
        "tags": [
            "stasistrapskill"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancientoflore",
        "tags": [
            "Ancient of Lore"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnyoudirtyrat!",
        "tags": [
            "Rat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlocmutant",
        "tags": [
            "Murloc Mutant",
            "Murloc Plaguebearer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentward",
        "tags": [
            "Serpent Ward"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofsilence",
        "tags": [
            "Staff of Silence",
            "Item Silence"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntavern",
        "tags": [
            "Tavern"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwolf",
        "tags": [
            "Spirit Wolf",
            "Shadow Wolf",
            "Dire Wolf",
            "Feral Spirit",
            "Summon Headhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherotinker",
        "tags": [
            "Tinker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostbolt",
        "tags": [
            "Frost Bolt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmedivh",
        "tags": [
            "Medivh"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnriderlesskodo",
        "tags": [
            "Kodo Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcaneobservatory",
        "tags": [
            "Arcane Observatory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorccar",
        "tags": [
            "Orc Cart"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscepterofhealing",
        "tags": [
            "scepterofhealing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriefireoff",
        "tags": [
            "faeriefireoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntownhall",
        "tags": [
            "Town Hall",
            "Build Tiny Great Hall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncleavingattack",
        "tags": [
            "cleavingattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfprince",
        "tags": [
            "bloodelfprince"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkelthuzad",
        "tags": [
            "Kel'Thuzad"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjanggo",
        "tags": [
            "Ancient Janggo of Endurance"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwindserpent",
        "tags": [
            "Couatl"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlocustswarm",
        "tags": [
            "Locust",
            "Voodoo Spirits",
            "Locust Swarm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplay-speeddown",
        "tags": [
            "replay-speeddown"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnstatup",
        "tags": [
            "Attribute Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkiljaedin",
        "tags": [
            "Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpurplefelravager",
        "tags": [
            "purplefelravager"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfshipyard",
        "tags": [
            "Night Elf Shipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellsteal",
        "tags": [
            "Gloves of Spell Mastery",
            "Control Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritpig",
        "tags": [
            "spiritpig"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackmarket",
        "tags": [
            "Marketplace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserrejuvpotion",
        "tags": [
            "Lesser Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonwell",
        "tags": [
            "Moon Well"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngathergold",
        "tags": [
            "Rusty Mining Pick",
            "Harvest",
            "Gather"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmantleofintelligence",
        "tags": [
            "Mantle of Intelligence +3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrune",
        "tags": [
            "Rune of Rebirth",
            "Rune of the Watcher",
            "Rune of Lesser Resurrection",
            "Rune of Lesser Healing",
            "Rune of Greater Mana",
            "Rune of Speed",
            "Rune of Mana",
            "Rune of Dispel Magic",
            "Rune of Restoration",
            "Rune of Greater Resurrection",
            "Rune of Healing",
            "Rune of Spirit Link",
            "Rune of Greater Healing",
            "Rune of Shielding",
            "Reborn",
            "Powerup Dispel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnload",
        "tags": [
            "Load Wisp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwatcherward",
        "tags": [
            "watcherward"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjailorkassan",
        "tags": [
            "jailorkassan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeaddestroyer",
        "tags": [
            "Undead Frigate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheadhunter",
        "tags": [
            "Headhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnassassin",
        "tags": [
            "Warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwyvern",
        "tags": [
            "Spirit Wind Rider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhippogriff",
        "tags": [
            "Hippogryph"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofslowness",
        "tags": [
            "Orb of Slow",
            "Item Attack Slow Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanarechargeon",
        "tags": [
            "Replenish Mana and Life"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostguard",
        "tags": [
            "frostguard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkeeperghostblue",
        "tags": [
            "Keeper of the Grove"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanevault",
        "tags": [
            "Arcane Vault"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnamuletofthewild",
        "tags": [
            "Amulet of the Wild",
            "Item Ursa Warrior Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmerchant",
        "tags": [
            "Goblin Merchant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngraveyard",
        "tags": [
            "Graveyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnaltarofkings",
        "tags": [
            "Altar of Kings",
            "Tiny Altar of Kings",
            "Build Tiny Altar of Kings"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbroodmother",
        "tags": [
            "broodmother"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphoenixegg",
        "tags": [
            "Phoenix Egg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshade",
        "tags": [
            "Shade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncriticalstrike",
        "tags": [
            "criticalstrike"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanashield",
        "tags": [
            "manashield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhellscream",
        "tags": [
            "Blademaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarchimonde",
        "tags": [
            "Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblackcitadel",
        "tags": [
            "Black Citadel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscepterofmastery",
        "tags": [
            "Scepter of Mastery",
            "Item Command"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkotobeast",
        "tags": [
            "Kodo Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselectherooff",
        "tags": [
            "selectherooff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrokhan",
        "tags": [
            "rokhan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogre",
        "tags": [
            "Ogre Mauler",
            "Ogre Warrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwirtsleg",
        "tags": [
            "Wirt's Leg"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalaranguardtower",
        "tags": [
            "Dalaran Guard Tower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonroost",
        "tags": [
            "Green Dragon Roost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnleatherupgradeone",
        "tags": [
            "leatherupgradeone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiwatcher",
        "tags": [
            "dranaiwatcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntornado",
        "tags": [
            "Tornado",
            "Tornado Spin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrengthofthemoon",
        "tags": [
            "strengthofthemoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodelfsupplywagon",
        "tags": [
            "Wagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchaoswarlock",
        "tags": [
            "Fel Orc Warlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantfrostwolf",
        "tags": [
            "giantfrostwolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatchshaman",
        "tags": [
            "Elder Sasquatch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhoodofcunning",
        "tags": [
            "Hood of Cunning"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterrejuvpotion",
        "tags": [
            "Greater Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarmorupthree",
        "tags": [
            "Shield of Honor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanual",
        "tags": [
            "Manual of Health",
            "Item Permanent Life Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsalamanderlord",
        "tags": [
            "salamanderlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmedivhravenform",
        "tags": [
            "medivhravenform"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellshieldamulet",
        "tags": [
            "Amulet of Spell Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofstrength",
        "tags": [
            "tomeofstrength"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnentanglemine",
        "tags": [
            "entanglemine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbookofthedead",
        "tags": [
            "Book of the Dead"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnthickfur",
        "tags": [
            "Resistant Skin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedspikedbarricades",
        "tags": [
            "advancedspikedbarricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshamanmaster",
        "tags": [
            "Shaman Claws"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcmeleeupone",
        "tags": [
            "Sturdy War Axe"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchestofgold",
        "tags": [
            "Gold Coins",
            "Chest of Gold"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndwarvenlongrifle",
        "tags": [
            "Long Rifles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstone",
        "tags": [
            "Talisman of the Wild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguldanskull",
        "tags": [
            "Skull of Gul'dan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnboots",
        "tags": [
            "Boots of Quel'Thalas +6",
            "Speed Bonus",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterrejuvscroll",
        "tags": [
            "Greater Scroll of Replenishment ",
            "Rejuvenation",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofsanctuary",
        "tags": [
            "Staff of Sanctuary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestadept",
        "tags": [
            "Scepter of Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecromancermaster",
        "tags": [
            "Grimoire of Souls"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelvenarcher_v1",
        "tags": [
            "highelvenarcher_v1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsobimask",
        "tags": [
            "Sobi Mask",
            "Item Mana Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodkey",
        "tags": [
            "Blood Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngmexchange",
        "tags": [
            "gmexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrificialskull",
        "tags": [
            "Sacrificial Skull",
            "Blight Placement"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsilence",
        "tags": [
            "Silence"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbreathoffrost",
        "tags": [
            "Breath of Frost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninn",
        "tags": [
            "inn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornofdoom",
        "tags": [
            "Legion Doom-Horn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorclumberupgradetwo",
        "tags": [
            "orclumberupgradetwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringjadefalcon",
        "tags": [
            "Ring of the Archmagi",
            "Jade Ring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzyscrollpurple",
        "tags": [
            "Scroll of Animate Dead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnperiapt1",
        "tags": [
            "Khadgar's Gem of Health",
            "Item Life Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpatrol",
        "tags": [
            "patrol"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonkey",
        "tags": [
            "Moon Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnurnofkelthuzad",
        "tags": [
            "Urn of King Terenas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrystalball",
        "tags": [
            "Crystal Ball",
            "Item Area Detection"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbelt",
        "tags": [
            "Belt of Giant Strength +6",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbonechimes",
        "tags": [
            "Scourge Bone Chimes"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterinvisibility",
        "tags": [
            "Potion of Greater Invisibility",
            "Item Temporary Invisibility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresurrection",
        "tags": [
            "Greater Rune Resurrection",
            "Item Resurrection",
            "Lesser Rune Resurrection"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsteelarmor",
        "tags": [
            "steelarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntelescope",
        "tags": [
            "Goblin Night Scope",
            "Item Sight Range Bonus",
            "Ultravision"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomered",
        "tags": [
            "Tome of Power",
            "Tome of Knowledge",
            "Item Permanent Damage Gain",
            "Item Attack Damage Gain",
            "Item Int/Agi/Str gain",
            "Item Level Gain",
            "Item Permanent Life Gain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnancienthydra",
        "tags": [
            "ancienthydra"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnexhumecorpses",
        "tags": [
            "Exhume Corpses"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaidarkslayer",
        "tags": [
            "dranaidarkslayer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btniceshard",
        "tags": [
            "Ice Shard",
            "Item Ice Revenant Summon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionred",
        "tags": [
            "Potion of Speed",
            "Item Temporary Speed Bonus",
            "Item Heal/Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserk",
        "tags": [
            "berserk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvialfull",
        "tags": [
            "Full Vial",
            "Enchanted Vial"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntheblackarrow",
        "tags": [
            "Black Arrow",
            "Dark Minion",
            "Item Black Arrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingsalve",
        "tags": [
            "Healing Salve",
            "Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcmeleeupthree",
        "tags": [
            "Serathil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrodofnecromancy",
        "tags": [
            "Rod of Necromancy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserinvulneralbility",
        "tags": [
            "Potion of Lesser Invulnerability",
            "Item Temporary Invulnerability"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrimward",
        "tags": [
            "Skull Shield",
            "Frost Wyrm Skull Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringlionhead",
        "tags": [
            "Lion's Ring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorboffire",
        "tags": [
            "Orb of Fire",
            "Heal Reduction",
            "Item Attack Heal Reduction Bonus",
            "Item Attack Fire Bonus",
            "Melee Fire Damage Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanitemelee",
        "tags": [
            "Searing Blade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorruptedtreeofages",
        "tags": [
            "corruptedtreeofages"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofcorruption",
        "tags": [
            "Skeletal Artifact",
            "Orb of Corruption",
            "Item Attack Corruption Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornoffog",
        "tags": [
            "Horn of the Clouds"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwateryminioncaster",
        "tags": [
            "wateryminioncaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnalleriaflute",
        "tags": [
            "Alleria's Flute of Accuracy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofrestoration",
        "tags": [
            "Potion of Restoration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotiongreen",
        "tags": [
            "Potion of Greater Healing",
            "Item Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofretraining",
        "tags": [
            "Tome of Retraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringpurple",
        "tags": [
            "Bracer of Agility",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstun",
        "tags": [
            "Stunned"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringgreen",
        "tags": [
            "Ring of Protection +5",
            "Ring of Protection +4",
            "Ring of Protection +1",
            "Ring of Protection +2",
            "Ring of Protection +3",
            "Item Armor Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn3m1",
        "tags": [
            "Mooncrystal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanaflareoff",
        "tags": [
            "Thunderbloom Bulb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarkskinoff",
        "tags": [
            "barkskinoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfcaptureflag",
        "tags": [
            "Night Elf Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurtent2",
        "tags": [
            "centaurtent2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn3m2",
        "tags": [
            "Partial Key of the Three Moons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntrueshot",
        "tags": [
            "Trueshot Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphaseshifton",
        "tags": [
            "Phase Shift"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnliquidfire",
        "tags": [
            "liquidfire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrunedbracers",
        "tags": [
            "Runed Bracers",
            "Spell Damage Reduction"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndust",
        "tags": [
            "Druid Pouch"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndustofappearance",
        "tags": [
            "Dust of Appearance",
            "Detected"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnregenerate",
        "tags": [
            "regenerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedunholystrength",
        "tags": [
            "Firehand Gauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrenghtofthewild",
        "tags": [
            "strenghtofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrekthar",
        "tags": [
            "drekthar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringskull",
        "tags": [
            "Ring of Regeneration",
            "Item Life Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealthstone",
        "tags": [
            "Health Stone",
            "Item Life Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnacorn",
        "tags": [
            "Seed of Expulsion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheartofaszune",
        "tags": [
            "Heart of Aszune",
            "Essence of Aszune",
            "Least Healing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostwolf",
        "tags": [
            "frostwolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonstone",
        "tags": [
            "Moonstone",
            "Change Time of Day"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngauntletsofogrepower",
        "tags": [
            "Gauntlets of Ogre Strength +3",
            "Item Attack Speed Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorboffrost",
        "tags": [
            "Orb of Frost",
            "Melee Cold Damage Bonus",
            "Item Attack Frost Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnankh",
        "tags": [
            "Ankh of Reincarnation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnregeneration",
        "tags": [
            "regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrejuvpotion",
        "tags": [
            "Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarmoredogre",
        "tags": [
            "armoredogre"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbrigand",
        "tags": [
            "brigand"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserdarkminion",
        "tags": [
            "lesserdarkminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzypotion",
        "tags": [
            "Anti-magic Potion",
            "Item Anti-Magic Shell"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzyscroll",
        "tags": [
            "Scroll of Resurrection"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvialempty",
        "tags": [
            "Empty Vial"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofclarity",
        "tags": [
            "Clarity Potion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofregenerationgreen",
        "tags": [
            "Scroll of Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabson",
        "tags": [
            "Carrion Beetles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage2",
        "tags": [
            "cage2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstop",
        "tags": [
            "stop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringvioletspider",
        "tags": [
            "Spider Ring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwitchdoctormaster",
        "tags": [
            "Ancestral Staff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclayfigurine",
        "tags": [
            "Ancient Figurine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaartrapper",
        "tags": [
            "tuskaartrapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhelmofvalor",
        "tags": [
            "Helm of Valor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn_ringjadefalcon",
        "tags": [
            "_ringjadefalcon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncloak",
        "tags": [
            "Cloak of Shadows",
            "Shadow Meld (Item)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigoelder",
        "tags": [
            "wendigoelder"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnelunesblessing",
        "tags": [
            "Elune's Grace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselectheroon",
        "tags": [
            "Secret Level Powerup",
            "Shop Sharing",
            "Allied Bldg.",
            "Select Hero",
            "Select Unit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpackbeast",
        "tags": [
            "Unit Inventory",
            "Pack Mule"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobeofthemagi",
        "tags": [
            "Robe of the Magi +6",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionofomniscience",
        "tags": [
            "Potion of Omniscience",
            "Item Reveal Entire Map"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnecromanceradept",
        "tags": [
            "Tome of Sacrifices"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghostkey",
        "tags": [
            "Ghost Key"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbundleoflumber",
        "tags": [
            "Bundle of Lumber"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfirerocks",
        "tags": [
            "Burning Oil"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnliquidfire",
        "tags": [
            "Liquid Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpipeofinsight",
        "tags": [
            "Khadgar's Pipe of Insight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanetower",
        "tags": [
            "arcanetower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrificialdagger",
        "tags": [
            "Ritual Dagger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkelthuzadcin",
        "tags": [
            "kelthuzadcin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslippersofagility",
        "tags": [
            "Slippers of Agility +3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowpact",
        "tags": [
            "Voodoo Doll",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritlink",
        "tags": [
            "Spirit Link"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionbluebig",
        "tags": [
            "Potion of Greater Mana",
            "Item Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbootsofspeed",
        "tags": [
            "Boots of Speed",
            "Item Move Speed Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanastone",
        "tags": [
            "Mana Stone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolymorph",
        "tags": [
            "Polymorph"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnazzyscrollgreen",
        "tags": [
            "Scroll of the Beast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btn3m3",
        "tags": [
            "Key of Three Moons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaibarracks",
        "tags": [
            "dranaibarracks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscrollofhealing",
        "tags": [
            "Scroll of Restoration",
            "Item Area Heal/Mana Regain",
            "Rune Area Heal/Mana Regain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshimmerweed",
        "tags": [
            "Shimmerweed"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserrejuvscroll",
        "tags": [
            "Lesser Scroll of Replenishment ",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodluston",
        "tags": [
            "Frenzy",
            "Bloodlust"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnminorrejuvpotion",
        "tags": [
            "Minor Replenishment Potion",
            "Generic Item-Rejuv Effect"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthoriumarmor",
        "tags": [
            "Enchanted Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbookbls",
        "tags": [
            "Spell Book"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnparasite",
        "tags": [
            "Parasite"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlightningshield",
        "tags": [
            "Shield of the Deathlord",
            "Lightning Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofpreservation",
        "tags": [
            "Staff of Preservation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbansheeadept",
        "tags": [
            "Arcane Scroll"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumancaptureflag",
        "tags": [
            "Human Flag",
            "Item Capture The Flag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpendantofenergy",
        "tags": [
            "Pendant of Energy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndisenchant",
        "tags": [
            "Disenchant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmedalionofcourage",
        "tags": [
            "Medallion of Courage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsoulgem",
        "tags": [
            "Soul Gem",
            "Item Soul Theft"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofteleportation",
        "tags": [
            "Staff of Teleportation"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnimmolation",
        "tags": [
            "Permanent Immolation",
            "Phoenix Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderlizarddiamond",
        "tags": [
            "thunderlizarddiamond"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwand",
        "tags": [
            "Wand of Illusion",
            "Item Illusions"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsentry",
        "tags": [
            "sentry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphilosophersstone",
        "tags": [
            "Bloodfeather's Heart",
            "Random Item"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhammer",
        "tags": [
            "Maul of Strength",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalkeradepttraining",
        "tags": [
            "Killmaim"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoldring",
        "tags": [
            "Ring of Superiority",
            "Item Hero Stat Bonus"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspirithawk",
        "tags": [
            "spirithawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbansheemaster",
        "tags": [
            "Scroll of the Unholy Legion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpendantofmana",
        "tags": [
            "Pendant of Mana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellstealoff",
        "tags": [
            "spellstealoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheartofsearinox",
        "tags": [
            "The Heart of Searinox"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnenvenomedspear",
        "tags": [
            "Envenomed Spears",
            "Envenomed Weapons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndizzy",
        "tags": [
            "Dizziness",
            "Dark Portal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrepairon",
        "tags": [
            "Repair",
            "Restore"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfreezingbreath",
        "tags": [
            "Freezing Breath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncommand",
        "tags": [
            "Endurance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobogoblinoff",
        "tags": [
            "robogoblinoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaihut2",
        "tags": [
            "dranaihut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreturngoods",
        "tags": [
            "Charge Gold and Lumber"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncorrosivebreath",
        "tags": [
            "Corrosive Breath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngolemthunderclap",
        "tags": [
            "Slam"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnslowpoison",
        "tags": [
            "Slow Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofagility",
        "tags": [
            "tomeofagility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanaflare",
        "tags": [
            "Mana Flare"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarkskin",
        "tags": [
            "Barkskin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbigbadvoodoospell",
        "tags": [
            "Big Bad Voodoo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealingspray",
        "tags": [
            "Healing Spray"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishmana",
        "tags": [
            "Spirit Touch",
            "Replenish"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostarmor",
        "tags": [
            "Frost Armor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnensnare",
        "tags": [
            "Ensnare",
            "Ensnare (General)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnclusterrockets",
        "tags": [
            "Cluster Rockets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslowon",
        "tags": [
            "Slow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvampiricaura",
        "tags": [
            "Vampiric Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguardiangolem",
        "tags": [
            "guardiangolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanimatedead",
        "tags": [
            "Animate Dead",
            "Item Animate Dead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstampede",
        "tags": [
            "Stampede"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollberserker",
        "tags": [
            "foresttrollberserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslowpoison",
        "tags": [
            "Slow Poison"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfire",
        "tags": [
            "Rain of Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndocmastertraining",
        "tags": [
            "docmastertraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldarrows",
        "tags": [
            "Cold Arrows"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnwellspring",
        "tags": [
            "Well Spring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninvisibility",
        "tags": [
            "Invisibility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselfdestruct",
        "tags": [
            "selfdestruct"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpandataunt",
        "tags": [
            "Taunt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnincinerate",
        "tags": [
            "Incinerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydrawarstomp",
        "tags": [
            "War Stomp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsapphironundead",
        "tags": [
            "sapphironundead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrongdrink",
        "tags": [
            "Drunken Haze"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncurse",
        "tags": [
            "Curse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvolcano",
        "tags": [
            "Volcano"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndevour",
        "tags": [
            "Devour"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthorns",
        "tags": [
            "Thorns Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncontrolmagic",
        "tags": [
            "Control Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncloudoffog",
        "tags": [
            "Cloud",
            "Cloud of Fog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndevotion",
        "tags": [
            "Devotion Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpossession",
        "tags": [
            "Possession"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnneutralmanashield",
        "tags": [
            "Mana Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnweb",
        "tags": [
            "Web"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncannibalize",
        "tags": [
            "Cannibalize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncalltoarms",
        "tags": [
            "Militia",
            "Call to Arms",
            "Call To Arms"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndivineintervention",
        "tags": [
            "Divine Shield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnetherealformon",
        "tags": [
            "Ethereal Form"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedstrengthofthewild",
        "tags": [
            "improvedstrengthofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchemicalrage",
        "tags": [
            "Chemical Rage"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncriticalstrike",
        "tags": [
            "Critical Strike"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderclap",
        "tags": [
            "Thunder Clap"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnearthquake",
        "tags": [
            "Earthquake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhowlofterror",
        "tags": [
            "Howl of Terror"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathanddecay",
        "tags": [
            "Death and Decay",
            "Death And Decay"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninvulnerable",
        "tags": [
            "Invulnerable"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbattlestations",
        "tags": [
            "Battle Stations"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncripple",
        "tags": [
            "Cripple"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavataroff",
        "tags": [
            "avataroff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriefire",
        "tags": [
            "Faerie Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarden",
        "tags": [
            "warden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormearth&fire",
        "tags": [
            "Pandaren Elemental",
            "Storm",
            "Earth",
            "And Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantbehemoth",
        "tags": [
            "seagiantbehemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimmolationon",
        "tags": [
            "Immolation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurenchieftain",
        "tags": [
            "taurenchieftain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodfiend",
        "tags": [
            "bloodfiend"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlifedrain",
        "tags": [
            "Life Drain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrushingwave",
        "tags": [
            "Crushing Wave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingarrowson",
        "tags": [
            "Searing Arrows",
            "Poison Arrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelfbuild",
        "tags": [
            "Build (Night Elf)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantwarstomp",
        "tags": [
            "War Stomp"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnanimalwartraining",
        "tags": [
            "Animal War Training"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnapprenticewizard",
        "tags": [
            "apprenticewizard"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndemolish",
        "tags": [
            "Demolish"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnbrilliance",
        "tags": [
            "Brilliance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormwyrm",
        "tags": [
            "stormwyrm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanaburn",
        "tags": [
            "Mana Burn"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherofemaledeathknight",
        "tags": [
            "herofemaledeathknight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndwarvenlongrifle",
        "tags": [
            "dwarvenlongrifle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncryptfiendburrow",
        "tags": [
            "Burrow"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndrunkendodge",
        "tags": [
            "Drunken Brawler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionswarm",
        "tags": [
            "Carrion Swarm"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfragmentationbombs",
        "tags": [
            "fragmentationbombs"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnvampiricaura",
        "tags": [
            "Vampiric Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstrengthofthewild",
        "tags": [
            "strengthofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncleavingattack",
        "tags": [
            "Cleaving Attack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellstealon",
        "tags": [
            "Spell Steal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadloadon",
        "tags": [
            "Get Corpse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsell",
        "tags": [
            "Sell Items"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunload",
        "tags": [
            "Unload",
            "Unload Instant"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncommand",
        "tags": [
            "Endurance Aura"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnupgrademoonglaive",
        "tags": [
            "Moon Glaive"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmoonarmor",
        "tags": [
            "moonarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypoint",
        "tags": [
            "Rally"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnevasion",
        "tags": [
            "Evasion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazuredrake",
        "tags": [
            "azuredrake"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtndevotion",
        "tags": [
            "Devotion Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfaeriefireon",
        "tags": [
            "Faerie Fire"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnblink",
        "tags": [
            "Blink (Item Version)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentauroutrunner",
        "tags": [
            "centauroutrunner"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnsmash",
        "tags": [
            "Pulverize,Pulverize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntranquility",
        "tags": [
            "Tranquility"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeathpact",
        "tags": [
            "Death Pact",
            "Channel"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtncorrosivebreath",
        "tags": [
            "Corrosive Breath"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnregenerationaura",
        "tags": [
            "Aura of Blight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmonsoon",
        "tags": [
            "Forked Lightning",
            "Monsoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnambush",
        "tags": [
            "Shadow Meld"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnreincarnation",
        "tags": [
            "Reincarnation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryaddispelmagicon",
        "tags": [
            "Abolish Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreveal",
        "tags": [
            "Reveal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacredrelic",
        "tags": [
            "sacredrelic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshockwave",
        "tags": [
            "Shockwave"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnincinerateon",
        "tags": [
            "Incinerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazorbackbrute",
        "tags": [
            "razorbackbrute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselfdestructon",
        "tags": [
            "Kaboom!"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngolemstormbolt",
        "tags": [
            "Hurl Boulder"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtngenericspellimmunity",
        "tags": [
            "Spell Immunity",
            "Spell Immunity"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnmagicimmunity",
        "tags": [
            "Spell Immunity"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnthorns",
        "tags": [
            "Thorns Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninnerfireoff",
        "tags": [
            "innerfireoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwebon",
        "tags": [
            "Web",
            "Item Web"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncharm",
        "tags": [
            "Charm"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnhumanartilleryupone",
        "tags": [
            "Flying Machine Bombs"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhealon",
        "tags": [
            "Item Healing"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnshadetruesight",
        "tags": [
            "True Sight"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnresistantskin",
        "tags": [
            "resistantskin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsentinel",
        "tags": [
            "Sentinel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraisedead",
        "tags": [
            "Raise Dead (Item)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvillagekid2",
        "tags": [
            "villagekid2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndevourmagic",
        "tags": [
            "Devour Magic"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfreezingbreath",
        "tags": [
            "Freezing Breath"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscourgebuild",
        "tags": [
            "Build (Undead)"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnseagiantpulverize",
        "tags": [
            "Pulverize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchainlightning",
        "tags": [
            "Chain Lightning"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhire",
        "tags": [
            "Sell Units"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforceofnature",
        "tags": [
            "forceofnature"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsacrifice",
        "tags": [
            "Sacrifice"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfanofknives",
        "tags": [
            "Fan of Knives"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnfrost",
        "tags": [
            "Frost Attack"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnimprovedbows",
        "tags": [
            "Improved Bows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormbolt",
        "tags": [
            "Storm Bolt"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnhumanlumberupgrade1",
        "tags": [
            "Improved Lumber Harvesting,Improved Lumber Harvesting,Advanced Lumber Harvesting"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnregenerate",
        "tags": [
            "Troll Regeneration"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnparasiteon",
        "tags": [
            "Parasite"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnincinerate",
        "tags": [
            "Incinerate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbacktowork",
        "tags": [
            "Stand Down"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnreinforcedburrows",
        "tags": [
            "Reinforced Defenses"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestv0",
        "tags": [
            "priestv0"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstarfall",
        "tags": [
            "Starfall"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmalfurion",
        "tags": [
            "malfurion"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnheadhunterberserker",
        "tags": [
            "Berserker Upgrade"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnmagicalsentry",
        "tags": [
            "Magic Sentry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrimoireofsouls",
        "tags": [
            "grimoireofsouls"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarkritual",
        "tags": [
            "Dark Ritual"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndispelmagic",
        "tags": [
            "Dispel Magic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadunload",
        "tags": [
            "Drop Corpse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnazgalor",
        "tags": [
            "azgalor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfectedgranary",
        "tags": [
            "infectedgranary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndirefrostwolf",
        "tags": [
            "direfrostwolf"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnberserk",
        "tags": [
            "Brute Strength"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtngnollcommandaura",
        "tags": [
            "Command Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimpalingbolt",
        "tags": [
            "impalingbolt"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbearblink",
        "tags": [
            "Blink"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnunholyaura",
        "tags": [
            "Unholy Aura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthundersalamandervizier",
        "tags": [
            "thundersalamandervizier"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanbuild",
        "tags": [
            "Build (Human)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbreakermagicdefend",
        "tags": [
            "Magic Defense"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreengiant",
        "tags": [
            "seaturtlegreengiant"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnghoulfrenzy",
        "tags": [
            "Ghoul Frenzy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsiegegolem",
        "tags": [
            "siegegolem"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnshade",
        "tags": [
            "Shade"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnspikedbarricades",
        "tags": [
            "Spiked Barricades,Spiked Barricades,Improved Spiked Barricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfireforthecannon",
        "tags": [
            "Breath of Fire"
        ]
    },
    {
        "src": "replaceabletextures\\passivebuttons\\pasbtnpillage",
        "tags": [
            "Pillage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedcreatureattack",
        "tags": [
            "advancedcreatureattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedcreaturecarapace",
        "tags": [
            "advancedcreaturecarapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedmoonarmor",
        "tags": [
            "advancedmoonarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedreinforcedhides",
        "tags": [
            "advancedreinforcedhides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedstrengthofthemoon",
        "tags": [
            "advancedstrengthofthemoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreengargantuan",
        "tags": [
            "seaturtlegreengargantuan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvancedunholyarmor",
        "tags": [
            "advancedunholyarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurtent1",
        "tags": [
            "centaurtent1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnadvstruct",
        "tags": [
            "advstruct"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanimalwartraining",
        "tags": [
            "animalwartraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnanubarak",
        "tags": [
            "anubarak"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntent2",
        "tags": [
            "tent2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarachnathidearthborer",
        "tags": [
            "arachnathidearthborer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarcanescroll",
        "tags": [
            "arcanescroll"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarthasevil",
        "tags": [
            "arthasevil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnauraofdarkness",
        "tags": [
            "auraofdarkness"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnarthasfrost",
        "tags": [
            "arthasfrost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarwarlock",
        "tags": [
            "eredarwarlock"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnassassinsblade",
        "tags": [
            "assassinsblade"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollwarlord",
        "tags": [
            "darktrollwarlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnattack",
        "tags": [
            "attack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnattackground",
        "tags": [
            "attackground"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingassassinoff",
        "tags": [
            "avengingassassinoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingassassinon",
        "tags": [
            "avengingassassinon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnavengingwatcheroff",
        "tags": [
            "avengingwatcheroff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnballista",
        "tags": [
            "ballista"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselfdestructoff",
        "tags": [
            "selfdestructoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbalnazzar",
        "tags": [
            "balnazzar"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbarkskinon",
        "tags": [
            "barkskinon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnillidan",
        "tags": [
            "illidan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserkelemental",
        "tags": [
            "berserkelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncurseoff",
        "tags": [
            "curseoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmuradinbronzebeard",
        "tags": [
            "muradinbronzebeard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnberserkwildkin",
        "tags": [
            "berserkwildkin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbladebanearmor",
        "tags": [
            "bladebanearmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbloodlustoff",
        "tags": [
            "bloodlustoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulhut2",
        "tags": [
            "murgulhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzebowlfull",
        "tags": [
            "bronzebowlfull"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedragonroost",
        "tags": [
            "bronzedragonroost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndagrentheorcslayer",
        "tags": [
            "dagrentheorcslayer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnbronzedragonwhelp",
        "tags": [
            "bronzedragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillageruined",
        "tags": [
            "nightelffishingvillageruined"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncagedlllidan",
        "tags": [
            "cagedlllidan"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnburningarcher",
        "tags": [
            "burningarcher"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage1",
        "tags": [
            "cage1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncage3",
        "tags": [
            "cage3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncairnebloodhoof",
        "tags": [
            "cairnebloodhoof"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabslv1",
        "tags": [
            "carrionscarabslv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabslv2",
        "tags": [
            "carrionscarabslv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabslv3",
        "tags": [
            "carrionscarabslv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncarrionscarabsoff",
        "tags": [
            "carrionscarabsoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncenarius",
        "tags": [
            "cenarius"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmantle",
        "tags": [
            "mantle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncenariusnightmare",
        "tags": [
            "cenariusnightmare"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncentaurtent3",
        "tags": [
            "centaurtent3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnchime",
        "tags": [
            "chime"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncoldarrowsoff",
        "tags": [
            "coldarrowsoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillsprayoff",
        "tags": [
            "quillsprayoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngemfragment",
        "tags": [
            "gemfragment"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncrate",
        "tags": [
            "crate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsasquatchoracle",
        "tags": [
            "sasquatchoracle"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btncreatureattack",
        "tags": [
            "creatureattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndalvengyr",
        "tags": [
            "dalvengyr"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollberserker",
        "tags": [
            "darktrollberserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcshipyard",
        "tags": [
            "orcshipyard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneldervoidwalker",
        "tags": [
            "eldervoidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndarktrollhighpriest",
        "tags": [
            "darktrollhighpriest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelunesblessing",
        "tags": [
            "elunesblessing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndeceiver",
        "tags": [
            "deceiver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndefendergolem",
        "tags": [
            "defendergolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndefendstop",
        "tags": [
            "defendstop"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndemolish",
        "tags": [
            "demolish"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndenofwonders",
        "tags": [
            "denofwonders"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndepthsrevenant",
        "tags": [
            "depthsrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndetheroc",
        "tags": [
            "detheroc"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndirewolflv2",
        "tags": [
            "direwolflv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndivineshieldoff",
        "tags": [
            "divineshieldoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastlv4",
        "tags": [
            "quillbeastlv4"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndocadepttraining",
        "tags": [
            "docadepttraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndotadepttraining",
        "tags": [
            "dotadepttraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndotmastertraining",
        "tags": [
            "dotmastertraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedcrows",
        "tags": [
            "enchantedcrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawkrider",
        "tags": [
            "dragonhawkrider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaarmorup3",
        "tags": [
            "nagaarmorup3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawkriderv0",
        "tags": [
            "dragonhawkriderv0"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaarmorup2",
        "tags": [
            "nagaarmorup2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonhawkriderv1",
        "tags": [
            "dragonhawkriderv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonspawnoverseer",
        "tags": [
            "dragonspawnoverseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndragonturtlered",
        "tags": [
            "dragonturtlered"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrain",
        "tags": [
            "drain"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiharbinger",
        "tags": [
            "dranaiharbinger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaihaven",
        "tags": [
            "dranaihaven"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiprotocter",
        "tags": [
            "dranaiprotocter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaiseer",
        "tags": [
            "dranaiseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmeatapult",
        "tags": [
            "meatapult"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaistalker",
        "tags": [
            "dranaistalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndranaivindicator",
        "tags": [
            "dranaivindicator"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrektharsspellbook",
        "tags": [
            "drektharsspellbook"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressv1",
        "tags": [
            "sorceressv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndrunkendodge",
        "tags": [
            "drunkendodge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv2",
        "tags": [
            "mishalv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btndryaddispelmagic",
        "tags": [
            "dryaddispelmagic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnearthfurytower",
        "tags": [
            "earthfurytower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelderhydra",
        "tags": [
            "elderhydra"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelderjunglebeast",
        "tags": [
            "elderjunglebeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnelvenfarm2",
        "tags": [
            "elvenfarm2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnemissary",
        "tags": [
            "emissary"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkoboldtunneler",
        "tags": [
            "koboldtunneler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedbear",
        "tags": [
            "enchantedbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenchantedbears",
        "tags": [
            "enchantedbears"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenforcer",
        "tags": [
            "enforcer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmudgolem",
        "tags": [
            "mudgolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanmissileuptwo",
        "tags": [
            "humanmissileuptwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnengineergazlowe",
        "tags": [
            "engineergazlowe"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenragedelemental",
        "tags": [
            "enragedelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlesserspiritbeast",
        "tags": [
            "lesserspiritbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnenragedwildkin",
        "tags": [
            "enragedwildkin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnholdposition",
        "tags": [
            "holdposition"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarred",
        "tags": [
            "eredarred"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlightninglizard",
        "tags": [
            "lightninglizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarsorcerer",
        "tags": [
            "eredarsorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btneredarwarloc",
        "tags": [
            "eredarwarloc"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnexhumecorpses",
        "tags": [
            "exhumecorpses"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreatervoidwalker",
        "tags": [
            "greatervoidwalker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnexpandedview",
        "tags": [
            "expandedview"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragonroost",
        "tags": [
            "reddragonroost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfacelessonedeathbringer",
        "tags": [
            "facelessonedeathbringer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochut3",
        "tags": [
            "murlochut3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfacelessoneterror",
        "tags": [
            "facelessoneterror"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskullshield",
        "tags": [
            "skullshield"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfallenkingarthas",
        "tags": [
            "fallenkingarthas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfeedback",
        "tags": [
            "feedback"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollwarlord",
        "tags": [
            "icetrollwarlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfeltrollburrow",
        "tags": [
            "feltrollburrow"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfemalemetamorphosis",
        "tags": [
            "femalemetamorphosis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfiregauntlet",
        "tags": [
            "firegauntlet"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfiregauntlets",
        "tags": [
            "firegauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulsnarecaster",
        "tags": [
            "murgulsnarecaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirerevenant",
        "tags": [
            "firerevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfirerocks",
        "tags": [
            "firerocks"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflakcannons",
        "tags": [
            "flakcannons"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpackhorse",
        "tags": [
            "packhorse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflamingarrows",
        "tags": [
            "flamingarrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollhut1",
        "tags": [
            "foresttrollhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflaregun",
        "tags": [
            "flaregun"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnflute",
        "tags": [
            "flute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollhighpriest",
        "tags": [
            "foresttrollhighpriest"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnforesttrollhut2",
        "tags": [
            "foresttrollhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainofmana",
        "tags": [
            "fountainofmana"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedmining",
        "tags": [
            "improvedmining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfountainofpower",
        "tags": [
            "fountainofpower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostarmoroff",
        "tags": [
            "frostarmoroff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnaturesblessing",
        "tags": [
            "naturesblessing"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfrostrevenant",
        "tags": [
            "frostrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgchampion",
        "tags": [
            "furbolgchampion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolgeldershaman",
        "tags": [
            "furbolgeldershaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnfurbolghut2",
        "tags": [
            "furbolghut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngarthok",
        "tags": [
            "garthok"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnholywater",
        "tags": [
            "holywater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenerichumanbuilding1",
        "tags": [
            "generichumanbuilding1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngenericspellimmunity",
        "tags": [
            "genericspellimmunity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngerardslostledger",
        "tags": [
            "gerardslostledger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnghoulfrenzy",
        "tags": [
            "ghoulfrenzy"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkegofthunderwater",
        "tags": [
            "kegofthunderwater"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantfrostbear",
        "tags": [
            "giantfrostbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypoint",
        "tags": [
            "rallypoint"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantspider",
        "tags": [
            "giantspider"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngiantwolf",
        "tags": [
            "giantwolf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollassassin",
        "tags": [
            "gnollassassin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollbrute",
        "tags": [
            "gnollbrute"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngnollcommandaura",
        "tags": [
            "gnollcommandaura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlavaspawnlv2",
        "tags": [
            "lavaspawnlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinmerchant",
        "tags": [
            "goblinmerchant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntent1",
        "tags": [
            "tent1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpyrogue",
        "tags": [
            "harpyrogue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngoblinshredder",
        "tags": [
            "goblinshredder"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngrainwarehouse",
        "tags": [
            "grainwarehouse"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulcliffrunner",
        "tags": [
            "murgulcliffrunner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterdarkminion",
        "tags": [
            "greaterdarkminion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreaterspiritbeast",
        "tags": [
            "greaterspiritbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngreendragonwhelp",
        "tags": [
            "greendragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguarddog",
        "tags": [
            "guarddog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnguardianward",
        "tags": [
            "guardianward"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btngyrocopter",
        "tags": [
            "gyrocopter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhardenedskin",
        "tags": [
            "hardenedskin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpynest1",
        "tags": [
            "harpynest1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseaturtlegreenhatchling",
        "tags": [
            "seaturtlegreenhatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpynest2",
        "tags": [
            "harpynest2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnharpystormhag",
        "tags": [
            "harpystormhag"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsalamanderhatchling",
        "tags": [
            "salamanderhatchling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheretic",
        "tags": [
            "heretic"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemistlv1",
        "tags": [
            "heroalchemistlv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemistlv2",
        "tags": [
            "heroalchemistlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheroalchemistlv3",
        "tags": [
            "heroalchemistlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnogremauler",
        "tags": [
            "ogremauler"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherofemaledemonhunter",
        "tags": [
            "herofemaledemonhunter"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshamanclaws",
        "tags": [
            "shamanclaws"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnherolich",
        "tags": [
            "herolich"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnheromoonpriestess",
        "tags": [
            "heromoonpriestess"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelfarchmage",
        "tags": [
            "highelfarchmage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhighelfrunner",
        "tags": [
            "highelfrunner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhornofcenariuspedestal",
        "tags": [
            "hornofcenariuspedestal"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarmorupone",
        "tags": [
            "humanarmorupone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanarmoruptwo",
        "tags": [
            "humanarmoruptwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanartilleryupone",
        "tags": [
            "humanartilleryupone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpoisonent",
        "tags": [
            "poisonent"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanlumberupgrade1",
        "tags": [
            "humanlumberupgrade1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanmissileupone",
        "tags": [
            "humanmissileupone"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspellbreakermagicundefend",
        "tags": [
            "spellbreakermagicundefend"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhumanmissileupthree",
        "tags": [
            "humanmissileupthree"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydra",
        "tags": [
            "hydra"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnhydromancer",
        "tags": [
            "hydromancer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicerevenant",
        "tags": [
            "icerevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollberserker",
        "tags": [
            "icetrollberserker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrollhut2",
        "tags": [
            "icetrollhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnicetrolltrapper",
        "tags": [
            "icetrolltrapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnillidandemonform",
        "tags": [
            "illidandemonform"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnillidanprisonwagon",
        "tags": [
            "illidanprisonwagon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigoshaman",
        "tags": [
            "wendigoshaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkredsnapper",
        "tags": [
            "lobstrokkredsnapper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimbuedmasonry",
        "tags": [
            "imbuedmasonry"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimmolationoff",
        "tags": [
            "immolationoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedcreatureattack",
        "tags": [
            "improvedcreatureattack"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedcreaturecarapace",
        "tags": [
            "improvedcreaturecarapace"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedreinforcedhides",
        "tags": [
            "improvedreinforcedhides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedspikedbarricades",
        "tags": [
            "improvedspikedbarricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedstrenghtofthewild",
        "tags": [
            "improvedstrenghtofthewild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnimprovedstrengthofthemoon",
        "tags": [
            "improvedstrengthofthemoon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnincinerateoff",
        "tags": [
            "incinerateoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btninfernalmachine",
        "tags": [
            "infernalmachine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypointundead",
        "tags": [
            "rallypointundead"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjainanote",
        "tags": [
            "jainanote"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthornyshieldoff",
        "tags": [
            "thornyshieldoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjainasea",
        "tags": [
            "jainasea"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritwalkermastertraining",
        "tags": [
            "spiritwalkermastertraining"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnjennalladeemspring",
        "tags": [
            "jennalladeemspring"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkillmaim",
        "tags": [
            "killmaim"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnkoboldtaskmaster",
        "tags": [
            "koboldtaskmaster"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlament",
        "tags": [
            "lament"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlamp",
        "tags": [
            "lamp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlavaspawnlv3",
        "tags": [
            "lavaspawnlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnleatherupgradethree",
        "tags": [
            "leatherupgradethree"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidercrabbehemoth",
        "tags": [
            "spidercrabbehemoth"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnleatherupgradetwo",
        "tags": [
            "leatherupgradetwo"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlgexchange",
        "tags": [
            "lgexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlichkingcin",
        "tags": [
            "lichkingcin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlightningrevenant",
        "tags": [
            "lightningrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnloadpeon",
        "tags": [
            "loadpeon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkdeepseer",
        "tags": [
            "lobstrokkdeepseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnlobstrokkredpooldweller",
        "tags": [
            "lobstrokkredpooldweller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagicimmunity",
        "tags": [
            "magicimmunity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmagtheridon",
        "tags": [
            "magtheridon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmalganis",
        "tags": [
            "malganis"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnproudmoore",
        "tags": [
            "proudmoore"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanarecharge",
        "tags": [
            "manarecharge"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanarechargeoff",
        "tags": [
            "manarechargeoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmanual2",
        "tags": [
            "manual2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmathog",
        "tags": [
            "mathog"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmgexchange",
        "tags": [
            "mgexchange"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmishalv1",
        "tags": [
            "mishalv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmogrinsreport",
        "tags": [
            "mogrinsreport"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmossgolem",
        "tags": [
            "mossgolem"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulhut1",
        "tags": [
            "murgulhut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurgulmarauder",
        "tags": [
            "murgulmarauder"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochuntsman",
        "tags": [
            "murlochuntsman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochut1",
        "tags": [
            "murlochut1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnmurlochut2",
        "tags": [
            "murlochut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarbrownhealer",
        "tags": [
            "tuskaarbrownhealer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaarmorup1",
        "tags": [
            "nagaarmorup1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarsorcerer",
        "tags": [
            "tuskaarsorcerer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnagaweaponup2",
        "tags": [
            "nagaweaponup2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianseer",
        "tags": [
            "nerubianseer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianwarrior",
        "tags": [
            "nerubianwarrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnerubianwebspinner",
        "tags": [
            "nerubianwebspinner"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnetherdragonwhelp",
        "tags": [
            "netherdragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnneutralmanashieldoff",
        "tags": [
            "neutralmanashieldoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingboat",
        "tags": [
            "nightelffishingboat"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagecrested",
        "tags": [
            "nightelffishingvillagecrested"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshamanadept",
        "tags": [
            "shamanadept"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagecrestedruined",
        "tags": [
            "nightelffishingvillagecrestedruined"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagetwostory",
        "tags": [
            "nightelffishingvillagetwostory"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnnightelffishingvillagetwostoryruined",
        "tags": [
            "nightelffishingvillagetwostoryruined"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorb",
        "tags": [
            "orb"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofdeathoff",
        "tags": [
            "orbofdeathoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorbofkiljaeden",
        "tags": [
            "orbofkiljaeden"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcrallypoint",
        "tags": [
            "orcrallypoint"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlockapprentice",
        "tags": [
            "orcwarlockapprentice"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnorcwarlocknecrolyte",
        "tags": [
            "orcwarlocknecrolyte"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnotherbarrel",
        "tags": [
            "otherbarrel"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnowlscoutlv1",
        "tags": [
            "owlscoutlv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpebble",
        "tags": [
            "pebble"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnparasiteoff",
        "tags": [
            "parasiteoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphaseshiftoff",
        "tags": [
            "phaseshiftoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnphoenix",
        "tags": [
            "phoenix"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpillage",
        "tags": [
            "pillage"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpocketfactorylv2",
        "tags": [
            "pocketfactorylv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpoisonsting",
        "tags": [
            "poisonsting"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgchampion",
        "tags": [
            "polarfurbolgchampion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpolarfurbolgeldershaman",
        "tags": [
            "polarfurbolgeldershaman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpotionblue",
        "tags": [
            "potionblue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholyarmor",
        "tags": [
            "unholyarmor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnpriestv1",
        "tags": [
            "priestv1"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnqueenofsuffering",
        "tags": [
            "queenofsuffering"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastgod",
        "tags": [
            "quillbeastgod"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnquillbeastlv3",
        "tags": [
            "quillbeastlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnragingbear",
        "tags": [
            "ragingbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnraisedeadoff",
        "tags": [
            "raisedeadoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrallypointnightelf",
        "tags": [
            "rallypointnightelf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrazormanemedicineman",
        "tags": [
            "razormanemedicineman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddragonwhelp",
        "tags": [
            "reddragonwhelp"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreddrake",
        "tags": [
            "reddrake"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreefelemental",
        "tags": [
            "reefelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreinforcedburrows",
        "tags": [
            "reinforcedburrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreinforcedhides",
        "tags": [
            "reinforcedhides"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrejuvenationpotion",
        "tags": [
            "rejuvenationpotion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrenegadewizard",
        "tags": [
            "renegadewizard"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofintelligence",
        "tags": [
            "tomeofintelligence"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrepair",
        "tags": [
            "repair"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrepairoff",
        "tags": [
            "repairoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnreplenishhealthoff",
        "tags": [
            "replenishhealthoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringjadefalcon (2)",
        "tags": [
            "ringjadefalcon (2)"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnringofthearchmagi",
        "tags": [
            "ringofthearchmagi"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrobogoblinon",
        "tags": [
            "robogoblinon"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrogue",
        "tags": [
            "rogue"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrunedgauntlets",
        "tags": [
            "runedgauntlets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnrustyminingpick",
        "tags": [
            "rustyminingpick"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsapphironliving",
        "tags": [
            "sapphironliving"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrhellcaller",
        "tags": [
            "satyrhellcaller"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsatyrsoulstealer",
        "tags": [
            "satyrsoulstealer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscatterrockets",
        "tags": [
            "scatterrockets"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscepterofthesea",
        "tags": [
            "scepterofthesea"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnscouttower",
        "tags": [
            "scouttower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseagiantpulverize",
        "tags": [
            "seagiantpulverize"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingarrows",
        "tags": [
            "searingarrows"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearingarrowsoff",
        "tags": [
            "searingarrowsoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsearinox",
        "tags": [
            "searinox"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnseasrevenant",
        "tags": [
            "seasrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnselectunit",
        "tags": [
            "selectunit"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserathil",
        "tags": [
            "serathil"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentwardlv2",
        "tags": [
            "serpentwardlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentwardlv3",
        "tags": [
            "serpentwardlv3"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnserpentwardlv4",
        "tags": [
            "serpentwardlv4"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadowmeld",
        "tags": [
            "shadowmeld"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshadoworbfragment",
        "tags": [
            "shadoworbfragment"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshieldofdeathlord",
        "tags": [
            "shieldofdeathlord"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshieldofhonor",
        "tags": [
            "shieldofhonor"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnshimmerglazeroast",
        "tags": [
            "shimmerglazeroast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsiegeengine",
        "tags": [
            "siegeengine"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsiegeenginewithmissiles",
        "tags": [
            "siegeenginewithmissiles"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsirenadept",
        "tags": [
            "sirenadept"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsirgregoryedmunson",
        "tags": [
            "sirgregoryedmunson"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletallongevity",
        "tags": [
            "skeletallongevity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskeletalmarskman",
        "tags": [
            "skeletalmarskman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskillz",
        "tags": [
            "skillz"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnskyfurytower",
        "tags": [
            "skyfurytower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnslowoff",
        "tags": [
            "slowoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsmash",
        "tags": [
            "smash"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsnarlmanethebloodgorger",
        "tags": [
            "snarlmanethebloodgorger"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsorceressv0",
        "tags": [
            "sorceressv0"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsoul",
        "tags": [
            "soul"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspidercrablimbripper",
        "tags": [
            "spidercrablimbripper"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiderling",
        "tags": [
            "spiderling"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspikedbarricades",
        "tags": [
            "spikedbarricades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritbear",
        "tags": [
            "spiritbear"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnspiritbeast",
        "tags": [
            "spiritbeast"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofpreservation2",
        "tags": [
            "staffofpreservation2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofpurification",
        "tags": [
            "staffofpurification"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstaffofreanimation",
        "tags": [
            "staffofreanimation"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstatup",
        "tags": [
            "statup"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsteelmelee",
        "tags": [
            "steelmelee"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsteelranged",
        "tags": [
            "steelranged"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstonearchitecture",
        "tags": [
            "stonearchitecture"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnstormhammer",
        "tags": [
            "stormhammer"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsturdywaraxe",
        "tags": [
            "sturdywaraxe"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnswordsman",
        "tags": [
            "swordsman"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsylvanas",
        "tags": [
            "sylvanas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnsylvanasghost",
        "tags": [
            "sylvanasghost"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntamehippogriff",
        "tags": [
            "tamehippogriff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwateryminionlv2",
        "tags": [
            "wateryminionlv2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntaurenhut2",
        "tags": [
            "taurenhut2"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthaloriendawnseeker",
        "tags": [
            "thaloriendawnseeker"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntharifas",
        "tags": [
            "tharifas"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthievesguild",
        "tags": [
            "thievesguild"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthoriumranged",
        "tags": [
            "thoriumranged"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthrallchampion",
        "tags": [
            "thrallchampion"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnthunderhawk",
        "tags": [
            "thunderhawk"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntidesrevenant",
        "tags": [
            "tidesrevenant"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofpower",
        "tags": [
            "tomeofpower"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntomeofsacrifices",
        "tags": [
            "tomeofsacrifices"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntranqulity",
        "tags": [
            "tranqulity"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btntuskaarwarrior",
        "tags": [
            "tuskaarwarrior"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnultravision",
        "tags": [
            "ultravision"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunbrokendarkweaver",
        "tags": [
            "unbrokendarkweaver"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadload",
        "tags": [
            "undeadload"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnundeadloadoff",
        "tags": [
            "undeadloadoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunholystrength",
        "tags": [
            "unholystrength"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnunloaddwarf",
        "tags": [
            "unloaddwarf"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnupgraderegenerationaura",
        "tags": [
            "upgraderegenerationaura"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnuther",
        "tags": [
            "uther"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvengeanceincarnate",
        "tags": [
            "vengeanceincarnate"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnviletemptress",
        "tags": [
            "viletemptress"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvoljin",
        "tags": [
            "voljin"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnvorpalblades",
        "tags": [
            "vorpalblades"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwarriorarachnathid",
        "tags": [
            "warriorarachnathid"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwaterelemental",
        "tags": [
            "waterelemental"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnweboff",
        "tags": [
            "weboff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwendigoancient",
        "tags": [
            "wendigoancient"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwisphealoff",
        "tags": [
            "wisphealoff"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnwraith",
        "tags": [
            "wraith"
        ]
    },
    {
        "src": "replaceabletextures\\commandbuttons\\btnzombiefemale",
        "tags": [
            "zombiefemale"
        ]
    }
]

```

`LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.
```

`README.md`:

```md
# HiveWE
HiveWE is a Warcraft III World Editor (WE) that focusses on speed and ease of use. 
It improves massively on the vanilla WE, especially for large maps where the regular World Editor is often too slow and clunky.
The aim is to be a lightweight tool that only does what it needs to and relegates other tasks to high-quality apps.

[Thread on the Hiveworkshop](https://www.hiveworkshop.com/threads/introducing-hivewe.303183/)

Some of the benefits over the vanilla WE:
- Faster loading
- Faster rendering
- Faster editing
- Modern UI/UX
- Edit the pathing map directly
- Edit global tile pathing
- Import heightmaps
- Improved editing palettes

## Features

- Edit the terrain
![HiveWE Screenshot](/Screenshots/HiveWE.png)
- Advanced Object Editor
![HiveWE Screenshot](/Screenshots/ObjectEditor.png)
- Directly edit the pathing map  
![Edit the Pathing Map](/Screenshots/PathingEditing.png)
- Edit global tile pathing  
![Edit global tile pathing](/Screenshots/GlobalPathingEditing.png)

## Download

See the [releases page](https://github.com/stijnherfst/HiveWE/releases) for binary downloads.

## Other Community Tools

Trigger editing: [WC3 Typescript](https://cipherxof.github.io/w3ts/)  
Model editing: [3DS Max Plugin](https://github.com/TaylorMouse/warcraft_III_reforged_tools)
or [Retera Model Studio](https://github.com/Retera/ReterasModelStudio)

## Build Instructions

1. Clone HiveWE somewhere 
`git clone https://github.com/stijnherfst/HiveWE.git`
2. Clone [vcpkg](https://github.com/microsoft/vcpkg) somewhere central (eg. "C:/")
`git clone https://github.com/Microsoft/vcpkg.git`
3. Run vcpkg/bootstrap-vcpkg.bat
4. Add 2 environment variables to your system:
- `VCPKG_ROOT`: the location where vcpkg is installed (e.g. "C:\vcpkg")
- `VCPKG_DEFAULT_TRIPLET`: depending on your operating system (`x64-windows`, `x64-linux`, `x64-osx`)
5. Open Visual Studio as an **Administrator** and using the open folder button to open the HiveWE folder. (**Administrator required** for creating a symbolic link on Windows)
6. Dependencies will be automatically compiled, might take about 15-20 minutes (mostly due to Qt)

**Done**

If you run into any issues then feel free to contact me at HiveWorkshop (eejin) or on Discord eejin#4240

## Potential Contributions

Want to help with the development of HiveWE? Below is a list of features that you could implement. You can try one of these or just add something else you feel like HiveWE should have. Any contributions are welcome!

- Being able to change forces/teams
- Changing map sizes/camera bound
- Ramp editing with the terrain palette
- Making HiveWE run faster
- An FDF frame editor
- Text colorizer
- Advanced terrain editing tools (e.g. flood fill, magic wand selection)
- Or any other functionality you think would be cool

If you have any questions then don't be afraid to message me here, on the HiveWorkshop (eejin) or on Discord eejin#4240
```

`src/Base/BinaryReader.ixx`:

```ixx
module;

#include <stdexcept>
#include <vector>
#include <string>

export module BinaryReader;

import no_init_allocator;

export class BinaryReader {
  public:
	std::vector<uint8_t, default_init_allocator<uint8_t>> buffer;
	unsigned long long int position = 0;

	explicit BinaryReader(std::vector<uint8_t, default_init_allocator<uint8_t>> buffer)
		: buffer(std::move(buffer)) {
	}

	template <typename T>
	[[nodiscard]] T read() {
		static_assert(std::is_standard_layout<T>::value, "T must be of standard layout.");

		if (position + sizeof(T) > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}
		T result = *reinterpret_cast<T*>(&buffer[position]);

		position += sizeof(T);
		return result;
	}

	[[nodiscard]] std::string read_string(const size_t size) {
		if (position + size > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}
		std::string result = { reinterpret_cast<char*>(&buffer[position]), static_cast<size_t>(size) };

		if (const size_t pos = result.find_first_of('\0', 0); pos != std::string::npos) {
			result.resize(pos);
		}

		position += size;
		return result;
	}

	[[nodiscard]] std::string read_c_string() {
		const std::string string(reinterpret_cast<char*>(buffer.data() + position));
		position += string.size() + 1;

		if (position > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}

		return string;
	}

	template <typename T>
	[[nodiscard]] std::vector<T> read_vector(const size_t size) {
		static_assert(std::is_standard_layout<T>::value, "T must be of standard layout.");

		if (position + sizeof(T) * size > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}
		std::vector<T> result(reinterpret_cast<T*>(&buffer[position]), reinterpret_cast<T*>(&buffer[position]) + size);
		position += sizeof(T) * size;
		return result;
	}

	[[nodiscard]] long long remaining() const {
		return buffer.size() - position;
	}

	void advance(const size_t amount) {
		if (position + amount > buffer.size()) {
			throw std::out_of_range("Trying to advance past the end of the buffer");
		}
		position += amount;
	}

	void advance_c_string() {
		position += std::string(reinterpret_cast<char*>(buffer.data() + position)).size() + 1;

		if (position > buffer.size()) {
			throw std::out_of_range("Trying to read out of range of buffer");
		}
	}
};
```

`src/Base/BinaryWriter.ixx`:

```ixx
module;

#include <cstring>
#include <string>
#include <vector>

export module BinaryWriter;

export class BinaryWriter {
  public:
	std::vector<uint8_t> buffer;

	template <typename T = void, typename U>
	void write(U value) {
		static_assert(std::is_standard_layout<U>::value, "U must be of standard layout.");

		if constexpr (not std::is_void_v<T>) {
			static_assert(std::is_standard_layout<T>::value, "T must be of standard layout.");

			T temp = static_cast<T>(value);
			buffer.resize(buffer.size() + sizeof(T));
			std::memcpy(buffer.data() + buffer.size() - sizeof(T), &temp, sizeof(T));
		} else {
			U temp = value;
			buffer.resize(buffer.size() + sizeof(U));
			std::memcpy(buffer.data() + buffer.size() - sizeof(U), &temp, sizeof(U));
		}
	}

	/// Writes the string to the buffer (null terminated if the input string is null terminated)
	/// ToDo string_view?
	void write_string(const std::string& string) {
		buffer.resize(buffer.size() + string.size());
		std::copy(string.begin(), string.end(), buffer.end() - string.size());
	}

	/// Writes a null terminated string to the buffer
	/// ToDo string_view?
	void write_c_string(const std::string& string) {
		if (!string.empty() && string.back() == '\0') {
			buffer.resize(buffer.size() + string.size());
			std::copy(string.begin(), string.end(), buffer.end() - string.size());
		} else {
			buffer.resize(buffer.size() + string.size() + 1);
			std::copy(string.begin(), string.end(), buffer.end() - string.size() - 1);
			buffer[buffer.size() - 1] = '\0';
		}
	}

	/// Writes a null terminated string to the buffer with padding
	/// ToDo string_view?
	void write_c_string_padded(const std::string& string, int final_size) {
		buffer.resize(buffer.size() + final_size);
		std::copy(string.begin(), string.end(), buffer.end() - final_size);

		// std::vector::resize will memset to 0 so adding a \0 terminator is not required
	}

	/// Copies the contents of the array to the buffer, has special code for std::string
	template <typename T>
	void write_vector(const std::vector<T>& vector) {
		if constexpr (std::is_same_v<T, std::string>) {
			for (const auto& i : vector) {
				buffer.insert(buffer.end(), i.begin(), i.end());
			}
		} else {
			static_assert(std::is_standard_layout<T>::value, "T must be of standard layout or std::string.");
			buffer.resize(buffer.size() + vector.size() * sizeof(T));
			// std::copy(vector.begin(), vector.end(), buffer.end() - vector.size() * sizeof(T));
			std::memcpy(buffer.data() + buffer.size() - vector.size() * sizeof(T), vector.data(), vector.size() * sizeof(T));
		}
	}
};
```

`src/Base/Camera.cpp`:

```cpp
#include "Camera.h"

#include "Globals.h"
#include "InputHandler.h"

void Camera::reset() {
	distance = 20;
	horizontal_angle = 0.0f;
	vertical_angle = -0.977f;
	update(0);
}

void Camera::extract_frustrum_planes(const glm::mat4& proj, const glm::mat4& view) {
	double clip[4][4];
	clip[0][0] = view[0][0] * proj[0][0] + view[0][1] * proj[1][0] + view[0][2] * proj[2][0] + view[0][3] * proj[3][0];
	clip[0][1] = view[0][0] * proj[0][1] + view[0][1] * proj[1][1] + view[0][2] * proj[2][1] + view[0][3] * proj[3][1];
	clip[0][2] = view[0][0] * proj[0][2] + view[0][1] * proj[1][2] + view[0][2] * proj[2][2] + view[0][3] * proj[3][2];
	clip[0][3] = view[0][0] * proj[0][3] + view[0][1] * proj[1][3] + view[0][2] * proj[2][3] + view[0][3] * proj[3][3];

	clip[1][0] = view[1][0] * proj[0][0] + view[1][1] * proj[1][0] + view[1][2] * proj[2][0] + view[1][3] * proj[3][0];
	clip[1][1] = view[1][0] * proj[0][1] + view[1][1] * proj[1][1] + view[1][2] * proj[2][1] + view[1][3] * proj[3][1];
	clip[1][2] = view[1][0] * proj[0][2] + view[1][1] * proj[1][2] + view[1][2] * proj[2][2] + view[1][3] * proj[3][2];
	clip[1][3] = view[1][0] * proj[0][3] + view[1][1] * proj[1][3] + view[1][2] * proj[2][3] + view[1][3] * proj[3][3];

	clip[2][0] = view[2][0] * proj[0][0] + view[2][1] * proj[1][0] + view[2][2] * proj[2][0] + view[2][3] * proj[3][0];
	clip[2][1] = view[2][0] * proj[0][1] + view[2][1] * proj[1][1] + view[2][2] * proj[2][1] + view[2][3] * proj[3][1];
	clip[2][2] = view[2][0] * proj[0][2] + view[2][1] * proj[1][2] + view[2][2] * proj[2][2] + view[2][3] * proj[3][2];
	clip[2][3] = view[2][0] * proj[0][3] + view[2][1] * proj[1][3] + view[2][2] * proj[2][3] + view[2][3] * proj[3][3];

	clip[3][0] = view[3][0] * proj[0][0] + view[3][1] * proj[1][0] + view[3][2] * proj[2][0] + view[3][3] * proj[3][0];
	clip[3][1] = view[3][0] * proj[0][1] + view[3][1] * proj[1][1] + view[3][2] * proj[2][1] + view[3][3] * proj[3][1];
	clip[3][2] = view[3][0] * proj[0][2] + view[3][1] * proj[1][2] + view[3][2] * proj[2][2] + view[3][3] * proj[3][2];
	clip[3][3] = view[3][0] * proj[0][3] + view[3][1] * proj[1][3] + view[3][2] * proj[2][3] + view[3][3] * proj[3][3];

	frustum_planes[Right][0] = clip[0][3] - clip[0][0];
	frustum_planes[Right][1] = clip[1][3] - clip[1][0];
	frustum_planes[Right][2] = clip[2][3] - clip[2][0];
	frustum_planes[Right][3] = clip[3][3] - clip[3][0];
	normalize_frustrum_plane(frustum_planes[Right]);

	frustum_planes[Left][0] = clip[0][3] + clip[0][0];
	frustum_planes[Left][1] = clip[1][3] + clip[1][0];
	frustum_planes[Left][2] = clip[2][3] + clip[2][0];
	frustum_planes[Left][3] = clip[3][3] + clip[3][0];
	normalize_frustrum_plane(frustum_planes[Left]);

	frustum_planes[Bottom][0] = clip[0][3] + clip[0][1];
	frustum_planes[Bottom][1] = clip[1][3] + clip[1][1];
	frustum_planes[Bottom][2] = clip[2][3] + clip[2][1];
	frustum_planes[Bottom][3] = clip[3][3] + clip[3][1];
	normalize_frustrum_plane(frustum_planes[Bottom]);

	frustum_planes[Top][0] = clip[0][3] - clip[0][1];
	frustum_planes[Top][1] = clip[1][3] - clip[1][1];
	frustum_planes[Top][2] = clip[2][3] - clip[2][1];
	frustum_planes[Top][3] = clip[3][3] - clip[3][1];
	normalize_frustrum_plane(frustum_planes[Top]);

	frustum_planes[Front][0] = clip[0][3] - clip[0][2];
	frustum_planes[Front][1] = clip[1][3] - clip[1][2];
	frustum_planes[Front][2] = clip[2][3] - clip[2][2];
	frustum_planes[Front][3] = clip[3][3] - clip[3][2];
	normalize_frustrum_plane(frustum_planes[Front]);

	frustum_planes[Back][0] = clip[0][3] + clip[0][2];
	frustum_planes[Back][1] = clip[1][3] + clip[1][2];
	frustum_planes[Back][2] = clip[2][3] + clip[2][2];
	frustum_planes[Back][3] = clip[3][3] + clip[3][2];
	normalize_frustrum_plane(frustum_planes[Back]);
}

void Camera::normalize_frustrum_plane(glm::vec4& plane) {
	float magnitude = glm::sqrt(
		plane[0] * plane[0] +
		plane[1] * plane[1] +
		plane[2] * plane[2]);

	plane[0] /= magnitude;
	plane[1] /= magnitude;
	plane[2] /= magnitude;
	plane[3] /= magnitude;
}


bool Camera::inside_frustrum(const glm::vec3& point) const {
	for (unsigned int i = 0; i < 6; i++) {
		if (frustum_planes[i][0] * point.x +
				frustum_planes[i][1] * point.y +
				frustum_planes[i][2] * point.z +
				frustum_planes[i][3] <=
			0) {
			return false;
		}
	}

	return true;
}

bool Camera::inside_frustrum(const glm::vec3& min, const glm::vec3& max) const {
	auto GetVisibility = [](const glm::vec4& clip, const glm::vec3& min, const glm::vec3& max) {
		float x0 = min.x * clip.x;
		float x1 = max.x * clip.x;
		float y0 = min.y * clip.y;
		float y1 = max.y * clip.y;
		float z0 = min.z * clip.z + clip.w;
		float z1 = max.z * clip.z + clip.w;
		float p1 = x0 + y0 + z0;
		float p2 = x1 + y0 + z0;
		float p3 = x1 + y1 + z0;
		float p4 = x0 + y1 + z0;
		float p5 = x0 + y0 + z1;
		float p6 = x1 + y0 + z1;
		float p7 = x1 + y1 + z1;
		float p8 = x0 + y1 + z1;

		return !(p1 <= 0.f && p2 <= 0.f && p3 <= 0.f && p4 <= 0.f && p5 <= 0.f && p6 <= 0.f && p7 <= 0.f && p8 <= 0.f);
	};

	bool v0 = GetVisibility(frustum_planes[Right], min, max);
	bool v1 = GetVisibility(frustum_planes[Left], min, max);
	bool v2 = GetVisibility(frustum_planes[Bottom], min, max);
	bool v3 = GetVisibility(frustum_planes[Top], min, max);
	bool v4 = GetVisibility(frustum_planes[Front], min, max);
	return v0 && v1 && v2 && v3 && v4;
}

void FPSCamera::update(const double delta) {
	float speed = 5;
	if (input_handler.key_pressed(Qt::Key_Shift)) {
		speed = 20;
	}

	if (input_handler.key_pressed(Qt::Key_W)) {
		position += direction * speed * static_cast<float>(delta);
	} else if (input_handler.key_pressed(Qt::Key_S)) {
		position -= direction * speed * static_cast<float>(delta);
	}

	const glm::vec3 displacement = glm::normalize(glm::cross(direction, up)) * speed * float(delta);
	if (input_handler.key_pressed(Qt::Key_A)) {
		position -= displacement;
	} else if (input_handler.key_pressed(Qt::Key_D)) {
		position += displacement;
	}

	if (input_handler.key_pressed(Qt::Key_Space)) {
		position.z += 1.f * speed * static_cast<float>(delta);
	} else if (input_handler.key_pressed(Qt::Key_Control)) {
		position.z -= 1.f * speed * static_cast<float>(delta);
	}

	direction = glm::vec3(
		std::cos(vertical_angle) * std::sin(horizontal_angle),
		std::cos(vertical_angle) * std::cos(horizontal_angle),
		std::sin(vertical_angle)
	);

	direction = glm::normalize(direction);

	projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	view = glm::lookAt(position, position + direction, up);
	projection_view = projection * view;

	// for billboarded animated mesh
	glm::vec3 opDirection = -direction; // camera->position - this->position;

	glm::vec3 opDirectionZ = glm::normalize(glm::vec3(opDirection.x, opDirection.y, 0));
	float angleZ = glm::atan(opDirectionZ.y, opDirectionZ.x);
	glm::vec3 axisZ = glm::vec3(0, 0, 1);

	glm::vec3 opDirectionY = glm::normalize(opDirection);
	glm::vec3 axisY = glm::vec3(0, -1, 0);

	decomposed_rotation = glm::angleAxis(angleZ, axisZ) * glm::angleAxis(glm::asin(opDirectionY.z), axisY);
	extract_frustrum_planes(projection, view);
}

void FPSCamera::mouse_move_event(QMouseEvent* event) {
	glm::vec2 diff = input_handler.mouse - input_handler.previous_mouse;

	horizontal_angle += diff.x * 0.012;
	vertical_angle += -diff.y * 0.012;
	vertical_angle = std::max(-glm::pi<float>() / 2.f + 0.001f, std::min(vertical_angle, glm::pi<float>() / 2.f - 0.001f));

	update(0);
}

void FPSCamera::mouse_scroll_event(QWheelEvent* event) {
}


void TPSCamera::update(double delta) {
	direction = glm::vec3(
		std::cos(vertical_angle) * std::sin(horizontal_angle),
		std::cos(vertical_angle) * std::cos(horizontal_angle),
		std::sin(vertical_angle)
	);

	direction = glm::normalize(direction);
	// Calculate axis directions for camera as referential point:
	// Z axis is simply the direction we are facing
	// X axis is then the cross product between the "fake" up and Z
	X = glm::cross(direction, up);
	X = glm::normalize(X);
	// Y Axis is cross product between X and Z, e.g is the real up
	Y = glm::cross(X, direction);
	Y = glm::normalize(Y);

	// The vector that is perpendicular to the up vector, thus points forward
	forward = glm::cross(X, up);

	if (input_handler.key_pressed(Qt::Key_Left)) { //glm::vec3(-40, 0, 0)
		position +=  -X * 40.f * static_cast<float>(delta) * (distance / 30.f);
	} else if (input_handler.key_pressed(Qt::Key_Right)) {
		position += X * 40.f * static_cast<float>(delta) * (distance / 30.f);
	}

	if (input_handler.key_pressed(Qt::Key_Up)) {
		position += -forward * 40.f * static_cast<float>(delta) * (distance / 30.f);
	} else if (input_handler.key_pressed(Qt::Key_Down)) {
		position += forward * 40.f * static_cast<float>(delta) * (distance / 30.f);
	}
	position.z = map->terrain.interpolated_height(position.x, position.y);

	projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	view = glm::lookAt(position - direction * distance, position, up);
	projection_view = projection * view;

	// for billboarded animated mesh
	glm::vec3 opDirection = -direction; // camera->position - this->position;

	glm::vec3 opDirectionZ = glm::normalize(glm::vec3(opDirection.x, opDirection.y, 0));
	float angleZ = glm::atan(opDirectionZ.y, opDirectionZ.x);
	glm::vec3 axisZ = glm::vec3(0, 0, 1);

	glm::vec3 opDirectionY = glm::normalize(opDirection);
	glm::vec3 axisY = glm::vec3(0, -1, 0);

	decomposed_rotation = glm::angleAxis(angleZ, axisZ) * glm::angleAxis(glm::asin(opDirectionY.z), axisY);

	extract_frustrum_planes(projection, view);
}

void TPSCamera::mouse_move_event(QMouseEvent* event) {
	glm::vec2 diff = input_handler.mouse - input_handler.previous_mouse;

	if (rolling || (event->buttons() == Qt::RightButton && event->modifiers() & Qt::ControlModifier)) {
		horizontal_angle += diff.x * 0.0025f;
		vertical_angle -= diff.y * 0.0025f;
		vertical_angle = std::max(-glm::pi<float>() / 2.f + 0.001f, std::min(vertical_angle, glm::pi<float>() / 2.f - 0.001f));
		update(0);
	} else if (event->buttons() == Qt::RightButton) {
		position += X * (-diff.x * 0.025f * (distance / 30.f));
		position += forward * (-diff.y * 0.025f * (distance / 30.f));
		position.z = map->terrain.interpolated_height(position.x, position.y);
		update(0);
	}
}

void TPSCamera::mouse_scroll_event(QWheelEvent* event) {
	distance = std::clamp(distance * std::pow(0.999f, static_cast<float>(event->angleDelta().y())), 0.001f, 1000.f);
	update(0);
}

void TPSCamera::mouse_press_event(QMouseEvent* event) {
	switch (event->button()) {
		case Qt::MiddleButton:
			rolling = true;
			break;
        default:
			break;
	}
}

void TPSCamera::mouse_release_event(QMouseEvent* event) {
	switch (event->button()) {
		case Qt::MiddleButton:
			rolling = false;
			break;
        default:
			break;
	}
}

Camera* camera;
```

`src/Base/Camera.h`:

```h
#pragma once

#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

#include <QEvent>
#include <QMouseEvent>

struct Camera {
	virtual ~Camera() = default;

	glm::vec3 position = { 0, 0, 0 };

	float distance = 20.f;

	glm::vec3 direction = { 0, 1, 0 };
	glm::vec3 X = { 1, 0, 0 };
	glm::vec3 Y = { 0, 1, 0 };
	glm::vec3 up = { 0, 0, 1 };
	glm::vec3 forward = { 0, 1, 0 };

	float fov = 70.f;
	float aspect_ratio = 16.f / 9.f;
	float draw_distance_close = 0.05f;
	float draw_distance_far = 2000.f;
	float fov_rad = (glm::pi<double>() / 180.f) * static_cast<double>(fov); // Need radians
	float tan_height = 2.f * glm::tan(fov_rad * 0.5f);

	glm::mat4 projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	glm::mat4 view = glm::lookAt(position - direction * distance, position, up);
	glm::mat4 projection_view;

	glm::vec4 frustum_planes[6];

	// Used for decomposing camera information to get rotation, for camera-centric Billboarded model elements
	glm::vec3 decomposed_scale;
	glm::quat decomposed_rotation;
	glm::vec3 decomposed_translation;
	glm::vec3 decomposed_skew;
	glm::vec4 decomposed_perspective;

	float horizontal_angle = 0.f;
	float vertical_angle = -0.977f;

	enum FrustrumPlane {
		Right,
		Left,
		Bottom,
		Top,
		Front,
		Back
	};

	void extract_frustrum_planes(const glm::mat4& proj, const glm::mat4& view);
	void normalize_frustrum_plane(glm::vec4& plane);
	bool inside_frustrum(const glm::vec3& point) const;
	bool inside_frustrum(const glm::vec3& min, const glm::vec3& max) const;

	virtual void update(double delta) = 0;

	virtual void mouse_move_event(QMouseEvent* event) = 0;
	virtual void mouse_scroll_event(QWheelEvent* event) = 0;
	virtual void mouse_press_event(QMouseEvent* event) = 0;
	virtual void mouse_release_event(QMouseEvent* event) = 0;
	virtual void reset();
};

struct FPSCamera : Camera {
	void update(double delta) override;
	void mouse_move_event(QMouseEvent* event) override;
	void mouse_scroll_event(QWheelEvent* event) override;
	void mouse_press_event(QMouseEvent* event) override{};
	void mouse_release_event(QMouseEvent* event) override{};
};

struct TPSCamera : Camera {

	bool rolling = false;

	void update(double delta) override;
	void mouse_move_event(QMouseEvent* event) override;
	void mouse_scroll_event(QWheelEvent* event) override;
	void mouse_press_event(QMouseEvent* event) override;
	void mouse_release_event(QMouseEvent* event) override;
};

extern Camera* camera;
```

`src/Base/Doodads.cpp`:

```cpp
#include "Doodads.h"

#include <iostream>
#include <optional>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "Globals.h"
import BinaryWriter;
import Hierarchy;

void Doodad::update() {
	glm::vec3 base_scale = glm::vec3(1.f);
	std::string max_roll;
	if (doodads_slk.row_headers.contains(id)) {
		color.r = doodads_slk.data<float>("vertr" + std::to_string(variation + 1), id) / 255.f;
		color.g = doodads_slk.data<float>("vertg" + std::to_string(variation + 1), id) / 255.f;
		color.b = doodads_slk.data<float>("vertb" + std::to_string(variation + 1), id) / 255.f;
		max_roll = doodads_slk.data("maxroll", id);
		base_scale = glm::vec3(doodads_slk.data<float>("defscale", id));
	} else {
		color.r = destructibles_slk.data<float>("colorr", id) / 255.f;
		color.g = destructibles_slk.data<float>("colorg", id) / 255.f;
		color.b = destructibles_slk.data<float>("colorb", id) / 255.f;
		max_roll = destructibles_slk.data("maxroll", id);
	}

	matrix = glm::translate(glm::mat4(1.f), position);
	matrix = glm::scale(matrix, (base_scale * scale) / 128.f);
	matrix = glm::rotate(matrix, angle, glm::vec3(0, 0, 1));

	if (!max_roll.empty() && max_roll != "-") {
		matrix = glm::rotate(matrix, -std::stof(max_roll), glm::vec3(1, 0, 0));
	}

	skeleton.update_location(position, angle, (base_scale * scale) / 128.f);
}

float Doodad::acceptable_angle(std::string_view id, std::shared_ptr<PathingTexture> pathing, float current_angle, float target_angle) {
	bool fixed_rotation = false;
	if (doodads_slk.row_headers.contains(id)) {
		fixed_rotation = doodads_slk.data<int>("fixedrot", id) > 0;
	} else {
		fixed_rotation = destructibles_slk.data<int>("fixedrot", id) > 0;
	}

	if (fixed_rotation) {
		return current_angle;
	}

	if (pathing) {
		if (pathing->width == pathing->height && pathing->homogeneous) {
			return target_angle;
		} else {
			return (static_cast<int>((target_angle + glm::pi<float>() * 0.25f) / (glm::pi<float>() * 0.5f)) % 4) * glm::pi<float>() * 0.5f;
		}
	} else {
		return target_angle;
	}
}

bool Doodads::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.doo");

	const std::string magic_number = reader.read_string(4);
	if (magic_number != "W3do") {
		std::cout << "Invalid war3map.doo file: Magic number is not W3do\n";
		return false;
	}
	const uint32_t version = reader.read<uint32_t>();
	if (version != 7 && version != 8) {
		std::cout << "Unknown war3map.doo version: " << version << " Attempting to load but may crash\nPlease send this map to eejin\n";
	}

	// Subversion
	const uint32_t subversion = reader.read<uint32_t>();
	// ToDO check subversion

	Doodad::auto_increment = 0;
	doodads.resize(reader.read<uint32_t>());
	for (auto&& i : doodads) {
		i.id = reader.read_string(4);
		i.variation = reader.read<uint32_t>();
		i.position = (reader.read<glm::vec3>() - glm::vec3(map->terrain.offset, 0)) / 128.f;
		i.angle = reader.read<float>();
		i.scale = reader.read<glm::vec3>();

		if (map->info.game_version_major * 100 + map->info.game_version_minor >= 132) {
			i.skin_id = reader.read_string(4);
		} else {
			i.skin_id = i.id;
		}

		i.state = static_cast<Doodad::State>(reader.read<uint8_t>());
		i.life = reader.read<uint8_t>();

		if (version >= 8) {
			i.item_table_pointer = reader.read<int32_t>();
			i.item_sets.resize(reader.read<uint32_t>());
			for (auto&& j : i.item_sets) {
				j.items.resize(reader.read<uint32_t>());
				for (auto& [id, chance] : j.items) {
					id = reader.read_string(4);
					chance = reader.read<uint32_t>();
				}
			}
		}

		i.creation_number = reader.read<uint32_t>();
		Doodad::auto_increment = std::max(Doodad::auto_increment, i.creation_number);
	}

	// Terrain Doodads
	const int special_format_version = reader.read<uint32_t>();

	special_doodads.resize(reader.read<uint32_t>());
	for (auto&& i : special_doodads) {
		i.id = reader.read_string(4);
		i.variation = reader.read<uint32_t>();
		i.position = glm::ivec3(reader.read<glm::ivec2>(), 0);
		i.old_position = i.position;
	}

	return true;
}

void Doodads::save() const {
	BinaryWriter writer;
	writer.write_string("W3do");
	writer.write<uint32_t>(write_version);
	writer.write<uint32_t>(write_subversion);

	writer.write<uint32_t>(doodads.size());
	for (auto&& i : doodads) {
		writer.write_string(i.id);
		writer.write<uint32_t>(i.variation);
		writer.write<glm::vec3>(i.position * 128.f + glm::vec3(map->terrain.offset, 0));
		writer.write<float>(i.angle);
		writer.write<glm::vec3>(i.scale);

		writer.write_string(i.skin_id);

		writer.write<uint8_t>(static_cast<int>(i.state));
		writer.write<uint8_t>(i.life);

		writer.write<int32_t>(i.item_table_pointer);
		writer.write<uint32_t>(i.item_sets.size());
		for (auto&& j : i.item_sets) {
			writer.write<uint32_t>(j.items.size());
			for (const auto& [id, chance] : j.items) {
				writer.write_string(id);
				writer.write<uint32_t>(chance);
			}
		}

		writer.write<uint32_t>(i.creation_number);
	}

	writer.write<uint32_t>(write_special_version);

	writer.write<uint32_t>(special_doodads.size());
	for (auto&& i : special_doodads) {
		writer.write_string(i.id);
		writer.write<uint32_t>(i.variation);
		writer.write<glm::ivec2>(glm::ivec2(i.old_position.x, i.old_position.y));
	}

	hierarchy.map_file_write("war3map.doo", writer.buffer);
}

void Doodads::create() {
	for (auto&& i : doodads) {
		i.mesh = get_mesh(i.id, i.variation);
		i.skeleton = SkeletalModelInstance(i.mesh->model);
		// Get pathing map
		const bool is_doodad = doodads_slk.row_headers.contains(i.id);
		const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

		const std::string pathing_texture_path = slk.data("pathtex", i.id);
		if (hierarchy.file_exists(pathing_texture_path)) {
			i.pathing = resource_manager.load<PathingTexture>(pathing_texture_path);
		}
		i.update();
	}

	for (auto&& i : special_doodads) {
		i.mesh = get_mesh(i.id, i.variation);
		i.skeleton = SkeletalModelInstance(i.mesh->model);
		const std::string pathing_texture_path = doodads_slk.data("pathtex", i.id);
		if (hierarchy.file_exists(pathing_texture_path)) {
			i.pathing = resource_manager.load<PathingTexture>(pathing_texture_path);
			i.position += glm::vec3(glm::vec2(i.pathing->width / 8.f, i.pathing->height / 8.f), 0.f);
		}

		i.position.z = map->terrain.interpolated_height(i.position.x, i.position.y);

		float rotation = doodads_slk.data<int>("fixedrot", i.id) / 360.f * 2.f * glm::pi<float>();
		i.matrix = glm::translate(i.matrix, i.position);
		i.matrix = glm::scale(i.matrix, { 1.f / 128.f, 1.f / 128.f, 1.f / 128.f });
		i.matrix = glm::rotate(i.matrix, rotation, glm::vec3(0, 0, 1));
	}

	// Blit doodad pathing
	for (const auto& i : doodads) {
		if (!i.pathing) {
			continue;
		}

		map->pathing_map.blit_pathing_texture(i.position, glm::degrees(i.angle) + 90, i.pathing);
	}
	map->pathing_map.upload_dynamic_pathing();

	// Update terrain exists
	update_special_doodad_pathing(QRect(0, 0, map->terrain.width, map->terrain.height));
}

void Doodads::render() {
	for (auto&& i : doodads) {
		i.mesh->render_queue(i.skeleton, i.color);
	}
	for (auto&& i : special_doodads) {
		i.mesh->render_queue(i.skeleton, glm::vec3(1.f));
	}
}

// Will assign a creation number
Doodad& Doodads::add_doodad(std::string id, int variation, glm::vec3 position) {
	Doodad doodad;
	doodad.id = id;
	doodad.skin_id = id;
	doodad.variation = variation;
	doodad.mesh = get_mesh(id, variation);
	doodad.position = position;
	doodad.scale = { 1, 1, 1 };
	doodad.angle = 0;
	doodad.creation_number = ++Doodad::auto_increment;
	doodad.skeleton = SkeletalModelInstance(doodad.mesh->model);

	const bool is_doodad = doodads_slk.row_headers.contains(id);
	const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
	std::string pathing_texture_path = slk.data("pathtex", id);
	if (hierarchy.file_exists(pathing_texture_path)) {
		doodad.pathing = resource_manager.load<PathingTexture>(pathing_texture_path);
	}

	doodad.update();

	doodads.push_back(doodad);
	return doodads.back();
}

// You will have to manually set a creation number and valid skin ID
Doodad& Doodads::add_doodad(Doodad doodad) {
	doodads.push_back(doodad);
	return doodads.back();
}

void Doodads::remove_doodad(Doodad* doodad) {
	auto iterator = doodads.begin() + std::distance(doodads.data(), doodad);
	doodads.erase(iterator);
}

std::vector<Doodad*> Doodads::query_area(const QRectF& area) {
	std::vector<Doodad*> result;

	for (auto&& i : doodads) {
		if (area.contains(i.position.x, i.position.y)) {
			result.push_back(&i);
		}
	}
	return result;
}

void Doodads::remove_doodads(const std::vector<Doodad*>& list) {
	doodads.erase(std::remove_if(doodads.begin(), doodads.end(), [&](Doodad& doodad) {
					  return std::find(list.begin(), list.end(), &doodad) != list.end();
				  }),
				  doodads.end());
}

void Doodads::update_doodad_pathing(const std::vector<Doodad>& target_doodads) {
	QRectF update_pathing_area;
	for (const auto& i : target_doodads) {
		if (update_pathing_area.width() == 0 || update_pathing_area.height() == 0) {
			update_pathing_area = { i.position.x, i.position.y, 1.f, 1.f };
		}
		update_pathing_area |= { i.position.x, i.position.y, 1.f, 1.f };
	}

	update_doodad_pathing(update_pathing_area);
}

void Doodads::update_doodad_pathing(const std::vector<Doodad*>& target_doodads) {
	QRectF update_pathing_area;
	for (const auto& i : target_doodads) {
		if (update_pathing_area.width() == 0 || update_pathing_area.height() == 0) {
			update_pathing_area = { i->position.x, i->position.y, 1.f, 1.f };
		}
		update_pathing_area |= { i->position.x, i->position.y, 1.f, 1.f };
	}

	update_doodad_pathing(update_pathing_area);
}

void Doodads::update_doodad_pathing(const QRectF& area) {
	QRectF new_area = area.adjusted(-6, -6, 6, 6);
	map->pathing_map.dynamic_clear_area(new_area.toRect());

	new_area.adjust(-6, -6, 6, 6);

	const auto doodads_to_blit = map->doodads.query_area(new_area);
	for (const auto& i : doodads_to_blit) {
		if (!i->pathing) {
			continue;
		}
		map->pathing_map.blit_pathing_texture(i->position, glm::degrees(i->angle) + 90, i->pathing);
	}
	map->pathing_map.upload_dynamic_pathing();
}

void Doodads::update_special_doodad_pathing(const QRectF& area) {
	QRectF new_area = area.adjusted(-6.f, -6.f, 6.f, 6.f);
	new_area = new_area.intersected({ 0, 0, static_cast<float>(map->terrain.width), static_cast<float>(map->terrain.height) });

	for (int i = new_area.left(); i < new_area.right(); i++) {
		for (int j = new_area.top(); j < new_area.bottom(); j++) {
			map->terrain.corners[i][j].special_doodad = false;
		}
	}

	new_area = area.adjusted(-6, -6, 6, 6);

	for (const auto& i : special_doodads) {
		if (!new_area.contains(i.position.x, i.position.y)) {
			continue;
		}

		if (!i.pathing) {
			continue;
		}

		for (int j = 0; j < i.pathing->width / 4; j++) {
			for (int k = 0; k < i.pathing->height / 4; k++) {
				const int x = i.position.x - i.pathing->width / 8.f + j;
				const int y = i.position.y - i.pathing->height / 8.f + k;

				if (x < 0 || y < 0 || x >= map->terrain.width || y >= map->terrain.height) {
					continue;
				}

				map->terrain.corners[x][y].special_doodad = true;
			}
		}
	}

	map->terrain.update_ground_exists(area.toRect());
}

void Doodads::process_doodad_field_change(const std::string& id, const std::string& field) {
	if (field == "file" || field == "numvar") {
		// id_to_mesh requires a variation too so we will just have to check a bunch of them
		// ToDo just use the numvar field from the SLKs
		for (int i = 0; i < 20; i++) {
			if (id_to_mesh.contains(id + std::to_string(i))) {
				id_to_mesh.erase(id_to_mesh.find(id));
			}
		}
		for (auto& i : doodads) {
			if (i.id == id) {
				i.mesh = get_mesh(id, i.variation);
				i.update();
			}
		}
	}

	if (field == "maxroll" || field == "vertr" || field == "vertg" || field == "vertb") {
		for (auto& i : doodads) {
			if (i.id == id) {
				i.update();
			}
		}
	}
}

void Doodads::process_destructible_field_change(const std::string& id, const std::string& field) {
	if (field == "file" || field == "numvar") {
		// id_to_mesh requires a variation too so we will just have to check a bunch of them
		// ToDo just use the numvar field from the SLKs
		for (int i = 0; i < 20; i++) {
			if (id_to_mesh.contains(id + std::to_string(i))) {
				id_to_mesh.erase(id_to_mesh.find(id + std::to_string(i)));
			}
		}
		for (auto& i : doodads) {
			if (i.id == id) {
				i.mesh = get_mesh(id, i.variation);
				i.update();
			}
		}
	}

	if (field == "maxroll" || field == "colorr" || field == "colorg" || field == "colorb") {
		for (auto& i : doodads) {
			if (i.id == id) {
				i.update();
			}
		}
	}
}

std::shared_ptr<SkinnedMesh> Doodads::get_mesh(std::string id, int variation) {
	std::string full_id = id + std::to_string(variation);
	if (id_to_mesh.contains(full_id)) {
		return id_to_mesh[full_id];
	}

	fs::path mesh_path;
	std::string variations;
	std::string replaceable_id;
	fs::path texture_name;

	if (doodads_slk.row_headers.contains(id)) {
		// Is doodad
		mesh_path = doodads_slk.data("file", id);
		variations = doodads_slk.data("numvar", id);
	} else {
		mesh_path = destructibles_slk.data("file", id);
		variations = destructibles_slk.data("numvar", id);

		replaceable_id = destructibles_slk.data("texid", id);
		texture_name = destructibles_slk.data("texfile", id);
		texture_name.replace_extension("");
	}

	const std::string stem = mesh_path.stem().string();
	mesh_path.replace_filename(stem + (variations == "1" ? "" : std::to_string(variation)));
	mesh_path.replace_extension(".mdx");

	// Use base model when variation doesn't exist
	if (!hierarchy.file_exists(mesh_path)) {
		mesh_path.remove_filename() /= stem + ".mdx";
	}

	mesh_path = fs::path(string_replaced(mesh_path.string(), "\\", "/"));

	// Mesh doesnt exist at all
	if (!hierarchy.file_exists(mesh_path)) {
		std::cout << "Invalid model file for " << id << " With file path: " << mesh_path << "\n";
		id_to_mesh.emplace(full_id, resource_manager.load<SkinnedMesh>("Objects/Invalidmodel/Invalidmodel.mdx", "", std::nullopt));
		return id_to_mesh[full_id];
	}

	if (is_number(replaceable_id) && texture_name != "_") {
		id_to_mesh.emplace(full_id, resource_manager.load<SkinnedMesh>(mesh_path, texture_name.string(), std::make_optional(std::make_pair(std::stoi(replaceable_id), texture_name.replace_extension("").string()))));
	} else {
		id_to_mesh.emplace(full_id, resource_manager.load<SkinnedMesh>(mesh_path, "", std::nullopt));
	}

	return id_to_mesh[full_id];
}

void DoodadAddAction::undo() {
	map->doodads.doodads.resize(map->doodads.doodads.size() - doodads.size());
	map->doodads.update_doodad_pathing(doodads);
}

void DoodadAddAction::redo() {
	map->doodads.doodads.insert(map->doodads.doodads.end(), doodads.begin(), doodads.end());
	map->doodads.update_doodad_pathing(doodads);
}

void DoodadDeleteAction::undo() {
	if (map->brush) {
		map->brush->clear_selection();
	}

	map->doodads.doodads.insert(map->doodads.doodads.end(), doodads.begin(), doodads.end());
	map->doodads.update_doodad_pathing(doodads);
}

void DoodadDeleteAction::redo() {
	if (map->brush) {
		map->brush->clear_selection();
	}

	map->doodads.doodads.resize(map->doodads.doodads.size() - doodads.size());
	map->doodads.update_doodad_pathing(doodads);
}

void DoodadStateAction::undo() {
	QRectF update_pathing_area;
	for (auto& i : old_doodads) {
		for (auto& j : map->doodads.doodads) {
			if (i.creation_number == j.creation_number) {
				if (update_pathing_area.width() == 0 || update_pathing_area.height() == 0) {
					update_pathing_area = { j.position.x, j.position.y, 1.f, 1.f };
				}
				update_pathing_area |= { j.position.x, j.position.y, 1.f, 1.f };
				update_pathing_area |= { i.position.x, i.position.y, 1.f, 1.f };

				j = i;
			}
		}
	}
	map->doodads.update_doodad_pathing(update_pathing_area);
}

void DoodadStateAction::redo() {
	QRectF update_pathing_area;
	for (auto& i : new_doodads) {
		for (auto& j : map->doodads.doodads) {
			if (i.creation_number == j.creation_number) {
				if (update_pathing_area.width() == 0 || update_pathing_area.height() == 0) {
					update_pathing_area = { j.position.x, j.position.y, 1.f, 1.f };
				}
				update_pathing_area |= { j.position.x, j.position.y, 1.f, 1.f };
				update_pathing_area |= { i.position.x, i.position.y, 1.f, 1.f };

				j = i;
			}
		}
	}
	map->doodads.update_doodad_pathing(update_pathing_area);
}

```

`src/Base/Doodads.h`:

```h
#pragma once

#include <vector>
#include <memory>

#include "SkinnedMesh.h"
#include "Utilities.h"
import PathingTexture;

#include "Terrain.h"
#include "TerrainUndo.h"

#include <SkeletalModelInstance.h>

struct Doodad {
	static inline int auto_increment;

	std::string id;
	std::string skin_id;
	int variation = 0;
	glm::vec3 position = {0, 0, 0};
	glm::vec3 scale = {0, 0, 0};
	float angle = 0.f;

	enum class State {
		invisible_non_solid,
		visible_non_solid,
		visible_solid
	};
	State state = State::visible_solid;
	int life = 100;

	int item_table_pointer = -1;
	std::vector<ItemSet> item_sets;

	int creation_number;

	// Auxiliary data
	glm::mat4 matrix = glm::mat4(1.f);
	SkeletalModelInstance skeleton;
	std::shared_ptr<SkinnedMesh> mesh;
	std::shared_ptr<PathingTexture> pathing;
	glm::vec3 color;

	void update();
	static float acceptable_angle(std::string_view id, std::shared_ptr<PathingTexture> pathing, float current_angle, float target_angle);
};

struct SpecialDoodad {
	std::string id;
	int variation;
	glm::vec3 position;
	glm::vec3 old_position;

	// Auxiliary data
	glm::mat4 matrix = glm::mat4(1.f);
	SkeletalModelInstance skeleton;
	std::shared_ptr<SkinnedMesh> mesh;
	std::shared_ptr<PathingTexture> pathing;
};

class Doodads {
	std::unordered_map<std::string, std::shared_ptr<SkinnedMesh>> id_to_mesh;

	static constexpr int write_version = 8;
	static constexpr int write_subversion = 11;
	static constexpr int write_special_version = 0;

public:
	std::vector<SpecialDoodad> special_doodads;
	std::vector<Doodad> doodads;

	bool load();
	void save() const;
	void create();
	void render();

	Doodad& add_doodad(std::string id, int variation, glm::vec3 position);
	Doodad& add_doodad(Doodad doodad);

	void remove_doodad(Doodad* doodad);

	std::vector<Doodad*> query_area(const QRectF& area);
	void remove_doodads(const std::vector<Doodad*>& list);

	void update_doodad_pathing(const std::vector<Doodad*>& target_doodads);
	void update_doodad_pathing(const std::vector<Doodad>& target_doodads);
	void update_doodad_pathing(const QRectF& area);

	void update_special_doodad_pathing(const QRectF& area);

	void process_doodad_field_change(const std::string& id, const std::string& field);
	void process_destructible_field_change(const std::string& id, const std::string& field);

	std::shared_ptr<SkinnedMesh> get_mesh(std::string id, int variation);
};

// Undo/redo structures
class DoodadAddAction : public TerrainUndoAction {
public:
	std::vector<Doodad> doodads;

	void undo() override;
	void redo() override;
};

class DoodadDeleteAction : public TerrainUndoAction {
public:
	std::vector<Doodad> doodads;

	void undo() override;
	void redo() override;
};

class DoodadStateAction : public TerrainUndoAction {
public:
	std::vector<Doodad> old_doodads;
	std::vector<Doodad> new_doodads;

	void undo() override;
	void redo() override;
};
```

`src/Base/FlowLayout.cpp`:

```cpp
#include "FlowLayout.h"

#include <QStyle>
#include <QWidget>

FlowLayout::FlowLayout(QWidget *parent, const int margin, const int h_spacing, const int v_spacing) : QLayout(parent), h_space(h_spacing), v_space(v_spacing) {
	setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::FlowLayout(const int margin, const int hSpacing, const int vSpacing) : h_space(hSpacing), v_space(vSpacing) {
	setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::~FlowLayout() {
	QLayoutItem *item;
	while ((item = FlowLayout::takeAt(0)))
		delete item;
}

void FlowLayout::addItem(QLayoutItem *item) {
	item_list.append(item);
}

void FlowLayout::insert_widget(const int index, QWidget* widget) {
	addWidget(widget);
	item_list.move(indexOf(widget), index);
}

void FlowLayout::move_widget(const int index, QWidget* widget) {
	if (index >= 0 && index < count()) {
		item_list.move(indexOf(widget), index);
		update();
	}
}

int FlowLayout::horizontal_spacing() const {
	return spacing();
	//if (h_space >= 0) {
	//	return h_space;
	//} else {
	//	return smart_spacing(QStyle::PM_LayoutHorizontalSpacing);
	//}
}

int FlowLayout::vertical_spacing() const {
	if (v_space >= 0) {
		return v_space;
	} else {
		return smart_spacing(QStyle::PM_LayoutVerticalSpacing);
	}
}

int FlowLayout::count() const {
	return item_list.size();
}

QLayoutItem *FlowLayout::itemAt(const int index) const {
	return item_list.value(index);
}

QLayoutItem *FlowLayout::takeAt(const int index) {
	if (index >= 0 && index < item_list.size())
		return item_list.takeAt(index);
	else
		return nullptr;
}

Qt::Orientations FlowLayout::expandingDirections() const {
	return Qt::Orientations();
}

bool FlowLayout::hasHeightForWidth() const {
	return true;
}


//int FlowLayout::heightForWidth(const int width) const {
//	const int height = do_layout(QRect(0, 0, width, 0), true);
//	return height;
//}

int FlowLayout::heightForWidth(const int width) const {
	const int height = do_layout(QRect(0, 0, width, 0), true, nullptr); // jpo38: set added parameter to NULL here
	return height;
}

//void FlowLayout::setGeometry(const QRect &rect) {
//	QLayout::setGeometry(rect);
//	do_layout(rect, false);
//}

void FlowLayout::setGeometry(const QRect &rect) {
	QLayout::setGeometry(rect);

	const QSize oldSize = min_size;
	do_layout(rect, false, &min_size);
	if (oldSize != min_size) {
		// force layout to consider new minimum size!
		invalidate();
	}
}

QSize FlowLayout::sizeHint() const {
	return minimumSize();
}

//QSize FlowLayout::minimumSize() const {
//	QSize size;
//	for (auto&& item : item_list) {
//		size = size.expandedTo(item->minimumSize());
//	}
//
//	size += QSize(2 * margin(), 2 * margin());
//	return size;
//}

QSize FlowLayout::minimumSize() const {
	return min_size;
}

QList<QLayoutItem*> FlowLayout::items() const {
	return item_list;
}

void FlowLayout::clear() {
	for (auto&& i : item_list) {
		i->widget()->deleteLater();
		delete i;
	}
	item_list.clear();
}

//int FlowLayout::do_layout(const QRect &rect, const bool test_only) const {
//	int left, top, right, bottom;
//	getContentsMargins(&left, &top, &right, &bottom);
//	QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
//	int x = effectiveRect.x();
//	int y = effectiveRect.y();
//	int lineHeight = 0;
//
//	for (auto&& item : item_list) {
//		QWidget *wid = item->widget();
//		int spaceX = horizontal_spacing();
//		if (spaceX == -1)
//			spaceX = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
//		int spaceY = vertical_spacing();
//		if (spaceY == -1)
//			spaceY = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
//		int nextX = x + item->sizeHint().width() + spaceX;
//		if (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {
//			x = effectiveRect.x();
//			y = y + lineHeight + spaceY;
//			nextX = x + item->sizeHint().width() + spaceX;
//			lineHeight = 0;
//		}
//
//		if (!test_only)
//			item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));
//
//		x = nextX;
//		lineHeight = qMax(lineHeight, item->sizeHint().height());
//	}
//	return y + lineHeight - rect.y() + bottom;
//}

int FlowLayout::do_layout(const QRect &rect, const bool test_only, QSize* p_min_size) const {
	int left, top, right, bottom;
	getContentsMargins(&left, &top, &right, &bottom);
	QRect effective_rect = rect.adjusted(+left, +top, -right, -bottom);
	int x = effective_rect.x();
	int y = effective_rect.y();
	int line_height = 0;

	// jpo38: store max X
	int max_x = 0;

	for (auto&& item : item_list) {
		QWidget *wid = item->widget();
		int space_x = horizontal_spacing();
		if (space_x == -1)
			space_x = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
		int space_y = vertical_spacing();
		if (space_y == -1)
			space_y = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
		int next_x = x + item->sizeHint().width() + space_x;
		if (next_x - space_x > effective_rect.right() && line_height > 0) {
			x = effective_rect.x();
			y = y + line_height + space_y;
			next_x = x + item->sizeHint().width() + space_x;
			line_height = 0;
		}

		if (!test_only)
			item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));

		// jpo38: update max X based on current position
		max_x = qMax(max_x, x + item->sizeHint().width() - rect.x() + left);

		x = next_x;
		line_height = qMax(line_height, item->sizeHint().height());
	}

	// jpo38: save height/width as max height/xidth in p_min_size is specified
	const int height = y + line_height - rect.y() + bottom;
	if (p_min_size) {
		p_min_size->setHeight(height);
		p_min_size->setWidth(max_x);
	}
	return height;
}

int FlowLayout::smart_spacing(const QStyle::PixelMetric pm) const {
	QObject *parent = this->parent();
	if (!parent) {
		return -1;
	} else if (parent->isWidgetType()) {
		QWidget *pw = dynamic_cast<QWidget *>(parent);
		return pw->style()->pixelMetric(pm, nullptr, pw);
	} else {
		return dynamic_cast<QLayout *>(parent)->spacing();
	}
}
```

`src/Base/FlowLayout.h`:

```h
#pragma once

#include <QLayout>
#include <QLayoutItem>
#include <QStyle>

// FlowLayout is a gridlike layout that will adjust the position of the items according to screen width

class FlowLayout : public QLayout {
public:
	explicit FlowLayout(QWidget *parent, int margin = -1, int h_spacing = -1, int v_spacing = -1);
	explicit FlowLayout(int margin = -1, int h_spacing = -1, int v_spacing = -1);
	~FlowLayout();

	void addItem(QLayoutItem *item) override;
	void insert_widget(int index, QWidget* widget);
	void move_widget(int index, QWidget* widget);
	int horizontal_spacing() const;
	int vertical_spacing() const;
	Qt::Orientations expandingDirections() const override;
	bool hasHeightForWidth() const override;
	int heightForWidth(int) const override;
	int count() const override;
	QLayoutItem *itemAt(int index) const override;
	QSize minimumSize() const override;
	void setGeometry(const QRect &rect) override;
	QSize sizeHint() const override;
	QLayoutItem *takeAt(int index) override;
	QList<QLayoutItem*> items() const;
	void clear();

private:
	int do_layout(const QRect &rect, bool test_only, QSize* p_min_size) const;
	int smart_spacing(QStyle::PixelMetric pm) const;

	QSize min_size;
	QList<QLayoutItem *> item_list;
	int h_space;
	int v_space;
};
```

`src/Base/GameCameras.ixx`:

```ixx
module;

#include <vector>
#include <string>
#include <iostream>

export module GameCameras;

import BinaryReader;
import Hierarchy;

export struct GameCamera {
	float target_x;
	float target_y;
	float z_offset;
	float rotation;
	float angle_of_attack;
	float distance;
	float roll;
	float fov;
	float far_z;
	float near_z;
	float local_roll;
	float local_pitch;
	float local_yaw;
	std::string name;
};

export class GameCameras {
  public:
	std::vector<GameCamera> cameras;

	void load(int game_version_major, int game_version_minor) {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3c");

		int version = reader.read<uint32_t>();
		if (version != 0) {
			std::cout << "Unknown war3map.w3c version: " << version << " Attempting to load but may crash\n";
		}

		cameras.resize(reader.read<uint32_t>());
		for (auto& i : cameras) {
			i.target_x = reader.read<float>();
			i.target_y = reader.read<float>();
			i.z_offset = reader.read<float>();
			i.rotation = reader.read<float>();
			i.angle_of_attack = reader.read<float>();
			i.distance = reader.read<float>();
			i.roll = reader.read<float>();
			i.fov = reader.read<float>();
			i.far_z = reader.read<float>();
			i.near_z = reader.read<float>();

			if (game_version_major * 100 + game_version_minor >= 131) {
				i.local_pitch = reader.read<float>();
				i.local_yaw = reader.read<float>();
				i.local_roll = reader.read<float>();
			}
			i.name = reader.read_c_string();
		}
	}

	void save() {
	}
};
```

`src/Base/Hierarchy.ixx`:

```ixx
module;

#include <vector>
#include <filesystem>
#include <map>
//#include <QSettings>
#include <iostream>
#include <fstream>

export module Hierarchy;

namespace fs = std::filesystem;
using namespace std::literals::string_literals;

import JSON;
import BinaryReader;
import CASC;
import no_init_allocator;

export class Hierarchy {
  public:
	char tileset = 'L';
	casc::CASC game_data;
	json::JSON aliases;

	fs::path map_directory;
	fs::path warcraft_directory;
	fs::path root_directory;

	bool ptr = false;
	bool hd = true;
	bool teen = false;
	bool local_files = true;

	bool open_casc(fs::path directory) {
		warcraft_directory = directory;
		/*QSettings settings;
		ptr = settings.value("flavour", "Retail").toString() != "Retail";
		hd = settings.value("hd", "True").toString() != "False";
		teen = settings.value("teen", "False").toString() != "False";
		QSettings war3reg("HKEY_CURRENT_USER\\Software\\Blizzard Entertainment\\Warcraft III", QSettings::NativeFormat);
		local_files = war3reg.value("Allow Local Files", 0).toInt() != 0;*/

		std::cout << "Loading CASC data from: " << warcraft_directory << "\n";
		bool open = game_data.open(warcraft_directory / (ptr ? ":w3t" : ":w3"));
		root_directory = warcraft_directory / (ptr ? "_ptr_" : "_retail_");

		if (open) {
			aliases.load(open_file("filealiases.json"));
		}
		return open;
	}

	BinaryReader open_file(const fs::path& path) const {
		casc::File file;

		if (local_files && fs::exists(root_directory / path)) {
			std::ifstream stream(root_directory / path, std::ios::binary);
			return BinaryReader(std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>()));
		} else if (hd && teen && map_file_exists("_hd.w3mod:_teen.w3mod:" + path.string())) {
			return map_file_read("_hd.w3mod:_teen.w3mod:" + path.string());
		} else if (hd && map_file_exists("_hd.w3mod:" + path.string())) {
			return map_file_read("_hd.w3mod:" + path.string());
		} else if (map_file_exists(path)) {
			return map_file_read(path);
		} else if (hd && game_data.file_exists("war3.w3mod:_hd.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_hd.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path.string());
		} else if (hd && teen && game_data.file_exists("war3.w3mod:_hd.w3mod:_teen.w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_hd.w3mod:_teen.w3mod:"s + path.string());
		} else if (hd && game_data.file_exists("war3.w3mod:_hd.w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_hd.w3mod:"s + path.string());
		} else if (game_data.file_exists("war3.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path.string());
		} else if (game_data.file_exists("war3.w3mod:_locales/enus.w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_locales/enus.w3mod:"s + path.string());
		} else if (teen && game_data.file_exists("war3.w3mod:_teen.w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_teen.w3mod:"s + path.string());
		} else if (game_data.file_exists("war3.w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:"s + path.string());
		} else if (game_data.file_exists("war3.w3mod:_deprecated.w3mod:"s + path.string())) {
			file = game_data.file_open("war3.w3mod:_deprecated.w3mod:"s + path.string());
		} else if (aliases.exists(path.string())) {
			return open_file(aliases.alias(path.string()));
		} else {
			throw std::invalid_argument(path.string() + " could not be found in the hierarchy");
		}

		return BinaryReader(file.read());
	}

	bool file_exists(const fs::path& path) const {
		if (path.empty()) {
			return false;
		}

		return (local_files && fs::exists(root_directory / path)) || (hd && teen && map_file_exists("_hd.w3mod:_teen.w3mod:" + path.string())) || (hd && map_file_exists("_hd.w3mod:" + path.string())) || map_file_exists(path) || (hd && game_data.file_exists("war3.w3mod:_hd.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path.string())) || (hd && teen && game_data.file_exists("war3.w3mod:_hd.w3mod:_teen.w3mod:"s + path.string())) || (hd && game_data.file_exists("war3.w3mod:_hd.w3mod:"s + path.string())) || game_data.file_exists("war3.w3mod:_tilesets/"s + tileset + ".w3mod:"s + path.string()) || game_data.file_exists("war3.w3mod:_locales/enus.w3mod:"s + path.string()) || (teen && game_data.file_exists("war3.w3mod:_teen.w3mod:"s + path.string())) || game_data.file_exists("war3.w3mod:"s + path.string()) || game_data.file_exists("war3.w3mod:_deprecated.w3mod:"s + path.string()) || (aliases.exists(path.string()) ? file_exists(aliases.alias(path.string())) : false);
	}

	BinaryReader map_file_read(const fs::path& path) const {
		std::ifstream stream(map_directory / path, std::ios::binary);
		return BinaryReader(std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>()));
	}

	/// source somewhere on disk, destination relative to the map
	void map_file_add(const fs::path& source, const fs::path& destination) const {
		fs::copy_file(source, map_directory / destination, fs::copy_options::overwrite_existing);
	}

	void map_file_write(const fs::path& path, const std::vector<uint8_t>& data) const {
		std::ofstream outfile(map_directory / path, std::ios::binary);

		if (!outfile) {
			throw std::runtime_error("Error writing file " + path.string());
		}

		outfile.write(reinterpret_cast<char const*>(data.data()), data.size());
	}

	void map_file_remove(const fs::path& path) const {
		fs::remove(map_directory / path);
	}

	bool map_file_exists(const fs::path& path) const {
		return fs::exists(map_directory / path);
	}

	void map_file_rename(const fs::path& original, const fs::path& renamed) const {
		fs::rename(map_directory / original, map_directory / renamed);
	}
};

export inline Hierarchy hierarchy;
```

`src/Base/Imports.ixx`:

```ixx
module;

#include <filesystem>
#include <unordered_set>

export module Imports;

import BinaryWriter;
import Hierarchy;
namespace fs = std::filesystem;

// HiveWE does not use the war3map.imp file at all, but the old WE does
// That's why we write the file at save time
export class Imports {
  public:

	std::unordered_set<std::string> blacklist = {
		"conversation.json",
		"war3mapUnits.doo",
		"war3map.doo",
		"war3map.imp",
		"war3map.j",
		"war3map.mmp",
		"war3map.shd",
		"war3map.w3a",
		"war3map.w3b",
		"war3map.w3c",
		"war3map.w3d",
		"war3map.w3e",
		"war3map.w3h",
		"war3map.w3i",
		"war3map.w3q",
		"war3map.w3r",
		"war3map.w3t",
		"war3map.w3u",
		"war3map.wct",
		"war3map.wpm",
		"war3map.wtg",
		"war3map.wts",
		"war3map.w3s",
		"war3mapMap.blp",
		"war3mapExtra.txt",
		"war3mapMisc.txt",
		"war3mapSkin.txt"
	};

	/// Requires the filesystem_path for the map to make the saved paths lexically relative
	void save(fs::path filesystem_path) const {
		BinaryWriter writer;

		writer.write<uint32_t>(1);

		int count = 0;
		for (const auto& i : fs::recursive_directory_iterator(filesystem_path)) {
			if (i.is_regular_file()) {
				std::string file_name = i.path().filename().string();
				if (blacklist.contains(file_name)) {
					continue;
				}
				count++;
			}
		}
		writer.write<uint32_t>(count);

		for (const auto& i : fs::recursive_directory_iterator(filesystem_path)) {
			if (i.is_regular_file()) {
				std::string path = i.path().lexically_relative(filesystem_path).string();
				std::string file_name = i.path().filename().string();
				if (blacklist.contains(file_name)) {
					continue;
				}

				writer.write<uint8_t>(13);
				writer.write_c_string(path);
			}
		}

		hierarchy.map_file_write("war3map.imp", writer.buffer);
	}
};
```

`src/Base/InputHandler.cpp`:

```cpp
#include "InputHandler.h"


bool InputHandler::key_pressed(const Qt::Key key) const {
	return keys_pressed.count(key);
}

void InputHandler::mouse_move_event(QMouseEvent* event) {
	previous_mouse = mouse;
	mouse = { event->pos().x(), event->pos().y() };
}
```

`src/Base/InputHandler.h`:

```h
#pragma once

#include <unordered_set>

#include <QMouseEvent>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

class InputHandler {
public:
	glm::vec2 mouse;
	glm::vec2 previous_mouse;

	glm::vec3 mouse_world;
	glm::vec3 previous_mouse_world;

	glm::vec3 drag_start;

	std::unordered_set<int> keys_pressed;

	void mouse_move_event(QMouseEvent* event);

	bool key_pressed(Qt::Key key) const;
};

inline InputHandler input_handler;
```

`src/Base/Map.cpp`:

```cpp
#include "Map.h"

#include <execution>
#include <random>

#include <QMessageBox>
#include <QOpenGLFunctions_4_5_Core>

import Hierarchy;

#include "Globals.h"
#include "InputHandler.h"
#include "Physics.h"
#include "Camera.h"

import Timer;

#include <fstream>
#include <bullet/btBulletDynamicsCommon.h>
#include <fmt/format.h>

using namespace std::literals::string_literals;

void Map::load(const fs::path& path) {
	Timer timer;

	hierarchy.map_directory = path;
	filesystem_path = fs::absolute(path) / "";
	name = (*--(--filesystem_path.end())).string();

	// ToDo So for the game data files we should actually load from _balance/custom_v0.w3mod/Units, _balance/custom_v1.w3mod/Units, _balance/melee_v0.w3mod/units or /Units depending on the Game Data set and Game Data Versions
	// Maybe just ignore RoC so we only need to choose between _balance/custom_v1.w3mod/Units and /Units
	// Maybe just force everyone to suck it up and use /Units

	// Units
	units_slk = slk::SLK("Units/UnitData.slk");
	// By making some changes to unitmetadata.slk and unitdata.slk we can avoid the 1->2->2 mapping for SLK->OE->W3U files. We have to add some columns for this though
	units_slk.add_column("missilearc2");
	units_slk.add_column("missileart2");
	units_slk.add_column("missilespeed2");
	units_slk.add_column("buttonpos2");

	units_meta_slk = slk::SLK("Data/Warcraft/UnitMetaData.slk", true);
	units_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
	units_meta_slk.build_meta_map();

	unit_editor_data = ini::INI("UI/UnitEditorData.txt");
	unit_editor_data.substitute(world_edit_strings, "WorldEditStrings");
	// Have to substitute twice since some of the keys refer to other keys in the same file
	unit_editor_data.substitute(world_edit_strings, "WorldEditStrings");

	units_slk.merge(ini::INI("Units/UnitSkin.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/UnitWeaponsFunc.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/UnitWeaponsSkin.txt"), units_meta_slk);

	units_slk.merge(slk::SLK("Units/UnitBalance.slk"));
	units_slk.merge(slk::SLK("Units/unitUI.slk"));
	units_slk.merge(slk::SLK("Units/UnitWeapons.slk"));
	units_slk.merge(slk::SLK("Units/UnitAbilities.slk"));

	units_slk.merge(ini::INI("Units/HumanUnitFunc.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/OrcUnitFunc.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/UndeadUnitFunc.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/NightElfUnitFunc.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/NeutralUnitFunc.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/CampaignUnitFunc.txt"), units_meta_slk);

	units_slk.merge(ini::INI("Units/HumanUnitStrings.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/OrcUnitStrings.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/UndeadUnitStrings.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/NightElfUnitStrings.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/NeutralUnitStrings.txt"), units_meta_slk);
	units_slk.merge(ini::INI("Units/CampaignUnitStrings.txt"), units_meta_slk);

	abilities_slk = slk::SLK("Units/AbilityData.slk");
	abilities_meta_slk = slk::SLK("Units/AbilityMetaData.slk");
	abilities_meta_slk.substitute(world_edit_strings, "WorldEditStrings");

	// Patch the SLKs
	abilities_slk.add_column("buttonpos2");
	abilities_slk.add_column("unbuttonpos2");
	abilities_slk.add_column("researchbuttonpos2");
	abilities_meta_slk.set_shadow_data("field", "abpy", "buttonpos2");
	abilities_meta_slk.set_shadow_data("field", "auby", "unbuttonpos2");
	abilities_meta_slk.set_shadow_data("field", "arpy", "researchbuttonpos2");
	abilities_meta_slk.build_meta_map();

	abilities_slk.merge(ini::INI("Units/AbilitySkin.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/AbilitySkinStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/HumanAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/OrcAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/UndeadAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/NightElfAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/NeutralAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/ItemAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/CommonAbilityFunc.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/CampaignAbilityFunc.txt"), abilities_meta_slk);

	abilities_slk.merge(ini::INI("Units/HumanAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/OrcAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/UndeadAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/NightElfAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/NeutralAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/ItemAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/CommonAbilityStrings.txt"), abilities_meta_slk);
	abilities_slk.merge(ini::INI("Units/CampaignAbilityStrings.txt"), abilities_meta_slk);

	// Items
	items_slk = slk::SLK("Units/ItemData.slk");
	items_meta_slk = slk::SLK("Data/Warcraft/ItemMetaData.slk", true);
	items_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
	items_meta_slk.build_meta_map();

	items_slk.merge(ini::INI("Units/ItemSkin.txt"), items_meta_slk);
	items_slk.merge(ini::INI("Units/ItemFunc.txt"), items_meta_slk);
	items_slk.merge(ini::INI("Units/ItemStrings.txt"), items_meta_slk);

	// Doodads
	doodads_slk = slk::SLK("Doodads/Doodads.slk");
	doodads_meta_slk = slk::SLK("Doodads/DoodadMetaData.slk");
	doodads_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
	doodads_meta_slk.build_meta_map();

	doodads_slk.merge(ini::INI("Doodads/DoodadSkins.txt"), doodads_meta_slk);
	doodads_slk.substitute(world_edit_strings, "WorldEditStrings");
	doodads_slk.substitute(world_edit_game_strings, "WorldEditStrings");

	// Destructables
	destructibles_slk = slk::SLK("Units/DestructableData.slk");
	destructibles_slk.substitute(world_edit_strings, "WorldEditStrings");

	destructibles_meta_slk = slk::SLK("Units/DestructableMetaData.slk");
	destructibles_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
	destructibles_meta_slk.build_meta_map();

	//Fix Scorched tree
	destructibles_slk.merge(ini::INI("Data/Warcraft/DestructableSkin.txt", true), destructibles_meta_slk);

	destructibles_slk.merge(ini::INI("Units/DestructableSkin.txt"), destructibles_meta_slk);
	destructibles_slk.substitute(world_edit_strings, "WorldEditStrings");
	destructibles_slk.substitute(world_edit_game_strings, "WorldEditStrings");

	upgrade_slk = slk::SLK("Units/UpgradeData.slk");
	upgrade_meta_slk = slk::SLK("Units/UpgradeMetaData.slk");
	upgrade_meta_slk.substitute(world_edit_strings, "WorldEditStrings");

	// Patch the SLKs
	upgrade_slk.add_column("buttonpos2");
	upgrade_meta_slk.set_shadow_data("field", "gbpy", "buttonpos2");
	upgrade_meta_slk.build_meta_map();

	upgrade_slk.merge(ini::INI("Units/AbilitySkin.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/UpgradeSkin.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/HumanUpgradeFunc.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/OrcUpgradeFunc.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/UndeadUpgradeFunc.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/NightElfUpgradeFunc.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/NeutralUpgradeFunc.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/CampaignUpgradeFunc.txt"), upgrade_meta_slk);

	upgrade_slk.merge(ini::INI("Units/CampaignUpgradeStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/HumanUpgradeStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/NeutralUpgradeStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/NightElfUpgradeStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/OrcUpgradeStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/UndeadUpgradeStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/UpgradeSkinStrings.txt"), upgrade_meta_slk);
	upgrade_slk.merge(ini::INI("Units/CampaignUpgradeFunc.txt"), upgrade_meta_slk);

	buff_slk = slk::SLK("Units/AbilityBuffData.slk");
	buff_meta_slk = slk::SLK("Units/AbilityBuffMetaData.slk");
	buff_meta_slk.substitute(world_edit_strings, "WorldEditStrings");
	buff_meta_slk.build_meta_map();

	buff_slk.merge(ini::INI("Units/AbilitySkin.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/AbilitySkinStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/HumanAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/OrcAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/UndeadAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/NightElfAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/NeutralAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/ItemAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/CommonAbilityFunc.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/CampaignAbilityFunc.txt"), buff_meta_slk);

	buff_slk.merge(ini::INI("Units/HumanAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/OrcAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/UndeadAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/NightElfAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/NeutralAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/ItemAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/CommonAbilityStrings.txt"), buff_meta_slk);
	buff_slk.merge(ini::INI("Units/CampaignAbilityStrings.txt"), buff_meta_slk);

	units_table = new TableModel(&units_slk, &units_meta_slk);
	items_table = new TableModel(&items_slk, &items_meta_slk);
	abilities_table = new TableModel(&abilities_slk, &abilities_meta_slk);
	doodads_table = new TableModel(&doodads_slk, &doodads_meta_slk);
	destructibles_table = new TableModel(&destructibles_slk, &destructibles_meta_slk);
	upgrade_table = new TableModel(&upgrade_slk, &upgrade_meta_slk);
	buff_table = new TableModel(&buff_slk, &buff_meta_slk);

	fmt::print("\nSLK loading:\t {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	// Trigger strings
	if (hierarchy.map_file_exists("war3map.wts")) {
		trigger_strings.load();
	}

	// Triggers (GUI and JASS)
	if (hierarchy.map_file_exists("war3map.wtg")) {
		triggers.load();

		// Custom text triggers (JASS)
		if (hierarchy.map_file_exists("war3map.wct")) {
			triggers.load_jass();
		}
	}

	fmt::print("Trigger loading: {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	info.load();
	terrain.load();

	fmt::print("Terrain loading: {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	// Pathing Map
	if (hierarchy.map_file_exists("war3map.wpm")) {
		pathing_map.load();
	} else {
		pathing_map.resize(terrain.width * 4, terrain.height * 4);
	}

	fmt::print("Pathing loading: {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	// Doodads
	if (hierarchy.map_file_exists("war3map.w3d")) {
		load_modification_file("war3map.w3d", doodads_slk, doodads_meta_slk, true);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3d")) {
		load_modification_file("war3mapSkin.w3d", doodads_slk, doodads_meta_slk, true);
	}

	if (hierarchy.map_file_exists("war3map.w3b")) {
		load_modification_file("war3map.w3b", destructibles_slk, destructibles_meta_slk, false);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3b")) {
		load_modification_file("war3mapSkin.w3b", destructibles_slk, destructibles_meta_slk, false);
	}

	doodads.load();
	doodads.create();

	fmt::print("Doodad loading:\t {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	if (hierarchy.map_file_exists("war3map.w3u")) {
		load_modification_file("war3map.w3u", units_slk, units_meta_slk, false);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3u")) {
		load_modification_file("war3mapSkin.w3u", units_slk, units_meta_slk, false);
	}

	if (hierarchy.map_file_exists("war3map.w3t")) {
		load_modification_file("war3map.w3t", items_slk, items_meta_slk, false);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3t")) {
		load_modification_file("war3mapSkin.w3t", items_slk, items_meta_slk, false);
	}

	// Units/Items
	if (hierarchy.map_file_exists("war3mapUnits.doo")) {
		units.load();
		units.create();
	}

	fmt::print("Unit loading:\t {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	// Abilities
	if (hierarchy.map_file_exists("war3map.w3a")) {
		load_modification_file("war3map.w3a", abilities_slk, abilities_meta_slk, true);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3a")) {
		load_modification_file("war3mapSkin.w3a", abilities_slk, abilities_meta_slk, true);
	}

	// Buffs
	if (hierarchy.map_file_exists("war3map.w3h")) {
		load_modification_file("war3map.w3h", buff_slk, buff_meta_slk, false);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3h")) {
		load_modification_file("war3mapSkin.w3h", buff_slk, buff_meta_slk, false);
	}

	// Upgrades
	if (hierarchy.map_file_exists("war3map.w3q")) {
		load_modification_file("war3map.w3q", upgrade_slk, upgrade_meta_slk, true);
	}

	if (hierarchy.map_file_exists("war3mapSkin.w3q")) {
		load_modification_file("war3mapSkin.w3q", upgrade_slk, upgrade_meta_slk, true);
	}

	// Regions
	if (hierarchy.map_file_exists("war3map.w3r")) {
		regions.load();
	}

	// Cameras
	if (hierarchy.map_file_exists("war3map.w3c")) {
		cameras.load(map->info.game_version_major, map->info.game_version_minor);
	}

	// Sounds
	if (hierarchy.map_file_exists("war3map.w3s")) {
		sounds.load();
	}

	fmt::print("Misc loading:\t {:>5}ms\n", timer.elapsed_ms());
	timer.reset();

	// Center camera
	camera->position = glm::vec3(terrain.width / 2, terrain.height / 2, 0);
	camera->position.z = terrain.interpolated_height(camera->position.x, camera->position.y);

	loaded = true;

	connect(units_table, &TableModel::dataChanged, [&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
		const std::string& id = units_slk.index_to_row.at(top_left.row());
		const std::string& field = units_slk.index_to_column.at(top_left.column());
		units.process_field_change(id, field);
	});

	connect(doodads_table, &TableModel::dataChanged, [&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
		const std::string& id = doodads_slk.index_to_row.at(top_left.row());
		const std::string& field = doodads_slk.index_to_column.at(top_left.column());
		doodads.process_doodad_field_change(id, field);
	});

	connect(destructibles_table, &TableModel::dataChanged, [&](const QModelIndex& top_left, const QModelIndex& top_right, const QVector<int>& roles) {
		const std::string& id = destructibles_slk.index_to_row.at(top_left.row());
		const std::string& field = destructibles_slk.index_to_column.at(top_left.column());
		doodads.process_destructible_field_change(id, field);
	});
}

bool Map::save(const fs::path& path) {
	if (!fs::equivalent(path, filesystem_path)) {
		try {
			fs::copy(filesystem_path, fs::absolute(path), fs::copy_options::recursive);
		} catch (fs::filesystem_error& e) {
			QMessageBox msgbox;
			msgbox.setText(e.what());
			msgbox.exec();
			return false;
		}
		filesystem_path = fs::absolute(path) / "";
		name = (*--(--filesystem_path.end())).string();
	}

	pathing_map.save();
	terrain.save();

	save_modification_file("war3map.w3d", doodads_slk, doodads_meta_slk, true, false);
	save_modification_file("war3mapSkin.w3d", doodads_slk, doodads_meta_slk, true, true);
	save_modification_file("war3map.w3b", destructibles_slk, destructibles_meta_slk, false, false);
	save_modification_file("war3mapSkin.w3b", destructibles_slk, destructibles_meta_slk, false, true);
	doodads.save();

	save_modification_file("war3map.w3u", units_slk, units_meta_slk, false, false);
	save_modification_file("war3mapSkin.w3u", units_slk, units_meta_slk, false, true);
	save_modification_file("war3map.w3t", items_slk, items_meta_slk, false, false);
	save_modification_file("war3mapSkin.w3t", items_slk, items_meta_slk, false, true);
	units.save();

	save_modification_file("war3map.w3a", abilities_slk, abilities_meta_slk, true, false);
	save_modification_file("war3mapSkin.w3a", abilities_slk, abilities_meta_slk, true, true);

	save_modification_file("war3map.w3h", buff_slk, buff_meta_slk, false, false);
	save_modification_file("war3mapSkin.w3h", buff_slk, buff_meta_slk, false, true);
	save_modification_file("war3map.w3q", upgrade_slk, upgrade_meta_slk, true, false);
	save_modification_file("war3mapSkin.w3q", upgrade_slk, upgrade_meta_slk, true, true);

	info.save(terrain.tileset);
	trigger_strings.save();
	triggers.save();
	triggers.save_jass();
	triggers.generate_map_script();
	imports.save(map->filesystem_path);

	return true;
}

void Map::update(double delta, int width, int height) {
	if (!loaded) {
		return;
	}

	camera->update(delta);

	// Update current water texture index
	terrain.current_texture += std::max(0.0, terrain.animation_rate * delta);
	if (terrain.current_texture >= terrain.water_textures_nr) {
		terrain.current_texture = 0;
	}

	/*auto current_time = std::chrono::steady_clock::now().time_since_epoch();
	auto seconds = std::chrono::duration_cast<std::chrono::milliseconds>(current_time).count() / 1000.f;
	light_direction = glm::normalize(glm::vec3(std::cos(seconds), std::sin(seconds), -2.f));*/

	// Map mouse coordinates to world coordinates
	if (input_handler.mouse != input_handler.previous_mouse) {
		glm::vec3 window = { input_handler.mouse.x, height - input_handler.mouse.y, 1.f };
		glm::vec3 pos = glm::unProject(window, camera->view, camera->projection, glm::vec4(0, 0, width, height));
		glm::vec3 origin = camera->position - camera->direction * camera->distance;
		glm::vec3 direction = glm::normalize(pos - origin);
		glm::vec3 toto = origin + direction * 2000.f;

		btVector3 from(origin.x, origin.y, origin.z);
		btVector3 to(toto.x, toto.y, toto.z);

		btCollisionWorld::ClosestRayResultCallback res(from, to);
		res.m_collisionFilterGroup = 32;
		res.m_collisionFilterMask = 32;
		physics.dynamicsWorld->rayTest(from, to, res);

		if (res.hasHit()) {
			auto& hit = res.m_hitPointWorld;
			input_handler.previous_mouse_world = input_handler.mouse_world;
			input_handler.mouse_world = glm::vec3(hit.x(), hit.y(), hit.z());
		}
	}

	// Animate units
	std::for_each(std::execution::par_unseq, units.units.begin(), units.units.end(), [&](Unit& i) {
		if (i.id == "sloc") {
			return;
		} // ToDo handle starting locations

		mdx::Extent& extent = i.mesh->model->sequences[i.skeleton.sequence_index].extent;
		if (!camera->inside_frustrum(i.matrix * glm::vec4(extent.minimum, 1.f), i.matrix * glm::vec4(extent.maximum, 1.f))) {
			return;
		}

		i.skeleton.update(delta);
	});

	// Animate items
	for (auto& i : units.items) {
		i.skeleton.update(delta);
	}

	// Animate doodads
	std::for_each(std::execution::par_unseq, doodads.doodads.begin(), doodads.doodads.end(), [&](Doodad& i) {
		if (!i.mesh->model->sequences.empty()) {
			mdx::Extent& extent = i.mesh->model->sequences[i.skeleton.sequence_index].extent;
			if (!camera->inside_frustrum(i.matrix * glm::vec4(extent.minimum, 1.f), i.matrix * glm::vec4(extent.maximum, 1.f))) {
				return;
			}
		}

		i.skeleton.update(delta);
	});
}

void Map::render() {
	// While switching maps it may happen that render is called before loading has finished.
	if (!loaded) {
		return;
	}

	gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	gl->glPolygonMode(GL_FRONT_AND_BACK, render_wireframe ? GL_LINE : GL_FILL);

	terrain.render_ground();

	if (render_doodads) {
		doodads.render();
	}

	if (render_units) {
		units.render();
	}

	if (render_brush && brush) {
		brush->render();
	}

	render_manager.render(render_lighting, light_direction);

	terrain.render_water();

	//physics.dynamicsWorld->debugDrawWorld();
	//physics.draw->render();
}

void Map::resize(size_t width, size_t height) {
	terrain.resize(width, height);
	pathing_map.resize(width * 4, height * 4);
}

std::string Map::get_unique_id(bool first_uppercase) {
	std::random_device rd;
	std::mt19937 mt(rd());
	std::uniform_int_distribution<int> dist(0, 25);
again:

	std::string id = ""s + char((first_uppercase ? 'A' : 'a') + dist(mt)) + char('a' + dist(mt)) + char('a' + dist(mt)) + char('a' + dist(mt));

	if (units_slk.row_headers.contains(id) 
		|| items_slk.row_headers.contains(id) 
		|| abilities_slk.row_headers.contains(id) 
		|| doodads_slk.row_headers.contains(id) 
		|| destructibles_slk.row_headers.contains(id) 
		|| upgrade_slk.row_headers.contains(id) 
		|| buff_slk.row_headers.contains(id)) {

		fmt::print("Generated an existing ID: {} what're the odds\n", id);
		goto again;
	}

	return id;
}
```

`src/Base/Map.h`:

```h
#pragma once

#include "TriggerStrings.h"
#include "Triggers.h"
//#include "MapInfo.h"
#include "Terrain.h"
#include "TerrainUndo.h"
#include "PathingMap.h"
#include "Doodads.h"
#include "Units.h"
#include "Regions.h"
#include "Sounds.h"
#include "RenderManager.h"

#include "Brush.h"
#include "Physics.h"

#include <filesystem> // Filesystem include at the bottom due to QTBUG-73263


import GameCameras;
import Imports;
import MapInfo;
namespace fs = std::filesystem;

class Map : public QObject {
	Q_OBJECT

  public:
	bool loaded = false;

	TriggerStrings trigger_strings;
	Triggers triggers;
	MapInfo info;
	Terrain terrain;
	TerrainUndo terrain_undo;
	PathingMap pathing_map;
	Imports imports;
	Doodads doodads;
	Units units;
	Regions regions;
	GameCameras cameras;
	Sounds sounds;

	Brush* brush = nullptr;
	Physics physics;

	bool enforce_water_height_limits = true;

	bool render_doodads = true;
	bool render_units = true;
	bool render_pathing = false;
	bool render_brush = true;
	bool render_lighting = true;
	bool render_wireframe = false;
	bool render_debug = false;

	glm::vec3 light_direction = glm::normalize(glm::vec3(1.f, 1.f, -3.f));

	fs::path filesystem_path;
	std::string name;

	RenderManager render_manager;

	void load(const fs::path& path);
	bool save(const fs::path& path);

	void update(double delta, int width, int height);
	void render();

	void resize(size_t width, size_t height);

	std::string get_unique_id(bool first_uppercase);
};
```

`src/Base/MapInfo.ixx`:

```ixx
module;

#include <string>
#include <vector>
#include <iostream>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>

export module MapInfo;

import BinaryReader;
import BinaryWriter;
import Hierarchy;

export enum class PlayerType {
	human,
	computer,
	neutral,
	rescuable
};

export enum class PlayerRace {
	selectable,
	human,
	orc,
	undead,
	night_elf
};

struct PlayerData {
	int internal_number;
	PlayerType type;
	PlayerRace race;
	int fixed_start_position;
	std::string name;
	glm::vec2 starting_position;
	uint32_t ally_low_priorities_flags;
	uint32_t ally_high_priorities_flags;
	uint32_t enemy_low_priorities_flags = 0;
	uint32_t enemy_high_priorities_flags = 0;
};

struct ForceData {
	bool allied;
	bool allied_victory;
	bool share_vision;
	bool share_unit_control;
	bool share_advanced_unit_control;
	int player_masks;
	std::string name;
};

struct UpgradeAvailability {
	int player_flags;
	std::string id;
	int level;
	int availability;
};

struct TechAvailability {
	int player_flags;
	std::string id;
};

struct RandomUnitLine {
	int chance;
	std::vector<std::string> ids;
};

struct RandomUnitTable {
	int number;
	std::string name;
	std::vector<int> positions;
	std::vector<RandomUnitLine> lines;
};

struct RandomItemSets {
	std::vector<std::tuple<int, std::string>> items;
};

struct RandomItemTable {
	int number;
	std::string name;
	std::vector<RandomItemSets> item_sets;
};

export class MapInfo {
  public:
	int map_version;
	int editor_version;
	int game_version_major;
	int game_version_minor;
	int game_version_patch;
	int game_version_build;
	std::string name;
	std::string author;
	std::string description;
	std::string suggested_players;

	glm::vec2 camera_left_bottom;
	glm::vec2 camera_right_top;
	glm::vec2 camera_left_top;
	glm::vec2 camera_right_bottom;

	glm::ivec4 camera_complements;

	int playable_width;
	int playable_height;

	int all_flags;
	bool hide_minimap_preview;
	bool modif_ally_priorities;
	bool melee_map;
	bool unknown;
	bool masked_area_partially_visible;
	bool fixed_player_settings;
	bool custom_forces;
	bool custom_techtree;
	bool custom_abilities;
	bool custom_upgrades;
	bool unknown2;
	bool cliff_shore_waves;
	bool rolling_shore_waves;
	bool unknown3;
	bool unknown4;
	bool item_classification;
	bool water_tinting;
	bool accurate_probability_for_calculations;
	bool custom_ability_skins;

	int loading_screen_number;
	std::string loading_screen_model;
	std::string loading_screen_text;
	std::string loading_screen_title;
	std::string loading_screen_subtitle;

	int game_data_set;

	std::string prologue_screen_model;
	std::string prologue_text;
	std::string prologue_title;
	std::string prologue_subtitle;

	int fog_style;
	float fog_start_z_height;
	float fog_end_z_height;
	float fog_density;
	glm::u8vec4 fog_color;

	int weather_id;
	std::string custom_sound_environment;
	char custom_light_tileset;
	glm::u8vec4 water_color;

	bool lua;
	uint32_t supported_modes;
	uint32_t game_data_version;

	std::vector<PlayerData> players;
	std::vector<ForceData> forces;
	std::vector<UpgradeAvailability> available_upgrades;
	std::vector<TechAvailability> available_tech;
	std::vector<RandomUnitTable> random_unit_tables;
	std::vector<RandomItemTable> random_item_tables;

	static constexpr int write_version = 31;
	static constexpr int write_editor_version = 6105;
	static constexpr int write_game_version_major = 1;
	static constexpr int write_game_version_minor = 32;
	static constexpr int write_game_version_patch = 1;
	static constexpr int write_game_version_build = 14604;

	void load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3i");

		const int version = reader.read<uint32_t>();

		if (version != 31 && version != 28 && version != 25 && version != 18 && version != 15) {
			std::cout << "Unknown war3map.w3i version\n";
		}

		if (version >= 18) {
			map_version = reader.read<uint32_t>();
			editor_version = reader.read<uint32_t>();

			if (version >= 28) {
				game_version_major = reader.read<uint32_t>();
				game_version_minor = reader.read<uint32_t>();
				game_version_patch = reader.read<uint32_t>();
				game_version_build = reader.read<uint32_t>();
			}
		}
		name = reader.read_c_string();
		author = reader.read_c_string();
		description = reader.read_c_string();
		suggested_players = reader.read_c_string();

		camera_left_bottom = reader.read<glm::vec2>();
		camera_right_top = reader.read<glm::vec2>();
		camera_left_top = reader.read<glm::vec2>();
		camera_right_bottom = reader.read<glm::vec2>();

		camera_complements = reader.read<glm::ivec4>();

		playable_width = reader.read<uint32_t>();
		playable_height = reader.read<uint32_t>();

		const int flags = reader.read<uint32_t>();
		hide_minimap_preview = flags & 0x0001;
		modif_ally_priorities = flags & 0x0002;
		melee_map = flags & 0x0004;
		unknown = flags & 0x0008; // playable map size was large
		masked_area_partially_visible = flags & 0x0010;
		fixed_player_settings = flags & 0x0020;
		custom_forces = flags & 0x0040;
		custom_techtree = flags & 0x0080;
		custom_abilities = flags & 0x0100;
		custom_upgrades = flags & 0x0200;
		unknown2 = flags & 0x0400; // has properties menu been opened
		cliff_shore_waves = flags & 0x0800;
		rolling_shore_waves = flags & 0x1000;
		unknown3 = flags & 0x2000; // has terrain fog
		unknown4 = flags & 0x4000; // requires expansion
		item_classification = flags & 0x8000;
		water_tinting = flags & 0x10000;
		accurate_probability_for_calculations = flags & 0x20000;
		custom_ability_skins = flags & 0x40000;

		// Tileset
		reader.advance(1);

		if (version >= 25) { // TFT
			loading_screen_number = reader.read<uint32_t>();
			loading_screen_model = reader.read_c_string();
			loading_screen_text = reader.read_c_string();
			loading_screen_title = reader.read_c_string();
			loading_screen_subtitle = reader.read_c_string();

			game_data_set = reader.read<uint32_t>();

			prologue_screen_model = reader.read_c_string();
			prologue_text = reader.read_c_string();
			prologue_title = reader.read_c_string();
			prologue_subtitle = reader.read_c_string();

			fog_style = reader.read<uint32_t>();
			fog_start_z_height = reader.read<float>();
			fog_end_z_height = reader.read<float>();
			fog_density = reader.read<float>();
			fog_color = reader.read<glm::u8vec4>();

			weather_id = reader.read<uint32_t>();
			custom_sound_environment = reader.read_c_string();
			custom_light_tileset = reader.read<uint8_t>();
			water_color = reader.read<glm::u8vec4>();

			if (version >= 28) {
				lua = reader.read<uint32_t>() == 1;
			}

			if (version >= 31) {
				supported_modes = reader.read<uint32_t>();
				game_data_version = reader.read<uint32_t>();
			}
		} else if (version == 18) { // RoC
			loading_screen_number = reader.read<uint32_t>();
			loading_screen_text = reader.read_c_string();
			loading_screen_title = reader.read_c_string();
			loading_screen_subtitle = reader.read_c_string();

			// game_data_set = reader.read<uint32_t>();
			reader.advance(4); // ToDo RoC map loading screen number

			prologue_text = reader.read_c_string();
			prologue_title = reader.read_c_string();
			prologue_subtitle = reader.read_c_string();
		} else {
			reader.advance(1); // unknown, loading screen number but only 1 digit?
			loading_screen_text = reader.read_c_string();
			loading_screen_title = reader.read_c_string();
			loading_screen_subtitle = reader.read_c_string();
			reader.advance(4); // prologue stuff?
		}

		players.resize(reader.read<uint32_t>());
		for (auto&& i : players) {
			i.internal_number = reader.read<uint32_t>();
			i.type = static_cast<PlayerType>(reader.read<uint32_t>() - 1);
			i.race = static_cast<PlayerRace>(reader.read<uint32_t>());
			i.fixed_start_position = reader.read<uint32_t>();
			i.name = reader.read_c_string();
			i.starting_position = reader.read<glm::vec2>();
			i.ally_low_priorities_flags = reader.read<uint32_t>();
			i.ally_high_priorities_flags = reader.read<uint32_t>();
			if (version >= 31) {
				i.enemy_low_priorities_flags = reader.read<uint32_t>();
				i.enemy_high_priorities_flags = reader.read<uint32_t>();
			}
		}

		forces.resize(reader.read<uint32_t>());
		for (auto&& i : forces) {
			const uint32_t force_flags = reader.read<uint32_t>();
			i.allied = force_flags & 0b00000001;
			i.allied_victory = force_flags & 0b00000010;
			i.share_vision = force_flags & 0b00001000;
			i.share_unit_control = force_flags & 0b00010000;
			i.share_advanced_unit_control = force_flags & 0b00100000;

			i.player_masks = reader.read<uint32_t>();
			i.name = reader.read_c_string();
		}

		if (reader.remaining() < 4) {
			return;
		}

		available_upgrades.resize(reader.read<uint32_t>());
		for (auto&& i : available_upgrades) {
			i.player_flags = reader.read<uint32_t>();
			i.id = reader.read_string(4);
			i.level = reader.read<uint32_t>();
			i.availability = reader.read<uint32_t>();
		}

		if (reader.remaining() < 4) {
			return;
		}

		available_tech.resize(reader.read<uint32_t>());
		for (auto&& i : available_tech) {
			i.player_flags = reader.read<uint32_t>();
			i.id = reader.read_string(4);
		}

		if (reader.remaining() < 4) {
			return;
		}

		random_unit_tables.resize(reader.read<uint32_t>());
		for (auto&& i : random_unit_tables) {
			i.number = reader.read<uint32_t>();
			i.name = reader.read_c_string();
			i.positions = reader.read_vector<int>(reader.read<uint32_t>());

			i.lines.resize(reader.read<uint32_t>());
			for (auto&& j : i.lines) {
				j.chance = reader.read<uint32_t>();
				for (size_t k = 0; k < i.positions.size(); k++) {
					j.ids.push_back(reader.read_string(4));
				}
			}
		}

		if (reader.remaining() < 4) {
			return;
		}

		if (version >= 25) {
			random_item_tables.resize(reader.read<uint32_t>());
			for (auto&& i : random_item_tables) {
				i.number = reader.read<uint32_t>();
				i.name = reader.read_c_string();
				i.item_sets.resize(reader.read<uint32_t>());
				for (auto&& j : i.item_sets) {
					j.items.resize(reader.read<uint32_t>());
					for (auto&& [chance, id] : j.items) {
						chance = reader.read<uint32_t>();
						id = reader.read_string(4);
					}
				}
			}
		}
	}

	void save(char tileset) const {
		BinaryWriter writer;

		writer.write(write_version);
		writer.write(map_version);
		writer.write(write_editor_version);
		writer.write(write_game_version_major);
		writer.write(write_game_version_minor);
		writer.write(write_game_version_patch);
		writer.write(write_game_version_build);
		writer.write_c_string(name);
		writer.write_c_string(author);
		writer.write_c_string(description);
		writer.write_c_string(suggested_players);

		writer.write(camera_left_bottom);
		writer.write(camera_right_top);
		writer.write(camera_left_top);
		writer.write(camera_right_bottom);

		writer.write(camera_complements);

		writer.write(playable_width);
		writer.write(playable_height);

		const int flags = hide_minimap_preview * 0x0001 | modif_ally_priorities * 0x0002 | melee_map * 0x0004 | unknown * 0x0008 | masked_area_partially_visible * 0x0010 | fixed_player_settings * 0x0020 | custom_forces * 0x0040 | custom_techtree * 0x0080 | custom_abilities * 0x0100 | custom_upgrades * 0x0200 | unknown2 * 0x0400 | cliff_shore_waves * 0x0800 | rolling_shore_waves * 0x1000 | unknown3 * 0x2000 | unknown4 * 0x4000 | item_classification * 0x8000 | water_tinting * 0x10000 | accurate_probability_for_calculations * 0x20000 | custom_ability_skins * 0x40000;

		writer.write(flags);

		writer.write(tileset);

		writer.write(loading_screen_number);
		writer.write_c_string(loading_screen_model);
		writer.write_c_string(loading_screen_text);
		writer.write_c_string(loading_screen_title);
		writer.write_c_string(loading_screen_subtitle);

		writer.write(game_data_set);

		writer.write_c_string(prologue_screen_model);
		writer.write_c_string(prologue_text);
		writer.write_c_string(prologue_title);
		writer.write_c_string(prologue_subtitle);

		writer.write(fog_style);
		writer.write(fog_start_z_height);
		writer.write(fog_end_z_height);
		writer.write(fog_density);
		writer.write(fog_color);

		writer.write(weather_id);
		writer.write_c_string(custom_sound_environment);
		writer.write(custom_light_tileset);
		writer.write(water_color);

		writer.write((uint32_t)lua);

		writer.write(supported_modes);
		writer.write(game_data_version);

		writer.write<uint32_t>(players.size());
		for (const auto& i : players) {
			writer.write(i.internal_number);
			writer.write(static_cast<int>(i.type) + 1);
			writer.write(static_cast<int>(i.race));
			writer.write(i.fixed_start_position);
			writer.write_c_string(i.name);
			writer.write(i.starting_position);
			writer.write(i.ally_low_priorities_flags);
			writer.write(i.ally_high_priorities_flags);
			writer.write(i.enemy_low_priorities_flags);
			writer.write(i.enemy_high_priorities_flags);
		}

		writer.write<uint32_t>(forces.size());
		for (const auto& i : forces) {
			const uint32_t force_flags = i.allied * 0b00000001 | i.allied_victory * 0b00000010 | i.share_vision * 0b00000100 | i.share_unit_control * 0b00010000 | i.share_advanced_unit_control * 0b00100000;
			writer.write(force_flags);

			writer.write(i.player_masks);
			writer.write_c_string(i.name);
		}

		writer.write<uint32_t>(available_upgrades.size());
		for (const auto& i : available_upgrades) {
			writer.write(i.player_flags);
			writer.write_string(i.id);
			writer.write(i.level);
			writer.write(i.availability);
		}

		writer.write<uint32_t>(available_tech.size());
		for (const auto& i : available_tech) {
			writer.write(i.player_flags);
			writer.write_string(i.id);
		}

		writer.write<uint32_t>(random_unit_tables.size());
		for (const auto& i : random_unit_tables) {
			writer.write(i.number);
			writer.write_c_string(i.name);
			writer.write_vector(i.positions);

			writer.write<uint32_t>(i.lines.size());
			for (const auto& j : i.lines) {
				writer.write(j.chance);
				writer.write_vector(j.ids);
			}
		}

		writer.write<uint32_t>(random_item_tables.size());
		for (const auto& i : random_item_tables) {
			writer.write(i.number);
			writer.write_c_string(i.name);

			writer.write<uint32_t>(i.item_sets.size());
			for (const auto& j : i.item_sets) {
				writer.write<uint32_t>(j.items.size());
				for (const auto& [chance, id] : j.items) {
					writer.write(chance);
					writer.write_string(id);
				}
			}
		}

		hierarchy.map_file_write("war3map.w3i", writer.buffer);
	}
};
```

`src/Base/MathOperations.ixx`:

```ixx
module;

#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

export module MathOperations;

// Equivalent to, but much faster than
// worldMatrix = glm::translate(glm::mat4(1.f), position);
// worldMatrix = glm::translate(worldMatrix, pivot);
// worldMatrix *= glm::mat4_cast(rotation);
// worldMatrix = glm::scale(worldMatrix, scale);
// worldMatrix = glm::translate(worldMatrix, -pivot);
//#define TEST_MODE 1
export void fromRotationTranslationScaleOrigin(const glm::quat& q, const glm::vec3& v, const glm::vec3& s, glm::mat4& out, const glm::vec3& pivot) {
	// ho tom bambadil
	// tom bombadillo
	// Retera was here
	// (This code is copied from the holy bible)
	float x = q.x;
	float y = q.y;
	float z = q.z;
	float w = q.w;
	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float xy = x * y2;
	float xz = x * z2;
	float yy = y * y2;
	float yz = y * z2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;
	float sx = s.x;
	float sy = s.y;
	float sz = s.z;
#ifdef TEST_MODE
	out[0][0] = (1 - (yy + zz)) * sx;
	out[1][0] = (xy + wz) * sx;
	out[2][0] = (xz - wy) * sx;
	out[3][0] = 0;
	out[0][1] = (xy - wz) * sy;
	out[1][1] = (1 - (xx + zz)) * sy;
	out[2][1] = (yz + wx) * sy;
	out[3][1] = 0;
	out[0][2] = (xz + wy) * sz;
	out[1][2] = (yz - wx) * sz;
	out[2][2] = (1 - (xx + yy)) * sz;
	out[3][2] = 0;
	out[0][3] = v.x + pivot.x - (out[0][0] * pivot.x + out[0][1] * pivot.y + out[0][2] * pivot.z);
	out[1][3] = v.y + pivot.y - (out[1][0] * pivot.x + out[1][1] * pivot.y + out[1][2] * pivot.z);
	out[2][3] = v.z + pivot.z - (out[2][0] * pivot.x + out[2][1] * pivot.y + out[2][2] * pivot.z);
	out[3][3] = 1;
#else
	out[0][0] = (1 - (yy + zz)) * sx;
	out[0][1] = (xy + wz) * sx;
	out[0][2] = (xz - wy) * sx;
	out[0][3] = 0;
	out[1][0] = (xy - wz) * sy;
	out[1][1] = (1 - (xx + zz)) * sy;
	out[1][2] = (yz + wx) * sy;
	out[1][3] = 0;
	out[2][0] = (xz + wy) * sz;
	out[2][1] = (yz - wx) * sz;
	out[2][2] = (1 - (xx + yy)) * sz;
	out[2][3] = 0;
	out[3][0] = v.x + pivot.x - (out[0][0] * pivot.x + out[1][0] * pivot.y + out[2][0] * pivot.z);
	out[3][1] = v.y + pivot.y - (out[0][1] * pivot.x + out[1][1] * pivot.y + out[2][1] * pivot.z);
	out[3][2] = v.z + pivot.z - (out[0][2] * pivot.x + out[1][2] * pivot.y + out[2][2] * pivot.z);
	out[3][3] = 1;
#endif
}

glm::quat ghostwolfSquad(const glm::quat a, const glm::quat aOutTan, const glm::quat bInTan, const glm::quat b, float t) {
	glm::quat temp1;
	glm::quat temp2;
	temp1 = glm::slerp(a, b, t);
	temp2 = glm::slerp(aOutTan, bInTan, t);
	return glm::slerp(temp1, temp2, 2 * t * (1 - t));
}

float hermite(float a, float aOutTan, float bInTan, float b, float t) {
	float factorTimes2 = t * t;
	float factor1 = factorTimes2 * (2 * t - 3) + 1;
	float factor2 = factorTimes2 * (t - 2) + t;
	float factor3 = factorTimes2 * (t - 1);
	float factor4 = factorTimes2 * (3 - 2 * t);
	return (a * factor1) + (aOutTan * factor2) + (bInTan * factor3) + (b * factor4);
}
float bezier(float a, float aOutTan, float bInTan, float b, float t) {
	float invt = 1 - t;
	float factorSquared = t * t;
	float inverseFactorSquared = invt * invt;
	float factor1 = inverseFactorSquared * invt;
	float factor2 = 3 * t * inverseFactorSquared;
	float factor3 = 3 * factorSquared * invt;
	float factor4 = factorSquared * t;
	return (a * factor1) + (aOutTan * factor2) + (bInTan * factor3) + (b * factor4);
}

// template <typename T>
// inline void interpolate(T& out, const T* start, const T* outTan, const T* inTan, const T* end, float t, int interpolationType) {
//	out = *start;
// }

export float interpolate(const float start, const float outTan, const float inTan, const float end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::mix(start, end, t);
		case 2: // HERMITE
			return hermite(start, outTan, inTan, end, t);
		case 3: // BEZIER
			return bezier(start, outTan, inTan, end, t);
		default:
			return start;
	}
}

export glm::vec3 interpolate(const glm::vec3 start, const glm::vec3 outTan, const glm::vec3 inTan, const glm::vec3 end, float t, int interpolationType) {
	switch (interpolationType) {
		glm::vec3 out;
		case 1: // LINEAR
			return glm::mix(start, end, t);
		case 2: // HERMITE
			out.x = hermite(start.x, outTan.x, inTan.x, end.x, t);
			out.y = hermite(start.y, outTan.y, inTan.y, end.y, t);
			out.z = hermite(start.z, outTan.z, inTan.z, end.z, t);
			return out;
		case 3: // BEZIER
			out.x = bezier(start.x, outTan.x, inTan.x, end.x, t);
			out.y = bezier(start.y, outTan.y, inTan.y, end.y, t);
			out.z = bezier(start.z, outTan.z, inTan.z, end.z, t);
			return out;
		default:
			return start;
	}
}

export glm::quat interpolate(const glm::quat start, const glm::quat outTan, const glm::quat inTan, const glm::quat end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::slerp(start, end, t);
		case 2: // HERMITE
			// GLM uses both {x, y, z, w} and {w, x, y, z} convention, in different places, sometimes.
			// Their squad is {w, x, y, z} but we are elsewhere using {x, y, z, w}, so we will
			// continue using the copy of the Matrix Eater "ghostwolfSquad" for now.
			// out = glm::squad(*start, *outTan, *inTan, *end, t);
			return ghostwolfSquad(start, outTan, inTan, end, t);
		case 3: // BEZIER
			// GLM uses both {x, y, z, w} and {w, x, y, z} convention, in different places, sometimes.
			// Their squad is {w, x, y, z} but we are elsewhere using {x, y, z, w}, so we will
			// continue using the copy of the Matrix Eater "ghostwolfSquad" for now.
			// out = glm::squad(*start, *outTan, *inTan, *end, t);
			return ghostwolfSquad(start, outTan, inTan, end, t);
		default:
			return start;
	}
}
export uint32_t interpolate(const uint32_t start, const uint32_t outTan, const uint32_t inTan, const uint32_t end, float t, int interpolationType) {
	return start;
}

export glm::quat safeQuatLookAt(
	glm::vec3 const& lookFrom,
	glm::vec3 const& lookTo,
	glm::vec3 const& up,
	glm::vec3 const& alternativeUp) {
	glm::vec3 direction = lookTo - lookFrom;
	float directionLength = glm::length(direction);

	// Check if the direction is valid; Also deals with NaN
	if (!(directionLength > 0.0001))
		return glm::quat(1, 0, 0, 0); // Just return identity

	// Normalize direction
	direction /= directionLength;

	// Is the normal up (nearly) parallel to direction?
	if (glm::abs(glm::dot(direction, up)) > .9999f) {
		// Use alternative up
		return glm::quatLookAt(direction, alternativeUp);
	} else {
		return glm::quatLookAt(direction, up);
	}
}
```

`src/Base/PathingMap.cpp`:

```cpp
#include "PathingMap.h"

#include "fmt/format.h"

#include "Utilities.h"
import Texture;
import Hierarchy;

import BinaryWriter;

#include "Globals.h"


bool PathingMap::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.wpm");
	const std::string magic_number = reader.read_string(4);
	if (magic_number != "MP3W") {
		fmt::print("Invalid war3map.wpm magic number, expected MP3W but got {}", magic_number);
		return false;
	}

	const int version = reader.read<uint32_t>();
	if (version != 0) {
		fmt::print("Unknown war3map.wpm version, expected 0 but got {}. Attempting to load, but may crash.\n", version);
	}

	width = reader.read<uint32_t>();
	height = reader.read<uint32_t>();

	if (width == 0 || height == 0) {
		resize(map->terrain.width * 4, map->terrain.height * 4);
		return true;
	}

	pathing_cells_static = reader.read_vector<uint8_t>(width * height);
	pathing_cells_dynamic.resize(width * height);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &texture_static);
	gl->glTextureStorage2D(texture_static, 1, GL_R8UI, width, height);
	gl->glTextureSubImage2D(texture_static, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_static.data());
	gl->glTextureParameteri(texture_static, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_static, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_static, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(texture_static, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &texture_dynamic);
	gl->glTextureStorage2D(texture_dynamic, 1, GL_R8UI, width, height);
	const uint8_t clear_color = 0;
	gl->glClearTexImage(texture_dynamic, 0, GL_RED_INTEGER, GL_UNSIGNED_BYTE, &clear_color);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	return true;
}

void PathingMap::save() const {
	BinaryWriter writer;
	writer.write_string("MP3W");
	writer.write<uint32_t>(write_version);
	writer.write<uint32_t>(width);
	writer.write<uint32_t>(height);
	writer.write_vector<uint8_t>(pathing_cells_static);

	hierarchy.map_file_write("war3map.wpm", writer.buffer);
}

/// Clears an area with zeroes
void PathingMap::dynamic_clear_area(const QRect& area) {
	const QRect t = QRect(area.left() * 4, area.top() * 4, area.width() * 4, area.height() * 4).intersected({ 0, 0, width, height });

	for (int j = t.top(); j < t.bottom(); j++) {
		for (int i = t.left(); i < t.right(); i++) {
			pathing_cells_dynamic[j * width + i] = 0;
		}
	}
}

/// Checks for every cell on the supplied pathing_texture where (pathing_texture & mask == true) whether (existing_pathing & mask == true) and if so returns false
/// Expects position in whole grid tiles
/// Rotation in multiples of 90
bool PathingMap::is_area_free(glm::vec2 position, int rotation, const std::shared_ptr<PathingTexture>& pathing_texture, uint8_t mask) {
	const int div_w = (rotation % 180) ? pathing_texture->height : pathing_texture->width;
	const int div_h = (rotation % 180) ? pathing_texture->width : pathing_texture->height;
	for (int j = 0; j < pathing_texture->height; j++) {
		for (int i = 0; i < pathing_texture->width; i++) {
			int x = i;
			int y = j;

			switch (rotation) {
				case 90:
					x = pathing_texture->height - 1 - j;
					y = i;
					break;
				case 180:
					x = pathing_texture->width - 1 - i;
					y = pathing_texture->height - 1 - j;
					break;
				case 270:
					x = j;
					y = pathing_texture->width - 1 - i;
					break;
			}

			// Width and height for centering change if rotation is not divisible by 180
			const int xx = position.x * 4 + x - div_w / 2;
			const int yy = position.y * 4 + y - div_h / 2;

			if (xx < 0 || xx > width - 1 || yy < 0 || yy > height - 1) {
				continue;
			}

			const unsigned int index = ((pathing_texture->height - 1 - j) * pathing_texture->width + i) * pathing_texture->channels;

			uint8_t pathing_texture_mask = (pathing_texture->data[index] > 250) * Flags::unwalkable | (pathing_texture->data[index + 1] > 250) * Flags::unflyable | (pathing_texture->data[index + 2] > 250) * Flags::unbuildable;

			if (pathing_texture_mask & mask && pathing_cells_dynamic[yy * width + xx] && mask) {
				return false;
			}
		}
	}
	return true;
}

/// Blits a pathing texture to the specified location on the pathing map. Manually call update_dynamic() afterwards to upload the changes to the GPU
/// Expects position in whole grid tiles and draws the texture centered around this position
/// Rotation in multiples of 90
/// Blits the texture upside down as OpenGL uses the bottom-left as 0,0
void PathingMap::blit_pathing_texture(glm::vec2 position, int rotation, const std::shared_ptr<PathingTexture>& pathing_texture) {
	const int div_w = (rotation % 180) ? pathing_texture->height : pathing_texture->width;
	const int div_h = (rotation % 180) ? pathing_texture->width : pathing_texture->height;
	for (int j = 0; j < pathing_texture->height; j++) {
		for (int i = 0; i < pathing_texture->width; i++) {
			int x = i;
			int y = j;

			switch (rotation) {
				case 90:
					x = pathing_texture->height - 1 - j;
					y = i;
					break;
				case 180:
					x = pathing_texture->width - 1 - i;
					y = pathing_texture->height - 1 - j;
					break;
				case 270:
					x = j;
					y = pathing_texture->width - 1 - i;
					break;
			}

			// Width and height for centering change if rotation is not divisible by 180
			const int xx = position.x * 4 + x - div_w / 2;
			const int yy = position.y * 4 + y - div_h / 2;

			if (xx < 0 || xx > width - 1 || yy < 0 || yy > height - 1) {
				continue;
			}

			const unsigned int index = ((pathing_texture->height - 1 - j) * pathing_texture->width + i) * pathing_texture->channels;

			uint8_t bytes = (pathing_texture->data[index] > 250) * Flags::unwalkable
				| (pathing_texture->data[index + 1] > 250) * Flags::unflyable
				| (pathing_texture->data[index + 2] > 250) * Flags::unbuildable;

			pathing_cells_dynamic[yy * width + xx] |= bytes;
		}
	}
}

void PathingMap::upload_static_pathing() {
	gl->glTextureSubImage2D(texture_static, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_static.data());
}

void PathingMap::upload_dynamic_pathing() {
	gl->glTextureSubImage2D(texture_dynamic, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_dynamic.data());
}


void PathingMap::new_undo_group() {
	old_pathing_cells_static = pathing_cells_static;
}

void PathingMap::add_undo(const QRect& area) {
	auto undo_action = std::make_unique<PathingMapAction>();

	undo_action->area = area;

	// Copy old corners
	undo_action->old_pathing.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->old_pathing.push_back(old_pathing_cells_static[j * width + i]);
		}
	}

	// Copy new corners
	undo_action->new_pathing.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->new_pathing.push_back(pathing_cells_static[j * width + i]);
		}
	}

	map->terrain_undo.add_undo_action(std::move(undo_action));
}

void PathingMap::resize(size_t new_width, size_t new_height) {
	width = new_width;
	height = new_height;

	pathing_cells_static.resize(width * height);
	pathing_cells_dynamic.resize(width * height);

	old_pathing_cells_static.resize(width * height);

	gl->glDeleteTextures(1, &texture_static);
	gl->glCreateTextures(GL_TEXTURE_2D, 1, &texture_static);
	gl->glTextureStorage2D(texture_static, 1, GL_R8UI, width, height);
	gl->glTextureSubImage2D(texture_static, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, pathing_cells_static.data());
	gl->glTextureParameteri(texture_static, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_static, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_static, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(texture_static, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	gl->glDeleteTextures(1, &texture_dynamic);
	gl->glCreateTextures(GL_TEXTURE_2D, 1, &texture_dynamic);
	gl->glTextureStorage2D(texture_dynamic, 1, GL_R8UI, width, height);
	const uint8_t clear_color = 0;
	gl->glClearTexImage(texture_dynamic, 0, GL_RED_INTEGER, GL_UNSIGNED_BYTE, &clear_color);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(texture_dynamic, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}

void PathingMapAction::undo() {
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			map->pathing_map.pathing_cells_static[j * map->pathing_map.width + i] = old_pathing[(j - area.top()) * area.width() + i - area.left()];
		}
	}
	map->pathing_map.upload_static_pathing();
}

void PathingMapAction::redo() {
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			map->pathing_map.pathing_cells_static[j * map->pathing_map.width + i] = new_pathing[(j - area.top()) * area.width() + i - area.left()];
		}
	}
	map->pathing_map.upload_static_pathing();
}
```

`src/Base/PathingMap.h`:

```h
#pragma once

import BinaryReader;
import PathingTexture;

#include <memory>

#include <QOpenGLFunctions_4_5_Core>
#include <QRect>

#include "TerrainUndo.h"

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

class PathingMap {
	static constexpr int write_version = 0;

	public:
	int width;
	int height;

	enum Flags {
		unwalkable	= 0b00000010,
		unflyable	= 0b00000100,
		unbuildable = 0b00001000,
	};

	GLuint texture_static;
	GLuint texture_dynamic;
	std::vector<uint8_t> pathing_cells_static;
	std::vector<uint8_t> pathing_cells_dynamic;

	// For undo/redo
	std::vector<uint8_t> old_pathing_cells_static;
	
	bool load();
	void save() const;

	void dynamic_clear_area(const QRect& area);

	bool is_area_free(glm::vec2 position, int rotation, const std::shared_ptr<PathingTexture>& pathing_texture, uint8_t mask);
	void blit_pathing_texture(glm::vec2 position, int rotation, const std::shared_ptr<PathingTexture>& pathing_texture);

	void upload_static_pathing();
	void upload_dynamic_pathing();

	void new_undo_group();
	void add_undo(const QRect& area);

	void resize(size_t width, size_t height);
};

// Undo/redo structures
class PathingMapAction : public TerrainUndoAction {
public:
	QRect area;
	std::vector<uint8_t> old_pathing;
	std::vector<uint8_t> new_pathing;

	void undo() override;
	void redo() override;
};
```

`src/Base/Physics.cpp`:

```cpp
#include "Physics.h"

#include "Camera.h"

PhysicsDebugDraw::PhysicsDebugDraw() : btIDebugDraw() {
	gl->glCreateBuffers(1, &vertex_buffer);
	shader = resource_manager.load<Shader>({ "Data/Shaders/physics_debug.vs", "Data/Shaders/physics_debug.fs" });
}

void PhysicsDebugDraw::drawLine(const btVector3& from, const btVector3& to, const btVector3& color) {
	debug_vertices.push_back(from.x());
	debug_vertices.push_back(from.y());
	debug_vertices.push_back(from.z());
	debug_vertices.push_back(to.x());
	debug_vertices.push_back(to.y());
	debug_vertices.push_back(to.z());
}

void PhysicsDebugDraw::drawContactPoint(const btVector3& PointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color) {
}

void PhysicsDebugDraw::reportErrorWarning(const char* warningString) {}

void PhysicsDebugDraw::draw3dText(const btVector3& location, const char* textString) {
}

void PhysicsDebugDraw::setDebugMode(int debugMode) {}

int PhysicsDebugDraw::getDebugMode() const {
	return DBG_DrawWireframe;
}

void PhysicsDebugDraw::clearLines() {
	debug_vertices.clear();
}

void PhysicsDebugDraw::render() {
	gl->glNamedBufferData(vertex_buffer, debug_vertices.size() * sizeof(float), debug_vertices.data(), GL_STATIC_DRAW);

	shader->use();
	//gl->glDisable(GL_DEPTH_TEST);

	gl->glUniformMatrix4fv(1, 1, GL_FALSE, &camera->projection_view[0][0]);

	gl->glEnableVertexAttribArray(0);
	gl->glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	gl->glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glDrawArrays(GL_LINES, 0, debug_vertices.size());

	gl->glDisableVertexAttribArray(0);
	gl->glEnable(GL_DEPTH_TEST);
}

Physics::Physics() {
	broadphase = new btDbvtBroadphase();
	collisionConfiguration = new btDefaultCollisionConfiguration();
	dispatcher = new btCollisionDispatcher(collisionConfiguration);
	solver = new btSequentialImpulseConstraintSolver;
	dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
	dynamicsWorld->setGravity(btVector3(0, 0, gravity));

	draw = new PhysicsDebugDraw;
	draw->setDebugMode(draw->getDebugMode() | btIDebugDraw::DBG_DrawAabb);
	dynamicsWorld->setDebugDrawer(draw);
}
```

`src/Base/Physics.h`:

```h
#pragma once

#include "bullet/btBulletDynamicsCommon.h"
#include <vector>
#include "Shader.h"
#include <memory>

class PhysicsDebugDraw : public btIDebugDraw {
	std::shared_ptr<Shader> shader;
	GLuint vertex_buffer;


public:
	std::vector<float> debug_vertices;
	PhysicsDebugDraw();

	virtual void drawLine(const btVector3& from, const btVector3& to, const btVector3& color) override;
	virtual void drawContactPoint(const btVector3& PointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color) override;
	virtual void reportErrorWarning(const char* warningString) override;
	virtual void draw3dText(const btVector3& location, const char* textString) override;
	virtual void setDebugMode(int debugMode) override;
	virtual int  getDebugMode() const override;
	virtual void clearLines() override;
	void render();
};

struct Physics {
	float gravity = -9.81f;

	btBroadphaseInterface* broadphase;
	btDefaultCollisionConfiguration* collisionConfiguration;
	btCollisionDispatcher* dispatcher;
	btSequentialImpulseConstraintSolver* solver;
	btDiscreteDynamicsWorld* dynamicsWorld;
	
	PhysicsDebugDraw* draw;
	
	Physics();

	~Physics() {
		delete dynamicsWorld;
		delete solver;
		delete dispatcher;
		delete collisionConfiguration;
		delete broadphase;
		delete draw;
	}
};
```

`src/Base/Regions.cpp`:

```cpp
#include "Regions.h"
//#include "Hierarchy.h"
import Hierarchy;


#include <iostream>

bool Regions::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.w3r");

	const int version = reader.read<uint32_t>();
	if (version != 5) {
		std::cout << "Unknown Regions file version. Attempting to load, but may crash.";
	}

	regions.resize(reader.read<uint32_t>());
	for (auto& i : regions) {
		i.left = reader.read<float>();
		i.bottom = reader.read<float>();
		i.right = reader.read<float>();
		i.top = reader.read<float>();
		i.name = reader.read_c_string();
		i.creation_number = reader.read<int>();
		i.weather_id = reader.read_string(4);
		i.ambient_id = reader.read_c_string();
		i.color = reader.read<glm::u8vec3>();
		reader.advance(1); // padding?
	}

	return true;
}

void Regions::save() const {
//	BinaryWriter writer;
	//writer.write_string("MP3W");
	//writer.write<uint32_t>(write_version);
	//writer.write<uint32_t>(width);
	//writer.write<uint32_t>(height);
	//writer.write_vector<uint8_t>(pathing_cells_static);

//	hierarchy.map_file_write("war3map.wpr", writer.buffer);
}
```

`src/Base/Regions.h`:

```h
#pragma once

#include <vector>
#include <string>

import BinaryReader;

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

struct Region {
	float left;
	float right;
	float top;
	float bottom;
	std::string name;
	int creation_number;
	std::string weather_id;
	std::string ambient_id;
	glm::vec3 color;
};

class Regions {
	static constexpr int write_version = 5;


public:
	std::vector<Region> regions;

	bool load();
	void save() const;
};
```

`src/Base/RenderManager.cpp`:

```cpp
#include "RenderManager.h"

import ResourceManager;

#include "Camera.h"
#include "Units.h"
#include "Globals.h"

RenderManager::RenderManager() {
	instance_static_mesh_shader_sd = resource_manager.load<Shader>({ "Data/Shaders/static_mesh_instanced_sd.vs", "Data/Shaders/static_mesh_instanced_sd.fs" });
	instance_static_mesh_shader_hd = resource_manager.load<Shader>({ "Data/Shaders/static_mesh_instanced_hd.vs", "Data/Shaders/static_mesh_instanced_hd.fs" });
	static_mesh_shader_sd = resource_manager.load<Shader>({ "Data/Shaders/static_mesh_sd.vs", "Data/Shaders/static_mesh_sd.fs" });
	static_mesh_shader_hd = resource_manager.load<Shader>({ "Data/Shaders/static_mesh_hd.vs", "Data/Shaders/static_mesh_hd.fs" });
	colored_static_shader = resource_manager.load<Shader>({ "Data/Shaders/static_mesh_color_coded.vs", "Data/Shaders/static_mesh_color_coded.fs" });
	
	instance_skinned_mesh_shader_sd = resource_manager.load<Shader>({ "Data/Shaders/skinned_mesh_instanced_sd.vs", "Data/Shaders/skinned_mesh_instanced_sd.fs" });
	instance_skinned_mesh_shader_hd = resource_manager.load<Shader>({ "Data/Shaders/skinned_mesh_instanced_hd.vs", "Data/Shaders/skinned_mesh_instanced_hd.fs" });
	skinned_mesh_shader_sd = resource_manager.load<Shader>({ "Data/Shaders/skinned_mesh_sd.vs", "Data/Shaders/skinned_mesh_sd.fs" });
	skinned_mesh_shader_hd = resource_manager.load<Shader>({ "Data/Shaders/skinned_mesh_hd.vs", "Data/Shaders/skinned_mesh_hd.fs" });
	colored_skinned_shader = resource_manager.load<Shader>({ "Data/Shaders/skinned_mesh_instance_color_coded.vs", "Data/Shaders/skinned_mesh_instance_color_coded.fs" });

	gl->glCreateFramebuffers(1, &color_picking_framebuffer);

	gl->glCreateRenderbuffers(1, &color_buffer);
	gl->glNamedRenderbufferStorage(color_buffer, GL_RGBA8, 800, 600);
	gl->glNamedFramebufferRenderbuffer(color_picking_framebuffer, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, color_buffer);

	gl->glCreateRenderbuffers(1, &depth_buffer);
	gl->glNamedRenderbufferStorage(depth_buffer, GL_DEPTH24_STENCIL8, 800, 600);
	gl->glNamedFramebufferRenderbuffer(color_picking_framebuffer, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depth_buffer);

	if (gl->glCheckNamedFramebufferStatus(color_picking_framebuffer, GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
		std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;
	}
}

RenderManager::~RenderManager() {
	gl->glDeleteRenderbuffers(1, &color_buffer);
	gl->glDeleteRenderbuffers(1, &depth_buffer);
	gl->glDeleteFramebuffers(1, &color_picking_framebuffer);
}

void RenderManager::render(bool render_lighting, glm::vec3 light_direction) {
	GLint old_vao;
	gl->glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);
	
	for (const auto& i : skinned_meshes) {
		i->upload_render_data();
	}

	// Render opaque meshes
	// These don't have to be sorted and can thus be drawn instanced (one draw call per type of mesh)
	instance_skinned_mesh_shader_sd->use();
	gl->glUniformMatrix4fv(0, 1, false, &camera->projection_view[0][0]);
	gl->glUniform1i(2, render_lighting);
	gl->glUniform3fv(6, 1, &light_direction.x);
	gl->glBlendFunc(GL_ONE, GL_ZERO);

	for (const auto& i : skinned_meshes) {
		i->render_opaque(false);
	}

	instance_skinned_mesh_shader_hd->use();
	gl->glUniformMatrix4fv(0, 1, false, &camera->projection_view[0][0]);
	gl->glUniform1i(2, render_lighting);
	gl->glUniform3fv(6, 1, &light_direction.x);

	for (const auto& i : skinned_meshes) {
		i->render_opaque(true);
	}

	// Render transparent meshes
	std::sort(skinned_transparent_instances.begin(), skinned_transparent_instances.end(), [](auto& left, auto& right) { return left.distance > right.distance; });
	gl->glEnable(GL_BLEND);
	gl->glDepthMask(false);

	skinned_mesh_shader_sd->use();
	gl->glUniform1i(2, render_lighting);
	gl->glUniform3fv(8, 1, &light_direction.x);

	for (const auto& i : skinned_transparent_instances) {
		i.mesh->render_transparent(i.instance_id, false);
	}

	skinned_mesh_shader_hd->use();
	gl->glUniform1i(2, render_lighting);
	gl->glUniform3fv(8, 1, &light_direction.x);

	for (const auto& i : skinned_transparent_instances) {
		i.mesh->render_transparent(i.instance_id, true);
	}

	gl->glBindVertexArray(old_vao);

	for (const auto& i : skinned_meshes) {
		i->render_jobs.clear();
		i->render_colors.clear();
		i->skeletons.clear();
		i->instance_bone_matrices.clear();
	}

	skinned_meshes.clear();
	skinned_transparent_instances.clear();
}

void RenderManager::resize_framebuffers(int width, int height) {
	gl->glNamedRenderbufferStorage(color_buffer, GL_RGBA8, width, height);
	gl->glNamedRenderbufferStorage(depth_buffer, GL_DEPTH24_STENCIL8, width, height);
	window_width = width;
	window_height = height;
}

std::optional<size_t> RenderManager::pick_unit_id_under_mouse(glm::vec2 mouse_position) {
	GLint old_fbo;
	gl->glGetIntegerv(GL_FRAMEBUFFER_BINDING, &old_fbo);
	GLint old_vao;
	gl->glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);

	gl->glBindFramebuffer(GL_FRAMEBUFFER, color_picking_framebuffer);

	gl->glClearColor(0, 0, 0, 1);
	gl->glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	gl->glViewport(0, 0, window_width, window_height);

	colored_skinned_shader->use();
	for (size_t i = 0; i < map->units.units.size(); i++) {
		const Unit& unit = map->units.units[i];
		if (unit.id == "sloc") {
			continue;
		} // ToDo handle starting locations

		mdx::Extent& extent = unit.mesh->model->sequences[unit.skeleton.sequence_index].extent;
		if (camera->inside_frustrum(unit.matrix * glm::vec4(extent.minimum, 1.f), unit.matrix * glm::vec4(extent.maximum, 1.f))) {
			unit.mesh->render_color_coded(unit.skeleton, i + 1);
		}
	}

	glm::u8vec4 color;
	glReadPixels(mouse_position.x, window_height - mouse_position.y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, &color);

	gl->glBindFramebuffer(GL_FRAMEBUFFER, old_fbo);
	gl->glBindVertexArray(old_vao);

	const int index = color.r + (color.g << 8) + (color.b << 16);
	if (index != 0) {
		return { index - 1 };
	} else {
		return {};
	}
}

// Requires the OpenGL context to be active/current
std::optional<size_t> RenderManager::pick_doodad_id_under_mouse(glm::vec2 mouse_position) {
	GLint old_fbo;
	gl->glGetIntegerv(GL_FRAMEBUFFER_BINDING, &old_fbo);
	GLint old_vao;
	gl->glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &old_vao);

	gl->glBindFramebuffer(GL_FRAMEBUFFER, color_picking_framebuffer);

	gl->glClearColor(0, 0, 0, 1);
	gl->glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	gl->glViewport(0, 0, window_width, window_height);

	colored_skinned_shader->use();
	for (size_t i = 0; i < map->doodads.doodads.size(); i++) {
		const Doodad& doodad = map->doodads.doodads[i];
		const mdx::Extent& extent = doodad.mesh->model->sequences[doodad.skeleton.sequence_index].extent;
		if (camera->inside_frustrum(doodad.matrix * glm::vec4(extent.minimum, 1.f), doodad.matrix * glm::vec4(extent.maximum, 1.f))) {
			doodad.mesh->render_color_coded(doodad.skeleton, i + 1);
		}
	}

	glm::u8vec4 color;
	glReadPixels(mouse_position.x, window_height - mouse_position.y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE, &color);

	gl->glBindFramebuffer(GL_FRAMEBUFFER, old_fbo);
	gl->glBindVertexArray(old_vao);

	const int index = color.r + (color.g << 8) + (color.b << 16);
	if (index != 0) {
		return { index - 1 };
	} else {
		return {};
	}
}
```

`src/Base/RenderManager.h`:

```h
#pragma once

#include <vector>

#include "SkinnedMesh.h"

class RenderManager {
public:
	struct SkinnedInstance {
		SkinnedMesh* mesh;
		int instance_id;
		float distance;
	};

	std::shared_ptr<Shader> instance_static_mesh_shader_sd;
	std::shared_ptr<Shader> instance_static_mesh_shader_hd;
	std::shared_ptr<Shader> static_mesh_shader_sd;
	std::shared_ptr<Shader> static_mesh_shader_hd;
	std::shared_ptr<Shader> colored_static_shader;

	std::shared_ptr<Shader> instance_skinned_mesh_shader_sd;
	std::shared_ptr<Shader> instance_skinned_mesh_shader_hd;
	std::shared_ptr<Shader> skinned_mesh_shader_sd;
	std::shared_ptr<Shader> skinned_mesh_shader_hd;
	std::shared_ptr<Shader> colored_skinned_shader;

	std::vector<SkinnedMesh*> skinned_meshes;
	std::vector<SkinnedInstance> skinned_transparent_instances;

	GLuint color_buffer;
	GLuint depth_buffer;
	GLuint color_picking_framebuffer;

	int window_width;
	int window_height;

	RenderManager();
	~RenderManager();

	void render(bool render_lighting, glm::vec3 light_direction);

	void resize_framebuffers(int width, int height);
	
	/// Returns the unit ID of the unit that is currently under the mouse coordinates
	/// Renders the meshes currently inside the view frustrum coded by unit ID and then reads the pixel under the mouse coordinates
	std::optional<size_t> pick_unit_id_under_mouse(glm::vec2 mouse_position);

	/// Returns the doodad ID of the doodad that is currently under the mouse coordinates
	/// Renders the meshes currently inside the view frustrum coded by unit ID and then reads the pixel under the mouse coordinates
	std::optional<size_t> pick_doodad_id_under_mouse(glm::vec2 mouse_position);
};
```

`src/Base/ResourceManager.ixx`:

```ixx
module;

#include <unordered_map>
#include <string>
#include <memory>
#include <filesystem>

export module ResourceManager;

namespace fs = std::filesystem;

export class Resource {
  public:
	virtual ~Resource() = default;
};

export class ResourceManager {
  public:
	/// Loads and caches a resource in memory until no longer referenced.
	/// Whether two load paths lead to different cached instances is determined by the path, T::name and custom_identifier
	/// Any additional arguments are passed to your type its constructor
	template <typename T, typename... Args>
	std::shared_ptr<T> load(const fs::path& path, const std::string& custom_identifier = "", Args... args) {
		static_assert(std::is_base_of<Resource, T>::value, "T must inherit from Resource");
		const std::string resource = path.string() + T::name + custom_identifier;

		auto res = resources[resource].lock();
		if (!res) {
			resources[resource] = res = std::make_shared<T>(path, args...);
		}

		return std::dynamic_pointer_cast<T>(res);
	}

	template <typename T>
	std::shared_ptr<T> load(const std::initializer_list<fs::path> paths) {
		static_assert(std::is_base_of<Resource, T>::value, "T must inherit from Resource");

		std::string resource;
		for (const auto& path : paths) {
			resource += path.string();
		}
		resource += T::name;

		auto res = resources[resource].lock();
		if (!res) {
			resources[resource] = res = std::make_shared<T>(paths);
		}

		return std::dynamic_pointer_cast<T>(res);
	}

  private:
	std::unordered_map<std::string, std::weak_ptr<Resource>> resources;
};

export inline ResourceManager resource_manager;
```

`src/Base/ShadowMap.cpp`:

```cpp
#include "ShadowMap.h"

import Hierarchy;

#include "Globals.h"

bool ShadowMap::load(BinaryReader& reader) {
	width = map->terrain.width * 4;
	height = map->terrain.height * 4;

	cells = reader.read_vector<uint8_t>(width * height);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &texture);
	gl->glTextureStorage2D(texture, 1, GL_R8UI, width, height);
	gl->glTextureSubImage2D(texture, 0, 0, 0, width, height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, cells.data());
	gl->glTextureParameteri(texture, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(texture, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(texture, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	return true;
}

void ShadowMap::save() const {
	hierarchy.map_file_write("war3map.shd", cells);
}
```

`src/Base/ShadowMap.h`:

```h
#pragma once

#include <QOpenGLFunctions_4_5_Core>

import BinaryReader;

class ShadowMap {
	int width;
	int height;

	GLuint texture;
	std::vector<uint8_t> cells;

	bool load(BinaryReader& reader);
	void save() const;

	void resize(size_t width, size_t height);
};
```

`src/Base/Sounds.cpp`:

```cpp
#include "Sounds.h"

#include <iostream>

//#include "Hierarchy.h"
import Hierarchy;


void Sounds::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.w3s");

	int version = reader.read<uint32_t>();
	if (version != 1 && version != 2 && version != 3) {
		std::cout << "Unknown war3map.w3s version: " << version << " Attempting to load but may crash\n";
	}

	sounds.resize(reader.read<uint32_t>());
	for (auto& i : sounds) {
		i.name = reader.read_c_string();
		i.file = reader.read_c_string();;
		i.eax_effect = reader.read_c_string();;
		int flags = reader.read<uint32_t>();
		i.looping = flags & 0b00000001;
		i.is_3d = flags & 0b00000010;
		i.stop_out_of_range = flags & 0b00000100;
		i.music = flags & 0b00001000;

		i.fade_in_rate = reader.read<uint32_t>();
		i.fade_out_rate = reader.read<uint32_t>();
		i.volume = reader.read<uint32_t>();
		i.pitch = reader.read<float>();
		i.pitch_variance = reader.read<float>();
		i.priority = reader.read<uint32_t>();
		i.channel = reader.read<uint32_t>();
		i.min_distance = reader.read<float>();
		i.max_distance = reader.read<float>();
		i.distance_cutoff = reader.read<float>();
		i.cone_inside = reader.read<float>();
		i.cone_outside = reader.read<float>();
		i.cone_outside_volume = reader.read<uint32_t>();
		i.cone_orientation_x = reader.read<float>();
		i.cone_orientation_y = reader.read<float>();
		i.cone_orientation_z = reader.read<float>();

		if (version >= 2) {
			// Sound asset data merged with sound data in v2?

			reader.advance_c_string();
			reader.advance_c_string();
			reader.advance_c_string();
			reader.advance(4); // int?
			reader.advance_c_string();
			reader.advance(4); // int?
			if (reader.read<uint32_t>())
				reader.advance_c_string();
			reader.advance_c_string();
			reader.advance_c_string();
			reader.advance_c_string();
			reader.advance_c_string();
			reader.advance_c_string();
			if (version >= 3)
				reader.advance(4); // int?
		}
	}
}

void Sounds::save() const {

}
```

`src/Base/Sounds.h`:

```h
#pragma once

#include <string>
#include <vector>

import BinaryReader;

struct Sound {
	std::string name;
	std::string file;
	std::string eax_effect;
	//int flags;
	bool looping;
	bool is_3d;
	bool stop_out_of_range;
	bool music;

	int fade_in_rate;
	int fade_out_rate;
	int volume;
	float pitch;
	float pitch_variance;
	int priority;
	int channel;
	float min_distance;
	float max_distance;
	float distance_cutoff;
	float cone_inside;
	float cone_outside;
	int cone_outside_volume;
	float cone_orientation_x;
	float cone_orientation_y;
	float cone_orientation_z;
};

class Sounds {
public:
	std::vector<Sound> sounds;

	void load();
	void save() const;
};
```

`src/Base/Sounds.ixx`:

```ixx
module;

#include <string>
#include <vector>
#include <iostream>

export module Sounds;

import BinaryReader;
import Hierarchy;

struct Sound {
	std::string name;
	std::string file;
	std::string eax_effect;
	// int flags;
	bool looping;
	bool is_3d;
	bool stop_out_of_range;
	bool music;

	int fade_in_rate;
	int fade_out_rate;
	int volume;
	float pitch;
	float pitch_variance;
	int priority;
	int channel;
	float min_distance;
	float max_distance;
	float distance_cutoff;
	float cone_inside;
	float cone_outside;
	int cone_outside_volume;
	float cone_orientation_x;
	float cone_orientation_y;
	float cone_orientation_z;
};

export class Sounds {
  public:
	std::vector<Sound> sounds;

	void load() {
		BinaryReader reader = hierarchy.map_file_read("war3map.w3s");

		int version = reader.read<uint32_t>();
		if (version != 1 && version != 2 && version != 3) {
			std::cout << "Unknown war3map.w3s version: " << version << " Attempting to load but may crash\n";
		}

		sounds.resize(reader.read<uint32_t>());
		for (auto& i : sounds) {
			i.name = reader.read_c_string();
			i.file = reader.read_c_string();
			;
			i.eax_effect = reader.read_c_string();
			;
			int flags = reader.read<uint32_t>();
			i.looping = flags & 0b00000001;
			i.is_3d = flags & 0b00000010;
			i.stop_out_of_range = flags & 0b00000100;
			i.music = flags & 0b00001000;

			i.fade_in_rate = reader.read<uint32_t>();
			i.fade_out_rate = reader.read<uint32_t>();
			i.volume = reader.read<uint32_t>();
			i.pitch = reader.read<float>();
			i.pitch_variance = reader.read<float>();
			i.priority = reader.read<uint32_t>();
			i.channel = reader.read<uint32_t>();
			i.min_distance = reader.read<float>();
			i.max_distance = reader.read<float>();
			i.distance_cutoff = reader.read<float>();
			i.cone_inside = reader.read<float>();
			i.cone_outside = reader.read<float>();
			i.cone_outside_volume = reader.read<uint32_t>();
			i.cone_orientation_x = reader.read<float>();
			i.cone_orientation_y = reader.read<float>();
			i.cone_orientation_z = reader.read<float>();

			if (version >= 2) {
				// Sound asset data merged with sound data in v2?

				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance(4); // int?
				reader.advance_c_string();
				reader.advance(4); // int?
				if (reader.read<uint32_t>()) {
					reader.advance_c_string();
				}
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				reader.advance_c_string();
				if (version >= 3) {
					reader.advance(4); // int?
				}
			}
		}
	}

	void save() const {
	}
};
```

`src/Base/Terrain.cpp`:

```cpp
#include <set>
#include <bitset>
#include <iostream>

#include "Terrain.h"
import Hierarchy;

#include "Camera.h"
#include "SLK.h"
#include "Globals.h"
import BinaryReader;
import BinaryWriter;
#include "Physics.h"

using namespace std::literals::string_literals;

float Corner::final_ground_height() const {
	return height + layer_height - 2.0;
}

float Corner::final_water_height() const {
	return water_height + map->terrain.water_offset;
}

Terrain::~Terrain() {
	gl->glDeleteTextures(1, &ground_height);
	gl->glDeleteTextures(1, &ground_corner_height);
	gl->glDeleteTextures(1, &ground_texture_data);
	gl->glDeleteTextures(1, &ground_exists);
	gl->glDeleteTextures(1, &cliff_texture_array);

	gl->glDeleteTextures(1, &water_texture_array);
	gl->glDeleteTextures(1, &water_exists);
	gl->glDeleteTextures(1, &water_height);

	//map->physics.dynamicsWorld->removeRigidBody(collision_body);
	//delete collision_body;
	//delete collision_shape;
}

bool Terrain::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.w3e");

	const std::string magic_number = reader.read_string(4);
	if (magic_number != "W3E!") {
		std::cout << "Invalid war3map.w3e file: Magic number is not W3E!" << std::endl;
		return false;
	}
	
	reader.advance(4); // Version

	tileset = reader.read<char>();
	reader.advance(4); // Custom tileset

	const uint32_t tileset_textures = reader.read<uint32_t>();
	for (size_t i = 0; i < tileset_textures; i++) {
		tileset_ids.push_back(reader.read_string(4));
	}

	const int cliffset_textures = reader.read<uint32_t>();
	for (int i = 0; i < cliffset_textures; i++) {
		cliffset_ids.push_back(reader.read_string(4));
	}

	width = reader.read<uint32_t>();
	height = reader.read<uint32_t>();

	offset = reader.read<glm::vec2>();

	// Parse all tilepoints
	corners.resize(width, std::vector<Corner>(height));
	for (int j = 0; j < height; j++) {
		for (int i = 0; i < width; i++) {
			Corner& corner = corners[i][j];

			corners[i][j].height = (reader.read<uint16_t>() - 8192.f) / 512.f;

			const uint16_t water_and_edge = reader.read<uint16_t>();
			corners[i][j].water_height = ((water_and_edge & 0x3FFF) - 8192.f) / 512.f;
			corner.map_edge = water_and_edge & 0x4000;

			const uint8_t texture_and_flags = reader.read<uint8_t>();
			corner.ground_texture = texture_and_flags & 0b00001111;

			corner.ramp = texture_and_flags & 0b00010000;
			corner.blight = texture_and_flags & 0b00100000;
			corner.water = texture_and_flags & 0b01000000;
			corner.boundary = texture_and_flags & 0b10000000;

			const uint8_t variation = reader.read<uint8_t>();
			corner.ground_variation = variation & 0b00011111;
			corner.cliff_variation = (variation & 0b11100000) >> 5;

			const uint8_t misc = reader.read<uint8_t>();
			corner.cliff_texture = (misc & 0b11110000) >> 4;
			corner.layer_height = misc & 0b00001111;
		}
	}

	create();

	return true;
}

void Terrain::create() {
	// Determine if cliff
	for (int i = 0; i < width - 1; i++) {
		for (int j = 0; j < height - 1; j++) {
			Corner& bottom_left = corners[i][j];
			Corner& bottom_right = corners[i + 1][j];
			Corner& top_left = corners[i][j + 1];
			Corner& top_right = corners[i + 1][j + 1];

			bottom_left.cliff = bottom_left.layer_height != bottom_right.layer_height
				|| bottom_left.layer_height != top_left.layer_height
				|| bottom_left.layer_height != top_right.layer_height;
		}
	}
	// Done parsing

	hierarchy.tileset = tileset;

	terrain_slk.load("TerrainArt/Terrain.slk");
	cliff_slk.load("TerrainArt/CliffTypes.slk");
	const slk::SLK water_slk("TerrainArt/Water.slk");

	// Water Textures and Colours

	water_offset = water_slk.data<float>("height", tileset + "Sha"s);
	water_textures_nr = water_slk.data<int>("numtex", tileset + "Sha"s);
	animation_rate = water_slk.data<int>("texrate", tileset + "Sha"s);

	int red = water_slk.data<int>("smin_r", tileset + "Sha"s);
	int green = water_slk.data<int>("smin_g", tileset + "Sha"s);
	int blue = water_slk.data<int>("smin_b", tileset + "Sha"s);
	int alpha = water_slk.data<int>("smin_a", tileset + "Sha"s);

	shallow_color_min = { red, green, blue, alpha };
	shallow_color_min /= 255.f;

	red = water_slk.data<int>("smax_r", tileset + "Sha"s);
	green = water_slk.data<int>("smax_g", tileset + "Sha"s);
	blue = water_slk.data<int>("smax_b", tileset + "Sha"s);
	alpha = water_slk.data<int>("smax_a", tileset + "Sha"s);

	shallow_color_max = { red, green, blue, alpha };
	shallow_color_max /= 255.f;

	red = water_slk.data<int>("dmin_r", tileset + "Sha"s);
	green = water_slk.data<int>("dmin_g", tileset + "Sha"s);
	blue = water_slk.data<int>("dmin_b", tileset + "Sha"s);
	alpha = water_slk.data<int>("dmin_a", tileset + "Sha"s);

	deep_color_min = { red, green, blue, alpha };
	deep_color_min /= 255.f;

	red = water_slk.data<int>("dmax_r", tileset + "Sha"s);
	green = water_slk.data<int>("dmax_g", tileset + "Sha"s);
	blue = water_slk.data<int>("dmax_b", tileset + "Sha"s);
	alpha = water_slk.data<int>("dmax_a", tileset + "Sha"s);

	deep_color_max = { red, green, blue, alpha };
	deep_color_max /= 255.f;

	// Cliff Meshes
	slk::SLK cliffs_variation_slk("Data/Warcraft/Cliffs.slk", true);
	for (size_t i = 0; i < cliffs_variation_slk.rows(); i++) {
		for (int j = 0; j < cliffs_variation_slk.data<int>("variations", i) + 1; j++) {
			std::string file_name = "Doodads/Terrain/Cliffs/Cliffs" + cliffs_variation_slk.index_to_row.at(i) + std::to_string(j) + ".mdx";
			cliff_meshes.push_back(resource_manager.load<CliffMesh>(file_name));
			path_to_cliff.emplace(cliffs_variation_slk.index_to_row.at(i) + std::to_string(j), static_cast<int>(cliff_meshes.size()) - 1);
		}
		cliff_variations.emplace(cliffs_variation_slk.index_to_row.at(i), cliffs_variation_slk.data<int>("variations", i));
	}

	// Ground textures
	for (const auto& tile_id : tileset_ids) {
		ground_textures.push_back(resource_manager.load<GroundTexture>(terrain_slk.data("dir", tile_id) + "/" + terrain_slk.data("file", tile_id)));
		ground_texture_to_id.emplace(tile_id, static_cast<int>(ground_textures.size() - 1));
	}
	blight_texture = static_cast<int>(ground_textures.size());
	ground_texture_to_id.emplace("blight", blight_texture);
	ground_textures.push_back(resource_manager.load<GroundTexture>(world_edit_data.data("TileSets", std::string(1, tileset), 1)));

	// Cliff Textures
	for (auto&& cliff_id : cliffset_ids) {
		cliff_textures.push_back(resource_manager.load<Texture>(cliff_slk.data("texdir", cliff_id) + "/" + cliff_slk.data("texfile", cliff_id)));
		cliff_texture_size = std::max(cliff_texture_size, cliff_textures.back()->width);
		cliff_to_ground_texture.push_back(ground_texture_to_id[cliff_slk.data("groundtile", cliff_id)]);
	}

	// prepare GPU data
	ground_heights.resize(width * height);
	ground_corner_heights.resize(width * height);
	ground_texture_list.resize((width - 1) * (height - 1));
	ground_exists_data.resize(width * height);

	water_heights.resize(width * height);
	water_exists_data.resize(width * height);

	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			ground_corner_heights[j * width + i] = corners[i][j].final_ground_height();
			water_exists_data[j * width + i] = corners[i][j].water;
			ground_heights[j * width + i] = corners[i][j].height;
			water_heights[j * width + i] = corners[i][j].water_height;
		}
	}

	// Ground
	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_height);
	gl->glTextureStorage2D(ground_height, 1, GL_R16F, width, height);
	gl->glTextureSubImage2D(ground_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_heights.data());
	gl->glTextureParameteri(ground_height, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(ground_height, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_corner_height);
	gl->glTextureStorage2D(ground_corner_height, 1, GL_R16F, width, height);
	gl->glTextureSubImage2D(ground_corner_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_corner_heights.data());
	gl->glTextureParameteri(ground_corner_height, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(ground_corner_height, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	// Cliff
	gl->glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &cliff_texture_array);
	gl->glTextureStorage3D(cliff_texture_array, log2(cliff_texture_size) + 1, GL_RGBA8, cliff_texture_size, cliff_texture_size, cliff_textures.size());
	gl->glTextureParameteri(cliff_texture_array, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	int sub = 0;
	for (const auto& i : cliff_textures) {
		gl->glTextureSubImage3D(cliff_texture_array, 0, 0, 0, sub, i->width, i->height, 1, i->channels == 4 ? GL_RGBA : GL_RGB, GL_UNSIGNED_BYTE, i->data.data());
		sub += 1;
	}
	gl->glGenerateTextureMipmap(cliff_texture_array);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_texture_data);
	gl->glTextureStorage2D(ground_texture_data, 1, GL_RGBA16UI, width - 1, height - 1);
	gl->glTextureParameteri(ground_texture_data, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(ground_texture_data, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_exists);
	gl->glTextureStorage2D(ground_exists, 1, GL_R8, width, height);

	// Water
	gl->glCreateTextures(GL_TEXTURE_2D, 1, &water_height);
	gl->glTextureStorage2D(water_height, 1, GL_R16F, width, height);
	gl->glTextureSubImage2D(water_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, water_heights.data());

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &water_exists);
	gl->glTextureStorage2D(water_exists, 1, GL_R8, width, height);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gl->glTextureSubImage2D(water_exists, 0, 0, 0, width, height, GL_RED, GL_UNSIGNED_BYTE, water_exists_data.data());
	glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

	// Water textures
	gl->glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &water_texture_array);
	gl->glTextureStorage3D(water_texture_array, std::log(128) + 1, GL_RGBA8, 128, 128, water_textures_nr);
	gl->glTextureParameteri(water_texture_array, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(water_texture_array, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	const std::string file_name = water_slk.data("texfile", tileset + "Sha"s);
	for (int i = 0; i < water_textures_nr; i++) {
		const auto texture = resource_manager.load<Texture>(file_name + (i < 10 ? "0" : "") + std::to_string(i));

		if (texture->width != 128 || texture->height != 128) {
			std::cout << "Odd water texture size detected of " << texture->width << " wide and " << texture->height << " high\n";
		}
		gl->glTextureSubImage3D(water_texture_array, 0, 0, 0, i, texture->width, texture->height, 1, GL_RGB, GL_UNSIGNED_BYTE, texture->data.data());
	}
	gl->glGenerateTextureMipmap(water_texture_array);

	update_cliff_meshes({ 0, 0, width - 1, height - 1 });
	update_ground_textures({ 0, 0, width - 1, height - 1 });
	update_ground_heights({ 0, 0, width - 1, height - 1 });

	ground_shader = resource_manager.load<Shader>({ "Data/Shaders/terrain.vs", "Data/Shaders/terrain.fs" });
	cliff_shader = resource_manager.load<Shader>({ "Data/Shaders/cliff.vs", "Data/Shaders/cliff.fs" });
	water_shader = resource_manager.load<Shader>({ "Data/Shaders/water.vs", "Data/Shaders/water.fs" });

	collision_shape = new btHeightfieldTerrainShape(width, height, ground_corner_heights.data(), 0, -16.f, 16.f, 2 /*z*/, PHY_FLOAT, false);
	if (collision_shape == nullptr) {
		std::cout << "Error creating Bullet collision shape\n";
	}

	collision_body = new btRigidBody(0, new btDefaultMotionState(), collision_shape);
	collision_body->getWorldTransform().setOrigin(btVector3(width / 2.f - 0.5f, height / 2.f - 0.5f, 0.f)); // Bullet centers the collision mesh automatically, we need to decenter it and place it under the player
	collision_body->setCollisionFlags(collision_body->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
	map->physics.dynamicsWorld->addRigidBody(collision_body, 32, 32);
	
	emit minimap_changed(minimap_image());
}

void Terrain::save() const {
	BinaryWriter writer;
	writer.write_string("W3E!");
	writer.write(write_version);
	writer.write(tileset);
	writer.write(1);
	writer.write<uint32_t>(tileset_ids.size());
	writer.write_vector(tileset_ids);
	writer.write<uint32_t>(cliffset_ids.size());
	writer.write_vector(cliffset_ids);
	writer.write(width);
	writer.write(height);
	writer.write(offset);

	for (int j = 0; j < height; j++) {
		for (int i = 0; i < width; i++) {
			const Corner& corner = corners[i][j];

			writer.write<uint16_t>(corner.height * 512.f + 8192.f);

			uint16_t water_and_edge = corner.water_height * 512.f + 8192.f;
			water_and_edge += corner.map_edge << 14;
			writer.write(water_and_edge);

			uint8_t texture_and_flags = corner.ground_texture;
			texture_and_flags |= corner.ramp << 4;

			texture_and_flags |= corner.blight << 5;
			texture_and_flags |= corner.water << 6;
			texture_and_flags |= corner.boundary << 7;
			writer.write(texture_and_flags);

			uint8_t variation = corner.ground_variation;
			variation += corner.cliff_variation << 5;
			writer.write(variation);

			uint8_t misc = corner.cliff_texture << 4;
			misc += corner.layer_height;
			writer.write(misc);
		}
	}

	hierarchy.map_file_write("war3map.w3e", writer.buffer);
}

void Terrain::render_ground() const {
	// Render tiles
	ground_shader->use();

	gl->glDisable(GL_BLEND);
	gl->glEnable(GL_CULL_FACE);

	gl->glUniformMatrix4fv(1, 1, GL_FALSE, &camera->projection_view[0][0]);
	gl->glUniform1i(2, map->render_pathing);
	gl->glUniform1i(3, map->render_lighting);
	gl->glUniform3fv(4, 1, &map->light_direction.x);

	gl->glBindTextureUnit(0, ground_height);
	gl->glBindTextureUnit(1, ground_corner_height);
	gl->glBindTextureUnit(2, ground_texture_data);
	gl->glBindTextureUnit(22, ground_exists);

	for (size_t i = 0; i < ground_textures.size(); i++) {
		gl->glBindTextureUnit(3 + i, ground_textures[i]->id);
	}
	gl->glBindTextureUnit(20, map->pathing_map.texture_static);
	gl->glBindTextureUnit(21, map->pathing_map.texture_dynamic);

	gl->glEnableVertexAttribArray(0);
	gl->glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
	gl->glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
	gl->glDrawElementsInstanced(GL_TRIANGLES, shapes.quad_indices.size() * 3, GL_UNSIGNED_INT, nullptr, (width - 1) * (height - 1));

	gl->glDisableVertexAttribArray(0);

	gl->glEnable(GL_BLEND);

	// Render cliffs
	for (const auto& i : cliffs) {
		const Corner& bottom_left = corners[i.x][i.y];
		const Corner& bottom_right = corners[i.x + 1][i.y];
		const Corner& top_left = corners[i.x][i.y + 1];
		const Corner& top_right = corners[i.x + 1][i.y + 1];

		const float min = std::min({ bottom_left.layer_height - 2,	bottom_right.layer_height - 2,
									top_left.layer_height - 2,		top_right.layer_height - 2 });

		if (bottom_left.special_doodad) {
			continue;
		}

		cliff_meshes[i.z]->render_queue({ i.x, i.y, min, bottom_left.cliff_texture });
	}

	cliff_shader->use();

	// WC3 models are 128x too large
	gl->glUniformMatrix4fv(0, 1, GL_FALSE, &camera->projection_view[0][0]);
	gl->glUniform1i(1, map->render_pathing);
	gl->glUniform1i(2, map->render_lighting);
	gl->glUniform3fv(3, 1, &map->light_direction.x);

	gl->glBindTextureUnit(0, cliff_texture_array);
	gl->glBindTextureUnit(1, ground_height);
	gl->glBindTextureUnit(2, map->pathing_map.texture_static);
	for (const auto& i : cliff_meshes) {
		i->render();
	}
}

void Terrain::render_water() const {
	gl->glEnable(GL_BLEND);
	gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	water_shader->use();

	gl->glUniformMatrix4fv(0, 1, GL_FALSE, &camera->projection_view[0][0]);
	gl->glUniform4fv(1, 1, &shallow_color_min[0]);
	gl->glUniform4fv(2, 1, &shallow_color_max[0]);
	gl->glUniform4fv(3, 1, &deep_color_min[0]);
	gl->glUniform4fv(4, 1, &deep_color_max[0]);
	gl->glUniform1f(5, water_offset);
	gl->glUniform1i(6, current_texture);

	gl->glBindTextureUnit(0, water_height);
	gl->glBindTextureUnit(1, ground_corner_height);
	gl->glBindTextureUnit(2, water_exists);
	gl->glBindTextureUnit(3, water_texture_array);

	gl->glEnableVertexAttribArray(0);
	gl->glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
	gl->glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
	gl->glDrawElementsInstanced(GL_TRIANGLES, shapes.quad_indices.size() * 3, GL_UNSIGNED_INT, nullptr, (width - 1) * (height - 1));

	gl->glDisableVertexAttribArray(0);
}

void Terrain::change_tileset(const std::vector<std::string>& new_tileset_ids, std::vector<int> new_to_old) {
	tileset_ids = new_tileset_ids;

	// Blight
	new_to_old.push_back(new_tileset_ids.size());

	// Map old ids to the new ids
	for (auto& i : corners) {
		for (auto& j : i) {
			j.ground_texture = new_to_old[j.ground_texture];
		}
	}

	// Reload tile textures
	ground_textures.clear();	// ToDo Clear them after loading new ones?
	ground_texture_to_id.clear();

	for (const auto& tile_id : tileset_ids) {
		ground_textures.push_back(resource_manager.load<GroundTexture>(terrain_slk.data("dir", tile_id) + "/" + terrain_slk.data("file", tile_id) + (hierarchy.hd ? "_diffuse.dds" : ".dds")));
		ground_texture_to_id.emplace(tile_id, static_cast<int>(ground_textures.size() - 1));
	}
	blight_texture = static_cast<int>(ground_textures.size());
	ground_texture_to_id.emplace("blight", blight_texture);
	ground_textures.push_back(resource_manager.load<GroundTexture>(world_edit_data.data("TileSets", std::string(1, tileset), 1) + (hierarchy.hd ? "_diffuse.dds" : ".dds")));

	cliff_to_ground_texture.clear();
	for (const auto& cliff_id : cliffset_ids) {
		cliff_to_ground_texture.push_back(ground_texture_to_id[cliff_slk.data("groundtile", cliff_id)]);
	}

	update_ground_textures({ 0, 0, width, height });
}

/// The texture of the tilepoint which is influenced by its surroundings. nearby cliff/ramp > blight > regular texture
int Terrain::real_tile_texture(const int x, const int y) const {
	for (int i = -1; i < 1; i++) {
		for (int j = -1; j < 1; j++) {
			if (x + i >= 0 && x + i < width && y + j >= 0 && y + j < height) {
				if (corners[x + i][y + j].cliff) {
					if (x + i < width - 1 && y + j < height - 1) {
						const Corner& bottom_left = corners[x + i][y + j];
						const Corner& bottom_right = corners[x + i + 1][y + j];
						const Corner& top_left = corners[x + i][y + j + 1];
						const Corner& top_right = corners[x + i + 1][y + j + 1];

						if (bottom_left.ramp && top_left.ramp && bottom_right.ramp && top_right.ramp && !bottom_left.romp && !bottom_right.romp && !top_left.romp && !top_right.romp) {
							goto out_of_loop;
						}
					}
				}

				if (corners[x + i][y + j].romp || corners[x + i][y + j].cliff) {
					int texture = corners[x + i][y + j].cliff_texture;
					// Number 15 seems to be something
					if (texture == 15) {
						texture -= 14;
					}

					return cliff_to_ground_texture[texture];
				}
			}
		}
	}
out_of_loop:

	if (corners[x][y].blight) {
		return blight_texture;
	}

	return corners[x][y].ground_texture;
}

/// The subtexture of a groundtexture to use.
int Terrain::get_tile_variation(const int ground_texture, const int variation) const {
	if (ground_textures[ground_texture]->extended) {
		if (variation <= 15) {
			return 16 + variation;
		} else if (variation == 16) {
			return 15;
		} else {
			return 0;
		}
	} else {
		if (variation == 0) {
			return 0;
		} else {
			return 15;
		}
	}
}

/// The 4 ground textures of the tilepoint. First 5 bits are which texture array to use and the next 5 bits are which subtexture to use
glm::u16vec4 Terrain::get_texture_variations(const int x, const int y) const {
	const int bottom_left = real_tile_texture(x, y);
	const int bottom_right = real_tile_texture(x + 1, y);
	const int top_left = real_tile_texture(x, y + 1);
	const int top_right = real_tile_texture(x + 1, y + 1);

	std::set<int> set({ bottom_left, bottom_right, top_left, top_right });
	glm::u16vec4 tiles(17); // 17 is a black transparent texture
	int component = 1;

	tiles.x = *set.begin() + (get_tile_variation(*set.begin(), corners[x][y].ground_variation) << 5);
	set.erase(set.begin());

	std::bitset<4> index;
	for (auto&& texture : set) {
		index[0] = bottom_right == texture;
		index[1] = bottom_left == texture;
		index[2] = top_right == texture;
		index[3] = top_left == texture;

		tiles[component++] = texture + (index.to_ulong() << 5);
	}
	return tiles;
}

float Terrain::interpolated_height(float x, float y) const {
	x = std::clamp(x, 0.f, width - 1.01f);
	y = std::clamp(y, 0.f, height - 1.01f);

	// Biliniear interpolation
	float xx = glm::mix(corners[x][y].final_ground_height(), corners[std::ceil(x)][y].final_ground_height(), x - floor(x));
	float yy = glm::mix(corners[x][std::ceil(y)].final_ground_height(), corners[std::ceil(x)][std::ceil(y)].final_ground_height(), x - floor(x));
	return glm::mix(xx, yy, y - floor(y));
}

bool Terrain::is_corner_ramp_entrance(int x, int y) {
	if (x == width || y == height) {
		return false;
	}

	Corner& bottom_left = corners[x][y];
	Corner& bottom_right = corners[x + 1][y];
	Corner& top_left = corners[x][y + 1];
	Corner& top_right = corners[x + 1][y + 1];

	return bottom_left.ramp && top_left.ramp && bottom_right.ramp && top_right.ramp && !(bottom_left.layer_height == top_right.layer_height && top_left.layer_height == bottom_right.layer_height);
}

/// Constructs a minimap image with tile, cliff, and water colors. Other objects such as doodads will not be added here
Texture Terrain::minimap_image() {
	Texture new_minimap_image;

	new_minimap_image.width = width;
	new_minimap_image.height = height;
	new_minimap_image.channels = 4;
	new_minimap_image.data.resize(width * height * 4);

	for (int j = 0; j < height; j++) {
		for (int i = 0; i < width; i++) {
			glm::vec4 color;

			if (corners[i][j].cliff || (i > 0 && corners[i - 1][j].cliff) || (j > 0 && corners[i][j - 1].cliff) || (i > 0 && j > 0 && corners[i - 1][j - 1].cliff)) {
				color = glm::vec4(128.f, 128.f, 128.f, 255.f);
			} else {
				color = ground_textures[real_tile_texture(i, j)]->minimap_color;
			}

			if (corners[i][j].water && corners[i][j].final_water_height() > corners[i][j].final_ground_height()) {
				if (corners[i][j].final_water_height() - corners[i][j].final_ground_height() > 0.5f) {
					color *= 0.5625f;
					color += glm::vec4(0, 0, 80, 112);
				} else {
					color *= 0.75f;
					color += glm::vec4(0, 0, 48, 64);
				}
			}

			int index = (height - 1 - j) * (width * 4) + i * 4;
			new_minimap_image.data[index + 0] = color.r;
			new_minimap_image.data[index + 1] = color.g;
			new_minimap_image.data[index + 2] = color.b;
			new_minimap_image.data[index + 3] = color.a;

		}
	}

	return new_minimap_image;
}

/// Backups the old corners for a new undo group
void Terrain::new_undo_group() {
	old_corners = corners;
}

/// Adds the undo to the current undo group
void Terrain::add_undo(const QRect& area, undo_type type) {
	auto undo_action = std::make_unique<TerrainGenericAction>();

	undo_action->area = area;
	undo_action->undo_type = type;

	// Copy old corners
	undo_action->old_corners.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->old_corners.push_back(old_corners[i][j]);
		}
	}

	// Copy new corners
	undo_action->new_corners.reserve(area.width() * area.height());
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			undo_action->new_corners.push_back(corners[i][j]);
		}
	}

	map->terrain_undo.add_undo_action(std::move(undo_action));
}

void Terrain::upload_ground_heights() const {
	gl->glTextureSubImage2D(ground_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_heights.data());
}

void Terrain::upload_corner_heights() const {
	gl->glTextureSubImage2D(ground_corner_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_corner_heights.data());
}

void Terrain::upload_ground_texture() const {
	gl->glTextureSubImage2D(ground_texture_data, 0, 0, 0, width - 1, height - 1, GL_RGBA_INTEGER, GL_UNSIGNED_SHORT, ground_texture_list.data());
}

void Terrain::upload_ground_exists() const {
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gl->glTextureSubImage2D(ground_exists, 0, 0, 0, width, height, GL_RED, GL_UNSIGNED_BYTE, ground_exists_data.data());
	glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
}

void Terrain::upload_water_exists() const {
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gl->glTextureSubImage2D(water_exists, 0, 0, 0, width, height, GL_RED, GL_UNSIGNED_BYTE, water_exists_data.data());
	glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
}

void Terrain::upload_water_heights() const {
	gl->glTextureSubImage2D(water_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, water_heights.data());
}

void Terrain::update_ground_heights(const QRect& area) {
	for (int j = area.y(); j < area.y() + area.height(); j++) {
		for (int i = area.x(); i < area.x() + area.width(); i++) {
			ground_heights[j * width + i] = corners[i][j].height; // todo 15.998???

			float ramp_height = 0.f;
			// Check if in one of the configurations the bottom_left is a ramp
			for (int x_offset = -1; x_offset <= 0; x_offset++) {
				for (int y_offset = -1; y_offset <= 0; y_offset++) {
					if (i + x_offset >= 0 && i + x_offset < width - 1 && j + y_offset >= 0 && j + y_offset < height - 1) {
						const Corner& bottom_left = corners[i + x_offset][j + y_offset];
						const Corner& bottom_right = corners[i + 1 + x_offset][j + y_offset];
						const Corner& top_left = corners[i + x_offset][j + 1 + y_offset];
						const Corner& top_right = corners[i + 1 + x_offset][j + 1 + y_offset];

						const int base = std::min({ bottom_left.layer_height, bottom_right.layer_height, top_left.layer_height, top_right.layer_height });
						if (corners[i][j].layer_height != base) {
							continue;
						}

						if (is_corner_ramp_entrance(i + x_offset, j + y_offset)) {
							ramp_height = 0.5f;
							goto exit_loop;
						}
					}
				}
			}
		exit_loop:

			ground_corner_heights[j * width + i] = corners[i][j].final_ground_height() + ramp_height;
		}
	}

	upload_ground_heights();
	upload_corner_heights();
}

/// Updates the ground texture variation information and uploads it to the GPU
void Terrain::update_ground_textures(const QRect& area) {
	const QRect update_area = area.adjusted(-1, -1, 1, 1).intersected({ 0, 0, width - 1, height - 1 });

	for (int j = update_area.top(); j <= update_area.bottom(); j++) {
		for (int i = update_area.left(); i <= update_area.right(); i++) {
			ground_texture_list[j * (width - 1) + i] = get_texture_variations(i, j);
		}
	}

	upload_ground_texture();
}

void Terrain::update_ground_exists(const QRect& area) {
	QRect update_area = area.adjusted(-1, -1, 1, 1).intersected({ 0, 0, width - 1, height - 1 });

	for (int j = update_area.top(); j <= update_area.bottom(); j++) {
		for (int i = update_area.left(); i <= update_area.right(); i++) {
			ground_exists_data[j * (width - 1) + i] = !(((corners[i][j].cliff || corners[i][j].romp) && !is_corner_ramp_entrance(i, j)) || corners[i][j].special_doodad);
		}
	}

	upload_ground_exists();
}

/// Updates and uploads the water data for the GPU
void Terrain::update_water(const QRect& area) {
	for (int i = area.x(); i < area.x() + area.width(); i++) {
		for (int j = area.y(); j < area.y() + area.height(); j++) {
			map->terrain.water_exists_data[j * width + i] = corners[i][j].water;
			map->terrain.water_heights[j * width + i] = corners[i][j].water_height;
		}
	}
	upload_water_exists();
	upload_water_heights();
}

/// ToDo clean
/// Function is a bit of a mess
/// Updates the cliff and ramp meshes for an area
void Terrain::update_cliff_meshes(const QRect& area) {
	// Remove all existing cliff meshes in area
	for (size_t i = cliffs.size(); i-- > 0;) {
		glm::ivec3& pos = cliffs[i];
		if (area.contains(pos.x, pos.y)) {
			cliffs.erase(cliffs.begin() + i);
		}
	}

	for (int i = area.x(); i < area.right(); i++) {
		for (int j = area.y(); j < area.bottom(); j++) {
			corners[i][j].romp = false;
		}
	}

	QRect ramp_area = area.adjusted(-2, -2, 2, 2).intersected({ 0, 0, width, height });

	// Add new cliff meshes
	for (int i = ramp_area.x(); i < ramp_area.right(); i++) {
		for (int j = ramp_area.y(); j < ramp_area.bottom(); j++) {
			Corner& bottom_left = corners[i][j];
			Corner& bottom_right = corners[i + 1][j];
			Corner& top_left = corners[i][j + 1];
			Corner& top_right = corners[i + 1][j + 1];

			// Vertical ramps
			if (j < height - 2) {
				const Corner& top_top_left = corners[i][j + 2];
				const Corner& top_top_right = corners[i + 1][j + 2];
				const int ae = std::min(bottom_left.layer_height, top_top_left.layer_height);
				const int cf = std::min(bottom_right.layer_height, top_top_right.layer_height);

				if (top_left.layer_height == ae && top_right.layer_height == cf) {
					int base = std::min(ae, cf);
					if (bottom_left.ramp == top_left.ramp 
						&& bottom_left.ramp == top_top_left.ramp 
						&& bottom_right.ramp == top_right.ramp 
						&& bottom_right.ramp == top_top_right.ramp 
						&& bottom_left.ramp != bottom_right.ramp) {

						std::string file_name = ""s
							+ char((top_top_left.ramp ? 'L' : 'A') + (top_top_left.layer_height - base) * (top_top_left.ramp ? -4 : 1))
							+ char((top_top_right.ramp ? 'L' : 'A') + (top_top_right.layer_height - base) * (top_top_right.ramp ? -4 : 1))
							+ char((bottom_right.ramp ? 'L' : 'A') + (bottom_right.layer_height - base) * (bottom_right.ramp ? -4 : 1))
							+ char((bottom_left.ramp ? 'L' : 'A') + (bottom_left.layer_height - base) * (bottom_left.ramp ? -4 : 1));

						file_name = "doodads/terrain/clifftrans/clifftrans" + file_name + "0.mdx";
						if (hierarchy.file_exists(file_name)) {
							if (!path_to_cliff.contains(file_name)) {
								cliff_meshes.push_back(resource_manager.load<CliffMesh>(file_name));
								path_to_cliff.emplace(file_name, static_cast<int>(cliff_meshes.size()) - 1);
							}

							cliffs.emplace_back(i, j, path_to_cliff[file_name]);
							bottom_left.romp = true;
							top_left.romp = true;

							continue;
						}
					}
				}
			}

			// Horizontal ramps
			if (i < width - 2) {
				const Corner& bottom_right_right = corners[i + 2][j];
				const Corner& top_right_right = corners[i + 2][j + 1];
				const int ae = std::min(bottom_left.layer_height, bottom_right_right.layer_height);
				const int bf = std::min(top_left.layer_height, top_right_right.layer_height);

				if (bottom_right.layer_height == ae && top_right.layer_height == bf) {
					int base = std::min(ae, bf);
					if (bottom_left.ramp == bottom_right.ramp 
						&& bottom_left.ramp == bottom_right_right.ramp 
						&& top_left.ramp == top_right.ramp 
						&& top_left.ramp == top_right_right.ramp 
						&& bottom_left.ramp != top_left.ramp) {

						std::string file_name = ""s
							+ char((top_left.ramp ? 'L' : 'A') + (top_left.layer_height - base) * (top_left.ramp ? -4 : 1))
							+ char((top_right_right.ramp ? 'L' : 'A') + (top_right_right.layer_height - base) * (top_right_right.ramp ? -4 : 1))
							+ char((bottom_right_right.ramp ? 'L' : 'A') + (bottom_right_right.layer_height - base) * (bottom_right_right.ramp ? -4 : 1))
							+ char((bottom_left.ramp ? 'L' : 'A') + (bottom_left.layer_height - base) * (bottom_left.ramp ? -4 : 1));

						file_name = "doodads/terrain/clifftrans/clifftrans" + file_name + "0.mdx";
						if (hierarchy.file_exists(file_name)) {
							if (!path_to_cliff.contains(file_name)) {
								cliff_meshes.push_back(resource_manager.load<CliffMesh>(file_name));
								path_to_cliff.emplace(file_name, static_cast<int>(cliff_meshes.size()) - 1);
							}

							cliffs.emplace_back(i, j, path_to_cliff[file_name]);
							bottom_left.romp = true;
							bottom_right.romp = true;

							continue;
						}
					}
				}
			}

			if (!bottom_left.cliff || bottom_left.romp) {
				continue;
			}

			if (is_corner_ramp_entrance(i, j)) {
				continue;
			}

			const int base = std::min({bottom_left.layer_height, bottom_right.layer_height, top_left.layer_height, top_right.layer_height});

			// Cliff model path
			std::string file_name = ""s + char('A' + top_left.layer_height - base)
				+ char('A' + top_right.layer_height - base)
				+ char('A' + bottom_right.layer_height - base)
				+ char('A' + bottom_left.layer_height - base);

			if (file_name == "AAAA") {
				continue;
			}

			// Clamp to within max variations
			file_name += std::to_string(std::clamp(bottom_left.cliff_variation, 0, cliff_variations[file_name]));

			cliffs.emplace_back(i, j, path_to_cliff[file_name]);
		}
	}

	update_ground_exists(ramp_area);
}

void Terrain::resize(size_t new_width, size_t new_height) {
	gl->glDeleteTextures(1, &ground_height);
	gl->glDeleteTextures(1, &ground_corner_height);
	gl->glDeleteTextures(1, &ground_texture_data);
	gl->glDeleteTextures(1, &ground_exists);

	gl->glDeleteTextures(1, &water_exists);
	gl->glDeleteTextures(1, &water_height);

	width = new_width;
	height = new_height;

	//offset = 

	auto t = corners[0][0];
	corners.clear();
	corners.resize(width, std::vector<Corner>(height, t));

	ground_heights.resize(width * height);
	ground_corner_heights.resize(width * height);
	ground_texture_list.resize((width - 1) * (height - 1));
	ground_exists_data.resize(width * height);

	water_heights.resize(width * height);
	water_exists_data.resize(width * height);

	for (int i = 0; i < width; i++) {
		for (int j = 0; j < height; j++) {
			ground_corner_heights[j * width + i] = corners[i][j].final_ground_height();
			water_exists_data[j * width + i] = corners[i][j].water;
			ground_heights[j * width + i] = corners[i][j].height;
			water_heights[j * width + i] = corners[i][j].water_height;
		}
	}

	for (int i = 0; i < width - 1; i++) {
		for (int j = 0; j < height - 1; j++) {
			Corner& bottom_left = corners[i][j];
			Corner& bottom_right = corners[i + 1][j];
			Corner& top_left = corners[i][j + 1];
			Corner& top_right = corners[i + 1][j + 1];

			bottom_left.cliff = bottom_left.layer_height != bottom_right.layer_height || bottom_left.layer_height != top_left.layer_height || bottom_left.layer_height != top_right.layer_height;
		}
	}

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_height);
	gl->glTextureStorage2D(ground_height, 1, GL_R16F, width, height);
	gl->glTextureSubImage2D(ground_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_heights.data());
	gl->glTextureParameteri(ground_height, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(ground_height, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_corner_height);
	gl->glTextureStorage2D(ground_corner_height, 1, GL_R16F, width, height);
	gl->glTextureSubImage2D(ground_corner_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, ground_corner_heights.data());
	gl->glTextureParameteri(ground_corner_height, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(ground_corner_height, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_texture_data);
	gl->glTextureStorage2D(ground_texture_data, 1, GL_RGBA16UI, width - 1, height - 1);
	gl->glTextureParameteri(ground_texture_data, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(ground_texture_data, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &ground_exists);
	gl->glTextureStorage2D(ground_exists, 1, GL_R8, width, height);

	// Water
	gl->glCreateTextures(GL_TEXTURE_2D, 1, &water_height);
	gl->glTextureStorage2D(water_height, 1, GL_R16F, width, height);
	gl->glTextureSubImage2D(water_height, 0, 0, 0, width, height, GL_RED, GL_FLOAT, water_heights.data());

	gl->glCreateTextures(GL_TEXTURE_2D, 1, &water_exists);
	gl->glTextureStorage2D(water_exists, 1, GL_R8, width, height);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	gl->glTextureSubImage2D(water_exists, 0, 0, 0, width, height, GL_RED, GL_UNSIGNED_BYTE, water_exists_data.data());
	glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

	update_cliff_meshes({ 0, 0, width - 1, height - 1 });
	update_ground_textures({ 0, 0, width - 1, height - 1 });
	update_ground_heights({ 0, 0, width - 1, height - 1 });

	map->physics.dynamicsWorld->removeRigidBody(collision_body);
	delete collision_body;
	delete collision_shape;

	collision_shape = new btHeightfieldTerrainShape(width, height, ground_corner_heights.data(), 0, -16.f, 16.f, 2 /*z*/, PHY_FLOAT, false);
	if (collision_shape == nullptr) {
		std::cout << "Error creating Bullet collision shape\n";
	}
	collision_body = new btRigidBody(0, new btDefaultMotionState(), collision_shape);
	collision_body->getWorldTransform().setOrigin(btVector3(width / 2.f - 0.5f, height / 2.f - 0.5f, 0.f)); // Bullet centers the collision mesh automatically, we need to decenter it and place it under the player
	collision_body->setCollisionFlags(collision_body->getCollisionFlags() | btCollisionObject::CF_STATIC_OBJECT);
	map->physics.dynamicsWorld->addRigidBody(collision_body, 32, 32);
}

void Terrain::update_minimap() {
	emit minimap_changed(minimap_image());
}

void TerrainGenericAction::undo() {
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			map->terrain.corners[i][j] = old_corners[(j - area.top()) * area.width() + i - area.left()];
		}
	}

	if (undo_type == Terrain::undo_type::height) {
		map->terrain.update_ground_heights(area);
	}

	if (undo_type == Terrain::undo_type::texture) {
		map->terrain.update_ground_textures(area);
	}

	if (undo_type == Terrain::undo_type::cliff) {
		map->terrain.update_ground_heights(area);
		map->terrain.update_cliff_meshes(area);
		map->terrain.update_ground_textures(area);
		map->terrain.update_water(area);
	}

	map->terrain.update_minimap();
	map->units.update_area(area);
}

void TerrainGenericAction::redo() {
	for (int j = area.top(); j <= area.bottom(); j++) {
		for (int i = area.left(); i <= area.right(); i++) {
			map->terrain.corners[i][j] = new_corners[(j - area.top()) * area.width() + i - area.left()];
		}
	}

	if (undo_type == Terrain::undo_type::height) {
		map->terrain.update_ground_heights(area);
	}

	if (undo_type == Terrain::undo_type::texture) {
		map->terrain.update_ground_textures(area);
	}

	if (undo_type == Terrain::undo_type::cliff) {
		map->terrain.update_ground_heights(area);
		map->terrain.update_cliff_meshes(area);
		map->terrain.update_ground_textures(area);
		map->terrain.update_water(area);
	}

	map->terrain.update_minimap();
	map->units.update_area(area);
}
```

`src/Base/Terrain.h`:

```h
#pragma once

#include <memory>

#include <QObject>
#include <QOpenGLFunctions_4_5_Core>
#include <QRect>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

#include <bullet/BulletCollision/CollisionShapes/btHeightfieldTerrainShape.h>
#include "btBulletDynamicsCommon.h"

#include "GroundTexture.h"
#include "CliffMesh.h"
import Texture;
import BinaryReader;
#include "Shader.h"
#include "SLK.h"

#include "TerrainUndo.h"

struct Corner {
	bool map_edge;

	int ground_texture;

	float height;
	float water_height;
	bool ramp;
	bool blight;
	bool water;
	bool boundary;
	bool cliff = false;
	bool romp = false;
	bool special_doodad = false;

	int ground_variation;
	int cliff_variation;

	int cliff_texture;
	int layer_height;

	float final_ground_height() const;
	float final_water_height() const;
};

struct TilePathingg {
	bool unwalkable = false;
	bool unflyable = false;
	bool unbuildable = false;

	uint8_t mask() const {
		uint8_t mask = 0;
		mask |= unwalkable ? 0b00000010 : 0;
		mask |= unflyable ? 0b00000100 : 0;
		mask |= unbuildable ? 0b00001000 : 0;
		return mask;
	}
};

class Terrain : public QObject {
	Q_OBJECT

	static constexpr int write_version = 11;

	// Sequential versions for GPU uploading
	std::vector<float> ground_heights;
	std::vector<float> ground_corner_heights;
	std::vector<glm::u16vec4> ground_texture_list;
	std::vector<unsigned char> ground_exists_data;

	std::vector<float> water_heights;
	std::vector<unsigned char> water_exists_data;
	
	btHeightfieldTerrainShape* collision_shape;
	btRigidBody* collision_body;
public:
	char tileset;
	std::vector<std::string> tileset_ids;
	std::vector<std::string> cliffset_ids;

	int width;
	int height;
	glm::vec2 offset;

	// Ground
	std::shared_ptr<Shader> ground_shader;
	std::map<std::string, int> ground_texture_to_id;
	std::vector<std::shared_ptr<GroundTexture>> ground_textures;
	std::unordered_map<std::string, TilePathingg> pathing_options;

	// GPU textures
	GLuint ground_height;
	GLuint ground_corner_height;
	GLuint ground_texture_data;
	GLuint ground_exists;
	GLuint water_height;
	GLuint water_exists;

	std::vector<std::vector<Corner>> corners;
	// For undo/redo operations
	std::vector<std::vector<Corner>> old_corners;

	int variation_size = 64;
	int blight_texture;

	slk::SLK terrain_slk;
	slk::SLK cliff_slk;

	// Cliffs
	std::vector<glm::ivec3> cliffs;
	std::map<std::string, int> path_to_cliff;
	std::map<std::string, int> cliff_variations;
	std::vector<int> cliff_to_ground_texture;
	
	std::shared_ptr<Shader> cliff_shader;
	std::vector<std::shared_ptr<CliffMesh>> cliff_meshes;
	std::vector<std::shared_ptr<Texture>> cliff_textures;

	GLuint cliff_texture_array;
	
	int cliff_texture_size = 256;

	// Water
	float min_depth = 10.f / 128.f;
	float deeplevel = 64.f / 128.f;
	float maxdepth = 72.f / 128.f;

	glm::vec4 shallow_color_min;
	glm::vec4 shallow_color_max;
	glm::vec4 deep_color_min;
	glm::vec4 deep_color_max;

	float water_offset;
	int water_textures_nr;
	int animation_rate;

	std::shared_ptr<Shader> water_shader;

	float current_texture = 1.f;
	GLuint water_texture_array;

	~Terrain();

	bool load();
	void create();
	void save() const;
	void render_ground() const;
	void render_water() const;

	void change_tileset(const std::vector<std::string>& new_tileset_ids, std::vector<int> new_to_old);

	int real_tile_texture(int x, int y) const;
	int get_tile_variation(int ground_texture, int variation) const;
	glm::u16vec4 get_texture_variations(int x, int y) const;

	float interpolated_height(float x, float y) const;

	//bool is_corner_ramp_mesh(int x, int y);
	bool is_corner_ramp_entrance(int x, int y);
	//bool is_corner_cliff(int x, int y);

	Texture minimap_image();

	enum class undo_type {
		texture,
		height,
		cliff,
		water
	};

	void new_undo_group();
	void add_undo(const QRect& area, undo_type type);

	void upload_ground_heights() const;
	void upload_corner_heights() const;
	void upload_ground_texture() const;
	void upload_ground_exists() const;
	void upload_water_exists() const;
	void upload_water_heights() const;

	void update_ground_heights(const QRect& area);
	void update_ground_textures(const QRect& area);
	void update_ground_exists(const QRect& area);
	void update_water(const QRect& area);
	void update_cliff_meshes(const QRect& area);

	void update_minimap();

	void resize(size_t width, size_t height);

signals:
	void minimap_changed(Texture minimap);
};

// Undo/redo structures
class TerrainGenericAction : public TerrainUndoAction {
public:
	QRect area;
	std::vector<Corner> old_corners;
	std::vector<Corner> new_corners;
	Terrain::undo_type undo_type;

	void undo() override;
	void redo() override;
};
```

`src/Base/TerrainUndo.cpp`:

```cpp
#include "TerrainUndo.h"

void TerrainUndo::undo() {
	if (undo_actions.empty()) {
		return;
	}

	auto& actions = undo_actions.back();
	for (const auto& i : actions) {
		i->undo();
	}

	redo_actions.push_back(std::move(actions));
	undo_actions.pop_back();
}

void TerrainUndo::redo() {
	if (redo_actions.empty()) {
		return;
	}

	auto& actions = redo_actions.back();
	for (const auto& i : actions) {
		i->redo();
	}

	undo_actions.push_back(std::move(actions));
	redo_actions.pop_back();
}

void TerrainUndo::new_undo_group() {
	undo_actions.push_back({});
}

void TerrainUndo::add_undo_action(std::unique_ptr<TerrainUndoAction> action) {
	if (undo_actions.empty()) {
		return;
	}

	undo_actions.back().push_back(std::move(action));
	redo_actions.clear();
}
```

`src/Base/TerrainUndo.h`:

```h
#pragma once

#include <vector>
#include <memory>

class TerrainUndoAction {
public:
	virtual void undo() = 0;
	virtual void redo() = 0;

	virtual ~TerrainUndoAction() {}
};

class TerrainUndo {
	std::vector<std::vector<std::unique_ptr<TerrainUndoAction>>> undo_actions;
	std::vector<std::vector<std::unique_ptr<TerrainUndoAction>>> redo_actions;

public:
	void undo();
	void redo();

	void new_undo_group();
	void add_undo_action(std::unique_ptr<TerrainUndoAction> action);
};
```

`src/Base/TriggerStrings.cpp`:

```cpp
#include "TriggerStrings.h"

#include <sstream>
#include <iostream>
#include <algorithm>
#include <cmath>

import BinaryWriter;
import Hierarchy;


#undef min
#undef max

void TriggerStrings::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.wts");

	std::stringstream file;
	file << reader.buffer.data();

	std::string key;
	std::string line;
	while (std::getline(file, line)) {
		if (line.empty() || line.substr(0, 2) == "//") {
			continue;
		}
		if (line.back() == '\r') {
			line.pop_back();
		}

		if (line.empty()) {
			continue;
		}

		line.erase(std::remove_if(line.begin(), line.end(), [](char c) { return c == '\r'; }), line.end());

		if (line.front() == '{') {
			std::string value;
			bool first = true;
			while (std::getline(file, line) && !line.empty() && line.front() != '}') {
				if (line.back() == '\r') {
					line.pop_back();
				}
				value += (first ? "" : "\n") + line;
				first = false;
			}
			strings.emplace(key, value);
		} else {
			size_t found = line.find(' ') + 1;
			next_id = std::max(next_id, found);
			int padsize = std::max(0, 3 - ((int)line.size() - (int)found));
			key = "TRIGSTR_" + std::string(padsize, '0') + line.substr(found);
		}
	}
}

void TriggerStrings::save() const {
	BinaryWriter writer;

	writer.write<uint8_t>(0xEF);
	writer.write<uint8_t>(0xBB);
	writer.write<uint8_t>(0xBF);

	std::stringstream file;
	for (auto&& [key, value] : strings) {
		auto found = key.find('_') + 1;
		std::string final_key = "STRING " + key.substr(found);

		// Remove leading zeroes
		while (final_key.front() == '0') {
			final_key.erase(final_key.begin());
		}

		std::string final_value = value;
		// Insert carriage returns
		auto it = final_value.begin();
		while (it != final_value.end()) {
			if (*it == '\n') {
				it = final_value.insert(it, '\r');
				it++;
			}
			it++;
		}
		
		writer.write_string(final_key);
		writer.write_string("\r\n{\r\n");
		writer.write_string(final_value);
		writer.write_string("\r\n}\r\n\r\n");
	}

	hierarchy.map_file_write("war3map.wts", writer.buffer);
}

std::string TriggerStrings::string(const std::string& key) const {
	if (!strings.contains(key)) {
		return "";
	}

	return strings.at(key);
}

/// If the key exists then the correspending string in the trigger string file is set
/// If the key does not exist AND the key empty AND the value is not empty then a string reference is created and assigned to the key variable
void TriggerStrings::set_string(std::string& key, const std::string& value) {
	if (key.rfind("TRIGSTR_", 0) != 0) {
		if (key.empty() && !value.empty()) {
			const int padsize = std::max(0, 2 - static_cast<int>(std::log10(next_id)));
			key = "TRIGSTR_" + std::string(padsize, '0') + std::to_string(++next_id);
			strings[key] = value;
			std::cout << "Creating key: " << key << "  " << value << "\n";

			return;
		}
		std::cout << "Invalid TRIGSTR set: " << key << " " << value << "\n";
		return;
	}

	strings[key] = value;
}
```

`src/Base/TriggerStrings.h`:

```h
#pragma once

import BinaryReader;

#include <map>
#include<string>

class TriggerStrings {
	std::map<std::string, std::string> strings; // ToDo change back to unordered_map?

	size_t next_id;
public:
	void load();
	void save() const;

	std::string string(const std::string& key) const;
	void set_string(std::string& key, const std::string& value);
};
```

`src/Base/Triggers.cpp`:

```cpp
#include "Triggers.h"

#include <functional>
#include <fstream>

#include <QProcess>
#include <QMessageBox>
#include <QDir>

#include "fmt/format.h"

#include "Globals.h"
#include "Utilities.h"
import Hierarchy;


using namespace std::literals::string_literals;

void Triggers::parse_parameter_structure(BinaryReader& reader, TriggerParameter& parameter, uint32_t version) {
	parameter.type = static_cast<TriggerParameter::Type>(reader.read<uint32_t>());
	parameter.value = reader.read_c_string();
	parameter.has_sub_parameter = reader.read<uint32_t>();
	if (parameter.has_sub_parameter) {
		parameter.sub_parameter.type = static_cast<TriggerSubParameter::Type>(reader.read<uint32_t>());
		parameter.sub_parameter.name = reader.read_c_string();
		parameter.sub_parameter.begin_parameters = reader.read<uint32_t>();
		if (parameter.sub_parameter.begin_parameters) {
			parameter.sub_parameter.parameters.resize(argument_counts[parameter.sub_parameter.name]);
			for (auto&& i : parameter.sub_parameter.parameters) {
				parse_parameter_structure(reader, i, version);
			}
		}
	}
	if (version == 4) {
		if (parameter.type == TriggerParameter::Type::function) {
			reader.advance(4); // Unknown always 0
		} else {
			parameter.is_array = reader.read<uint32_t>();
		}
	} else {
		if (parameter.has_sub_parameter) {
			parameter.unknown = reader.read<uint32_t>(); // Unknown always 0
		}
		parameter.is_array = reader.read<uint32_t>();
	}
	if (parameter.is_array) {
		parameter.parameters.resize(1);
		parse_parameter_structure(reader, parameter.parameters.front(), version);
	}
}

void Triggers::parse_eca_structure(BinaryReader& reader, ECA& eca, bool is_child, uint32_t version) {
	eca.type = static_cast<ECA::Type>(reader.read<uint32_t>());
	if (is_child) {
		eca.group = reader.read<uint32_t>();
	}
	eca.name = reader.read_c_string();
	eca.enabled = reader.read<uint32_t>();
	eca.parameters.resize(argument_counts[eca.name]);
	for (auto&& i : eca.parameters) {
		parse_parameter_structure(reader, i, version);
	}
	if (version == 7) {
		eca.ecas.resize(reader.read<uint32_t>());
		for (auto&& i : eca.ecas) {
			parse_eca_structure(reader, i, true, version);
		}
	}
}

void Triggers::load() {
	BinaryReader reader = hierarchy.map_file_read("war3map.wtg");

	trigger_strings.load("UI/TriggerStrings.txt");
	trigger_data.load("UI/TriggerData.txt");
	trigger_data.substitute(world_edit_strings, "WorldEditStrings");

	// Manual fixes
	trigger_data.set_whole_data("TriggerTypeDefaults", "string", "\"\"");

	for (auto&& section : { "TriggerActions"s, "TriggerEvents"s, "TriggerConditions"s, "TriggerCalls"s }) {
		for (const auto& [key, value] : trigger_data.section(section)) {
			if (key.front() == '_') {
				continue;
			}

			int arguments = 0;
			for (const auto& j : value) {
				arguments += !j.empty() && !is_number(j) && j != "nothing";
			}

			if (section == "TriggerCalls") {
				--arguments;
			}

			argument_counts[key] = arguments;
		}
	}

	Trigger::next_id = 0;

	std::string magic_number = reader.read_string(4);
	if (magic_number != "WTG!") {
		fmt::print("Unknown magic number for war3map.wtg {}\n", magic_number);
		return;
	}

	uint32_t version = reader.read<uint32_t>();
	if (version == 0x80000004)
		load_version_31(reader, version);
	else if (version == 4 || version == 7)
		load_version_pre31(reader, version);
	else {
		fmt::print("Unknown WTG format! Trying 1.31 loader\n");
		load_version_31(reader, version);
	}
}

void Triggers::load_version_pre31(BinaryReader& reader, uint32_t version) {
	fmt::print("Importing pre-1.31 trigger format\n");

	categories.resize(reader.read<uint32_t>());
	for (auto& i : categories) {
		i.classifier = Classifier::category;
		i.id = reader.read<uint32_t>();
		i.name = reader.read_c_string();
		i.parent_id = 0;
		if (version == 7) {
			i.is_comment = reader.read<uint32_t>();
		}

		Trigger::next_id = std::max(Trigger::next_id, i.id + 1);
		if (i.id == 0) {
			i.id = -2;
		}
	}


	reader.advance(4); // dunno

	int variable_category = Trigger::next_id++;
	categories.insert(categories.begin(), { Classifier::map, 0, "Map Header", true, false, -1 });
	categories.insert(categories.begin(), { Classifier::category, variable_category, "Variables", true, false, 0 });

	variables.resize(reader.read<uint32_t>());
	for (auto& i : variables) {
		i.name = reader.read_c_string();
		i.type = reader.read_c_string();
		i.unknown = reader.read<uint32_t>();
		i.id = Trigger::next_id++;

		i.is_array = reader.read<uint32_t>();
		if (version == 7) {
			i.array_size = reader.read<uint32_t>();
		}
		i.is_initialized = reader.read<uint32_t>();
		i.initial_value = reader.read_c_string();
		i.parent_id = variable_category;
	}

	triggers.resize(reader.read<uint32_t>());
	for (auto& i : triggers) {
		i.name = reader.read_c_string();
		i.description = reader.read_c_string();
		if (version == 7) {
			i.is_comment = reader.read<uint32_t>();
		}
		i.is_enabled = reader.read<uint32_t>();
		i.is_script = reader.read<uint32_t>();
		i.initially_on = !reader.read<uint32_t>();
		i.run_on_initialization = reader.read<uint32_t>();

		i.id = Trigger::next_id++;

		if (i.run_on_initialization && i.is_script) {
			i.classifier = Classifier::gui;
		} else if (i.is_comment) {
			i.classifier = Classifier::comment;
		} else if (i.is_script) {
			i.classifier = Classifier::script;
		} else {
			i.classifier = Classifier::gui;
		}
    
		i.parent_id = reader.read<uint32_t>();
		if (i.parent_id == 0) {
			i.parent_id = -2;
		}
		i.ecas.resize(reader.read<uint32_t>());
		for (auto& j : i.ecas) {
			parse_eca_structure(reader, j, false, version);
		}
	}
}

void Triggers::load_version_31(BinaryReader& reader, uint32_t version) {
	uint32_t sub_version = reader.read<uint32_t>();
	if (sub_version != 7 && sub_version != 4) {
		fmt::print("Unknown 1.31 WTG subformat! Trying anyway.\n");
	}

	reader.advance(4);							 // map_count
	reader.advance(4 * reader.read<uint32_t>()); //map ids of deleted maps

	reader.advance(4);							 // library_count
	reader.advance(4 * reader.read<uint32_t>()); // library ids of deleted libraries
	
	reader.advance(4);							 // category_count
	reader.advance(4 * reader.read<uint32_t>()); // category ids of deleted categories

	reader.advance(4);							 // trigger_count
	reader.advance(4 * reader.read<uint32_t>()); // trigger ids of deleted triggers

	reader.advance(4);							 // comment_count
	reader.advance(4 * reader.read<uint32_t>()); // comment ids of deleted comments

	reader.advance(4);							 // script_count
	reader.advance(4 * reader.read<uint32_t>()); // script ids of deleted scripts

	reader.advance(4);							 // variable_count
	reader.advance(4 * reader.read<uint32_t>()); // variable ids of deleted variables

	unknown1 = reader.read<uint32_t>();
	unknown2 = reader.read<uint32_t>();
	trig_def_ver = reader.read<uint32_t>();

	uint32_t variable_count = reader.read<uint32_t>();
	for (uint32_t i = 0; i < variable_count; i++) {
		TriggerVariable variable;
		variable.name = reader.read_c_string();
		variable.type = reader.read_c_string();
		variable.unknown = reader.read<uint32_t>();
		variable.is_array = reader.read<uint32_t>();
		if (sub_version == 7) {
			variable.array_size = reader.read<uint32_t>();
		}
		variable.is_initialized = reader.read<uint32_t>();
		variable.initial_value = reader.read_c_string();
		variable.id = reader.read<uint32_t>();
		variable.parent_id = reader.read<uint32_t>();
		variables.push_back(variable);

		Trigger::next_id = std::max(Trigger::next_id, variable.id + 1);
	}
	
	uint32_t element_count = reader.read<uint32_t>();

	for (uint32_t i = 0; i < element_count; i++) {
		Classifier classifier = static_cast<Classifier>(reader.read<uint32_t>());
		switch (classifier) {
			case Classifier::map:
			case Classifier::library:
			case Classifier::category: {
				TriggerCategory cat;
				cat.classifier = classifier;
				cat.id = reader.read<uint32_t>();
				cat.name = reader.read_c_string();
				if (sub_version == 7) {
					cat.is_comment = reader.read<uint32_t>();
				}
				cat.open_state = reader.read<uint32_t>();
				cat.parent_id = reader.read<uint32_t>();
				categories.push_back(cat);

				Trigger::next_id = std::max(Trigger::next_id, cat.id + 1);
				break;
			}
			case Classifier::gui:
			case Classifier::comment:
			case Classifier::script: {
				Trigger trigger;
				trigger.classifier = classifier;
				trigger.name = reader.read_c_string();
				trigger.description = reader.read_c_string();
				if (sub_version == 7) {
					trigger.is_comment = reader.read<uint32_t>();
				}
				trigger.id = reader.read<uint32_t>();
				trigger.is_enabled = reader.read<uint32_t>();
				trigger.is_script = reader.read<uint32_t>();
				trigger.initially_on = !reader.read<uint32_t>();
				trigger.run_on_initialization = reader.read<uint32_t>();
				trigger.parent_id = reader.read<uint32_t>();
				trigger.ecas.resize(reader.read<uint32_t>());
				for (auto& j : trigger.ecas) {
					parse_eca_structure(reader, j, false, sub_version);
				}

				triggers.push_back(trigger);

				Trigger::next_id = std::max(Trigger::next_id, trigger.id + 1);
				break;
			}
			case Classifier::variable: {
				reader.advance(4); //id
				reader.advance_c_string(); //name
				reader.advance(4); //parentid
				break;
			}
		}
	}
}

void Triggers::load_jass() {
	BinaryReader reader = hierarchy.map_file_read("war3map.wct");

	const uint32_t version = reader.read<uint32_t>();
	if (version != 0x80000004) {
		if (version == 1 || version == 0) {
			if (version == 1) {
				global_jass_comment = reader.read_c_string();
				global_jass = reader.read_string(reader.read<uint32_t>());
			}
			reader.advance(4);
			for (auto&& i : triggers) {
				const uint32_t size = reader.read<uint32_t>();
				if (size > 0) {
					i.custom_text = reader.read_string(size);
				}
			}
			return;
		} else {
			fmt::print("Probably invalid WCT format\n");
		}
	} 

	const int sub_version = reader.read<uint32_t>();
	if (sub_version != 1 && sub_version != 0) {
		fmt::print("Unknown WCT 1.31 subformat\n");
	}

	if (sub_version == 1) {
		global_jass_comment = reader.read_c_string();
		int size = reader.read<uint32_t>();
		if (size > 0) {
			global_jass = reader.read_string(size);
		}
	}

	for (auto& i : triggers) {
		if (!i.is_comment) {
			int size = reader.read<uint32_t>();
			if (size > 0) {
				i.custom_text = reader.read_string(size);
			}
		}
	}
}

void Triggers::print_parameter_structure(BinaryWriter& writer, const TriggerParameter& parameter) const {
	writer.write<uint32_t>(static_cast<int>(parameter.type));
	writer.write_c_string(parameter.value);
	writer.write<uint32_t>(parameter.has_sub_parameter);

	if (parameter.has_sub_parameter) {
		writer.write<uint32_t>(static_cast<int>(parameter.sub_parameter.type));
		writer.write_c_string(parameter.sub_parameter.name);
		writer.write<uint32_t>(parameter.sub_parameter.begin_parameters);
		if (parameter.sub_parameter.begin_parameters) {
			for (const auto& i : parameter.sub_parameter.parameters) {
				print_parameter_structure(writer, i);
			}
		}

		writer.write<uint32_t>(parameter.unknown);
	}
	writer.write<uint32_t>(parameter.is_array);
	if (parameter.is_array) {
		print_parameter_structure(writer, parameter.parameters.front());
	}
}

void Triggers::print_eca_structure(BinaryWriter& writer, const ECA& eca, bool is_child) const {
	writer.write<uint32_t>(static_cast<int>(eca.type));
	if (is_child) {
		writer.write<uint32_t>(eca.group);
	}

	writer.write_c_string(eca.name);
	writer.write<uint32_t>(eca.enabled);
	for (const auto& i : eca.parameters) {
		print_parameter_structure(writer, i);
	}

	writer.write<uint32_t>(eca.ecas.size());
	for (const auto& i : eca.ecas) {
		print_eca_structure(writer, i, true);
	}
}

void Triggers::save() const {
 	BinaryWriter writer;
	writer.write_string("WTG!");
	writer.write<uint32_t>(write_version);
	writer.write<uint32_t>(write_sub_version);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(0);
	writer.write<uint32_t>(0);

	writer.write<uint32_t>(unknown1);
	writer.write<uint32_t>(unknown2);
	writer.write<uint32_t>(trig_def_ver);
	writer.write<uint32_t>(variables.size());

	for (const auto& i : variables) {
		writer.write_c_string(i.name);
		writer.write_c_string(i.type);
		writer.write<uint32_t>(i.unknown);
		writer.write<uint32_t>(i.is_array);
		writer.write<uint32_t>(i.array_size);
		writer.write<uint32_t>(i.is_initialized);
		writer.write_c_string(i.initial_value);
		writer.write<uint32_t>(i.id);
		writer.write<uint32_t>(i.parent_id);
	}

	writer.write<uint32_t>(categories.size() + triggers.size() + variables.size());
	
	for (const auto& i : categories) {
		writer.write<uint32_t>(static_cast<int>(i.classifier));
		writer.write<uint32_t>(i.id);
		writer.write_c_string(i.name);
		writer.write<uint32_t>(i.is_comment);
		writer.write<uint32_t>(i.open_state);
		writer.write<uint32_t>(i.parent_id);
	}

	for (const auto& i : triggers) {
		writer.write<uint32_t>(static_cast<int>(i.classifier));
		writer.write_c_string(i.name);
		writer.write_c_string(i.description);

		writer.write<uint32_t>(i.is_comment);
		writer.write<uint32_t>(i.id);
		writer.write<uint32_t>(i.is_enabled);
		writer.write<uint32_t>(i.is_script);
		writer.write<uint32_t>(!i.initially_on);
		writer.write<uint32_t>(i.run_on_initialization);
		writer.write<uint32_t>(i.parent_id);
		writer.write<uint32_t>(i.ecas.size());
		for (const auto& eca : i.ecas) {
			print_eca_structure(writer, eca, false);
		}
	}

	for (const auto& i : variables) {
		writer.write<uint32_t>(static_cast<int>(Classifier::variable));
		writer.write<uint32_t>(i.id);
		writer.write_c_string(i.name);
		writer.write<uint32_t>(i.parent_id);
	}

	hierarchy.map_file_write("war3map.wtg", writer.buffer);
}

void Triggers::save_jass() const {
	BinaryWriter writer;

	writer.write<uint32_t>(write_version);
	writer.write<uint32_t>(1);

	writer.write_c_string(global_jass_comment);
	if (global_jass.size() == 0) {
		writer.write<uint32_t>(0);
	} else {
		writer.write<uint32_t>(global_jass.size() + (global_jass.back() == '\0' ? 0 : 1));
		writer.write_c_string(global_jass);
	}

	// Custom text (jass) needs to be saved in the order they appear in the hierarchy
	for (const auto& j : categories) {
		for (const auto& i : triggers) {
			if (i.parent_id == j.id) {
				if (!i.is_comment) {
					if (i.custom_text.size() == 0) {
						writer.write<uint32_t>(0);
					} else {
						writer.write<uint32_t>(i.custom_text.size() + (i.custom_text.back() == '\0' ? 0 : 1));
						writer.write_c_string(i.custom_text);
					}
				}
			}
		}
	}

	hierarchy.map_file_write("war3map.wct", writer.buffer);
}

void Triggers::generate_global_variables(BinaryWriter& writer, std::unordered_map<std::string, std::string>& unit_variables, std::unordered_map<std::string, std::string>& destructable_variables) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Global variables\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("globals\n");

	for (const auto& variable : variables) {
		std::string base_type = get_base_type(variable.type);
		if (variable.is_array) {
			writer.write_string("\t" + base_type + " array udg_" + variable.name + "\n");
		} else {
			std::string default_value = trigger_data.data("TriggerTypeDefaults", base_type);

			if (default_value.empty()) { // handle?
				default_value = "null";
			}

			writer.write_string("\t" + base_type + " udg_" + variable.name + " = " + default_value + "\n");
		}
	}

	for (const auto& i : map->regions.regions) {
		std::string region_name = i.name;
		trim(region_name);
		std::replace(region_name.begin(), region_name.end(), ' ', '_');
		writer.write_string("\trect gg_rct_" + region_name + " = null\n");
	}

	for (const auto& i : map->cameras.cameras) {
		std::string camera_name = i.name;
		trim(camera_name);
		std::replace(camera_name.begin(), camera_name.end(), ' ', '_');
		writer.write_string("\tcamerasetup gg_cam_" + camera_name + " = null\n");
	}

	for (const auto& i : map->sounds.sounds) {
		std::string sound_name = i.name;
		trim(sound_name);
		std::replace(sound_name.begin(), sound_name.end(), ' ', '_');
		writer.write_string("\tsound " + sound_name + " = null\n");
	}

	for (const auto& i : triggers) {
		if (i.is_comment || !i.is_enabled) {
			continue;
		}

		std::string trigger_name = i.name;
		trim(trigger_name);
		std::replace(trigger_name.begin(), trigger_name.end(), ' ', '_');

		writer.write_string("\ttrigger gg_trg_" + trigger_name + " = null\n");
	}

	for (const auto& [creation_number, type] : unit_variables) {
		writer.write_string("\tunit gg_unit_" + type + "_" + creation_number + " = null\n");
	}

	for (const auto& [creation_number, type] : destructable_variables) {
		writer.write_string("\tdestructable gg_dest_" + type + "_" + creation_number + " = null\n");
	}

	writer.write_string("endglobals\n\n");
}

void Triggers::generate_init_global_variables(BinaryWriter& writer) {
	writer.write_string("function InitGlobals takes nothing returns nothing\n");
	writer.write_string("\tlocal integer i = 0\n");
	for (const auto& variable : variables) {
		const std::string base_type = trigger_data.data("TriggerTypes", variable.type, 4);
		const std::string type = base_type.empty() ? variable.type : base_type;
		std::string default_value = trigger_data.data("TriggerTypeDefaults", type);

		if (variable.is_array) {
			if (!variable.is_initialized && default_value.empty()) {
				continue;
			}
			writer.write_string("\tset i = 0\n");
			writer.write_string("\tloop\n");
			writer.write_string("\t\texitwhen(i > " + std::to_string(variable.array_size) + ")\n");

			if (variable.is_initialized) {
				if (type == "string" && variable.initial_value.empty()) {
					writer.write_string("\t\tset udg_" + variable.name + "[i] = \"\"\n");
				} else {
					writer.write_string("\t\tset udg_" + variable.name + "[i] = " + variable.initial_value + "\n");
				}
			} else {
				if (type == "string") {
					writer.write_string("\t\tset udg_" + variable.name + "[i] = \"\"\n");
				} else {
					writer.write_string("\t\tset udg_" + variable.name + "[i] = " + default_value + "\n");
				}
			}
			writer.write_string("\t\tset i = i + 1\n");
			writer.write_string("\tendloop\n");
			continue;
		}

		if (!variable.is_initialized) {
			continue;
		}

		if (type == "string") {
			writer.write_string("\tset udg_" + variable.name + " = \"" + variable.initial_value + "\"\n");
		} else {
			std::string converted_value = trigger_data.data("TriggerParams", variable.initial_value, 2);

			if (converted_value.empty()) {
				writer.write_string("\tset udg_" + variable.name + " = " + variable.initial_value + "\n");
			} else {
				writer.write_string("\tset udg_" + variable.name + " = " + converted_value + "\n");
			}
		}
	}
	writer.write_string("endfunction\n\n");
}

void Triggers::generate_units(BinaryWriter& writer, std::unordered_map<std::string, std::string>& unit_variables) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Unit Creation\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function CreateUnits takes nothing returns nothing\n");

	writer.write_string("\tlocal unit u\n");
	writer.write_string("\tlocal integer unitID\n");
	writer.write_string("\tlocal trigger t\n");
	writer.write_string("\tlocal real life\n");

	for (const auto& i : map->units.units) {
		if (i.id == "sloc") {
			continue;
		}

		std::string unit_reference = "u";
		if (unit_variables.contains(std::to_string(i.creation_number))) {
			unit_reference = fmt::format("gg_unit_{}_{}", i.id, i.creation_number);
		}

		writer.write_string(fmt::format("\tset {} = BlzCreateUnitWithSkin(Player({}), '{}', {:.4f}, {:.4f}, {:.4f}, '{}')\n",
			unit_reference, 
			i.player, 
			i.id, 
			i.position.x * 128.f + map->terrain.offset.x, 
			i.position.y * 128.f + map->terrain.offset.y, 
			glm::degrees(i.angle),
			i.skin_id));

		if (i.health != -1) {
			writer.write_string(fmt::format("\tset life = GetUnitState({}, UNIT_STATE_LIFE)\n", unit_reference));
			writer.write_string(fmt::format("\tcall SetUnitState({}, UNIT_STATE_LIFE, {:.4f}* life)\n", unit_reference, i.health / 100.f));
		}

		if (i.mana != -1) {
			writer.write_string(fmt::format("\tcall SetUnitState({}, UNIT_STATE_MANA, {})\n", unit_reference, i.mana));
		}
		if (i.level != 1) {
			writer.write_string(fmt::format("\tcall SetHeroLevel({}, {}, false)\n", unit_reference, i.level));
		}

		if (i.strength != 0) {
			writer.write_string(fmt::format("\tcall SetHeroStr({}, {}, true)\n", unit_reference, i.strength));
		}

		if (i.agility != 0) {
			writer.write_string(fmt::format("\tcall SetHeroAgi({}, {}, true)\n", unit_reference, i.agility));
		}

		if (i.intelligence != 0) {
			writer.write_string(fmt::format("\tcall SetHeroInt({}, {}, true)\n", unit_reference, i.intelligence));
		}

		float range;
		if (i.target_acquisition != -1.f) {
			if (i.target_acquisition == -2.f) {
				range = 200.f;
			} else {
				range = i.target_acquisition;
			}
			writer.write_string(fmt::format("\tcall SetUnitAcquireRange({}, {})\n", unit_reference, range));
		}

		for (const auto& j : i.abilities) {
			for (size_t k = 0; k < std::get<2>(j); k++) {
				writer.write_string(fmt::format("\tcall SelectHeroSkill({}, '{}')\n", unit_reference, std::get<0>(j)));
			}

			if (std::get<1>(j)) {
				std::string order_on = abilities_slk.data("orderon", std::get<0>(j));
				if (order_on.empty()) {
					order_on = abilities_slk.data("order", std::get<0>(j));
				}
				writer.write_string(fmt::format("\t call IssueImmediateOrder({}, \"{}\")\n", unit_reference, order_on));
			} else {
				std::string order_off = abilities_slk.data("orderoff", std::get<0>(j));
				if (!order_off.empty()) {
					writer.write_string(fmt::format("\tcall IssueImmediateOrder({}, \"{}\")\n", unit_reference, order_off));
				}
			}

		}

		for (const auto& j : i.items) {
			writer.write_string(fmt::format("\tcall UnitAddItemToSlotById({}, '{}', {})\n", unit_reference, j.second, j.first));
		}

		if (i.item_sets.size()) {
			writer.write_string("\tset t = CreateTrigger()\n");
			writer.write_string("\tcall TriggerRegisterUnitEvent(t, " + unit_reference + ", EVENT_UNIT_DEATH)\n");
			writer.write_string("\tcall TriggerRegisterUnitEvent(t, " + unit_reference + ", EVENT_UNIT_CHANGE_OWNER)\n");
			writer.write_string("\tcall TriggerAddAction(t, function UnitItemDrops_" + std::to_string(i.creation_number) + ")\n");
		}
	}

	writer.write_string("endfunction\n");
}

void Triggers::generate_items(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Items\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function CreateItems takes nothing returns nothing\n");

	writer.write_string("\tlocal integer itemID\n");
	for (const auto& i : map->units.items) {
		writer.write_string(fmt::format("\tcall CreateItem('{}', {:.4f}, {:.4f})\n", i.id, i.position.x * 128.f + map->terrain.offset.x, i.position.y * 128.f + map->terrain.offset.y));
	}

	writer.write_string("endfunction\n");
}

void Triggers::generate_destructables(BinaryWriter& writer, std::unordered_map<std::string, std::string>& destructable_variables) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Destructable Objects\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function CreateDestructables takes nothing returns nothing\n");
	writer.write_string("\tlocal destructable d\n");
	writer.write_string("\tlocal trigger t\n");
	writer.write_string("\tlocal real life\n");

	for (const auto& i : map->doodads.doodads) {
		std::string id = "d";

		if (destructable_variables.contains(std::to_string(i.creation_number))) {
			id = "gg_dest_" + i.id + "_" + std::to_string(i.creation_number);
		}

		if (id == "d" && i.item_sets.empty() && i.item_table_pointer == -1) {
			continue;
		}

		writer.write_string("\tset " + id + " = BlzCreateDestructableZWithSkin('" +
			i.id + "', " +
			std::to_string(i.position.x * 128.f + map->terrain.offset.x) + ", " +
			std::to_string(i.position.y * 128.f + map->terrain.offset.y) + ", " +
			std::to_string(i.position.z * 128.f) + ", " +
			std::to_string(glm::degrees(i.angle)) + ", " +
			std::to_string(i.scale.x) + ", " +
			std::to_string(i.variation) + ", " +
			i.skin_id + ")\n");

		if (i.life != 100) {
			writer.write_string("\tset life = GetDestructableLife(" + id + ")\n");
			writer.write_string("\tcall SetDestructableLife(" + id + ", " + std::to_string(i.life / 100.f) + " * life)\n");
		}

		if (!i.item_sets.empty()) {
			writer.write_string("\tset t = CreateTrigger()\n");
			writer.write_string("\tcall TriggerRegisterDeathEvent(t, " + id + ")\n");
			writer.write_string("\tcall TriggerAddAction(t, function SaveDyingWidget)\n");
			writer.write_string("\tcall TriggerAddAction(t, function UnitItemDrops_" + std::to_string(i.creation_number) + ")\n");
		} else if (i.item_table_pointer != -1) {
			writer.write_string("\tset t = CreateTrigger()\n");
			writer.write_string("\tcall TriggerRegisterDeathEvent(t, " + id + ")\n");
			writer.write_string("\tcall TriggerAddAction(t, function SaveDyingWidget)\n");
			writer.write_string("\tcall TriggerAddAction(t, function ItemTable_" + std::to_string(i.item_table_pointer) + ")\n");
		}

	}

	writer.write_string("endfunction\n");
}

void Triggers::generate_regions(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Regions\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function CreateRegions takes nothing returns nothing\n");
	writer.write_string("\tlocal weathereffect we\n\n");

	for (const auto& i : map->regions.regions) {
		std::string region_name = "gg_rct_" + i.name;
		trim(region_name);
		std::replace(region_name.begin(), region_name.end(), ' ', '_');

		writer.write_string(fmt::format("\tset {} = Rect({}, {}, {}, {})\n", region_name, std::min(i.left, i.right), std::min(i.bottom, i.top), std::max(i.left, i.right), std::max(i.bottom, i.top)));

		if (!i.weather_id.empty()) {
			writer.write_string(fmt::format("\tset we = AddWeatherEffect({}, '{}')\n", region_name, i.weather_id));
			writer.write_string("\tcall EnableWeatherEffect(we, true)\n");
		}
	}


	writer.write_string("endfunction\n");
}

void Triggers::generate_cameras(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Cameras\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function CreateCameras takes nothing returns nothing\n");

	for (const auto& i : map->cameras.cameras) {
		std::string camera_name = "gg_cam_" + i.name;
		trim(camera_name);
		std::replace(camera_name.begin(), camera_name.end(), ' ', '_');

		writer.write_string("\tset " + camera_name + " = CreateCameraSetup()\n");
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_ZOFFSET, {}, 0.0)\n", camera_name, i.z_offset));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_ROTATION, {}, 0.0)\n", camera_name, i.rotation));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_ANGLE_OF_ATTACK, {}, 0.0)\n", camera_name, i.angle_of_attack));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_TARGET_DISTANCE, {}, 0.0)\n", camera_name, i.distance));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_ROLL, {}, 0.0)\n", camera_name, i.roll));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_FIELD_OF_VIEW, {}, 0.0)\n", camera_name, i.fov));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_FARZ, {}, 0.0)\n", camera_name, i.far_z));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_NEARZ, {}, 0.0)\n", camera_name, i.near_z));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_LOCAL_PITCH, {}, 0.0)\n", camera_name, i.local_pitch));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_LOCAL_YAW, {}, 0.0)\n", camera_name, i.local_yaw));
		writer.write_string(fmt::format("\tcall CameraSetupSetField({}, CAMERA_FIELD_LOCAL_ROLL, {}, 0.0)\n", camera_name, i.local_roll));

		writer.write_string(fmt::format("\tcall CameraSetupSetDestPosition({}, {}, {}, 0.0)\n", camera_name, i.target_x, i.target_y));
	}

	writer.write_string("endfunction\n");
}

void Triggers::generate_sounds(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Sounds\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function InitSounds takes nothing returns nothing\n");

	for (const auto& i : map->sounds.sounds) {

		std::string sound_name = i.name;
		trim(sound_name);
		std::replace(sound_name.begin(), sound_name.end(), ' ', '_');
		//writer.write_string("\tset " + sound_name + " = CreateSound(\"" +
		//	string_replaced(i.file, "\\", "\\\\") + "\", " +
		//	(i.looping ? "true" : "false") + ", " +
		//	(i.is_3d ? "true" : "false") + ", " +
		//	(i.stop_out_of_range ? "true" : "false") + ", " +
		//	std::to_string(i.fade_in_rate) + ", " +
		//	std::to_string(i.fade_out_rate) + ", " +
		//	"\"" + string_replaced(i.eax_effect, "\\", "\\\\") + "\"" +
		//	")\n");

		writer.write_string(fmt::format("\tset {} = CreateSound(\"{}\", {}, {}, {}, {}, {}, \"{}\")\n", 
			sound_name, 
			string_replaced(i.file, "\\", "\\\\"), 
			i.looping ? "true" : "false", 
			i.is_3d ? "true" : "false", 
			i.stop_out_of_range ? "true" : "false", 
			i.fade_in_rate, 
			i.fade_out_rate, 
			string_replaced(i.eax_effect, "\\", "\\\\")));

		writer.write_string(fmt::format("\tcall SetSoundDuration({}, {})\n", sound_name, i.fade_in_rate));
		writer.write_string(fmt::format("\tcall SetSoundChannel({}, {})\n", sound_name, i.channel));
		writer.write_string(fmt::format("\tcall SetSoundVolume({}, {})\n", sound_name, i.volume));
		writer.write_string(fmt::format("\tcall SetSoundPitch({}, {})\n", sound_name, i.pitch));
	}

	//string_replaced(parameter.value, "\\", "\\\\")

	writer.write_string("endfunction\n");
}

void Triggers::write_item_table_entry(BinaryWriter &writer, int chance, const std::string &id) {
	if (id == "") {
		writer.write_string("\t\tcall RandomDistAddItem(-1, " + std::to_string(chance) + ")\n");
	} else if (id[0] == 'Y' && id[2] == 'I' &&
			   ((id[1] >= 'i' && id[1] <= 'o') || id[1] == 'Y')) { // Random items
		writer.write_string("\t\tcall RandomDistAddItem(ChooseRandomItemEx(ITEM_TYPE_");
		switch (id[1]) {
			case 'i': // permanent
				writer.write_string("PERMANENT, ");
				break;
			case 'j': // charged
				writer.write_string("CHARGED, ");
				break;
			case 'k': // powerup
				writer.write_string("POWERUP, ");
				break;
			case 'l': // artifact
				writer.write_string("ARTIFACT, ");
				break;
			case 'm': // purchasable
				writer.write_string("PURCHASABLE, ");
				break;
			case 'n': // campaign
				writer.write_string("CAMPAIGN, ");
				break;
			case 'o': // miscellaneous
				writer.write_string("MISCELLANEOUS, ");
				break;
			case 'Y': // any category
				writer.write_string("ANY, ");
				break;
		}
		if (id[3] == '/') // any level
			writer.write_string("-1), ");
		else
			writer.write_string(std::string(1, id[3]) + "), ");
		writer.write_string(std::to_string(chance) + ")\n");
	} else {
		writer.write_string("\t\tcall RandomDistAddItem('" + id + "', " + std::to_string(chance) + ")\n");
	}
}

void Triggers::generate_item_tables(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Map Item Tables\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	for (const auto& i : map->info.random_item_tables) {

		writer.write_string("function ItemTable_" + std::to_string(i.number) + " takes nothing returns nothing\n");

		writer.write_string(R"(
	local widget trigWidget= null
	local unit trigUnit= null
	local integer itemID= 0
	local boolean canDrop= true

	set trigWidget=bj_lastDyingWidget
	if ( trigWidget == null ) then
		set trigUnit=GetTriggerUnit()
	endif

	if ( trigUnit != null ) then
		set canDrop=not IsUnitHidden(trigUnit)
		if ( canDrop and GetChangingUnit() != null ) then
			set canDrop=( GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE) )
		endif
	endif

	if ( canDrop ) then
		)");

		writer.write_string("\n");

		for (const auto& j : i.item_sets) {
			writer.write_string("\t\tcall RandomDistReset()\n");
			for (const auto& [chance, id] : j.items) {
				write_item_table_entry(writer, chance, id);
			}

			writer.write_string(R"(
		set itemID=RandomDistChoose()
		if ( trigUnit != null ) then
			call UnitDropItem(trigUnit, itemID)
		else
			call WidgetDropItem(trigWidget, itemID)
		endif
		)");

		}

		writer.write_string(R"(
	endif

	set bj_lastDyingWidget=null
	call DestroyTrigger(GetTriggeringTrigger())
endfunction
		)");

		writer.write_string("\n");
	}
}

void Triggers::generate_unit_item_tables(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Unit Item Tables\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	for (const auto& i : map->units.units) {
		if (i.item_sets.size()) {


			writer.write_string("function UnitItemDrops_" + std::to_string(i.creation_number) + " takes nothing returns nothing\n");

			writer.write_string(R"(
	local widget trigWidget= null
	local unit trigUnit= null
	local integer itemID= 0
	local boolean canDrop= true

	set trigWidget=bj_lastDyingWidget
	if ( trigWidget == null ) then
		set trigUnit=GetTriggerUnit()
	endif

	if ( trigUnit != null ) then
		set canDrop=not IsUnitHidden(trigUnit)
		if ( canDrop and GetChangingUnit() != null ) then
			set canDrop=( GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE) )
		endif
	endif

	if ( canDrop ) then
		)");

			writer.write_string("\n");

			for (const auto& j : i.item_sets) {
				writer.write_string("\t\tcall RandomDistReset()\n");
				for (const auto& [id, chance] : j.items) {
					write_item_table_entry(writer, chance, id);
				}

				writer.write_string(R"(
		set itemID=RandomDistChoose()
		if ( trigUnit != null ) then
			call UnitDropItem(trigUnit, itemID)
		else
			call WidgetDropItem(trigWidget, itemID)
		endif
		)");

			}

			writer.write_string(R"(
	endif

	set bj_lastDyingWidget=null
	call DestroyTrigger(GetTriggeringTrigger())
endfunction
		)");

			writer.write_string("\n");
		}
	}

	for (const auto& i : map->doodads.doodads) {
		if (i.item_sets.size()) {


			writer.write_string("function UnitItemDrops_" + std::to_string(i.creation_number) + " takes nothing returns nothing\n");

			writer.write_string(R"(
	local widget trigWidget= null
	local unit trigUnit= null
	local integer itemID= 0
	local boolean canDrop= true

	set trigWidget=bj_lastDyingWidget
	if ( trigWidget == null ) then
		set trigUnit=GetTriggerUnit()
	endif

	if ( trigUnit != null ) then
		set canDrop=not IsUnitHidden(trigUnit)
		if ( canDrop and GetChangingUnit() != null ) then
			set canDrop=( GetChangingUnitPrevOwner() == Player(PLAYER_NEUTRAL_AGGRESSIVE) )
		endif
	endif

	if ( canDrop ) then
		)");

			writer.write_string("\n");

			for (const auto& j : i.item_sets) {
				writer.write_string("\t\tcall RandomDistReset()\n");
				for (const auto& [id, chance] : j.items) {
					write_item_table_entry(writer, chance, id);
				}

				writer.write_string(R"(
		set itemID=RandomDistChoose()
		if ( trigUnit != null ) then
			call UnitDropItem(trigUnit, itemID)
		else
			call WidgetDropItem(trigWidget, itemID)
		endif
		)");

			}

			writer.write_string(R"(
	endif

	set bj_lastDyingWidget=null
	call DestroyTrigger(GetTriggeringTrigger())
endfunction
		)");

			writer.write_string("\n");
		}
	}
}

void Triggers::generate_trigger_initialization(BinaryWriter& writer, std::vector<std::string> initialization_triggers) {
	writer.write_string("function InitCustomTriggers takes nothing returns nothing\n");
	for (const auto& i : triggers) {
		if (i.is_comment || !i.is_enabled) {
			continue;
		}
		std::string trigger_name = i.name;
		trim(trigger_name);
		std::replace(trigger_name.begin(), trigger_name.end(), ' ', '_');

		writer.write_string("\tcall InitTrig_" + trigger_name + "()\n");
	}
	writer.write_string("endfunction\n");

	writer.write_string(separator);
	writer.write_string("function RunInitializationTriggers takes nothing returns nothing\n");
	for (const auto& i : initialization_triggers) {
		writer.write_string("\tcall ConditionalTriggerExecute(" + i + ")\n");
	}
	writer.write_string("endfunction\n");
}

void Triggers::generate_players(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Players\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function InitCustomPlayerSlots takes nothing returns nothing\n");

	const std::vector<std::string> players = { "MAP_CONTROL_USER", "MAP_CONTROL_COMPUTER", "MAP_CONTROL_NEUTRAL", "MAP_CONTROL_RESCUABLE" };
	const std::vector<std::string> races = { "RACE_PREF_RANDOM", "RACE_PREF_HUMAN", "RACE_PREF_ORC", "RACE_PREF_UNDEAD", "RACE_PREF_NIGHTELF" };

	int index = 0;
	for (const auto& i : map->info.players) {
		std::string player = "Player(" + std::to_string(i.internal_number) + "), ";
		writer.write_string("\tcall SetPlayerStartLocation(" + player + std::to_string(index) + ")\n");
		if (i.fixed_start_position || i.race == PlayerRace::selectable) {
			writer.write_string("\tcall ForcePlayerStartLocation(" + player + std::to_string(index) + ")\n");
		}

		writer.write_string("\tcall SetPlayerColor(" + player + "ConvertPlayerColor(" + std::to_string(i.internal_number) + "))\n");
		writer.write_string("\tcall SetPlayerRacePreference(" + player + races[static_cast<int>(i.race)] + ")\n");
		writer.write_string("\tcall SetPlayerRaceSelectable(" + player + "true" + ")\n");
		writer.write_string("\tcall SetPlayerController(" + player + players[static_cast<int>(i.type)] + ")\n");

		if (i.type == PlayerType::rescuable) {
			for (const auto& j : map->info.players) {
				if (j.type == PlayerType::human) {
					writer.write_string("\tcall SetPlayerAlliance(" + player + "Player(" + std::to_string(j.internal_number) + "), ALLIANCE_RESCUABLE, true)\n");
				}
			}
		}

		writer.write_string("\n");
		index++;

	}

	writer.write_string("endfunction\n\n");
}

void Triggers::generate_custom_teams(BinaryWriter& writer) {
	writer.write_string("function InitCustomTeams takes nothing returns nothing\n");

	int current_force = 0;
	for (const auto& i : map->info.forces) {
		writer.write_string("\n");
		writer.write_string("\t// Force: " + i.name + "\n");

		std::string post_state;

		for (const auto& j : map->info.players) {
			if (i.player_masks & (1 << j.internal_number)) {
				writer.write_string("\tcall SetPlayerTeam(Player(" + std::to_string(j.internal_number) + "), " + std::to_string(current_force) + ")\n");

				if (i.allied_victory) {
					writer.write_string("\tcall SetPlayerState(Player(" + std::to_string(j.internal_number) + "), PLAYER_STATE_ALLIED_VICTORY, 1)\n");
				}

				for (const auto& k : map->info.players) {
					if (i.player_masks & (1 << k.internal_number) && j.internal_number != k.internal_number) {
						if (i.allied) {
							//post_state += "\tcall SetPlayerAllianceStateAllyBJ(Player(" + std::to_string(j.internal_number) + "), Player(" + std::to_string(k.internal_number) + "), true)\n";
							post_state += fmt::format("\tcall SetPlayerAllianceStateAllyBJ(Player({}), Player({}), true)\n", j.internal_number, k.internal_number);
						}
						if (i.share_vision) {
							//post_state += "\tcall SetPlayerAllianceStateVisionBJ(Player(" + std::to_string(j.internal_number) + "), Player(" + std::to_string(k.internal_number) + "), true)\n";
							post_state += fmt::format("\tcall SetPlayerAllianceStateVisionBJ(Player({}), Player({}), true)\n", j.internal_number, k.internal_number);
						}
						if (i.share_unit_control) {
							//post_state += "\tcall SetPlayerAllianceStateControlBJ(Player(" + std::to_string(j.internal_number) + "), Player(" + std::to_string(k.internal_number) + "), true)\n";
							post_state += fmt::format("\tcall SetPlayerAllianceStateControlBJ(Player({}), Player({}), true)\n", j.internal_number, k.internal_number);
						}
						if (i.share_advanced_unit_control) {
							//post_state += "\tcall SetPlayerAllianceStateFullControlBJ(Player(" + std::to_string(j.internal_number) + "), Player(" + std::to_string(k.internal_number) + "), true)\n";
							post_state += fmt::format("\tcall SetPlayerAllianceStateFullControlBJ(Player({}), Player({}), true)\n", j.internal_number, k.internal_number);
						}
					}
				}
			}
		}

		if (!post_state.empty()) {
			writer.write_string(post_state);
		}

		writer.write_string("\n");
		current_force++;
	}
	writer.write_string("endfunction\n");
}

void Triggers::generate_ally_priorities(BinaryWriter& writer) {
	writer.write_string("function InitAllyPriorities takes nothing returns nothing\n");

	std::unordered_map<int, int> player_to_startloc;

	int current_player = 0;
	for (const auto& i : map->info.players) {
		player_to_startloc[i.internal_number] = current_player;
		current_player++;
	}


	current_player = 0;
	for (const auto& i : map->info.players) {
		std::string player_text;

		int current_index = 0;
		for (const auto& j : map->info.players) {
			if (i.ally_low_priorities_flags & (1 << j.internal_number) && i.internal_number != j.internal_number) {
				//player_text += "\tcall SetStartLocPrio(" + std::to_string(current_player) + ", " + std::to_string(current_index) + ", " + std::to_string(player_to_startloc[j.internal_number]) + ", MAP_LOC_PRIO_LOW)\n";
				player_text += fmt::format("\tcall SetStartLocPrio({}, {}, {}, MAP_LOC_PRIO_LOW)\n", current_player, current_index, player_to_startloc[j.internal_number]);
				current_index++;
			} else if (i.ally_high_priorities_flags & (1 << j.internal_number) && i.internal_number != j.internal_number) {
				//player_text += "\tcall SetStartLocPrio(" + std::to_string(current_player) + ", " + std::to_string(current_index) + ", " + std::to_string(player_to_startloc[j.internal_number]) + ", MAP_LOC_PRIO_HIGH)\n";
				player_text += fmt::format("\tcall SetStartLocPrio({}, {}, {}, MAP_LOC_PRIO_HIGH)\n", current_player, current_index, player_to_startloc[j.internal_number]);
				current_index++;
			}
		}

		//player_text = "\tcall SetStartLocPrioCount(" + std::to_string(current_player) + ", " + std::to_string(current_index) + ")\n" + player_text;
		player_text = fmt::format("\tcall SetStartLocPrioCount({}, {})\n", current_player, current_index) + player_text;
		writer.write_string(player_text);
		current_player++;
	}
	writer.write_string("endfunction\n");
}

void Triggers::generate_main(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Main Initialization\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function main takes nothing returns nothing\n");

	const std::string camera_bounds = "\tcall SetCameraBounds(" +
		std::to_string(map->info.camera_left_bottom.x - 512.f) + " + GetCameraMargin(CAMERA_MARGIN_LEFT), " +
		std::to_string(map->info.camera_left_bottom.y - 256.f) + " + GetCameraMargin(CAMERA_MARGIN_BOTTOM), " +

		std::to_string(map->info.camera_right_top.x + 512.f) + " - GetCameraMargin(CAMERA_MARGIN_RIGHT), " +
		std::to_string(map->info.camera_right_top.y + 256.f) + " - GetCameraMargin(CAMERA_MARGIN_TOP), " +

		std::to_string(map->info.camera_left_top.x - 512.f) + " + GetCameraMargin(CAMERA_MARGIN_LEFT), " +
		std::to_string(map->info.camera_left_top.y + 256.f) + " - GetCameraMargin(CAMERA_MARGIN_TOP), " +

		std::to_string(map->info.camera_right_bottom.x + 512.f) + " - GetCameraMargin(CAMERA_MARGIN_RIGHT), " +
		std::to_string(map->info.camera_right_bottom.y - 256.f) + " + GetCameraMargin(CAMERA_MARGIN_BOTTOM))\n";

	writer.write_string(camera_bounds);

	const std::string terrain_lights = string_replaced(world_edit_data.data("TerrainLights", ""s + map->terrain.tileset), "\\", "/");
	const std::string unit_lights = string_replaced(world_edit_data.data("TerrainLights", ""s + map->terrain.tileset), "\\", "/");
	writer.write_string("\tcall SetDayNightModels(\"" + terrain_lights + "\", \"" + unit_lights + "\")\n");

	const std::string sound_environment = string_replaced(world_edit_data.data("SoundEnvironment", ""s + map->terrain.tileset), "\\", "/");
	writer.write_string("\tcall NewSoundEnvironment(\"" + sound_environment + "\")\n");

	const std::string ambient_day = string_replaced(world_edit_data.data("DayAmbience", ""s + map->terrain.tileset), "\\", "/");
	writer.write_string("\tcall SetAmbientDaySound(\"" + ambient_day + "\")\n");

	const std::string ambient_night = string_replaced(world_edit_data.data("NightAmbience", ""s + map->terrain.tileset), "\\", "/");
	writer.write_string("\tcall SetAmbientNightSound(\"" + ambient_night + "\")\n");

	writer.write_string("\tcall SetMapMusic(\"Music\", true, 0)\n");
	writer.write_string("\tcall InitSounds()\n");
	writer.write_string("\tcall CreateRegions()\n");
	writer.write_string("\tcall CreateCameras()\n");
	writer.write_string("\tcall CreateDestructables()\n");
	writer.write_string("\tcall CreateItems()\n");
	writer.write_string("\tcall CreateUnits()\n");
	writer.write_string("\tcall InitBlizzard()\n");

	writer.write_string("\tcall InitGlobals()\n");
	writer.write_string("\tcall InitCustomTriggers()\n");
	writer.write_string("\tcall RunInitializationTriggers()\n");

	writer.write_string("endfunction\n");
}

void Triggers::generate_map_configuration(BinaryWriter& writer) {
	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Map Configuration\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string("function config takes nothing returns nothing\n");

	writer.write_string("\tcall SetMapName(\"" + map->info.name + " \")\n");
	writer.write_string("\tcall SetMapDescription(\"" + map->info.description + " \")\n");
	writer.write_string("\tcall SetPlayers(" + std::to_string(map->info.players.size()) + ")\n");
	writer.write_string("\tcall SetTeams(" + std::to_string(map->info.forces.size()) + ")\n");
	writer.write_string("\tcall SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)\n");

	writer.write_string("\n");

	for (const auto& i : map->units.units) {
		if (i.id == "sloc") {
			//writer.write_string("\tcall DefineStartLocation(" + std::to_string(i.player) + ", " + std::to_string(i.position.x * 128.f + map->terrain.offset.x) + ", " + std::to_string(i.position.y * 128.f + map->terrain.offset.y) + ")\n");
			writer.write_string(fmt::format("\tcall DefineStartLocation({}, {}, {})\n", i.player, i.position.x * 128.f + map->terrain.offset.x, i.position.y * 128.f + map->terrain.offset.y));
		}
	}

	writer.write_string("\n");

	writer.write_string("\tcall InitCustomPlayerSlots()\n");
	if (map->info.custom_forces) {
		writer.write_string("\tcall InitCustomTeams()\n");
	} else {
		for (const auto& i : map->info.players) {
			writer.write_string("\tcall SetPlayerSlotAvailable(Player(" +
				std::to_string(i.internal_number) +
				"), MAP_CONTROL_USER)\n");
		}

		writer.write_string("\tcall InitGenericPlayerSlots()\n");
	}
	writer.write_string("\tcall InitAllyPriorities()\n");

	writer.write_string("endfunction\n");
}

QString Triggers::generate_map_script() {
	std::unordered_map<std::string, std::string> unit_variables; // creation_number, unit_id
	std::unordered_map<std::string, std::string> destructable_variables; // creation_number, destructable_id
	std::vector<std::string> initialization_triggers;

	std::string trigger_script;
	for (const auto& i : triggers) {
		if (i.is_comment || !i.is_enabled) {
			continue;
		}
		if (!i.custom_text.empty()) {
			trigger_script += i.custom_text + "\n";
		} else {
			trigger_script += convert_gui_to_jass(i, initialization_triggers);
		}
	}

	// Search the trigger script for global unit/destructible definitons
	size_t pos = trigger_script.find("gg_unit", 0);
	while (pos != std::string::npos) {
		std::string type = trigger_script.substr(pos + 8, 4);
		std::string creation_number = trigger_script.substr(pos + 13, 4);
		unit_variables[creation_number] = type;
		pos = trigger_script.find("gg_unit", pos + 17);
	}

	pos = trigger_script.find("gg_dest", 0);
	while (pos != std::string::npos) {
		std::string type = trigger_script.substr(pos + 8, 4);
		std::string creation_number = trigger_script.substr(pos + 13, trigger_script.find_first_not_of("0123456789", pos + 13) - pos - 13);
		destructable_variables[creation_number] = type;
		pos = trigger_script.find("gg_dest", pos + 17);
	}

	// Write the results to a buffer
	BinaryWriter writer;

	generate_global_variables(writer, unit_variables, destructable_variables);
	generate_init_global_variables(writer);
	generate_item_tables(writer);
	generate_unit_item_tables(writer);
	generate_sounds(writer);

	generate_destructables(writer, destructable_variables);
	generate_items(writer);
	generate_units(writer, unit_variables);
	generate_regions(writer);
	generate_cameras(writer);

	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Custom Script Code\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string(global_jass);

	writer.write_string(separator);
	writer.write_string("//*\n");
	writer.write_string("//*  Triggers\n");
	writer.write_string("//*\n");
	writer.write_string(separator);

	writer.write_string(trigger_script);

	writer.write_string(separator);

	generate_trigger_initialization(writer, initialization_triggers);
	generate_players(writer);
	generate_custom_teams(writer);
	generate_ally_priorities(writer);
	generate_main(writer);
	generate_map_configuration(writer);

	fs::path path = QDir::tempPath().toStdString() + "/input.j";
	std::ofstream output(path, std::ios::binary);
	output.write((char*)writer.buffer.data(), writer.buffer.size());
	output.close();

	QProcess* proc = new QProcess();
	proc->setWorkingDirectory("Data/Tools");
	proc->start("Data/Tools/clijasshelper.exe", { "--scriptonly", "common.j", "blizzard.j", QString::fromStdString(path.string()), "war3map.j" });
	proc->waitForFinished();
	QString result = proc->readAllStandardOutput();

	if (result.contains("Compile error")) {
		QMessageBox::information(nullptr, "vJass output", "There were compilation errors. See the output tab for more information", QMessageBox::StandardButton::Ok);
		return result.mid(result.indexOf("Compile error"));
	} else if (result.contains("compile errors")) {
		QMessageBox::information(nullptr, "vJass output", "There were compilation errors. See the output tab for more information", QMessageBox::StandardButton::Ok);
		return result.mid(result.indexOf("compile errors."));
	} else {
		hierarchy.map_file_add("Data/Tools/war3map.j", "war3map.j");
		return "Compilation successful";
	}
}

std::string Triggers::convert_eca_to_jass(const ECA& eca, std::string& pre_actions, const std::string& trigger_name, bool nested) const {
	std::string output;

	if (!eca.enabled) {
		return "";
	}

	if (eca.name == "WaitForCondition") {
		output += "loop\n";
		output += "exitwhen (" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0)) + ")\n";
		output += "call TriggerSleepAction(RMaxBJ(bj_WAIT_FOR_COND_MIN_INTERVAL, " + resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1)) + "))\n";
		output += "endloop";
		return output;
	}

	if (eca.name == "ForLoopAMultiple" || eca.name == "ForLoopBMultiple") {
		std::string loop_index = eca.name == "ForLoopAMultiple" ? "bj_forLoopAIndex" : "bj_forLoopBIndex";
		std::string loop_index_end = eca.name == "ForLoopAMultiple" ? "bj_forLoopAIndexEnd" : "bj_forLoopBIndexEnd";

		output += "set " + loop_index + "=" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0)) + "\n";
		output += "set " + loop_index_end + "=" + resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1)) + "\n";
		output += "loop\n";
		output += "\texitwhen " + loop_index + " > " + loop_index_end + "\n";
		for (const auto& i : eca.ecas) {
			output += "\t" + convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
		}
		output += "\tset " + loop_index + " = " + loop_index + " + 1\n";
		output += "endloop\n";
		return output;
	}

	if (eca.name == "ForLoopVarMultiple") {
		std::string variable = resolve_parameter(eca.parameters[0], trigger_name, pre_actions, "integer");

		output += "set " + variable + " = ";
		output += resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1)) + "\n";
		output += "loop\n";
		output += "exitwhen " + variable + " > " + resolve_parameter(eca.parameters[2], trigger_name, pre_actions, get_type(eca.name, 2)) + "\n";
		for (const auto& i : eca.ecas) {
			output += convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
		}
		output += "set " + variable + " = " + variable + " + 1\n";
		output += "endloop\n";
		return output;
	}

	if (eca.name == "IfThenElseMultiple") {
		std::string iftext;
		std::string thentext;
		std::string elsetext;

		std::string function_name = generate_function_name(trigger_name);
		iftext += "function " + function_name + " takes nothing returns boolean\n";

		for (const auto& i : eca.ecas) {
			if (i.type == ECA::Type::condition) {
				iftext += "\tif (not (" + convert_eca_to_jass(i, pre_actions, trigger_name, true) + ")) then\n";
				iftext += "\t\treturn false\n";
				iftext += "\tendif\n";
			} else if (i.type == ECA::Type::action) {
				if (i.group == 1) {
					thentext += convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
				} else {
					elsetext += convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
				}
			}
		}
		iftext += "\treturn true\n";
		iftext += "endfunction\n";
		pre_actions += iftext;

		return "if (" + function_name + "()) then\n" + thentext + "\telse\n" + elsetext + "\tendif";
	}

	if (eca.name == "ForForceMultiple" || eca.name == "ForGroupMultiple") {
		const std::string function_name = generate_function_name(trigger_name);

		// Remove multiple
		output += "call " + eca.name.substr(0, 8) + "(" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0)) + ", function " + function_name + ")\n";

		std::string toto;
		for (const auto& i : eca.ecas) {
			toto += "\t" + convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
		}
		pre_actions += "function " + function_name + " takes nothing returns nothing\n";
		pre_actions += toto;
		pre_actions += "\nendfunction\n";

		return output;
	}

	// This one and ForForceMultiple look very much the same
	if (eca.name == "EnumDestructablesInRectAllMultiple") {
		std::string script_name = trigger_data.data("TriggerActions", "_" + eca.name + "_ScriptName");

		const std::string function_name = generate_function_name(trigger_name);

		// Remove multiple
		output += "call " + script_name + "(" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0)) + ", function " + function_name + ")\n";

		std::string toto;
		for (const auto& i : eca.ecas) {
			toto += "\t" + convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
		}
		pre_actions += "function " + function_name + " takes nothing returns nothing\n";
		pre_actions += toto;
		pre_actions += "\nendfunction\n";

		return output;
	}
	// And this one too
	if (eca.name == "EnumDestructablesInCircleBJMultiple") {
		std::string script_name = trigger_data.data("TriggerActions", "_" + eca.name + "_ScriptName");

		const std::string function_name = generate_function_name(trigger_name);

		// Remove multiple
		output += "call " + script_name + "(" + resolve_parameter(eca.parameters[0], trigger_name, pre_actions, get_type(eca.name, 0)) + ", " +
			resolve_parameter(eca.parameters[1], trigger_name, pre_actions, get_type(eca.name, 1)) + ", function " + function_name + ")\n";

		std::string toto;
		for (const auto& i : eca.ecas) {
			toto += "\t" + convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
		}
		pre_actions += "function " + function_name + " takes nothing returns nothing\n";
		pre_actions += toto;
		pre_actions += "\nendfunction\n";

		return output;
	}

	if (eca.name == "AndMultiple") {
		const std::string function_name = generate_function_name(trigger_name);

		std::string iftext = "function " + function_name + " takes nothing returns boolean\n";
		for (const auto& i : eca.ecas) {
			iftext += "\tif (not (" + convert_eca_to_jass(i, pre_actions, trigger_name, true) + ")) then\n";
			iftext += "\t\treturn false\n";
			iftext += "\tendif\n";
		}
		iftext += "\treturn true\n";
		iftext += "endfunction\n";
		pre_actions += iftext;

		return function_name + "()";
	}

	if (eca.name == "OrMultiple") {
		const std::string function_name = generate_function_name(trigger_name);

		std::string iftext = "function " + function_name + " takes nothing returns boolean\n";
		for (const auto& i : eca.ecas) {
			iftext += "\tif (" + convert_eca_to_jass(i, pre_actions, trigger_name, true) + ") then\n";
			iftext += "\t\treturn true\n";
			iftext += "\tendif\n";
		}
		iftext += "\treturn false\n";
		iftext += "endfunction\n";
		pre_actions += iftext;

		return function_name + "()";
	}

	return testt(trigger_name, eca.name, eca.parameters, pre_actions, !nested);
}

std::string Triggers::testt(const std::string& trigger_name, const std::string& parent_name, const std::vector<TriggerParameter>& parameters, std::string& pre_actions, bool add_call) const {
	std::string output;

	std::string script_name = trigger_data.data("TriggerActions", "_" + parent_name + "_ScriptName");
 
	if (parent_name == "SetVariable") {
		//const auto& type = variables.at(parameters[0].value).type;
		const std::string &type = (*find_if(variables.begin(), variables.end(),
			[parameters](const TriggerVariable& var) {
				return var.name == parameters[0].value;
			}
		)).type;
		const std::string first = resolve_parameter(parameters[0], trigger_name, pre_actions, "");
		const std::string second = resolve_parameter(parameters[1], trigger_name, pre_actions, type);

		return "set " + first + " = " + second;
	}

	if (parent_name == "CommentString") {
		return "//" + resolve_parameter(parameters[0], trigger_name, pre_actions, "");
	}

	if (parent_name == "CustomScriptCode") {
		return resolve_parameter(parameters[0], trigger_name, pre_actions, "");
	}

	if (parent_name.substr(0, 15) == "OperatorCompare") {
		output += resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		output += " " + resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1)) + " ";
		output += resolve_parameter(parameters[2], trigger_name, pre_actions, get_type(parent_name, 2));
		return output;
	}

	if (parent_name == "OperatorString") {
		output += "(" + resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		output += " + ";
		output += resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1)) + ")";
		return output;
	}

	if (parent_name == "ForLoopVar") {
		std::string variable = resolve_parameter(parameters[0], trigger_name, pre_actions, "integer");

		output += "set " + variable + " = ";
		output += resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1)) + "\n";
		output += "loop\n";
		output += "\texitwhen " + variable + " > " + resolve_parameter(parameters[2], trigger_name, pre_actions, get_type(parent_name, 2)) + "\n";
		output += "\t" + resolve_parameter(parameters[3], trigger_name, pre_actions, get_type(parent_name, 3), true) + "\n";
		output += "\tset " + variable + " = " + variable + " + 1\n";
		output += "endloop\n";
		return output;
	}

	if (parent_name == "IfThenElse") {
		std::string thentext;
		std::string elsetext;

		std::string function_name = generate_function_name(trigger_name);
		std::string tttt = resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));

		output += "if (" + function_name + "()) then\n";
		output += "\t" + resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1), true) + "\n";
		output += "else\n";
		output += "\t" + resolve_parameter(parameters[2], trigger_name, pre_actions, get_type(parent_name, 2), true) + "\n";
		output += "endif";

		pre_actions += "function " + function_name + " takes nothing returns boolean\n";
		pre_actions += "return " + tttt + "\n";
		pre_actions += "endfunction\n";
		return output;
	}

	if (parent_name == "ForForce" || parent_name == "ForGroup") {
		std::string function_name = generate_function_name(trigger_name);

		std::string tttt = resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1));

		output += parent_name + "(";
		output += resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		output += ", function " + function_name;
		output += ")";

		pre_actions += "function " + function_name + " takes nothing returns nothing\n";
		pre_actions += "\tcall " + tttt + "\n";
		pre_actions += "endfunction\n\n";
		return (add_call ? "call " : "") + output;
	}

	if (parent_name == "GetBooleanAnd") {
		std::string first_parameter = resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		std::string second_parameter = resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1));

		std::string function_name = generate_function_name(trigger_name);
		output += "GetBooleanAnd(" + function_name + "(), ";
		pre_actions += "function " + function_name + " takes nothing returns boolean\n";
		pre_actions += "\t return ( " + first_parameter + ")\n";
		pre_actions += "endfunction\n\n";

		function_name = generate_function_name(trigger_name);
		output += function_name + "())";
		pre_actions += "function " + function_name + " takes nothing returns boolean\n";
		pre_actions += "\t return ( " + second_parameter + ")\n";
		pre_actions += "endfunction\n\n";

		return (add_call ? "call " : "") + output;
	}

	if (parent_name == "GetBooleanOr") {
		std::string first_parameter = resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		std::string second_parameter = resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1));

		std::string function_name = generate_function_name(trigger_name);
		output += "GetBooleanOr(" + function_name + "(), ";
		pre_actions += "function " + function_name + " takes nothing returns boolean\n";
		pre_actions += "\t return ( " + first_parameter + ")\n";
		pre_actions += "endfunction\n\n";

		function_name = generate_function_name(trigger_name);
		output += function_name + "())";
		pre_actions += "function " + function_name + " takes nothing returns boolean\n";
		pre_actions += "\t return ( " + second_parameter + ")\n";
		pre_actions += "endfunction\n\n";

		return (add_call ? "call " : "") + output;
	}

	if (parent_name == "OperatorInt" || parent_name == "OperatorReal") {
		output += "(" + resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		output += " " + resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1)) + " ";
		output += resolve_parameter(parameters[2], trigger_name, pre_actions, get_type(parent_name, 2)) + ")";
		return output;
	}

	if (parent_name == "AddTriggerEvent") {
		std::string first_parameter = resolve_parameter(parameters[0], trigger_name, pre_actions, get_type(parent_name, 0));
		std::string second_parameter = resolve_parameter(parameters[1], trigger_name, pre_actions, get_type(parent_name, 1));
		output += second_parameter.insert(second_parameter.find_first_of('(') + 1, first_parameter + ", ");
		return (add_call ? "call " : "") + output;
	}

	for (size_t k = 0; k < parameters.size(); k++) {
		const auto& i = parameters[k];

		const std::string type = get_type(parent_name, k);

		if (type == "boolexpr") {
			const std::string function_name = generate_function_name(trigger_name);

			std::string tttt = resolve_parameter(parameters[k], trigger_name, pre_actions, type);

			pre_actions += "function " + function_name + " takes nothing returns boolean\n";
			pre_actions += "\treturn " + tttt + "\n";
			pre_actions += "endfunction\n\n";

			output += "function " + function_name;
		} else if (type == "code") {
			const std::string function_name = generate_function_name(trigger_name);

			std::string tttt = resolve_parameter(parameters[k], trigger_name, pre_actions, type);

			pre_actions += "function " + function_name + " takes nothing returns nothing\n";
			pre_actions += "\tcall " + tttt + "\n";
			pre_actions += "endfunction\n\n";

			output += "function " + function_name;
		} else {
			output += resolve_parameter(i, trigger_name, pre_actions, type);
		}

		if (k < parameters.size() - 1) {
			output += ", ";
		}
	}

	return (add_call ? "call " : "") + (script_name.empty() ? parent_name : script_name) + "(" + output + ")";
}

std::string Triggers::resolve_parameter(const TriggerParameter& parameter, const std::string& trigger_name, std::string& pre_actions, const std::string& type, bool add_call) const {
	if (parameter.has_sub_parameter) {
		return testt(trigger_name, parameter.sub_parameter.name, parameter.sub_parameter.parameters, pre_actions, add_call);
	} else {
		switch (parameter.type) {
			case TriggerParameter::Type::invalid:
				fmt::print("Invalid parameter type\n");
				return "";
			case TriggerParameter::Type::preset: {
				const std::string preset_type = trigger_data.data("TriggerParams", parameter.value, 1);

				if (get_base_type(preset_type) == "string") {
					return string_replaced(trigger_data.data("TriggerParams", parameter.value, 2), "`", "\"");
				}

				return trigger_data.data("TriggerParams", parameter.value, 2);
			}
			case TriggerParameter::Type::function:
				return parameter.value + "()";
			case TriggerParameter::Type::variable: {
				std::string output = parameter.value;
				
				if (!output.starts_with("gg_")) {
					output = "udg_" + output;
				}

				if (parameter.is_array) {
					output += "[" + resolve_parameter(parameter.parameters[0], trigger_name, pre_actions, "integer") + "]";
				}
				return output;
			}
			case TriggerParameter::Type::string:
				std::string import_type = trigger_data.data("TriggerTypes", type, 5);

				if (!import_type.empty()) {
					return "\"" + string_replaced(parameter.value, "\\", "\\\\") + "\"";
				} else if (get_base_type(type) == "string") {
					return "\"" + parameter.value + "\"";
				} else if (type == "abilcode" || // ToDo this seems like a hack?
					type == "buffcode" ||
					type == "destructablecode" ||
					type == "itemcode" ||
					type == "ordercode" ||
					type == "techcode" ||
					type == "unitcode" ||
					type == "heroskillcode" ||
					type == "weathereffectcode" || 
					type == "timedlifebuffcode" ||
					type == "doodadcode") {
					return "'" + parameter.value + "'";
				} else {
					return parameter.value;
				}
		}
	}
	fmt::print("Unable to resolve parameter for trigger: {} and parameter value {}\n", trigger_name, parameter.value);
	return "";
}

std::string Triggers::get_base_type(const std::string& type) const {
	std::string base_type = trigger_data.data("TriggerTypes", type, 4);

	if (base_type.empty()) {
		return type;
	}

	return base_type;
}

std::string Triggers::get_type(const std::string& function_name, int parameter) const {
	std::string type;

	if (trigger_data.key_exists("TriggerActions", function_name)) {
		type = trigger_data.data("TriggerActions", function_name, 1 + parameter);
	} else if (trigger_data.key_exists("TriggerCalls", function_name)) {
		type = trigger_data.data("TriggerCalls", function_name, 3 + parameter);
	} else if (trigger_data.key_exists("TriggerEvents", function_name)) {
		type = trigger_data.data("TriggerEvents", function_name, 1 + parameter);
	} else if (trigger_data.key_exists("TriggerConditions", function_name)) {
		type = trigger_data.data("TriggerConditions", function_name, 1 + parameter);
	}
	return type;
}

std::string Triggers::generate_function_name(const std::string& trigger_name) const {
	auto time = std::chrono::high_resolution_clock::now().time_since_epoch().count();
	return "Trig_" + trigger_name + "_" + std::to_string(time & 0xFFFFFFFF);
}

std::string Triggers::convert_gui_to_jass(const Trigger& trigger, std::vector<std::string>& map_initializations) const {
	std::string trigger_name = trigger.name;
	trim(trigger_name);
	std::replace(trigger_name.begin(), trigger_name.end(), ' ', '_');

	std::string trigger_variable_name = "gg_trg_" + trigger_name;
	std::string trigger_action_name = "Trig_" + trigger_name + "_Actions";

	std::string events;
	std::string conditions;
	std::string pre_actions;
	std::string actions;

	events += "function InitTrig_" + trigger_name + " takes nothing returns nothing\n";
	events += "\tset " + trigger_variable_name + " = CreateTrigger()\n";

	actions += "function " + trigger_action_name + " takes nothing returns nothing\n";

	for (const auto& i : trigger.ecas) {
		if (!i.enabled) {
			continue;
		}

		switch (i.type) {
			case ECA::Type::event:
				if (i.name == "MapInitializationEvent") {
					map_initializations.push_back(trigger_variable_name);
					continue;
				}
				events += "\tcall " + i.name + "(" + trigger_variable_name + ", ";
				for (size_t k = 0; k < i.parameters.size(); k++) {
					const auto& p = i.parameters[k];

					if (get_type(i.name, k) == "VarAsString_Real") {
						events += "\"" + resolve_parameter(p, trigger_name, pre_actions, get_type(i.name, k)) + "\"";
					} else {
						events += resolve_parameter(p, trigger_name, pre_actions, get_type(i.name, k));
					}

					if (k < i.parameters.size() - 1) {
						events += ", ";
					}
				}
				events += ")\n";

				break;
			case ECA::Type::condition:
				conditions += "\tif (not (" + convert_eca_to_jass(i, pre_actions, trigger_name, true) + ")) then\n";
				conditions += "\treturn false\n";
				conditions += "\tendif\n";
				break;
			case ECA::Type::action:
				actions += "\t" + convert_eca_to_jass(i, pre_actions, trigger_name, false) + "\n";
				break;
		}
	}

	actions += "endfunction\n\n";

	if (!conditions.empty()) {
		conditions = "function Trig_" + trigger_name + "_Conditions takes nothing returns boolean\n" + conditions;
		conditions += "\treturn true\n";
		conditions += "endfunction\n\n";

		events += "\tcall TriggerAddCondition(" + trigger_variable_name + ", Condition(function Trig_" + trigger_name + "_Conditions))\n";
	}

	if (!trigger.initially_on) {
		events += "\tcall DisableTrigger(" + trigger_variable_name + ")\n";
	}
	events += "\tcall TriggerAddAction(" + trigger_variable_name + ", function " + trigger_action_name + ")\n";
	events += "endfunction\n\n";

	return separator + "// Trigger: " + trigger_name + "\n" + separator + pre_actions + conditions + actions + separator + events;
}
```

`src/Base/Triggers.h`:

```h
#pragma once

#include <QString>
#include <unordered_map>
#include <INI.h>

import BinaryReader;
import BinaryWriter;

enum class Classifier
{
	map = 1,
	library = 2,
	category = 4,
	gui = 8,
	comment = 16,
	script = 32,
	variable = 64
};

struct TriggerCategory {
	Classifier classifier;
	int id;
	std::string name;
	bool open_state = true;
	bool is_comment = false;
	int parent_id;
};

struct TriggerParameter;

struct TriggerSubParameter {
	enum class Type {
		events,
		conditions,
		actions,
		calls
	};
	Type type;
	std::string name;
	bool begin_parameters;
	std::vector<TriggerParameter> parameters;
};

struct TriggerParameter {
	enum class Type {
		invalid = -1,
		preset,
		variable,
		function,
		string
	};
	Type type;
	int unknown;
	std::string value;
	bool has_sub_parameter;
	TriggerSubParameter sub_parameter;
	bool is_array = false;
	std::vector<TriggerParameter> parameters; // There is really only one so unique_ptr I guess
};

struct ECA {
	enum class Type {
		event,
		condition,
		action
	};

	Type type;
	int group;
	std::string name;
	bool enabled;
	std::vector<TriggerParameter> parameters;
	std::vector<ECA> ecas;
};

struct Trigger {
	Classifier classifier;
	int id;
	int parent_id = 0;
	std::string name;
	std::string description;
	std::string custom_text;
	bool is_comment = false;
	bool is_enabled = true;
	bool is_script = false;
	bool initially_on = true;
	bool run_on_initialization = false;
	std::vector<ECA> ecas;

	static inline int next_id = 0;
};

struct TriggerVariable {
	std::string name;
	std::string type;
	uint32_t unknown;
	bool is_array;
	int array_size = 0;
	bool is_initialized;
	std::string initial_value;
	int id;
	int parent_id;
};

class Triggers {
	std::unordered_map<std::string, int> argument_counts;
	const std::string separator = "//===========================================================================\n";

	static constexpr int write_version = 0x80000004;
	static constexpr int write_sub_version = 7;
	static constexpr int write_string_version = 1;

	int unknown1 = 0;
	int unknown2 = 0;
	int trig_def_ver = 2;

	void parse_parameter_structure(BinaryReader& reader, TriggerParameter& parameter, uint32_t version);
	void parse_eca_structure(BinaryReader& reader, ECA& eca, bool is_child, uint32_t version);

	void print_parameter_structure(BinaryWriter& writer, const TriggerParameter& parameter) const;
	void print_eca_structure(BinaryWriter& writer, const ECA& eca, bool is_child) const;

	std::string convert_eca_to_jass(const ECA& lines, std::string& pre_actions, const std::string& trigger_name, bool nested) const;
	std::string testt(const std::string& trigger_name, const std::string& parent_name, const std::vector<TriggerParameter>& parameters, std::string& pre_actions, bool add_call) const;
	std::string resolve_parameter(const TriggerParameter& parameter, const std::string& trigger_name, std::string& pre_actions, const std::string& base_type, bool add_call = false) const;
	std::string get_base_type(const std::string& type) const;
	std::string get_type(const std::string& function_name, int parameter) const;
	std::string generate_function_name(const std::string& trigger_name) const;
	std::string convert_gui_to_jass(const Trigger& trigger, std::vector<std::string>& initialization_triggers) const;

	void generate_global_variables(BinaryWriter& writer, std::unordered_map<std::string, std::string>& unit_variables, std::unordered_map<std::string, std::string>& destructable_variables);
	void generate_init_global_variables(BinaryWriter& writer);
	void generate_units(BinaryWriter& writer, std::unordered_map<std::string, std::string>& unit_variables);
	void generate_items(BinaryWriter& writer);
	void generate_destructables(BinaryWriter& writer, std::unordered_map<std::string, std::string>& destructable_variables);
	void generate_regions(BinaryWriter& writer);
	void generate_cameras(BinaryWriter& writer);
	void generate_sounds(BinaryWriter& writer);
	void write_item_table_entry(BinaryWriter& writer, int chance, const std::string& id);
	void generate_item_tables(BinaryWriter& writer);
	void generate_unit_item_tables(BinaryWriter& writer);
	void generate_trigger_initialization(BinaryWriter& writer, std::vector<std::string> initialization_triggers);
	void generate_players(BinaryWriter& writer);
	void generate_custom_teams(BinaryWriter& writer);
	void generate_ally_priorities(BinaryWriter& writer);
	void generate_main(BinaryWriter& writer);
	void generate_map_configuration(BinaryWriter& writer);
public:
	ini::INI trigger_strings;
	ini::INI trigger_data;

	std::string global_jass_comment;
	std::string global_jass;

	std::vector<TriggerCategory> categories;
	std::vector<TriggerVariable> variables;
	std::vector<Trigger> triggers;

	void load();
	void load_version_31(BinaryReader& reader, uint32_t version);
	void load_version_pre31(BinaryReader& reader, uint32_t version);
	void load_jass();
	void save() const;
	void save_jass() const;

	// Returns compile output which could contain errors or general information
	QString generate_map_script();
};
```

`src/Base/Units.cpp`:

```cpp
#include "Units.h"

#include <iostream>
using namespace std::literals::string_literals;

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "Globals.h"
import BinaryWriter;
import Hierarchy;


void Unit::update() {
	const float model_scale = units_slk.data<float>("modelscale", id);
	const float move_height = units_slk.data<float>("moveheight", id);

	const glm::vec3 final_position = position + glm::vec3(0.f, 0.f, move_height / 128.f);
	const glm::vec3 final_scale = glm::vec3(model_scale / 128.f);
	
	matrix = glm::translate(glm::mat4(1.f), final_position);
	matrix = glm::scale(matrix, final_scale);
	matrix = glm::rotate(matrix, angle, glm::vec3(0, 0, 1));

	skeleton.update_location(final_position, angle, final_scale);

	color.r = units_slk.data<float>("red", id) / 255.f;
	color.g = units_slk.data<float>("green", id) / 255.f;
	color.b = units_slk.data<float>("blue", id) / 255.f;
}

void Units::load() {
	BinaryReader reader = hierarchy.map_file_read("war3mapUnits.doo");

	const std::string magic_number = reader.read_string(4);
	if (magic_number != "W3do") {
		std::cout << "Invalid war3mapUnits.w3e file: Magic number is not W3do\n";
	}
	const uint32_t version = reader.read<uint32_t>();
	if (version != 7 && version != 8) {
		std::cout << "Unknown war3mapUnits.doo version: " << version << " Attempting to load but may crash\nPlease send this map to eejin\n";
	}

	// Subversion
	const int subversion = reader.read<uint32_t>();
	if (subversion != 9 && subversion != 11) {
		std::cout << "Unknown war3mapUnits.doo subversion: " << subversion << " Attempting to load but may crash\nPlease send this map to eejin\n";
	}

	const int unit_count = reader.read<uint32_t>();
	for (int k = 0; k < unit_count; k++) {
		Unit i;
		i.id = reader.read_string(4);
		i.variation = reader.read<uint32_t>();
		i.position = (reader.read<glm::vec3>() - glm::vec3(map->terrain.offset, 0)) / 128.f;
		i.angle = reader.read<float>();
		i.scale = reader.read<glm::vec3>() / 128.f;

		if (map->info.game_version_major * 100 + map->info.game_version_minor >= 132) {
			i.skin_id = reader.read_string(4);
		} else {
			i.skin_id = i.id;
		}

		i.flags = reader.read<uint8_t>();

		i.player = reader.read<uint32_t>();
		if (i.player > 11 && map->info.editor_version < 6061) {
			i.player += 12;
		}

		i.unknown1 = reader.read<uint8_t>();
		i.unknown2 = reader.read<uint8_t>();

		i.health = reader.read<uint32_t>();
		i.mana = reader.read<uint32_t>();

		if (subversion >= 11) {
			i.item_table_pointer = reader.read<uint32_t>();
		}

		i.item_sets.resize(reader.read<uint32_t>());
		for (auto&& j : i.item_sets) {
			j.items.resize(reader.read<uint32_t>());
			for (auto&&[id, chance] : j.items) {
				id = reader.read_string(4);
				chance = reader.read<uint32_t>();
			}
		}

		i.gold = reader.read<uint32_t>();
		i.target_acquisition = reader.read<float>();

		i.level = reader.read<uint32_t>();

		if (subversion >= 11) {
			i.strength = reader.read<uint32_t>();
			i.agility = reader.read<uint32_t>();
			i.intelligence = reader.read<uint32_t>();
		}

		i.items.resize(reader.read<uint32_t>());
		for (auto&& [slot, id] : i.items) {
			slot = reader.read<uint32_t>();
			id = reader.read_string(4);
		}

		i.abilities.resize(reader.read<uint32_t>());
		for (auto&&[id, autocast, level] : i.abilities) {
			id = reader.read_string(4);
			autocast = reader.read<uint32_t>();
			level =  reader.read<uint32_t>();
		}

		i.random_type = reader.read<uint32_t>();
		switch (i.random_type) {
			case 0:
				i.random = reader.read_vector<uint8_t>(4);
				break;
			case 1:
				i.random = reader.read_vector<uint8_t>(8);
				break;
			case 2:
				i.random = reader.read_vector<uint8_t>(reader.read<uint32_t>() * 8);
				break;
		}

		i.custom_color = reader.read<uint32_t>();
		i.waygate = reader.read<uint32_t>();
		i.creation_number = reader.read<uint32_t>();

		// Either a unit or an item
		if (units_slk.row_headers.contains(i.id) || i.id == "sloc" || i.id == "uDNR" || i.id == "bDNR") {
			units.push_back(i);
		} else {
			items.push_back(i);
		}

		Unit::auto_increment = std::max(Unit::auto_increment, i.creation_number);
	}
}

void Units::save() const {
	BinaryWriter writer;

	writer.write_string("W3do");
	writer.write<uint32_t>(write_version);
	writer.write<uint32_t>(write_subversion);

	writer.write<uint32_t>(units.size() + items.size());

	auto write_units = [&](const std::vector<Unit>& to_write) {
		for (auto&& i : to_write) {
			writer.write_string(i.id);
			writer.write<uint32_t>(i.variation);
			writer.write<glm::vec3>(i.position * 128.f + glm::vec3(map->terrain.offset, 0));
			writer.write<float>(i.angle);
			writer.write<glm::vec3>(i.scale * 128.f);

			writer.write_string(i.skin_id);

			writer.write<uint8_t>(i.flags);

			writer.write<uint32_t>(i.player);

			writer.write<uint8_t>(i.unknown1);
			writer.write<uint8_t>(i.unknown2);

			writer.write<uint32_t>(i.health);
			writer.write<uint32_t>(i.mana);

			writer.write<uint32_t>(i.item_table_pointer);

			writer.write<uint32_t>(i.item_sets.size());
			for (auto&& j : i.item_sets) {
				writer.write<uint32_t>(j.items.size());
				for (auto&&[id, chance] : j.items) {
					writer.write_string(id);
					writer.write<uint32_t>(chance);
				}
			}

			writer.write<uint32_t>(i.gold);
			writer.write<float>(i.target_acquisition);
			writer.write<uint32_t>(i.level);
			writer.write<uint32_t>(i.strength);
			writer.write<uint32_t>(i.agility);
			writer.write<uint32_t>(i.intelligence);


			writer.write<uint32_t>(i.items.size());
			for (auto&&[slot, id] : i.items) {
				writer.write<uint32_t>(slot);
				writer.write_string(id);
			}

			writer.write<uint32_t>(i.abilities.size());
			for (auto&&[id, autocast, level] : i.abilities) {
				writer.write_string(id);
				writer.write<uint32_t>(autocast);
				writer.write<uint32_t>(level);
			}

			writer.write<uint32_t>(i.random_type);
			writer.write_vector(i.random);

			writer.write<uint32_t>(i.custom_color);
			writer.write<uint32_t>(i.waygate);
			writer.write<uint32_t>(i.creation_number);
		}
	};

	write_units(units);
	write_units(items);

	hierarchy.map_file_write("war3mapUnits.doo", writer.buffer);
}

void Units::update_area(const QRect& area) {
	for (auto&& i : query_area(area)) {
		i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y);
		i->update();
	}
}

void Units::create() {
	for (auto& i : units) {
		// ToDo handle starting location
		if (i.id == "sloc") {
			continue;
		}

		i.mesh = get_mesh(i.id);
		i.skeleton = SkeletalModelInstance(i.mesh->model);
		i.update();
	}	

	for (auto& i : items) {
		i.scale = glm::vec3(std::stof(items_slk.data("scale", i.id)));

		i.mesh = get_mesh(i.id);
		i.skeleton = SkeletalModelInstance(i.mesh->model);
		i.update();
	}
}

void Units::render() {
	for (auto& i : units) {
		if (i.id == "sloc") {
			continue;
		} // ToDo handle starting locations

		i.mesh->render_queue(i.skeleton, i.color);
	}
	for (auto& i : items) {
		i.mesh->render_queue(i.skeleton, i.color);
	}
}

// Will assign a unique creation number
Unit& Units::add_unit(std::string id, glm::vec3 position) {
	// ToDo change this once SkeletalModelInstance doesn't use pointers anymore
	units.push_back(Unit());
	Unit& unit = units.back();
	unit.id = id;
	unit.skin_id = id;
	unit.mesh = get_mesh(id);
	unit.position = position;
	unit.scale = glm::vec3(1.f);
	unit.angle = 0.f;
	unit.random = { 1, 0, 0, 0 };
	unit.creation_number = ++Unit::auto_increment;
	unit.skeleton = SkeletalModelInstance(unit.mesh->model);
	unit.update();

	return units.back();
}

// Assumes you will set a unique creation number yourself
Unit& Units::add_unit(Unit unit) {
	units.push_back(unit);
	return units.back();
}

void Units::remove_unit(Unit* unit) {
	auto iterator = units.begin() + std::distance(units.data(), unit);
	units.erase(iterator);
}

std::vector<Unit*> Units::query_area(const QRectF& area) {
	std::vector<Unit*> result;

	for (auto& i : units) {
		if (area.contains(i.position.x, i.position.y) && i.id != "sloc") {
			result.push_back(&i);
		}
	}
	return result;
}

void Units::remove_units(const std::vector<Unit*>& list) {
	std::erase_if(units, [&](Unit& unit) { return std::find(list.begin(), list.end(), &unit) != list.end(); });
}

void Units::process_field_change(const std::string& id, const std::string& field) {
	if (field == "file") {
		if (id_to_mesh.contains(id)) {
			id_to_mesh.erase(id_to_mesh.find(id));
			for (auto& i : units) {
				if (i.id == id) {
					i.mesh = get_mesh(id);
					i.skeleton = SkeletalModelInstance(i.mesh->model);
					i.update();
				}
			}
		}
	}
	if (field == "modelscale" || field == "moveheight" || field == "red" || field == "green" || field == "blue") {
		for (auto& i : units) {
			if (i.id == id) {
				i.update();
			}
		}
	}
}

std::shared_ptr<SkinnedMesh> Units::get_mesh(const std::string& id) {
	if (id_to_mesh.find(id) != id_to_mesh.end()) {
		return id_to_mesh[id];
	}

	fs::path mesh_path = units_slk.data("file", id);
	if (mesh_path.empty()) {
		mesh_path = items_slk.data("file", id);
	}
	mesh_path.replace_extension(".mdx");

	mesh_path = fs::path(string_replaced(mesh_path.string(), "\\", "/"));

	// Mesh doesnt exist at all
	if (!hierarchy.file_exists(mesh_path)) {
		std::cout << "Invalid model file for " << id << " With file path: " << mesh_path << "\n";
		id_to_mesh.emplace(id, resource_manager.load<SkinnedMesh>("Objects/Invalidmodel/Invalidmodel.mdx", "", std::nullopt));
		return id_to_mesh[id];
	}

	id_to_mesh.emplace(id, resource_manager.load<SkinnedMesh>(mesh_path, "", std::nullopt));

	return id_to_mesh[id];
}

void UnitAddAction::undo() {
	map->units.units.resize(map->units.units.size() - units.size());
}

void UnitAddAction::redo() {
	map->units.units.insert(map->units.units.end(), units.begin(), units.end());
}

void UnitDeleteAction::undo() {
	if (map->brush) {
		map->brush->clear_selection();
	}

	map->units.units.insert(map->units.units.end(), units.begin(), units.end());
}

void UnitDeleteAction::redo() {
	if (map->brush) {
		map->brush->clear_selection();
	}

	map->units.units.resize(map->units.units.size() - units.size());
}

void UnitStateAction::undo() {
	for (auto& i : old_units) {
		for (auto& j : map->units.units) {
			if (i.creation_number == j.creation_number) {
				j = i;
			}
		}
	}
}

void UnitStateAction::redo() {
	for (auto& i : new_units) {
		for (auto& j : map->units.units) {
			if (i.creation_number == j.creation_number) {
				j = i;
			}
		}
	}
}

```

`src/Base/Units.h`:

```h
#pragma once

#include <vector>
#include <unordered_map>
#include <memory>

import BinaryReader;
#include "SkinnedMesh.h"
#include "Terrain.h"
#include <SkeletalModelInstance.h>

struct Unit {
	static inline int auto_increment;

	std::string id;
	int variation = 0;
	glm::vec3 position;
	float angle;
	glm::vec3 scale;

	std::string skin_id;

	uint8_t flags = 2;
	int player = 0;

	uint8_t unknown1 = 0;
	uint8_t unknown2 = 0;
	int health = -1;
	int mana = -1;

	int item_table_pointer = 0xFFFF;
	std::vector<ItemSet> item_sets;

	int gold = 12500;
	float target_acquisition = -1;

	int level = 1;
	int strength = 0;
	int agility = 0;
	int intelligence = 0;

	// Slot, ID
	std::vector<std::pair<uint32_t, std::string>> items;

	// ID, autocast, ability level
	std::vector<std::tuple<std::string, uint32_t, uint32_t>> abilities;

	int random_type = 0;
	std::vector<uint8_t> random;

	int custom_color = -1;
	int waygate = -1;
	int creation_number;

	glm::mat4 matrix = glm::mat4(1.f);
	SkeletalModelInstance skeleton;
	std::shared_ptr<SkinnedMesh> mesh;
	glm::vec3 color;

	Unit() {
		creation_number = ++auto_increment;
	}

	void update();
};

class Units : public QObject {
	Q_OBJECT

	std::unordered_map<std::string, std::shared_ptr<SkinnedMesh>> id_to_mesh;

	static constexpr int write_version = 8;
	static constexpr int write_subversion = 11;

	//static constexpr int mod_table_write_version = 2;
public:
	std::vector<Unit> units;
	std::vector<Unit> items;

	void load();
	void save() const;
	void update_area(const QRect& area);
	void create();
	void render();

	Unit& add_unit(std::string id, glm::vec3 position);
	Unit& add_unit(Unit unit);

	void remove_unit(Unit* unit);

	std::vector<Unit*> query_area(const QRectF& area);
	void remove_units(const std::vector<Unit*>& list);

	void process_field_change(const std::string& id, const std::string& field);

	std::shared_ptr<SkinnedMesh> get_mesh(const std::string& id);
};

// Undo/redo structures
class UnitAddAction : public TerrainUndoAction {
public:
	std::vector<Unit> units;

	void undo() override;
	void redo() override;
};

class UnitDeleteAction : public TerrainUndoAction {
public:
	std::vector<Unit> units;

	void undo() override;
	void redo() override;
};

class UnitStateAction : public TerrainUndoAction {
public:
	std::vector<Unit> old_units;
	std::vector<Unit> new_units;

	void undo() override;
	void redo() override;
};
```

`src/Base/WindowHandler.h`:

```h
#pragma once


class WindowHandler : public QObject {
	Q_OBJECT

public:
	std::vector<std::pair<std::string, QWidget*>> windows;

	/// Creates a window of type T if one doesn't exist yet. Otherwise it raises to the foreground and activates the window.
	template<typename T>
	T* create_or_raise(QWidget* parent, bool& created) {
		auto found = std::find_if(windows.begin(), windows.end(), [&](const auto& item) { return item.first == typeid(T).name(); });
		if (found != windows.end()) {
			T* window = dynamic_cast<T*>((*found).second);
			window->raise();
			window->activateWindow();
			created = false;
			return window;
		} else {
			T* window = new T(parent);
			windows.push_back(std::make_pair(typeid(T).name(), dynamic_cast<QWidget*>(window)));
			connect(window, &T::destroyed, [this, window]() { 
				auto found = std::find_if(windows.begin(), windows.end(), [&](const auto& item) { return item.second == window; });
				windows.erase(found);
			});
			created = true;
			return window;
		}
		return nullptr;
	}
};
```

`src/Base/no_init_allocator.ixx`:

```ixx
module;

#include <memory>

export module no_init_allocator;

export template <typename T, typename A = std::allocator<T>>
class default_init_allocator : public A {
	typedef std::allocator_traits<A> a_t;

  public:
	using A::A; // Inherit constructors from A

	template <typename U>
	struct rebind {
		using other = default_init_allocator<U, typename a_t::template rebind_alloc<U>>;
	};

	template <typename U>
	void construct(U* ptr) noexcept(std::is_nothrow_default_constructible<U>::value) {
		::new (static_cast<void*>(ptr)) U;
	}

	template <typename U, typename... Args>
	void construct(U* ptr, Args&&... args) {
		a_t::construct(static_cast<A&>(*this),
					   ptr, std::forward<Args>(args)...);
	}
};
```

`src/Brush/Brush.cpp`:

```cpp
#include "Brush.h"

#include "Camera.h"
#include "Globals.h"
#include "InputHandler.h"

Brush::Brush() {
	gl->glCreateTextures(GL_TEXTURE_2D, 1, &brush_texture);
	gl->glTextureParameteri(brush_texture, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	gl->glTextureParameteri(brush_texture, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	gl->glTextureParameteri(brush_texture, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(brush_texture, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	set_size(size);

	selection_shader = resource_manager.load<Shader>({ "Data/Shaders/selection.vs", "Data/Shaders/selection.fs" });
	selection_circle_shader = resource_manager.load<Shader>({ "Data/Shaders/selection_circle.vs", "Data/Shaders/selection_circle.fs" });
	brush_shader = resource_manager.load<Shader>({ "Data/Shaders/brush.vs", "Data/Shaders/brush.fs" });
}

void Brush::set_position(const glm::vec2& new_position) {
	const glm::vec2 center_position = new_position - size / 2.f * 0.25f + brush_offset;

	position = glm::floor(center_position);
	if (!uv_offset_locked) {
		glm::vec2 decimals = center_position - glm::vec2(position);

		switch (uv_offset_granularity) {
			case 1:
				uv_offset = { 0.f, 0.f };
				break;
			case 2:
				decimals *= 2.f;
				decimals = glm::floor(decimals);
				decimals *= 2.f;
				uv_offset = glm::abs(decimals);
				break;
			case 4:
				uv_offset = glm::abs(decimals * 4.f);
				break;
		}
	}
}

glm::vec2 Brush::get_position() const {
	return glm::vec2(position);
}

void Brush::set_size(const int new_size) {
	glm::vec2 center = glm::vec2(position) + size / 8.f + glm::vec2(uv_offset) * 0.25f;

	size = std::clamp(new_size * size_granularity, 1, 999);

	brush.clear();
	brush.resize(size * size, { 0, 0, 0, 0 });

	set_shape(shape);

	set_position(center);
}

void Brush::set_shape(const Shape new_shape) {
	shape = new_shape;

	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			if (contains(i / size_granularity, j / size_granularity)) {
				brush[j * size + i] = brush_color;
			} else {
				brush[j * size + i] = { 0, 0, 0, 0 };
			}
		}
	}

	gl->glBindTexture(GL_TEXTURE_2D, brush_texture);
	gl->glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, size, size, 0, GL_BGRA, GL_UNSIGNED_BYTE, brush.data());
}

/// Whether the brush shape contains the point, Arguments in brush coordinates
bool Brush::contains(const int x, const int y) const {
	switch (shape) {
		case Shape::square:
			return true;
		case Shape::circle: {
			int half_size = (size / 2) / size_granularity;
			int distance = (x - half_size) * (x - half_size);
			distance += (y - half_size) * (y - half_size);
			return distance <= half_size * half_size;
		}
		case Shape::diamond:
			int half_size = (size / 2) / size_granularity;

			return std::abs(x - half_size) + std::abs(y - half_size) <= half_size;
	}
	return true;
}

void Brush::increase_size(const int new_size) {
	set_size(size / size_granularity + new_size);
}
void Brush::decrease_size(const int new_size) {
	set_size(size / size_granularity - new_size);
}

void Brush::switch_mode() {
	if (mode != Mode::placement && mode != Mode::selection) {
		mode = return_mode;
	}
	mode = (mode == Mode::placement) ? Mode::selection : Mode::placement;

	clear_selection();
	selection_started = false;
}

void Brush::key_press_event(QKeyEvent* event) {
	switch (event->key()) {
		case Qt::Key_Escape:
			clear_selection();
			break;
		case Qt::Key_Equal:
			increase_size(2);
			break;
		case Qt::Key_Minus:
			decrease_size(2);
			break;
		case Qt::Key_Delete:
			delete_selection();
			break;
		case Qt::Key_X:
			if (event->modifiers() & Qt::ControlModifier) {
				cut_selection();
			}
			break;
		case Qt::Key_C:
			if (event->modifiers() & Qt::ControlModifier) {
				copy_selection();
			}
			break;
		case Qt::Key_V:
			if (event->modifiers() & Qt::ControlModifier) {
				return_mode = mode;
				mode = Mode::pasting;
			}
			break;
	}
}

void Brush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	set_position(input_handler.mouse_world);

	if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::placement && (can_place() || event->modifiers() & Qt::ShiftModifier)) {
			apply(frame_delta);
		}
	}
}

void Brush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	if (event->button() != Qt::LeftButton) {
		return;
	}

	if (!event->modifiers()) {
		clear_selection();
	}

	if (mode == Mode::selection && !(event->modifiers() & Qt::ControlModifier)) {
		if (!selection_started) {
			selection_started = true;
			selection_start = input_handler.mouse_world;
		}
	} else if (mode == Mode::placement) {
		// Check if ellegible for placement
		if (event->button() == Qt::LeftButton) {
			apply_begin();
			if (can_place() || event->modifiers() & Qt::ShiftModifier) {
				apply(0.5);
			}
		}
	} else if (mode == Mode::pasting && (can_place() || event->modifiers() & Qt::ShiftModifier)) {
		clear_selection();
		place_clipboard();
		mode = Mode::selection;
	}
}

void Brush::mouse_release_event(QMouseEvent* event) {
	if (mode == Mode::selection) {
		selection_started = false;
	} else if (mode == Mode::placement) {
		if (event->button() == Qt::LeftButton) {
			apply_end();
		}
	}
}

void Brush::render() {
	if (mode == Mode::selection) {
		render_selector();
	} 
	if (mode == Mode::placement) {
		render_brush();
	}
	if (mode == Mode::pasting) {
		render_clipboard();
	}
	render_selection();
}

void Brush::render_selector() const {
	if (selection_started) {
		gl->glDisable(GL_DEPTH_TEST);

		selection_shader->use();

		glm::mat4 model(1.f);
		model = glm::translate(model, glm::vec3(selection_start, map->terrain.interpolated_height(selection_start.x, selection_start.y)));
		model = glm::scale(model, glm::vec3(glm::vec2(input_handler.mouse_world), 1.f) - glm::vec3(selection_start, 1.f));
		model = camera->projection_view * model;
		gl->glUniformMatrix4fv(1, 1, GL_FALSE, &model[0][0]);

		gl->glEnableVertexAttribArray(0);
		gl->glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
		gl->glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		gl->glDrawArrays(GL_LINE_LOOP, 0, 4);

		gl->glDisableVertexAttribArray(0);
		gl->glEnable(GL_DEPTH_TEST);
	}
}

void Brush::render_brush() {
	gl->glDisable(GL_DEPTH_TEST);

	brush_shader->use();

	const int cells = std::ceil(size / 4.f) + 1;

	gl->glUniformMatrix4fv(1, 1, GL_FALSE, &camera->projection_view[0][0]);
	gl->glUniform2f(2, position.x, position.y);
	gl->glUniform2f(3, uv_offset.x, uv_offset.y);
	gl->glUniform1i(4, cells);

	gl->glBindTextureUnit(0, map->terrain.ground_corner_height);
	gl->glBindTextureUnit(1, brush_texture);

	gl->glEnableVertexAttribArray(0);
	gl->glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
	gl->glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
	gl->glDrawElementsInstanced(GL_TRIANGLES, shapes.quad_indices.size() * 3, GL_UNSIGNED_INT, nullptr, cells * cells);

	gl->glDisableVertexAttribArray(0);
	gl->glEnable(GL_DEPTH_TEST);
}
```

`src/Brush/Brush.h`:

```h
#pragma once

#include <QMouseEvent>
#include <QKeyEvent>
#include <QOpenGLFunctions_4_5_Core>


#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

#include "Shader.h"

class Brush : public QObject {
	Q_OBJECT

public:
	enum class Shape {
		square,
		circle,
		diamond
	};

	enum class Mode {
		placement,
		selection,
		pasting
	};

	bool uv_offset_locked = false;
	glm::ivec2 uv_offset = { 0, 0 };
	int size_granularity = 1;
	int uv_offset_granularity = 4;

	glm::vec2 brush_offset = { 0, 0 };

	glm::vec4 brush_color = { 0, 255, 0, 128 };

	Brush();

	virtual void set_position(const glm::vec2& position);
	virtual glm::vec2 get_position() const;
	virtual void set_size(int size);
	virtual void set_shape(Shape shape);
	virtual void increase_size(int size);
	virtual void decrease_size(int size);
	virtual bool contains(int x, int y) const;

	virtual void switch_mode();

	virtual void key_press_event(QKeyEvent* event);
	virtual void key_release_event(QKeyEvent* event) {}
	virtual void mouse_move_event(QMouseEvent* event, double frame_delta);
	virtual void mouse_press_event(QMouseEvent* event, double frame_delta);
	virtual void mouse_release_event(QMouseEvent* event);

	virtual void delete_selection() {};
	virtual void copy_selection() {};
	virtual void cut_selection() {};
	virtual void clear_selection() {};
	virtual void place_clipboard() {};

	virtual void clear_clipboard() {};
	
	void render();
	virtual void render_selector() const;
	virtual void render_selection() const {};
	virtual void render_clipboard() {}
	virtual void render_brush();

	virtual bool can_place() {
		return true;
	};
	virtual void apply_begin() {};
	virtual void apply(double frame_delta) = 0;
	virtual void apply_end() {};
protected:
	Shape shape = Shape::circle;
	Mode mode = Mode::placement;
	Mode return_mode = Mode::placement;

	int size = 1;
	glm::ivec2 position;

	bool selection_started = false;
	glm::vec2 selection_start;

	std::vector<glm::u8vec4> brush;
	GLuint brush_texture;

	std::shared_ptr<Shader> selection_shader;
	std::shared_ptr<Shader> selection_circle_shader;
	std::shared_ptr<Shader> brush_shader;
};
```

`src/Brush/DoodadBrush.cpp`:

```cpp
#include "DoodadBrush.h"

#include <random>
#include <memory>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "InputHandler.h"
#include "TerrainUndo.h"
#include "Globals.h"
import Hierarchy;
import Texture;

DoodadBrush::DoodadBrush() : Brush() {
	uv_offset_granularity = 2;
	brush_offset = { 0.25f , 0.25f };
}

/// Gets a random variation from the possible_variation list
int DoodadBrush::get_random_variation() {
	if (possible_variations.size() == 0) {
		return 0;
	}

	std::mt19937 rng;
	rng.seed(std::random_device()());
	std::uniform_int_distribution<std::mt19937::result_type> dist(0, possible_variations.size() - 1);

	auto it = possible_variations.begin();
	std::advance(it, dist(rng));
	return *it;
}

void DoodadBrush::set_shape(const Shape new_shape) {
	shape = new_shape;

	if (pathing_texture) {
		const int div_w = (((int)glm::degrees(rotation) + 90) % 180) ? pathing_texture->height : pathing_texture->width;
		const int div_h = (((int)glm::degrees(rotation) + 90) % 180) ? pathing_texture->width : pathing_texture->height;

		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				brush[j * size + i] = { 0, 0, 0, 0 };
			}
		}

		for (int i = 0; i < pathing_texture->width; i++) {
			for (int j = 0; j < pathing_texture->height; j++) {
				int x = i;
				int y = j;

				switch (((int)glm::degrees(rotation) + 90) % 360) {
					case 90:
						x = pathing_texture->height - 1 - j;
						y = i;
						break;
					case 180:
						x = pathing_texture->width - 1 - i;
						y = pathing_texture->height - 1 - j;
						break;
					case 270:
						x = j;
						y = pathing_texture->width - 1 - i;
						break;
				}

				const int in = ((pathing_texture->height - 1 - j) * pathing_texture->width + i) * pathing_texture->channels;
				const int index = (y + std::max(0, div_w - div_h) / 2) * size + x + std::max(0, div_h - div_w) / 2;

				// Have to check for > 250 because sometimes the pathing textures are not properly thresholded
				glm::vec4 color = { pathing_texture->data[in + 2] > 250 ? 255 : 0,
					pathing_texture->data[in + 1] > 250 ? 255 : 0,
					pathing_texture->data[in] > 250 ? 255 : 0,
					128 };

				if (color.r || color.g || color.b) {
					brush[index] = color;
				}
			}
		}
	}

	gl->glBindTexture(GL_TEXTURE_2D, brush_texture);
	gl->glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, size, size, 0, GL_BGRA, GL_UNSIGNED_BYTE, brush.data());
}

void DoodadBrush::key_press_event(QKeyEvent* event) {
	if (event->modifiers() & Qt::KeypadModifier) {
		if (action == Action::none) {
			start_action(Action::move);
		}

		bool left = event->key() == Qt::Key_1 || event->key() == Qt::Key_4 || event->key() == Qt::Key_7;
		bool right = event->key() == Qt::Key_3 || event->key() == Qt::Key_6 || event->key() == Qt::Key_9;
		bool down = event->key() == Qt::Key_7 || event->key() == Qt::Key_8 || event->key() == Qt::Key_9;
		bool up = event->key() == Qt::Key_1 || event->key() == Qt::Key_2 || event->key() == Qt::Key_3;

		bool free_movement = true;
		for (const auto& i : selections) {
			free_movement = free_movement && !i->pathing;
		}

		float x_displacement;
		float y_displacement;
		if (free_movement) {
			x_displacement = -0.25f * left + 0.25f * right;
			y_displacement = -0.25f * up + 0.25f * down;
		} else {
			x_displacement = -0.5f * left + 0.5f * right;
			y_displacement = -0.5f * up + 0.5f * down;	
		}

		for (const auto& i : selections) {
			i->position.x += x_displacement;
			i->position.y += y_displacement;
			if (!lock_doodad_z) {
				i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y);
			}
			i->update();
		}
		emit position_changed();

		map->doodads.update_doodad_pathing(selections);
	}

	if (event->modifiers() & Qt::ControlModifier) {
		switch (event->key()) {
			case Qt::Key_A:
				selections.clear();
				selections.reserve(map->doodads.doodads.size());
				for (auto& i : map->doodads.doodads) {
					selections.push_back(&i);
				}

				emit selection_changed();
				break;
			case Qt::Key_PageUp:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->position.z += 0.1f;
					i->update();
				}
				emit position_changed();
				break;
			case Qt::Key_PageDown:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->position.z -= 0.1f;
					i->update();
				}
				emit position_changed();
				break;
			default:
				Brush::key_press_event(event);
		}
	} else {
		switch (event->key()) {
			case Qt::Key_PageUp:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->scale.z += 0.1f;
					i->update();
				}
				emit scale_changed();
				break;
			case Qt::Key_PageDown:
				if (action == Action::none) {
					start_action(Action::move);
				}
				for (const auto& i : selections) {
					i->scale.z -= 0.1f;
					i->update();
				}
				emit scale_changed();
				break;
			default:
				Brush::key_press_event(event);
		}
	}
}

void DoodadBrush::key_release_event(QKeyEvent* event) {
	if (event->isAutoRepeat()) {
		return;
	}
		
	if (action == Action::move) {
		end_action();
	}
}

void DoodadBrush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	// The mouse.y check is needed as sometimes it is negative for unknown reasons
	if (event->button() == Qt::LeftButton && mode == Mode::selection && !event->modifiers() && input_handler.mouse.y > 0.f) {
		auto id = map->render_manager.pick_doodad_id_under_mouse(input_handler.mouse);
		if (id) {
			Doodad& doodad = map->doodads.doodads[id.value()];

			drag_start = input_handler.mouse_world;
			dragging = true;

			// If the current index is already in a selection then we want to drag the entire group
			if (std::find(selections.begin(), selections.end(), &doodad) != selections.end()) {
				drag_offsets.clear();
				for (const auto& i : selections) {
					drag_offsets.push_back(input_handler.mouse_world - i->position);
				}
			} else {
				selections = { &doodad };
				drag_offsets = { input_handler.mouse_world - doodad.position };
				emit selection_changed();
			}
			return;
		}
	}
	Brush::mouse_press_event(event, frame_delta);
}

void DoodadBrush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	Brush::mouse_move_event(event, frame_delta);

	if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::selection) {
			if (dragging) {
				if (action == Action::none) {
					start_action(Action::drag);
				}

				bool free_movement = true;
				for (const auto& i : selections) {
					free_movement = free_movement && !i->pathing;
				}

				glm::vec3 offset;
				if (free_movement) {
					offset = input_handler.mouse_world - drag_start;
				} else {
					offset = glm::round((input_handler.mouse_world) * 2.f + 0.5f) / 2.f - 0.25f;
					offset -= glm::round((drag_start) * 2.f + 0.5f) / 2.f - 0.25f;
				}
				offset.z = 0;

				if (!free_movement && offset.x == 0.f && offset.y == 0.f) {
					return;
				}
				drag_start = input_handler.mouse_world;

				for (size_t i = 0; i < selections.size(); i++) {
					Doodad* doodad = selections[i];
					doodad->position += offset;
					if (!lock_doodad_z) {
						doodad->position.z = map->terrain.interpolated_height(doodad->position.x, doodad->position.y);
					}
					doodad->update();
				}
				emit position_changed();
				map->doodads.update_doodad_pathing(selections);
			} else if (event->modifiers() & Qt::ControlModifier) {
				if (action == Action::none) {
					start_action(Action::rotate);
				}

				for (auto&& i : selections) {
					float target_rotation = std::atan2(input_handler.mouse_world.y - i->position.y, input_handler.mouse_world.x - i->position.x);
					if (target_rotation < 0) {
						target_rotation += 2.f * glm::pi<float>();
					}

					i->angle = Doodad::acceptable_angle(i->id, i->pathing, i->angle, target_rotation);
					i->update();
				}
				emit angle_changed();

				map->doodads.update_doodad_pathing(selections);
			} else if (mode == Mode::selection && selection_started) {
				const glm::vec2 size = glm::vec2(input_handler.mouse_world) - selection_start;
				selections = map->doodads.query_area({ selection_start.x, selection_start.y, size.x, size.y });
				emit selection_changed();
			}
		}
	}
}

void DoodadBrush::mouse_release_event(QMouseEvent* event) {
	dragging = false;

	if (event->button() == Qt::LeftButton) {
		if (action == Action::drag || action == Action::rotate) {
			end_action();
		}
	}

	Brush::mouse_release_event(event);
}

void DoodadBrush::delete_selection() {
	if (!selections.size()) {
		return;
	}

	QRectF update_pathing_area;
	// Undo/redo
	auto action = std::make_unique<DoodadDeleteAction>();
	for (const auto& i : selections) {
		action->doodads.push_back(*i);

		if (update_pathing_area.width() == 0 || update_pathing_area.height() == 0) {
			update_pathing_area = { i->position.x, i->position.y, 1.f, 1.f };
		}
		update_pathing_area |= { i->position.x, i->position.y, 1.f, 1.f };
	}
	map->terrain_undo.new_undo_group();
	map->terrain_undo.add_undo_action(std::move(action));

	map->doodads.remove_doodads(selections);
	map->doodads.update_doodad_pathing(update_pathing_area);

	selections.clear();
	emit selection_changed();
}

void DoodadBrush::copy_selection() {
	clipboard.clear();

	// Mouse position is average location
	clipboard_free_placement = true;
	glm::vec3 average_position = {};
	for (const auto& i : selections) {
		if (i->pathing) {
			clipboard_free_placement = false;
		}
		clipboard.push_back(*i);
		average_position += i->position;
	}
	clipboard_mouse_offset = average_position / static_cast<float>(clipboard.size());
}

void DoodadBrush::cut_selection() {
	copy_selection();
	// Delete selection will add to the undo/redo tree
	delete_selection();
}

void DoodadBrush::clear_selection() {
	selections.clear();
	emit selection_changed();
}

void DoodadBrush::place_clipboard() {
	apply_begin();
	for (const auto& i : clipboard) {
		Doodad& new_doodad = map->doodads.add_doodad(i);
		new_doodad.creation_number = ++Doodad::auto_increment;
		glm::vec3 final_position;
		if (clipboard_free_placement) {
			final_position = glm::vec3(glm::vec2(input_handler.mouse_world + i.position) - clipboard_mouse_offset, i.position.z);
		} else {
			final_position = glm::round((input_handler.mouse_world) * 2.f + 0.5f) / 2.f - 0.25f + i.position - (glm::round((glm::vec3(clipboard_mouse_offset, 0)) * 2.f + 0.5f) / 2.f - 0.25f);
		}
		if (!lock_doodad_z) {
			final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y);
		}

		new_doodad.position = final_position;
		new_doodad.update();
		doodad_undo->doodads.push_back(new_doodad);
		
		if (new_doodad.pathing) {
			map->pathing_map.blit_pathing_texture(new_doodad.position, glm::degrees(rotation) + 90, new_doodad.pathing);
		}
	}
	map->pathing_map.upload_dynamic_pathing();
	apply_end();
}

void DoodadBrush::apply_begin() {
	doodad_undo = std::make_unique<DoodadAddAction>();
}

void DoodadBrush::apply(double frame_delta) {
	if (id == "") {
		return;
	}

	glm::vec3 doodad_position;
	if (free_placement) {
		doodad_position = input_handler.mouse_world;
	} else {
		doodad_position = glm::vec3(glm::vec2(position) + glm::vec2(uv_offset) * 0.25f + size * 0.125f, input_handler.mouse_world.z);
	}

	Doodad& doodad = map->doodads.add_doodad(id, variation, doodad_position);
	doodad.scale = glm::vec3(scale);
	doodad.angle = rotation;
	doodad.state = state;
	doodad.update();

	doodad_undo->doodads.push_back(doodad);

	if (pathing_texture) {
		map->pathing_map.blit_pathing_texture(doodad_position, glm::degrees(rotation) + 90, pathing_texture);
		map->pathing_map.upload_dynamic_pathing();
	}

	if (random_rotation) {
		set_random_rotation();
		set_shape(shape);
	}

	if (random_variation) {
		set_random_variation();
	}

	if (random_scale) {
		std::random_device rd;
		std::mt19937 gen(rd());
		std::uniform_real_distribution dist(min_scale, max_scale);
		scale = dist(gen);
	}
}

void DoodadBrush::apply_end() {
	if (doodad_undo->doodads.empty()) {
		return;
	}
	map->terrain_undo.new_undo_group();
	map->terrain_undo.add_undo_action(std::move(doodad_undo));
}

void DoodadBrush::render_brush() {
	if (pathing_texture) {
		Brush::render_brush();
	}

	if (!mesh) {
		return;
	}

	glm::vec3 final_position;
	if (free_placement) {
		final_position = input_handler.mouse_world;
	} else {
		final_position = glm::vec3(glm::vec2(position) + glm::vec2(uv_offset) * 0.25f + size * 0.125f, input_handler.mouse_world.z);
	}

	skeleton.update_location(final_position, rotation, glm::vec3(1.f / 128.f) * scale);
	skeleton.update(0.016f);
	mesh->render_queue(skeleton, glm::vec3(1.f));
}

// Quads are drawn and then in the fragment shader fragments are discarded to form a circle
void DoodadBrush::render_selection() const {
	gl->glDisable(GL_DEPTH_TEST);
	selection_circle_shader->use();
	gl->glEnableVertexAttribArray(0);

	for (const auto& i : selections) {
		//float selection_scale = std::max(1.f, i->mesh->extent.bounds_radius / 128.f);
		float selection_scale = i->mesh->model->sequences[i->skeleton.sequence_index].extent.bounds_radius / 128.f;

		glm::mat4 model(1.f);
		model = glm::translate(model, i->position - glm::vec3(selection_scale * 0.5f, selection_scale * 0.5f, 0.f));
		model = glm::scale(model, glm::vec3(selection_scale));

		model = camera->projection_view * model;
		gl->glUniformMatrix4fv(1, 1, GL_FALSE, &model[0][0]);

		gl->glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
		gl->glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
		gl->glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);

	}

	gl->glDisableVertexAttribArray(0);
	gl->glEnable(GL_DEPTH_TEST);
}

void DoodadBrush::render_clipboard() {
	for (const auto& i : clipboard) {
		glm::vec3 base_scale = glm::vec3(1.f);

		if (doodads_slk.row_headers.contains(i.id)) {
			base_scale = glm::vec3(doodads_slk.data<float>("defscale", i.id));
		}

		glm::vec3 final_position;
		if (clipboard_free_placement) {
			final_position = glm::vec3(glm::vec2(input_handler.mouse_world + i.position) - clipboard_mouse_offset, i.position.z);
		} else {
			final_position = glm::round((input_handler.mouse_world) * 2.f + 0.5f) / 2.f - 0.25f + i.position - (glm::round((glm::vec3(clipboard_mouse_offset, 0)) * 2.f + 0.5f) / 2.f - 0.25f);
		}

		if (!lock_doodad_z) {
			final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y);
		}

		glm::mat4 model(1.f);
		model = glm::translate(model, final_position);
		model = glm::scale(model, (base_scale - 1.f + i.scale) / 128.f);
		model = glm::rotate(model, i.angle, glm::vec3(0, 0, 1));

		i.mesh->render_queue(i.skeleton, glm::vec3(1.f));
	}
}

bool DoodadBrush::can_place() {
	if (!pathing_texture) {
		return true;
	}

	glm::vec3 doodad_position;
	if (free_placement) {
		doodad_position = input_handler.mouse_world;
	} else {
		doodad_position = glm::vec3(glm::vec2(position) + glm::vec2(uv_offset) * 0.25f + size * 0.125f, input_handler.mouse_world.z);
	}

	return map->pathing_map.is_area_free(doodad_position, glm::degrees(rotation) + 90, pathing_texture, PathingMap::Flags::unwalkable | PathingMap::Flags::unflyable | PathingMap::Flags::unbuildable);
}

void DoodadBrush::set_random_variation() {
	variation = get_random_variation();
	context->makeCurrent();
	mesh = map->doodads.get_mesh(id, variation);
	skeleton = SkeletalModelInstance(mesh->model);
}

void DoodadBrush::set_random_rotation() {
	std::random_device rd;
	std::mt19937 gen(rd());

	bool fixed_rotation = false;
	if (doodads_slk.row_headers.contains(id)) {
		fixed_rotation = doodads_slk.data<int>("fixedrot", id) > 0;
	} else {
		fixed_rotation = destructibles_slk.data<int>("fixedrot", id) > 0;
	}

	std::uniform_real_distribution dist(0.f, glm::pi<float>() * 2.f);
	float target_rotation = dist(gen);
	if (pathing_texture && pathing_texture->width == pathing_texture->height) {
		if (pathing_texture->homogeneous) {
			rotation = target_rotation;
		} else {
			rotation = (static_cast<int>((target_rotation + glm::pi<float>() * 0.25f) / (glm::pi<float>() * 0.5f)) % 4)* glm::pi<float>() * 0.5f;
		}
	} else {
		rotation = (static_cast<int>((target_rotation + glm::pi<float>() * 0.25f) / (glm::pi<float>() * 0.5f)) % 4)* glm::pi<float>() * 0.5f;
	}
}

void DoodadBrush::add_variation(int variation) {
	possible_variations.insert(variation);
}

void DoodadBrush::erase_variation(int variation) {
	possible_variations.erase(variation);
	if (this->variation == variation) {
		this->variation = get_random_variation();
	}
}

void DoodadBrush::set_doodad(const std::string& id) {
	this->id = id;

	const bool is_doodad = doodads_slk.row_headers.contains(id);
	const slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;
	
	min_scale = slk.data<float>("minscale", id);
	max_scale = slk.data<float>("maxscale", id);

	std::string maxRoll = doodads_slk.data("maxroll", id);
	if (!maxRoll.empty()) {
		roll = -std::stof(maxRoll);
	} else{
		roll = 0;
	}

	if (is_doodad) {
		scale = slk.data<float>("defscale", id);
	}

	if (slk.data<int>("fixedrot", id) < 0) {
		rotation = glm::pi<float>() * 1.5f;
	} else {
		rotation = glm::radians(slk.data<float>("fixedrot", id));
	}

	pathing_texture.reset();
	std::string pathing_texture_path = slk.data("pathtex", id);
	if (hierarchy.file_exists(pathing_texture_path)) {
		free_placement = false;
		pathing_texture = resource_manager.load<PathingTexture>(pathing_texture_path);

		set_size(std::max(pathing_texture->width, pathing_texture->height));

		free_rotation = pathing_texture->width == pathing_texture->height;
		free_rotation = free_rotation && pathing_texture->homogeneous;
		free_rotation = free_rotation && slk.data<float>("fixedrot", id) < 0.f;
	} else {
		free_placement = true;
		free_rotation = true;
	}

	possible_variations.clear();
	int variation_count = slk.data<int>("numvar", id);
	for (int i = 0; i < variation_count; i++) {
		possible_variations.insert(i);
	}
	set_random_variation();
}

void DoodadBrush::start_action(Action new_action) {
	action = new_action;
	map->terrain_undo.new_undo_group();
	doodad_state_undo = std::make_unique<DoodadStateAction>();
	for (const auto& i : selections) {
		doodad_state_undo->old_doodads.push_back(*i);
	}
}

void DoodadBrush::end_action() {
	for (const auto& i : selections) {
		doodad_state_undo->new_doodads.push_back(*i);
	}
	map->terrain_undo.add_undo_action(std::move(doodad_state_undo));
	action = Action::none;
}

void DoodadBrush::set_selection_angle(float angle) {
	start_action(Action::rotate);
	for (auto& i : selections) {
		i->angle = Doodad::acceptable_angle(i->id, i->pathing, i->angle, angle);
		i->update();
	}
	end_action();
}

void DoodadBrush::set_selection_absolute_height(float height) {
	start_action(Action::move);
	for (auto& i : selections) {
		i->position.z = height;
		i->update();
	}
	end_action();
}

void DoodadBrush::set_selection_relative_height(float height) {
	start_action(Action::move);
	for (auto& i : selections) {
		i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y) + height;
		i->update();
	}
	end_action();
}

void DoodadBrush::set_selection_scale_component(int component, float scale) {
	start_action(Action::scale);
	for (auto& i : selections) {
		bool is_doodad = doodads_slk.row_headers.contains(i->id);
		slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

		float min_scale = slk.data<float>("minscale", i->id);
		float max_scale = slk.data<float>("maxscale", i->id);

		if (!is_doodad) {
			i->scale = glm::vec3(std::clamp(scale, min_scale, max_scale));
		} else {
			i->scale[component] = std::clamp(scale, min_scale, max_scale);
		}
		i->update();
	}
	end_action();
}
```

`src/Brush/DoodadBrush.h`:

```h
#pragma once

#include <set>
#include <vector>

#include "Doodads.h"
#include "Brush.h"
import PathingTexture;

class DoodadBrush : public Brush {
	Q_OBJECT

	std::set<int> possible_variations = { 0 };
	int get_random_variation();

	std::string id;
	int variation = 0;

	std::shared_ptr<SkinnedMesh> mesh;
	SkeletalModelInstance skeleton;

public:
	Doodad::State state = Doodad::State::visible_solid;
	std::shared_ptr<PathingTexture> pathing_texture;

	bool free_placement = false;
	bool free_rotation = false;

	bool random_variation = true;
	bool random_scale = true;
	bool random_rotation = true;

	bool select_doodads = true;
	bool select_destructibles = true;

	bool lock_doodad_z = false;

	float scale = 1.f;
	float min_scale = 1.f;
	float max_scale = 1.f;

	float rotation = 0.f;
	float roll = 0.f;

	std::unique_ptr<DoodadAddAction> doodad_undo;
	std::unique_ptr<DoodadStateAction> doodad_state_undo;

	std::vector<Doodad*> selections;

	glm::vec2 clipboard_mouse_offset;
	std::vector<Doodad> clipboard;
	bool clipboard_free_placement = false;

	bool dragging = false;
	bool dragged = false;
	glm::vec3 drag_start;
	std::vector<glm::vec2> drag_offsets;

	enum class Action {
		none,
		drag,
		move,
		rotate,
		scale
	};

	Action action = Action::none;

	DoodadBrush();

	void set_shape(const Shape new_shape) override;

	void key_press_event(QKeyEvent* event) override;
	void key_release_event(QKeyEvent* event) override;
	void mouse_press_event(QMouseEvent* event, double frame_delta) override;
	void mouse_move_event(QMouseEvent* event, double frame_delta) override;
	void mouse_release_event(QMouseEvent* event) override;

	void delete_selection() override;
	void copy_selection() override;
	void cut_selection() override;
	void clear_selection() override;
	void place_clipboard() override;

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;
	void render_brush() override;
	void render_selection() const override;
	void render_clipboard() override;

	bool can_place() override;

	void set_random_rotation();
	void set_random_variation();
	void add_variation(int variation);
	void erase_variation(int variation);

	void set_doodad(const std::string& id);

	void start_action(Action new_action);
	void end_action();

public slots:
	// Angle in radians
	void set_selection_angle(float angle);
	void set_selection_absolute_height(float height);
	void set_selection_relative_height(float height);
	void set_selection_scale_component(int component, float scale);

signals:
	void selection_changed();
	void angle_changed();
	void scale_changed();
	void position_changed();
};
```

`src/Brush/PathingBrush.cpp`:

```cpp
#include "PathingBrush.h"

#include <QRect>

#include "Globals.h"

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

PathingBrush::PathingBrush() : Brush() {
	brush_offset = {0.125f, 0.125f};
}

void PathingBrush::apply_begin() {
	const int x = position.x * 4 + uv_offset.x;
	const int y = position.y * 4 + uv_offset.y;

	applied_area = QRect(x, y, size, size).intersected({ 0, 0, map->pathing_map.width, map->pathing_map.height });

	map->terrain_undo.new_undo_group();
	map->pathing_map.new_undo_group();
}

void PathingBrush::apply(double frame_delta) {
	const int x = position.x * 4 + uv_offset.x;
	const int y = position.y * 4 + uv_offset.y;

	QRect area = QRect(x, y, size, size).intersected({ 0, 0, map->pathing_map.width, map->pathing_map.height });
	
	if (area.width() <= 0 || area.height() <= 0) {
		return;
	}

	const int offset = area.y() * map->pathing_map.width + area.x();

	for (int i = 0; i < area.width(); i++) {
		for (int j = 0; j < area.height(); j++) {
			if (!contains(i - std::min(x, 0), j - std::min(y, 0))) {
				continue;
			}

			const int index = offset + j * map->pathing_map.width + i;
			switch (operation) {
				case Operation::replace:
					map->pathing_map.pathing_cells_static[index] &= ~0b00001110;
					map->pathing_map.pathing_cells_static[index] |= brush_mask;
					break;
				case Operation::add:
					map->pathing_map.pathing_cells_static[index] |= brush_mask;
					break;
				case Operation::remove:
					map->pathing_map.pathing_cells_static[index] &= ~brush_mask;
					break;
			}
		}
	}

	applied_area = applied_area.united(area);

	map->pathing_map.upload_static_pathing();
}

void PathingBrush::apply_end() {
	map->pathing_map.add_undo(applied_area);
}
```

`src/Brush/PathingBrush.h`:

```h
#pragma once

#include <cstdint>

#include "Brush.h"

class PathingBrush : public Brush {
public:
	enum class Operation {
		replace,
		add,
		remove
	};

	uint8_t brush_mask = 0b00000000;

	Operation operation = Operation::replace;

	QRect applied_area;

	PathingBrush();

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;
};
```

`src/Brush/TerrainBrush.cpp`:

```cpp
#include "TerrainBrush.h"

#include <random>

#include "Globals.h"
#include "Terrain.h"

TerrainBrush::TerrainBrush() : Brush() {
	size_granularity = 4;
	uv_offset_locked = true;
	uv_offset = { 2, 2 };
	set_size(size);
}

// Make this an iterative function instead to avoid stack overflows
void TerrainBrush::check_nearby(const int begx, const int begy, const int i, const int j, QRect& area) const {
	QRect bounds = QRect(i - 1, j - 1, 3, 3).intersected({ 0, 0, map->terrain.width, map->terrain.height });

	for (int k = bounds.x(); k <= bounds.right(); k++) {
		for (int l = bounds.y(); l <= bounds.bottom(); l++) {
			if (k == 0 && l == 0) {
				continue;
			}

			int difference = map->terrain.corners[i][j].layer_height - map->terrain.corners[k][l].layer_height;
			if (std::abs(difference) > 2 && !contains(begx + (k - i), begy + (l - k))) {
				map->terrain.corners[k][l].layer_height = map->terrain.corners[i][j].layer_height - std::clamp(difference, -2, 2);
				map->terrain.corners[k][l].ramp = false;

				area.setX(std::min(area.x(), k - 1));
				area.setY(std::min(area.y(), l - 1));
				area.setRight(std::max(area.right(), k));
				area.setBottom(std::max(area.bottom(), l));

				check_nearby(begx, begy, k, l, area);
			}
		}
	}
};

void TerrainBrush::apply_begin() {
	int width = map->terrain.width;
	int height = map->terrain.height;
	auto& corners = map->terrain.corners;

	const int x = position.x + 1;
	const int y = position.y + 1;
	const QRect area = QRect(x, y, size / 4.f, size / 4.f).intersected({ 0, 0, width, height });
	const int center_x = area.x() + area.width() * 0.5f;
	const int center_y = area.y() + area.height() * 0.5f;
	
	// Setup for undo/redo
	map->terrain_undo.new_undo_group();
	map->terrain.new_undo_group();
	map->pathing_map.new_undo_group();
	texture_height_area = area;
	cliff_area = area;

	if (apply_height) {
		deformation_height = corners[center_x][center_y].height;
	}

	if (apply_cliff) {
		layer_height = corners[center_x][center_y].layer_height;
		switch (cliff_operation_type) {
			case cliff_operation::shallow_water:
				if (!corners[center_x][center_y].water) {
					layer_height -= 1;
				} else if (corners[center_x][center_y].final_water_height() > corners[center_x][center_y].final_ground_height() + 1) {
					layer_height += 1;
				}
				break;
			case cliff_operation::lower1:
				layer_height -= 1;
				break;
			case cliff_operation::lower2:
				layer_height -= 2;
				break;
			case cliff_operation::deep_water:
				if (!corners[center_x][center_y].water) {
					layer_height -= 2;
				} else if (corners[center_x][center_y].final_water_height() < corners[center_x][center_y].final_ground_height() + 1) {
					layer_height -= 1;
				}
				break;
			case cliff_operation::raise1:
				layer_height += 1;
				break;
			case cliff_operation::raise2:
				layer_height += 2;
				break;
			case cliff_operation::ramp:
				break;
			case cliff_operation::level:
				break;
		}
		layer_height = std::clamp(layer_height, 0, 15);
	}
}

void TerrainBrush::apply(double frame_delta) {
	int width = map->terrain.width;
	int height = map->terrain.height;
	auto& corners = map->terrain.corners;

	const int x = position.x + 1;
	const int y = position.y + 1;

	QRect area = QRect(x, y, size / 4.f, size / 4.f).intersected({ 0, 0, width, height });

	if (area.width() <= 0 || area.height() <= 0) {
		return;
	}

	if (apply_texture) {
		const int id = map->terrain.ground_texture_to_id[tile_id];

		// Update textures
		for (int i = area.x(); i < area.x() + area.width(); i++) {
			for (int j = area.y(); j < area.y() + area.height(); j++) {
				if (!contains(i - area.x() - std::min(position.x + 1, 0), j - area.y() - std::min(position.y + 1, 0))) {
					continue;
				}

				bool cliff_near = false;
				for (int k = -1; k < 1 && !cliff_near; k++) {
					for (int l = -1; l < 1 && !cliff_near; l++) {
						if (i + k >= 0 && i + k <= width && j + l >= 0 && j + l <= height) {
							cliff_near = corners[i + k][j + l].cliff;
						}
					}
				}

				if (id == map->terrain.blight_texture) {
					// Blight shouldn't be set when there is a cliff near
					if (cliff_near) {
						continue;
					}

					corners[i][j].blight = true;
				} else {
					corners[i][j].blight = false;
					corners[i][j].ground_texture = id;
					corners[i][j].ground_variation = get_random_variation();
				}
			}
		}

		map->terrain.update_ground_textures(area);
		texture_height_area = texture_height_area.united(area);
	}

	if (apply_height) {
		std::vector<std::vector<float>> heights(area.width(), std::vector<float>(area.height()));

		for (int i = area.x(); i < area.x() + area.width(); i++) {
			for (int j = area.y(); j < area.y() + area.height(); j++) {
				float new_height = corners[i][j].height;
				heights[i - area.x()][j - area.y()] = new_height;

				if (!contains(i - area.x() - std::min(position.x + 1, 0), j - area.y() - std::min(position.y + 1, 0))) {
					continue;
				}
				const int center_x = area.x() + area.width() * 0.5f;
				const int center_y = area.y() + area.height() * 0.5f;

				switch (deformation_type) {
					case deformation::raise: {
						auto distance = std::sqrt(std::pow(center_x - i, 2) + std::pow(center_y - j, 2));
						new_height += std::max(0.0, 1 - distance / size * std::sqrt(2)) * frame_delta;
						break;
					}
					case deformation::lower: {
						auto distance = std::sqrt(std::pow(center_x - i, 2) + std::pow(center_y - j, 2));
						new_height -= std::max(0.0, 1 - distance / size * std::sqrt(2)) * frame_delta;
						break;
					}
					case deformation::plateau: {
						new_height = deformation_height;
						break;
					}
					case deformation::ripple:
						break;
					case deformation::smooth: {
						float accumulate = 0;

						QRect acum_area = QRect(i - 1, j - 1, 3, 3).intersected({0, 0, width, height});

						for (int k = acum_area.x(); k < acum_area.right() + 1; k++) {
							for (int l = acum_area.y(); l < acum_area.bottom() + 1; l++) {
								if ((k < i || l < j) && k <= i && 
									// The checks below are required because the code is just wrong (area is too small so we cant convolute a cell from at the edges of the area)
									k - area.x() >= 0 && l - area.y() >= 0 && k < area.right() + 1 && l < area.bottom() + 1) {
									accumulate += heights[k - area.x()][l - area.y()];
								} else {
									accumulate += corners[k][l].height;
								}
							}
						}
						accumulate -= new_height;
						new_height = 0.8 * new_height + 0.2 * (accumulate / (acum_area.width() * acum_area.height() - 1));
						break;
					}
				}

				corners[i][j].height = std::clamp(new_height, -16.f, 15.98f); // ToDo why 15.98?
			}
		}

		map->terrain.update_ground_heights(area);

		texture_height_area = texture_height_area.united(area);
	}

	QRect updated_area = QRect(x - 1, y - 1, size / 4.f + 1, size / 4.f + 1).intersected({ 0, 0, width - 1, height - 1 });

	if (apply_cliff) {
		
		//if (cliff_operation_type == cliff_operation::ramp) {
		//	const int center_x = area.x() + area.width() * 0.5f;
		//	const int center_y = area.y() + area.height() * 0.5f;

		//	glm::vec2 p = glm::vec2(input_handler.mouse_world) - get_position();

		//	int cliff_count = corners[center_x][center_y].cliff + corners[center_x - 1][center_y].cliff + corners[center_x][center_y - 1].cliff + corners[center_x - 1][center_y - 1].cliff;

		//	// Cliff count 1 and 4 are nothing

		//	if (cliff_count == 2 ) {
		//		corners[center_x][center_y].ramp = true;

		//		// possibly place a new ramp
		//	} else if (cliff_count == 3) {
		//		// Target for whole rampification
		//	}

		//	std::cout << cliff_count << "\n";

		//	if (corners[center_x - (p.x < 1)][center_y - (p.y < 1)].cliff) {
		//	//	corners[center_x][center_y].ramp = true;
		//	//	std::cout << "Ramp set\n";
		//	}

		//	//if (corners[center_x][center_y].cliff) {
		//	//	corners[i][j].ramp = true;
		//	//}
		//} else {
			for (int i = area.x(); i < area.x() + area.width(); i++) {
				for (int j = area.y(); j < area.y() + area.height(); j++) {
					const int xx = i - area.x() - std::min(position.x + 1, 0);
					const int yy = j - area.y() - std::min(position.y + 1, 0);
					if (!contains(xx, yy)) {
						continue;
					}
					corners[i][j].ramp = false;
					corners[i][j].layer_height = layer_height;

					switch (cliff_operation_type) {
						case cliff_operation::lower1:
						case cliff_operation::lower2:
						case cliff_operation::level:
						case cliff_operation::raise1:
						case cliff_operation::raise2:
							if (corners[i][j].water) {
								if (enforce_water_height_limits && corners[i][j].final_water_height() < corners[i][j].final_ground_height()) {
									corners[i][j].water = false;
								}
							}
							break;
						case cliff_operation::shallow_water:
							corners[i][j].water = true;
							corners[i][j].water_height = corners[i][j].layer_height - 1;
							break;
						case cliff_operation::deep_water:
							corners[i][j].water = true;
							corners[i][j].water_height = corners[i][j].layer_height;
							break;
						case cliff_operation::ramp:
							break;
					}

					check_nearby(x, y, i, j, updated_area);
				}
			}
		//}

		// Bounds check
		updated_area = updated_area.intersected({ 0, 0, width - 1, height - 1 });

		// Determine if cliff
		for (int i = updated_area.x(); i <= updated_area.right(); i++) {
			for (int j = updated_area.y(); j <= updated_area.bottom(); j++) {
				Corner& bottom_left = map->terrain.corners[i][j];
				Corner& bottom_right = map->terrain.corners[i + 1][j];
				Corner& top_left = map->terrain.corners[i][j + 1];
				Corner& top_right = map->terrain.corners[i + 1][j + 1];

				bottom_left.cliff = bottom_left.layer_height != bottom_right.layer_height
					|| bottom_left.layer_height != top_left.layer_height
					|| bottom_left.layer_height != top_right.layer_height;

				if (cliff_operation_type != cliff_operation::ramp) {
					bottom_left.cliff_texture = cliff_id;
				}
			}
		}

		QRect tile_area = updated_area.adjusted(-1, -1, 1, 1).intersected({ 0, 0, width - 1, height - 1 });

		map->terrain.update_cliff_meshes(tile_area);
		map->terrain.update_ground_textures(updated_area);
		map->terrain.update_ground_heights(updated_area.adjusted(0, 0, 1, 1));
		map->terrain.update_water(tile_area.adjusted(0, 0, 1, 1));

		cliff_area = cliff_area.united(updated_area);

		if (cliff_operation_type == cliff_operation::shallow_water || cliff_operation_type == cliff_operation::deep_water) {
			map->terrain.upload_water_heights();
		}
	}

	// Apply pathing
	for (int i = updated_area.x(); i <= updated_area.right(); i++) {
		for (int j = updated_area.y(); j <= updated_area.bottom(); j++) {
			Corner& bottom_left = map->terrain.corners[i][j];

			for (int k = 0; k < 4; k++) {
				for (int l = 0; l < 4; l++) {
					map->pathing_map.pathing_cells_static[(j * 4 + l) * map->pathing_map.width + i * 4 + k] &= ~0b01001110;

					uint8_t mask = 0;
					if ((bottom_left.cliff || bottom_left.romp) && !map->terrain.is_corner_ramp_entrance(i, j) && apply_cliff_pathing) {
						mask = 0b00001010;
					} 
					
					if (!bottom_left.cliff || (bottom_left.ramp && !bottom_left.romp)) {
						Corner& corner = map->terrain.corners[i + k / 2][j + l / 2];
						if (apply_tile_pathing) {
							const int id = corner.ground_texture;
							mask |= map->terrain.pathing_options[map->terrain.tileset_ids[id]].mask();
						}

						if (corner.water && apply_water_pathing) {
							mask |= 0b01000000;
							if (corner.final_water_height() > corner.final_ground_height() + 0.40) {
								mask |= 0b00001010;
							} else if (corner.final_water_height() > corner.final_ground_height()) {
								mask |= 0b00001000;
							}
						}
					}
					map->pathing_map.pathing_cells_static[(j * 4 + l) * map->pathing_map.width + i * 4 + k] |= mask;
				}
			}
		}
	}

	map->pathing_map.upload_static_pathing();

	if (apply_height || apply_cliff) {
		if (change_doodad_heights) {
			for (auto&& i : map->doodads.doodads) {
				if (area.contains(i.position.x, i.position.y)) {
					if (std::find_if(pre_change_doodads.begin(), pre_change_doodads.end(), [i](const Doodad& doodad) { return doodad.creation_number == i.creation_number; }) == pre_change_doodads.end()) {
						pre_change_doodads.push_back(i);
					}
					i.position.z = map->terrain.interpolated_height(i.position.x, i.position.y);
					i.update();
					post_change_doodads[i.creation_number] = i;
				}
			}
		}
		map->units.update_area(updated_area);
	}
}

void TerrainBrush::apply_end() {
	if (apply_texture) {
		map->terrain.add_undo(texture_height_area, Terrain::undo_type::texture);
	}

	if (apply_height) {
		map->terrain.add_undo(texture_height_area, Terrain::undo_type::height);
	}

	if (apply_cliff) {
		QRect cliff_areaa = cliff_area.adjusted(0, 0, 1, 1).intersected({ 0, 0, map->terrain.width, map->terrain.height });
		map->terrain.add_undo(cliff_areaa, Terrain::undo_type::cliff);
	}

	if (change_doodad_heights) {
		auto undo = std::make_unique<DoodadStateAction>();
		undo->old_doodads = pre_change_doodads;
		for (const auto& [id, doodad] : post_change_doodads) {
			undo->new_doodads.push_back(doodad);
		}
		pre_change_doodads.clear();
		post_change_doodads.clear();
		map->terrain_undo.add_undo_action(std::move(undo));
	}

	QRect pathing_area = QRect(cliff_area.x() * 4, cliff_area.y() * 4, cliff_area.width() * 4, cliff_area.height() * 4).adjusted(-2, -2, 2, 2).intersected({ 0, 0, map->pathing_map.width, map->pathing_map.height });
	map->pathing_map.add_undo(pathing_area);

	map->terrain.update_minimap();
}

int TerrainBrush::get_random_variation() const {
	std::random_device rd;
	std::mt19937 e2(rd());
	std::uniform_int_distribution<> dist(0, 570);

	int nr = dist(e2) - 1;

	for (auto&&[variation, chance] : variation_chances) {
		if (nr < chance) {
			return variation;
		}
		nr -= chance;
	}
	assert("Didn't hit the list of tile variations");
	return 0;
}
```

`src/Brush/TerrainBrush.h`:

```h
#pragma once

#include <string>

#include "Brush.h"

#include "Doodads.h"

class TerrainBrush : public Brush {
public:
	bool apply_texture = false;
	bool apply_height = false;
	bool apply_cliff = false;
	bool apply_tile_pathing = true;
	bool apply_cliff_pathing = true;
	bool apply_water_pathing = true;

	bool enforce_water_height_limits = true;
	bool change_doodad_heights = true;
	bool relative_cliff_heights = false;

	std::string tile_id;

	enum class deformation {
		raise,
		lower,
		plateau,
		ripple,
		smooth
	};
	deformation deformation_type = deformation::plateau;

	int cliff_id = 0;

	enum class cliff_operation {
		lower2,
		lower1,
		level,
		raise1,
		raise2,
		deep_water,
		shallow_water,
		ramp
	};
	cliff_operation cliff_operation_type = cliff_operation::level;

	TerrainBrush();
	void check_nearby(int begx, int begy, int i, int j, QRect& area) const;

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;

	int get_random_variation() const;
private:
	// Total sum 570
	const std::tuple<int, int> variation_chances[18] = {
		{ 0, 85 },
		{ 16, 85 },
		{ 0, 85 },
		{ 1, 10 },
		{ 2, 4 },
		{ 3, 1 },
		{ 4, 85 },
		{ 5, 10 },
		{ 6, 4 },
		{ 7, 1 },
		{ 8, 85 },
		{ 9, 10 },
		{ 10, 4 },
		{ 11, 1 },
		{ 12, 85 },
		{ 13, 10 },
		{ 14, 4 },
		{ 15, 1 }
	};

	int layer_height = 0;
	float deformation_height = 0.f;

	QRect texture_height_area;
	QRect cliff_area;
	std::vector<Doodad> pre_change_doodads;
	std::map<int, Doodad> post_change_doodads;

};
```

`src/Brush/UnitBrush.cpp`:

```cpp
#include "UnitBrush.h"

#include <random>
#include <memory>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "InputHandler.h"
#include "TerrainUndo.h"
#include "Globals.h"
import Hierarchy;
import Texture;

UnitBrush::UnitBrush() : Brush() {
}

void UnitBrush::set_shape(const Shape new_shape) {
}

void UnitBrush::key_press_event(QKeyEvent* event) {
	if (event->modifiers() & Qt::KeypadModifier) {
		if (!event->isAutoRepeat()) {
			map->terrain_undo.new_undo_group();
			unit_state_undo = std::make_unique<UnitStateAction>();
			for (const auto& i : selections) {
				unit_state_undo->old_units.push_back(*i);
			}
		}

		bool left = event->key() == Qt::Key_1 || event->key() == Qt::Key_4 || event->key() == Qt::Key_7;
		bool right = event->key() == Qt::Key_3 || event->key() == Qt::Key_6 || event->key() == Qt::Key_9;
		bool down = event->key() == Qt::Key_7 || event->key() == Qt::Key_8 || event->key() == Qt::Key_9;
		bool up = event->key() == Qt::Key_1 || event->key() == Qt::Key_2 || event->key() == Qt::Key_3;

		float x_displacement = -0.25f * left + 0.25f * right;
		float y_displacement = -0.25f * up + 0.25f * down;

		for (const auto& i : selections) {
			i->position.x += x_displacement;
			i->position.y += y_displacement;
			i->update();
		}
	}

	if (event->modifiers() & Qt::ControlModifier) {
		switch (event->key()) {
			case Qt::Key_A:
				selections.clear();
				selections.reserve(map->units.units.size());
				for (auto& i : map->units.units) {
					selections.push_back(&i);
				}
				break;
			default:
				Brush::key_press_event(event);
		}
	} else {
		Brush::key_press_event(event);
	}
}

void UnitBrush::key_release_event(QKeyEvent* event) {
	if (!event->isAutoRepeat()) {
		if (unit_state_undo) {
			for (const auto& i : selections) {
				unit_state_undo->new_units.push_back(*i);
			}
			map->terrain_undo.add_undo_action(std::move(unit_state_undo));
		}
	}
}

//void UnitBrush::mouse_release_event(QMouseEvent* event) {
//	Brush::mouse_release_event(event);
//	//if (event->button() == Qt::LeftButton && mode == Mode::selection) {
//	//	selection_started = false;
//	//} else {
//	//}
//}

void UnitBrush::mouse_press_event(QMouseEvent* event, double frame_delta) {
	if (event->button() == Qt::LeftButton && mode == Mode::selection && !event->modifiers() && input_handler.mouse.y > 0.f) {
		auto id = map->render_manager.pick_unit_id_under_mouse(input_handler.mouse);
		if (id) {
			Unit& unit = map->units.units[id.value()];
			selections = { &unit };
			dragging = true;
			drag_x_offset = input_handler.mouse_world.x - unit.position.x;
			drag_y_offset = input_handler.mouse_world.y - unit.position.y;
			return;
		}
	}

	Brush::mouse_press_event(event, frame_delta);
}

void UnitBrush::mouse_move_event(QMouseEvent* event, double frame_delta) {
	Brush::mouse_move_event(event,	frame_delta);

	if (event->buttons() == Qt::LeftButton) {
		if (mode == Mode::selection) {
			if (dragging) {
				if (!dragged) {
					dragged = true;
					map->terrain_undo.new_undo_group();
					unit_state_undo = std::make_unique<UnitStateAction>();
					for (const auto& i : selections) {
						unit_state_undo->old_units.push_back(*i);
					}
				}
				for (auto& i : selections) {
					i->position.x = input_handler.mouse_world.x - drag_x_offset;
					i->position.y = input_handler.mouse_world.y - drag_y_offset;
					i->position.z = map->terrain.interpolated_height(i->position.x, i->position.y);
					i->update();
				}
			} else if (event->modifiers() & Qt::ControlModifier) {
				for (auto&& i : selections) {
					float target_rotation = std::atan2(input_handler.mouse_world.y - i->position.y, input_handler.mouse_world.x - i->position.x);
					if (target_rotation < 0) {
						target_rotation = (glm::pi<float>() + target_rotation) + glm::pi<float>();
					}

					i->angle = target_rotation;
					i->update();
				}
			} else if (selection_started) {
				const glm::vec2 size = glm::vec2(input_handler.mouse_world) - selection_start;
				selections = map->units.query_area({ selection_start.x, selection_start.y, size.x, size.y });
			}
		}
	}
}

void UnitBrush::mouse_release_event(QMouseEvent* event) {
	dragging = false;
	if (dragged) {
		dragged = false;
		for (const auto& i : selections) {
			unit_state_undo->new_units.push_back(*i);
		}
		map->terrain_undo.add_undo_action(std::move(unit_state_undo));
	}

	Brush::mouse_release_event(event);
}

void UnitBrush::delete_selection() {
	if (selections.size()) {

		// Undo/redo
		map->terrain_undo.new_undo_group();
		auto action = std::make_unique<UnitDeleteAction>();
		for (const auto& i : selections) {
			action->units.push_back(*i);
		}
		map->terrain_undo.add_undo_action(std::move(action));
		map->units.remove_units(selections);

		selections.clear();
	}
}

void UnitBrush::copy_selection() {
	clipboard.clear();

	// Mouse position is average location
	clipboard_free_placement = true;
	glm::vec3 average_position = {};
	for (const auto& i : selections) {
		clipboard.push_back(*i);
		average_position += i->position;
	}
	clipboard_mouse_offset = average_position / static_cast<float>(clipboard.size());
}

void UnitBrush::cut_selection() {
	copy_selection();
	// Delete selection will add to the undo/redo tree
	delete_selection();
}

void UnitBrush::clear_selection() {
	selections.clear();
}

void UnitBrush::place_clipboard() {
	apply_begin();
	for (const auto& i : clipboard) {
		Unit& new_unit = map->units.add_unit(i);
		new_unit.creation_number = ++Unit::auto_increment;
		glm::vec3 final_position = glm::vec3(glm::vec2(input_handler.mouse_world + i.position) - clipboard_mouse_offset, 0);

		final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y);

		new_unit.position = final_position;
		new_unit.update();
		unit_undo->units.push_back(new_unit);
	}
	apply_end();
}

void UnitBrush::apply_begin() {
	map->terrain_undo.new_undo_group();
	unit_undo = std::make_unique<UnitAddAction>();
}

void UnitBrush::apply(double frame_delta) {
	if (id.empty()) {
		return;
	}

	Unit& new_unit = map->units.add_unit(id, input_handler.mouse_world);
	new_unit.angle = rotation;
	new_unit.update();
	new_unit.player = player_id;

	unit_undo->units.push_back(new_unit);

	if (random_rotation) {
		set_random_rotation();
	}
}

void UnitBrush::apply_end() {
	map->terrain_undo.add_undo_action(std::move(unit_undo));
}

void UnitBrush::render_brush() {
	const float model_scale = units_slk.data<float>("modelscale", id);
	const float move_height = units_slk.data<float>("moveheight", id);

	glm::vec3 final_position = input_handler.mouse_world;
	final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y) + move_height / 128.f;
	const glm::vec3 final_scale = glm::vec3(model_scale / 128.f);

	if (mesh) {
		skeleton.update_location(final_position, rotation, final_scale);
		skeleton.update(0.016f);
		mesh->render_queue(skeleton, glm::vec3(1.f));
	}
}

void UnitBrush::render_selection() const {
	gl->glDisable(GL_DEPTH_TEST);
	selection_circle_shader->use();
	gl->glEnableVertexAttribArray(0);

	for (const auto& i : selections) {
		float selection_scale = i->mesh->model->sequences[i->skeleton.sequence_index].extent.bounds_radius / 128.f;

		glm::mat4 model(1.f);
		model = glm::translate(model, i->position - glm::vec3(selection_scale * 0.5f, selection_scale * 0.5f, 0.f));
		model = glm::scale(model, glm::vec3(selection_scale));

		model = camera->projection_view * model;
		gl->glUniformMatrix4fv(1, 1, GL_FALSE, &model[0][0]);

		gl->glBindBuffer(GL_ARRAY_BUFFER, shapes.vertex_buffer);
		gl->glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

		gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, shapes.index_buffer);
		gl->glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
	}

	gl->glDisableVertexAttribArray(0);
	gl->glEnable(GL_DEPTH_TEST);
}

void UnitBrush::render_clipboard() {
	for (auto& i : clipboard) {
		const float model_scale = units_slk.data<float>("modelscale", i.id);
		const float move_height = units_slk.data<float>("moveheight", i.id);

		glm::vec3 final_position = glm::vec3(glm::vec2(input_handler.mouse_world + i.position) - clipboard_mouse_offset, 0);
		final_position.z = map->terrain.interpolated_height(final_position.x, final_position.y) + move_height / 128.f;

		const glm::vec3 final_scale = glm::vec3(model_scale / 128.f);

		i.skeleton.update_location(final_position, i.angle, final_scale);
		i.skeleton.update(0.016f);
		i.mesh->render_queue(i.skeleton, glm::vec3(1.f));
	}
}

void UnitBrush::set_random_rotation() {
	std::random_device rd;
	std::mt19937 gen(rd());

	std::uniform_real_distribution dist(0.f, glm::pi<float>() * 2.f);
	rotation = dist(gen);
}

void UnitBrush::set_unit(const std::string& id) {
	context->makeCurrent();
	this->id = id;
	mesh = map->units.get_mesh(id);
	skeleton = SkeletalModelInstance(mesh->model);
}
```

`src/Brush/UnitBrush.h`:

```h
#pragma once

#include <set>
#include <vector>

#include "Units.h"
#include "Brush.h"
#include "SkinnedMesh.h"
import PathingTexture;

class UnitBrush : public Brush {
	std::string id;

	std::shared_ptr<SkinnedMesh> mesh;
	SkeletalModelInstance skeleton;

  public:
	float rotation = 0.f;
	bool random_rotation = true;

	int player_id = 0;

	std::unique_ptr<UnitAddAction> unit_undo;
	std::unique_ptr<UnitStateAction> unit_state_undo;

	std::vector<Unit*> selections;
	glm::vec2 clipboard_mouse_offset;
	bool clipboard_free_placement = false;
	std::vector<Unit> clipboard;

	bool dragging = false;
	bool dragged = false;
	float drag_x_offset;
	float drag_y_offset;

	UnitBrush();

	void set_shape(const Shape new_shape) override;

	void key_press_event(QKeyEvent* event) override;
	void key_release_event(QKeyEvent* event) override;
	void mouse_release_event(QMouseEvent* event) override;
	void mouse_press_event(QMouseEvent* event, double frame_delta) override;
	void mouse_move_event(QMouseEvent* event, double frame_delta) override;

	void delete_selection() override;
	void copy_selection() override;
	void cut_selection() override;
	void clear_selection() override;
	void place_clipboard() override;

	void apply_begin() override;
	void apply(double frame_delta) override;
	void apply_end() override;
	void render_brush() override;
	void render_selection() const override;
	void render_clipboard() override;

	void set_random_rotation();
	void set_unit(const std::string& id);
};
```

`src/CMakeLists.txt`:

```txt
target_sources(HiveWE PRIVATE

	"main.cpp"
	"test.cpp"
	"Utilities.cpp"
	"Globals.h"

	"MainWindow/HiveWE.rc"
	"MainWindow/HiveWE.cpp"	
	"MainWindow/GLWidget.cpp"
	"MainWindow/MainRibbon.cpp"

	"Base/BinaryReader.ixx"
	"Base/BinaryWriter.ixx"
	"Base/no_init_allocator.ixx"
	"Base/Doodads.cpp"
	"Base/Hierarchy.ixx"
	"Base/GameCameras.ixx"
	"Base/Imports.ixx"
	"Base/Map.cpp"
	"Base/MapInfo.ixx"
	"Base/PathingMap.cpp"
	"Base/Regions.cpp"
	"Base/Camera.cpp"
	"Base/InputHandler.cpp"
	"Base/TerrainUndo.cpp"
	"Base/WindowHandler.h"
	"Base/MathOperations.ixx"
	"Base/ResourceManager.ixx"
	
	"Base/RenderManager.cpp"
	"Base/ShadowMap.cpp"
	"Base/Sounds.cpp"
	"Base/Terrain.cpp"
	"Base/Triggers.cpp"
	"Base/TriggerStrings.cpp"
	"Base/Units.cpp"
	"Base/Physics.cpp"

	"Brush/Brush.cpp"
	"Brush/DoodadBrush.cpp"
	"Brush/PathingBrush.cpp"
	"Brush/TerrainBrush.cpp"
	"Brush/UnitBrush.cpp"

	"File Formats/BLP.ixx"
	"File Formats/CASC.ixx"
	"File Formats/INI.cpp"
	"File Formats/JSON.ixx"
	"File Formats/MDX/MDX.ixx"
	"File Formats/MDX/MDLReader.cpp"
	"File Formats/MDX/MDLWriter.cpp"
	"File Formats/MDX/MDXReader.cpp"
	"File Formats/MDX/MDXWriter.cpp"
	"File Formats/MPQ.ixx"
	"File Formats/SLK.cpp"

	"Resources/CliffMesh.cpp"
	"Resources/GPUTexture.cpp"
	"Resources/GroundTexture.cpp"
	"Resources/Shader.cpp"
	"Resources/SkinnedMesh.cpp"
	"Resources/EditableMesh.cpp"
	"Resources/Texture.ixx"
	"Resources/PathingTexture.ixx"
	"Resources/QIconResource.cpp"

	"Resources/SkinnedMesh/RenderNode.ixx"
	"Resources/SkinnedMesh/SkeletalModelInstance.cpp"

	"Menus/DoodadPalette.cpp"
	
	
	"Menus/MapInfoEditor.cpp"
	"Menus/Minimap.cpp"
	"Menus/Palette.cpp"
	"Menus/PathingPalette.cpp"
	"Menus/SettingsEditor.cpp"
	"Menus/TerrainPalette.cpp"
	"Menus/UnitPalette.cpp"
	"Menus/TilePather.cpp"
	"Menus/TilePicker.cpp"
	"Menus/TileSetter.cpp"
	"Menus/Selections.cpp"
	"Menus/ObjectEditor.cpp"

	"Models/SingleModel.cpp"
	"Models/TableModel.cpp"
	"Models/BaseTreeModel.cpp"
	"Models/UnitTreeModel.cpp"
	"Models/DoodadTreeModel.cpp"
	"Models/ItemTreeModel.cpp"
	"Models/AbilityTreeModel.cpp"
	"Models/BuffTreeModel.cpp"
	"Models/UpgradeTreeModel.cpp"
	"Models/UnitListModel.cpp"
	"Models/DoodadListModel.cpp"
	"Models/DestructableListModel.cpp"
	"Models/DestructibleTreeModel.cpp"
	"Models/DestructibleTreeModel.h"

	"Custom Widgets/AspectRatioPixmapLabel.cpp"
	"Custom Widgets/ColorButton.cpp"
	"Custom Widgets/QRibbon.cpp"
	"Custom Widgets/UnitSelector.cpp"
	"Custom Widgets/GenericSelectorList.cpp"
	"Custom Widgets/IconView.cpp"
	"Custom Widgets/FlowLayout.cpp"
	

	"ModelEditor/ModelEditorCamera.cpp"
	"ModelEditor/ModelEditor.cpp"
	"ModelEditor/ModelEditorGLWidget.cpp"

	"QtImgui/ImGuiRenderer.cpp"
	"QtImgui/QtImGui.cpp"

	"Utilities/Timer.ixx"
)
```

`src/Custom Widgets/AspectRatioPixmapLabel.cpp`:

```cpp
#include "AspectRatioPixmapLabel.h"

#include <QPainter>
#include <QPixmap>

QPixmap AspectRatioPixmapLabel::get_scaled_pixmap(bool grid_lines) {
	QPixmap new_pixmap(width(), height());

	QPainter painter(&new_pixmap);
	painter.fillRect(0, 0, width(), height(), Qt::black);

	QPixmap scaled_pixmap = pixmap.scaled(width(), height(), Qt::KeepAspectRatio);
	horizontal_border = (width() - scaled_pixmap.width()) / 2.f;
	vertical_border = (height() - scaled_pixmap.height()) / 2.f;

	painter.drawPixmap(horizontal_border, vertical_border, scaled_pixmap);


	/*if (grid_lines) {
		auto tt = new_pixmap.width();
		auto ttt = pixmap.width();

		const int horizontal_spacing = new_pixmap.width() / pixmap.width();
		const int vertical_spacing = new_pixmap.height() / pixmap.height();

		if (horizontal_spacing > 2) {
			for (int i = 1; i < pixmap.width(); i++) {
				painter.drawLine(i * horizontal_spacing, 0, i * horizontal_spacing, new_pixmap.height());
			}
		}

		if (vertical_spacing > 2) {
			for (int j = 1; j < pixmap.height(); j++) {
				painter.drawLine(0, vertical_spacing * j, new_pixmap.width(), vertical_spacing * j);
			}
		}
		painter.end();
	}*/

	return new_pixmap;
}

void AspectRatioPixmapLabel::setPixmap(const QPixmap& p) {
	pixmap = p;

	if (pixmap.isNull()) {
		return;
	}

	QLabel::setPixmap(get_scaled_pixmap(false));
}

void AspectRatioPixmapLabel::resizeEvent(QResizeEvent* e) {
	if (pixmap.isNull()) {
		return;
	}

	QLabel::setPixmap(get_scaled_pixmap(false));
}
```

`src/Custom Widgets/AspectRatioPixmapLabel.h`:

```h
#pragma once
#include <QLabel>

class AspectRatioPixmapLabel : public QLabel {
	Q_OBJECT

	QPixmap pixmap;

	QPixmap get_scaled_pixmap(bool grid_lines = false);

public:
	AspectRatioPixmapLabel() {
		setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
	}
	using QLabel::QLabel;

	int horizontal_border;
	int vertical_border;

public slots:
	void setPixmap(const QPixmap&);
	void resizeEvent(QResizeEvent*) override;
};
```

`src/Custom Widgets/ColorButton.cpp`:

```cpp
#include "ColorButton.h"

#include <QColorDialog>

ColorButton::ColorButton(QWidget* parent) : QPushButton(parent) {
	connect(this, &QPushButton::clicked, this, &ColorButton::changeColor);
}

void ColorButton::changeColor() {
	QColor newColor = QColorDialog::getColor(color, parentWidget());
	if (newColor != color) {
		setColor(newColor);
	}
}

void ColorButton::setColor(const QColor& new_color) {
	color = new_color;

	int delta = color.red() * 0.299 + color.green() * 0.587 + color.blue() * 0.114;
	QColor text_color = QColor((255 - delta < 105) ? Qt::black : Qt::white);

	setStyleSheet("border-color: " + color.name() + "; " + QString("background-color: ") + color.name() + "; color: " + text_color.name());
}

const QColor& ColorButton::getColor() {
	return color;
}

glm::vec4 ColorButton::get_glm_color() const {
	return { color.red(), color.green(), color.blue(), color.alpha() };
}
```

`src/Custom Widgets/ColorButton.h`:

```h
#pragma once

#include <QPushButton>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

class ColorButton : public QPushButton {
	Q_OBJECT
public:
	ColorButton(QWidget* parent);

	void setColor(const QColor& color);
	const QColor& getColor();
	glm::vec4 get_glm_color() const;

public slots:
	void changeColor();

private:
	QColor color;
};
```

`src/Custom Widgets/FlowLayout.cpp`:

```cpp
#include "FlowLayout.h"

#include <QStyle>
#include <QWidget>

FlowLayout::FlowLayout(QWidget *parent, const int margin, const int h_spacing, const int v_spacing) : QLayout(parent), h_space(h_spacing), v_space(v_spacing) {
	setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::FlowLayout(const int margin, const int hSpacing, const int vSpacing) : h_space(hSpacing), v_space(vSpacing) {
	setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::~FlowLayout() {
	QLayoutItem *item;
	while ((item = FlowLayout::takeAt(0)))
		delete item;
}

void FlowLayout::addItem(QLayoutItem *item) {
	item_list.append(item);
}

void FlowLayout::insert_widget(const int index, QWidget* widget) {
	addWidget(widget);
	item_list.move(indexOf(widget), index);
}

void FlowLayout::move_widget(const int index, QWidget* widget) {
	if (index >= 0 && index < count()) {
		item_list.move(indexOf(widget), index);
		update();
	}
}

int FlowLayout::horizontal_spacing() const {
	return spacing();
	//if (h_space >= 0) {
	//	return h_space;
	//} else {
	//	return smart_spacing(QStyle::PM_LayoutHorizontalSpacing);
	//}
}

int FlowLayout::vertical_spacing() const {
	if (v_space >= 0) {
		return v_space;
	} else {
		return smart_spacing(QStyle::PM_LayoutVerticalSpacing);
	}
}

int FlowLayout::count() const {
	return item_list.size();
}

QLayoutItem *FlowLayout::itemAt(const int index) const {
	return item_list.value(index);
}

QLayoutItem *FlowLayout::takeAt(const int index) {
	if (index >= 0 && index < item_list.size())
		return item_list.takeAt(index);
	else
		return nullptr;
}

Qt::Orientations FlowLayout::expandingDirections() const {
	return Qt::Orientations();
}

bool FlowLayout::hasHeightForWidth() const {
	return true;
}


//int FlowLayout::heightForWidth(const int width) const {
//	const int height = do_layout(QRect(0, 0, width, 0), true);
//	return height;
//}

int FlowLayout::heightForWidth(const int width) const {
	const int height = do_layout(QRect(0, 0, width, 0), true, nullptr); // jpo38: set added parameter to NULL here
	return height;
}

//void FlowLayout::setGeometry(const QRect &rect) {
//	QLayout::setGeometry(rect);
//	do_layout(rect, false);
//}

void FlowLayout::setGeometry(const QRect &rect) {
	QLayout::setGeometry(rect);

	const QSize oldSize = min_size;
	do_layout(rect, false, &min_size);
	if (oldSize != min_size) {
		// force layout to consider new minimum size!
		invalidate();
	}
}

QSize FlowLayout::sizeHint() const {
	return minimumSize();
}

//QSize FlowLayout::minimumSize() const {
//	QSize size;
//	for (auto&& item : item_list) {
//		size = size.expandedTo(item->minimumSize());
//	}
//
//	size += QSize(2 * margin(), 2 * margin());
//	return size;
//}

QSize FlowLayout::minimumSize() const {
	return min_size;
}

QList<QLayoutItem*> FlowLayout::items() const {
	return item_list;
}

void FlowLayout::clear() {
	for (auto&& i : item_list) {
		i->widget()->deleteLater();
		delete i;
	}
	item_list.clear();
}

//int FlowLayout::do_layout(const QRect &rect, const bool test_only) const {
//	int left, top, right, bottom;
//	getContentsMargins(&left, &top, &right, &bottom);
//	QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
//	int x = effectiveRect.x();
//	int y = effectiveRect.y();
//	int lineHeight = 0;
//
//	for (auto&& item : item_list) {
//		QWidget *wid = item->widget();
//		int spaceX = horizontal_spacing();
//		if (spaceX == -1)
//			spaceX = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
//		int spaceY = vertical_spacing();
//		if (spaceY == -1)
//			spaceY = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
//		int nextX = x + item->sizeHint().width() + spaceX;
//		if (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {
//			x = effectiveRect.x();
//			y = y + lineHeight + spaceY;
//			nextX = x + item->sizeHint().width() + spaceX;
//			lineHeight = 0;
//		}
//
//		if (!test_only)
//			item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));
//
//		x = nextX;
//		lineHeight = qMax(lineHeight, item->sizeHint().height());
//	}
//	return y + lineHeight - rect.y() + bottom;
//}

int FlowLayout::do_layout(const QRect &rect, const bool test_only, QSize* p_min_size) const {
	int left, top, right, bottom;
	getContentsMargins(&left, &top, &right, &bottom);
	QRect effective_rect = rect.adjusted(+left, +top, -right, -bottom);
	int x = effective_rect.x();
	int y = effective_rect.y();
	int line_height = 0;

	// jpo38: store max X
	int max_x = 0;

	for (auto&& item : item_list) {
		QWidget *wid = item->widget();
		int space_x = horizontal_spacing();
		if (space_x == -1)
			space_x = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
		int space_y = vertical_spacing();
		if (space_y == -1)
			space_y = wid->style()->layoutSpacing(QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
		int next_x = x + item->sizeHint().width() + space_x;
		if (next_x - space_x > effective_rect.right() && line_height > 0) {
			x = effective_rect.x();
			y = y + line_height + space_y;
			next_x = x + item->sizeHint().width() + space_x;
			line_height = 0;
		}

		if (!test_only)
			item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));

		// jpo38: update max X based on current position
		max_x = qMax(max_x, x + item->sizeHint().width() - rect.x() + left);

		x = next_x;
		line_height = qMax(line_height, item->sizeHint().height());
	}

	// jpo38: save height/width as max height/xidth in p_min_size is specified
	const int height = y + line_height - rect.y() + bottom;
	if (p_min_size) {
		p_min_size->setHeight(height);
		p_min_size->setWidth(max_x);
	}
	return height;
}

int FlowLayout::smart_spacing(const QStyle::PixelMetric pm) const {
	QObject *parent = this->parent();
	if (!parent) {
		return -1;
	} else if (parent->isWidgetType()) {
		QWidget *pw = dynamic_cast<QWidget *>(parent);
		return pw->style()->pixelMetric(pm, nullptr, pw);
	} else {
		return dynamic_cast<QLayout *>(parent)->spacing();
	}
}
```

`src/Custom Widgets/FlowLayout.h`:

```h
#pragma once

#include <QLayout>
#include <QLayoutItem>
#include <QStyle>

// FlowLayout is a gridlike layout that will adjust the position of the items according to screen width

class FlowLayout : public QLayout {
public:
	explicit FlowLayout(QWidget *parent, int margin = -1, int h_spacing = -1, int v_spacing = -1);
	explicit FlowLayout(int margin = -1, int h_spacing = -1, int v_spacing = -1);
	~FlowLayout();

	void addItem(QLayoutItem *item) override;
	void insert_widget(int index, QWidget* widget);
	void move_widget(int index, QWidget* widget);
	int horizontal_spacing() const;
	int vertical_spacing() const;
	Qt::Orientations expandingDirections() const override;
	bool hasHeightForWidth() const override;
	int heightForWidth(int) const override;
	int count() const override;
	QLayoutItem *itemAt(int index) const override;
	QSize minimumSize() const override;
	void setGeometry(const QRect &rect) override;
	QSize sizeHint() const override;
	QLayoutItem *takeAt(int index) override;
	QList<QLayoutItem*> items() const;
	void clear();

private:
	int do_layout(const QRect &rect, bool test_only, QSize* p_min_size) const;
	int smart_spacing(QStyle::PixelMetric pm) const;

	QSize min_size;
	QList<QLayoutItem *> item_list;
	int h_space;
	int v_space;
};
```

`src/Custom Widgets/GenericSelectorList.cpp`:

```cpp
//#include "GenericSelectorList.h"
//
//#include <QLineEdit>
//#include <QComboBox>
//#include <QDialog>
//#include <QDialogButtonBox>
//#include <QListWidget>
//#include <QLayout>
//#include <QPushButton>
//
//GenericSelectorList::GenericSelectorList(QWidget* parent) : QDialog(parent) {
//	QDialog* dialog = new QDialog(parent, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
//	dialog->resize(256, 360);
//	dialog->setWindowModality(Qt::WindowModality::WindowModal);
//
//	QVBoxLayout* layout = new QVBoxLayout(dialog);
//
//	QListWidget* list = new QListWidget;
//	list->setObjectName("unitList");
//	list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
//	layout->addWidget(list);
//
//	QHBoxLayout* hbox = new QHBoxLayout;
//
//	QPushButton* add = new QPushButton("Add");
//	QPushButton* remove = new QPushButton("Remove");
//	remove->setDisabled(true);
//	hbox->addWidget(add);
//	hbox->addWidget(remove);
//	layout->addLayout(hbox);
//	connect(add, &QPushButton::clicked, [=]() {
//		QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
//		selectdialog->resize(300, 560);
//		selectdialog->setWindowModality(Qt::WindowModality::WindowModal);
//
//		QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);
//
//		UnitSelector* selector = new UnitSelector(selectdialog);
//		selectlayout->addWidget(selector);
//
//		QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
//		connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
//		connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
//		selectlayout->addWidget(buttonBox2);
//
//		connect(selector, &UnitSelector::unitSelected, [selectdialog, list](const std::string& id) {
//			QListWidgetItem* item = new QListWidgetItem;
//			item->setText(QString::fromStdString(units_slk.data("name", id)));
//			item->setData(Qt::StatusTipRole, QString::fromStdString(id));
//			auto one = units_slk.row_headers.at(id);
//			auto two = units_slk.column_headers.at("art");
//			item->setIcon(units_table->data(units_table->index(one, two), Qt::DecorationRole).value<QIcon>());
//			list->addItem(item);
//			selectdialog->close();
//		});
//
//		connect(selectdialog, &QDialog::accepted, selector, &UnitSelector::forceSelection);
//
//		selectdialog->show();
//		selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
//	});
//	connect(remove, &QPushButton::clicked, [=]() {
//		for (auto i : list->selectedItems()) {
//			delete i;
//		}
//	});
//	connect(list, &QListWidget::itemSelectionChanged, [=]() {
//		remove->setEnabled(list->selectedItems().size() > 0);
//	});
//
//	QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
//	connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
//	connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
//	layout->addWidget(buttonBox);
//
//	dialog->show();
//}
```

`src/Custom Widgets/GenericSelectorList.h`:

```h
//#pragma once
//
//#include <QDialog>
//
//class GenericSelectorList : public QDialog {
//
//public:
//	GenericSelectorList(QWidget* parent = nullptr);
//};
```

`src/Custom Widgets/IconView.cpp`:

```cpp
#include "IconView.h"
#include "Globals.h"

#include <fstream>

#include <QVBoxLayout>
#include <QGridLayout>
#include <QPushButton>
#include <QScrollArea>
#include <QListView>
#include <QFile>
#include <QJsonDocument>
#include <QJsonArray>
#include <QJsonObject>
#include <QLabel>

#include "fmt/format.h"

std::unordered_map<std::string, std::shared_ptr<QIconResource>> icon_cache;

IconModel::IconModel(QObject* parent) : QAbstractListModel(parent) {
	//std::unordered_map<std::string, QString> icons_map;

	//for (const auto& [key, values] : units_slk.base_data) {
	//	if (!values.contains("art")) {
	//		continue;
	//	}

	//	//std::string art_path = values.at("art");
	//	std::string art_path = to_lowercase_copy(values.at("art"));
	//	art_path = fs::path(art_path).replace_extension("").string();
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);
	//		QString new_data = QString::fromStdString(values.at("name"));
	//		if (!data.contains(new_data)) {
	//			data += ", " + new_data;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, QString::fromStdString(values.at("name")));
	//	}
	//}

	//for (const auto& [key, values] : items_slk.base_data) {
	//	if (!values.contains("art")) {
	//		continue;
	//	}

	//	//std::string art_path = values.at("art");
	//	std::string art_path = to_lowercase_copy(values.at("art"));
	//	art_path = fs::path(art_path).replace_extension("").string();
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);
	//		QString new_data = QString::fromStdString(values.at("name"));
	//		if (!data.contains(new_data)) {
	//			data += ", " + new_data;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, QString::fromStdString(values.at("name")));
	//	}
	//}

	//for (const auto& [key, values] : buff_slk.base_data) {
	//	if (!values.contains("buffart")) {
	//		continue;
	//	}

	//	QString tags;
	//	if (!values.contains("bufftip") && !values.contains("editorname")) {
	//		fmt::print("Missing buff name: {}\n", key);
	//		continue;
	//	} else if (!values.contains("bufftip")) {
	//		tags = QString::fromStdString(values.at("editorname"));
	//	} else {
	//		tags = QString::fromStdString(values.at("bufftip"));
	//	}
	//	
	//	//std::string art_path = values.at("buffart");
	//	std::string art_path = to_lowercase_copy(values.at("buffart"));
	//	art_path = fs::path(art_path).replace_extension("").string();
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);

	//		if (!data.contains(tags)) {
	//			data += ", " + tags;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, tags);
	//	}
	//}

	//for (const auto& [key, values] : abilities_slk.base_data) {
	//	if (!values.contains("art")) {
	//		continue;
	//	}

	//	QString tags;
	//	if (values.contains("name")) {
	//		tags = QString::fromStdString(values.at("name"));
	//	} else if (values.contains("tip")) {
	//		tags = QString::fromStdString(values.at("tip"));
	//	} else {
	//		fmt::print("Missing ability name: {}\n", key);
	//		continue;
	//	}
	//	std::string art_path = to_lowercase_copy(values.at("art"));
	//	art_path = fs::path(art_path).replace_extension("").string();

	//	//std::string art_path = values.at("art");
	//	art_path = split(art_path, ',').front();

	//	if (icons_map.contains(art_path)) {
	//		QString& data = icons_map.at(art_path);
	//		if (!data.contains(tags)) {
	//			data += ", " + tags;
	//		}
	//	} else {
	//		icons_map.emplace(art_path, tags);
	//	}
	//}

	//for (const auto& i : fs::directory_iterator("C:/Users/User/Desktop/Warcraft/MPQContent/1.32.x/_hd.w3mod/replaceabletextures/commandbuttons")) {
	//	fs::path path = i.path().lexically_relative("C:/Users/User/Desktop/Warcraft/MPQContent/1.32.x/_hd.w3mod");
	//	path.replace_extension("");
	//	if (icons_map.contains(path.string())) {
	//		continue;
	//	}

	//	icons_map.emplace(path.string(), QString::fromStdString(path.stem().string()).remove(0, 3));
	//}

	//QJsonDocument json;
	//QJsonArray array;
	//for (const auto& [key, value] : icons_map) {
	//	icons.push_back({ key, value });
	//	QJsonObject object;
	//	object["src"] = QString::fromStdString(key);
	//	
	//	QJsonArray raaaa;
	//	auto parts = value.split(", ");
	//	for (const auto& i : parts) {
	//		raaaa.append(i);
	//	}
	//	object["tags"] = raaaa;
	//
	//	array.append(object);
	//}
	//json.setArray(array);
	//std::ofstream file("C:/Users/User/stack/Projects/HiveWE/HiveWE/Data/Warcraft/icon_tags.json");
	//std::string output = json.toJson().toStdString();
	//file.write(output.data(), output.size());
	//file.close();

	QFile file(fs::path("Data/Warcraft/icon_tags.json"));
	file.open(QIODevice::ReadOnly);

	QJsonParseError error;
	QJsonDocument json = QJsonDocument::fromJson(file.readAll(), &error);
	file.close();

	if (json.isNull()) {
		fmt::print("Error parsing icon_tags.json: {}", error.errorString().toStdString());
	}

	for (const auto& i : json.array()) {
		QJsonObject object = i.toObject();
		
		QJsonArray tags = object["tags"].toArray();

		QString text;
		if (tags.size()) {
			text = tags.at(0).toString();
			for (int i = 1; i < tags.size(); i++) {
				text += ", " + tags.at(i).toString();
			}
		}

		std::string string_path = object["src"].toString().toStdString() + ".dds";
		if (!hierarchy.file_exists(string_path)) {
			continue;
		}
		icons.emplace_back(string_path, text);
	}
}

QVariant IconModel::data(const QModelIndex& index, int role) const {
	switch (role) {
		case Qt::DecorationRole: {
			std::string string_path = icons[index.row()].first;

			if (icon_cache.contains(string_path)) {
				return icon_cache.at(string_path)->icon;
			} else {
				icon_cache.emplace(string_path, resource_manager.load<QIconResource>(string_path));
				return icon_cache.at(string_path)->icon;
			}
		}
		case Qt::ToolTipRole:
			return icons[index.row()].second;
		case Qt::EditRole:
			return QString::fromStdString(icons[index.row()].first);
	}

	return {};
}

IconView::IconView(QWidget* parent) : QWidget(parent) {
	model = new IconModel;

	filter->setSourceModel(model);
	filter->setFilterCaseSensitivity(Qt::CaseInsensitive);
	filter->setFilterRole(Qt::ItemDataRole::ToolTipRole);

	view->setViewMode(QListView::IconMode);
	view->setIconSize(QSize(64, 64));
	view->setResizeMode(QListView::ResizeMode::Adjust);
	view->setUniformItemSizes(true);
	view->setWordWrap(true);
	view->setWrapping(true);
	view->setModel(filter);

	QVBoxLayout* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);
	//layout->addWidget(type);
	layout->addWidget(search);
	layout->addWidget(view);

	QHBoxLayout* hlayout = new QHBoxLayout;
	hlayout->addWidget(new QLabel("Path"));
	hlayout->addWidget(finalPath);
	//layout->addWidget(finalPath);
	layout->addLayout(hlayout);
	setLayout(layout);

	type->addItem("Units");
	type->addItem("Items");
	type->addItem("Abilities");
	type->addItem("Upgrades");
	type->addItem("Buffs");
	search->setPlaceholderText("Search Icons");

	//connect(type, &QComboBox::currentTextChanged, filter, &QSortFilterProxyModel::setFilterFixedString);
	connect(search, &QLineEdit::textEdited, filter, &QSortFilterProxyModel::setFilterFixedString);

	connect(view->selectionModel(), &QItemSelectionModel::selectionChanged, [&]() {
		if (!view->currentIndex().isValid()) {
			finalPath->clear();
			return;
		}
		
		finalPath->setText(filter->data(view->currentIndex(), Qt::EditRole).toString());
	});
}

QString IconView::currentIconPath() {
	return finalPath->text();
}

void IconView::setCurrentIconPath(QString path) {
	finalPath->setText(path);
}
```

`src/Custom Widgets/IconView.h`:

```h
#pragma once

#include <unordered_map>
#include <memory>

#include <QDialog>
#include <QComboBox>
#include <QLineEdit>
#include <QListView>
#include <QAbstractListModel>
#include <QSortFilterProxyModel>

#include "QIconResource.h"

class IconModel : public QAbstractListModel {
	int rowCount(const QModelIndex& parent = QModelIndex()) const override {
		return static_cast<int>(icons.size());
	}

public:
	explicit IconModel(QObject* parent = nullptr);

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;

	std::vector<std::pair<std::string, QString>> icons;
};

class IconView : public QWidget {
	Q_OBJECT

	QComboBox* type = new QComboBox;
	QLineEdit* search = new QLineEdit;
	QListView* view = new QListView;
	QLineEdit* finalPath = new QLineEdit;

	QSortFilterProxyModel* filter = new QSortFilterProxyModel;
	IconModel* model;

public:
	IconView(QWidget* parent = nullptr);

	QString currentIconPath();
	void setCurrentIconPath(QString path);
};
```

`src/Custom Widgets/QRibbon.cpp`:

```cpp
#include "QRibbon.h"

#include <QStyle>
#include <QStyleOption>
#include <QPainter>

QRibbonButton::QRibbonButton(QWidget* parent) : QToolButton(parent) {
	setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding);
}

QRibbonButton::~QRibbonButton() {
	for (auto&& i : shortcuts) {
		i->setParent(nullptr);
		delete i;
	}
}

void QRibbonButton::setShortCut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to) {
	for (auto&& i : attach_to) {
		shortcuts.push_back(new QShortcut(sequence, i));
		connect(shortcuts.back(), &QShortcut::activated, this, &QToolButton::click);
		connect(shortcuts.back(), &QShortcut::activatedAmbiguously, []() { printf("kut2\n"); });
	}
}

void QRibbonButton::disableShortcuts() {
	for (auto&& i : shortcuts) {
		i->setEnabled(false);
	}
}

void QRibbonButton::enableShortcuts() {
	for (auto&& i : shortcuts) {
		i->setEnabled(true);
	}
}

void QRibbonButton::disconnectShortcuts() {
	//for (auto&& i : shortcuts) {
	//	delete i;
	//	shortcuts.clear();
	//}
}

QRibbonContainer::QRibbonContainer(QWidget* parent) : QFrame(parent) {
	setLayout(layout);
	setAutoFillBackground(true);

	layout->setContentsMargins(0, 0, 0, 0);
	layout->setSpacing(0);
}

void QRibbonContainer::addWidget(QWidget* widget, int row, int column) {
	layout->addWidget(widget, row, column);
}

void QRibbonContainer::clear() {
	QLayoutItem *item;
	while ((item = layout->takeAt(0))) {
		if (item->widget()) {
			delete item->widget();
		}
		delete item;
	}
}

QRibbonSection::QRibbonSection(QWidget* parent) : QWidget(parent) {
	setLayout(section_inner);

	section_inner->setContentsMargins(0, 0, 0, 0);
	section_inner->setSpacing(5);
	section_inner->setContentsMargins(0, 0, 0, 0);

	section_outer->setContentsMargins(0, 0, 0, 0);
	section_outer->setSpacing(0);
	section_outer->setContentsMargins(0, 0, 0, 0);

	layout()->setContentsMargins(0, 0, 0, 0);
	setContentsMargins(0, 0, 0, 0);
	
	section_inner->addLayout(section_outer);
	section_inner->addWidget(section_text);

	section_text->setAlignment(Qt::AlignBottom | Qt::AlignmentFlag::AlignHCenter);
}

void QRibbonSection::addWidget(QWidget* widget) {
	section_outer->addWidget(widget);
}

void QRibbonSection::addLayout(QLayout* layout) {
	section_outer->addLayout(layout);
}

void QRibbonSection::addSpacing(int spacing) {
	section_outer->addSpacing(spacing);
}


void QRibbonSection::setText(const QString& text) {
	section_text->setText(text);
}

QRibbonTab::QRibbonTab(QWidget* parent) : QWidget(parent) {
	setContentsMargins(0, 0, 0, 0);
	sections->addStretch(1);
	layout()->setContentsMargins(6, 4, 5, 3);
}

void QRibbonTab::disableShortcuts() {
}

void QRibbonTab::enableShortcuts() {
}

void QRibbonTab::paintEvent(QPaintEvent* event) {
	QStyleOption opt;
	opt.initFrom(this);
	QPainter p(this);
	style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);

	QWidget::paintEvent(event);
}

void QRibbonTab::addSection(QLayout* layout) {
	sections->insertLayout(0, layout);
}

void QRibbonTab::addSection(QRibbonSection* section) {
	QFrame* line = new QFrame();
	line->setObjectName("seperator");

	int count = sections->count();
	sections->insertWidget(count - 1, section);
	sections->insertWidget(count, line);
}

void QRibbonTab::addSpacer(QSpacerItem* spacer) {
	QFrame* line = new QFrame();
	line->setObjectName("seperator");

	int count = sections->count();
	sections->insertSpacerItem(count - 1, spacer);
	sections->insertWidget(count, line);
}

QRibbonMenu::QRibbonMenu(QWidget* parent) : QMenu(parent) {
	base->setContentsMargins(1, 1, 1, 1);
	base->setSpacing(0);
	actions->setContentsMargins(0, 0, 0, 0);

	QFrame* line = new QFrame();
	line->setObjectName("verticalSeperator");

	base->addLayout(actions);
	base->addWidget(line);
	//base->addLayout(frequent_places);

	setLayout(base);

	//frequent_places->setContentsMargins(0, 0, 0, 0);

	//QLabel* label = new QLabel("Recent Maps");
	//label->setStyleSheet(R"(
	//	QLabel {
	//		background-color: rgb(246, 247, 248);
	//		
	//	}
	//)");

	//frequent_places->addWidget(label);
	
	//for (int i = 0; i < 5; i++) {
	//	QLabel* labell = new QLabel("test");
	//	labell->setStyleSheet(R"(
	//		QLabel::hover {
	//			background-color: rgb(233, 240, 248);
	//			border: 1px solid rgb(165, 207, 249);
	//			
	//		}
	//	)");
	//	frequent_places->addWidget(labell);
	//}
	//frequent_places->addStretch(1);
}

//bool QRibbonMenu::eventFilter(QObject *obj, QEvent *event) {
//	if (event->type() == QEvent::KeyPress) {
//		QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
//		qDebug("Ate key press %d", keyEvent->key());
//		return true;
//	} else {
//		return QObject::eventFilter(obj, event);
//	}
//}

QRibbonFileButton::QRibbonFileButton(QWidget* parent) : QToolButton(parent) {
	setText("File");
	setMenu(menu);
}

QRibbon::QRibbon(QWidget *parent) : QTabWidget(parent) {
	setCornerWidget(file, Qt::TopLeftCorner);
}

void QRibbon::addMenuItem(QAbstractButton* widget) {
	file->menu->actions->addWidget(widget);
	connect(widget, &QAbstractButton::clicked, [&]() { file->menu->close(); });
}

void QRibbon::addMenuSeperator() {
	QFrame* line = new QFrame();
	line->setObjectName("horizontalSeperator");
	file->menu->actions->addWidget(line);
}

QRibbon::~QRibbon() {
}
```

`src/Custom Widgets/QRibbon.h`:

```h
#pragma once

#include <vector>

#include <QShortcut>
#include <QToolButton>
#include <QFrame>
#include <QGridLayout>
#include <QBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QTabWidget>

class QRibbonButton : public QToolButton {
	Q_OBJECT

public:
	QRibbonButton(QWidget* parent = nullptr);
	~QRibbonButton();

	std::vector<QShortcut*> shortcuts;

	void setShortCut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to);

	void disableShortcuts();
	void enableShortcuts();
	void disconnectShortcuts();
};

class QSmallRibbonButton : public QRibbonButton {
	Q_OBJECT

  public:

	using QRibbonButton::QRibbonButton;


	//QSmallRibbonButton(QWidget* parent = nullptr);
	//~QSmallRibbonButton();
};

class QRibbonContainer : public QFrame {
	Q_OBJECT

	QGridLayout* layout = new QGridLayout;

public:
	QRibbonContainer(QWidget* parent = nullptr);

	void addWidget(QWidget* widget, int row, int column);
	void clear();
};

class QRibbonSection : public QWidget {
	Q_OBJECT

public:
	QLabel* section_text = new QLabel;
	QVBoxLayout* section_inner = new QVBoxLayout;
	QHBoxLayout* section_outer = new QHBoxLayout;

	QRibbonSection(QWidget* parent = nullptr);
	
	void addWidget(QWidget* widget);
	void addLayout(QLayout* layout);
	void addSpacing(int spacing);

	void setText(const QString& text);
};

class QRibbonTab : public QWidget {
	Q_OBJECT

public:
	QHBoxLayout* sections = new QHBoxLayout(this);
	
	QRibbonTab(QWidget* parent = nullptr);
	
	void addSection(QLayout* layout);
	void addSection(QRibbonSection* layout);
	void addSpacer(QSpacerItem* spacer);

	void disableShortcuts();
	void enableShortcuts();


	void paintEvent(QPaintEvent* event) override;
};


class QRibbonMenu : public QMenu {
	Q_OBJECT
public:
	QHBoxLayout* base = new QHBoxLayout;
	QVBoxLayout* actions = new QVBoxLayout;
	QVBoxLayout* frequent_places = new QVBoxLayout;

	QRibbonMenu(QWidget* parent = nullptr);

	//bool eventFilter(QObject *obj, QEvent *event);
};

class QRibbonFileButton : public QToolButton {
	Q_OBJECT
public:
	QRibbonMenu* menu = new QRibbonMenu;
	QRibbonFileButton(QWidget* parent = nullptr);
};

class QRibbon : public QTabWidget {
	Q_OBJECT

	QRibbonFileButton* file = new QRibbonFileButton;

public:
	QRibbon(QWidget *parent = nullptr);
	~QRibbon();

	void addMenuItem(QAbstractButton* widget);
	void addMenuSeperator();
};

```

`src/Custom Widgets/UnitSelector.cpp`:

```cpp
#include "UnitSelector.h"
#include "Globals.h"
#include <QVBoxLayout>

UnitSelector::UnitSelector(QWidget* parent) : QWidget(parent) {
	list_model = new UnitListModel(this);
	list_model->setSourceModel(units_table);

	filter_model = new UnitListFilter(this);
	filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	filter_model->setSourceModel(list_model);
	filter_model->sort(0, Qt::AscendingOrder);

	race = new QComboBox(this);
	search = new QLineEdit(this);
	units = new QListView(this);

	search->setPlaceholderText("Search");

	units->setModel(filter_model);

	QVBoxLayout* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);
	layout->addWidget(race);
	layout->addWidget(search);
	layout->addWidget(units);
	setLayout(layout);

	for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
		if (key == "Sort" || key == "NumValues") {
			continue;
		}
		race->addItem(QString::fromStdString(value[1]), QString::fromStdString(value[0]));
	}

	connect(race, QOverload<int>::of(&QComboBox::currentIndexChanged), [&]() {
		filter_model->setFilterRace(race->currentData().toString());
	});

	connect(search, &QLineEdit::textEdited, filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(search, &QLineEdit::returnPressed, [&]() {
		units->setCurrentIndex(units->model()->index(0, 0));
		units->setFocus();
	});

	connect(units, &QListView::clicked, [&](const QModelIndex& index) {
		const int row = filter_model->mapToSource(index).row();
		emit unitSelected(units_slk.index_to_row.at(row));
	});
	connect(units, &QListView::activated, [&](const QModelIndex& index) {
		const int row = filter_model->mapToSource(index).row();
		emit unitSelected(units_slk.index_to_row.at(row));
	});
}

void UnitSelector::forceSelection() {
	if (units->selectionModel()->selectedRows().isEmpty()) {
		return;
	}
	QModelIndex index = units->selectionModel()->selectedRows().front();
	if (!index.isValid()) {
		return;
	}
	const int row = filter_model->mapToSource(index).row();
	emit unitSelected(units_slk.index_to_row.at(row));
}
```

`src/Custom Widgets/UnitSelector.h`:

```h
#pragma once

#include "UnitListModel.h"

#include <QListView>
#include <QComboBox>
#include <QLineEdit>

class UnitSelector : public QWidget {
	Q_OBJECT

public:
	UnitSelector(QWidget* parent = nullptr);

	UnitListModel* list_model;
	UnitListFilter* filter_model;

	QComboBox* race;
	QLineEdit* search;
	QListView* units;

public slots:
	void forceSelection();

signals:
	void unitSelected(std::string id);
};
```

`src/File Formats/BLP.ixx`:

```ixx
module;


#include <cmath>
#include <fmt/format.h>

#include <turbojpeg.h>

export module BLP;

import BinaryReader;

namespace blp {
	export uint8_t* load(BinaryReader& reader, int& width, int& height, int& channels) {
		const std::string magic_number = reader.read_string(4);
		if (magic_number != "BLP1") {
			fmt::print("Wrong magic number, should be BLP1, is {}\n", magic_number);
			return nullptr;
		}

		int content_type = reader.read<uint32_t>();
		int alpha_bits = reader.read<uint32_t>();

		width = reader.read<uint32_t>();
		height = reader.read<uint32_t>();
		channels = 4;

		// extra and has_mipmaps
		reader.advance(8);

		uint8_t* data = new uint8_t[width * height * 4];

		auto mipmap_offsets = reader.read_vector<uint32_t>(16);
		auto mipmap_sizes = reader.read_vector<uint32_t>(16);

		if (content_type == 0) { // jpeg
			tjhandle handle = tjInitDecompress();
			const uint32_t header_size = reader.read<uint32_t>();
			auto header_position = reader.buffer.begin() + reader.position;

			// Move header in front of content
			std::copy(header_position, header_position + header_size, reader.buffer.begin() + mipmap_offsets[0] - header_size);
			header_position = reader.buffer.begin() + mipmap_offsets[0] - header_size;

			const int success = tjDecompress2(handle, reader.buffer.data() + mipmap_offsets[0] - header_size, header_size + mipmap_sizes[0], data, width, 0, height, TJPF_CMYK, 0); // Actually BGRA

			if (success == -1) {
				fmt::print("Error loading JPEG data from BLP {}\n", tjGetErrorStr());
			}
			tjDestroy(handle);
		} else if (content_type == 1) { // direct
			auto header = reader.read_vector<uint32_t>(256);

			// There might be fake mipmaps or the first mipmap could start within the 256 bytes of the colour header
			// Thus we cannot rely purely on advancing the position by mipmap sizes alone
			reader.position = mipmap_offsets[0];
			auto rgb = reader.read_vector<uint8_t>(width * height);

			if (alpha_bits == 0) {
				for (size_t j = 0; j < rgb.size(); j++) {
					// + (255 << 24) because the header alpha value is always 0 so we add 255
					reinterpret_cast<uint32_t*>(data)[j] = header[rgb[j]] + (255 << 24);
				}
			} else {
				auto alpha = reader.read_vector<uint8_t>((width * height * alpha_bits + 7) / 8);

				for (size_t j = 0; j < rgb.size(); j++) {
					reinterpret_cast<uint32_t*>(data)[j] = header[rgb[j]];
					switch (alpha_bits) {
						case 8:
							data[j * 4 + 3] = alpha[j];
							break;
						case 4: {
							uint8_t byte = alpha[j / 2];
							data[j * 4 + 3] = j % 2 ? byte >> 4 : byte & 0b00001111;
							break;
						}
						case 1:
							data[j * 4 + 3] = alpha[j / 8] & (1 << (j % 8));
							break;
					}
				}
			}
		}

		// Data is BGR(A) instead of RGB(A). While GPUs can natively load BGRA some of the code would have to deal with both RGBA and BGRA which is a pita
		for (int i = 0; i < width * height; i++) {
			std::swap(data[i * channels], data[i * channels + 2]);
		}

		return data;
	}
} // namespace blp
```

`src/File Formats/CASC.ixx`:

```ixx
module;

#include <filesystem>
#include <vector>
#include <span>

#define __CASCLIB_SELF__
#define WIN32_LEAN_AND_MEAN
#include <CascLib.h>

//#include "no_init_allocator.h"
#include "fmt/format.h"

export module CASC;

import no_init_allocator;

namespace fs = std::filesystem;

// A thin wrapper around CascLib https://github.com/ladislav-zezula/CascLib
namespace casc {
	export class File {
	  public:
		HANDLE handle = nullptr;

		File() = default;
		~File() {
			close();
		}
		File(File&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		File(const File&) = default;
		File& operator=(const File&) = default;
		File& operator=(File&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		// std::span<uint8_t> read() const;
		std::vector<uint8_t, default_init_allocator<uint8_t>> read() const {
			const uint32_t size = CascGetFileSize(handle, 0);
			std::vector<uint8_t, default_init_allocator<uint8_t>> buffer(size);

#ifdef _MSC_VER
			unsigned long bytes_read;
#else
			unsigned bytes_read;
#endif
			const bool success = CascReadFile(handle, buffer.data(), size, &bytes_read);
			if (!success) {
				fmt::print("Failed to read file: {}\n", GetCascError());
			}
			return buffer;
		}
		// std::pair<std::unique_ptr<uint8_t[]>, std::size_t> read() const;

		size_t size() const noexcept {
			return CascGetFileSize(handle, 0);
		}

		void close() const noexcept {
			CascCloseFile(handle);
		}
	};

	export class CASC {
	  public:
		HANDLE handle = nullptr;

		CASC() = default;

		explicit CASC(const fs::path& path) {
			open(path);
		}

		~CASC() {
			close();
		}

		CASC(CASC&& move)
		noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		CASC(const CASC&) = default;
		CASC& operator=(const CASC&) = delete;
		CASC& operator=(CASC&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		bool open(const fs::path& path) {
			if (handle != nullptr)
				close();
			const bool opened = CascOpenStorage(path.c_str(), CASC_LOCALE_ALL, &handle);
			if (!opened) {
				fmt::print("Error opening {} with error: {}\n", path.string(), GetCascError());
			}
			return opened;
		}

		void close() {
			CascCloseStorage(handle);
			handle = nullptr;
		}

		File file_open(const fs::path& path) const {
			File file;
			const bool opened = CascOpenFile(handle, path.string().c_str(), 0, CASC_OPEN_BY_NAME, &file.handle);
			if (!opened) {
				fmt::print("Error opening {} with error: {}\n", path.string(), GetCascError());
			}
			return file;
		}

		/// ToDo is there a better way to check if a file exists?
		bool file_exists(const fs::path& path) const {
			File file;
			return CascOpenFile(handle, path.string().c_str(), 0, CASC_OPEN_BY_NAME, &file.handle);
		}
	};
} // namespace casc
```

`src/File Formats/INI.cpp`:

```cpp
#include "INI.h"

//#include "Hierarchy.h"
#include "Utilities.h"

#include <absl/strings/str_split.h>
#include <fstream>

import Hierarchy;

namespace ini {
	INI::INI(const fs::path& path, bool local) {
		load(path, local);
	}

	void INI::load(const fs::path& path, bool local) {
		std::vector<uint8_t, default_init_allocator<uint8_t>> buffer;
		if (local) {
			std::ifstream stream(path, std::ios::binary);
			buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>());
		} else {
			buffer = hierarchy.open_file(path).buffer;
		}
		std::string_view view(reinterpret_cast<char*>(buffer.data()), buffer.size());

		// Strip byte order marking
		if (view.starts_with(std::string{ static_cast<char>(0xEF), static_cast<char>(0xBB), static_cast<char>(0xBF) })) {
			view.remove_prefix(3);
		}

		std::string_view current_section;

		while (view.size()) {
			size_t eol = view.find('\n');
			if (eol == std::string_view::npos) {
				eol = view.size() - 1;
			}

			if (view.starts_with("//") || view.starts_with(';') || view.starts_with('\n') || view.starts_with('\r')) {
				view.remove_prefix(eol + 1);
				continue;
			}

			if (view.front() == '[') {
				current_section = view.substr(1, view.find(']') - 1);
			} else {
				const size_t found = view.find_first_of('=');
				if (found == std::string_view::npos) {
					view.remove_prefix(eol + 1);
					continue;
				}

				const std::string_view key = view.substr(0, found);
				const std::string_view value = view.substr(found + 1, view.find_first_of("\r\n") - 1 - found);

				if (key.empty() || value.empty()) {
					view.remove_prefix(eol + 1);
					continue;
				}

				std::vector<std::string> parts;

				if (value.front() == '\"') {
					parts = absl::StrSplit(value, "\",\"");
				} else {
					parts = absl::StrSplit(value, ',');
				}

				// Strip off quotes at the front/back
				for (auto&& i : parts) {
					if (i.size() < 2) {
						continue;
					}
					if (i.front() == '\"') {
						i.erase(i.begin());
					}
					if (i.back() == '\"') {
						i.pop_back();
					}
				}

				ini_data[std::string(current_section)][std::string(key)] = parts;
			}
			view.remove_prefix(eol + 1);
		}
	}

	/// Replaces all values (not keys) which match one of the keys in substitution INI
	void INI::substitute(const INI& ini, const std::string& section) {
		for (auto&& [section_key, section_value] : ini_data) {
			for (auto&& [key, value] : section_value) {
				for (auto&& part : value) {
					std::string westring = ini.data(section, part);
					if (!westring.empty()) {
						part = westring;
					}
				}
			}
		}
	}

	std::map<std::string, std::vector<std::string>> INI::section(const std::string& section) const {
		if (ini_data.contains(section)) {
			return ini_data.at(section);
		} else {
			return {};
		}
	}

	void INI::set_whole_data(const std::string& section, const std::string& key, std::string value) {
		ini_data[section][key] = { value };
	}

	std::vector<std::string> INI::whole_data(const std::string& section, const std::string& key) const {
		if (ini_data.contains(section) && ini_data.at(section).contains(key)) { // ToDo C++20 contains
			return ini_data.at(section).at(key);
		} else {
			return {};
		}
	}

	bool INI::key_exists(const std::string& section, const std::string& key) const {
		return ini_data.contains(section) && ini_data.at(section).contains(key);
	}

	bool INI::section_exists(const std::string& section) const {
		return ini_data.contains(section);
	}
}
```

`src/File Formats/INI.h`:

```h
#pragma once

#include <map>
#include <vector>
#include <sstream>
#include <filesystem>
namespace fs = std::filesystem;

namespace ini {

	class INI {
	public:
		/// header to items to list of values to value
		// Use abseil absl::btree_map when they fix their C++20 branch
		std::map<std::string, std::map<std::string, std::vector<std::string>>> ini_data;

		INI() = default;
		explicit INI(const fs::path& path, bool local = false);

		void load(const fs::path& path, bool local = false);
		void substitute(const INI& ini, const std::string& section);

		std::map<std::string, std::vector<std::string>> section(const std::string& section) const;

		/// To access key data where the value of the key is comma seperated
		template<typename T = std::string>
		T data(const std::string & section, const std::string & key, const size_t argument = 0) const {
			if (ini_data.contains(section) && ini_data.at(section).contains(key) && argument < ini_data.at(section).at(key).size()) {
				if constexpr (std::is_same<T, std::string>()) {
					return ini_data.at(section).at(key)[argument];
				} else if constexpr (std::is_same<T, int>()) {
					return std::stoi(ini_data.at(section).at(key)[argument]);
				} else if constexpr (std::is_same<T, float>()) {
					return std::stof(ini_data.at(section).at(key)[argument]);
				} 
				static_assert("Type not supported. Convert yourself or add conversion here if it makes sense");
			} else {
				return T();
			}
		}

		/// Retrieves the list of key values
		std::vector<std::string> whole_data(const std::string& section, const std::string& key) const;

		/// Sets the data of a whole key
		void set_whole_data(const std::string& section, const std::string& key, std::string value);

		bool key_exists(const std::string& section, const std::string& key) const;
		bool section_exists(const std::string& section) const;
	};
}
```

`src/File Formats/JSON.ixx`:

```ixx
module;

#include <map>
#include <string>
#include <filesystem>
#include <iostream>
#include <sstream>

export module JSON;

import BinaryReader;
namespace fs = std::filesystem;

namespace json {
	export class JSON {
	  public:
		std::map<std::string, std::string> json_data;
		
		JSON() = default;

		explicit JSON(const BinaryReader& reader) {
			load(reader);
		}

		void load(const BinaryReader& reader) {
			json_data.clear();
			std::stringstream file;
			file << reader.buffer.data();
			size_t end1;
			std::string line;
			if (std::getline(file, line)) {
				if (line.front() == '[') {
					while (std::getline(file, line) && line.back() != '}') {
						// Normaly json files use ; for comments, but Blizzard uses //
						if (line.substr(0, 2) == "//" || line.empty() || line.front() == ';') {
							continue;
						}
						for (size_t i = 0; i < line.length(); i++) {
							if (line.at(i) == '/') {
								line.replace(i, 1, "\\");
							}
						}
						if (line.substr(0, 12) == "    {\"src\":\"") {
							end1 = line.find('\"', 13);
							std::string key = line.substr(12, end1 - 12);
							std::transform(key.begin(), key.end(), key.begin(), ::tolower);
							// If the segment already exists
							if (json_data.contains(key)) {
								continue;
							}
							json_data[key] = line.substr(end1 + 11, line.find('\"', end1 + 12) - end1 - 11);
						}
					}
					if (line.substr(0, 12) == "    {\"src\":\"") {
						end1 = line.find('\"', 13);
						const std::string key = line.substr(12, end1 - 12);
						// If the segment already exists
						if (json_data.contains(key)) {
						} else {
							json_data[key] = line.substr(end1 + 11, line.find('\"', end1 + 12) - end1 - 11);
						}
					}
				} else {
					std::cout << "Malformed Alias JSON\n";
				}
			}
		}

		bool exists(const std::string& file) const {
			std::string file_lower_case = file;
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(), ::tolower);
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(),
							[](char c) {if (c == '/')return '\\'; return c; });
			if (json_data.contains(file_lower_case)) {
				return true;
			}
			return false;
		}

		std::string alias(const std::string& file) const {
			std::string file_lower_case = file;
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(), ::tolower);
			std::transform(file_lower_case.begin(), file_lower_case.end(), file_lower_case.begin(),
							[](char c) {if (c == '/')return '\\'; return c; });
			return json_data.at(file_lower_case);
		}
	};
} // namespace json
```

`src/File Formats/MDX/MDLReader.cpp`:

```cpp
module;

#include <string>
#include <vector>
#include <iostream>
#include <optional>
#include <charconv>
#include <unordered_set>

#include <fmt/format.h>
#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

#include <outcome/outcome.hpp>

module MDX;

using outcome_v2_35644f5c::failure;
using outcome_v2_35644f5c::result;

namespace mdx {
#define TRY(r)                                \
	{                                         \
		if (auto optional = r; optional) {    \
			return failure(optional.value()); \
		}                                     \
	}

#define TRY_PASS(r)          \
	{                        \
		auto optional = r;   \
		if (optional) {      \
			return optional; \
		}                    \
	}

	struct MDLReader {
		std::vector<std::string_view> tokens;
		size_t position = 0;

		std::string_view current() {
			return tokens[position];
		}

		std::optional<std::string> consume(std::string_view token) {
			if (position >= tokens.size()) {
				[[unlikely]] return fmt::format("Expected: {}, but we reached the end of the file", token);
			}
			if (tokens[position] != token) {
				[[unlikely]] return fmt::format("Expected: {}, got: {}", token, tokens[position]);
			}
			position += 1;
			return std::nullopt;
		}

		template <typename F>
		std::optional<std::string> consume_any(F callback) {
			if (position >= tokens.size()) {
				[[unlikely]] return fmt::format("Expected a name/value, but we reached the end of the file");
			}
			std::optional<std::string> error = callback(tokens[position]);
			position += 1;
			if (error) {
				[[unlikely]] return error;
			}
			return std::nullopt;
		}

		template <typename F>
		std::optional<std::string> consume_quoted_string(F callback) {
			auto token = current();
			if (position >= tokens.size()) {
				[[unlikely]] return fmt::format("Expected quoted string (e.g. \"SomeName\"), but we reached the end of the file");
			}

			if (token.size() < 3 || token.front() != '\"' || token.back() != '\"') {
				[[unlikely]] return fmt::format("The name should be surrounded in quotes \"likethis\" and at least one character long, but is: {}", token);
			}

			callback(token.substr(1, token.size() - 2)); // Get rid of quotes
			position += 1;
			return std::nullopt;
		}

		template <typename F>
		std::optional<std::string> consume_attributes(
			const std::unordered_set<std::string_view>& attributes,
			const std::unordered_set<std::string_view>& chunks,
			F callback
		) {
			//if (one_of_each) {
			//	std::unordered_set<std::string> already_seen;

			//}
			
			/*while (current() != "}") {
				
			}*/

			if (attributes.contains(current())) {
				position += 1;
				if (current() == "{") {
					
				}
			}
		}
	};

	std::optional<std::string> parse_version_chunk(MDLReader& reader, MDX& mdx) {
		TRY_PASS(reader.consume("Version"));
		TRY_PASS(reader.consume("{"));
		TRY_PASS(reader.consume("FormatVersion"));

		TRY_PASS(reader.consume_any([&](std::string_view token) -> std::optional<std::string> {
			std::from_chars(token.data(), token.data() + token.size(), mdx.version);
			if (mdx.version != 800 || mdx.version != 900 || mdx.version != 1000) {
				return fmt::format("Invalid version {}, expected 800, 900, 1000", mdx.version);
			}
			return std::nullopt;
		}));

		TRY_PASS(reader.consume("}"));
	}

	std::optional<std::string> parse_model_chunk(MDLReader& reader, MDX& mdx) {
		TRY_PASS(reader.consume("Model"));

		TRY_PASS(reader.consume_quoted_string([&](std::string_view token) -> std::optional<std::string> {
			mdx.name = std::string(token);			
			return std::nullopt;
		}));

		TRY_PASS(reader.consume("{"));

		while (reader.current() != "}") {
			if (reader.current() == "BlendTime") {
				
				/*mdx.blend_time = 
				name = reader.read_string(80);
				animation_filename = reader.read_string(260);
				extent = Extent(reader);
				blend_time = reader.read<uint32_t>();*/
			}
		}

		TRY_PASS(reader.consume("}"));
	}

	result<MDX, std::string> MDX::from_mdl(std::string_view mdl) {
		MDLReader reader;

		// Tokenize
		while (mdl.size() > 1) {
			size_t pos = mdl.find_first_of(" \t\r\n,");

			if (mdl[0] == '"') {
				pos = mdl.find_first_of('\"', 1) + 1;
			}
			reader.tokens.emplace_back(mdl.substr(0, pos));

			std::cout << mdl.substr(0, pos) << "\n";

			pos = mdl.find_first_not_of(" \t\r\n,", pos);
			if (pos == std::string::npos) {
				break;
			}
			mdl.remove_prefix(pos);
		}

		MDX mdx;
		TRY(parse_version_chunk(reader, mdx));
		while (!reader.tokens.empty()) {
			if (reader.current() == "Model") {
				TRY(parse_model_chunk(reader, mdx));
			}

			return failure(fmt::format("Error reading token {}, expected a chunk type (Version/Model/Textures/etc). Make sure to match the casing", reader.current()));
		}

		return mdx;
	}

	//void MDX::from_mdl2(std::string_view mdl) {
		// tao::pegtl::string_input input(mdl.substr(0), "from_content");
		// tao::pegtl::parse<file, my_action>(input);
	//}
} // namespace mdx
```

`src/File Formats/MDX/MDLWriter.cpp`:

```cpp
module;

#include <string>
#include <fmt/format.h>
#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

module MDX;

import Timer;

namespace mdx {
	/// A minimal utility wrapper around an std::string that manages newlines, indentation and closing braces
	struct MDLWriter {
		std::string mdl;
		size_t current_indentation = 0;

		/// Writes a line and automatically handles indentation and the newline character
		void write_line(std::string_view line) {
			for (size_t i = 0; i < current_indentation; i++) {
				mdl += '\t';
			}
			mdl += line;
			mdl += '\n';
		}

		// template <typename... T>
		// void write_line(fmt::format_string<T...> fmt, T&&... args) {
		//	for (size_t i = 0; i < current_indentation; i++) {
		//		mdl += '\t';
		//	}
		//	fmt::format_to(std::back_inserter(mdl), fmt, args...);
		//	mdl += '\n';
		// }

		template <typename T>
		void write_track(const TrackHeader<T>& track_header, std::string name, T static_value) {
			if (track_header.tracks.empty()) {
				if constexpr (std::is_same_v<T, glm::vec2>) {
					write_line(fmt::format("static {} {{ {}, {} }},", name, static_value.x, static_value.y));
				} else if constexpr (std::is_same_v<T, glm::vec3>) {
					write_line(fmt::format("static {} {{ {}, {}, {} }},", name, static_value.x, static_value.y, static_value.z));
				} else if constexpr (std::is_same_v<T, glm::quat>) {
					write_line(fmt::format("static {} {{ {}, {}, {}, {} }},", name, static_value.x, static_value.y, static_value.z, static_value.w));
				} else {
					write_line(fmt::format("static {} {},", name, static_value));
				}

				// write_line(fmt::format("static {} {},", name, static_value));
			} else {
				start_group(name, [&]() {
					switch (track_header.interpolation_type) {
						case 0:
							write_line("DontInterp,");
							break;
						case 1:
							write_line("Linear,");
							break;
						case 2:
							write_line("Hermite,");
							break;
						case 3:
							write_line("Bezier,");
							break;
					}

					write_line(fmt::format("GlobalSeqId {},", track_header.global_sequence_ID));

					for (const auto& track : track_header.tracks) {
						if constexpr (std::is_same_v<T, glm::vec2>) {
							write_line(fmt::format("{}: {{ {}, {} }},", track.frame, track.value.x, track.value.y));
						} else if constexpr (std::is_same_v<T, glm::vec3>) {
							write_line(fmt::format("{}: {{ {}, {}, {} }},", track.frame, track.value.x, track.value.y, track.value.z));
						} else if constexpr (std::is_same_v<T, glm::quat>) {
							write_line(fmt::format("{}: {{ {}, {}, {}, {} }},", track.frame, track.value.x, track.value.y, track.value.z, track.value.w));
						} else {
							write_line(fmt::format("{}: {},", track.frame, track.value));
						}

						if (track_header.interpolation_type == 2 || track_header.interpolation_type == 3) {
							if constexpr (std::is_same_v<T, glm::vec2>) {
								write_line(fmt::format("InTan {{ {}, {} }},", track.inTan.x, track.inTan.y));
								write_line(fmt::format("OutTan {{ {}, {} }},", track.outTan.x, track.outTan.y));
							} else if constexpr (std::is_same_v<T, glm::vec3>) {
								write_line(fmt::format("InTan {{ {}, {}, {} }},", track.inTan.x, track.inTan.y, track.inTan.z));
								write_line(fmt::format("OutTan {{ {}, {}, {} }},", track.outTan.x, track.outTan.y, track.outTan.z));
							} else if constexpr (std::is_same_v<T, glm::quat>) {
								write_line(fmt::format("InTan {{ {}, {}, {}, {} }},", track.inTan.x, track.inTan.y, track.inTan.z, track.inTan.w));
								write_line(fmt::format("OutTan {{ {}, {}, {}, {} }},", track.outTan.x, track.outTan.y, track.outTan.z, track.outTan.w));
							} else {
								write_line(fmt::format("InTan {},", track.inTan));
								write_line(fmt::format("OutTan {},", track.outTan));
							}
						}
					}
				});
			}
		}

		void write_node(const Node& node) {
			write_line(fmt::format("ObjectId {},", node.id));
			write_line(fmt::format("Parent {},", node.parent_id));

			if (node.flags & Node::Flags::billboarded) {
				write_line("Billboarded,");
			}

			if (node.flags & Node::Flags::unfogged) {
				write_line("Unfogged,");
			}

			if (node.flags & Node::Flags::line_emitter) {
				write_line("LineEmitter,");
			}

			if (node.flags & Node::Flags::unshaded) {
				write_line("Unshaded,");
			}

			if (node.flags & Node::Flags::model_space) {
				write_line("ModelSpace,");
			}

			write_track(node.KGRT, "Rotation", glm::quat(0.f, 0.f, 0.f, 0.f));
			write_track(node.KGTR, "Translation", glm::vec3(0.0));
			write_track(node.KGSC, "Scale", glm::vec3(1.0));
		}

		template <typename T>
		void start_group(std::string name, T callback) {
			for (size_t i = 0; i < current_indentation; i++) {
				mdl += '\t';
			}
			mdl += name + " {\n";
			current_indentation += 1;
			callback();
			current_indentation -= 1;
			for (size_t i = 0; i < current_indentation; i++) {
				mdl += '\t';
			}
			mdl += "}\n";
		}
	};

	std::string MDX::to_mdl() {
		Timer timer;
		MDLWriter mdl;

		mdl.start_group("Version", [&]() {
			mdl.write_line("FormatVersion 1000,");
		});

		mdl.start_group(fmt::format("Model \"{}\"", name), [&]() {
			mdl.write_line(fmt::format("BlendTime {},", blend_time));
			mdl.write_line(fmt::format("MinimumExtent {{ {}, {}, {} }},", extent.minimum.x, extent.minimum.y, extent.minimum.z));
			mdl.write_line(fmt::format("MaximumExtent {{ {}, {}, {} }},", extent.maximum.x, extent.maximum.y, extent.maximum.z));
		});

		mdl.start_group(fmt::format("Sequences {}", sequences.size()), [&]() {
			for (const auto& i : sequences) {
				mdl.start_group(fmt::format("Anim \"{}\"", i.name), [&]() {
					mdl.write_line(fmt::format("Interval {{ {}, {} }},", i.start_frame, i.end_frame));
					mdl.write_line(fmt::format("Movespeed {},", i.movespeed));
					mdl.write_line(fmt::format("SyncPoint {},", i.sync_point));

					if (i.flags & Sequence::Flags::non_looping) {
						mdl.write_line("NonLooping,");
					}

					mdl.write_line(fmt::format("Rarity {},", i.rarity));
					mdl.write_line(fmt::format("MinimumExtent {{ {}, {}, {}, }},", i.extent.minimum.x, i.extent.minimum.y, i.extent.minimum.z));
					mdl.write_line(fmt::format("MinimumExtent {{ {}, {}, {}, }},", i.extent.maximum.x, i.extent.maximum.y, i.extent.maximum.z));
					mdl.write_line(fmt::format("BoundRadius {},", i.extent.bounds_radius));
				});
			}
		});

		mdl.start_group(fmt::format("GlobalSequences {}", global_sequences.size()), [&]() {
			for (const auto& i : global_sequences) {
				mdl.write_line(fmt::format("Duration {},", i));
			}
		});

		mdl.start_group(fmt::format("Textures {}", textures.size()), [&]() {
			for (const auto& i : textures) {
				mdl.start_group("Bitmap", [&]() {
					mdl.write_line(fmt::format("Image \"{}\",", i.file_name.string()));
					mdl.write_line(fmt::format("ReplaceableId {},", i.replaceable_id));
					if (i.flags & Texture::Flags::wrap_width) {
						mdl.write_line("WrapWidth");
					}
					if (i.flags & Texture::Flags::wrap_height) {
						mdl.write_line("WrapHeight");
					}
				});
			}
		});

		mdl.start_group(fmt::format("Materials {}", materials.size()), [&]() {
			for (const auto& material : materials) {
				mdl.start_group("Material", [&]() {
					if (material.layers[0].hd) {
						mdl.write_line("Shader \"Shader_HD_DefaultUnit\",");
						const auto& layer = material.layers[0];
						for (int i = 0; i < 6; i++) {
							switch (layer.blend_mode) {
								case 0:
									mdl.write_line("FilterMode None");
									break;
								case 1:
									mdl.write_line("FilterMode Transparent");
									break;
								case 2:
									mdl.write_line("FilterMode Blend");
									break;
								case 3:
									mdl.write_line("FilterMode Additive");
									break;
								case 4:
									mdl.write_line("FilterMode AddAlpha");
									break;
								case 5:
									mdl.write_line("FilterMode Modulate");
									break;
								case 6:
									mdl.write_line("FilterMode Modulate2x");
									break;
							}

							if (layer.shading_flags & Layer::ShadingFlags::unshaded) {
								mdl.write_line("Unshaded");
							}

							if (layer.shading_flags & Layer::ShadingFlags::unfogged) {
								mdl.write_line("Unfogged");
							}

							if (layer.shading_flags & Layer::ShadingFlags::no_depth_test) {
								mdl.write_line("NoDepthTest");
							}

							if (layer.shading_flags & Layer::ShadingFlags::no_depth_set) {
								mdl.write_line("NoDepthSet");
							}

							mdl.write_track(layer.textures.at(i).KMTF, "TextureID", layer.textures.at(i).id);
							mdl.write_track(layer.KMTA, "Alpha", layer.alpha);
							mdl.write_track(layer.KMTE, "EmissiveGain", layer.emissive_gain);
							mdl.write_track(layer.KFC3, "FresnelColor", layer.fresnel_color);
							mdl.write_track(layer.KFCA, "FresnelAlpha", layer.fresnel_opacity);
							mdl.write_track(layer.KFTC, "FresnelTeamColor", layer.fresnel_team_color);
						}
					} else {
						mdl.write_line("Shader \"\",");

						for (const auto& layer : material.layers) {
							mdl.start_group("Layer", [&]() {
								switch (layer.blend_mode) {
									case 0:
										mdl.write_line("FilterMode None");
										break;
									case 1:
										mdl.write_line("FilterMode Transparent");
										break;
									case 2:
										mdl.write_line("FilterMode Blend");
										break;
									case 3:
										mdl.write_line("FilterMode Additive");
										break;
									case 4:
										mdl.write_line("FilterMode AddAlpha");
										break;
									case 5:
										mdl.write_line("FilterMode Modulate");
										break;
									case 6:
										mdl.write_line("FilterMode Modulate2x");
										break;
								}

								if (layer.shading_flags & Layer::ShadingFlags::unshaded) {
									mdl.write_line("Unshaded");
								}

								if (layer.shading_flags & Layer::ShadingFlags::unfogged) {
									mdl.write_line("Unfogged");
								}

								if (layer.shading_flags & Layer::ShadingFlags::no_depth_test) {
									mdl.write_line("NoDepthTest");
								}

								if (layer.shading_flags & Layer::ShadingFlags::no_depth_set) {
									mdl.write_line("NoDepthSet");
								}

								mdl.write_track(layer.textures.at(0).KMTF, "TextureID", layer.textures.at(0).id);
								mdl.write_track(layer.KMTA, "Alpha", layer.alpha);
								mdl.write_track(layer.KMTE, "EmissiveGain", layer.emissive_gain);
								mdl.write_track(layer.KFC3, "FresnelColor", layer.fresnel_color);
								mdl.write_track(layer.KFCA, "FresnelAlpha", layer.fresnel_opacity);
								mdl.write_track(layer.KFTC, "FresnelTeamColor", layer.fresnel_team_color);
							});
						}
					}
				});
			}
		});

		for (const auto& geoset : geosets) {
			mdl.start_group("Geoset", [&]() {
				mdl.start_group(fmt::format("Vertices {}", geoset.vertices.size()), [&]() {
					for (const auto& vertex : geoset.vertices) {
						mdl.write_line(fmt::format("{{ {}, {}, {} }},", vertex.x, vertex.y, vertex.z));
					}
				});

				mdl.start_group(fmt::format("Normals {}", geoset.normals.size()), [&]() {
					for (const auto& normal : geoset.normals) {
						mdl.write_line(fmt::format("{{ {}, {}, {} }},", normal.x, normal.y, normal.z));
					}
				});

				for (const auto& i : geoset.texture_coordinate_sets) {
					mdl.start_group(fmt::format("TVertices {}", i.size()), [&]() {
						for (const auto& uv : i) {
							mdl.write_line(fmt::format("{{ {}, {} }},", uv.x, uv.y));
						}
					});
				}

				mdl.start_group(fmt::format("Tangents {}", geoset.tangents.size()), [&]() {
					for (const auto& tangent : geoset.tangents) {
						mdl.write_line(fmt::format("{{ {}, {}, {}, {} }},", tangent.x, tangent.y, tangent.z, tangent.w));
					}
				});

				mdl.start_group(fmt::format("SkinWeights {}", geoset.skin.size() / 8), [&]() {
					for (size_t i = 0; i < geoset.skin.size() / 8; i++) {
						mdl.write_line(fmt::format("{}, {}, {}, {}, {}, {}, {}, {},",
												   geoset.skin[i * 8],
												   geoset.skin[i * 8 + 1],
												   geoset.skin[i * 8 + 2],
												   geoset.skin[i * 8 + 3],
												   geoset.skin[i * 8 + 4],
												   geoset.skin[i * 8 + 5],
												   geoset.skin[i * 8 + 6],
												   geoset.skin[i * 8 + 7]));
					}
				});

				mdl.start_group(fmt::format("Faces {}", geoset.faces.size()), [&]() {
					mdl.start_group("Triangles", [&]() { // Yall mfs gonna be having triangles, I ain't in the quad business
						std::string triangles;
						for (const auto& face : geoset.faces) {
							triangles += fmt::format("{}, ", face);
						}

						mdl.write_line(fmt::format("{{ {} }}", triangles));
					});
				});

				mdl.write_line(fmt::format("MinimumExtent {{ {}, {}, {} }},", geoset.extent.minimum.x, geoset.extent.minimum.z, geoset.extent.minimum.z));
				mdl.write_line(fmt::format("MaximumExtent {{ {}, {}, {} }},", geoset.extent.maximum.x, geoset.extent.maximum.z, geoset.extent.maximum.z));
				mdl.write_line(fmt::format("BoundsRadius {},", geoset.extent.bounds_radius));

				for (const auto& i : geoset.extents) {
					mdl.start_group("Anim", [&]() {
						mdl.write_line(fmt::format("MinimumExtent {{ {}, {}, {} }},", i.minimum.x, i.minimum.z, i.minimum.z));
						mdl.write_line(fmt::format("MaximumExtent {{ {}, {}, {} }},", i.maximum.x, i.maximum.z, i.maximum.z));
						mdl.write_line(fmt::format("BoundsRadius {},", i.bounds_radius));
					});
				}

				// mdl.start_group(fmt::format("Group {} {}", geoset.matrix_groups), [&]() {
				//	for (const auto& face : geoset.matrix_groups) {
				//		mdl.write_line(fmt::format("Matrices {{ {} }}", ));
				//	}
				// });

				mdl.write_line(fmt::format("MaterialID {},", geoset.material_id));
				mdl.write_line(fmt::format("SelectionGroup {},", geoset.selection_group));
				mdl.write_line("LevelOfDetail 0,");
				mdl.write_line(fmt::format("Name {},", geoset.lod_name));
			});
		}

		for (const auto& geoset_anim : animations) {
			mdl.start_group("GeosetAnim", [&]() {
				mdl.write_track(geoset_anim.KGAO, "Alpha", geoset_anim.alpha);
				mdl.write_track(geoset_anim.KGAC, "Color", geoset_anim.color);
				mdl.write_line(fmt::format("GeosetId {}", geoset_anim.geoset_id));
			});
		}

		for (const auto& bone : bones) {
			mdl.start_group(fmt::format("Bone \"{}\"", bone.node.name), [&]() {
				mdl.write_line(fmt::format("GeosetId {},", bone.geoset_id));			   // The MDL has "Multiple" as value for some reason
				mdl.write_line(fmt::format("GeosetAnimId {},", bone.geoset_animation_id)); // And this one has "None"

				mdl.write_node(bone.node);
			});
		}

		for (const auto& help_bone : help_bones) {
			mdl.start_group(fmt::format("Helper \"{}\"", help_bone.name), [&]() {
				mdl.write_node(help_bone);
			});
		}

		for (const auto& attachment : attachments) {
			mdl.start_group(fmt::format("Helper \"{}\"", attachment.node.name), [&]() {
				mdl.write_node(attachment.node);
				mdl.write_line(fmt::format("AttachmentID {},", attachment.attachment_id));
				mdl.write_track(attachment.KATV, "Visibility", 0.f); // dunno
			});
		}

		mdl.start_group(fmt::format("PivotPoints \"{}\"", pivots.size()), [&]() {
			for (const auto& pivot : pivots) {
				mdl.write_line(fmt::format("{{ {}, {}, {} }},", pivot.x, pivot.y, pivot.z));
			}
		});

		for (const auto& emitter : emitters2) {
			mdl.start_group(fmt::format("ParticleEmitter2 \"{}\"", emitter.node.name), [&]() {
				mdl.write_node(emitter.node);

				mdl.write_track(emitter.KP2S, "Speed", emitter.speed);
				mdl.write_track(emitter.KP2R, "Variation", emitter.variation);
				mdl.write_track(emitter.KP2L, "Latitude", emitter.latitude);
				mdl.write_track(emitter.KP2G, "Gravity", emitter.gravity);
				if (emitter.squirt) {
					mdl.write_line("Squirt,");
				}
				mdl.write_track(emitter.KP2V, "Visibility", 0.f); // ToDo static value
				mdl.write_line(fmt::format("Lifespan {},", emitter.life_span));
				mdl.write_track(emitter.KP2E, "EmissionRate", emitter.emission_rate);
				mdl.write_track(emitter.KP2W, "Width", emitter.width);
				mdl.write_track(emitter.KP2N, "Length", emitter.length);

				switch (emitter.filter_mode) {
					case 0:
						mdl.write_line("Blend");
						break;
					case 1:
						mdl.write_line("Additive");
						break;
					case 2:
						mdl.write_line("Modulate");
						break;
					case 3:
						mdl.write_line("Modulate2x");
						break;
					case 4:
						mdl.write_line("AlphaKey");
						break;
				}

				mdl.write_line(fmt::format("Rows {},", emitter.rows));
				mdl.write_line(fmt::format("Columns {},", emitter.columns));

				if (emitter.head_or_tail == 0) {
					mdl.write_line("Head,");
				} else if (emitter.head_or_tail == 0) {
					mdl.write_line("Tail,");
				} else {
					mdl.write_line("Both,");
				}

				mdl.write_line(fmt::format("TailLength {},", emitter.tail_length));
				mdl.write_line(fmt::format("Time {},", emitter.time_middle));

				mdl.start_group("SegmentColor", [&]() {
					mdl.write_line(fmt::format("Color {{ {}, {}, {}  }},", emitter.start_segment_color.x, emitter.start_segment_color.y, emitter.start_segment_color.z));
					mdl.write_line(fmt::format("Color {{ {}, {}, {}  }},", emitter.middle_segment_color.x, emitter.middle_segment_color.y, emitter.middle_segment_color.z));
					mdl.write_line(fmt::format("Color {{ {}, {}, {}  }},", emitter.end_segment_color.x, emitter.end_segment_color.y, emitter.end_segment_color.z));
				});

				mdl.write_line(fmt::format("Alpha {{ {}, {}, {}  }},", emitter.segment_alphas.x, emitter.segment_alphas.y, emitter.segment_alphas.z));
				mdl.write_line(fmt::format("ParticleScaling {{ {}, {}, {}  }},", emitter.segment_scaling.x, emitter.segment_scaling.y, emitter.segment_scaling.z));
				mdl.write_line(fmt::format("LifeSpanUVAnim {{ {}, {}, {}  }},", emitter.head_intervals.x, emitter.head_intervals.y, emitter.head_intervals.z));
				mdl.write_line(fmt::format("DecayUVAnim {{ {}, {}, {}  }},", emitter.head_decay_intervals.x, emitter.head_decay_intervals.y, emitter.head_decay_intervals.z));
				mdl.write_line(fmt::format("TailUVAnim {{ {}, {}, {}  }},", emitter.tail_intervals.x, emitter.tail_intervals.y, emitter.tail_intervals.z));
				mdl.write_line(fmt::format("TailDecayUVAnim {{ {}, {}, {}  }},", emitter.tail_decay_intervals.x, emitter.tail_decay_intervals.y, emitter.tail_decay_intervals.z));

				mdl.write_line(fmt::format("TextureID {},", emitter.texture_id));
				mdl.write_line(fmt::format("PriorityPlane {},", emitter.priority_plane));
			});
		}

		for (const auto& event_object : event_objects) {
			mdl.start_group(fmt::format("EventObject \"{}\"", event_object.node.name), [&]() {
				mdl.write_node(event_object.node);

				mdl.start_group(fmt::format("EventTrack {}", event_object.times.size()), [&]() {
					for (const auto& track : event_object.times) {
						mdl.write_line(fmt::format("{},", track));
					}
				});
			});
		}

		for (const auto& collision_shape : collision_shapes) {
			mdl.start_group(fmt::format("CollisionShape \"{}\"", collision_shape.node.name), [&]() {
				mdl.write_node(collision_shape.node);

				switch (collision_shape.type) {
					case CollisionShape::Shape::Box:
						mdl.write_line("Cube,");
						mdl.start_group("Vertices 2", [&]() {
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z));
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[1].x, collision_shape.vertices[1].y, collision_shape.vertices[1].z));
						});
						break;
					case CollisionShape::Shape::Plane:
						mdl.write_line("Plane,");
						mdl.start_group("Vertices 2", [&]() {
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z));
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[1].x, collision_shape.vertices[1].y, collision_shape.vertices[1].z));
						});
						break;
					case CollisionShape::Shape::Sphere:
						mdl.write_line("Sphere,");
						mdl.start_group("Vertices 1", [&]() {
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z));
						});
						mdl.write_line(fmt::format("BoundsRadius {},", collision_shape.radius));
						break;
					case CollisionShape::Shape::Cylinder:
						mdl.write_line("Cylinder,");
						mdl.start_group("Vertices 2", [&]() {
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[0].x, collision_shape.vertices[0].y, collision_shape.vertices[0].z));
							mdl.write_line(fmt::format("{{ {}, {}, {}  }},", collision_shape.vertices[1].x, collision_shape.vertices[1].y, collision_shape.vertices[1].z));
						});
						mdl.write_line(fmt::format("BoundsRadius {},", collision_shape.radius));
						break;
				}
			});
		}
		fmt::print("Elapsed {}ms", timer.elapsed_ms());
		return mdl.mdl;
	}
} // namespace mdx
```

`src/File Formats/MDX/MDX.ixx`:

```ixx
module;

#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

#include <functional>
#include <filesystem>
#include <unordered_map>
#include <string_view>
#include <fstream>
#include <fmt/format.h>
#include <outcome/outcome.hpp>

export module MDX;

namespace fs = std::filesystem;
using outcome_v2_35644f5c::failure;
using outcome_v2_35644f5c::result;

import BinaryReader;
import BinaryWriter;
import Timer;

namespace mdx {
	export extern const std::unordered_map<int, std::string> replacable_id_to_texture{
		{ 1, "ReplaceableTextures/TeamColor/TeamColor00" },
		{ 2, "ReplaceableTextures/TeamGlow/TeamGlow00" },
		{ 11, "ReplaceableTextures/Cliff/Cliff0" },
		{ 31, "ReplaceableTextures/LordaeronTree/LordaeronFallTree" },
		{ 32, "ReplaceableTextures/AshenvaleTree/AshenTree" },
		{ 33, "ReplaceableTextures/BarrensTree/BarrensTree" },
		{ 34, "ReplaceableTextures/NorthrendTree/NorthTree" },
		{ 35, "ReplaceableTextures/Mushroom/MushroomTree" },
		{ 36, "ReplaceableTextures/RuinsTree/RuinsTree" },
		{ 37, "ReplaceableTextures/OutlandMushroomTree/MushroomTree" }
	};

	enum class TrackTag {
		KMTF = 'FTMK',
		KMTA = 'ATMK',
		KTAT = 'TATK',
		KTAR = 'RATK',
		KTAS = 'SATK',
		KGAO = 'OAGK',
		KGAC = 'CAGK',
		KLAS = 'SALK',
		KLAE = 'EALK',
		KLAC = 'CALK',
		KLAI = 'IALK',
		KLBI = 'IBLK',
		KLBC = 'CBLK',
		KLAV = 'VALK',
		KATV = 'VTAK',
		KPEE = 'EEPK',
		KPEG = 'GEPK',
		KPLN = 'NLPK',
		KPLT = 'TLPK',
		KPEL = 'LEPK',
		KPES = 'SEPK',
		KPEV = 'VEPK',
		KP2S = 'S2PK',
		KP2R = 'R2PK',
		KP2L = 'L2PK',
		KP2G = 'G2PK',
		KP2E = 'E2PK',
		KP2N = 'N2PK',
		KP2W = 'W2PK',
		KP2V = 'V2PK',
		KRHA = 'AHRK',
		KRHB = 'BHRK',
		KRAL = 'LARK',
		KRCO = 'OCRK',
		KRTX = 'XTRK',
		KRVS = 'SVRK',
		KCTR = 'RTCK',
		KTTR = 'RTTK',
		KCRL = 'LRCK',
		KGTR = 'RTGK',
		KGRT = 'TRGK',
		KGSC = 'CSGK',
		KFC3 = '3CFK',
		KFCA = 'ACFK',
		KFTC = 'CTFK',
		KMTE = 'ETMK'
	};

	enum class ChunkTag {
		VERS = 'SREV',
		GEOS = 'SOEG',
		MTLS = 'SLTM',
		SEQS = 'SQES',
		GLBS = 'SBLG',
		GEOA = 'AOEG',
		BONE = 'ENOB',
		TEXS = 'SXET',
		LITE = 'ETIL',
		HELP = 'PLEH',
		ATCH = 'HCTA',
		PIVT = 'TVIP',
		PREM = 'MERP',
		PRE2 = '2ERP',
		RIBB = 'BBIR',
		EVTS = 'STVE',
		CLID = 'DILC',
		CORN = 'NROC',
		SNDS = 'SDNS',
		TXAN = 'NAXT',
		BPOS = 'SOPB',
		FAFX = 'XFAF',
		MODL = 'LDOM',
		CAMS = 'SMAC'
	};

	export template <typename T>
	struct Track {
		int32_t frame;
		T value;
		T inTan;
		T outTan;
	};

	export template <typename T>
	struct TrackHeader {
		int32_t interpolation_type = 0;
		int32_t global_sequence_ID = -1;
		std::vector<Track<T>> tracks;

		int id = -1; // Used to track each individual track for animation purposes

		TrackHeader() = default;
		explicit TrackHeader(BinaryReader& reader, int track_id) {
			const uint32_t tracks_count = reader.read<uint32_t>();
			interpolation_type = reader.read<int32_t>();
			global_sequence_ID = reader.read<int32_t>();
			id = track_id;

			tracks.reserve(tracks_count);
			for (size_t i = 0; i < tracks_count; i++) {
				Track<T> track;
				track.frame = reader.read<int32_t>();
				track.value = reader.read<T>();
				if (interpolation_type > 1) {
					track.inTan = reader.read<T>();
					track.outTan = reader.read<T>();
				}
				tracks.push_back(track);
			}
		}

		void save(TrackTag tag, BinaryWriter& writer) const {
			if (tracks.empty()) {
				return;
			}

			writer.write<uint32_t>(static_cast<uint32_t>(tag));
			writer.write<uint32_t>(tracks.size());
			writer.write<uint32_t>(interpolation_type);
			writer.write<uint32_t>(global_sequence_ID);

			for (const auto& i : tracks) {
				writer.write<uint32_t>(i.frame);
				writer.write<T>(i.value);
				if (interpolation_type > 1) {
					writer.write<T>(i.inTan);
					writer.write<T>(i.outTan);
				}
			}
		}
	};

	export struct LayerTexture {
		uint32_t id;
		TrackHeader<uint32_t> KMTF;
	};

	export struct Layer {
		uint32_t blend_mode;
		uint32_t shading_flags;
		uint32_t texture_animation_id;
		uint32_t coord_id;
		float alpha;

		float emissive_gain;
		glm::vec3 fresnel_color;
		float fresnel_opacity;
		float fresnel_team_color;

		bool hd;

		std::vector<LayerTexture> textures;

		TrackHeader<uint32_t> KMTFTemp;
		TrackHeader<float> KMTA;
		TrackHeader<float> KMTE;
		TrackHeader<glm::vec3> KFC3;
		TrackHeader<float> KFCA;
		TrackHeader<float> KFTC;

		enum ShadingFlags {
			unshaded = 1,
			sphere_environment_map = 2,
			uknown1 = 4,
			unknown2 = 8,
			two_sided = 16,
			unfogged = 32,
			no_depth_test = 64,
			no_depth_set = 128
		};
	};

	export struct Node {
		Node() = default;
		explicit Node(BinaryReader& reader, int& unique_tracks) {
			const size_t reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			name = reader.read_string(80);
			id = reader.read<uint32_t>();
			parent_id = reader.read<uint32_t>();
			flags = reader.read<uint32_t>();

			while (reader.position < reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KGTR) {
					KGTR = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KGRT) {
					KGRT = TrackHeader<glm::quat>(reader, unique_tracks++);
				} else if (tag == TrackTag::KGSC) {
					KGSC = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
		}

		void save(BinaryWriter& writer) const {
			// Write temporary zero, remember location
			size_t inclusive_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_c_string_padded(name, 80);
			writer.write<uint32_t>(id);
			writer.write<uint32_t>(parent_id);
			writer.write<uint32_t>(flags);

			KGTR.save(TrackTag::KGTR, writer);
			KGRT.save(TrackTag::KGRT, writer);
			KGSC.save(TrackTag::KGSC, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index);
			std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
		}

		std::string name;
		int id;
		int parent_id;
		int flags;

		TrackHeader<glm::vec3> KGTR;
		TrackHeader<glm::quat> KGRT;
		TrackHeader<glm::vec3> KGSC;

		enum Flags {
			dont_inherit_translation = 0x1,
			dont_inherit_rotation = 0x2,
			dont_inherit_scaling = 0x4,
			billboarded = 0x8,
			billboarded_lock_x = 0x10,
			billboarded_lock_y = 0x20,
			billboarded_lock_z = 0x40,
			camera_anchored = 0x80,
			bone = 0x100,
			light = 0x200,
			object = 0x400,
			attachment = 0x800,
			emitter = 0x1000,
			collision_shape = 0x2000,
			ribbon_emitter = 0x4000,
			// if_particle_emitter : emitter_uses_mdl,
			unshaded = 0x8000,
			// if_particle_emitter : emitter_uses_tga,
			sort_primitives_far_z = 0x10000,
			line_emitter = 0x20000,
			unfogged = 0x40000,
			model_space = 0x80000,
			xy_quad = 0x100000
		};
	};

	export struct Extent {
		float bounds_radius;
		glm::vec3 minimum;
		glm::vec3 maximum;

		Extent() = default;
		explicit Extent(BinaryReader& reader) {
			bounds_radius = reader.read<float>();
			minimum = reader.read<glm::vec3>();
			maximum = reader.read<glm::vec3>();
		}

		void save(BinaryWriter& writer) const {
			writer.write<float>(bounds_radius);
			writer.write<glm::vec3>(minimum);
			writer.write<glm::vec3>(maximum);
		}
	};

	export struct Sequence {
		std::string name;
		uint32_t start_frame;
		uint32_t end_frame;
		float movespeed;
		uint32_t flags;
		float rarity;
		uint32_t sync_point;
		Extent extent;

		enum Flags {
			looping,
			non_looping
		};
	};

	export struct Geoset {
		std::vector<glm::vec3> vertices;
		std::vector<glm::vec3> normals;
		std::vector<uint32_t> face_type_groups;
		std::vector<uint32_t> face_groups;
		std::vector<uint16_t> faces;
		std::vector<uint8_t> vertex_groups;
		std::vector<uint32_t> matrix_groups;
		std::vector<uint32_t> matrix_indices;

		uint32_t material_id;
		uint32_t selection_group;
		uint32_t selection_flags;
		uint32_t lod;
		std::string lod_name;
		Extent extent;

		std::vector<Extent> extents;

		std::vector<glm::vec4> tangents;
		std::vector<uint8_t> skin;

		using TextureCoordinateSet = std::vector<glm::vec2>;
		std::vector<TextureCoordinateSet> texture_coordinate_sets;
	};

	export struct GeosetAnimation {
		float alpha;
		uint32_t flags;
		glm::vec3 color;
		uint32_t geoset_id;

		TrackHeader<float> KGAO;
		TrackHeader<glm::vec3> KGAC;
	};

	export struct Texture {
		uint32_t replaceable_id;
		fs::path file_name;
		uint32_t flags;

		enum Flags {
			wrap_width = 1,
			wrap_height
		};
	};

	export struct Material {
		uint32_t priority_plane;
		uint32_t flags;
		std::vector<Layer> layers;
	};

	struct Bone {
		Node node;
		int32_t geoset_id;
		int32_t geoset_animation_id;
	};

	struct Light {
		Node node;
		int type;
		int attenuation_start;
		int attenuation_end;
		glm::vec3 color;
		float intensity;
		glm::vec3 ambient_color;
		float ambient_intensity;

		TrackHeader<uint32_t> KLAS;
		TrackHeader<uint32_t> KLAE;
		TrackHeader<glm::vec3> KLAC;
		TrackHeader<float> KLAI;
		TrackHeader<float> KLBI;
		TrackHeader<glm::vec3> KLBC;
		TrackHeader<float> KLAV;
	};

	struct Attachment {
		Node node;
		std::string path; // Reference to Undead, NE, or Naga birth anim
		int reserved;	  // ToDo mine meaning of reserved from Game.dll, likely strlen
		int attachment_id;

		TrackHeader<float> KATV;
	};

	// Dragon/bird death bone emitter; usually emit MDLs based
	// on "path" string, but has a setting to emit TGAs from
	// path also (In practice EmitterUsesTGA setting is almost
	// never used, in favor of ParticleEmitter2).
	struct ParticleEmitter1 {
		Node node;
		float emission_rate;
		float gravity;
		float longitude;
		float latitude;
		std::string path;
		int reserved; // ToDo mine meaning, same as Attachment's reserved?
		float life_span;
		float speed;

		TrackHeader<float> KPEE;
		TrackHeader<float> KPEG;
		TrackHeader<float> KPLN;
		TrackHeader<float> KPLT;
		TrackHeader<float> KPEL;
		TrackHeader<float> KPES;
		TrackHeader<float> KPEV;
	};

	/*
	ParticleEmitter2: Texture only advanced "v2" emitter (99.9% of use cases)

	The "Tail" mode emits elongated particles, and the "Head"
	mode emits perfect square shapes. If you think about
	something like frost armor's damage that looks like a "strike,"
	this is a tail particle. The Wisp is another example. Disenchant
	is another.
	This can also be used where all elongated particles are going
	the same direction (based on latitude settings), such as the
	vertical lines in the yellow "heal" spell effect.

	The "Head" mode would be used for the snowflakes in frost armor's
	damage. It is also used in the water spray from the base of the
	Water Elemental. We say in comments we want to support the bubble geyser.
	That is a "Head" mode particle emitting a bubble
	texture, and a second one with XYQuad setting (flat, not facing camera) emitting the
	ripples above the water.

	There is also a "Both" mode that will emit both head and tail (when head_or_tail=2).

	--
	Each ParticleEmitter2 is a rectangular area specified by length and width that
	can be hand drawn in 3DS max, but many of them choose to forgo use of the rectangle,
	make it very small, and then use latitude settings to emit outward in all directions
	randomly, effectively making a point emitter (like NE Wisp).
	I seem to recall that variation is the random speed variation (when zero,
	all particles would move with equal speed, modified downward by gravity setting
	as an acceleration ).
	*/
	struct ParticleEmitter2 {
		Node node;
		float speed;
		float variation;
		float latitude;
		float gravity;
		float life_span;
		float emission_rate;
		float length;
		float width;
		uint32_t filter_mode;
		uint32_t rows; // for Textures\Clouds8x8 files
		uint32_t columns;
		uint32_t head_or_tail;
		float tail_length;
		float time_middle;

		glm::vec3 start_segment_color;
		glm::vec3 middle_segment_color;
		glm::vec3 end_segment_color;
		glm::u8vec3 segment_alphas;
		glm::vec3 segment_scaling;
		glm::uvec3 head_intervals;
		glm::uvec3 head_decay_intervals;
		glm::uvec3 tail_intervals;
		glm::uvec3 tail_decay_intervals;
		uint32_t texture_id;
		uint32_t squirt;
		uint32_t priority_plane;
		uint32_t replaceable_id; // for Wisp team color particles

		TrackHeader<float> KP2S;
		TrackHeader<float> KP2R;
		TrackHeader<float> KP2L;
		TrackHeader<float> KP2G;
		TrackHeader<float> KP2E;
		TrackHeader<float> KP2N;
		TrackHeader<float> KP2W;
		TrackHeader<float> KP2V;
	};

	struct RibbonEmitter {
		Node node;
		float height_above;
		float height_below;
		float alpha;
		glm::vec3 color;
		float life_span;
		uint32_t texture_slot;
		uint32_t emission_rate;
		uint32_t rows;
		uint32_t columns;
		uint32_t material_id; // note: not a texture id, avoids need for filtermode field like PE2
		float gravity;

		TrackHeader<float> KRHA;
		TrackHeader<float> KRHB;
		TrackHeader<float> KRAL;
		TrackHeader<glm::vec3> KRCO;
		TrackHeader<uint32_t> KRTX;
		TrackHeader<float> KRVS;
	};

	/*
	 EventObjects:
	 The type of sound or spawned effect is determined by node name
	 and SLK table lookup. The default World Editor ignores EventObjects
	 entirely, so they are only viewable in game. Even when you activate
	 the GEM setting in the Terrain Editor and listen for unit death sounds
	 when deleting them, the World Editor plays the sound file from the soundset
	 information despite the game playing the sound file from the EventObject.

	 Every EventObject's name is typically 8 characters. It usually starts with:
		SPN to spawn a model file from "Splats\SpawnData.slk"
		   - Example: illidan footprints, blood particle emitters
		SPLT to spawn a ground texture from "Splats\SplatData.slk"
			 - Example: blood ground texture on unit death
		FPT to spawn a footprint also from "Splats\SplatData.slk"
		   - It is possible that FPT animates differently,
			 such as only shows on certain terrain?? (ToDo research if needed)
		   - Some FPT entries make situational sounds, such as spiders walking on metallic
			 tiles (icecrown tileset bricks/runes) if memory serves? (ToDo research if needed)
		UBR to spawn a temporary uber splat from "Splats\UberSplatData.slk"
		   - Example: Several buildings, when they die, use an UBR tag to create a crater
			   style ground texture. Flamestrike also uses this style of model tag
			 to spawn its ground texture.
		SND to play a sound from "UI\SoundInfo\AnimLookups.slk" (unit death and spell sounds)

	 The 4 last characters of the 8-character name will be the 4-digit rawcode
	 SLK table lookup key within the particular table being used.
	 RoC Beta had 5-digit rawcodes present in the UberSplatData.slk
	 that I did not research. They were probably just a different way
	 to store terrain information; I do not know if they were used in any
	 model files. The uber splat table is also used by the World Editor
	 for building Ground Textures, so it is possible that the World Editor
	 accepts the five letter codes and this allowed Blizzard to test the
	 different per-tileset variations of the entries.

	 For 3-letter table names, like FPT, the 4th character is often "x" or "y",
	 presumably a redundant indicator for left or right, although both
	 flipped versions of most footprint textures exist and are loaded with
	 separate table entries.

	 Tags like "SNDxPOOP" might exist for an SLK table entry we do not have that is only
	 found in custom environments. Although modern maps cannot easily override
	 these tables, old MPQ mods on historic versions of the game exist with
	 fan created table entries. For example, in the TToR Mod, when you
	 kill a Balrog it makes a very loud custom noise that is embedded into
	 the model via a custom EventObject. So we must allow invalid entries without crashing.
	 If the "times" vector is empty, then War3 does not load the model, and we can consider
	 it invalid.
	*/
	struct EventObject {
		Node node;
		int global_sequence_id; // signed, -1 to specify "none"
		std::vector<uint32_t> times;
	};

	/*
	I was pretty sure that in the old days, not having a CollisionShape meant that
	a unit was not able to be selected in-game. However, at some point,
	I think they patched it so that it usually always works. Might've been
	the 2009 patch cycle, could have been TFT.

	So at this point I've seen some models that didn't have collision shapes that
	worked fine, but we need to parse them for rendering since they are legal
	nodes and could technically be a parent of another node.

	(They are used for ray intersection bounding cues, not for in-game "collision")
	(World editor doesn't use them and uses MODL/GEOS for selection and bounding cues, which
	is also why you don't ever have a doodad model that cant be clicked on in WE,
	even though some doodad models can't be clicked on easily in-game)

	Voidwalker's attack animation animates his CollisionShape to float outside
	of his center and DracoL1ch said that for DotA at some point he had to
	replace the Voidwalker model because of user complaints where the Voidwalker
	model had "invincibility frames" effectively, where it could not be attacked,
	because the CollisionShape had floated away.
	*/
	struct CollisionShape {
		enum class Shape {
			Box = 0,	 // 2 verts
			Plane = 1,	 // 2 verts
			Sphere = 2,	 // 1 verts
			Cylinder = 3 // 2 vert
		};

		Node node;
		Shape type;
		glm::vec3 vertices[2]; // sometimes only 1 is used
		float radius;		   // used for sphere/cylinder
	};

	struct FaceFX {
		std::string name;
		fs::path path;
	};

	struct CornEmitter {
		Node node;
		std::vector<uint8_t> data; // Just store it so we can save it again
	};

	struct Camera {
		std::vector<uint8_t> data; // Just store it so we can save it again
	};

	struct TextureAnimation {
		std::vector<uint8_t> data; // Just store it so we can save it again
	};

	export class MDX {
	  public:
		int unique_tracks = 0;

		int version;
		std::string name;
		std::string animation_filename;
		Extent extent;
		uint32_t blend_time;

		std::string face_target;
		std::string face_path;

		std::vector<Geoset> geosets;
		std::vector<Sequence> sequences;
		std::vector<uint32_t> global_sequences;
		std::vector<GeosetAnimation> animations;
		std::vector<Bone> bones;
		std::vector<Material> materials;
		std::vector<Texture> textures;
		std::vector<Light> lights;
		std::vector<Node> help_bones;
		std::vector<Attachment> attachments;
		std::vector<glm::vec3> pivots;
		std::vector<ParticleEmitter1> emitters1;
		std::vector<ParticleEmitter2> emitters2;
		std::vector<RibbonEmitter> ribbons;
		std::vector<EventObject> event_objects;
		std::vector<CollisionShape> collision_shapes;
		std::vector<CornEmitter> corn_emitters;
		std::vector<FaceFX> facefxes;

		std::vector<Camera> cameras;
		std::vector<float> bind_poses;
		std::vector<TextureAnimation> texture_animations;

	  private:

		void read_GEOS_chunk(BinaryReader& reader);
		void read_MTLS_chunk(BinaryReader& reader);
		void read_SEQS_chunk(BinaryReader& reader);
		void read_GEOA_chunk(BinaryReader& reader);
		void read_BONE_chunk(BinaryReader& reader);
		void read_TEXS_chunk(BinaryReader& reader);
		void read_GLBS_chunk(BinaryReader& reader);
		void read_LITE_chunk(BinaryReader& reader);
		void read_HELP_chunk(BinaryReader& reader);
		void read_ATCH_chunk(BinaryReader& reader);
		void read_PIVT_chunk(BinaryReader& reader);
		void read_PREM_chunk(BinaryReader& reader);
		void read_PRE2_chunk(BinaryReader& reader);
		void read_RIBB_chunk(BinaryReader& reader);
		void read_EVTS_chunk(BinaryReader& reader);
		void read_CLID_chunk(BinaryReader& reader);
		void read_CORN_chunk(BinaryReader& reader);
		void read_CAMS_chunk(BinaryReader& reader);
		void read_BPOS_chunk(BinaryReader& reader);
		void read_TXAN_chunk(BinaryReader& reader);
		void read_FAFX_chunk(BinaryReader& reader);

		void write_GEOS_chunk(BinaryWriter& writer) const;
		void write_MTLS_chunk(BinaryWriter& writer) const;
		void write_SEQS_chunk(BinaryWriter& writer) const;
		void write_GLBS_chunk(BinaryWriter& writer) const;
		void write_GEOA_chunk(BinaryWriter& writer) const;
		void write_BONE_chunk(BinaryWriter& writer) const;
		void write_TEXS_chunk(BinaryWriter& writer) const;
		void write_LITE_chunk(BinaryWriter& writer) const;
		void write_HELP_chunk(BinaryWriter& writer) const;
		void write_ATCH_chunk(BinaryWriter& writer) const;
		void write_PIVT_chunk(BinaryWriter& writer) const;
		void write_PREM_chunk(BinaryWriter& writer) const;
		void write_PRE2_chunk(BinaryWriter& writer) const;
		void write_RIBB_chunk(BinaryWriter& writer) const;
		void write_EVTS_chunk(BinaryWriter& writer) const;
		void write_CLID_chunk(BinaryWriter& writer) const;
		void write_CORN_chunk(BinaryWriter& writer) const;
		void write_CAMS_chunk(BinaryWriter& writer) const;
		void write_BPOS_chunk(BinaryWriter& writer) const;
		void write_TXAN_chunk(BinaryWriter& writer) const;
		void write_FAFX_chunk(BinaryWriter& writer) const;

		void load(BinaryReader& reader);

		MDX() = default;

	  public:
		explicit MDX(BinaryReader& reader) {
			load(reader);
		}

		void save(const fs::path& path);

		void validate() {
			// Remove geoset animations that reference non existing geosets
			for (size_t i = animations.size(); i-- > 0;) {
				if (animations[i].geoset_id >= geosets.size()) {
					animations.erase(animations.begin() + i);
				}
			}

			size_t node_count = bones.size() +
								lights.size() +
								help_bones.size() +
								attachments.size() +
								emitters1.size() +
								emitters2.size() +
								ribbons.size() +
								event_objects.size() +
								collision_shapes.size() +
								corn_emitters.size();

			// If there are no bones we have to add one to prevent crashing and stuff.
			if (bones.empty()) {
				Bone bone{};
				bone.node.parent_id = -1;
				bone.node.id = node_count++;
				bones.push_back(bone);
			}

			// Ensure that pivots is big enough
			pivots.resize(node_count, {});

			// Compact node IDs
			std::vector<int> IDs;
			IDs.reserve(node_count);
			for_each_node([&](mdx::Node& node) {
				if (node.id == -1) {
					fmt::print("Invalid node \"{}\" with ID -1\n", node.name);
					return;
				}
				IDs.push_back(node.id);
			});

			const int max_id = *std::max_element(IDs.begin(), IDs.end());
			std::vector<int> remapping(max_id + 1);
			for (size_t i = 0; i < IDs.size(); i++) {
				remapping[IDs[i]] = i;
			}

			for_each_node([&](mdx::Node& node) {
				if (node.id == -1) {
					fmt::print("Invalid node \"{}\" with ID -1\n", node.name);
					return;
				}
				node.id = remapping[node.id];
				if (node.parent_id != -1) {
					node.parent_id = remapping[node.parent_id];
				}
			});

			// Fix vertex groups that reference non existent matrix groups
			for (auto& i : geosets) {
				for (auto& j : i.vertex_groups) {
					// If no matrix groups exist we insert one
					if (i.matrix_groups.empty()) {
						i.matrix_groups.push_back(1);
						i.matrix_indices.push_back(0);
					}
					// Don't reference non existing ones!
					if (j >= i.matrix_groups.size()) {
						j = std::min<uint8_t>(j, i.matrix_groups.size() - 1);
					}
				}
			}
		}

		void optimize() {
			Bone& bone = bones.front();
			auto& header = bone.node.KGTR;
			const auto& new_tracks = header.tracks;

			Sequence& current_sequence = sequences.front();
			// for (const auto& track : header.tracks) {
			for (size_t i = 0; i < new_tracks.size(); i++) {
				auto& track = new_tracks[i];

				if (track.frame > current_sequence.end_frame) {
					for (const auto& i : sequences) {
						if (i.start_frame <= track.frame && i.end_frame >= track.frame) {
							current_sequence = i;
							break;
						}
					}
					// If we find a track that lies outside any sequence we skip it
					if (track.frame > current_sequence.end_frame) {
						continue;
					}
				}
			}

			if (header.interpolation_type == 1) {
				for (const auto& i : sequences) {
				}
				const auto& trackA = header.tracks[0];
				const auto& trackB = header.tracks[1];
				const auto& trackC = header.tracks[2];

				int32_t diffAB = trackB.frame - trackA.frame;
				int32_t diffBC = trackC.frame - trackB.frame;
				int32_t total = trackC.frame - trackA.frame;

				glm::vec3 between = trackA.value + trackC.value * (static_cast<float>(diffAB) / total);
				glm::vec3 diff = (trackB.value - between) / between * 100.f;
				if (diff.x < 1.f && diff.y < 1.f && diff.z < 1.f) {
					fmt::print("yeet");
				}
			}
		}

		std::string to_mdl();
		static result<MDX, std::string> from_mdl(std::string_view mdl);

		void for_each_node(const std::function<void(Node&)>& F) {
			for (auto& i : bones) {
				F(i.node);
			}

			for (auto& i : lights) {
				F(i.node);
			}

			for (auto& i : help_bones) {
				F(i);
			}

			for (auto& i : attachments) {
				F(i.node);
			}

			for (auto& i : emitters1) {
				F(i.node);
			}

			for (auto& i : emitters2) {
				F(i.node);
			}

			for (auto& i : ribbons) {
				F(i.node);
			}

			for (auto& i : event_objects) {
				F(i.node);
			}

			for (auto& i : collision_shapes) {
				F(i.node);
			}

			for (auto& i : corn_emitters) {
				F(i.node);
			}
		}
	};
} // namespace mdx
```

`src/File Formats/MDX/MDXReader.cpp`:

```cpp
module;

#include <string>
#include <fmt/format.h>
#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

module MDX;

//import BinaryReader;

namespace mdx {
	void MDX::read_GEOS_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		uint32_t total_size = 0;

		while (total_size < size) {
			total_size += reader.read<uint32_t>();

			Geoset geoset;
			reader.advance(4);
			const uint32_t vertex_count = reader.read<uint32_t>();
			geoset.vertices = reader.read_vector<glm::vec3>(vertex_count);
			reader.advance(4);
			const uint32_t normal_count = reader.read<uint32_t>();
			geoset.normals = reader.read_vector<glm::vec3>(normal_count);
			reader.advance(4);
			const uint32_t face_type_groups_count = reader.read<uint32_t>();
			geoset.face_type_groups = reader.read_vector<uint32_t>(face_type_groups_count);
			reader.advance(4);
			const uint32_t face_groups_count = reader.read<uint32_t>();
			geoset.face_groups = reader.read_vector<uint32_t>(face_groups_count);
			reader.advance(4);
			const uint32_t faces_count = reader.read<uint32_t>();
			geoset.faces = reader.read_vector<uint16_t>(faces_count);
			reader.advance(4);
			const uint32_t vertex_groups_count = reader.read<uint32_t>();
			geoset.vertex_groups = reader.read_vector<uint8_t>(vertex_groups_count);
			reader.advance(4);
			const uint32_t matrix_group_count = reader.read<uint32_t>();
			geoset.matrix_groups = reader.read_vector<uint32_t>(matrix_group_count);
			reader.advance(4); // Mats
			const uint32_t matrix_indices_count = reader.read<uint32_t>();
			geoset.matrix_indices = reader.read_vector<uint32_t>(matrix_indices_count);
			geoset.material_id = reader.read<uint32_t>();
			geoset.selection_group = reader.read<uint32_t>();
			geoset.selection_flags = reader.read<uint32_t>();

			if (version > 800) {
				geoset.lod = reader.read<uint32_t>();
				geoset.lod_name = reader.read_string(80); // lod name
			} else {
				geoset.lod = 0;
			}

			geoset.extent = Extent(reader);
			const uint32_t extents_count = reader.read<uint32_t>();
			for (size_t i = 0; i < extents_count; i++) {
				geoset.extents.emplace_back(Extent(reader));
			}

			std::string tag = reader.read_string(4);

			if (tag == "TANG") {
				uint32_t structure_count = reader.read<uint32_t>();
				geoset.tangents = reader.read_vector<glm::vec4>(structure_count);
				tag = reader.read_string(4); // Maybe SKIN, maybe UVAS
			}

			if (tag == "SKIN") {
				uint32_t skin_count = reader.read<uint32_t>();
				geoset.skin = reader.read_vector<uint8_t>(skin_count);
				reader.advance(4); // UVAS
			}

			const uint32_t texture_coordinate_sets_count = reader.read<uint32_t>();
			for (size_t i = 0; i < texture_coordinate_sets_count; i++) {
				reader.advance(4);
				const uint32_t texture_coordinates_count = reader.read<uint32_t>();
				geoset.texture_coordinate_sets.push_back(reader.read_vector<glm::vec2>(texture_coordinates_count));
			}

			geosets.push_back(std::move(geoset));
		}
	}

	// Transform from the old version format to our new v1100 based internal representation
	void read_MTLS_texs_pre_v1100(BinaryReader& reader, bool is_hd, uint32_t version, Material& material, int& unique_tracks) {
		reader.advance(4);
		const uint32_t layers_count = reader.read<uint32_t>();

		// These older versions encoded HD materials by having a layer for each PBR material
		// We combine these into the new format
		if (is_hd) {
			Layer layer;
			layer.hd = is_hd;

			for (size_t i = 0; i < layers_count; i++) {
				const size_t reader_pos = reader.position;
				const uint32_t size = reader.read<uint32_t>();

				// Only the first layer's properties matter
				if (i > 0) {
					reader.read<uint32_t>();
					reader.read<uint32_t>();
					LayerTexture layer_texture;
					layer_texture.id = reader.read<uint32_t>();
					layer.textures.push_back(layer_texture);

					reader.advance(size - 16);
					continue;
				}

				layer.blend_mode = reader.read<uint32_t>();
				layer.shading_flags = reader.read<uint32_t>();
				LayerTexture layer_texture;
				layer_texture.id = reader.read<uint32_t>();
				layer.texture_animation_id = reader.read<uint32_t>();
				layer.coord_id = reader.read<uint32_t>();
				layer.alpha = reader.read<float>();

				layer.emissive_gain = reader.read<float>();
				layer.fresnel_color = reader.read<glm::vec3>();
				layer.fresnel_opacity = reader.read<float>();
				layer.fresnel_team_color = reader.read<float>();

				while (reader.position < reader_pos + size) {
					TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
					if (tag == TrackTag::KMTF) {
						layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTA) {
						layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTE) {
						layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFC3) {
						layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFCA) {
						layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFTC) {
						layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
					} else {
						fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
					}
				}

				layer.textures.push_back(layer_texture);
			}

			material.layers.push_back(std::move(layer));
		} else {
			for (size_t i = 0; i < layers_count; i++) {
				const size_t reader_pos = reader.position;
				const uint32_t size = reader.read<uint32_t>();
				Layer layer;
				layer.hd = is_hd;
				layer.blend_mode = reader.read<uint32_t>();
				layer.shading_flags = reader.read<uint32_t>();

				LayerTexture layer_texture;
				layer_texture.id = reader.read<uint32_t>();
				layer.textures.push_back(layer_texture);

				layer.texture_animation_id = reader.read<uint32_t>();
				layer.coord_id = reader.read<uint32_t>();
				layer.alpha = reader.read<float>();

				if (version > 800) {
					layer.emissive_gain = reader.read<float>();
					layer.fresnel_color = reader.read<glm::vec3>();
					layer.fresnel_opacity = reader.read<float>();
					layer.fresnel_team_color = reader.read<float>();
				}

				while (reader.position < reader_pos + size) {
					TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
					if (tag == TrackTag::KMTF) {
						layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTA) {
						layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KMTE) {
						layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFC3) {
						layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFCA) {
						layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
					} else if (tag == TrackTag::KFTC) {
						layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
					} else {
						fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
					}
				}

				material.layers.push_back(std::move(layer));
			}
		}
	}

	void read_MTLS_texs_post_v1100(BinaryReader& reader, Material& material, int& unique_tracks) {
		reader.advance(4);
		const uint32_t layers_count = reader.read<uint32_t>();
		for (size_t i = 0; i < layers_count; i++) {
			const size_t reader_pos = reader.position;
			Layer layer;
			const uint32_t size = reader.read<uint32_t>();
			layer.blend_mode = reader.read<uint32_t>();
			layer.shading_flags = reader.read<uint32_t>();
			reader.advance(4); // skip texture_id
			layer.texture_animation_id = reader.read<uint32_t>();
			layer.coord_id = reader.read<uint32_t>();
			layer.alpha = reader.read<float>();

			layer.emissive_gain = reader.read<float>();
			layer.fresnel_color = reader.read<glm::vec3>();
			layer.fresnel_opacity = reader.read<float>();
			layer.fresnel_team_color = reader.read<float>();

			layer.hd = reader.read<uint32_t>();
			uint32_t texs = reader.read<uint32_t>();
			for (size_t j = 0; j < texs; j++) {
				LayerTexture layer_texture;
				layer_texture.id = reader.read<uint32_t>();
				uint32_t slot = reader.read<uint32_t>(); // always a garbage value?

				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KMTF) {
					layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
				} else {
					reader.advance(-4);
				}
				layer.textures.push_back(layer_texture);
			}

			while (reader.position < reader_pos + size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KMTA) {
					layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KMTE) {
					layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KFC3) {
					layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KFCA) {
					layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KFTC) {
					layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}

			material.layers.push_back(std::move(layer));
		}
	}

	void MDX::read_MTLS_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		uint32_t total_size = 0;

		while (total_size < size) {
			total_size += reader.read<uint32_t>();

			Material material;
			material.priority_plane = reader.read<uint32_t>();
			material.flags = reader.read<uint32_t>();

			//bool oldSD = version == 800;
			//bool oldHD = false;
			//if (version == 900 || version == 1000) {
			//	oldSD = reader.read_string(80).empty();
			//	oldHD = !oldSD;
			//}

			if (version < 1100) {
				bool is_hd = false;
				if (version == 900 || version == 1000) {
					is_hd = !reader.read_string(80).empty();
				}
				read_MTLS_texs_pre_v1100(reader, is_hd, version, material, unique_tracks);
			} else {
				read_MTLS_texs_post_v1100(reader, material, unique_tracks);
			}


			//bool old_hd = false;
			//if (version == 900 || version == 1000) {
			//	old_hd = !reader.read_string(80).empty();
			//}

			//reader.advance(4);
			//const uint32_t layers_count = reader.read<uint32_t>();

			//for (size_t i = 0; i < layers_count; i++) {
			//	const size_t reader_pos = reader.position;
			//	Layer layer;
			//	const uint32_t size = reader.read<uint32_t>();
			//	layer.blend_mode = reader.read<uint32_t>();
			//	layer.shading_flags = reader.read<uint32_t>();

			//	//if (version == 800 || version == 900 || version == 1000) {
			//	//	layer.hd = reader.read<uint32_t>();

			//	//	LayerTexture layer_texture;
			//	//	layer_texture.id = reader.read<uint32_t>();

			//	//	TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
			//	//	if (tag == TrackTag::KMTF) {
			//	//		layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
			//	//	} else {
			//	//		reader.advance(-4);
			//	//	}
			//	//	layer.textures.push_back(layer_texture);
			//	//}

			//	layer.texture_id = reader.read<uint32_t>();
			//	layer.texture_animation_id = reader.read<uint32_t>();
			//	layer.coord_id = reader.read<uint32_t>();
			//	layer.alpha = reader.read<float>();

			//	if (version > 800) {
			//		layer.emissive_gain = reader.read<float>();
			//		layer.fresnel_color = reader.read<glm::vec3>();
			//		layer.fresnel_opacity = reader.read<float>();
			//		layer.fresnel_team_color = reader.read<float>();
			//	}

			//	layer.hd = false;
			//	if (version > 1000) {
			//		layer.hd = reader.read<uint32_t>();
			//		uint32_t texs = reader.read<uint32_t>();
			//		for (size_t j = 0; j < texs; j++) {
			//			LayerTexture layer_texture;
			//			layer_texture.id = reader.read<uint32_t>();
			//			uint32_t slot = reader.read<uint32_t>();

			//			TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
			//			if (tag == TrackTag::KMTF) {
			//				layer_texture.KMTF = TrackHeader<uint32_t>(reader, unique_tracks++);
			//			} else {
			//				reader.advance(-4);
			//			}
			//			layer.textures.push_back(layer_texture);
			//		}
			//	}

			//	while (reader.position < reader_pos + size) {
			//		TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
			//		if (tag == TrackTag::KMTF) {
			//			layer.KMTFTemp = TrackHeader<uint32_t>(reader, unique_tracks++);
			//		} else if (tag == TrackTag::KMTA) {
			//			layer.KMTA = TrackHeader<float>(reader, unique_tracks++);
			//		} else if (tag == TrackTag::KMTE) {
			//			layer.KMTE = TrackHeader<float>(reader, unique_tracks++);
			//		} else if (tag == TrackTag::KFC3) {
			//			layer.KFC3 = TrackHeader<glm::vec3>(reader, unique_tracks++);
			//		} else if (tag == TrackTag::KFCA) {
			//			layer.KFCA = TrackHeader<float>(reader, unique_tracks++);
			//		} else if (tag == TrackTag::KFTC) {
			//			layer.KFTC = TrackHeader<float>(reader, unique_tracks++);
			//		} else {
			//			fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
			//		}
			//	}

			//	material.layers.push_back(std::move(layer));
			//}

			//if (oldHD) {
			//	material.layers[0].hd = true;
			//	for (int i = 1; i < 6; i++) {
			//		material.layers[0].textures[i].id = material.layers[i].textures[0].id;
			//		material.layers[0].textures[i].KMTF = material.layers[i].KMTFTemp;

			//		//LayerTexture layer_texture;
			//		//layer_texture.id = material.layers[i].textures[0].id;

			//		material.layers[0].textures.push_back()
			//	}
			//	material.layers.resize(1);
			//} else if (oldSD) {
			//	for (auto& layer : material.layers) {
			//		layer.textures[0].id = layer.textures[0].id;
			//		layer.textures[0].KMTF = layer.KMTFTemp;
			//	}
			//}

			materials.push_back(std::move(material));
		}
	}

	void MDX::read_SEQS_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		for (size_t i = 0; i < size / 132; i++) {
			Sequence sequence;
			sequence.name = reader.read_string(80);
			sequence.start_frame = reader.read<uint32_t>();
			sequence.end_frame = reader.read<uint32_t>();
			sequence.movespeed = reader.read<float>();
			sequence.flags = reader.read<uint32_t>();
			sequence.rarity = reader.read<float>();
			sequence.sync_point = reader.read<uint32_t>();
			sequence.extent = Extent(reader);
			sequences.push_back(std::move(sequence));
		}
	}

	void MDX::read_GEOA_chunk(BinaryReader& reader) {
		uint32_t remaining_size = reader.read<uint32_t>();

		while (remaining_size > 0) {
			const size_t reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			remaining_size -= inclusive_size;

			GeosetAnimation animation;
			animation.alpha = reader.read<float>();
			animation.flags = reader.read<uint32_t>();
			animation.color = reader.read<glm::vec3>();
			animation.geoset_id = reader.read<uint32_t>();

			while (reader.position < reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KGAO) {
					animation.KGAO = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KGAC) {
					animation.KGAC = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}

			animations.push_back(std::move(animation));
		}
	}

	void MDX::read_BONE_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Bone bone;
			bone.node = Node(reader, unique_tracks);
			bone.geoset_id = reader.read<int32_t>();
			bone.geoset_animation_id = reader.read<int32_t>();
			bones.push_back(std::move(bone));
		}
	}

	void MDX::read_TEXS_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		for (size_t i = 0; i < size / 268; i++) {
			Texture texture;
			texture.replaceable_id = reader.read<uint32_t>();
			texture.file_name = reader.read_string(260);
			texture.flags = reader.read<uint32_t>();
			textures.push_back(std::move(texture));
		}
	}

	void MDX::read_GLBS_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		global_sequences = reader.read_vector<uint32_t>(size / 4);
	}

	void MDX::read_LITE_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Light light;
			const size_t node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			light.node = Node(reader, unique_tracks);
			light.type = reader.read<uint32_t>();
			light.attenuation_start = reader.read<float>();
			light.attenuation_end = reader.read<float>();
			light.color = reader.read<glm::vec3>();
			light.intensity = reader.read<float>();
			light.ambient_color = reader.read<glm::vec3>();
			light.ambient_intensity = reader.read<float>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KLAS) {
					light.KLAS = TrackHeader<uint32_t>(reader, unique_tracks++);
				} else if (tag == TrackTag::KLAE) {
					light.KLAE = TrackHeader<uint32_t>(reader, unique_tracks++);
				} else if (tag == TrackTag::KLAC) {
					light.KLAC = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KLAI) {
					light.KLAI = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KLBI) {
					light.KLBI = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KLBC) {
					light.KLBC = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KLAV) {
					light.KLAV = TrackHeader<float>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			lights.push_back(std::move(light));
		}
	}

	void MDX::read_HELP_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();
		while (reader.position < reader_pos + size) {
			help_bones.push_back(Node(reader, unique_tracks));
		}
	}

	void MDX::read_ATCH_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Attachment attachment;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			attachment.node = Node(reader, unique_tracks);
			attachment.path = reader.read_string(256);
			attachment.reserved = reader.read<uint32_t>();
			attachment.attachment_id = reader.read<uint32_t>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				attachment.KATV = TrackHeader<float>(reader, unique_tracks++);
				if (tag != TrackTag::KATV) {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			attachments.push_back(std::move(attachment));
		}
	}

	void MDX::read_PIVT_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		pivots = reader.read_vector<glm::vec3>(size / 12);
	}

	void MDX::read_PREM_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			ParticleEmitter1 emitter;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter.node = Node(reader, unique_tracks);
			emitter.emission_rate = reader.read<float>();
			emitter.gravity = reader.read<float>();
			emitter.longitude = reader.read<float>();
			emitter.latitude = reader.read<float>();
			emitter.path = reader.read_string(256);
			emitter.reserved = reader.read<uint32_t>();
			emitter.life_span = reader.read<float>();
			emitter.speed = reader.read<float>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KPEE) {
					emitter.KPEE = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KPEG) {
					emitter.KPEG = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KPLN) {
					emitter.KPLN = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KPLT) {
					emitter.KPLT = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KPEL) {
					emitter.KPEL = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KPES) {
					emitter.KPES = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KPEV) {
					emitter.KPEV = TrackHeader<float>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			emitters1.push_back(std::move(emitter));
		}
	}

	void MDX::read_PRE2_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			ParticleEmitter2 emitter2;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter2.node = Node(reader, unique_tracks);

			emitter2.speed = reader.read<float>();
			emitter2.variation = reader.read<float>();
			emitter2.latitude = reader.read<float>();
			emitter2.gravity = reader.read<float>();
			emitter2.life_span = reader.read<float>();
			emitter2.emission_rate = reader.read<float>();
			emitter2.length = reader.read<float>();
			emitter2.width = reader.read<float>();
			emitter2.filter_mode = reader.read<uint32_t>();
			emitter2.rows = reader.read<uint32_t>();
			emitter2.columns = reader.read<uint32_t>();
			emitter2.head_or_tail = reader.read<uint32_t>();
			emitter2.tail_length = reader.read<float>();
			emitter2.time_middle = reader.read<float>();

			emitter2.start_segment_color = reader.read<glm::vec3>();
			emitter2.middle_segment_color = reader.read<glm::vec3>();
			emitter2.end_segment_color = reader.read<glm::vec3>();

			emitter2.segment_alphas = reader.read<glm::u8vec3>();
			emitter2.segment_scaling = reader.read<glm::vec3>();
			emitter2.head_intervals = reader.read<glm::uvec3>();
			emitter2.head_decay_intervals = reader.read<glm::uvec3>();
			emitter2.tail_intervals = reader.read<glm::uvec3>();
			emitter2.tail_decay_intervals = reader.read<glm::uvec3>();

			emitter2.texture_id = reader.read<uint32_t>();
			emitter2.squirt = reader.read<uint32_t>();
			emitter2.priority_plane = reader.read<uint32_t>();
			emitter2.replaceable_id = reader.read<uint32_t>();

			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KP2S) {
					emitter2.KP2S = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2R) {
					emitter2.KP2R = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2L) {
					emitter2.KP2L = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2G) {
					emitter2.KP2G = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2E) {
					emitter2.KP2E = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2N) {
					emitter2.KP2N = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2W) {
					emitter2.KP2W = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KP2V) {
					emitter2.KP2V = TrackHeader<float>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			emitters2.push_back(std::move(emitter2));
		}
	}

	void MDX::read_RIBB_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			RibbonEmitter emitter;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter.node = Node(reader, unique_tracks);
			emitter.height_above = reader.read<float>();
			emitter.height_below = reader.read<float>();
			emitter.alpha = reader.read<float>();
			emitter.color = reader.read<glm::vec3>();
			emitter.life_span = reader.read<float>();
			emitter.texture_slot = reader.read<uint32_t>();
			emitter.emission_rate = reader.read<uint32_t>();
			emitter.rows = reader.read<uint32_t>();
			emitter.columns = reader.read<uint32_t>();
			emitter.material_id = reader.read<uint32_t>();
			emitter.gravity = reader.read<float>();
			while (reader.position < node_reader_pos + inclusive_size) {
				TrackTag tag = static_cast<TrackTag>(reader.read<int32_t>());
				if (tag == TrackTag::KRHA) {
					emitter.KRHA = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KRHB) {
					emitter.KRHB = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KRAL) {
					emitter.KRAL = TrackHeader<float>(reader, unique_tracks++);
				} else if (tag == TrackTag::KRCO) {
					emitter.KRCO = TrackHeader<glm::vec3>(reader, unique_tracks++);
				} else if (tag == TrackTag::KRTX) {
					emitter.KRTX = TrackHeader<uint32_t>(reader, unique_tracks++);
				} else if (tag == TrackTag::KRVS) {
					emitter.KRVS = TrackHeader<float>(reader, unique_tracks++);
				} else {
					fmt::print("Unknown track tag {}\n", static_cast<uint32_t>(tag));
				}
			}
			ribbons.push_back(std::move(emitter));
		}
	}

	void MDX::read_EVTS_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			EventObject evt;
			evt.node = Node(reader, unique_tracks);
			reader.advance(4); // read KEVT
			uint32_t count = reader.read<uint32_t>();
			evt.global_sequence_id = reader.read<int32_t>(); // signed
			evt.times = reader.read_vector<uint32_t>(count);
			event_objects.push_back(std::move(evt));
		}
	}

	void MDX::read_CLID_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			CollisionShape shape;
			shape.node = Node(reader, unique_tracks);
			shape.type = static_cast<CollisionShape::Shape>(reader.read<uint32_t>());

			for (int i = 0; i < 3; i++) {
				if (reader.remaining() <= 0) {
					shape.vertices[0][i] = 0.f;
				} else {
					shape.vertices[0][i] = reader.read<float>();
				}
			}

			if (shape.type != CollisionShape::Shape::Sphere) {
				for (int i = 0; i < 3; i++) {
					if (reader.remaining() <= 0) {
						shape.vertices[1][i] = 0.f;
					} else {
						shape.vertices[1][i] = reader.read<float>();
					}
				}
			}

			if (shape.type == CollisionShape::Shape::Sphere || shape.type == CollisionShape::Shape::Cylinder) {
				if (reader.remaining() > 0) {
					shape.radius = reader.read<float>();
				} else {
					shape.radius = 0.f;
				}
			}
			collision_shapes.push_back(std::move(shape));
		}
	}

	void MDX::read_CORN_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			CornEmitter emitter;
			const int node_reader_pos = reader.position;
			const uint32_t inclusive_size = reader.read<uint32_t>();
			emitter.node = Node(reader, unique_tracks);
			emitter.data = reader.read_vector<uint8_t>(inclusive_size - (reader.position - node_reader_pos));
			corn_emitters.push_back(std::move(emitter));
		}
	}

	void MDX::read_CAMS_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			Camera camera;
			const uint32_t inclusive_size = reader.read<uint32_t>();

			camera.data = reader.read_vector<uint8_t>(inclusive_size - 4);
			cameras.push_back(std::move(camera));
		}
	}

	void MDX::read_BPOS_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		bind_poses = reader.read_vector<float>(reader.read<uint32_t>() * 12);
	}

	void MDX::read_TXAN_chunk(BinaryReader& reader) {
		const size_t reader_pos = reader.position;
		const uint32_t size = reader.read<uint32_t>();

		while (reader.position < reader_pos + size) {
			TextureAnimation animation;
			const uint32_t inclusive_size = reader.read<uint32_t>();

			animation.data = reader.read_vector<uint8_t>(inclusive_size - 4);
			texture_animations.push_back(std::move(animation));
		}
	}

	void MDX::read_FAFX_chunk(BinaryReader& reader) {
		const uint32_t size = reader.read<uint32_t>();
		for (size_t i = 0; i < size / 340; i++) {
			FaceFX facefx;
			facefx.name = reader.read_string(80);
			facefx.path = reader.read_string(260);
			facefxes.push_back(std::move(facefx));
		}
	}

	void MDX::load(BinaryReader& reader) {
		const std::string magic_number = reader.read_string(4);
		if (magic_number != "MDLX") {
			fmt::print("Incorrect file magic number, expected MDLX but got {}\n", magic_number);
			return;
		}

		while (reader.remaining() > 0) {
			uint32_t header = reader.read<uint32_t>();

			switch (static_cast<ChunkTag>(header)) {
				case ChunkTag::VERS:
					reader.advance(4);
					version = reader.read<uint32_t>();
					break;
				case ChunkTag::MODL:
					reader.advance(4);
					name = reader.read_string(80);
					animation_filename = reader.read_string(260);
					extent = Extent(reader);
					blend_time = reader.read<uint32_t>();
					break;
				case ChunkTag::GEOS:
					read_GEOS_chunk(reader);
					break;
				case ChunkTag::MTLS:
					read_MTLS_chunk(reader);
					break;
				case ChunkTag::SEQS:
					read_SEQS_chunk(reader);
					break;
				case ChunkTag::GLBS:
					read_GLBS_chunk(reader);
					break;
				case ChunkTag::GEOA:
					read_GEOA_chunk(reader);
					break;
				case ChunkTag::BONE:
					read_BONE_chunk(reader);
					break;
				case ChunkTag::TEXS:
					read_TEXS_chunk(reader);
					break;
				case ChunkTag::LITE:
					read_LITE_chunk(reader);
					break;
				case ChunkTag::HELP:
					read_HELP_chunk(reader);
					break;
				case ChunkTag::ATCH:
					read_ATCH_chunk(reader);
					break;
				case ChunkTag::PIVT:
					read_PIVT_chunk(reader);
					break;
				case ChunkTag::PREM:
					read_PREM_chunk(reader);
					break;
				case ChunkTag::PRE2:
					read_PRE2_chunk(reader);
					break;
				case ChunkTag::RIBB:
					read_RIBB_chunk(reader);
					break;
				case ChunkTag::EVTS:
					read_EVTS_chunk(reader);
					break;
				case ChunkTag::CLID:
					read_CLID_chunk(reader);
					break;
				case ChunkTag::CORN:
					read_CORN_chunk(reader);
					break;
				case ChunkTag::FAFX:
					read_FAFX_chunk(reader);
					break;
				case ChunkTag::CAMS:
					read_CAMS_chunk(reader);
					break;
				case ChunkTag::BPOS:
					read_BPOS_chunk(reader);
					break;
				case ChunkTag::TXAN:
					read_TXAN_chunk(reader);
					break;
				default:
					reader.advance(reader.read<uint32_t>());
			}
		}

		validate();
	}
}
```

`src/File Formats/MDX/MDXWriter.cpp`:

```cpp
module;

#include <string>
#include <fmt/format.h>
#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <filesystem>
#include <fstream>

module MDX;

namespace fs = std::filesystem;

namespace mdx {
	void MDX::write_GEOS_chunk(BinaryWriter& writer) const {
		if (geosets.empty()) {
			return;
		}

		writer.write(ChunkTag::GEOS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& geoset : geosets) {
			// Write temporary zero, remember location
			const size_t geoset_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_string("VRTX");
			writer.write<uint32_t>(geoset.vertices.size());
			writer.write_vector(geoset.vertices);

			writer.write_string("NRMS");
			writer.write<uint32_t>(geoset.normals.size());
			writer.write_vector(geoset.normals);

			writer.write_string("PTYP");
			writer.write<uint32_t>(geoset.face_type_groups.size());
			writer.write_vector(geoset.face_type_groups);

			writer.write_string("PCNT");
			writer.write<uint32_t>(geoset.face_groups.size());
			writer.write_vector(geoset.face_groups);

			writer.write_string("PVTX");
			writer.write<uint32_t>(geoset.faces.size());
			writer.write_vector(geoset.faces);

			writer.write_string("GNDX");
			writer.write<uint32_t>(geoset.vertex_groups.size());
			writer.write_vector(geoset.vertex_groups);

			writer.write_string("MTGC");
			writer.write<uint32_t>(geoset.matrix_groups.size());
			writer.write_vector(geoset.matrix_groups);

			writer.write_string("MATS");
			writer.write<uint32_t>(geoset.matrix_indices.size());
			writer.write_vector(geoset.matrix_indices);

			writer.write<uint32_t>(geoset.material_id);
			writer.write<uint32_t>(geoset.selection_group);
			writer.write<uint32_t>(geoset.selection_flags);
			writer.write<uint32_t>(geoset.lod);
			writer.write_c_string_padded(geoset.lod_name, 80);

			geoset.extent.save(writer);
			writer.write<uint32_t>(geoset.extents.size());
			for (const auto& extent : geoset.extents) {
				extent.save(writer);
			}

			if (geoset.tangents.size()) {
				writer.write_string("TANG");
				writer.write<uint32_t>(geoset.tangents.size());
				writer.write_vector(geoset.tangents);
			}

			if (geoset.skin.size()) {
				writer.write_string("SKIN");
				writer.write<uint32_t>(geoset.skin.size());
				writer.write_vector(geoset.skin);
			}

			writer.write_string("UVAS");
			writer.write<uint32_t>(geoset.texture_coordinate_sets.size());
			for (const auto& set : geoset.texture_coordinate_sets) {
				writer.write_string("UVBS");
				writer.write<uint32_t>(set.size());
				writer.write_vector(set);
			}
			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - geoset_index);
			std::memcpy(writer.buffer.data() + geoset_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_MTLS_chunk(BinaryWriter& writer) const {
		if (materials.empty()) {
			return;
		}

		writer.write(ChunkTag::MTLS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& material : materials) {
			// Write temporary zero, remember location
			const size_t material_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write<uint32_t>(material.priority_plane);
			writer.write<uint32_t>(material.flags);
			writer.write_string("LAYS");
			writer.write<uint32_t>(material.layers.size());

			for (const auto& layer : material.layers) {
				// Write temporary zero, remember location
				const size_t layer_index = writer.buffer.size();
				writer.write<uint32_t>(0);

				writer.write<uint32_t>(layer.blend_mode);
				writer.write<uint32_t>(layer.shading_flags);
				writer.write<uint32_t>(0); // texture_id irrelevant when writing V1100
				writer.write<uint32_t>(layer.texture_animation_id);
				writer.write<uint32_t>(layer.coord_id);
				writer.write<float>(layer.alpha);

				writer.write<float>(layer.emissive_gain);
				writer.write<glm::vec3>(layer.fresnel_color);
				writer.write<float>(layer.fresnel_opacity);
				writer.write<float>(layer.fresnel_team_color);

				writer.write<uint32_t>(layer.hd);
				writer.write<uint32_t>(layer.textures.size());


				for (size_t i = 0; i < layer.textures.size(); i++) {
					writer.write<uint32_t>(layer.textures[i].id);
					writer.write<uint32_t>(i);
					layer.textures[i].KMTF.save(TrackTag::KMTF, writer);
				}

				layer.KMTA.save(TrackTag::KMTA, writer);
				layer.KMTE.save(TrackTag::KMTE, writer);
				layer.KFC3.save(TrackTag::KFC3, writer);
				layer.KFCA.save(TrackTag::KFCA, writer);
				layer.KFTC.save(TrackTag::KFTC, writer);

				const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - layer_index);
				std::memcpy(writer.buffer.data() + layer_index, &temporary, 4);
			}
			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - material_index);
			std::memcpy(writer.buffer.data() + material_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_SEQS_chunk(BinaryWriter& writer) const {
		if (sequences.empty()) {
			return;
		}

		writer.write(ChunkTag::SEQS);
		writer.write<uint32_t>(sequences.size() * 132);
		for (const auto& i : sequences) {
			writer.write_c_string_padded(i.name, 80);
			writer.write<uint32_t>(i.start_frame);
			writer.write<uint32_t>(i.end_frame);
			writer.write<float>(i.movespeed);
			writer.write<uint32_t>(i.flags);
			writer.write<float>(i.rarity);
			writer.write<uint32_t>(i.sync_point);
			i.extent.save(writer);
		}
	}

	void MDX::write_GLBS_chunk(BinaryWriter& writer) const {
		if (global_sequences.empty()) {
			return;
		}

		writer.write(ChunkTag::GLBS);
		writer.write<uint32_t>(global_sequences.size() * 4);
		writer.write_vector(global_sequences);
	}

	void MDX::write_GEOA_chunk(BinaryWriter& writer) const {
		if (animations.empty()) {
			return;
		}

		writer.write(ChunkTag::GEOA);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& geoset_animation : animations) {
			// Write temporary zero, remember location
			const size_t geoset_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write<float>(geoset_animation.alpha);
			writer.write<uint32_t>(geoset_animation.flags);
			writer.write<glm::vec3>(geoset_animation.color);
			writer.write<uint32_t>(geoset_animation.geoset_id);

			geoset_animation.KGAO.save(TrackTag::KGAO, writer);
			geoset_animation.KGAC.save(TrackTag::KGAC, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - geoset_index);
			std::memcpy(writer.buffer.data() + geoset_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_BONE_chunk(BinaryWriter& writer) const {
		if (bones.empty()) {
			return;
		}

		writer.write(ChunkTag::BONE);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& bone : bones) {
			bone.node.save(writer);
			writer.write<int32_t>(bone.geoset_id);
			writer.write<int32_t>(bone.geoset_animation_id);
		}
		const uint32_t temporary = writer.buffer.size() - inclusive_index - 4;
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_TEXS_chunk(BinaryWriter& writer) const {
		if (textures.empty()) {
			return;
		}

		writer.write(ChunkTag::TEXS);
		writer.write<uint32_t>(textures.size() * 268);
		for (const auto& texture : textures) {
			writer.write<uint32_t>(texture.replaceable_id);
			writer.write_c_string_padded(texture.file_name.string(), 260);
			writer.write<uint32_t>(texture.flags);
		}
	}

	void MDX::write_LITE_chunk(BinaryWriter& writer) const {
		if (lights.empty()) {
			return;
		}

		writer.write(ChunkTag::LITE);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& light : lights) {
			// Write temporary zero, remember location
			const size_t light_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			light.node.save(writer);
			writer.write<uint32_t>(light.type);
			writer.write<float>(light.attenuation_start);
			writer.write<float>(light.attenuation_end);
			writer.write<glm::vec3>(light.color);
			writer.write<float>(light.intensity);
			writer.write<glm::vec3>(light.ambient_color);
			writer.write<float>(light.ambient_intensity);

			light.KLAS.save(TrackTag::KLAS, writer);
			light.KLAE.save(TrackTag::KLAE, writer);
			light.KLAC.save(TrackTag::KLAC, writer);
			light.KLAI.save(TrackTag::KLAI, writer);
			light.KLBI.save(TrackTag::KLBI, writer);
			light.KLBC.save(TrackTag::KLBC, writer);
			light.KLAV.save(TrackTag::KLAV, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - light_index);
			std::memcpy(writer.buffer.data() + light_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_HELP_chunk(BinaryWriter& writer) const {
		if (help_bones.empty()) {
			return;
		}

		writer.write(ChunkTag::HELP);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& help_bone : help_bones) {
			help_bone.save(writer);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_ATCH_chunk(BinaryWriter& writer) const {
		if (attachments.empty()) {
			return;
		}

		writer.write(ChunkTag::ATCH);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& attachment : attachments) {
			// Write temporary zero, remember location
			const size_t attachment_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			attachment.node.save(writer);
			writer.write_c_string_padded(attachment.path, 256);
			writer.write<uint32_t>(attachment.reserved);
			writer.write<uint32_t>(attachment.attachment_id);

			attachment.KATV.save(TrackTag::KATV, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - attachment_index);
			std::memcpy(writer.buffer.data() + attachment_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_PIVT_chunk(BinaryWriter& writer) const {
		if (pivots.empty()) {
			return;
		}

		writer.write(ChunkTag::PIVT);
		writer.write<uint32_t>(pivots.size() * 12);
		for (const auto& pivot : pivots) {
			writer.write<glm::vec3>(pivot);
		}
	}

	void MDX::write_PREM_chunk(BinaryWriter& writer) const {
		if (emitters1.empty()) {
			return;
		}

		writer.write(ChunkTag::PREM);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& emitter : emitters1) {
			// Write temporary zero, remember location
			const size_t emitter_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			emitter.node.save(writer);
			writer.write<float>(emitter.emission_rate);
			writer.write<float>(emitter.gravity);
			writer.write<float>(emitter.longitude);
			writer.write<float>(emitter.latitude);
			writer.write_c_string_padded(emitter.path, 260);
			writer.write<uint32_t>(emitter.reserved);
			writer.write<float>(emitter.life_span);
			writer.write<float>(emitter.speed);

			emitter.KPEE.save(TrackTag::KPEE, writer);
			emitter.KPEG.save(TrackTag::KPEG, writer);
			emitter.KPLN.save(TrackTag::KPLN, writer);
			emitter.KPLT.save(TrackTag::KPLT, writer);
			emitter.KPEL.save(TrackTag::KPEL, writer);
			emitter.KPES.save(TrackTag::KPES, writer);
			emitter.KPEV.save(TrackTag::KPEV, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - emitter_index);
			std::memcpy(writer.buffer.data() + emitter_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_PRE2_chunk(BinaryWriter& writer) const {
		if (emitters2.empty()) {
			return;
		}

		writer.write(ChunkTag::PRE2);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& emitter : emitters2) {
			// Write temporary zero, remember location
			const size_t emitter_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			emitter.node.save(writer);
			writer.write<float>(emitter.speed);
			writer.write<float>(emitter.variation);
			writer.write<float>(emitter.latitude);
			writer.write<float>(emitter.gravity);
			writer.write<float>(emitter.life_span);
			writer.write<float>(emitter.emission_rate);
			writer.write<float>(emitter.length);
			writer.write<float>(emitter.width);
			writer.write<uint32_t>(emitter.filter_mode);
			writer.write<uint32_t>(emitter.rows);
			writer.write<uint32_t>(emitter.columns);
			writer.write<uint32_t>(emitter.head_or_tail);
			writer.write<float>(emitter.tail_length);
			writer.write<float>(emitter.time_middle);

			writer.write<glm::vec3>(emitter.start_segment_color);
			writer.write<glm::vec3>(emitter.middle_segment_color);
			writer.write<glm::vec3>(emitter.end_segment_color);

			writer.write<glm::u8vec3>(emitter.segment_alphas);
			writer.write<glm::vec3>(emitter.segment_scaling);
			writer.write<glm::uvec3>(emitter.head_intervals);
			writer.write<glm::uvec3>(emitter.head_decay_intervals);
			writer.write<glm::uvec3>(emitter.tail_intervals);
			writer.write<glm::uvec3>(emitter.tail_decay_intervals);

			writer.write<uint32_t>(emitter.texture_id);
			writer.write<uint32_t>(emitter.squirt);
			writer.write<uint32_t>(emitter.priority_plane);
			writer.write<uint32_t>(emitter.replaceable_id);

			emitter.KP2R.save(TrackTag::KP2R, writer);
			emitter.KP2L.save(TrackTag::KP2L, writer);
			emitter.KP2G.save(TrackTag::KP2G, writer);
			emitter.KP2E.save(TrackTag::KP2E, writer);
			emitter.KP2N.save(TrackTag::KP2N, writer);
			emitter.KP2W.save(TrackTag::KP2W, writer);
			emitter.KP2V.save(TrackTag::KP2V, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - emitter_index);
			std::memcpy(writer.buffer.data() + emitter_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_RIBB_chunk(BinaryWriter& writer) const {
		if (ribbons.empty()) {
			return;
		}

		writer.write(ChunkTag::RIBB);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& ribbon : ribbons) {
			// Write temporary zero, remember location
			const size_t ribbon_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			ribbon.node.save(writer);
			writer.write<float>(ribbon.height_above);
			writer.write<float>(ribbon.height_below);
			writer.write<float>(ribbon.alpha);
			writer.write<glm::vec3>(ribbon.color);
			writer.write<float>(ribbon.life_span);
			writer.write<uint32_t>(ribbon.texture_slot);
			writer.write<uint32_t>(ribbon.emission_rate);
			writer.write<uint32_t>(ribbon.rows);
			writer.write<uint32_t>(ribbon.columns);
			writer.write<uint32_t>(ribbon.material_id);
			writer.write<float>(ribbon.gravity);

			ribbon.KRHA.save(TrackTag::KRHA, writer);
			ribbon.KRHB.save(TrackTag::KRHB, writer);
			ribbon.KRAL.save(TrackTag::KRAL, writer);
			ribbon.KRCO.save(TrackTag::KRCO, writer);
			ribbon.KRTX.save(TrackTag::KRTX, writer);
			ribbon.KRVS.save(TrackTag::KRVS, writer);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - ribbon_index);
			std::memcpy(writer.buffer.data() + ribbon_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_EVTS_chunk(BinaryWriter& writer) const {
		if (event_objects.empty()) {
			return;
		}

		writer.write(ChunkTag::EVTS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& event_object : event_objects) {
			event_object.node.save(writer);
			writer.write_string("KEVT");
			writer.write<uint32_t>(event_object.times.size());
			writer.write<int32_t>(event_object.global_sequence_id);
			writer.write_vector(event_object.times);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_CLID_chunk(BinaryWriter& writer) const {
		if (collision_shapes.empty()) {
			return;
		}

		writer.write(ChunkTag::CLID);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& shape : collision_shapes) {
			shape.node.save(writer);
			writer.write<uint32_t>(static_cast<uint32_t>(shape.type));

			if (shape.type == CollisionShape::Shape::Sphere) {
				writer.write<glm::vec3>(shape.vertices[0]);
			} else {
				writer.write<glm::vec3>(shape.vertices[0]);
				writer.write<glm::vec3>(shape.vertices[1]);
			}
			if (shape.type == CollisionShape::Shape::Sphere || shape.type == CollisionShape::Shape::Cylinder) {
				writer.write<float>(shape.radius);
			}
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_CORN_chunk(BinaryWriter& writer) const {
		if (corn_emitters.empty()) {
			return;
		}

		writer.write(ChunkTag::CORN);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& corn : corn_emitters) {
			// Write temporary zero, remember location
			const size_t corn_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			corn.node.save(writer);
			writer.write_vector(corn.data);

			const uint32_t temporary = writer.buffer.size() - corn_index;
			std::memcpy(writer.buffer.data() + corn_index, &temporary, 4);
		}
		const uint32_t temporary = writer.buffer.size() - inclusive_index - 4;
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_CAMS_chunk(BinaryWriter& writer) const {
		if (cameras.empty()) {
			return;
		}

		writer.write(ChunkTag::CAMS);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& camera : cameras) {
			// Write temporary zero, remember location
			const size_t camera_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_vector(camera.data);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - camera_index);
			std::memcpy(writer.buffer.data() + camera_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_BPOS_chunk(BinaryWriter& writer) const {
		if (bind_poses.empty()) {
			return;
		}

		writer.write(ChunkTag::BPOS);
		writer.write<uint32_t>(4 + bind_poses.size() * 4);
		writer.write<uint32_t>(bind_poses.size() / 12);
		writer.write_vector(bind_poses);
	}

	void MDX::write_TXAN_chunk(BinaryWriter& writer) const {
		if (texture_animations.empty()) {
			return;
		}

		writer.write(ChunkTag::TXAN);
		// Write temporary zero, remember location
		const size_t inclusive_index = writer.buffer.size();
		writer.write<uint32_t>(0);

		for (const auto& texture_animation : texture_animations) {
			// Write temporary zero, remember location
			const size_t texture_animation_index = writer.buffer.size();
			writer.write<uint32_t>(0);

			writer.write_vector(texture_animation.data);

			const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - texture_animation_index);
			std::memcpy(writer.buffer.data() + texture_animation_index, &temporary, 4);
		}
		const uint32_t temporary = static_cast<uint32_t>(writer.buffer.size() - inclusive_index - 4);
		std::memcpy(writer.buffer.data() + inclusive_index, &temporary, 4);
	}

	void MDX::write_FAFX_chunk(BinaryWriter& writer) const {
		if (facefxes.empty()) {
			return;
		}

		writer.write(ChunkTag::FAFX);
		writer.write<uint32_t>(facefxes.size() * 340);
		for (const auto& facefx : facefxes) {
			writer.write_c_string_padded(facefx.name, 80);
			writer.write_c_string_padded(facefx.path.string(), 260);
		}
	}

	void MDX::save(const fs::path& path) {
		BinaryWriter writer;

		writer.write_string("MDLX");
		writer.write(ChunkTag::VERS);
		writer.write<uint32_t>(4);
		writer.write<uint32_t>(1100);

		writer.write(ChunkTag::MODL);
		writer.write<uint32_t>(372);
		writer.write_c_string_padded(name, 80);
		writer.write_c_string_padded(animation_filename, 260);
		extent.save(writer);
		writer.write<uint32_t>(blend_time);

		write_SEQS_chunk(writer);
		write_MTLS_chunk(writer);
		write_TEXS_chunk(writer);
		write_GEOS_chunk(writer);
		write_GEOA_chunk(writer);
		write_BONE_chunk(writer);
		write_GLBS_chunk(writer);
		write_LITE_chunk(writer);
		write_HELP_chunk(writer);
		write_ATCH_chunk(writer);
		write_PIVT_chunk(writer);
		write_PREM_chunk(writer);
		write_PRE2_chunk(writer);
		write_RIBB_chunk(writer);
		write_CAMS_chunk(writer);
		write_EVTS_chunk(writer);
		write_CLID_chunk(writer);
		write_CORN_chunk(writer);
		write_FAFX_chunk(writer);
		write_BPOS_chunk(writer);
		write_TXAN_chunk(writer);

		std::ofstream file(path, std::ios::binary | std::ios::out);
		file.write(reinterpret_cast<char*>(writer.buffer.data()), writer.buffer.size());
	}
}
```

`src/File Formats/MPQ.ixx`:

```ixx
module;

#include <string>
#include <vector>
#include <stdexcept>
#include <optional>
#include <iostream>
#include <filesystem>

#define STORMLIB_NO_AUTO_LINK
#include <StormLib.h>

export module MPQ;

namespace fs = std::filesystem;

// A thin wrapper around StormLib https://github.com/ladislav-zezula/StormLib
namespace mpq {
	export class File {
	  public:
		HANDLE handle = nullptr;

		File() = default;
		~File() {
			close();
		}
		File(File&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		File(const File&) = default;
		File& operator=(const File&) = default;
		File& operator=(File&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		std::vector<uint8_t> read() const {
			const uint32_t size = SFileGetFileSize(handle, nullptr);
			if (size == 0) {
				return {};
			}

			std::vector<uint8_t> buffer(size);

#ifdef _MSC_VER
			unsigned long bytes_read;
#else
			unsigned int bytes_read;
#endif
			const bool success = SFileReadFile(handle, buffer.data(), size, &bytes_read, nullptr);
			if (!success) {
				throw std::runtime_error("Failed to read file: " + std::to_string(GetLastError()));
			}
			return buffer;
		}

		/// An implementation using optional. Use this for all reads?
		std::optional<std::vector<uint8_t>> read2() const {
			const uint32_t size = SFileGetFileSize(handle, nullptr);
			if (size == 0) {
				return {};
			}

			std::vector<uint8_t> buffer(size);

#ifdef _MSC_VER
			unsigned long bytes_read;
#else
			unsigned int bytes_read;
#endif
			const bool success = SFileReadFile(handle, buffer.data(), size, &bytes_read, nullptr);
			if (!success) {
				std::cout << "Failed to read file: " << GetLastError() << std::endl;
			}
			return buffer;
		}

		size_t size() const {
			return SFileGetFileSize(handle, nullptr);
		}

		void close() const {
			SFileCloseFile(handle);
		}
	};

	export class MPQ {
	  public:
		HANDLE handle = nullptr;

		MPQ() = default;

		explicit MPQ(const fs::path& path, const unsigned long flags = 0) {
			open(path, flags);
		}

		~MPQ() {
			close();
		}
		MPQ(MPQ&& move)
		noexcept {
			handle = move.handle;
			move.handle = nullptr;
		}
		MPQ(const MPQ&) = default;
		MPQ& operator=(const MPQ&) = delete;
		MPQ& operator=(MPQ&& move) noexcept {
			handle = move.handle;
			move.handle = nullptr;
			return *this;
		}

		bool open(const fs::path& path, const unsigned long flags = 0) {
			return SFileOpenArchive(path.c_str(), 0, flags, &handle);
		}

		void close() {
			SFileCloseArchive(handle);
			handle = nullptr;
		}

		bool compact() {
			return SFileCompactArchive(handle, nullptr, false);
		}

		bool unpack(const fs::path& path) {
			SFILE_FIND_DATA file_data;
			HANDLE find_handle = SFileFindFirstFile(handle, "*", &file_data, nullptr);
			fs::create_directories((path / file_data.cFileName).parent_path());
			SFileExtractFile(handle, file_data.cFileName, (path / file_data.cFileName).c_str(), SFILE_OPEN_FROM_MPQ);

			while (SFileFindNextFile(find_handle, &file_data)) {
				fs::create_directories((path / file_data.cFileName).parent_path());
				SFileExtractFile(handle, file_data.cFileName, (path / file_data.cFileName).c_str(), SFILE_OPEN_FROM_MPQ);
			}
			SFileFindClose(find_handle);

			// Delete unneeded files
			fs::remove(path / "(listfile)");
			fs::remove(path / "(attributes)");
			fs::remove(path / "(war3map.imp)");
			return true;
		}

		File file_open(const fs::path& path) const {
			File file;
#ifdef WIN32
			const bool opened = SFileOpenFileEx(handle, fs::weakly_canonical(path).string().c_str(), 0, &file.handle);
#else
			const bool opened = SFileOpenFileEx(handle, path.string().c_str(), 0, &file.handle);
#endif
			if (!opened) {
				throw std::runtime_error("Failed to read file " + path.string() + " with error: " + std::to_string(GetLastError()));
			}
			return file;
		}

		void file_write(const fs::path& path, const std::vector<uint8_t>& data) const {
			HANDLE out_handle;
			bool success = SFileCreateFile(handle, path.string().c_str(), 0, static_cast<DWORD>(data.size()), 0, MPQ_FILE_COMPRESS | MPQ_FILE_REPLACEEXISTING, &out_handle);
			if (!success) {
				std::cout << GetLastError() << " " << path << "\n";
			}

			success = SFileWriteFile(out_handle, data.data(), static_cast<DWORD>(data.size()), MPQ_COMPRESSION_ZLIB);
			if (!success) {
				std::cout << "Writing to file failed: " << GetLastError() << " " << path << "\n";
			}

			success = SFileFinishFile(out_handle);
			if (!success) {
				std::cout << "Finishing write failed: " << GetLastError() << " " << path << "\n";
			}
		}

		void file_remove(const fs::path& path) const {
			SFileRemoveFile(handle, path.string().c_str(), 0);
		}

		bool file_exists(const fs::path& path) const {
#ifdef WIN32
			return SFileHasFile(handle, fs::weakly_canonical(path).string().c_str());
#else
			return SFileHasFile(handle, path.string().c_str());
#endif
		}

		void file_add(const fs::path& path, const fs::path& new_path) const {
#ifdef _MSC_VER
			bool success = SFileAddFileEx(handle, path.wstring().c_str(), new_path.string().c_str(), MPQ_FILE_COMPRESS | MPQ_FILE_REPLACEEXISTING, MPQ_COMPRESSION_ZLIB, MPQ_COMPRESSION_ZLIB);
#else
			bool success = SFileAddFileEx(handle, path.string().c_str(), new_path.string().c_str(), MPQ_FILE_COMPRESS | MPQ_FILE_REPLACEEXISTING, MPQ_COMPRESSION_ZLIB, MPQ_COMPRESSION_ZLIB);
#endif
			if (!success) {
				std::cout << "Error adding file: " << GetLastError() << "\n";
			}
		}
	};
} // namespace mpq
```

`src/File Formats/SLK.cpp`:

```cpp
#include "SLK.h"

#include <random>
#include <fstream>
#include <numeric>
#include <string_view>
#include <charconv>
#include <absl/container/flat_hash_set.h>
#include <absl/strings/str_split.h>
#include <absl/strings/str_join.h>

import Hierarchy;

#include "Utilities.h"
import BinaryReader;

#undef mix
#undef max

using namespace std::string_literals;

namespace slk {
	SLK::SLK(const fs::path& path, const bool local) {
		load(path, local);
	}

	void SLK::load(const fs::path& path, const bool local) {
		std::vector<uint8_t, default_init_allocator<uint8_t>> buffer;
		if (local) {
			std::ifstream stream(path, std::ios::binary);
			buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>());
		} else {
			buffer = hierarchy.open_file(path).buffer;
		}

		std::string_view view(reinterpret_cast<char*>(buffer.data()), buffer.size());

		if (!view.starts_with("ID")) {
			std::cout << "Invalid SLK file, does not contain \"ID\" as first record" << std::endl;
			return;
		}

		const auto parse_integer = [&]() {
			size_t value;
			size_t separator = view.find(';');
			std::from_chars(&view[1], &view[separator], value);
			view.remove_prefix(separator + 1);
			return value;
		};

		// Skip first ID line
		view.remove_prefix(view.find('\n') + 1);

		size_t column = 0;
		size_t row = 0;

		while (view.size()) {
			switch (view.front()) {
				case 'C':
					view.remove_prefix(2);
					
					if (view.front() == 'X') {
						column = parse_integer() - 1;

						if (view.front() == 'Y') {
							row = parse_integer() - 1;
						}
					} else {
						row = parse_integer() - 1;

						if (view.front() == 'X') {
							column = parse_integer() - 1;
						}
					}

					if (row == 0 && column == 0) {
						view.remove_prefix(view.find('\n') + 1);
						break;
					}

					view.remove_prefix(1);

					{
						std::string data;
						if (view.front() == '\"') {
							data = view.substr(1, view.find('"', 1) - 1);
						} else {
							data = view.substr(0, view.find_first_of("\r\n"));
						}

						if (data == "-" || data == "_") {
							data = "";
						}

						if (column == 0) {
							// -1 as 0,0 is unitid/doodadid etc.
							row_headers.emplace(data, row - 1);
							index_to_row.emplace(row - 1, data);
						} else if (row == 0) {
							// If it is a column header we need to lowercase it as column headers are case insensitive
							to_lowercase(data);
							// -1 as 0,0 is unitid/doodadid etc.
							column_headers.emplace(data, column - 1);
							index_to_column.emplace(column - 1, data);
						} else {
							base_data[index_to_row[row - 1]][index_to_column[column - 1]] = data;
						}

						view.remove_prefix(view.find('\n') + 1);
					}
					break;
				case 'F':
					if (view.front() == 'X') {
						column = parse_integer() - 1;

						if (view.front() == 'Y') {
							row = parse_integer() - 1;
						}
					} else {
						row = parse_integer() - 1;

						if (view.front() == 'X') {
							column = parse_integer() - 1;
						}
					}
					view.remove_prefix(view.find('\n') + 1);
					break;
				default:
					view.remove_prefix(view.find_first_of('\n') + 1);
			}
		}
	}
	void SLK::build_meta_map() {
		// Check if we are a meta_slk
		if (!column_headers.contains("field")) {
			return;
		}

		for (const auto& [header, row] : row_headers) {
			std::string field = to_lowercase_copy(data("field", header));

			const int repeat = data<int>("data", header);
			if (repeat > 0) {
				field += 'a' + (repeat - 1);
			}
			if (column_headers.contains("usespecific")) {
				std::vector<std::string> parts = absl::StrSplit(data("usespecific", header), ",");
				if (!parts.empty()) {
					for (const auto& i : parts) {
						meta_map.emplace(field, header + i);
					}
				} else {
					meta_map.emplace(field, header);
				}
			} else {
				meta_map.emplace(field, header);
			}
		}
	}

	// Merges the base data of the files
	// Shadow data is not merged
	// Any unknown columns are appended
	void SLK::merge(const slk::SLK& slk) {
		for (const auto& [header, index] : slk.column_headers) {
			if (!column_headers.contains(header)) {
				add_column(header);
			}
		}

		for (const auto& [id, properties] : slk.base_data) {
			if (!base_data.contains(id)) {
				continue;
			}
			base_data[id].insert(properties.begin(), properties.end());
		}
	}

	/// Merges the data of the files. INI sections are matched to row keys and INI keys are matched to column keys.
	/// If an unknown section key is encountered then that section is skipped
	/// If an unknown column key is encountered then the column is added
	void SLK::merge(const ini::INI& ini, const SLK& meta_slk) {
		for (const auto& [section_key, section_value] : ini.ini_data) {
			if (!base_data.contains(section_key)) {
				continue;
			}

			for (const auto& [key, value] : section_value) {
				std::string key_lower = to_lowercase_copy(key);

				if (!column_headers.contains(key_lower)) {
					add_column(key_lower);
				}

				// By making some changes to unitmetadata.slk and unitdata.slk we can avoid the 1->2->2 mapping for SLK->OE->W3U files.
				// This means we have to manually split these into the correct column
				if (value.size() > 1 && (
					key_lower == "missilearc" 
					|| key_lower == "missileart" 
					|| key_lower == "missilehoming" 
					|| key_lower == "missilespeed" 
					|| key_lower == "buttonpos" 
					|| key_lower == "unbuttonpos" 
					|| key_lower == "researchbuttonpos") && column_headers.contains(key_lower + "2")) {

					base_data[section_key][key_lower] = value[0];
					base_data[section_key][key_lower + "2"] = value[1];
					continue;
				}
				
				const std::string key_lower_stripped = key_lower.substr(0, key_lower.find_first_of(':'));

				std::string id;
				if (meta_slk.meta_map.contains(key_lower_stripped)) {
					id = meta_slk.meta_map.at(key_lower_stripped);
				} else if (meta_slk.meta_map.contains(key_lower_stripped + section_key)) {
					id = meta_slk.meta_map.at(key_lower_stripped + section_key);
				} else {
					size_t nr_position = key_lower_stripped.find_first_of("0123456789");
					std::string without_numbers = key_lower_stripped.substr(0, nr_position);

					if (meta_slk.meta_map.contains(without_numbers)) {
						id = meta_slk.meta_map.at(without_numbers);
					} else {
						continue;
					}
				}

				const int repeat = meta_slk.data<int>("repeat", id);
				if (repeat > 0 && !(meta_slk.column_headers.contains("appendindex") && meta_slk.data<int>("appendindex", id) > 0)) {
					for (size_t i = 0; i < value.size(); i++) {
						const std::string new_key = key_lower + std::to_string(i + 1);
						if (!column_headers.contains(new_key)) {
							add_column(new_key);
						}
						base_data[section_key][new_key] = value[i];
					}
					continue;
				} else {
					if (meta_slk.data<std::string>("type", id).ends_with("List")) {
						base_data[section_key][key_lower] = absl::StrJoin(value, ",");
					} else {
						base_data[section_key][key_lower] = value[0];
					
					}
				}
			}
		}
	}

	/// Substitutes the data of the slk with data from the INI based on a certain section key.
	/// The keys of the section are matched with all the cells in the table and if they match will replace the value
	void SLK::substitute(const ini::INI& ini, const std::string& section) {
		assert(ini.section_exists(section));

		for (auto& [id, properties] : base_data) {
			for (auto& [prop_id, prop_value] : properties) {
				std::string data = ini.data(section, prop_value);
				if (!data.empty()) {
					prop_value = data;
				}
			}
		}
	}

	/// Copies the row with header row_header to a new line with the new header as new_row_header
	void SLK::copy_row(const std::string_view row_header, std::string_view new_row_header, bool copy_shadow_data) {
		assert(base_data.contains(row_header));
		assert(!base_data.contains(new_row_header));

		// Get a weird allocation error if not done via a temporary 19/06/2021
		const auto t = base_data.at(row_header);
		base_data[new_row_header] = t;

		if (copy_shadow_data && shadow_data.contains(row_header)) {
			// Get a weird allocation error if not done via a temporary 19/06/2021
			const auto tt = shadow_data.at(row_header);
			shadow_data[new_row_header] = tt;
		}

		size_t index = row_headers.size();
		row_headers.emplace(new_row_header, index);
		index_to_row[index] = new_row_header;
		
		// Only set/change oldid if the row didn't have one (which means it is a default unit/item/...)
		if (!shadow_data[new_row_header].contains("oldid")) {
			shadow_data[new_row_header]["oldid"] = row_header;
		}
	}

	void SLK::remove_row(const std::string_view row_header) {
		assert(base_data.contains(row_header));

		base_data.erase(row_header);
		shadow_data.erase(row_header);
		
		const size_t index = row_headers.at(row_header);
		if (index == rows() - 1) {
			index_to_row.erase(index);
			row_headers.erase(row_header);
		} else {
			// Swap with a element from the end to avoid having to change all indices
			const std::string replacement_id = index_to_row.at(rows() - 1);
			index_to_row[index] = replacement_id;
			row_headers[replacement_id] = index;
			index_to_row.erase(rows() - 1);

			row_headers.erase(row_header);
		}
	}

	/// Adds a (virtual) column
	/// Since SLK2 is only a key/pair store it emulates being table like and thus this call is very cheap memory/cpu wise
	/// column_header must be lowercase
	void SLK::add_column(const std::string_view column_header) {
		assert(to_lowercase_copy(column_header) == column_header);

		size_t index = column_headers.size();
		column_headers.emplace(column_header, index);
		index_to_column[index] = column_header;
	}

	// column_header should be lowercase
	void SLK::set_shadow_data(const std::string_view column_header, const std::string_view row_header, std::string data) {
		assert(to_lowercase_copy(column_header) == column_header);

		if (!column_headers.contains(column_header)) {
			add_column(column_header);
		}

		if (base_data.contains(row_header) && base_data.at(row_header).contains(column_header)) {
			if (base_data.at(row_header).at(column_header) == data) {
				if (shadow_data.contains(row_header)) {
					shadow_data.at(row_header).erase(column_header);
					if (shadow_data.at(row_header).empty()) {
						shadow_data.erase(row_header);
					}
				}
				return;
			}
		}

		shadow_data[row_header][column_header] = data;
	}

	void SLK::set_shadow_data(const int column, const int row, std::string data) {
		set_shadow_data(index_to_column.at(column), index_to_row.at(row), data);
	}
}

```

`src/File Formats/SLK.h`:

```h
#pragma once


#include <string>
#include <iostream>
#include <unordered_map>
#include <filesystem>
#include <INI.h>

namespace fs = std::filesystem;

import Hierarchy;

#include <absl/container/flat_hash_map.h>

extern std::string to_lowercase_copy(const std::string_view& string);
namespace slk {
	class SLK {

	public:
		absl::flat_hash_map<size_t, std::string> index_to_row;
		absl::flat_hash_map<size_t, std::string> index_to_column;
		absl::flat_hash_map<std::string, size_t> row_headers;
		absl::flat_hash_map<std::string, size_t> column_headers;
		absl::flat_hash_map<std::string, absl::flat_hash_map<std::string, std::string>> base_data;
		absl::flat_hash_map<std::string, absl::flat_hash_map<std::string, std::string>> shadow_data;

		// The following map is only used in meta SLKs and maps the field (+unit/ability ID) to a meta ID
		absl::flat_hash_map<std::string, std::string> meta_map;

		SLK() = default;
		explicit SLK(const fs::path & path, bool local = false);

		void load(const fs::path&, bool local = false);
		void build_meta_map();

		// column_header should be lowercase
		template <typename T = std::string>
		T data(std::string_view column_header, std::string_view row_header) const {
			assert(to_lowercase_copy(column_header) == column_header);

			// Todo, do find() directly as the .contains() and .at().at() do multiple lookups
			if (shadow_data.contains(row_header) && shadow_data.at(row_header).contains(column_header)) {
				if constexpr (std::is_same<T, std::string>()) {
					return shadow_data.at(row_header).at(column_header);
				} else if constexpr (std::is_same<T, float>()) {
					return std::stof(shadow_data.at(row_header).at(column_header));
				} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
					return std::stoi(shadow_data.at(row_header).at(column_header));
				}
			}

			//if (const auto found = column_headers.find(std::string(column_header) + ":hd"); found) {
			//	if (!found->first.empty()) {
			//		if constexpr (std::is_same<T, std::string>()) {
			//			return found->first;
			//		} else if constexpr (std::is_same<T, float>()) {
			//			return std::stof(found->first);
			//		} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
			//			return std::stoi(found->first);
			//		}
			//	}
			//}

			// Todo, do .find() directly as the .contains() and .at().at() do multiple lookups
			if (hierarchy.hd && column_headers.contains(std::string(column_header) + ":hd")) {
				std::string hd_data = data(std::string(column_header) + ":hd", row_header);
				if (!hd_data.empty()) {
					if constexpr (std::is_same<T, std::string>()) {
						return hd_data;
					} else if constexpr (std::is_same<T, float>()) {
						return std::stof(hd_data);
					} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
						return std::stoi(hd_data);
					}
				}
			}

			/*if (const auto found = base_data.find(row_header); found) {
				if (const auto found_sub = found->second.find(column_header); found_sub) {
					if constexpr (std::is_same<T, std::string>()) {
						return found_sub->second;
					} else if constexpr (std::is_same<T, float>()) {
						return std::stof(found_sub->second);
					} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
						return std::stoi(found_sub->second);
					}
				}
			}*/


			// Todo, do find() directly as the .contains() and .at().at() do multiple lookups
			if (base_data.contains(row_header) && base_data.at(row_header).contains(column_header)) {
				if constexpr (std::is_same<T, std::string>()) {
					return base_data.at(row_header).at(column_header);
				} else if constexpr (std::is_same<T, float>()) {
					return std::stof(base_data.at(row_header).at(column_header));
				} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
					return std::stoi(base_data.at(row_header).at(column_header));
				}
			}

			static_assert("Type not supported. Convert yourself or add conversion here if it makes sense");
			return T();
		}

		// Gets the data by first checking the shadow table and then checking the base table
		// Also does :hd tag resolution
		// column_header should be lowercase
		// If you have both an integer row index and the string row name then use the overload that takes string_view as it will do a index->name conversion internally
		template <typename T = std::string>
		T data(const std::string_view column_header, size_t row) const {
			if (row >= index_to_row.size()) {
				throw;
			}

			return data<T>(column_header, index_to_row.at(row));
		}

		// Gets the data by first checking the shadow table and then checking the base table
		template <typename T = std::string>
		T data(size_t column, size_t row) const {
			if (row >= index_to_row.size()) {
				throw;
			}

			if (column >= index_to_column.size()) {
				throw;
			}

			return data<T>(index_to_column.at(column), index_to_row.at(row));
		}

		void merge(const SLK& slk);
		void merge(const ini::INI& ini, const SLK& meta_slk);
		void substitute(const ini::INI& ini, const std::string& section);
		void copy_row(const std::string_view row_header, const std::string_view new_row_header, bool copy_shadow_data);
		void remove_row(const std::string_view row_header);

		void add_column(const std::string_view column_header);

		/// If the column does not exist then it will be created
		void set_shadow_data(const std::string_view column_header, const std::string_view row_header, std::string data);
		void set_shadow_data(const int column, const int row, std::string data);

		size_t rows() {
			return row_headers.size();
		}

		size_t columns() {
			return column_headers.size();
		}
	};
}

```

`src/File Formats/SLK.ixx`:

```ixx
module;

#include <absl/container/flat_hash_map.h>
#include <absl/container/flat_hash_set.h>
#include <absl/strings/str_split.h>
#include <absl/strings/str_join.h>

export module SLK;

import<string>;
import<iostream>;
import<unordered_map>;
import<filesystem>;
import<random>;
import<fstream>;
import<numeric>;
import<string_view>;
import<charconv>;
//import<absl/container/flat_hash_map.h>;
//import<absl/container/flat_hash_set.h>;
//import<absl/strings/str_split.h>;
//import<absl/strings/str_join.h>;

import INI;
import Hierarchy;
import Utilities;

namespace fs = std::filesystem;
using namespace std::string_literals;

namespace slk {
	export class SLK {

	  public:
		absl::flat_hash_map<size_t, std::string> index_to_row;
		absl::flat_hash_map<size_t, std::string> index_to_column;
		absl::flat_hash_map<std::string, size_t> row_headers;
		absl::flat_hash_map<std::string, size_t> column_headers;
		absl::flat_hash_map<std::string, absl::flat_hash_map<std::string, std::string>> base_data;
		absl::flat_hash_map<std::string, absl::flat_hash_map<std::string, std::string>> shadow_data;

		// The following map is only used in meta SLKs and maps the field (+unit/ability ID) to a meta ID
		absl::flat_hash_map<std::string, std::string> meta_map;

		SLK() = default;
		explicit SLK(const fs::path& path, const bool local) {
			load(path, local);
		}

		void load(const fs::path& path, const bool local) {
			std::vector<uint8_t, default_init_allocator<uint8_t>> buffer;
			if (local) {
				std::ifstream stream(path, std::ios::binary);
				buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>());
			} else {
				buffer = hierarchy.open_file(path).buffer;
			}

			std::string_view view(reinterpret_cast<char*>(buffer.data()), buffer.size());

			if (!view.starts_with("ID")) {
				std::cout << "Invalid SLK file, does not contain \"ID\" as first record" << std::endl;
				return;
			}

			const auto parse_integer = [&]() {
				size_t value;
				size_t separator = view.find(';');
				std::from_chars(&view[1], &view[separator], value);
				view.remove_prefix(separator + 1);
				return value;
			};

			// Skip first ID line
			view.remove_prefix(view.find('\n') + 1);

			size_t column = 0;
			size_t row = 0;

			while (view.size()) {
				switch (view.front()) {
					case 'C':
						view.remove_prefix(2);

						if (view.front() == 'X') {
							column = parse_integer() - 1;

							if (view.front() == 'Y') {
								row = parse_integer() - 1;
							}
						} else {
							row = parse_integer() - 1;

							if (view.front() == 'X') {
								column = parse_integer() - 1;
							}
						}

						if (row == 0 && column == 0) {
							view.remove_prefix(view.find('\n') + 1);
							break;
						}

						view.remove_prefix(1);

						{
							std::string data;
							if (view.front() == '\"') {
								data = view.substr(1, view.find('"', 1) - 1);
							} else {
								data = view.substr(0, view.find_first_of("\r\n"));
							}

							if (data == "-" || data == "_") {
								data = "";
							}

							if (column == 0) {
								// -1 as 0,0 is unitid/doodadid etc.
								row_headers.emplace(data, row - 1);
								index_to_row.emplace(row - 1, data);
							} else if (row == 0) {
								// If it is a column header we need to lowercase it as column headers are case insensitive
								to_lowercase(data);
								// -1 as 0,0 is unitid/doodadid etc.
								column_headers.emplace(data, column - 1);
								index_to_column.emplace(column - 1, data);
							} else {
								base_data[index_to_row[row - 1]][index_to_column[column - 1]] = data;
							}

							view.remove_prefix(view.find('\n') + 1);
						}
						break;
					case 'F':
						if (view.front() == 'X') {
							column = parse_integer() - 1;

							if (view.front() == 'Y') {
								row = parse_integer() - 1;
							}
						} else {
							row = parse_integer() - 1;

							if (view.front() == 'X') {
								column = parse_integer() - 1;
							}
						}
						view.remove_prefix(view.find('\n') + 1);
						break;
					default:
						view.remove_prefix(view.find_first_of('\n') + 1);
				}
			}
		}
		void build_meta_map() {
			// Check if we are a meta_slk
			if (!column_headers.contains("field")) {
				return;
			}

			for (const auto& [header, row] : row_headers) {
				std::string field = to_lowercase_copy(data("field", header));

				const int repeat = data<int>("data", header);
				if (repeat > 0) {
					field += 'a' + (repeat - 1);
				}
				if (column_headers.contains("usespecific")) {
					std::vector<std::string> parts = absl::StrSplit(data("usespecific", header), ",");
					if (!parts.empty()) {
						for (const auto& i : parts) {
							meta_map.emplace(field, header + i);
						}
					} else {
						meta_map.emplace(field, header);
					}
				} else {
					meta_map.emplace(field, header);
				}
			}
		}

		// column_header should be lowercase
		template <typename T = std::string>
		T data(std::string_view column_header, std::string_view row_header) const {
			assert(to_lowercase_copy(column_header) == column_header);

			// Todo, do find() directly as the .contains() and .at().at() do multiple lookups
			if (shadow_data.contains(row_header) && shadow_data.at(row_header).contains(column_header)) {
				if constexpr (std::is_same<T, std::string>()) {
					return shadow_data.at(row_header).at(column_header);
				} else if constexpr (std::is_same<T, float>()) {
					return std::stof(shadow_data.at(row_header).at(column_header));
				} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
					return std::stoi(shadow_data.at(row_header).at(column_header));
				}
			}

			// if (const auto found = column_headers.find(std::string(column_header) + ":hd"); found) {
			//	if (!found->first.empty()) {
			//		if constexpr (std::is_same<T, std::string>()) {
			//			return found->first;
			//		} else if constexpr (std::is_same<T, float>()) {
			//			return std::stof(found->first);
			//		} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
			//			return std::stoi(found->first);
			//		}
			//	}
			// }

			// Todo, do .find() directly as the .contains() and .at().at() do multiple lookups
			if (hierarchy.hd && column_headers.contains(std::string(column_header) + ":hd")) {
				std::string hd_data = data(std::string(column_header) + ":hd", row_header);
				if (!hd_data.empty()) {
					if constexpr (std::is_same<T, std::string>()) {
						return hd_data;
					} else if constexpr (std::is_same<T, float>()) {
						return std::stof(hd_data);
					} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
						return std::stoi(hd_data);
					}
				}
			}

			/*if (const auto found = base_data.find(row_header); found) {
				if (const auto found_sub = found->second.find(column_header); found_sub) {
					if constexpr (std::is_same<T, std::string>()) {
						return found_sub->second;
					} else if constexpr (std::is_same<T, float>()) {
						return std::stof(found_sub->second);
					} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
						return std::stoi(found_sub->second);
					}
				}
			}*/

			// Todo, do find() directly as the .contains() and .at().at() do multiple lookups
			if (base_data.contains(row_header) && base_data.at(row_header).contains(column_header)) {
				if constexpr (std::is_same<T, std::string>()) {
					return base_data.at(row_header).at(column_header);
				} else if constexpr (std::is_same<T, float>()) {
					return std::stof(base_data.at(row_header).at(column_header));
				} else if constexpr (std::is_same<T, int>() || std::is_same<T, bool>()) {
					return std::stoi(base_data.at(row_header).at(column_header));
				}
			}

			static_assert("Type not supported. Convert yourself or add conversion here if it makes sense");
			return T();
		}

		// Gets the data by first checking the shadow table and then checking the base table
		// Also does :hd tag resolution
		// column_header should be lowercase
		// If you have both an integer row index and the string row name then use the overload that takes string_view as it will do a index->name conversion internally
		template <typename T = std::string>
		T data(const std::string_view column_header, size_t row) const {
			if (row >= index_to_row.size()) {
				throw;
			}

			return data<T>(column_header, index_to_row.at(row));
		}

		// Gets the data by first checking the shadow table and then checking the base table
		template <typename T = std::string>
		T data(size_t column, size_t row) const {
			if (row >= index_to_row.size()) {
				throw;
			}

			if (column >= index_to_column.size()) {
				throw;
			}

			return data<T>(index_to_column.at(column), index_to_row.at(row));
		}

	// Merges the base data of the files
		// Shadow data is not merged
		// Any unknown columns are appended
		void merge(const SLK& slk) {
			for (const auto& [header, index] : slk.column_headers) {
				if (!column_headers.contains(header)) {
					add_column(header);
				}
			}

			for (const auto& [id, properties] : slk.base_data) {
				if (!base_data.contains(id)) {
					continue;
				}
				base_data[id].insert(properties.begin(), properties.end());
			}
		}

		/// Merges the data of the files. INI sections are matched to row keys and INI keys are matched to column keys.
		/// If an unknown section key is encountered then that section is skipped
		/// If an unknown column key is encountered then the column is added
		void merge(const ini::INI& ini, const SLK& meta_slk) {
			for (const auto& [section_key, section_value] : ini.ini_data) {
				if (!base_data.contains(section_key)) {
					continue;
				}

				for (const auto& [key, value] : section_value) {
					std::string key_lower = to_lowercase_copy(key);

					if (!column_headers.contains(key_lower)) {
						add_column(key_lower);
					}

					// By making some changes to unitmetadata.slk and unitdata.slk we can avoid the 1->2->2 mapping for SLK->OE->W3U files.
					// This means we have to manually split these into the correct column
					if (value.size() > 1 && (key_lower == "missilearc" || key_lower == "missileart" || key_lower == "missilehoming" || key_lower == "missilespeed" || key_lower == "buttonpos" || key_lower == "unbuttonpos" || key_lower == "researchbuttonpos") && column_headers.contains(key_lower + "2")) {

						base_data[section_key][key_lower] = value[0];
						base_data[section_key][key_lower + "2"] = value[1];
						continue;
					}

					const std::string key_lower_stripped = key_lower.substr(0, key_lower.find_first_of(':'));

					std::string id;
					if (meta_slk.meta_map.contains(key_lower_stripped)) {
						id = meta_slk.meta_map.at(key_lower_stripped);
					} else if (meta_slk.meta_map.contains(key_lower_stripped + section_key)) {
						id = meta_slk.meta_map.at(key_lower_stripped + section_key);
					} else {
						size_t nr_position = key_lower_stripped.find_first_of("0123456789");
						std::string without_numbers = key_lower_stripped.substr(0, nr_position);

						if (meta_slk.meta_map.contains(without_numbers)) {
							id = meta_slk.meta_map.at(without_numbers);
						} else {
							continue;
						}
					}

					const int repeat = meta_slk.data<int>("repeat", id);
					if (repeat > 0 && !(meta_slk.column_headers.contains("appendindex") && meta_slk.data<int>("appendindex", id) > 0)) {
						for (size_t i = 0; i < value.size(); i++) {
							const std::string new_key = key_lower + std::to_string(i + 1);
							if (!column_headers.contains(new_key)) {
								add_column(new_key);
							}
							base_data[section_key][new_key] = value[i];
						}
						continue;
					} else {
						if (meta_slk.data<std::string>("type", id).ends_with("List")) {
							base_data[section_key][key_lower] = absl::StrJoin(value, ",");
						} else {
							base_data[section_key][key_lower] = value[0];
						}
					}
				}
			}
		}

		/// Substitutes the data of the slk with data from the INI based on a certain section key.
		/// The keys of the section are matched with all the cells in the table and if they match will replace the value
		void substitute(const ini::INI& ini, const std::string& section) {
			assert(ini.section_exists(section));

			for (auto& [id, properties] : base_data) {
				for (auto& [prop_id, prop_value] : properties) {
					std::string data = ini.data(section, prop_value);
					if (!data.empty()) {
						prop_value = data;
					}
				}
			}
		}

		/// Copies the row with header row_header to a new line with the new header as new_row_header
		void copy_row(const std::string_view row_header, std::string_view new_row_header, bool copy_shadow_data) {
			assert(base_data.contains(row_header));
			assert(!base_data.contains(new_row_header));

			// Get a weird allocation error if not done via a temporary 19/06/2021
			const auto t = base_data.at(row_header);
			base_data[new_row_header] = t;

			if (copy_shadow_data && shadow_data.contains(row_header)) {
				// Get a weird allocation error if not done via a temporary 19/06/2021
				const auto tt = shadow_data.at(row_header);
				shadow_data[new_row_header] = tt;
			}

			size_t index = row_headers.size();
			row_headers.emplace(new_row_header, index);
			index_to_row[index] = new_row_header;

			// Only set/change oldid if the row didn't have one (which means it is a default unit/item/...)
			if (!shadow_data[new_row_header].contains("oldid")) {
				shadow_data[new_row_header]["oldid"] = row_header;
			}
		}

		void remove_row(const std::string_view row_header) {
			assert(base_data.contains(row_header));

			base_data.erase(row_header);
			shadow_data.erase(row_header);

			const size_t index = row_headers.at(row_header);
			if (index == rows() - 1) {
				index_to_row.erase(index);
				row_headers.erase(row_header);
			} else {
				// Swap with a element from the end to avoid having to change all indices
				const std::string replacement_id = index_to_row.at(rows() - 1);
				index_to_row[index] = replacement_id;
				row_headers[replacement_id] = index;
				index_to_row.erase(rows() - 1);

				row_headers.erase(row_header);
			}
		}

		/// Adds a (virtual) column
		/// Since SLK2 is only a key/pair store it emulates being table like and thus this call is very cheap memory/cpu wise
		/// column_header must be lowercase
		void add_column(const std::string_view column_header) {
			assert(to_lowercase_copy(column_header) == column_header);

			size_t index = column_headers.size();
			column_headers.emplace(column_header, index);
			index_to_column[index] = column_header;
		}

		/// If the column does not exist then it will be created
		// column_header should be lowercase
		void set_shadow_data(const std::string_view column_header, const std::string_view row_header, std::string data) {
			assert(to_lowercase_copy(column_header) == column_header);

			if (!column_headers.contains(column_header)) {
				add_column(column_header);
			}

			if (base_data.contains(row_header) && base_data.at(row_header).contains(column_header)) {
				if (base_data.at(row_header).at(column_header) == data) {
					if (shadow_data.contains(row_header)) {
						shadow_data.at(row_header).erase(column_header);
						if (shadow_data.at(row_header).empty()) {
							shadow_data.erase(row_header);
						}
					}
					return;
				}
			}

			shadow_data[row_header][column_header] = data;
		}

		void set_shadow_data(const int column, const int row, std::string data) {
			set_shadow_data(index_to_column.at(column), index_to_row.at(row), data);
		}

		size_t rows() {
			return row_headers.size();
		}

		size_t columns() {
			return column_headers.size();
		}
	};
} // namespace slk

```

`src/Globals.h`:

```h
#pragma once 

#include "INI.h"
#include "SLK.h"
#include "MainWindow/GLWidget.h"
#include "Map.h"
#include "TableModel.h"
#include "WindowHandler.h"

inline Map* map = nullptr;
inline ini::INI world_edit_strings;
inline ini::INI world_edit_game_strings;
inline ini::INI world_edit_data;

inline TableModel* units_table;
inline slk::SLK units_slk;
inline slk::SLK units_meta_slk;
inline ini::INI unit_editor_data;

inline TableModel* items_table;
inline slk::SLK items_slk;
inline slk::SLK items_meta_slk;

inline TableModel* abilities_table;
inline slk::SLK abilities_slk;
inline slk::SLK abilities_meta_slk;

inline TableModel* doodads_table;
inline slk::SLK doodads_slk;
inline slk::SLK doodads_meta_slk;

inline TableModel* destructibles_table;
inline slk::SLK destructibles_slk;
inline slk::SLK destructibles_meta_slk;

inline TableModel* upgrade_table;
inline slk::SLK upgrade_slk;
inline slk::SLK upgrade_meta_slk;

inline TableModel* buff_table;
inline slk::SLK buff_slk;
inline slk::SLK buff_meta_slk;

inline GLWidget* context;

inline WindowHandler window_handler;
```

`src/MainWindow/GLWidget.cpp`:

```cpp
#include "GLWidget.h"

#include "fmt/format.h"

#include <QTimer>
#include <QOpenGLFunctions_4_5_Core>
#include <QPainter>

#include "Utilities.h"
#include "InputHandler.h"

#include "Globals.h"

void APIENTRY gl_debug_output(const GLenum source, const GLenum type, const GLuint id, const GLenum severity, const GLsizei, const GLchar *message, void *) {
	// Skip buffer info messages, framebuffer info messages, texture usage state warning, redundant state change buffer
	if (id == 131185 // ?
		|| id == 131169 // ?
		|| id == 131204 // ?
		|| id == 8 // ?
		|| id == 131218) // Unexplainable performance warnings
	{
		return;
	}

	std::cout << "---------------" << std::endl;
	std::cout << "Debug message (" << id << "): " << message << std::endl;

	switch (source) {
		case GL_DEBUG_SOURCE_API:             std::cout << "Source: API"; break;
		case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   std::cout << "Source: Window System"; break;
		case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout << "Source: Shader Compiler"; break;
		case GL_DEBUG_SOURCE_THIRD_PARTY:     std::cout << "Source: Third Party"; break;
		case GL_DEBUG_SOURCE_APPLICATION:     std::cout << "Source: Application"; break;
		case GL_DEBUG_SOURCE_OTHER:           std::cout << "Source: Other"; break;
		default: break;
	}
	std::cout << std::endl;

	switch (type) {
		case GL_DEBUG_TYPE_ERROR:               std::cout << "Type: Error"; break;
		case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout << "Type: Deprecated Behaviour"; break;
		case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  std::cout << "Type: Undefined Behaviour"; break;
		case GL_DEBUG_TYPE_PORTABILITY:         std::cout << "Type: Portability"; break;
		case GL_DEBUG_TYPE_PERFORMANCE:         std::cout << "Type: Performance"; break;
		case GL_DEBUG_TYPE_MARKER:              std::cout << "Type: Marker"; break;
		case GL_DEBUG_TYPE_PUSH_GROUP:          std::cout << "Type: Push Group"; break;
		case GL_DEBUG_TYPE_POP_GROUP:           std::cout << "Type: Pop Group"; break;
		case GL_DEBUG_TYPE_OTHER:               std::cout << "Type: Other"; break;
		default: break;
	}
	std::cout << std::endl;

	switch (severity) {
		case GL_DEBUG_SEVERITY_HIGH:         std::cout << "Severity: high"; break;
		case GL_DEBUG_SEVERITY_MEDIUM:       std::cout << "Severity: medium"; break;
		case GL_DEBUG_SEVERITY_LOW:          std::cout << "Severity: low"; break;
		case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout << "Severity: notification"; break;
		default: break;
	}
	std::cout << std::endl;
}

GLWidget::GLWidget(QWidget* parent) : QOpenGLWidget(parent) {
	QTimer::singleShot(16, this, &GLWidget::update_scene);

	camera = &tps_camera;

	setMouseTracking(true);
	setFocus();
	setFocusPolicy(Qt::WheelFocus);
}

std::chrono::steady_clock::time_point begin;


void GLWidget::initializeGL() {
	gl = new QOpenGLFunctions_4_5_Core;
	gl->initializeOpenGLFunctions();
	
	gl->glEnable(GL_DEBUG_OUTPUT);
	gl->glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	gl->glDebugMessageCallback(GLDEBUGPROC(gl_debug_output), nullptr);
	gl->glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_NOTIFICATION, 0, nullptr, false);
	gl->glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_LOW, 0, nullptr, true);
	gl->glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_MEDIUM, 0, nullptr, true);
	gl->glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_HIGH, 0, nullptr, true);

	gl->glEnable(GL_DEPTH_TEST);
	gl->glEnable(GL_CULL_FACE);
	gl->glDepthFunc(GL_LEQUAL);
	gl->glEnable(GL_BLEND);
	gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	gl->glClearColor(0, 0, 0, 1);

	gl->glGenVertexArrays(1, &vao);
	gl->glBindVertexArray(vao);

	int extension_count;
	gl->glGetIntegerv(GL_NUM_EXTENSIONS, &extension_count);
	
	shapes.init();

	begin = std::chrono::steady_clock::now();
}

void GLWidget::resizeGL(const int w, const int h) {
	gl->glViewport(0, 0, w, h);

	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
	camera->aspect_ratio = double(w) / h;

	if (!map || !map->loaded) {
		return;
	}
	camera->update(delta);
	map->render_manager.resize_framebuffers(w, h);
}


void GLWidget::update_scene() {
	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
	elapsed_timer.start();

	update();
	if (map) {
		map->update(delta, width(), height());
	}

	QTimer::singleShot(16.67 - std::clamp(delta, 0.001, 16.60), this, &GLWidget::update_scene);
}

void GLWidget::paintGL() {
	if (!map) {
		return;
	}

	//gl->glEnable(GL_FRAMEBUFFER_SRGB);
	gl->glEnable(GL_DEPTH_TEST);
	gl->glDepthMask(true);
	gl->glClearColor(0.f, 0.f, 0.f, 1.f);
	gl->glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


	gl->glBindVertexArray(vao);
	map->render();

	gl->glBindVertexArray(0);

	if (map->render_debug) {
		QPainter p(this);
		p.setPen(QColor(Qt::GlobalColor::white));
		p.setFont(QFont("Arial", 10, 100, false));

		// Rendering time
		static std::vector<double> frametimes;
		frametimes.push_back(delta);
		if (frametimes.size() > 60) {
			frametimes.erase(frametimes.begin());
		}
		float average_frametime = std::accumulate(frametimes.begin(), frametimes.end(), 0.f) / frametimes.size();
		p.drawText(10, 20, QString::fromStdString(fmt::format("Total time: {:.2f}ms", average_frametime * 1000.0)));

		// General info
		p.drawText(300, 20, QString::fromStdString(fmt::format("Mouse Grid Position X:{:.4f} Y:{:.4f}", input_handler.mouse_world.x, input_handler.mouse_world.y)));
		if (map->brush) {
			p.drawText(300, 35, QString::fromStdString(fmt::format("Brush Grid Position X:{:.4f} Y:{:.4f}", map->brush->get_position().x, map->brush->get_position().y)));
		}

		p.drawText(300, 50, QString::fromStdString(fmt::format("Camera Horizontal Angle: {:.4f}", camera->horizontal_angle)));
		p.drawText(300, 64, QString::fromStdString(fmt::format("Camera Vertical Angle: {:.4f}", camera->vertical_angle)));

		p.end();

		// Set changed state back
		gl->glEnable(GL_DEPTH_TEST);
		gl->glDepthFunc(GL_LEQUAL);
		gl->glEnable(GL_BLEND);
		gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}
}

void GLWidget::keyPressEvent(QKeyEvent* event) {
	if (!map) {
		return;
	}

	input_handler.keys_pressed.emplace(event->key());

	if (map->brush) {
		map->brush->key_press_event(event);
	}
}

void GLWidget::keyReleaseEvent(QKeyEvent* event) {
	if (!map) {
		return;
	}

	input_handler.keys_pressed.erase(event->key());

	if (map->brush) {
		map->brush->key_release_event(event);
	}
}

void GLWidget::mouseMoveEvent(QMouseEvent* event) {
	if (!map) {
		return;
	}

	input_handler.mouse_move_event(event);
	camera->mouse_move_event(event);

	if (map->brush) {
		map->brush->mouse_move_event(event, delta);
	}
}

void GLWidget::mousePressEvent(QMouseEvent* event) {
	makeCurrent();

	if (!map) {
		return;
	}

	camera->mouse_press_event(event);
	if (map->brush) {
		map->brush->mouse_press_event(event, delta);
	}
}

void GLWidget::mouseReleaseEvent(QMouseEvent* event) {
	if (!map) {
		return;

	}
	camera->mouse_release_event(event);
	if (map->brush) {
		map->brush->mouse_release_event(event);
	}
}

void GLWidget::wheelEvent(QWheelEvent* event) {
	if (!map) {
		return;
	}

	camera->mouse_scroll_event(event);
}
```

`src/MainWindow/GLWidget.h`:

```h
#pragma once

#include <QObject>
#include <QOpenGLWidget>

#include "Camera.h"
#include <QElapsedTimer>

class GLWidget : public QOpenGLWidget {
	Q_OBJECT

public:
	QElapsedTimer elapsed_timer;
	GLuint vao;

	TPSCamera tps_camera;
	FPSCamera fps_camera;

	double delta = 0.0;

	explicit GLWidget(QWidget* parent);
	~GLWidget() = default;

	void initializeGL() override;
	void resizeGL(int w, int h) override;
	void update_scene();
	void paintGL() override;

	void keyPressEvent(QKeyEvent* event) override;
	void keyReleaseEvent(QKeyEvent* event) override;
	void mouseMoveEvent(QMouseEvent* event) override;
	void mousePressEvent(QMouseEvent* event) override;
	void mouseReleaseEvent(QMouseEvent* event) override;
	void wheelEvent(QWheelEvent* event) override;
};
```

`src/MainWindow/HiveWE.cpp`:

```cpp
#include "HiveWE.h"

#include <fstream>

#include <QFileDialog>
#include <QSettings>
#include <QObject>
#include <QMessageBox>
#include <QTimer>
#include <QProcess>
#include <QPushButton>
#include <QApplication>

#include <SOIL2/SOIL2.h>

#define STORMLIB_NO_AUTO_LINK
#include <StormLib.h>

import Hierarchy;

#include "TileSetter.h"
#include "MapInfoEditor.h"
#include "TerrainPalette.h"
#include "SettingsEditor.h"
#include "TilePather.h"
#include "Palette.h"
#include "TerrainPalette.h"
#include "DoodadPalette.h"
#include "UnitPalette.h"
#include "PathingPalette.h"
#include "ObjectEditor.h"
#include "ModelEditor/ModelEditor.h"
#include "Camera.h"

#include "IconView.h"
#include "Globals.h"

import MPQ;

HiveWE::HiveWE(QWidget* parent) : QMainWindow(parent) {
	setAutoFillBackground(true);

	fs::path directory = find_warcraft_directory();
	QSettings settings;

	//TODO: these are out of hierarchy while QSettings have ICE in modules
	hierarchy.ptr = settings.value("flavour", "Retail").toString() != "Retail";
	hierarchy.hd = settings.value("hd", "True").toString() != "False";
	hierarchy.teen = settings.value("teen", "False").toString() != "False";
	QSettings war3reg("HKEY_CURRENT_USER\\Software\\Blizzard Entertainment\\Warcraft III", QSettings::NativeFormat);
	hierarchy.local_files = war3reg.value("Allow Local Files", 0).toInt() != 0;
	while (!hierarchy.open_casc(directory)) {
		directory = QFileDialog::getExistingDirectory(this, "Select Warcraft Directory", "/home", QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks).toStdWString();
		if (directory == "") {
			exit(EXIT_SUCCESS);
		}
	}
	settings.setValue("warcraftDirectory", QString::fromStdString(directory.string()));

	// Place common.j and blizzard.j in the data folder. Required by JassHelper
	BinaryReader common = hierarchy.open_file("scripts/common.j");
	std::ofstream output("Data/Tools/common.j");
	output.write((char*)common.buffer.data(), common.buffer.size());
	BinaryReader blizzard = hierarchy.open_file("scripts/blizzard.j");
	std::ofstream output2("Data/Tools/blizzard.j");
	output2.write((char*)blizzard.buffer.data(), blizzard.buffer.size());

	ui.setupUi(this);
	context = ui.widget;
	restore_window_state();

	world_edit_strings.load("UI/WorldEditStrings.txt");
	world_edit_game_strings.load("UI/WorldEditGameStrings.txt");
	world_edit_data.load("UI/WorldEditData.txt");

	world_edit_data.substitute(world_edit_game_strings, "WorldEditStrings");
	world_edit_data.substitute(world_edit_strings, "WorldEditStrings");

	connect(ui.ribbon->undo, &QPushButton::clicked, [&]() { 
		// ToDo: temporary, undoing should still allow a selection to persist
		if (map->brush) {
			map->brush->clear_selection();
		}
		map->terrain_undo.undo(); 
	});
	connect(ui.ribbon->redo, &QPushButton::clicked, [&]() { 
		// ToDo: temporary, undoing should still allow a selection to persist
		if (map->brush) {
			map->brush->clear_selection();
		}
		map->terrain_undo.redo(); 
	});

	connect(new QShortcut(Qt::CTRL | Qt::Key_Z, this), &QShortcut::activated, ui.ribbon->undo, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_Y, this), &QShortcut::activated, ui.ribbon->redo, &QPushButton::click);

	connect(ui.ribbon->units_visible, &QPushButton::toggled, [](bool checked) { map->render_units = checked; });
	connect(ui.ribbon->doodads_visible, &QPushButton::toggled, [](bool checked) { map->render_doodads = checked; });
	connect(ui.ribbon->pathing_visible, &QPushButton::toggled, [](bool checked) { map->render_pathing = checked; });
	connect(ui.ribbon->brush_visible, &QPushButton::toggled, [](bool checked) { map->render_brush = checked; });
	connect(ui.ribbon->lighting_visible, &QPushButton::toggled, [](bool checked) { map->render_lighting = checked; });
	connect(ui.ribbon->wireframe_visible, &QPushButton::toggled, [](bool checked) { map->render_wireframe = checked; });
	connect(ui.ribbon->debug_visible, &QPushButton::toggled, [](bool checked) { map->render_debug = checked; });
	connect(ui.ribbon->minimap_visible, &QPushButton::toggled, [&](bool checked) { (checked) ? minimap->show() : minimap->hide(); });

	connect(new QShortcut(Qt::CTRL | Qt::Key_U, this), &QShortcut::activated, ui.ribbon->units_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_D, this), &QShortcut::activated, ui.ribbon->doodads_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_P, this), &QShortcut::activated, ui.ribbon->pathing_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_L, this), &QShortcut::activated, ui.ribbon->lighting_visible, &QPushButton::click);
	connect(new QShortcut(Qt::CTRL | Qt::Key_T, this), &QShortcut::activated, ui.ribbon->wireframe_visible, &QPushButton::click);
	connect(new QShortcut(Qt::Key_F3, this), &QShortcut::activated, ui.ribbon->debug_visible, &QPushButton::click);

	// Reload theme
	connect(new QShortcut(Qt::Key_F5, this), &QShortcut::activated, [&]() {
		QSettings settings;
		QFile file("Data/Themes/" + settings.value("theme").toString() + ".qss");
		file.open(QFile::ReadOnly);
		QString StyleSheet = QLatin1String(file.readAll());

		qApp->setStyleSheet(StyleSheet);
	});

	connect(ui.ribbon->reset_camera, &QPushButton::clicked, [&]() { camera->reset(); });
	connect(ui.ribbon->switch_camera, &QPushButton::clicked, this, &HiveWE::switch_camera);
	setAutoFillBackground(true);

	connect(new QShortcut(Qt::Key_F1, this), &QShortcut::activated, ui.ribbon->switch_camera, &QPushButton::click);
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_C), this), &QShortcut::activated, ui.ribbon->reset_camera, &QPushButton::click);

	connect(ui.ribbon->import_heightmap, &QPushButton::clicked, this, &HiveWE::import_heightmap);

	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_O), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->open_map_folder, &QPushButton::click);
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_I), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->open_map_mpq, &QPushButton::click);
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_S), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->save_map, &QPushButton::click);
	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::SHIFT | Qt::Key_S), this, nullptr, nullptr, Qt::ApplicationShortcut), &QShortcut::activated, ui.ribbon->save_map_as, &QPushButton::click);

	//connect(ui.ribbon->new_map, &QAction::triggered, this, &HiveWE::load);
	connect(ui.ribbon->open_map_folder, &QPushButton::clicked, this, &HiveWE::load_folder);
	connect(ui.ribbon->open_map_mpq, &QPushButton::clicked, this, &HiveWE::load_mpq);
	connect(ui.ribbon->save_map, &QPushButton::clicked, this, &HiveWE::save);
	connect(ui.ribbon->save_map_as, &QPushButton::clicked, this, &HiveWE::save_as);
	connect(ui.ribbon->export_mpq, &QPushButton::clicked, this, &HiveWE::export_mpq);
	connect(ui.ribbon->test_map, &QPushButton::clicked, this, &HiveWE::play_test);
	connect(ui.ribbon->settings, &QPushButton::clicked, [&]() { new SettingsEditor(this); });
	connect(ui.ribbon->switch_warcraft, &QPushButton::clicked, this, &HiveWE::switch_warcraft);
	connect(ui.ribbon->exit, &QPushButton::clicked, [&]() { QApplication::exit(); });

	connect(ui.ribbon->change_tileset, &QRibbonButton::clicked, [this]() { new TileSetter(this); });
	connect(ui.ribbon->change_tile_pathing, &QRibbonButton::clicked, [this]() { new TilePather(this); });

	connect(ui.ribbon->map_description, &QRibbonButton::clicked, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(0); });
	connect(ui.ribbon->map_loading_screen, &QRibbonButton::clicked, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(1); });
	connect(ui.ribbon->map_options, &QRibbonButton::clicked, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(2); });
	//connect(ui, &QAction::triggered, [&]() { (new MapInfoEditor(this))->ui.tabs->setCurrentIndex(3); });

	connect(new QShortcut(QKeySequence(Qt::Key_T), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		open_palette<TerrainPalette>();
	});

	connect(ui.ribbon->terrain_palette, &QRibbonButton::clicked, [this]() {
		open_palette<TerrainPalette>();
	});

	connect(new QShortcut(QKeySequence(Qt::Key_D), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		open_palette<DoodadPalette>();
	});
	connect(ui.ribbon->doodad_palette, &QRibbonButton::clicked, [this]() {
		open_palette<DoodadPalette>();
	});

	connect(new QShortcut(QKeySequence(Qt::Key_U), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		open_palette<UnitPalette>();
	});

	connect(ui.ribbon->unit_palette, &QRibbonButton::clicked, [this]() {
		open_palette<UnitPalette>();
	});

	connect(new QShortcut(QKeySequence(Qt::Key_P), this, nullptr, nullptr, Qt::WindowShortcut), &QShortcut::activated, [&]() {
		ui.ribbon->pathing_visible->setChecked(true);
		open_palette<PathingPalette>();
	});

	connect(ui.ribbon->pathing_palette, &QRibbonButton::clicked, [this]() {
		ui.ribbon->pathing_visible->setChecked(true);
		open_palette<PathingPalette>();
	});

	setAutoFillBackground(true);

	connect(ui.ribbon->object_editor, &QRibbonButton::clicked, [this]() {
		bool created = false;
		window_handler.create_or_raise<ObjectEditor>(nullptr, created);
	});

	connect(ui.ribbon->model_editor, &QRibbonButton::clicked, [this]() {
		bool created = false;
		window_handler.create_or_raise<ModelEditor>(nullptr, created);
	});

	minimap->setParent(ui.widget);
	minimap->move(10, 10);
	minimap->show();

	connect(minimap, &Minimap::clicked, [](QPointF location) { camera->position = { location.x() * map->terrain.width, (1.0 - location.y()) * map->terrain.height, camera->position.z }; });
	map = new Map();
	connect(&map->terrain, &Terrain::minimap_changed, minimap, &Minimap::set_minimap);

	ui.widget->makeCurrent();
	map->load("Data/Test Map/");
	map->render_manager.resize_framebuffers(ui.widget->width(), ui.widget->height());
}

void HiveWE::load_folder() {
	QSettings settings;

	QString folder_name = QFileDialog::getExistingDirectory(this, "Open Map Directory",
															settings.value("openDirectory", QDir::current().path()).toString(),
															QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);

	if (folder_name == "") {
		return;
	}

	settings.setValue("openDirectory", folder_name);

	fs::path directory = folder_name.toStdString();

	if (!fs::exists(directory / "war3map.w3i")) {
		QMessageBox::information(this, "Opening map failed", "Opening the map failed. Select a map that is saved in folder mode or use the Open Map (MPQ) option");
		return;
	}

	QMessageBox* loading_box = new QMessageBox(QMessageBox::Icon::Information, "Loading Map", "Loading " + QString::fromStdString(directory.filename().string()));
	loading_box->show();

	delete map;
	map = new Map();

	connect(&map->terrain, &Terrain::minimap_changed, minimap, &Minimap::set_minimap);

	ui.widget->makeCurrent();
	map->load(directory);

	loading_box->close();
	delete loading_box;

	map->render_manager.resize_framebuffers(ui.widget->width(), ui.widget->height());
	setWindowTitle("HiveWE 0.7 - " + QString::fromStdString(map->filesystem_path.string()));
}

/// Load MPQ will extract all files from the archive in a user specified location
void HiveWE::load_mpq() {
	QSettings settings;

	// Choose an MPQ
	QString file_name = QFileDialog::getOpenFileName(this, "Open File",
													 settings.value("openDirectory", QDir::current().path()).toString(),
													 "Warcraft III Scenario (*.w3m *.w3x)");

	if (file_name == "") {
		return;
	}

	settings.setValue("openDirectory", file_name);

	fs::path mpq_path = file_name.toStdWString();

	mpq::MPQ mpq;
	bool opened = mpq.open(mpq_path);
	if (!opened) {
		QMessageBox::critical(this, "Opening map failed", "Opening the map archive failed. It might be opened in another program.");
		std::cout << GetLastError() << "\n";
		return;
	}

	fs::path unpack_location = QFileDialog::getExistingDirectory(this, "Choose Unpacking Location",
																 settings.value("openDirectory", QDir::current().path()).toString(),
																 QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks)
								   .toStdString();

	if (unpack_location.empty()) {
		return;
	}

	fs::path final_directory = unpack_location / mpq_path.stem();

	try {
		fs::create_directory(final_directory);
	} catch (std::filesystem::filesystem_error& e) {
		QMessageBox::critical(this, "Error creating directory", "Failed to create the directory to unpack into with error:\n" + QString::fromStdString(e.what()), QMessageBox::StandardButton::Ok, QMessageBox::StandardButton::Ok);
		return;
	}

	bool unpacked = mpq.unpack(final_directory);
	if (!unpacked) {
		QMessageBox::critical(this, "Unpacking failed", "There was an error unpacking the archive.");
		std::cout << GetLastError() << "\n";
		return;
	}

	// Load map
	delete map;
	map = new Map();

	connect(&map->terrain, &Terrain::minimap_changed, minimap, &Minimap::set_minimap);

	ui.widget->makeCurrent();
	map->load(final_directory);
	map->render_manager.resize_framebuffers(ui.widget->width(), ui.widget->height());
	setWindowTitle("HiveWE 0.7 - " + QString::fromStdString(map->filesystem_path.string()));
}

void HiveWE::save() {
	emit saving_initiated();
	map->save(map->filesystem_path);
};

void HiveWE::save_as() {
	QSettings settings;
	const QString directory = settings.value("openDirectory", QDir::current().path()).toString() + "/" + QString::fromStdString(map->name);

	fs::path file_name = QFileDialog::getExistingDirectory(this, "Choose Save Location",
														   settings.value("openDirectory", QDir::current().path()).toString(),
														   QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks).toStdString();

	if (file_name.empty()) {
		return;
	}

	emit saving_initiated();
	if (fs::exists(file_name) && fs::equivalent(file_name, map->filesystem_path)) {
		map->save(map->filesystem_path);
	} else {
		fs::create_directories(file_name / map->name);

		hierarchy.map_directory = file_name / map->name;
		map->save(file_name / map->name);
	}

	setWindowTitle("HiveWE 0.7 - " + QString::fromStdString(map->filesystem_path.string()));
}

void HiveWE::export_mpq() {
	QSettings settings;
	const QString directory = settings.value("openDirectory", QDir::current().path()).toString() + "/" + QString::fromStdString(map->filesystem_path.filename().string());
	std::wstring file_name = QFileDialog::getSaveFileName(this, "Export Map to MPQ", directory, "Warcraft III Scenario (*.w3x)").toStdWString();

	if (file_name.empty()) {
		return;
	}

	fs::remove(file_name);

	emit saving_initiated();
	map->save(map->filesystem_path);

	unsigned long file_count = std::distance(fs::directory_iterator{ map->filesystem_path }, {});

	HANDLE handle;
	bool open = SFileCreateArchive(file_name.c_str(), MPQ_CREATE_LISTFILE | MPQ_CREATE_ATTRIBUTES, file_count, &handle);
	if (!open) {
		QMessageBox::critical(this, "Exporting failed", "There was an error creating the archive.");
		std::cout << GetLastError() << "\n";
		return;
	}

	for (const auto& entry : fs::recursive_directory_iterator(map->filesystem_path)) {
		if (entry.is_regular_file()) {
			SFileAddFileEx(handle, entry.path().c_str(), entry.path().lexically_relative(map->filesystem_path).string().c_str(), MPQ_FILE_COMPRESS, MPQ_COMPRESSION_ZLIB, MPQ_COMPRESSION_NEXT_SAME);
		}
	}
	SFileCompactArchive(handle, nullptr, false);
	SFileCloseArchive(handle);
}

void HiveWE::play_test() {
	emit saving_initiated();
	if (!map->save(map->filesystem_path)) {
		return;
	}
	QProcess* warcraft = new QProcess;
	const QString warcraft_path = QString::fromStdString(fs::canonical(hierarchy.root_directory / "x86_64" / "Warcraft III.exe").string());
	QStringList arguments;
	arguments << "-launch"
			  << "-loadfile" << QString::fromStdString(fs::canonical(map->filesystem_path).string());

	QSettings settings;
	if (settings.value("testArgs").toString() != "")
		arguments << settings.value("testArgs").toString().split(' ');

	warcraft->start(warcraft_path, arguments);
}

void HiveWE::closeEvent(QCloseEvent* event) {
	int choice = QMessageBox::question(this, "Do you want to quit?", "Are you sure you want to quit?", QMessageBox::Yes | QMessageBox::No, QMessageBox::No);

	if (choice == QMessageBox::Yes) {
		event->accept();
	} else {
		event->ignore();
	}
}

void HiveWE::resizeEvent(QResizeEvent* event) {
	QMainWindow::resizeEvent(event);
	QTimer::singleShot(0, [&] { save_window_state(); });
}

void HiveWE::moveEvent(QMoveEvent* event) {
	QMainWindow::moveEvent(event);
	QTimer::singleShot(0, [&] { save_window_state(); });
}

void HiveWE::switch_warcraft() {
	QSettings settings;
	fs::path directory;
	do {
		directory = QFileDialog::getExistingDirectory(this, "Select Warcraft Directory", "/home", QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks).toStdWString();
		if (directory == "") {
			directory = settings.value("warcraftDirectory").toString().toStdString();
		}
	} while (!hierarchy.open_casc(directory));

	if (directory != hierarchy.warcraft_directory) {
		settings.setValue("warcraftDirectory", QString::fromStdString(directory.string()));
	}
}

void HiveWE::switch_camera() {
	if (camera == &ui.widget->tps_camera) {
		ui.widget->fps_camera.horizontal_angle = ui.widget->tps_camera.horizontal_angle;
		ui.widget->fps_camera.vertical_angle = ui.widget->tps_camera.vertical_angle;

		ui.widget->fps_camera.position = ui.widget->tps_camera.position;
		camera = &ui.widget->fps_camera;
		ui.actionDoodads->setEnabled(false);
	} else {
		ui.widget->tps_camera.horizontal_angle = ui.widget->fps_camera.horizontal_angle;
		ui.widget->tps_camera.vertical_angle = ui.widget->fps_camera.vertical_angle;

		ui.widget->tps_camera.position = ui.widget->fps_camera.position;
		camera = &ui.widget->tps_camera;
		ui.actionDoodads->setEnabled(true);
	}
	camera->update(0);
}

// ToDo move to terrain class?
void HiveWE::import_heightmap() {
	QMessageBox::information(this, "Heightmap information", "Will read the red channel and map this onto the range -16 to +16");
	QSettings settings;
	const QString directory = settings.value("openDirectory", QDir::current().path()).toString() + "/" + QString::fromStdString(map->filesystem_path.filename().string());

	QString file_name = QFileDialog::getOpenFileName(this, "Open Heightmap Image", directory);

	if (file_name == "") {
		return;
	}

	int width;
	int height;
	int channels;
	uint8_t* image_data = SOIL_load_image(file_name.toStdString().c_str(), &width, &height, &channels, SOIL_LOAD_AUTO);

	if (width != map->terrain.width || height != map->terrain.height) {
		QMessageBox::warning(this, "Incorrect Image Size", QString("Image Size: %1x%2 does not match terrain size: %3x%4").arg(QString::number(width), QString::number(height), QString::number(map->terrain.width), QString::number(map->terrain.height)));
		return;
	}

	for (int j = 0; j < height; j++) {
		for (int i = 0; i < width; i++) {
			map->terrain.corners[i][j].height = (image_data[((height - 1 - j) * width + i) * channels] - 128) / 16.f;
		}
	}

	map->terrain.update_ground_heights({ 0, 0, width, height });
	delete image_data;
}

void HiveWE::save_window_state() {
	QSettings settings;

	if (!isMaximized()) {
		settings.setValue("MainWindow/geometry", saveGeometry());
	}

	settings.setValue("MainWindow/maximized", isMaximized());
	settings.setValue("MainWindow/windowState", saveState());
}

void HiveWE::restore_window_state() {
	QSettings settings;

	if (settings.contains("MainWindow/windowState")) {
		restoreGeometry(settings.value("MainWindow/geometry").toByteArray());
		restoreState(settings.value("MainWindow/windowState").toByteArray());
		if (settings.value("MainWindow/maximized").toBool()) {
			showMaximized();
		} else {
			showNormal();
		}
	} else {
		showMaximized();
	}
}

void HiveWE::set_current_custom_tab(QRibbonTab* tab, QString name) {
	if (current_custom_tab == tab) {
		return;
	}

	if (current_custom_tab != nullptr) {
		emit palette_changed(tab);
	}

	remove_custom_tab();
	current_custom_tab = tab;
	ui.ribbon->addTab(tab, name);
	ui.ribbon->setCurrentIndex(ui.ribbon->count() - 1);
}

void HiveWE::remove_custom_tab() {
	for (int i = 0; i < ui.ribbon->count(); i++) {
		if (ui.ribbon->widget(i) == current_custom_tab) {
			ui.ribbon->removeTab(i);
			current_custom_tab = nullptr;
			return;
		}
	}
}
```

`src/MainWindow/HiveWE.h`:

```h
#pragma once

#include "ui_HiveWE.h"

#include <QMainWindow>
#include "Palette.h"
#include "QRibbon.h"
#include "Minimap.h"
#include "Map.h"
#include "TableModel.h"
#include "SLK.h"
#include "GLWidget.h"
#include "INI.h"
#include "Globals.h"

class HiveWE : public QMainWindow {
	Q_OBJECT

public:
	explicit HiveWE(QWidget* parent = nullptr);

	void load_folder();
	void load_mpq();
	void save();
	void save_as();
	void export_mpq();
	void play_test();

private:
	Ui::HiveWEClass ui;
	QRibbonTab* current_custom_tab = nullptr;
	Minimap* minimap = new Minimap(this);

	void closeEvent(QCloseEvent* event) override;
	void resizeEvent(QResizeEvent* event) override;
	void moveEvent(QMoveEvent* event) override;

	void switch_camera();
	void switch_warcraft();
	void import_heightmap();
	void save_window_state();
	void restore_window_state();

	/// Adds the tab to the ribbon and sets the current index to this tab
	void set_current_custom_tab(QRibbonTab* tab, QString name);
	void remove_custom_tab();

	template <typename T>
	void open_palette() {
		bool created = false;
		auto palette = window_handler.create_or_raise<T>(this, created);
		if (created) {
			palette->move(width() - palette->width() - 10, ui.widget->y() + 29);
			connect(palette, &T::ribbon_tab_requested, this, &HiveWE::set_current_custom_tab);
			connect(this, &HiveWE::palette_changed, palette, &Palette::deactivate);
			connect(palette, &T::finished, [&]() {
				remove_custom_tab();
				disconnect(this, &HiveWE::palette_changed, palette, &Palette::deactivate);
			});
		}
	}

signals:
	void tileset_changed();
	void palette_changed(QRibbonTab* tab);

	void saving_initiated();
};
```

`src/MainWindow/HiveWE.qrc`:

```qrc
<RCC>
    <qresource prefix="HiveWE">
    </qresource>
</RCC>
```

`src/MainWindow/HiveWE.rc`:

```rc
IDI_ICON1               ICON    DISCARDABLE     "HiveWE.ico"
```

`src/MainWindow/HiveWE.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>HiveWEClass</class>
 <widget class="QMainWindow" name="HiveWEClass">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>400</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>HiveWE 0.7</string>
  </property>
  <widget class="QWidget" name="centralWidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <property name="spacing">
     <number>0</number>
    </property>
    <property name="leftMargin">
     <number>0</number>
    </property>
    <property name="topMargin">
     <number>0</number>
    </property>
    <property name="rightMargin">
     <number>0</number>
    </property>
    <property name="bottomMargin">
     <number>0</number>
    </property>
    <item>
     <widget class="MainRibbon" name="ribbon"/>
    </item>
    <item>
     <widget class="GLWidget" name="widget" native="true">
      <property name="minimumSize">
       <size>
        <width>200</width>
        <height>200</height>
       </size>
      </property>
      <property name="autoFillBackground">
       <bool>false</bool>
      </property>
     </widget>
    </item>
   </layout>
  </widget>
  <action name="actionConvert_Blockers_to_Pathmap">
   <property name="text">
    <string>Convert Blockers to Pathing Map</string>
   </property>
  </action>
  <action name="actionOpen">
   <property name="text">
    <string>Open Map...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+O</string>
   </property>
  </action>
  <action name="actionConvert_Tile_Type_to_PathMap">
   <property name="text">
    <string>Convert Tile Type to Pathing Map</string>
   </property>
  </action>
  <action name="actionPathing_Palette">
   <property name="text">
    <string>Pathing</string>
   </property>
  </action>
  <action name="actionSave">
   <property name="text">
    <string>Save Map</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+S</string>
   </property>
  </action>
  <action name="actionTest_Map">
   <property name="text">
    <string>Test Map</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+T</string>
   </property>
  </action>
  <action name="actionSave_As">
   <property name="text">
    <string>Save Map As...</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+S</string>
   </property>
  </action>
  <action name="actionDoodads">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Doodads</string>
   </property>
   <property name="shortcut">
    <string>D</string>
   </property>
  </action>
  <action name="actionPathing">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Pathing</string>
   </property>
   <property name="shortcut">
    <string>P</string>
   </property>
  </action>
  <action name="actionBrush">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Brush</string>
   </property>
  </action>
  <action name="actionTileSetter">
   <property name="text">
    <string>Modify Tileset...</string>
   </property>
  </action>
  <action name="actionTileReplace">
   <property name="text">
    <string>Replace Tile...</string>
   </property>
  </action>
  <action name="actionUnits">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Units</string>
   </property>
   <property name="shortcut">
    <string>U</string>
   </property>
   <property name="shortcutVisibleInContextMenu">
    <bool>false</bool>
   </property>
  </action>
  <action name="actionChangeTilePathing">
   <property name="text">
    <string>Change Tile Pathing...</string>
   </property>
  </action>
  <action name="actionChangeCliffPathing">
   <property name="text">
    <string>Change Cliff Pathing...</string>
   </property>
  </action>
  <action name="actionBirds_Eye">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Bird's-eye</string>
   </property>
   <property name="toolTip">
    <string>Bird's-eye</string>
   </property>
  </action>
  <action name="actionFirst_Person">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>First-person</string>
   </property>
  </action>
  <action name="actionTerrain_Palette">
   <property name="text">
    <string>Terrain</string>
   </property>
  </action>
  <action name="actionFrame_Times">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Frame Times</string>
   </property>
   <property name="shortcut">
    <string>F3</string>
   </property>
  </action>
  <action name="actionImport_Manager">
   <property name="text">
    <string>Import Manager</string>
   </property>
  </action>
  <action name="actionSwitch_Camera">
   <property name="text">
    <string>Switch Camera</string>
   </property>
   <property name="shortcut">
    <string>F1</string>
   </property>
  </action>
  <action name="actionLighting">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Lighting</string>
   </property>
   <property name="shortcut">
    <string>L</string>
   </property>
  </action>
  <action name="actionWireframe">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Wireframe</string>
   </property>
   <property name="shortcut">
    <string>T</string>
   </property>
  </action>
  <action name="actionReset_Camera">
   <property name="text">
    <string>Reset Camera</string>
   </property>
   <property name="shortcut">
    <string>Ctrl+Shift+C</string>
   </property>
  </action>
  <action name="actionTrigger_Editor">
   <property name="text">
    <string>Trigger Editor</string>
   </property>
  </action>
  <action name="actionDescription">
   <property name="text">
    <string>Description...</string>
   </property>
  </action>
  <action name="actionSize_and_Camera_Bounds">
   <property name="text">
    <string>Size and Camera Bounds...</string>
   </property>
  </action>
  <action name="actionLoading_Screen">
   <property name="text">
    <string>Loading Screen...</string>
   </property>
  </action>
  <action name="actionPreferences">
   <property name="text">
    <string>Preferences...</string>
   </property>
  </action>
  <action name="actionOptions">
   <property name="text">
    <string>Options...</string>
   </property>
  </action>
  <action name="actionDoodads_Palette">
   <property name="text">
    <string>Doodads</string>
   </property>
  </action>
  <action name="actionEnforce_Water_Height_Limit">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="checked">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Enforce Water Height Limits</string>
   </property>
  </action>
  <action name="actionSwitch_Warcraft">
   <property name="text">
    <string>Switch Warcraft folder</string>
   </property>
  </action>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>GLWidget</class>
   <extends>QWidget</extends>
   <header>GLWidget.h</header>
   <container>1</container>
  </customwidget>
  <customwidget>
   <class>MainRibbon</class>
   <extends>QTabWidget</extends>
   <header>MainRibbon.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources>
  <include location="HiveWE.qrc"/>
 </resources>
 <connections/>
</ui>

```

`src/MainWindow/MainRibbon.cpp`:

```cpp
#include "MainRibbon.h"

MainRibbon::MainRibbon(QWidget* parent) : QRibbon(parent) {
	// Home
	QRibbonTab* home_tab = new QRibbonTab;

	// Undo/Redo History
	QRibbonSection* history_section = new QRibbonSection;
	history_section->setText("History");

	undo->setIcon(QIcon("Data/Icons/Ribbon/undo32x32.png"));
	undo->setText("Undo");
	history_section->addWidget(undo);

	redo->setIcon(QIcon("Data/Icons/Ribbon/redo32x32.png"));
	redo->setText("Redo");
	history_section->addWidget(redo);

	//view_history->setIcon(QIcon("Data/Icons/Ribbon/description32x32.png"));
	//view_history->setText("View\nHistory");
	//view_history->setEnabled(false);
	//history_section->addWidget(view_history);

	/*copy->setIcon(QIcon("Data/Icons/Ribbon/copy32x32.ico"));
	copy->setText("Copy");
	home_section->addWidget(copy);

	paste->setIcon(QIcon("Data/Icons/Ribbon/paste32x32.ico"));
	paste->setText("Paste");
	home_section->addWidget(paste);

	QVBoxLayout* lay = new QVBoxLayout;
	QToolButton* but = new QToolButton;
	QToolButton* butt = new QToolButton;
	QToolButton* buttt = new QToolButton;

	but->setIcon(QIcon("Data/Icons/Ribbon/paste32x32.ico"));
	but->setIconSize({ 16, 16 });
	but->setText("Cut");
	but->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);*/

	//lay->addWidget(but);
	//lay->addWidget(butt);
	//lay->addWidget(buttt);

	//history_section->addLayout(lay);
	home_tab->addSection(history_section);

	// View
	QRibbonTab* view_tab = new QRibbonTab;

	// Visible section
	QRibbonSection* visible_section = new QRibbonSection;
	visible_section->setText("Visible");
	view_tab->addSection(visible_section);
	
	units_visible->setIcon(QIcon("Data/Icons/Ribbon/units32x32.png"));
	units_visible->setText("Units");
	units_visible->setCheckable(true);
	units_visible->setChecked(true);
	visible_section->addWidget(units_visible);

	doodads_visible->setIcon(QIcon("Data/Icons/Ribbon/doodads32x32.png"));
	doodads_visible->setText("Doodads");
	doodads_visible->setCheckable(true);
	doodads_visible->setChecked(true);
	visible_section->addWidget(doodads_visible);

	pathing_visible->setIcon(QIcon("Data/Icons/Ribbon/pathing32x32.png"));
	pathing_visible->setText("Pathing");
	pathing_visible->setCheckable(true);
	visible_section->addWidget(pathing_visible);
	
	brush_visible->setIcon(QIcon("Data/Icons/Ribbon/brush32x32.png"));
	brush_visible->setText("Brush");
	brush_visible->setCheckable(true);
	brush_visible->setChecked(true);
	visible_section->addWidget(brush_visible);

	lighting_visible->setIcon(QIcon("Data/Icons/Ribbon/lighting32x32.png"));
	lighting_visible->setText("Lighting");
	lighting_visible->setCheckable(true);
	lighting_visible->setChecked(true);
	visible_section->addWidget(lighting_visible);

	wireframe_visible->setIcon(QIcon("Data/Icons/Ribbon/wireframe32x32.png"));
	wireframe_visible->setText("Wireframe");
	wireframe_visible->setCheckable(true);
	visible_section->addWidget(wireframe_visible);

	debug_visible->setIcon(QIcon("Data/Icons/Ribbon/debug32x32.png"));
	debug_visible->setText("Debug");
	debug_visible->setCheckable(true);
	visible_section->addWidget(debug_visible);

	minimap_visible->setIcon(QIcon("Data/Icons/Ribbon/minimap32x32.png"));
	minimap_visible->setText("Minimap");
	minimap_visible->setCheckable(true);
	minimap_visible->setChecked(true);
	visible_section->addWidget(minimap_visible);
	// Camera section
	QRibbonSection* camera_section = new QRibbonSection;
	camera_section->setText("Camera");
	view_tab->addSection(camera_section);

	switch_camera->setIcon(QIcon("Data/Icons/Ribbon/switch32x32.png"));
	switch_camera->setText("Switch");
	camera_section->addWidget(switch_camera);

	reset_camera->setIcon(QIcon("Data/Icons/Ribbon/reset32x32.png"));
	reset_camera->setText("Reset");
	camera_section->addWidget(reset_camera);

	// Menu actions
	new_map->setText("New Map");
	new_map->setIcon(QIcon("Data/Icons/Ribbon/new32x32.ico"));
	new_map->setIconSize({ 32, 32 });
	new_map->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	new_map->setDisabled(true);
	addMenuItem(new_map);

	open_map_folder->setText("Open Map (Folder)");
	open_map_folder->setIcon(QIcon("Data/Icons/Ribbon/open32x32.png"));
	open_map_folder->setIconSize({ 32, 32 });
	open_map_folder->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(open_map_folder);

	open_map_mpq->setText("Open Map (MPQ)");
	open_map_mpq->setIcon(QIcon("Data/Icons/Ribbon/open32x32.png"));
	open_map_mpq->setIconSize({ 32, 32 });
	open_map_mpq->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(open_map_mpq);

	save_map->setText("Save Map");
	save_map->setIcon(QIcon("Data/Icons/Ribbon/save32x32.png"));
	save_map->setIconSize({ 32, 32 });
	save_map->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(save_map);

	save_map_as->setText("Save Map as");
	save_map_as->setIcon(QIcon("Data/Icons/Ribbon/saveas32x32.png"));
	save_map_as->setIconSize({ 32, 32 });
	save_map_as->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(save_map_as);

	export_mpq->setText("Export MPQ");
	export_mpq->setIcon(QIcon("Data/Icons/Ribbon/saveas32x32.png"));
	export_mpq->setIconSize({ 32, 32 });
	export_mpq->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(export_mpq);

	test_map->setText("Test Map");
	test_map->setIcon(QIcon("Data/Icons/Ribbon/test32x32.ico"));
	test_map->setIconSize({ 32, 32 });
	test_map->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(test_map);

	settings->setText("Settings");
	settings->setIcon(QIcon("Data/Icons/Ribbon/options32x32.png"));
	settings->setIconSize({ 32, 32 });
	settings->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(settings);

	addMenuSeperator();

	exit->setText("Exit");
	exit->setIcon(QIcon("Data/Icons/Ribbon/exit32x32.ico"));
	exit->setIconSize({ 32, 32 });
	exit->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
	addMenuItem(exit);

	// Map tab
	QRibbonTab* map_tab = new QRibbonTab;

	QRibbonSection* map_section = new QRibbonSection;

	map_description->setIcon(QIcon("Data/Icons/Ribbon/description32x32.png"));
	map_description->setText("Description");
	map_section->addWidget(map_description);

	map_loading_screen->setIcon(QIcon("Data/Icons/Ribbon/loading32x32.png"));
	map_loading_screen->setText("Loading\nScreen");
	map_section->addWidget(map_loading_screen);

	map_options->setIcon(QIcon("Data/Icons/Ribbon/options32x32.png"));
	map_options->setText("Options");
	map_section->addWidget(map_options);

	//map_size_camera_bounds->setIcon(QIcon("Data/Icons/Ribbon/sizebounds32x32.png"));
	//map_size_camera_bounds->setText("Size&&Camera\nBounds");
	//map_section->addWidget(map_size_camera_bounds);

	map_tab->addSection(map_section);

	// Tools tab
	QRibbonTab* tools_tab = new QRibbonTab;

	// Import
	QRibbonSection* import_section = new QRibbonSection;
	import_section->setText("Import");

	import_heightmap->setIcon(QIcon("Data/Icons/Ribbon/heightmap32x32.png"));
	import_heightmap->setText("Import\nHeightmap");
	import_section->addWidget(import_heightmap);

	tools_tab->addSection(import_section);

	// Tileset
	QRibbonSection* tileset_section = new QRibbonSection;
	tileset_section->setText("Tileset");

	change_tileset->setIcon(QIcon("Data/Icons/Ribbon/tileset32x32.png"));
	change_tileset->setText("Change\nTileset");
	tileset_section->addWidget(change_tileset);

	change_tile_pathing->setIcon(QIcon("Data/Icons/Ribbon/tileset32x32.png"));
	change_tile_pathing->setText("Change Tile\nPathing");
	tileset_section->addWidget(change_tile_pathing);

	tools_tab->addSection(tileset_section);

	QRibbonSection* game_section = new QRibbonSection;
	game_section->setText("Game");

	switch_warcraft->setIcon(QIcon("Data/Icons/Ribbon/WarIII32x32.ico"));
	switch_warcraft->setText("Change\n Game folder");
	game_section->addWidget(switch_warcraft);

	tools_tab->addSection(game_section);	

	// Window Tab
	QRibbonTab* window_tab = new QRibbonTab;

	QRibbonSection* editor_section = new QRibbonSection;
	editor_section->setText("Editor/Viewer");

	object_editor->setIcon(QIcon("Data/Icons/Ribbon/objecteditor32x32.png"));
	object_editor->setText("Object\nEditor");
	editor_section->addWidget(object_editor);

	model_editor->setIcon(QIcon("Data/Icons/Ribbon/objecteditor32x32.png"));
	model_editor->setText("Model\nEditor");
	editor_section->addWidget(model_editor);

	QRibbonSection* palette_section = new QRibbonSection;
	palette_section->setText("Palette"); 
	
	terrain_palette->setIcon(QIcon("Data/Icons/Ribbon/heightmap32x32.png"));
	terrain_palette->setText("Terrain");
	palette_section->addWidget(terrain_palette);

	doodad_palette->setIcon(QIcon("Data/Icons/Ribbon/doodads32x32.png"));
	doodad_palette->setText("Doodads");
	palette_section->addWidget(doodad_palette);

	unit_palette->setIcon(QIcon("Data/Icons/Ribbon/doodads32x32.png"));
	unit_palette->setText("Units");
	palette_section->addWidget(unit_palette);

	pathing_palette->setIcon(QIcon("Data/Icons/Ribbon/pathing32x32.png"));
	pathing_palette->setText("Pathing");
	palette_section->addWidget(pathing_palette);

	window_tab->addSection(editor_section);
	window_tab->addSection(palette_section);


	addTab(home_tab, "Home");
	addTab(view_tab, "View");
	addTab(map_tab, "Map");
	addTab(tools_tab, "Tools");
	addTab(window_tab, "Window");

}

MainRibbon::~MainRibbon() {
}
```

`src/MainWindow/MainRibbon.h`:

```h
#pragma once

#include "QRibbon.h"

class MainRibbon : public QRibbon {
	Q_OBJECT

public:
	QRibbonButton* undo = new QRibbonButton;
	QRibbonButton* redo = new QRibbonButton;
	QRibbonButton* view_history = new QRibbonButton;


	QRibbonButton* copy = new QRibbonButton;
	QRibbonButton* paste = new QRibbonButton;

	QRibbonButton* units_visible = new QRibbonButton;
	QRibbonButton* doodads_visible = new QRibbonButton;
	QRibbonButton* pathing_visible = new QRibbonButton;
	QRibbonButton* brush_visible = new QRibbonButton;
	QRibbonButton* lighting_visible = new QRibbonButton;
	QRibbonButton* wireframe_visible = new QRibbonButton;
	QRibbonButton* debug_visible = new QRibbonButton;
	QRibbonButton* minimap_visible = new QRibbonButton;

	QRibbonButton* switch_camera = new QRibbonButton;
	QRibbonButton* reset_camera = new QRibbonButton;

	QRibbonButton* map_description = new QRibbonButton;
	QRibbonButton* map_loading_screen = new QRibbonButton;
	QRibbonButton* map_options = new QRibbonButton;
	QRibbonButton* map_size_camera_bounds = new QRibbonButton;

	QRibbonButton* import_heightmap = new QRibbonButton;
	QRibbonButton* change_tileset = new QRibbonButton;
	QRibbonButton* change_tile_pathing = new QRibbonButton;
	QRibbonButton* switch_warcraft = new QRibbonButton;

	QRibbonButton* object_editor = new QRibbonButton;
	QRibbonButton* model_editor = new QRibbonButton;

	QRibbonButton* terrain_palette = new QRibbonButton;
	QRibbonButton* doodad_palette = new QRibbonButton;
	QRibbonButton* unit_palette = new QRibbonButton;
	QRibbonButton* pathing_palette = new QRibbonButton;

	QToolButton* new_map = new QToolButton;
	QToolButton* open_map_mpq = new QToolButton;
	QToolButton* open_map_folder = new QToolButton;

	QToolButton* save_map = new QToolButton;
	QToolButton* save_map_as = new QToolButton;
	QToolButton* export_mpq = new QToolButton;

	QToolButton* test_map = new QToolButton;
	QToolButton* settings = new QToolButton;
	QToolButton* exit = new QToolButton;

	MainRibbon(QWidget* parent);
	~MainRibbon();
};

```

`src/Menus/DoodadPalette.cpp`:

```cpp
#include "DoodadPalette.h"

#include <QRadioButton>
#include <QCheckBox>
#include <QFormLayout>
#include <QDoubleValidator>
#include <QComboBox>
#include <QListView>

#include "Globals.h"
#include "Selections.h"

#include "TableModel.h"
#include <ObjectEditor.h>

DoodadPalette::DoodadPalette(QWidget* parent) : Palette(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);
	show();

	map->brush = &brush;

	ui.tileset->addItem("All Tilesets", '*');
	for (auto&&[key, value] : world_edit_data.section("TileSets")) {
		ui.tileset->addItem(QString::fromStdString(value.front()), key.front());
	}

	for (auto&&[key, value] : world_edit_data.section("DoodadCategories")) {
		ui.type->addItem(QString::fromStdString(value.front()), QString::fromStdString(key));
	}

	for (auto&&[key, value] : world_edit_data.section("DestructibleCategories")) {
		const std::string text = value.front();
		ui.type->addItem(QString::fromStdString(text), QString::fromStdString(key));
	}

	DoodadListModel* doodad_list_model = new DoodadListModel;
	doodad_list_model->setSourceModel(doodads_table);

	DestructableListModel* destructable_list_model = new DestructableListModel;
	destructable_list_model->setSourceModel(destructibles_table);

	doodad_filter_model = new DoodadListFilter(this);
	doodad_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	doodad_filter_model->setSourceModel(doodad_list_model);
	doodad_filter_model->sort(0, Qt::AscendingOrder);

	destructable_filter_model = new DestructableListFilter(this);
	destructable_filter_model->setFilterCaseSensitivity(Qt::CaseInsensitive);
	destructable_filter_model->setSourceModel(destructable_list_model);
	destructable_filter_model->sort(0, Qt::AscendingOrder);

	table = new QConcatenateTablesProxyModel;
	table->addSourceModel(doodad_filter_model);
	table->addSourceModel(destructable_filter_model);

	ui.doodads->setModel(table);

	QRibbonSection* selection_section = new QRibbonSection;
	selection_section->setText("Selection");

	selection_mode->setText("Selection\nMode");
	selection_mode->setIcon(QIcon("Data/Icons/Ribbon/select32x32.png"));
	selection_mode->setCheckable(true);
	selection_section->addWidget(selection_mode);

	//selections_button->setText("View\nSelections");
	//selections_button->setIcon(QIcon("Data/Icons/Ribbon/description32x32.png.png"));
	//selection_section->addWidget(selections_button);

	//QVBoxLayout* selection_choices_layout = new QVBoxLayout;
	//QCheckBox* select_destructibles = new QCheckBox("Destructibles");
	//select_destructibles->setChecked(true);
	//QCheckBox* select_doodads = new QCheckBox("Doodads");
	//select_doodads->setChecked(true);
	
	//selection_choices_layout->addWidget(select_destructibles);
	//selection_choices_layout->addWidget(select_doodads);

	//selection_section->addLayout(selection_choices_layout);

	find_this = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	find_parent = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), parent, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	selection_mode->setShortCut(Qt::Key_Space, { this, parent });

	QRibbonSection* placement_section = new QRibbonSection;
	placement_section->setText("Placement");

	QRibbonButton* random_rotation = new QRibbonButton;
	random_rotation->setText("Random\nRotation");
	random_rotation->setIcon(QIcon("Data/Icons/Ribbon/reset32x32.png"));
	random_rotation->setCheckable(true);
	random_rotation->setChecked(true);
	placement_section->addWidget(random_rotation);

	QRibbonButton* random_scale = new QRibbonButton;
	random_scale->setText("Random\nScale");
	random_scale->setIcon(QIcon("Data/Icons/Ribbon/scale32x32.png"));
	random_scale->setCheckable(true);
	random_scale->setChecked(true);
	placement_section->addWidget(random_scale);

	QRibbonButton* lock_height = new QRibbonButton;
	lock_height->setText("Lock\nHeight");
	lock_height->setIcon(QIcon("Data/Icons/Ribbon/lock.png"));
	lock_height->setCheckable(true);
	placement_section->addWidget(lock_height);

	QRibbonSection* variation_section = new QRibbonSection;
	variation_section->setText("Variations");

	QRibbonButton* random_variation = new QRibbonButton;
	random_variation->setText("Random\nVariation");
	random_variation->setIcon(QIcon("Data/Icons/Ribbon/variation32x32.png"));
	random_variation->setCheckable(true);
	random_variation->setChecked(true);
	variation_section->addWidget(random_variation);
	variation_section->addWidget(variations);

	QRibbonSection* flags_section = new QRibbonSection;
	flags_section->setText("Flags");

	QVBoxLayout* visibility_flags_layout = new QVBoxLayout;

	QRadioButton* invisible_non_solid = new QRadioButton;
	invisible_non_solid->setText("Invisible non solid");

	QRadioButton* visible_non_solid = new QRadioButton;
	visible_non_solid->setText("Visible non solid");

	QRadioButton* visible_solid = new QRadioButton;
	visible_solid->setText("Visible solid");
	visible_solid->setChecked(true);

	visibility_flags_layout->addWidget(invisible_non_solid);
	visibility_flags_layout->addWidget(visible_non_solid);
	visibility_flags_layout->addWidget(visible_solid);

	visibility_flags_layout->setSpacing(6);
	flags_section->addLayout(visibility_flags_layout);

	current_selection_section = new QRibbonSection;
	current_selection_section->setText("Current Selection");

	QFormLayout* scaling_layout = new QFormLayout;
	scaling_layout->setSpacing(1);
	scaling_layout->setHorizontalSpacing(5);

	x_scale->setValidator(new QDoubleValidator(0.0, 100.0, 3));
	y_scale->setValidator(new QDoubleValidator(0.0, 100.0, 3));
	z_scale->setValidator(new QDoubleValidator(0.0, 100.0, 3));

	scaling_layout->addRow("x scale:", x_scale);
	scaling_layout->addRow("y scale:", y_scale);
	scaling_layout->addRow("z scale:", z_scale);

	QVBoxLayout* rotation_layout = new QVBoxLayout;

	QRibbonButton* degrees0 = new QRibbonButton;
	QRibbonButton* degrees90 = new QRibbonButton;
	QRibbonButton* degrees180 = new QRibbonButton;
	QRibbonButton* degrees270 = new QRibbonButton;

	degrees0->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);
	degrees90->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);
	degrees180->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);
	degrees270->setSizePolicy(QSizePolicy::Policy::Expanding, QSizePolicy::Policy::Expanding);

	degrees0->setText("0");
	degrees90->setText("90");
	degrees180->setText("180");
	degrees270->setText("270");

	rotation->setValidator(new QDoubleValidator(0.0, 100.0, 3));

	QGridLayout* degrees_layout = new QGridLayout;
	degrees_layout->addWidget(degrees0, 0, 0);
	degrees_layout->addWidget(degrees90, 1, 0);
	degrees_layout->addWidget(degrees180, 0, 1);
	degrees_layout->addWidget(degrees270, 1, 1);

	QHBoxLayout* rotation_sub = new QHBoxLayout;
	rotation_sub->addWidget(new QLabel("Angle:"));
	rotation_sub->addSpacing(5);
	rotation_sub->addWidget(rotation);
	rotation_layout->addLayout(rotation_sub);
	rotation_layout->addLayout(degrees_layout);

	QRibbonButton* average_z = new QRibbonButton;
	average_z->setText("Group\nHeight  ");
	average_z->setIcon(QIcon("Data/Icons/Ribbon/height.png"));
	average_z->addAction(group_height_minimum);
	average_z->addAction(group_height_average);
	average_z->addAction(group_height_maximum);
	average_z->setPopupMode(QToolButton::ToolButtonPopupMode::InstantPopup);

	QFormLayout* height_layout = new QFormLayout;
	height_layout->setSpacing(1);
	height_layout->setHorizontalSpacing(5);

	absolute_height->setValidator(new QDoubleValidator(-100.0, 100.0, 3));
	relative_height->setValidator(new QDoubleValidator(-100.0, 100.0, 3));

	height_layout->addRow("Absolute Height:", absolute_height);
	height_layout->addRow("Relative Height:", relative_height);

	QSmallRibbonButton* edit_in_oe = new QSmallRibbonButton;
	edit_in_oe->setText("Edit in OE");
	edit_in_oe->setIcon(QIcon("Data/Icons/Ribbon/objecteditor32x32.png"));

	QSmallRibbonButton* select_in_palette = new QSmallRibbonButton;
	select_in_palette->setText("Select in Palette");
	select_in_palette->setToolTip("Or click the doodad with middle mouse button");
	select_in_palette->setIcon(QIcon("Data/Icons/Ribbon/doodads32x32.png"));

	QVBoxLayout* info_layout = new QVBoxLayout;
	info_layout->addWidget(selection_name);
	info_layout->addWidget(edit_in_oe);
	//info_layout->addWidget(select_in_palette);

	current_selection_section->addLayout(scaling_layout);
	current_selection_section->addSpacing(5);
	current_selection_section->addLayout(rotation_layout);
	current_selection_section->addSpacing(5);
	current_selection_section->addLayout(height_layout);
	current_selection_section->addWidget(average_z);
	current_selection_section->addSpacing(5);
	current_selection_section->addLayout(info_layout);

	ribbon_tab->addSection(selection_section);
	ribbon_tab->addSection(placement_section);
	ribbon_tab->addSection(variation_section);
	ribbon_tab->addSection(flags_section);
	ribbon_tab->addSection(current_selection_section);

	connect(selection_mode, &QRibbonButton::toggled, [&]() { brush.switch_mode(); });
	connect(random_rotation, &QRibbonButton::toggled, [&](bool checked) { brush.random_rotation = checked; });
	connect(random_scale, &QRibbonButton::toggled, [&](bool checked) { brush.random_scale = checked; });
	connect(random_variation, &QRibbonButton::toggled, [&](bool checked) { brush.random_variation = checked; });
	connect(lock_height, &QRibbonButton::toggled, [&](bool checked) { brush.lock_doodad_z = checked; });

	connect(invisible_non_solid, &QRadioButton::clicked, [&]() { brush.state = Doodad::State::invisible_non_solid; });
	connect(visible_non_solid, &QRadioButton::clicked, [&]() { brush.state = Doodad::State::visible_non_solid; });
	connect(visible_solid, &QRadioButton::clicked, [&]() { brush.state = Doodad::State::visible_solid; });

	connect(ui.type, QOverload<int>::of(&QComboBox::currentIndexChanged), [&](int index) {
		// Possible Qt bug. Try swapping the two lines below and see if it crashes when selecting a tree and then swapping to a doodad category
		destructable_filter_model->setFilterCategory(ui.type->currentData().toString());
		doodad_filter_model->setFilterCategory(ui.type->currentData().toString());
	});

	connect(ui.tileset, QOverload<int>::of(&QComboBox::currentIndexChanged), [&](int index) {
		destructable_filter_model->setFilterTileset(ui.tileset->currentData().toChar().toLatin1());
		doodad_filter_model->setFilterTileset(ui.tileset->currentData().toChar().toLatin1());
	});

	connect(find_this, &QShortcut::activated, [&]() {
		ui.search->activateWindow();
		ui.search->setFocus();
		ui.search->selectAll();
	});

	connect(find_parent, &QShortcut::activated, [&]() {
		ui.search->activateWindow();
		ui.search->setFocus();
		ui.search->selectAll();
	});

	connect(ui.search, &QLineEdit::textEdited, doodad_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(ui.search, &QLineEdit::textEdited, destructable_filter_model, &QSortFilterProxyModel::setFilterFixedString);
	connect(ui.search, &QLineEdit::returnPressed, [&]() {
		ui.doodads->setCurrentIndex(ui.doodads->model()->index(0, 0));
		selection_changed(ui.doodads->model()->index(0, 0));
		ui.doodads->setFocus();
	});

	connect(ui.doodads, &QListView::clicked, this, &DoodadPalette::selection_changed);
	connect(ui.doodads, &QListView::activated, this, &DoodadPalette::selection_changed);

	connect(&brush, &DoodadBrush::selection_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::angle_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::scale_changed, this, &DoodadPalette::update_selection_info);
	connect(&brush, &DoodadBrush::position_changed, this, &DoodadPalette::update_selection_info);

	connect(x_scale, &QLineEdit::textEdited, [&](const QString& text) { update_scale_change(0, text); });
	connect(y_scale, &QLineEdit::textEdited, [&](const QString& text) { update_scale_change(1, text); });
	connect(z_scale, &QLineEdit::textEdited, [&](const QString& text) { update_scale_change(2, text); });
	connect(x_scale, &QLineEdit::editingFinished, [&]() { update_scale_finish(0); });
	connect(y_scale, &QLineEdit::editingFinished, [&]() { update_scale_finish(1); });
	connect(z_scale, &QLineEdit::editingFinished, [&]() { update_scale_finish(2); });

	connect(rotation, &QLineEdit::textEdited, this, &DoodadPalette::update_rotation_change);
	connect(absolute_height, &QLineEdit::textEdited, this, &DoodadPalette::update_absolute_change);
	connect(relative_height, &QLineEdit::textEdited, this, &DoodadPalette::update_relative_change);

	connect(degrees0, &QRibbonButton::clicked, [&]() { set_selection_rotation(0.f); });
	connect(degrees90, &QRibbonButton::clicked, [&]() { set_selection_rotation(90.f); });
	connect(degrees180, &QRibbonButton::clicked, [&]() { set_selection_rotation(180.f); });
	connect(degrees270, &QRibbonButton::clicked, [&]() { set_selection_rotation(270.f); });

	connect(group_height_minimum, &QAction::triggered, this, &DoodadPalette::set_group_height_minimum);
	connect(group_height_average, &QAction::triggered, this, &DoodadPalette::set_group_height_average);
	connect(group_height_maximum, &QAction::triggered, this, &DoodadPalette::set_group_height_maximum);
	
	connect(edit_in_oe, &QSmallRibbonButton::clicked, [&]() {
		bool created;
		auto editor = window_handler.create_or_raise<ObjectEditor>(nullptr, created);
		const Doodad& doodad = *brush.selections.front();
		if (destructibles_slk.row_headers.contains(doodad.id)) {
			editor->select_id(ObjectEditor::Category::destructible, doodad.id);
		} else {
			editor->select_id(ObjectEditor::Category::doodad, doodad.id);
		}
	});

	//connect(select_in_palette, &QSmallRibbonButton::clicked, [&]() {
	//	const Doodad& doodad = *brush.selections.front();
	//	ui.type
	//	auto model = ui.doodads->selectionModel()->select(;
	//	
	//});


	// Default to Trees/Destructibles
	ui.type->setCurrentIndex(ui.type->count() - 2);
	ui.tileset->setCurrentIndex(0);

	ui.search->setFocus();
	ui.search->selectAll();
}

DoodadPalette::~DoodadPalette() {
	map->brush = nullptr;
}

bool DoodadPalette::event(QEvent *e) {
	if (e->type() == QEvent::Close) {
		// Remove shortcut from parent
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
		selection_mode->disconnectShortcuts();
		ribbon_tab->setParent(nullptr);
		delete ribbon_tab;
	} else if (e->type() == QEvent::WindowActivate) {
		find_this->setEnabled(true);
		find_parent->setEnabled(true);
		selection_mode->enableShortcuts();
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Doodad Palette");
	}

	return QWidget::event(e);
}

void DoodadPalette::selection_changed(const QModelIndex& index) {
	std::string id;

	const auto model = table->mapToSource(index).model();
	if (model == destructable_filter_model) {
		const int row = destructable_filter_model->mapToSource(table->mapToSource(index)).row();
		id = destructibles_slk.index_to_row.at(row);
	} else if (model == doodad_filter_model) {
		const int row = doodad_filter_model->mapToSource(table->mapToSource(index)).row();
		id = doodads_slk.index_to_row.at(row);
	}

	brush.set_doodad(id);
	selection_mode->setChecked(false);

	bool is_doodad = doodads_slk.row_headers.contains(id);
	slk::SLK& slk = is_doodad ? doodads_slk : destructibles_slk;

	variations->clear();

	int variation_count = slk.data<int>("numvar", id);
	for (int i = 0; i < variation_count; i++) {
		QRibbonButton* toggle = new QRibbonButton;
		toggle->setCheckable(true);
		toggle->setChecked(true);
		toggle->setText(QString::number(i));
		variations->addWidget(toggle, i % 3, i / 3);
		connect(toggle, &QRibbonButton::toggled, [&](bool checked) {
			if (checked) {
				brush.add_variation(i);
			} else {
				brush.erase_variation(i);
			}
		});
	}
}

void DoodadPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
		selection_mode->disableShortcuts();
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
	}
}

QString toString(float num) {
	QString str = QString::number(num, 'f', 3);
	str.remove(QRegularExpression("\\.?0+$"));
	return str;
}

void DoodadPalette::update_selection_info() {
	if (brush.selections.empty()) {
		if (current_selection_section->isEnabled()) {
			current_selection_section->setEnabled(false);
		}
	} else {
		if (!current_selection_section->isEnabled()) {
			current_selection_section->setEnabled(true);
		}
		const Doodad& doodad = *brush.selections.front();

		float first_relative_height = doodad.position.z - map->terrain.interpolated_height(doodad.position.x, doodad.position.y);
		bool same_x = true;
		bool same_y = true;
		bool same_z = true;
		bool same_angle = true;
		bool same_absolute_height = true;
		bool same_relative_height = true;
		for (const auto& i : brush.selections) {
			float other_relative_height = i->position.z - map->terrain.interpolated_height(i->position.x, i->position.y);

			same_x = same_x && i->scale.x == doodad.scale.x;
			same_y = same_y && i->scale.y == doodad.scale.y;
			same_z = same_z && i->scale.z == doodad.scale.z;
			same_angle = same_angle && i->angle == doodad.angle;
			same_absolute_height = same_absolute_height && i->position.z == doodad.position.z;
			same_relative_height = same_relative_height && other_relative_height == first_relative_height;
		}

		x_scale->setText(same_x ? QString::number(doodad.scale.x) : "Differing");
		y_scale->setText(same_y ? QString::number(doodad.scale.y) : "Differing");
		z_scale->setText(same_z ? QString::number(doodad.scale.z) : "Differing");
		rotation->setText(same_angle ? toString(glm::degrees(doodad.angle)) : "Differing");
		absolute_height->setText(same_angle ? toString(doodad.position.z) : "Differing");
		relative_height->setText(same_angle ? toString(first_relative_height) : "Differing");

		// Set the name
		if (brush.selections.size() == 1) {
			if (doodads_slk.row_headers.contains(doodad.id)) {
				auto index = doodads_table->index(doodads_slk.row_headers.at(doodad.id), doodads_slk.column_headers.at("name"));
				selection_name->setText(doodads_table->data(index).toString());
			} else {
				auto index = destructibles_table->index(destructibles_slk.row_headers.at(doodad.id), destructibles_slk.column_headers.at("name"));
				selection_name->setText(destructibles_table->data(index).toString());
			}
		} else {
			selection_name->setText("Various");
		}
	}
}

void DoodadPalette::update_scale_change(int component, const QString& text) {
	brush.set_selection_scale_component(component, text.toFloat());
}

void DoodadPalette::update_scale_finish(int component) {
	if (brush.selections.empty()) {
		return;
	}

	update_selection_info();
}

void DoodadPalette::update_rotation_change(const QString& text) {
	brush.set_selection_angle(glm::radians(text.toFloat()));
	update_selection_info();
}

void DoodadPalette::update_absolute_change(const QString& text) {
	brush.set_selection_absolute_height(text.toFloat());
	update_selection_info();
}

void DoodadPalette::update_relative_change(const QString& text) {
	brush.set_selection_relative_height(text.toFloat());
	update_selection_info();
}

void DoodadPalette::set_group_height_minimum() {
	float minimum = std::numeric_limits<float>::max();
	for (auto& i : brush.selections) {
		minimum = std::min(minimum, i->position.z);
	}

	brush.set_selection_absolute_height(minimum);
}

void DoodadPalette::set_group_height_average() {
	float average = 0.f;
	for (auto& i : brush.selections) {
		average += i->position.z;
	}
	brush.set_selection_absolute_height(average / brush.selections.size());
}

void DoodadPalette::set_group_height_maximum() {
	float maximum = std::numeric_limits<float>::min();
	for (auto& i : brush.selections) {
		maximum = std::max(maximum, i->position.z);
	}

	brush.set_selection_absolute_height(maximum);
}

void DoodadPalette::set_selection_rotation(float rotation) {
	brush.set_selection_angle(glm::radians(rotation));
	update_selection_info();
}
```

`src/Menus/DoodadPalette.h`:

```h
#pragma once

#include "ui_DoodadPalette.h"

#include <QLineEdit>

#include "DoodadBrush.h"
#include "Palette.h"
#include "QRibbon.h"
#include "AspectRatioPixmapLabel.h"
#include "DoodadListModel.h"
#include "DestructableListModel.h"

#include <QConcatenateTablesProxyModel>

class DoodadPalette : public Palette {
	Q_OBJECT

public:
	DoodadPalette(QWidget* parent = nullptr);
	~DoodadPalette();

private:
	bool event(QEvent *e) override;

	void selection_changed(const QModelIndex& index);

	Ui::DoodadPalette ui;

	DoodadBrush brush;
	DoodadListModel* doodad_list_model;
	DoodadListFilter* doodad_filter_model;
	DestructableListModel* destructable_list_model;
	DestructableListFilter* destructable_filter_model;
	QConcatenateTablesProxyModel* table;

	QRibbonTab* ribbon_tab = new QRibbonTab;
	QRibbonButton* selection_mode = new QRibbonButton;
	QRibbonButton* selections_button = new QRibbonButton;

	QRibbonContainer* variations = new QRibbonContainer;

	QRibbonSection* current_selection_section = new QRibbonSection;
	QLineEdit* x_scale = new QLineEdit;
	QLineEdit* y_scale = new QLineEdit;
	QLineEdit* z_scale = new QLineEdit;
	QLineEdit* rotation = new QLineEdit;

	QLineEdit* absolute_height = new QLineEdit;
	QLineEdit* relative_height = new QLineEdit;

	QAction* group_height_minimum = new QAction("Minimum");
	QAction* group_height_average = new QAction("Average");
	QAction* group_height_maximum = new QAction("Maximum");

	QLabel* selection_name = new QLabel;

	QShortcut* find_this;
	QShortcut* find_parent;


public slots:
	void deactivate(QRibbonTab* tab) override;
	void update_selection_info();
	void update_scale_change(int component, const QString& text);
	void update_scale_finish(int component);
	void update_rotation_change(const QString& text);
	void update_absolute_change(const QString& text);
	void update_relative_change(const QString& text);
	void set_group_height_minimum();
	void set_group_height_average();
	void set_group_height_maximum();
	void set_selection_rotation(float rotation);
};
```

`src/Menus/DoodadPalette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>DoodadPalette</class>
 <widget class="QDialog" name="DoodadPalette">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>244</width>
    <height>560</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Doodad Palette</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QComboBox" name="tileset">
     <property name="maxVisibleItems">
      <number>20</number>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QComboBox" name="type"/>
   </item>
   <item>
    <widget class="QLineEdit" name="search">
     <property name="placeholderText">
      <string>Search</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QListView" name="doodads"/>
   </item>
   <item>
    <widget class="QGroupBox" name="brushGroupBox">
     <property name="enabled">
      <bool>true</bool>
     </property>
     <property name="maximumSize">
      <size>
       <width>16777215</width>
       <height>0</height>
      </size>
     </property>
     <property name="title">
      <string>Brush</string>
     </property>
     <property name="flat">
      <bool>true</bool>
     </property>
     <property name="checkable">
      <bool>false</bool>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_4">
      <property name="leftMargin">
       <number>0</number>
      </property>
      <property name="topMargin">
       <number>9</number>
      </property>
      <property name="rightMargin">
       <number>0</number>
      </property>
      <property name="bottomMargin">
       <number>0</number>
      </property>
      <item>
       <layout class="QHBoxLayout" name="horizontalLayout_2">
        <item>
         <widget class="QPushButton" name="brushSize1">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="baseSize">
           <size>
            <width>0</width>
            <height>0</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 1x1.</string>
          </property>
          <property name="text">
           <string>1</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize3">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 3x3.</string>
          </property>
          <property name="text">
           <string>2</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize5">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 5x5.</string>
          </property>
          <property name="text">
           <string>3</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize7">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 9x9.</string>
          </property>
          <property name="text">
           <string>5</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize9">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 15x15.</string>
          </property>
          <property name="text">
           <string>8</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushSize11">
          <property name="minimumSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="toolTip">
           <string>Sets the brush size to 21x21.</string>
          </property>
          <property name="text">
           <string>11</string>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </item>
      <item>
       <layout class="QHBoxLayout" name="horizontalLayout_4">
        <item>
         <widget class="QSpinBox" name="brushSize">
          <property name="toolTip">
           <string>The current brush size</string>
          </property>
          <property name="readOnly">
           <bool>true</bool>
          </property>
          <property name="buttonSymbols">
           <enum>QAbstractSpinBox::NoButtons</enum>
          </property>
          <property name="minimum">
           <number>1</number>
          </property>
          <property name="maximum">
           <number>241</number>
          </property>
          <property name="singleStep">
           <number>2</number>
          </property>
          <property name="value">
           <number>1</number>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QSlider" name="brushSizeSlider">
          <property name="toolTip">
           <string>Sets the brush size.</string>
          </property>
          <property name="minimum">
           <number>1</number>
          </property>
          <property name="maximum">
           <number>128</number>
          </property>
          <property name="singleStep">
           <number>1</number>
          </property>
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
          <property name="invertedAppearance">
           <bool>false</bool>
          </property>
          <property name="invertedControls">
           <bool>false</bool>
          </property>
          <property name="tickPosition">
           <enum>QSlider::TicksBelow</enum>
          </property>
          <property name="tickInterval">
           <number>0</number>
          </property>
         </widget>
        </item>
       </layout>
      </item>
      <item>
       <widget class="QLabel" name="label">
        <property name="text">
         <string>Shape</string>
        </property>
       </widget>
      </item>
      <item>
       <layout class="QHBoxLayout" name="brushShapeLayout">
        <item>
         <widget class="QPushButton" name="brushShapeCircle">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="toolTip">
           <string>Circular brush shape</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>Data/Icons/Brush/circle.png</normaloff>Data/Icons/Brush/circle.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushShapeSquare">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="toolTip">
           <string>Square brush shape</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>Data/Icons/Brush/square.png</normaloff>Data/Icons/Brush/square.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="brushShapeDiamond">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="toolTip">
           <string>Diamond brush shape</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>Data/Icons/Brush/diamond.png</normaloff>Data/Icons/Brush/diamond.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <spacer name="horizontalSpacer_3">
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>40</width>
            <height>20</height>
           </size>
          </property>
         </spacer>
        </item>
       </layout>
      </item>
     </layout>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/Menus/MapInfoEditor.cpp`:

```cpp
#include "MapInfoEditor.h"

#include "Globals.h"


MapInfoEditor::MapInfoEditor(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);

	// Description Tab
	ui.name->setText(QString::fromStdString(map->trigger_strings.string(map->info.name)));
	ui.suggestedPlayers->setText(QString::fromStdString(map->trigger_strings.string(map->info.suggested_players)));
	ui.description->setPlainText(QString::fromStdString(map->trigger_strings.string(map->info.description)));
	ui.author->setText(QString::fromStdString(map->trigger_strings.string(map->info.author)));

	ui.mapVersion->setText(QString::number(map->info.map_version));
	ui.editorVersion->setText(QString::number(map->info.editor_version));

	// Loading Screen Tab
	for (auto&&[key, value] : world_edit_data.section("LoadingScreens")) {
		if (key == "NumScreens") {
			continue;
		}
		ui.campaignLoadingScreen->addItem(QString::fromStdString(value[1]));
	}

	//for (auto&& i : map->imports.find([](const ImportItem& item) { return item.full_path.extension() == ".mdx"; })) {
	//	ui.importedLoadingScreen->addItem(QString::fromStdString(i.get().full_path.string()));
	//}

	for (auto&&[key, value] : world_edit_data.section("LoadingScreens")) {
		if (key == "NumScreens") {
			continue;
		}
		ui.campaignLoadingScreen->addItem(QString::fromStdString(value[1]));
	}

	if (map->info.loading_screen_model.empty() && map->info.loading_screen_number == -1) {
		ui.useDefaultLoadingScreen->setChecked(true);
	} else if (!map->info.loading_screen_model.empty() && map->info.loading_screen_number == -1) {
		ui.useImportedLoadingScreen->setChecked(true);
		ui.importedLoadingScreen->setCurrentText(QString::fromStdString(map->info.loading_screen_model));
	} else {
		ui.useCampaignLoadingScreen->setChecked(true);
		ui.campaignLoadingScreen->setCurrentIndex(map->info.loading_screen_number);
	}

	ui.loadingScreenTitle->setText(QString::fromStdString(map->trigger_strings.string(map->info.loading_screen_title)));
	ui.loadingScreenSubtitle->setText(QString::fromStdString(map->trigger_strings.string(map->info.loading_screen_subtitle)));
	ui.loadingScreenText->setPlainText(QString::fromStdString(map->trigger_strings.string(map->info.loading_screen_text)));

	// Options Tab
	ui.meleeMap->setChecked(map->info.melee_map);
	ui.hideMinimapPreview->setChecked(map->info.hide_minimap_preview);
	ui.maskedPartiallyVisible->setChecked(map->info.masked_area_partially_visible);
	ui.cliffWaves->setChecked(map->info.cliff_shore_waves);
	ui.rollingShoreWaves->setChecked(map->info.rolling_shore_waves);

	ui.terrainFogBox->setChecked(map->info.fog_style != 0);
	ui.fogStyle->setCurrentIndex(map->info.fog_style);
	ui.fogZStart->setValue(map->info.fog_start_z_height);
	ui.fogZEnd->setValue(map->info.fog_end_z_height);
	ui.fogDensity->setValue(map->info.fog_density);
	ui.fogColor->setColor(QColor(map->info.fog_color.r, map->info.fog_color.g, map->info.fog_color.b));

	ui.waterTinting->setChecked(map->info.water_tinting);
	ui.waterColor->setColor(QColor(map->info.water_color.r, map->info.water_color.g, map->info.water_color.b));

	ui.globalWeather->setChecked(map->info.weather_id != 0);

	// Global Weather
	slk::SLK weather_slk("TerrainArt/Weather.slk");
	weather_slk.substitute(world_edit_strings, "WorldEditStrings");

	ui.globalWeather->setChecked(map->info.weather_id != 0);
	for (size_t i = 1; i < weather_slk.rows(); i++) {
		ui.globalWeatherCombo->addItem(QString::fromStdString(weather_slk.data("name", i)), QString::fromStdString(weather_slk.data("effectid", i)));
	}
	std::string weather_id = { reinterpret_cast<char*>(&map->info.weather_id), 4 };
	ui.globalWeatherCombo->setCurrentText(QString::fromStdString(weather_slk.data("name", weather_id)));

	// Custom Sound
	slk::SLK environment_sounds_slk("UI/SoundInfo/EnvironmentSounds.slk");
	environment_sounds_slk.substitute(world_edit_strings, "WorldEditStrings");

	ui.customSound->setChecked(!map->info.custom_sound_environment.empty());
	for (size_t i = 1; i < environment_sounds_slk.rows(); i++) {
		ui.customSoundCombo->addItem(QString::fromStdString(environment_sounds_slk.data("displaytext", i)), QString::fromStdString(environment_sounds_slk.data("environmenttype", i)));
	}
	ui.customSoundCombo->setCurrentText(QString::fromStdString(environment_sounds_slk.data("displaytext", map->info.custom_sound_environment)));

	// Custom Lighting
	for (auto&& [key, value] : world_edit_data.section("TileSets")) {
		ui.customLightingCombo->addItem(QString::fromStdString(value[0]), key.front());

		if (key == std::string(&map->info.custom_light_tileset, 1)) {
			ui.customLightingCombo->setCurrentIndex(ui.customLightingCombo->count() - 1);
		}
	}
	ui.customLighting->setChecked(map->info.custom_light_tileset != 0);

	ui.itemClassification->setChecked(map->info.item_classification);
	ui.gameDataSet->setCurrentIndex(map->info.game_data_set);


	connect(ui.buttonBox, &QDialogButtonBox::accepted, [&]() {
		save();
		emit accept();
		close();
	});

	connect(ui.buttonBox, &QDialogButtonBox::rejected, [&]() {
		emit reject();
		close();
	});

	show();
}

void MapInfoEditor::save() const {
	// Description Tab
	map->trigger_strings.set_string(map->info.name, ui.name->text().toStdString());
	map->trigger_strings.set_string(map->info.author, ui.author->text().toStdString());
	map->trigger_strings.set_string(map->info.description, ui.description->toPlainText().toStdString());
	map->trigger_strings.set_string(map->info.suggested_players, ui.suggestedPlayers->text().toStdString());

	if (ui.useDefaultLoadingScreen->isChecked()) {
		map->info.loading_screen_model = "";
		map->info.loading_screen_number = -1;
	} else if (ui.useImportedLoadingScreen->isChecked()) {
		map->info.loading_screen_model = ui.importedLoadingScreen->currentText().toStdString();
		map->info.loading_screen_number = -1;
	} else {
		map->info.loading_screen_model = "";
		map->info.loading_screen_number = ui.campaignLoadingScreen->currentIndex();
	}

	map->trigger_strings.set_string(map->info.loading_screen_text, ui.loadingScreenText->toPlainText().toStdString());
	map->trigger_strings.set_string(map->info.loading_screen_title, ui.loadingScreenTitle->text().toStdString());
	map->trigger_strings.set_string(map->info.loading_screen_subtitle, ui.loadingScreenSubtitle->text().toStdString());

	map->info.game_data_set = ui.gameDataSet->currentIndex();

	// Prologue?

	// Options Tab
	map->info.melee_map = ui.meleeMap->isChecked();
	map->info.hide_minimap_preview = ui.hideMinimapPreview->isChecked();
	map->info.masked_area_partially_visible = ui.maskedPartiallyVisible->isChecked();
	map->info.cliff_shore_waves = ui.cliffWaves->isChecked();
	map->info.rolling_shore_waves = ui.rollingShoreWaves->isChecked();
	map->info.item_classification = ui.itemClassification->isChecked();

	map->info.fog_style = ui.fogStyle->currentIndex();
	map->info.fog_start_z_height = ui.fogZStart->value();
	map->info.fog_end_z_height = ui.fogZEnd->value();
	map->info.fog_density = ui.fogDensity->value();
	map->info.fog_color = ui.fogColor->get_glm_color();

	// Global Weather
	if (ui.globalWeather->isChecked()) {
		map->info.weather_id = *reinterpret_cast<int*>(ui.globalWeatherCombo->currentData().toString().toStdString().data());
	} else {
		map->info.weather_id = 0;
	}

	// Custom Sound
	if (ui.customSound->isChecked()) {
		map->info.custom_sound_environment = ui.customSoundCombo->currentData().toString().toStdString();
	} else {
		map->info.custom_sound_environment = "";
	}

	// Custom Lighting
	if (!ui.customLighting->isChecked()) {
		map->info.custom_light_tileset = 0;
	} else {
		map->info.custom_light_tileset = ui.customLightingCombo->currentData().toChar().toLatin1();
	}

	map->info.water_tinting = ui.waterTinting->isChecked();
	map->info.water_color = ui.waterColor->get_glm_color();
}
```

`src/Menus/MapInfoEditor.h`:

```h
#pragma once

#include "ui_MapInfoEditor.h"

class MapInfoEditor : public QDialog {
	Q_OBJECT

public:
	MapInfoEditor(QWidget* parent = nullptr);

	Ui::MapInfoEditor ui;

	void save() const;
};
```

`src/Menus/MapInfoEditor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MapInfoEditor</class>
 <widget class="QDialog" name="MapInfoEditor">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>376</width>
    <height>527</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MapInfoEditor</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_5">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QTabWidget" name="tabs">
       <property name="currentIndex">
        <number>2</number>
       </property>
       <property name="usesScrollButtons">
        <bool>false</bool>
       </property>
       <widget class="QWidget" name="tab">
        <attribute name="title">
         <string>Description</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_2">
         <item>
          <widget class="QLabel" name="label">
           <property name="text">
            <string>Name:</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="name"/>
         </item>
         <item>
          <widget class="QLabel" name="label_2">
           <property name="text">
            <string>Suggested Players:</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="suggestedPlayers"/>
         </item>
         <item>
          <widget class="QLabel" name="label_3">
           <property name="text">
            <string>Description</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPlainTextEdit" name="description"/>
         </item>
         <item>
          <widget class="QLabel" name="label_4">
           <property name="text">
            <string>Author</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="author"/>
         </item>
         <item>
          <layout class="QHBoxLayout" name="horizontalLayout">
           <item>
            <widget class="QLabel" name="label_5">
             <property name="text">
              <string>Map Version:</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="mapVersion">
             <property name="text">
              <string/>
             </property>
            </widget>
           </item>
           <item>
            <spacer name="horizontalSpacer">
             <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
             <property name="sizeHint" stdset="0">
              <size>
               <width>40</width>
               <height>20</height>
              </size>
             </property>
            </spacer>
           </item>
           <item>
            <widget class="QLabel" name="label_6">
             <property name="text">
              <string>Editor Version:</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="editorVersion">
             <property name="text">
              <string/>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_4">
        <attribute name="title">
         <string>Loading Screen</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_4">
         <item>
          <widget class="QLabel" name="label_7">
           <property name="text">
            <string>Loading Screen Graphic</string>
           </property>
          </widget>
         </item>
         <item>
          <layout class="QFormLayout" name="formLayout_3">
           <item row="0" column="0">
            <widget class="QRadioButton" name="useDefaultLoadingScreen">
             <property name="text">
              <string>Use Default Screen</string>
             </property>
             <attribute name="buttonGroup">
              <string notr="true">loadingScreenGraphicGroup</string>
             </attribute>
            </widget>
           </item>
           <item row="1" column="0">
            <widget class="QRadioButton" name="useCampaignLoadingScreen">
             <property name="text">
              <string>Use Campaign Screen</string>
             </property>
             <attribute name="buttonGroup">
              <string notr="true">loadingScreenGraphicGroup</string>
             </attribute>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QRadioButton" name="useImportedLoadingScreen">
             <property name="text">
              <string>Use Imported File</string>
             </property>
             <attribute name="buttonGroup">
              <string notr="true">loadingScreenGraphicGroup</string>
             </attribute>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QComboBox" name="campaignLoadingScreen">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QComboBox" name="importedLoadingScreen">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QLabel" name="label_14">
           <property name="text">
            <string>Loading Screen Title</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="loadingScreenTitle"/>
         </item>
         <item>
          <widget class="QLabel" name="label_15">
           <property name="text">
            <string>Loading Screen Subtitle</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLineEdit" name="loadingScreenSubtitle"/>
         </item>
         <item>
          <widget class="QLabel" name="label_16">
           <property name="text">
            <string>Loading Screen Text</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPlainTextEdit" name="loadingScreenText"/>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_2">
        <attribute name="title">
         <string>Options</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_3">
         <item>
          <widget class="QCheckBox" name="meleeMap">
           <property name="text">
            <string>Melee Map</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="hideMinimapPreview">
           <property name="text">
            <string>Hide minimap in preview screens</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="maskedPartiallyVisible">
           <property name="text">
            <string>Masked areas are partially visible</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="cliffWaves">
           <property name="text">
            <string>Show water waves on cliff shores</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="rollingShoreWaves">
           <property name="text">
            <string>Show water waves on rolling shores</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="itemClassification">
           <property name="text">
            <string>Use item classification system</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QGroupBox" name="terrainFogBox">
           <property name="title">
            <string>Use Terrain Fog</string>
           </property>
           <property name="checkable">
            <bool>true</bool>
           </property>
           <layout class="QFormLayout" name="formLayout">
            <item row="0" column="0">
             <widget class="QLabel" name="label_8">
              <property name="text">
               <string>Style</string>
              </property>
             </widget>
            </item>
            <item row="0" column="1">
             <widget class="QComboBox" name="fogStyle">
              <item>
               <property name="text">
                <string>Linear</string>
               </property>
              </item>
              <item>
               <property name="text">
                <string>Exponential 1</string>
               </property>
              </item>
              <item>
               <property name="text">
                <string>Exponential 2</string>
               </property>
              </item>
             </widget>
            </item>
            <item row="1" column="0">
             <widget class="QLabel" name="label_9">
              <property name="text">
               <string>Z Start</string>
              </property>
             </widget>
            </item>
            <item row="1" column="1">
             <widget class="QDoubleSpinBox" name="fogZStart">
              <property name="autoFillBackground">
               <bool>true</bool>
              </property>
              <property name="frame">
               <bool>true</bool>
              </property>
              <property name="maximum">
               <double>100000.000000000000000</double>
              </property>
             </widget>
            </item>
            <item row="2" column="0">
             <widget class="QLabel" name="label_10">
              <property name="text">
               <string>Z End</string>
              </property>
             </widget>
            </item>
            <item row="2" column="1">
             <widget class="QDoubleSpinBox" name="fogZEnd">
              <property name="autoFillBackground">
               <bool>true</bool>
              </property>
              <property name="frame">
               <bool>true</bool>
              </property>
              <property name="maximum">
               <double>100000.000000000000000</double>
              </property>
             </widget>
            </item>
            <item row="3" column="0">
             <widget class="QLabel" name="label_11">
              <property name="text">
               <string>Density</string>
              </property>
             </widget>
            </item>
            <item row="3" column="1">
             <widget class="QDoubleSpinBox" name="fogDensity">
              <property name="autoFillBackground">
               <bool>true</bool>
              </property>
              <property name="frame">
               <bool>true</bool>
              </property>
              <property name="maximum">
               <double>100.000000000000000</double>
              </property>
             </widget>
            </item>
            <item row="4" column="0">
             <widget class="QLabel" name="label_12">
              <property name="text">
               <string>Color</string>
              </property>
             </widget>
            </item>
            <item row="4" column="1">
             <widget class="ColorButton" name="fogColor">
              <property name="text">
               <string>Choose Color</string>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <layout class="QFormLayout" name="formLayout_2">
           <item row="0" column="0">
            <widget class="QCheckBox" name="globalWeather">
             <property name="text">
              <string>Use Global Weather</string>
             </property>
            </widget>
           </item>
           <item row="0" column="1">
            <widget class="QComboBox" name="globalWeatherCombo">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
           <item row="1" column="0">
            <widget class="QCheckBox" name="customSound">
             <property name="text">
              <string>Custom Sound Environment</string>
             </property>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QComboBox" name="customSoundCombo">
             <property name="enabled">
              <bool>false</bool>
             </property>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QCheckBox" name="customLighting">
             <property name="text">
              <string>Custom Light Environment</string>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QComboBox" name="customLightingCombo">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="maxVisibleItems">
              <number>20</number>
             </property>
            </widget>
           </item>
           <item row="4" column="0">
            <widget class="QLabel" name="label_13">
             <property name="text">
              <string>Game Data Set:</string>
             </property>
            </widget>
           </item>
           <item row="4" column="1">
            <widget class="QComboBox" name="gameDataSet">
             <item>
              <property name="text">
               <string>Default (Map melee status)</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Custom (TFT 1.02, RoC 1.01)</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Melee (Latest Patch)</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="3" column="0">
            <widget class="QCheckBox" name="waterTinting">
             <property name="text">
              <string>Use Water Tinting Color</string>
             </property>
            </widget>
           </item>
           <item row="3" column="1">
            <widget class="ColorButton" name="waterColor">
             <property name="enabled">
              <bool>false</bool>
             </property>
             <property name="text">
              <string>Choose Color</string>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_5">
        <attribute name="title">
         <string>Preferences</string>
        </attribute>
        <widget class="QLabel" name="label_17">
         <property name="geometry">
          <rect>
           <x>160</x>
           <y>170</y>
           <width>47</width>
           <height>13</height>
          </rect>
         </property>
         <property name="text">
          <string>?</string>
         </property>
        </widget>
       </widget>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>ColorButton</class>
   <extends>QPushButton</extends>
   <header>ColorButton.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections>
  <connection>
   <sender>useImportedLoadingScreen</sender>
   <signal>toggled(bool)</signal>
   <receiver>importedLoadingScreen</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>109</x>
     <y>120</y>
    </hint>
    <hint type="destinationlabel">
     <x>168</x>
     <y>120</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>useCampaignLoadingScreen</sender>
   <signal>toggled(bool)</signal>
   <receiver>campaignLoadingScreen</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>119</x>
     <y>92</y>
    </hint>
    <hint type="destinationlabel">
     <x>179</x>
     <y>93</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>globalWeather</sender>
   <signal>toggled(bool)</signal>
   <receiver>globalWeatherCombo</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>121</x>
     <y>351</y>
    </hint>
    <hint type="destinationlabel">
     <x>242</x>
     <y>357</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>customSound</sender>
   <signal>toggled(bool)</signal>
   <receiver>customSoundCombo</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>129</x>
     <y>377</y>
    </hint>
    <hint type="destinationlabel">
     <x>225</x>
     <y>384</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>customLighting</sender>
   <signal>toggled(bool)</signal>
   <receiver>customLightingCombo</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>151</x>
     <y>408</y>
    </hint>
    <hint type="destinationlabel">
     <x>210</x>
     <y>408</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>waterTinting</sender>
   <signal>toggled(bool)</signal>
   <receiver>waterColor</receiver>
   <slot>setEnabled(bool)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>130</x>
     <y>434</y>
    </hint>
    <hint type="destinationlabel">
     <x>218</x>
     <y>435</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <buttongroups>
  <buttongroup name="loadingScreenGraphicGroup"/>
 </buttongroups>
</ui>
```

`src/Menus/Minimap.cpp`:

```cpp
#include "Minimap.h"

#include <QMouseEvent>

Minimap::Minimap(QWidget *parent) : QWidget(parent) {
	ui.setupUi(this);
	show();
}

void Minimap::set_minimap(Texture texture) {
	QImage temp_image = QImage(texture.data.data(), texture.width, texture.height, texture.width * texture.channels, QImage::Format::Format_RGBA8888);
	ui.image->setPixmap(QPixmap::fromImage(temp_image));
}

int x_offset;
int y_offset;

void Minimap::mousePressEvent(QMouseEvent* event) {
	if (event->button() == Qt::LeftButton) {
		if (event->modifiers() & Qt::ControlModifier) {
			x_offset = event->globalPosition().x() - geometry().x();
			y_offset = event->globalPosition().y() - geometry().y();
		} else {
			float x = (event->position().x() - ui.image->horizontal_border) / (width() - ui.image->horizontal_border * 2.f);
			float y = (event->position().y() - ui.image->vertical_border) / (height() - ui.image->vertical_border * 2.f);

			x = std::clamp(x, 0.f, 1.f);
			y = std::clamp(y, 0.f, 1.f);

			emit clicked({ x, y });
		}
	}
}

void Minimap::mouseReleaseEvent(QMouseEvent*) {
	setCursor(Qt::ArrowCursor);
}

void Minimap::mouseMoveEvent(QMouseEvent* event) {
	if (event->modifiers() & Qt::ControlModifier) {
		setCursor(Qt::SizeAllCursor);
	}
	if (event->buttons() & Qt::LeftButton) {
		if (event->modifiers() & Qt::ControlModifier) {
			move(event->globalPosition().x() - x_offset, event->globalPosition().y() - y_offset);
		} else if (rect().contains(event->position().toPoint())) {
			float x = (event->position().x() - ui.image->horizontal_border) / (width() - ui.image->horizontal_border * 2.f);
			float y = (event->position().y() - ui.image->vertical_border) / (height() - ui.image->vertical_border * 2.f);
			
			x = std::clamp(x, 0.f, 1.f);
			y = std::clamp(y, 0.f, 1.f);

			emit clicked({ x, y });
		}
	}
}
```

`src/Menus/Minimap.h`:

```h
#pragma once

#include "ui_Minimap.h"

import Texture;

class Minimap : public QWidget {
	Q_OBJECT

public:
	Minimap(QWidget* parent = nullptr);

public slots:
	void set_minimap(Texture texture);

signals:
	/// point contains the location clicked on the minimap in the range [0..1]
	void clicked(QPointF point);
private:
	Ui::Minimap ui;

	void mousePressEvent(QMouseEvent* event) override;
	void mouseReleaseEvent(QMouseEvent* event) override;
	void mouseMoveEvent(QMouseEvent* event) override;
};

```

`src/Menus/Minimap.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Minimap</class>
 <widget class="QWidget" name="Minimap">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>256</width>
    <height>256</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="windowTitle">
   <string>Minimap</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <property name="leftMargin">
    <number>0</number>
   </property>
   <property name="topMargin">
    <number>0</number>
   </property>
   <property name="rightMargin">
    <number>0</number>
   </property>
   <property name="bottomMargin">
    <number>0</number>
   </property>
   <item>
    <widget class="AspectRatioPixmapLabel" name="image">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="frameShape">
      <enum>QFrame::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Plain</enum>
     </property>
     <property name="text">
      <string>Image</string>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>AspectRatioPixmapLabel</class>
   <extends>QLabel</extends>
   <header>AspectRatioPixmapLabel.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`src/Menus/ObjectEditor.cpp`:

```cpp
#include "ObjectEditor.h"


#include <QTableView>
#include <QLineEdit>
#include <QToolBar>
#include <QDialogButtonBox>
#include <QSortFilterProxyModel>
#include <QPushButton>
#include <QTimer>
#include <QLabel>
#include <QShortcut>
#include <QDialog>
#include <QToolButton>
#include <QMenu>

#include "SingleModel.h"
#include "UnitSelector.h"

ObjectEditor::ObjectEditor(QWidget* parent) : QMainWindow(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);

	custom_unit_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewUnit"));
	custom_item_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewItem"));
	custom_doodad_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewDood"));
	custom_destructible_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewDest"));
	custom_ability_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewAbil"));
	custom_buff_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewBuff"));
	custom_upgrade_icon = resource_manager.load<QIconResource>(world_edit_data.data("WorldEditArt", "ToolBarIcon_OE_NewUpgr"));

	dock_manager = new ads::CDockManager;
	dock_manager->setStyleSheet("");
	setCentralWidget(dock_manager);

	QLabel* image = new QLabel();
	image->setPixmap(QPixmap("Data/Icons/ObjectEditor/background.png"));
	image->setAlignment(Qt::AlignCenter);

	auto centraldock_widget = new ads::CDockWidget("CentralWidget");
	centraldock_widget->setWidget(image);
	centraldock_widget->setFeature(ads::CDockWidget::NoTab, true);
	dock_area = dock_manager->setCentralWidget(centraldock_widget);

	unitTreeModel = new UnitTreeModel(this);
	itemTreeModel = new ItemTreeModel(this);
	doodadTreeModel = new DoodadTreeModel(this);
	destructibleTreeModel = new DestructibleTreeModel(this);
	abilityTreeModel = new AbilityTreeModel(this);
	upgradeTreeModel = new UpgradeTreeModel(this);
	buffTreeModel = new BuffTreeModel(this);

	addTypeTreeView(unitTreeModel, unitTreeFilter, units_table, unit_explorer, custom_unit_icon->icon, "Units");
	addTypeTreeView(itemTreeModel, itemTreeFilter, items_table, item_explorer, custom_item_icon->icon, "Items");
	addTypeTreeView(doodadTreeModel, doodadTreeFilter, doodads_table, doodad_explorer, custom_doodad_icon->icon, "Doodads");
	addTypeTreeView(destructibleTreeModel, destructibleTreeFilter, destructibles_table, destructible_explorer, custom_destructible_icon->icon, "Destructibles");
	addTypeTreeView(abilityTreeModel, abilityTreeFilter, abilities_table, ability_explorer, custom_ability_icon->icon, "Abilities");
	addTypeTreeView(upgradeTreeModel, upgradeTreeFilter, upgrade_table, upgrade_explorer, custom_upgrade_icon->icon, "Upgrades");
	addTypeTreeView(buffTreeModel, buffTreeFilter, buff_table, buff_explorer, custom_buff_icon->icon, "Buffs");

	explorer_area->setCurrentIndex(0);
	// Set initial sizes, the second size doesn't really matter with only 2 dock areas
	dock_manager->setSplitterSizes(explorer_area, { 645, 9999 });

	connect(unit_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(unitTreeFilter, units_table, index, Category::unit); });
	connect(item_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(itemTreeFilter, items_table, index, Category::item); });
	connect(doodad_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(doodadTreeFilter, doodads_table, index, Category::doodad); });
	connect(destructible_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(destructibleTreeFilter, destructibles_table, index, Category::destructible); });
	connect(ability_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(abilityTreeFilter, abilities_table, index, Category::ability); });
	connect(upgrade_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(upgradeTreeFilter, upgrade_table, index, Category::upgrade); });
	connect(buff_explorer, &QTreeView::doubleClicked, [&](const QModelIndex& index) { itemClicked(buffTreeFilter, buff_table, index, Category::buff); });

	connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this), &QShortcut::activated, [&]() {
		auto edit = explorer_area->currentDockWidget()->findChild<QLineEdit*>("search");
		edit->setFocus();
		edit->selectAll();
	});

	show();
}

void ObjectEditor::itemClicked(QSortFilterProxyModel* model, TableModel* table, const QModelIndex& index, Category category) {
	BaseTreeItem* item = static_cast<BaseTreeItem*>(model->mapToSource(index).internalPointer());
	if (item->baseCategory || item->subCategory) {
		return;
	}

	// If there is already one open for this item
	if (auto found = dock_manager->findDockWidget(QString::fromStdString(item->id)); found) {
		found->dockAreaWidget()->setCurrentDockWidget(found);
		found->setFocus();
		found->raise();
		return;
	}

	QTableView* view = new QTableView;
	TableDelegate* delegate = new TableDelegate;
	view->setItemDelegate(delegate);
	view->horizontalHeader()->hide();
	view->setAlternatingRowColors(true);
	view->setVerticalHeader(new AlterHeader(Qt::Vertical, view));
	view->verticalHeader()->setSectionResizeMode(QHeaderView::ResizeMode::Fixed);
	view->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeMode::Stretch);
	view->setIconSize({ 24, 24 });

	ads::CDockWidget* dock_tab = new ads::CDockWidget("");
	dock_tab->setFeature(ads::CDockWidget::DockWidgetFeature::DockWidgetDeleteOnClose, true);
	dock_tab->setWidget(view);
	dock_tab->setObjectName(QString::fromStdString(item->id));
	dock_tab->setWindowTitle(model->data(index, Qt::DisplayRole).toString());
	dock_tab->setIcon(model->data(index, Qt::DecorationRole).value<QIcon>());

	SingleModel* single_model = new SingleModel(table, this);
	single_model->setID(item->id);
	view->setModel(single_model);

	dock_manager->addDockWidget(ads::CenterDockWidgetArea, dock_tab, dock_area);
}

void ObjectEditor::addTypeTreeView(BaseTreeModel* treeModel, BaseFilter*& filter, TableModel* table, QTreeView* view, QIcon icon, QString name) {
	treeModel->setSourceModel(table);
	filter = new BaseFilter;
	filter->slk = table->slk;
	filter->setRecursiveFilteringEnabled(true);
	filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);
	filter->setSourceModel(treeModel);
	view->setModel(filter);
	view->header()->hide();
	view->setContextMenuPolicy(Qt::CustomContextMenu);
	view->setSelectionBehavior(QAbstractItemView::SelectRows);
	view->setSelectionMode(QAbstractItemView::ExtendedSelection);
	view->setUniformRowHeights(true);
	view->expandAll();

	connect(view, &QTreeView::customContextMenuRequested, [=, this](const QPoint& pos) {
		QMenu menu;
		QAction* addAction = menu.addAction("Add " + name);
		QAction* removeAction = menu.addAction("Remove " + name);

		QModelIndexList selection = view->selectionModel()->selectedIndexes();
		if (selection.empty()) {
			removeAction->setDisabled(true);
		} else {
			BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(filter->mapToSource(selection.front()).internalPointer());
			if (!table->slk->shadow_data.contains(treeItem->id) || !table->slk->shadow_data.at(treeItem->id).contains("oldid")) {
				removeAction->setDisabled(true);	
			}
		}
		
		connect(addAction, &QAction::triggered, [=, this]() {
			QDialog* selectdialog = new QDialog(this, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
			selectdialog->resize(300, 560);
			selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

			QLineEdit* nameEdit = new QLineEdit;
			nameEdit->setPlaceholderText("New name");
			nameEdit->setReadOnly(true);

			QLineEdit* id = new QLineEdit;
			id->setPlaceholderText("Free ID");
			id->setText(QString::fromStdString(map->get_unique_id(false)));
			id->setFont(QFont("consolas"));

			QHBoxLayout* nameLayout = new QHBoxLayout;
			nameLayout->addWidget(nameEdit, 3);
			nameLayout->addWidget(id, 1);

			BaseFilter* sub_filter = new BaseFilter;
			sub_filter->slk = table->slk;
			sub_filter->setRecursiveFilteringEnabled(true);
			sub_filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);
			sub_filter->setSourceModel(treeModel);

			QLineEdit* search = new QLineEdit;
			search->setPlaceholderText("Search " + name);

			QTreeView* sub_view = new QTreeView;
			sub_view->setModel(sub_filter);
			sub_view->setUniformRowHeights(true);
			sub_view->header()->hide();
			sub_view->expandAll();

			QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
			connect(buttonBox, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
			connect(buttonBox, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);

			QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);
			selectlayout->addLayout(nameLayout);
			selectlayout->addWidget(search);
			selectlayout->addWidget(sub_view);
			selectlayout->addWidget(buttonBox);

			connect(search, &QLineEdit::textChanged, [=](const QString& string) {
				sub_filter->setFilterFixedString(string);
				sub_view->expandAll();
			});

			connect(sub_view->selectionModel(), &QItemSelectionModel::currentChanged, [table, sub_filter, filter, id, nameEdit](const QModelIndex& current, const QModelIndex& previous) {
				if (!current.isValid()) {
					return;
				}
				nameEdit->setText(sub_filter->data(current).toString());
				const BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sub_filter->mapToSource(current).internalPointer());
				if (treeItem->baseCategory || treeItem->subCategory) {
					return;
				}
				id->setText(QString::fromStdString(map->get_unique_id(!islower(treeItem->id.front()))));
			});

			connect(id, &QLineEdit::textChanged, [buttonBox](const QString& text) {
				buttonBox->button(QDialogButtonBox::Ok)->setEnabled(text.size() == 4);
			});

			auto select = [view, table, sub_filter, filter, selectdialog, id, nameEdit, treeModel](const QModelIndex& index) {
				if (id->text().size() != 4) {
					return;
				}

				const BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sub_filter->mapToSource(index).internalPointer());
				if (treeItem->baseCategory || treeItem->subCategory) {
					return;
				}

				selectdialog->close();
				table->copyRow(treeItem->id, id->text().toStdString());

				QModelIndex new_index = filter->mapFromSource(treeModel->mapFromSource(table->index(table->rowCount() - 1, 0)));
				view->setCurrentIndex(new_index);
				view->scrollTo(new_index, QAbstractItemView::ScrollHint::PositionAtCenter);
			};

			connect(sub_view, &QTreeView::activated, [select](const QModelIndex& index) { select(index); });

			connect(selectdialog, &QDialog::accepted, [sub_view, select]() {
				auto indices = sub_view->selectionModel()->selectedIndexes();
				if (indices.empty()) {
					return;
				}

				select(indices.front());
			});

			connect(new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), selectdialog), &QShortcut::activated, [=]() {
				search->setFocus();
				search->selectAll();
			});

			selectdialog->show();
			search->setFocus();
		});

		connect(removeAction, &QAction::triggered, [=, this]() {
			std::vector<std::string> ids_to_delete;
			for (const auto& i : selection) {
				BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(filter->mapToSource(i).internalPointer());
				ids_to_delete.push_back(treeItem->id);

				// Close any open dock widget
				if (auto found = dock_manager->findDockWidget(QString::fromStdString(treeItem->id)); found) {
					found->closeDockWidget();
				}
			}
			for (const auto& i : ids_to_delete) {
				table->deleteRow(i);
			}
		});

		menu.exec(view->mapToGlobal(pos));
	});

	QLineEdit* search = new QLineEdit;
	search->setObjectName("search");
	search->setPlaceholderText("Search " + name);
	connect(search, &QLineEdit::textChanged, [=](const QString& string) {
		filter->setFilterFixedString(string);
		view->expandAll();
	});

	QToolButton* hideDefault = new QToolButton;
	hideDefault->setIcon(icon);
	hideDefault->setToolTip("Hide default " + name);
	hideDefault->setCheckable(true);
	connect(hideDefault, &QToolButton::toggled, [=](bool checked) {
		filter->setFilterCustom(checked);
		if (!checked) {
			view->expandAll();
		}
	});

	QToolBar* bar = new QToolBar;
	bar->addWidget(search);
	bar->addWidget(hideDefault);

	ads::CDockWidget* tab = new ads::CDockWidget(name);
	tab->setToolBar(bar);
	tab->setWidget(view);
	tab->setFeature(ads::CDockWidget::DockWidgetClosable, false);
	tab->setFeature(ads::CDockWidget::DockWidgetAlwaysCloseAndDelete, false);
	tab->setIcon(icon);
	if (explorer_area == nullptr) {
		explorer_area = dock_manager->addDockWidget(ads::LeftDockWidgetArea, tab);
	} else {
		dock_manager->addDockWidget(ads::CenterDockWidgetArea, tab, explorer_area);
	}
}

void ObjectEditor::select_id(Category category, std::string id) {
	explorer_area->setCurrentIndex(static_cast<int>(category));
	auto edit = explorer_area->currentDockWidget()->findChild<QLineEdit*>("search");
	edit->clear();

	switch (category) {
		case Category::unit: {
			auto index = unitTreeFilter->mapFromSource(unitTreeModel->getIdIndex(id));
			unit_explorer->setCurrentIndex(index);
			unit_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit unit_explorer->doubleClicked(index);
			break;
		}
		case Category::item: {
			auto index = itemTreeFilter->mapFromSource(itemTreeModel->getIdIndex(id));
			item_explorer->setCurrentIndex(index);
			item_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit item_explorer->doubleClicked(index);
			break;
		}
		case Category::doodad: {
			auto index = doodadTreeFilter->mapFromSource(doodadTreeModel->getIdIndex(id));
			doodad_explorer->setCurrentIndex(index);
			doodad_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit doodad_explorer->doubleClicked(index);
			break;
		}
		case Category::destructible: {
			auto index = destructibleTreeFilter->mapFromSource(destructibleTreeModel->getIdIndex(id));
			destructible_explorer->setCurrentIndex(index);
			destructible_explorer->scrollTo(index, QAbstractItemView::PositionAtCenter);
			emit destructible_explorer->doubleClicked(index);
			break;
		}
		case Category::ability: {
			auto index = abilityTreeFilter->mapFromSource(abilityTreeModel->getIdIndex(id));
			ability_explorer->setCurrentIndex(index);
			ability_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit ability_explorer->doubleClicked(index);
			break;
		}
		case Category::upgrade: {
			auto index = upgradeTreeFilter->mapFromSource(upgradeTreeModel->getIdIndex(id));
			upgrade_explorer->setCurrentIndex(index);
			upgrade_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit upgrade_explorer->doubleClicked(index);
			break;
		}
		case Category::buff: {
			auto index = buffTreeFilter->mapFromSource(buffTreeModel->getIdIndex(id));
			buff_explorer->setCurrentIndex(index);
			buff_explorer->scrollTo(index, QAbstractItemView::ScrollHint::PositionAtCenter);
			emit buff_explorer->doubleClicked(index);
			break;
		}
	}
}
```

`src/Menus/ObjectEditor.h`:

```h
#pragma once

#include <QMainWindow>

#include "ui_ObjectEditor.h"

#include "TableModel.h"
#include "UnitTreeModel.h"
#include "DoodadTreeModel.h"
#include "DestructibleTreeModel.h"
#include "AbilityTreeModel.h"
#include "ItemTreeModel.h"
#include "BuffTreeModel.h"
#include "UpgradeTreeModel.h"
#include "DockManager.h"
#include "DockAreaWidget.h"
#include <QTreeView>

class ObjectEditor : public QMainWindow {
	Q_OBJECT

public:
	ObjectEditor(QWidget* parent = nullptr);

	enum class Category {
		unit,
		item,
		doodad,
		destructible,
		ability,
		upgrade,
		buff
	};

	void select_id(Category category, std::string id);

private:
	Ui::ObjectEditor ui;

	ads::CDockManager* dock_manager;
	ads::CDockAreaWidget* dock_area = nullptr;
	ads::CDockAreaWidget* explorer_area = nullptr;

	QTreeView* unit_explorer = new QTreeView;
	QTreeView* doodad_explorer = new QTreeView;
	QTreeView* item_explorer = new QTreeView;
	QTreeView* destructible_explorer = new QTreeView;
	QTreeView* ability_explorer = new QTreeView;
	QTreeView* upgrade_explorer = new QTreeView;
	QTreeView* buff_explorer = new QTreeView;
	
	UnitTreeModel* unitTreeModel;
	DoodadTreeModel* doodadTreeModel;
	DestructibleTreeModel* destructibleTreeModel;
	AbilityTreeModel* abilityTreeModel;
	ItemTreeModel* itemTreeModel;
	BuffTreeModel* buffTreeModel;
	UpgradeTreeModel* upgradeTreeModel;

	BaseFilter* unitTreeFilter;
	BaseFilter* doodadTreeFilter;
	BaseFilter* destructibleTreeFilter;
	BaseFilter* abilityTreeFilter;
	BaseFilter* itemTreeFilter;
	BaseFilter* buffTreeFilter;
	BaseFilter* upgradeTreeFilter;

	std::shared_ptr<QIconResource> custom_unit_icon;
	std::shared_ptr<QIconResource> custom_item_icon;
	std::shared_ptr<QIconResource> custom_doodad_icon;
	std::shared_ptr<QIconResource> custom_destructible_icon;
	std::shared_ptr<QIconResource> custom_ability_icon;
	std::shared_ptr<QIconResource> custom_buff_icon;
	std::shared_ptr<QIconResource> custom_upgrade_icon;

	void itemClicked(QSortFilterProxyModel* model, TableModel* table, const QModelIndex& index, Category category);
	void addTypeTreeView(BaseTreeModel* treeModel, BaseFilter*& filter, TableModel* table, QTreeView* view, QIcon icon, QString name);
};
```

`src/Menus/ObjectEditor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ObjectEditor</class>
 <widget class="QMainWindow" name="ObjectEditor">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1338</width>
    <height>804</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Object Editor</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QHBoxLayout" name="horizontalLayout"/>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`src/Menus/Palette.cpp`:

```cpp
#include "Palette.h"

Palette::Palette(QWidget* parent) : QDialog(parent) {
}

Palette::~Palette()
{
}

//void Palette::addShortcut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to) {
//	for (auto&& i : attach_to) {
//		shortcuts.push_back(new QShortcut(sequence, i));
//	}
//}
```

`src/Menus/Palette.h`:

```h
#pragma once

#include <QDialog>

#include "QRibbon.h"

/// Palette is the base for all other palette kinds and facilitates things like brush switching and shortcut management
class Palette : public QDialog {
	Q_OBJECT

public:
	Palette(QWidget* parent = nullptr);
	~Palette();

	std::vector<QShortcut*> shortcuts;

	//void addShortcut(const QKeySequence sequence, const std::vector<QWidget*>& attach_to);

signals:
	void ribbon_tab_requested(QRibbonTab* tab, QString name);

public slots:
	virtual void deactivate(QRibbonTab* tab) = 0;
};

```

`src/Menus/PathingPalette.cpp`:

```cpp
#include "PathingPalette.h"

#include <QDialog>
#include "Globals.h"

PathingPalette::PathingPalette(QWidget *parent) : Palette(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	map->brush = &brush;

	connect(ui.replaceType, &QPushButton::clicked, [&]() { brush.operation = PathingBrush::Operation::replace; });
	connect(ui.addType, &QPushButton::clicked, [&]() { brush.operation = PathingBrush::Operation::add; });
	connect(ui.removeType, &QPushButton::clicked, [&]() { brush.operation = PathingBrush::Operation::remove; });

	connect(ui.brushTypeGroup, &QButtonGroup::buttonToggled, [&]() {
		brush.brush_mask = 0;

		if (ui.walkable->isChecked()) {
			brush.brush_mask |= 0b00000010;
		}
		if (ui.flyable->isChecked()) {
			brush.brush_mask |= 0b00000100;
		}
		if (ui.buildable->isChecked()) {
			brush.brush_mask |= 0b00001000;
		}
	});

	connect(ui.brushSizeGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) { 
		brush.set_size(button->text().toInt()); 
		ui.brushSize->setValue(button->text().toInt());
	});

	connect(ui.brushSizeSlider, &QSlider::valueChanged, [&](int value) { brush.set_size(value); });

	connect(ui.brushShapeCircle, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::circle); });
	connect(ui.brushShapeSquare, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::square); });
	connect(ui.brushShapeDiamond, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::diamond); });
}

PathingPalette::~PathingPalette() {
	map->brush = nullptr;
}

bool PathingPalette::event(QEvent *e) {
	if (e->type() == QEvent::WindowActivate) {
		map->brush = &brush;
	}
	return QWidget::event(e);
}

void PathingPalette::deactivate(QRibbonTab* tab) {
	//if (tab != ribbon_tab) {
	//	brush.clear_selection();
	//}
}
```

`src/Menus/PathingPalette.h`:

```h
#pragma once

#include <QDialog>

#include "ui_PathingPalette.h"
#include "PathingBrush.h"

#include "Palette.h"

class PathingPalette : public Palette {
	Q_OBJECT

public:
	explicit PathingPalette(QWidget* parent = nullptr);
	~PathingPalette();

private:
	bool event(QEvent *e) override;

	Ui::PathingPalette ui;
	PathingBrush brush;

public slots:
	void deactivate(QRibbonTab* tab) override;
};
```

`src/Menus/PathingPalette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>PathingPalette</class>
 <widget class="QWidget" name="PathingPalette">
  <property name="windowModality">
   <enum>Qt::NonModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>242</width>
    <height>265</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pathing Pallete</string>
  </property>
  <property name="windowOpacity">
   <double>1.000000000000000</double>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="brushOperationLabel">
     <property name="toolTip">
      <string>The type of operation the brush will apply.</string>
     </property>
     <property name="text">
      <string>Brush Operation Type</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="ToolTypeLayout">
     <item>
      <widget class="QRadioButton" name="replaceType">
       <property name="toolTip">
        <string>Replaces the existing pathing when the brush is used.</string>
       </property>
       <property name="text">
        <string>Replace</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">toolTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QRadioButton" name="addType">
       <property name="toolTip">
        <string>Adds to the existing pathing any brush types that are selected.</string>
       </property>
       <property name="text">
        <string>Add</string>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">toolTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QRadioButton" name="removeType">
       <property name="toolTip">
        <string>Removes from the existing pathing all the brush types selected.</string>
       </property>
       <property name="text">
        <string>Remove</string>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">toolTypeGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="brushTypeLabel">
     <property name="toolTip">
      <string>Which pathing type will be applied by the brush.</string>
     </property>
     <property name="text">
      <string>Brush Type</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="walkable">
       <property name="toolTip">
        <string>Whether the brush will apply unwalkable.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/walkable.png</normaloff>Data/Icons/walkable.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="flyable">
       <property name="toolTip">
        <string>Whether the brush will apply unflyable.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/flyable.png</normaloff>Data/Icons/flyable.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushTypeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="buildable">
       <property name="toolTip">
        <string>Whether the brush will aply unbuildable</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/buildable.png</normaloff>Data/Icons/buildable.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushTypeGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="brushSizeLabel">
     <property name="toolTip">
      <string>The brush size that will be applied on the terrain. The final dimensions are: (size-1)*2+1 x (size-1)*2+1.</string>
     </property>
     <property name="text">
      <string>Brush</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QPushButton" name="brushSize1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 1x1.</string>
       </property>
       <property name="text">
        <string>1</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize3">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 3x3.</string>
       </property>
       <property name="text">
        <string>3</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize5">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 5x5.</string>
       </property>
       <property name="text">
        <string>5</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize7">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 7x7.</string>
       </property>
       <property name="text">
        <string>7</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize9">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 9x9.</string>
       </property>
       <property name="text">
        <string>9</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize11">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 11x11.</string>
       </property>
       <property name="text">
        <string>11</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <widget class="QSpinBox" name="brushSize">
       <property name="toolTip">
        <string>The current brush size</string>
       </property>
       <property name="readOnly">
        <bool>true</bool>
       </property>
       <property name="buttonSymbols">
        <enum>QAbstractSpinBox::NoButtons</enum>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>241</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="value">
        <number>1</number>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QSlider" name="brushSizeSlider">
       <property name="toolTip">
        <string>Sets the brush size.</string>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>128</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="invertedAppearance">
        <bool>false</bool>
       </property>
       <property name="invertedControls">
        <bool>false</bool>
       </property>
       <property name="tickPosition">
        <enum>QSlider::TicksBelow</enum>
       </property>
       <property name="tickInterval">
        <number>0</number>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="brushShapeLayout">
     <item>
      <widget class="QPushButton" name="brushShapeCircle">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Brush/circle.png</normaloff>Data/Icons/Brush/circle.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeSquare">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Brush/square.png</normaloff>Data/Icons/Brush/square.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeDiamond">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Brush/diamond.png</normaloff>Data/Icons/Brush/diamond.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <tabstops>
  <tabstop>replaceType</tabstop>
  <tabstop>addType</tabstop>
  <tabstop>removeType</tabstop>
  <tabstop>walkable</tabstop>
  <tabstop>flyable</tabstop>
  <tabstop>buildable</tabstop>
  <tabstop>brushSize1</tabstop>
  <tabstop>brushSize3</tabstop>
  <tabstop>brushSize5</tabstop>
  <tabstop>brushSize7</tabstop>
  <tabstop>brushSize9</tabstop>
  <tabstop>brushSize11</tabstop>
  <tabstop>brushSize</tabstop>
  <tabstop>brushSizeSlider</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>brushSizeSlider</sender>
   <signal>valueChanged(int)</signal>
   <receiver>brushSize</receiver>
   <slot>setValue(int)</slot>
   <hints>
    <hint type="sourcelabel">
     <x>65</x>
     <y>191</y>
    </hint>
    <hint type="destinationlabel">
     <x>32</x>
     <y>193</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <buttongroups>
  <buttongroup name="brushSizeGroup"/>
  <buttongroup name="brushTypeGroup">
   <property name="exclusive">
    <bool>false</bool>
   </property>
  </buttongroup>
  <buttongroup name="toolTypeGroup"/>
  <buttongroup name="brushShapeGroup"/>
 </buttongroups>
</ui>

```

`src/Menus/Selections.cpp`:

```cpp
#include "Selections.h"

Selections::Selections(QWidget* parent) : QDialog(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);
	show();


}

Selections::~Selections() {

}
```

`src/Menus/Selections.h`:

```h
#pragma once

#include "ui_Selections.h"

class Selections : public QDialog {
	Q_OBJECT

public:
	Selections(QWidget* parent = nullptr);
	~Selections();

private:

	Ui::Selections ui;
};
```

`src/Menus/Selections.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Selections</class>
 <widget class="QDialog" name="Selections">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>244</width>
    <height>553</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Selections</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QListWidget" name="selections">
     <property name="uniformItemSizes">
      <bool>true</bool>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/Menus/SettingsEditor.cpp`:

```cpp
#include "SettingsEditor.h"

#include <QSettings>
#include <QFile>


void setTestArgs(Ui::SettingsEditor &ui) {
	ui.testArgs->setText(ui.userArgs->text() + " -mapdiff " + QString::fromStdString(std::string("") + char(ui.diff->currentIndex() + '0')) +
						(ui.windowmode->currentText() != "Default" ? " -windowmode " + QString([](int x) {
		switch (x) { case 1: return "windowed"; case 2: return "windowedfullscreen"; default: return "fullscreen";} }(ui.windowmode->currentIndex())) : "") +
						(ui.testhd->currentText() != "Default" ? " -hd " + QString([](int x) {
		switch (x) { case 1: return "1"; default: return "0";} }(ui.testhd->currentIndex())) : "") +
						(ui.testteen->currentText() != "Default" ? " -teen " + QString([](int x) {
		switch (x) { case 1: return "1"; default: return "0"; } }(ui.testteen->currentIndex())) : "") +
						" -testmapprofile " + ui.profile->text() + " -fixedseed " + (ui.fixedseed->isChecked() ? "1" : "0") + (ui.nowfpause->isChecked() ? " -nowfpause" : ""));
};

SettingsEditor::SettingsEditor(QWidget* parent)
	: QDialog(parent) {
	ui.setupUi(this);
	QSettings settings;
	ui.theme->setCurrentText(settings.value("theme", "Dark").toString());
	ui.comments->setChecked(settings.value("comments", "True").toString() != "False");
	ui.flavour->setCurrentText(settings.value("flavour").toString());
	ui.hd->setChecked(settings.value("hd", "True").toString() != "False");
	ui.teen->setChecked(settings.value("teen", "False").toString() != "False");

	ui.userArgs->setText(settings.value("userArgs", "").toString());
	ui.diff->setCurrentText(settings.value("diff", "Normal").toString());
	ui.windowmode->setCurrentText(settings.value("windowmode", "Default").toString());
	ui.testhd->setCurrentText(settings.value("testhd", "Default").toString());
	ui.testteen->setCurrentText(settings.value("testteen", "Default").toString());
	ui.profile->setText(settings.value("profile", "HiveWE").toString());
	ui.fixedseed->setChecked(settings.value("fixedseed", "True").toString() != "False");
	ui.nowfpause->setChecked(settings.value("nowfpause", "True").toString() != "False");

	connect(ui.userArgs, &QLineEdit::textChanged, [&]() { setTestArgs(ui); });
	connect(ui.diff, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.windowmode, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.testhd, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.testteen, &QComboBox::currentTextChanged, [&]() { setTestArgs(ui); });
	connect(ui.profile, &QLineEdit::textChanged, [&]() { setTestArgs(ui); });
	connect(ui.fixedseed, &QCheckBox::stateChanged, [&]() { setTestArgs(ui); });
	connect(ui.nowfpause, &QCheckBox::stateChanged, [&]() { setTestArgs(ui); });
	emit ui.nowfpause->stateChanged(0);


	connect(ui.buttonBox, &QDialogButtonBox::accepted, [&]() {
		save();
		QSettings settings;
		QFile file("Data/Themes/" + settings.value("theme").toString() + ".qss");
		file.open(QFile::ReadOnly);
		QString StyleSheet = QLatin1String(file.readAll());

		qApp->setStyleSheet(StyleSheet);
		emit accept();
		close();
	});

	connect(ui.buttonBox, &QDialogButtonBox::rejected, [&]() {
		emit reject();
		close();
	});
	show();
}

void SettingsEditor::save() const {
	QSettings settings;
	settings.setValue("theme", ui.theme->currentText());
	settings.setValue("flavour", ui.flavour->currentText());
	settings.setValue("comments", ui.comments->isChecked() ? "True" : "False");
	settings.setValue("hd", ui.hd->isChecked() ? "True" : "False");
	settings.setValue("teen", ui.teen->isChecked() ? "True" : "False");
	settings.setValue("userArgs", ui.userArgs->text());
	settings.setValue("diff", ui.diff->currentText());
	settings.setValue("windowmode", ui.windowmode->currentText());
	settings.setValue("testhd", ui.testhd->currentText());
	settings.setValue("testteen", ui.testteen->currentText());
	settings.setValue("profile", ui.profile->text());
	settings.setValue("fixedseed", ui.fixedseed->isChecked() ? "True" : "False");
	settings.setValue("nowfpause", ui.nowfpause->isChecked() ? "True" : "False");
	settings.setValue("testArgs", ui.testArgs->text());
}
```

`src/Menus/SettingsEditor.h`:

```h
#pragma once

#include "ui_SettingsEditor.h"

class SettingsEditor : public QDialog {
	Q_OBJECT

public:
	explicit SettingsEditor(QWidget* parent = nullptr);
private:
	Ui::SettingsEditor ui;
	void save() const;
};
```

`src/Menus/SettingsEditor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SettingsEditor</class>
 <widget class="QDialog" name="SettingsEditor">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>730</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Settings</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_1">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QTabWidget" name="tabs">
       <property name="currentIndex">
        <number>0</number>
       </property>
       <property name="usesScrollButtons">
        <bool>false</bool>
       </property>
       <widget class="QWidget" name="tab">
        <attribute name="title">
         <string>General</string>
        </attribute>
        <layout class="QFormLayout" name="formLayout_2">
         <item row="0" column="0">
          <widget class="QLabel" name="themeLabel">
           <property name="text">
            <string>Theme</string>
           </property>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QComboBox" name="theme">
           <item>
            <property name="text">
             <string>Light</string>
            </property>
           </item>
           <item>
            <property name="text">
             <string>Dark</string>
            </property>
           </item>
          </widget>
         </item>
         <item row="1" column="0">
          <widget class="QLabel" name="typeLabel">
           <property name="text">
            <string>Game Data</string>
           </property>
          </widget>
         </item>
         <item row="1" column="1">
          <widget class="QComboBox" name="flavour">
           <item>
            <property name="text">
             <string>Retail</string>
            </property>
           </item>
           <item>
            <property name="text">
             <string>PTR</string>
            </property>
           </item>
          </widget>
         </item>
         <item row="2" column="1">
          <widget class="QCheckBox" name="hd">
           <property name="text">
            <string>Enable HD Mode (requires restart)</string>
           </property>
           <property name="checked">
            <bool>true</bool>
           </property>
          </widget>
         </item>
         <item row="3" column="1">
          <widget class="QCheckBox" name="teen">
           <property name="text">
            <string>Enable Teen Mode</string>
           </property>
          </widget>
         </item>
         <item row="4" column="1">
           <widget class="QCheckBox" name="comments">
             <property name="text">
               <string>Enable Comments</string>
             </property>
             <property name="checked">
               <bool>true</bool>
             </property>
           </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_1">
        <attribute name="title">
         <string>Testing</string>
        </attribute>
        <layout class="QFormLayout" name="formLayout">
         <property name="labelAlignment">
          <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
         </property>
         <property name="verticalSpacing">
          <number>6</number>
         </property>
         <item row="0" column="0" colspan="2">
          <layout class="QFormLayout" name="formLayout_4">
           <property name="labelAlignment">
            <set>Qt::AlignHCenter|Qt::AlignTop</set>
           </property>
           <property name="horizontalSpacing">
            <number>6</number>
           </property>
           <property name="verticalSpacing">
            <number>0</number>
           </property>
           <item row="0" column="0">
            <widget class="QLabel" name="label">
             <property name="text">
              <string>Arguments:</string>
             </property>
            </widget>
           </item>
           <item row="0" column="1">
            <widget class="QLineEdit" name="userArgs"/>
           </item>
           <item row="1" column="0">
            <widget class="QLabel" name="label_9">
             <property name="text">
              <string>Difficulty</string>
             </property>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QComboBox" name="diff">
             <property name="currentText">
              <string>Normal</string>
             </property>
             <item>
              <property name="text">
               <string>Easy</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Normal</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Hard</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QLabel" name="label_8">
             <property name="text">
              <string>Window Mode</string>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QComboBox" name="windowmode">
             <item>
              <property name="text">
               <string>Default</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Windowed</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Windowed Fullscreen</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Fullscreen</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="3" column="0">
            <widget class="QLabel" name="label_10">
             <property name="text">
              <string>Asset Mode</string>
             </property>
            </widget>
           </item>
           <item row="3" column="1">
            <widget class="QComboBox" name="testhd">
             <item>
              <property name="text">
               <string>Default</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>HD</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>SD</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="4" column="0">
            <widget class="QLabel" name="label_11">
             <property name="text">
              <string>Teen Mode</string>
             </property>
            </widget>
           </item>
           <item row="4" column="1">
            <widget class="QComboBox" name="testteen">
             <item>
              <property name="text">
               <string>Default</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>On</string>
              </property>
             </item>
             <item>
              <property name="text">
               <string>Off</string>
              </property>
             </item>
            </widget>
           </item>
           <item row="5" column="0">
            <widget class="QLabel" name="label_12">
             <property name="text">
              <string>Profile Name</string>
             </property>
            </widget>
           </item>
           <item row="5" column="1">
            <widget class="QLineEdit" name="profile">
             <property name="text">
              <string>HiveWE</string>
             </property>
            </widget>
           </item>
           <item row="6" column="1">
            <widget class="QCheckBox" name="fixedseed">
             <property name="text">
              <string>Fixed random Seed</string>
             </property>
             <property name="checked">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item row="7" column="1">
            <widget class="QCheckBox" name="nowfpause">
             <property name="text">
              <string>No Windows Focus Pause</string>
             </property>
             <property name="checked">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item row="8" column="0">
            <widget class="QLabel" name="label_7">
             <property name="text">
              <string>Final arguments:</string>
             </property>
            </widget>
           </item>
           <item row="8" column="1">
            <widget class="QLineEdit" name="testArgs">
             <property name="readOnly">
              <bool>true</bool>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="tab_2">
        <attribute name="title">
         <string>Script</string>
        </attribute>
        <layout class="QVBoxLayout" name="verticalLayout_4">
         <item>
          <widget class="QGroupBox" name="groupBox_2">
           <property name="title">
            <string>Generate map script</string>
           </property>
           <property name="checkable">
            <bool>true</bool>
           </property>
           <layout class="QVBoxLayout" name="verticalLayout_2">
            <item>
             <widget class="QLabel" name="label_6">
              <property name="sizePolicy">
               <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                <horstretch>0</horstretch>
                <verstretch>0</verstretch>
               </sizepolicy>
              </property>
              <property name="text">
               <string>Map script generation implies converting all GUI triggers to JASS and appending the text from all custom triggers.</string>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QCheckBox" name="checkBox_2">
              <property name="text">
               <string>Run VJass preprocessor</string>
              </property>
              <property name="checked">
               <bool>true</bool>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <widget class="QGroupBox" name="groupBox">
           <property name="title">
            <string>Custom Tool</string>
           </property>
           <property name="checkable">
            <bool>true</bool>
           </property>
           <property name="checked">
            <bool>false</bool>
           </property>
           <layout class="QVBoxLayout" name="verticalLayout_3">
            <item>
             <layout class="QFormLayout" name="formLayout_3">
              <item row="0" column="0">
               <widget class="QLabel" name="label_2">
                <property name="text">
                 <string>Executable</string>
                </property>
               </widget>
              </item>
              <item row="1" column="0">
               <widget class="QLabel" name="label_3">
                <property name="text">
                 <string>Arguments</string>
                </property>
               </widget>
              </item>
              <item row="2" column="0">
               <widget class="QLabel" name="label_4">
                <property name="text">
                 <string>Working Directory</string>
                </property>
               </widget>
              </item>
              <item row="0" column="1">
               <layout class="QHBoxLayout" name="horizontalLayout_2">
                <item>
                 <widget class="QLineEdit" name="lineEdit_2"/>
                </item>
                <item>
                 <widget class="QToolButton" name="toolButton_2">
                  <property name="sizePolicy">
                   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                    <horstretch>0</horstretch>
                    <verstretch>0</verstretch>
                   </sizepolicy>
                  </property>
                  <property name="text">
                   <string>...</string>
                  </property>
                 </widget>
                </item>
               </layout>
              </item>
              <item row="2" column="1">
               <layout class="QHBoxLayout" name="horizontalLayout_4">
                <item>
                 <widget class="QLineEdit" name="lineEdit_4"/>
                </item>
                <item>
                 <widget class="QToolButton" name="toolButton_4">
                  <property name="sizePolicy">
                   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                    <horstretch>0</horstretch>
                    <verstretch>0</verstretch>
                   </sizepolicy>
                  </property>
                  <property name="text">
                   <string>...</string>
                  </property>
                 </widget>
                </item>
               </layout>
              </item>
              <item row="1" column="1">
               <widget class="QLineEdit" name="lineEdit_5"/>
              </item>
             </layout>
            </item>
            <item>
             <widget class="QLabel" name="label_5">
              <property name="text">
               <string>HiveWE exposes the following variables:
$hivewe_path - The absolute path to the HiveWE exe
$map_path - The absolute path to the map directory</string>
              </property>
             </widget>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <spacer name="verticalSpacer">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>20</width>
             <height>194</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </widget>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/Menus/TerrainPalette.cpp`:

```cpp
#include "TerrainPalette.h"

#include "Globals.h"

TerrainPalette::TerrainPalette(QWidget *parent) : Palette(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	brush.tile_id = map->terrain.tileset_ids.front();
	map->brush = &brush;

	ui.flowLayout_placeholder->addLayout(textures_layout);
	ui.flowLayout_placeholder_2->addLayout(cliff_layout);

	// Ground Tiles
	slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : map->terrain.tileset_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "/" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(48, 48);
		button->setIconSize({ 48, 48 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromStdString(slk.data("comment", i)));

		textures_layout->addWidget(button);
		textures_group->addButton(button);

		auto& cliff_tiles = map->terrain.cliff_to_ground_texture;
		const auto is_cliff_tile = std::find(cliff_tiles.begin(), cliff_tiles.end(), map->terrain.ground_texture_to_id[i]);

		if (is_cliff_tile != cliff_tiles.end()) {
			const int index = std::distance(cliff_tiles.begin(), is_cliff_tile);

			button = new QPushButton;
			button->setIcon(icon);
			button->setFixedSize(48, 48);
			button->setIconSize({ 48, 48 });
			button->setCheckable(true); 
			button->setProperty("cliffID", QString::number(index));
			button->setProperty("tileName", QString::fromStdString(slk.data("comment", i)));

			cliff_layout->addWidget(button);
			cliff_group->addButton(button);
		}
	}

	// Blight texture
	const auto image = resource_manager.load<Texture>("TerrainArt/Blight/Ashen_Blight.dds");
	const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

	ui.blight->setIcon(icon);
	ui.blight->setFixedSize(48, 48);
	ui.blight->setIconSize({ 48, 48 });
	ui.blight->setCheckable(true);
	ui.blight->setProperty("tileID", "blight");
	ui.blight->setProperty("tileName", "Blight");
	textures_group->addButton(ui.blight);

	// Ribbon
	QRibbonSection* general_section = new QRibbonSection;
	general_section->setText("General");

	QRibbonButton* enforce_water_height_limit = new QRibbonButton;
	enforce_water_height_limit->setText("Enforce Water\nHeight Limit");
	enforce_water_height_limit->setIcon(QIcon("Data/Icons/Ribbon/variation32x32.png"));
	enforce_water_height_limit->setCheckable(true);
	enforce_water_height_limit->setChecked(true);
	general_section->addWidget(enforce_water_height_limit);

	QRibbonButton* change_doodad_heights = new QRibbonButton;
	change_doodad_heights->setText("Update\nDoodad Z");
	change_doodad_heights->setIcon(QIcon("Data/Icons/Ribbon/changeheight32x32.png"));
	change_doodad_heights->setCheckable(true);
	change_doodad_heights->setChecked(true);
	general_section->addWidget(change_doodad_heights);

	QRibbonSection* cliff_section = new QRibbonSection;
	cliff_section->setText("Cliff");

	QRibbonButton* relative_cliff_heights = new QRibbonButton;
	relative_cliff_heights->setText("Relative\nHeight");
	relative_cliff_heights->setIcon(QIcon("Data/Icons/Ribbon/changeheight32x32.png"));
	relative_cliff_heights->setCheckable(true);
	relative_cliff_heights->setChecked(false);
	relative_cliff_heights->setEnabled(false);
	cliff_section->addWidget(relative_cliff_heights);

	QRibbonSection* pathing_section = new QRibbonSection;
	pathing_section->setText("Pathing");

	QRibbonButton* apply_cliff_pathing = new QRibbonButton;
	apply_cliff_pathing->setText("Cliff\nPathing");
	apply_cliff_pathing->setIcon(QIcon("Data/Icons/Ribbon/rock32x32.png"));
	apply_cliff_pathing->setCheckable(true);
	apply_cliff_pathing->setChecked(true);
	pathing_section->addWidget(apply_cliff_pathing);

	QRibbonButton* apply_tile_pathing = new QRibbonButton;
	apply_tile_pathing->setText("Tile\nPathing");
	apply_tile_pathing->setIcon(QIcon("Data/Icons/Ribbon/tileset32x32.png"));
	apply_tile_pathing->setCheckable(true);
	apply_tile_pathing->setChecked(true);
	pathing_section->addWidget(apply_tile_pathing);

	QRibbonButton* apply_water_pathing = new QRibbonButton;
	apply_water_pathing->setText("Water\nPathing");
	apply_water_pathing->setIcon(QIcon("Data/Icons/Ribbon/water32x32.png"));
	apply_water_pathing->setCheckable(true);
	apply_water_pathing->setChecked(true);
	pathing_section->addWidget(apply_water_pathing);

	ribbon_tab->addSection(general_section);
	ribbon_tab->addSection(cliff_section);
	ribbon_tab->addSection(pathing_section);

	connect(enforce_water_height_limit, &QRibbonButton::toggled, [&](bool checked) { brush.enforce_water_height_limits = checked; });
	connect(change_doodad_heights, &QRibbonButton::toggled, [&](bool checked) { brush.change_doodad_heights = checked; });
	connect(relative_cliff_heights, &QRibbonButton::toggled, [&](bool checked) { brush.relative_cliff_heights = checked; });

	connect(enforce_water_height_limit, &QRibbonButton::toggled, [&](bool checked) { brush.enforce_water_height_limits = checked; });

	connect(apply_cliff_pathing, &QRibbonButton::toggled, [&](bool checked) { brush.apply_cliff_pathing = checked; });
	connect(apply_tile_pathing, &QRibbonButton::toggled, [&](bool checked) { brush.apply_tile_pathing = checked; });
	connect(apply_water_pathing, &QRibbonButton::toggled, [&](bool checked) { brush.apply_water_pathing	= checked; });

	connect(ui.brushSizeButtonGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		ui.brushSizeSlider->setValue(button->text().toInt());
	});
	connect(ui.brushSizeSlider, &QSlider::valueChanged, [&](int value) {
		brush.set_size(value);
		ui.brushSize->setValue(value);
	});
	
	connect(ui.textureCheckbox, &QCheckBox::clicked, [&](bool checked) { brush.apply_texture = checked; });
	connect(ui.cliffCheckbox, &QCheckBox::clicked, [&](bool checked) { brush.apply_cliff = checked; });
	connect(ui.deformationCheckbox, &QCheckBox::clicked, [&](bool checked) { brush.apply_height = checked; });

	connect(textures_group, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		brush.tile_id = button->property("tileID").toString().toStdString();
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(false);
		ui.textureCheckbox->setChecked(true);
		brush.apply_cliff = false;
		brush.apply_height = false;
		brush.apply_texture = true;
	});

	connect(cliff_group, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		brush.cliff_id = button->property("cliffID").toInt();
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(true);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = true;
		brush.apply_height = false;
		brush.apply_texture = false;
	});

	connect(ui.cliffButtonGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&]() {
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(true);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = true;
		brush.apply_height = false;
		brush.apply_texture = false;
	});

	connect(cliff_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), [&]() {
		ui.deformationCheckbox->setChecked(false);
		ui.cliffCheckbox->setChecked(true);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = true;
		brush.apply_height = false;
		brush.apply_texture = false;
	});

	connect(ui.deformationButtonGroup, QOverload<QAbstractButton *>::of(&QButtonGroup::buttonClicked), [&]() {
		ui.deformationCheckbox->setChecked(true);
		ui.cliffCheckbox->setChecked(false);
		ui.textureCheckbox->setChecked(false);
		brush.apply_cliff = false;
		brush.apply_height = true;
		brush.apply_texture = false;
	});

	connect(ui.terrainRaise, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::raise; });
	connect(ui.terrainLower, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::lower; });
	connect(ui.terrainPlateau, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::plateau; });
	connect(ui.terrainRipple, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::ripple; });
	connect(ui.terrainSmooth, &QPushButton::clicked, [&]() { brush.deformation_type = TerrainBrush::deformation::smooth; });

	connect(ui.cliffLower2, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::lower2; });
	connect(ui.cliffLower1, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::lower1; });
	connect(ui.cliffLevel, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::level; });
	connect(ui.cliffRaise1, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::raise1; });
	connect(ui.cliffRaise2, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::raise2; });
	connect(ui.cliffDeepWater, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::deep_water; });
	connect(ui.cliffShallowWater, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::shallow_water; });
	connect(ui.cliffRamp, &QPushButton::clicked, [&]() { brush.cliff_operation_type = TerrainBrush::cliff_operation::ramp; });

	connect(ui.brushShapeCircle, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::circle); });
	connect(ui.brushShapeSquare, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::square); });
	connect(ui.brushShapeDiamond, &QPushButton::clicked, [&]() { brush.set_shape(Brush::Shape::diamond); });
}

TerrainPalette::~TerrainPalette() {
	map->brush = nullptr;
}

bool TerrainPalette::event(QEvent *e) {
	if (e->type() == QEvent::WindowActivate) {
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Terrain Palette");
	}
	return QWidget::event(e);
}

void TerrainPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
	}
}
```

`src/Menus/TerrainPalette.h`:

```h
#pragma once

#include "ui_TerrainPalette.h"

#include <QDialog>
#include "FlowLayout.h"

#include "Palette.h"
#include "TerrainBrush.h"
#include "QRibbon.h"

class TerrainPalette : public Palette {
	Q_OBJECT

public:
	TerrainPalette(QWidget* parent = nullptr);
	~TerrainPalette();

private:
	bool event(QEvent *e) override;

	Ui::TerrainPalette ui;
	QButtonGroup* textures_group = new QButtonGroup;
	FlowLayout* textures_layout = new FlowLayout;

	QButtonGroup* cliff_group = new QButtonGroup;
	FlowLayout* cliff_layout = new FlowLayout;

	TerrainBrush brush;
	QRibbonTab* ribbon_tab = new QRibbonTab;

public slots:
	void deactivate(QRibbonTab* tab) override;
};
```

`src/Menus/TerrainPalette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TerrainPalette</class>
 <widget class="QWidget" name="TerrainPalette">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>300</width>
    <height>670</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Terrain Palette</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QCheckBox" name="textureCheckbox">
     <property name="text">
      <string>Texture</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="textureLayout">
     <item>
      <layout class="QHBoxLayout" name="flowLayout_placeholder">
       <property name="spacing">
        <number>4</number>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="blightBoundaryLayout">
       <property name="sizeConstraint">
        <enum>QLayout::SetDefaultConstraint</enum>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
       <item>
        <widget class="QPushButton" name="blight">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="baseSize">
          <size>
           <width>64</width>
           <height>64</height>
          </size>
         </property>
         <property name="toolTip">
          <string>Blight.</string>
         </property>
         <property name="text">
          <string/>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="addBoundary">
         <property name="enabled">
          <bool>false</bool>
         </property>
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="baseSize">
          <size>
           <width>64</width>
           <height>64</height>
          </size>
         </property>
         <property name="toolTip">
          <string>Add Boundary.</string>
         </property>
         <property name="text">
          <string/>
         </property>
         <property name="icon">
          <iconset>
           <normaloff>Data/Icons/Terrain/boundary_place.png</normaloff>Data/Icons/Terrain/boundary_place.png</iconset>
         </property>
         <property name="iconSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="removeBoundary">
         <property name="enabled">
          <bool>false</bool>
         </property>
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="maximumSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
         <property name="baseSize">
          <size>
           <width>64</width>
           <height>64</height>
          </size>
         </property>
         <property name="toolTip">
          <string>Remove Boundary.</string>
         </property>
         <property name="text">
          <string/>
         </property>
         <property name="icon">
          <iconset>
           <normaloff>Data/Icons/Terrain/boundary_remove.png</normaloff>Data/Icons/Terrain/boundary_remove.png</iconset>
         </property>
         <property name="iconSize">
          <size>
           <width>48</width>
           <height>48</height>
          </size>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="verticalSpacer_2">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QCheckBox" name="cliffCheckbox">
     <property name="text">
      <string>Cliff</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="cliffRaiseLayout">
     <property name="spacing">
      <number>6</number>
     </property>
     <property name="rightMargin">
      <number>0</number>
     </property>
     <item>
      <widget class="QPushButton" name="cliffLower2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Lower cliff by 2.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/lower2.png</normaloff>Data/Icons/Terrain/lower2.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffLower1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Lower cliff by 1.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/lower1.png</normaloff>Data/Icons/Terrain/lower1.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffLevel">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Level.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/level.png</normaloff>Data/Icons/Terrain/level.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="default">
        <bool>false</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffRaise1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Raise cliff by 1.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/raise1.png</normaloff>Data/Icons/Terrain/raise1.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffRaise2">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Raise cliff by 2.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/raise2.png</normaloff>Data/Icons/Terrain/raise2.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="cliffWaterLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="cliffDeepWater">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Deep water.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/deep_water.png</normaloff>Data/Icons/Terrain/deep_water.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffShallowWater">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Shallow water.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/shallow_water.png</normaloff>Data/Icons/Terrain/shallow_water.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="cliffRamp">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Ramp.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/ramp.png</normaloff>Data/Icons/Terrain/ramp.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">cliffButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowLayout_placeholder_2"/>
   </item>
   <item>
    <widget class="QCheckBox" name="deformationCheckbox">
     <property name="text">
      <string>Deformation</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="deformationLayout">
     <item>
      <widget class="QPushButton" name="terrainLower">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Raise the terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/brush_lower.png</normaloff>Data/Icons/Terrain/brush_lower.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainRaise">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Lower the terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/brush_raise.png</normaloff>Data/Icons/Terrain/brush_raise.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainRipple">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Ripple the terrain randomly.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/brush_ripple.png</normaloff>Data/Icons/Terrain/brush_ripple.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainPlateau">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Plateau/flatten terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/brush_plateau.png</normaloff>Data/Icons/Terrain/brush_plateau.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="terrainSmooth">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>64</width>
         <height>64</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Smooth terrain.</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Terrain/brush_smooth.png</normaloff>Data/Icons/Terrain/brush_smooth.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>48</width>
         <height>48</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">deformationButtonGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="label_2">
     <property name="text">
      <string>Brush Size</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QPushButton" name="brushSize1">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="baseSize">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 1x1.</string>
       </property>
       <property name="text">
        <string>1</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize3">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 3x3.</string>
       </property>
       <property name="text">
        <string>3</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize5">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 5x5.</string>
       </property>
       <property name="text">
        <string>5</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize7">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 7x7.</string>
       </property>
       <property name="text">
        <string>7</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize9">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 9x9.</string>
       </property>
       <property name="text">
        <string>9</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushSize11">
       <property name="minimumSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="toolTip">
        <string>Sets the brush size to 11x11.</string>
       </property>
       <property name="text">
        <string>11</string>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushSizeButtonGroup</string>
       </attribute>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_4">
     <item>
      <widget class="QSpinBox" name="brushSize">
       <property name="toolTip">
        <string>The current brush size</string>
       </property>
       <property name="readOnly">
        <bool>true</bool>
       </property>
       <property name="buttonSymbols">
        <enum>QAbstractSpinBox::NoButtons</enum>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>241</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="value">
        <number>1</number>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QSlider" name="brushSizeSlider">
       <property name="toolTip">
        <string>Sets the brush size.</string>
       </property>
       <property name="minimum">
        <number>1</number>
       </property>
       <property name="maximum">
        <number>128</number>
       </property>
       <property name="singleStep">
        <number>2</number>
       </property>
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="invertedAppearance">
        <bool>false</bool>
       </property>
       <property name="invertedControls">
        <bool>false</bool>
       </property>
       <property name="tickPosition">
        <enum>QSlider::TicksBelow</enum>
       </property>
       <property name="tickInterval">
        <number>0</number>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Brush Shape</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="brushShapeLayout">
     <item>
      <widget class="QPushButton" name="brushShapeCircle">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Circular brush shape</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Brush/circle.png</normaloff>Data/Icons/Brush/circle.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeSquare">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Square brush shape</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Brush/square.png</normaloff>Data/Icons/Brush/square.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="brushShapeDiamond">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Diamond brush shape</string>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="icon">
        <iconset>
         <normaloff>Data/Icons/Brush/diamond.png</normaloff>Data/Icons/Brush/diamond.png</iconset>
       </property>
       <property name="iconSize">
        <size>
         <width>32</width>
         <height>32</height>
        </size>
       </property>
       <property name="checkable">
        <bool>true</bool>
       </property>
       <attribute name="buttonGroup">
        <string notr="true">brushShapeButtonGroup</string>
       </attribute>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
 <buttongroups>
  <buttongroup name="cliffButtonGroup"/>
  <buttongroup name="brushShapeButtonGroup"/>
  <buttongroup name="brushSizeButtonGroup"/>
  <buttongroup name="deformationButtonGroup"/>
 </buttongroups>
</ui>

```

`src/Menus/TilePather.cpp`:

```cpp
#include "TilePather.h"

#include "Globals.h"

#include <QOpenGLFunctions_4_5_Core>


TilePather::TilePather(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	ui.flowlayout_placeholder->addLayout(selected_layout);

	for (auto&&[tile_id, options] : map->terrain.pathing_options) {
		pathing_options[tile_id].unwalkable = options.unwalkable;
		pathing_options[tile_id].unflyable = options.unflyable;
		pathing_options[tile_id].unbuildable = options.unbuildable;
	}

	slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : map->terrain.tileset_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromStdString(slk.data("comment", i)));

		selected_layout->addWidget(button);
		selected_group->addButton(button);
	}

	selected_group->buttons().first()->setChecked(true);
	changed_tile(selected_group->buttons().first());

	connect(selected_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), this, &TilePather::changed_tile);

	connect(ui.buttonBox, &QDialogButtonBox::accepted, this, &TilePather::save_tiles);
	connect(ui.buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

	connect(ui.unwalkable, &QPushButton::clicked, [&](bool checked) { pathing_options[current_tile].unwalkable = checked; });
	connect(ui.unflyable, &QPushButton::clicked, [&](bool checked) { pathing_options[current_tile].unflyable = checked; });
	connect(ui.unbuildable, &QPushButton::clicked, [&](bool checked) { pathing_options[current_tile].unbuildable = checked; });

	connect(ui.replaceType, &QPushButton::clicked, [&]() { pathing_options[current_tile].operation = PathingOptions::Operation::replace; });
	connect(ui.addType, &QPushButton::clicked, [&]() { pathing_options[current_tile].operation = PathingOptions::Operation::add; });
	connect(ui.removeType, &QPushButton::clicked, [&]() { pathing_options[current_tile].operation = PathingOptions::Operation::remove; });

	connect(ui.applyRetroactively, &QCheckBox::clicked, [&](bool checked) { pathing_options[current_tile].apply_retroactively = checked; });
}

void TilePather::changed_tile(QAbstractButton* button) {
	ui.selectedTileLabel->setText("Tile: " + button->property("tileName").toString());

	current_tile = button->property("tileID").toString().toStdString();

	ui.unwalkable->setChecked(pathing_options[current_tile].unwalkable);
	ui.unflyable->setChecked(pathing_options[current_tile].unflyable);
	ui.unbuildable->setChecked(pathing_options[current_tile].unbuildable);

	ui.applyRetroactively->setChecked(pathing_options[current_tile].apply_retroactively);

	switch (pathing_options[current_tile].operation) {
	case PathingOptions::Operation::replace:
		ui.replaceType->setChecked(true);
		break;
	case PathingOptions::Operation::add:
		ui.addType->setChecked(true);
		break;
	case PathingOptions::Operation::remove:
		ui.removeType->setChecked(true);
		break;
	}
}

void TilePather::save_tiles() {
	for (auto&&[tile_id, options] : pathing_options) {
		// Save state
		map->terrain.pathing_options[tile_id].unwalkable = options.unwalkable;
		map->terrain.pathing_options[tile_id].unflyable = options.unflyable;
		map->terrain.pathing_options[tile_id].unbuildable = options.unbuildable;

		if (!options.apply_retroactively) {
			continue;
		}

		uint8_t mask = 0;
		if (options.unwalkable) {
			mask |= 0b00000010;
		}
		if (options.unflyable) {
			mask |= 0b00000100;
		}
		if (options.unbuildable) {
			mask |= 0b00001000;
		}

		const int id = map->terrain.ground_texture_to_id.at(tile_id);
		for (int i = 0; i < map->terrain.width; i++) {
			for (int j = 0; j < map->terrain.height; j++) {
				if (map->terrain.real_tile_texture(i, j) != id) {
					continue;
				}

				const int left = std::max(i * 4 - 2, 0);
				const int bottom = std::max(j * 4 - 2, 0);

				const int right = std::min(i * 4 + 2, map->pathing_map.width);
				const int top = std::min(j * 4 + 2, map->pathing_map.height);

				for (int x = left; x < right; x++) {
					for (int y = bottom; y < top; y++) {
						uint8_t byte_cell = map->pathing_map.pathing_cells_static[y * map->pathing_map.width + x];

						switch (options.operation) {
						case PathingOptions::Operation::replace:
							byte_cell &= ~0b00001110;
							byte_cell |= mask;
							break;
						case PathingOptions::Operation::add:
							byte_cell |= mask;
							break;
						case PathingOptions::Operation::remove:
							byte_cell &= ~mask;
							break;
						}

						map->pathing_map.pathing_cells_static[y * map->pathing_map.width + x] = byte_cell;
					}
				}
			}
		}
	}

	gl->glTextureSubImage2D(map->pathing_map.texture_static, 0, 0, 0, map->pathing_map.width, map->pathing_map.height, GL_RED_INTEGER, GL_UNSIGNED_BYTE, map->pathing_map.pathing_cells_static.data());

	close();
}
```

`src/Menus/TilePather.h`:

```h
#pragma once

#include "ui_TilePather.h"

#include <QDialog>
#include <QButtonGroup>

#include "FlowLayout.h"

struct PathingOptions {
	bool unwalkable = false;
	bool unflyable = false;
	bool unbuildable = false;

	enum class Operation {
		replace,
		add,
		remove
	};
	Operation operation = Operation::replace;

	bool apply_retroactively = false;
};

class TilePather : public QDialog {
	Q_OBJECT

public:
	explicit TilePather(QWidget* parent = nullptr);

private:
	void changed_tile(QAbstractButton* button);
	void save_tiles();

	Ui::TilePather ui;
	QButtonGroup* selected_group = new QButtonGroup;
	FlowLayout* selected_layout = new FlowLayout;

	std::string current_tile;
	std::unordered_map<std::string, PathingOptions> pathing_options;
};
```

`src/Menus/TilePather.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TilePather</class>
 <widget class="QWidget" name="TilePather">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>580</width>
    <height>260</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Tile Pathing</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="pathingTileLabel">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Pathing Tile&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="selectedTileLabel">
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder"/>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QGroupBox" name="groupBox_2">
       <property name="title">
        <string>Pathing</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout_4">
        <item>
         <widget class="QPushButton" name="unwalkable">
          <property name="toolTip">
           <string>Whether the brush will apply unwalkable.</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>Data/Icons/walkable.png</normaloff>Data/Icons/walkable.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="unflyable">
          <property name="toolTip">
           <string>Whether the brush will apply unflyable.</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>Data/Icons/flyable.png</normaloff>Data/Icons/flyable.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QPushButton" name="unbuildable">
          <property name="toolTip">
           <string>Whether the brush will aply unbuildable</string>
          </property>
          <property name="text">
           <string/>
          </property>
          <property name="icon">
           <iconset>
            <normaloff>Data/Icons/buildable.png</normaloff>Data/Icons/buildable.png</iconset>
          </property>
          <property name="iconSize">
           <size>
            <width>32</width>
            <height>32</height>
           </size>
          </property>
          <property name="checkable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBox">
       <property name="toolTip">
        <string>How the new pathing is applied</string>
       </property>
       <property name="title">
        <string>Operation Type</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout_3">
        <item>
         <widget class="QRadioButton" name="replaceType">
          <property name="toolTip">
           <string>Replaces the existing pathing</string>
          </property>
          <property name="text">
           <string>Replace</string>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QRadioButton" name="addType">
          <property name="toolTip">
           <string>Adds to the existing pathing any types that are selected.</string>
          </property>
          <property name="text">
           <string>Add</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QRadioButton" name="removeType">
          <property name="toolTip">
           <string>Removes from the existing pathing all the types selected.</string>
          </property>
          <property name="text">
           <string>Remove</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="groupBox_3">
       <property name="title">
        <string>Application</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_2">
        <item>
         <widget class="QCheckBox" name="applyRetroactively">
          <property name="toolTip">
           <string>Whether the pathing is applied to all existing tiles or only to newly placed tiles.</string>
          </property>
          <property name="text">
           <string>Apply Retroactively</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>

```

`src/Menus/TilePicker.cpp`:

```cpp
#include "TilePicker.h"

#include <QPushButton>

import ResourceManager;
import Texture;
#include "Globals.h"


TilePicker::TilePicker(QWidget* parent, std::vector<std::string> from_ids, std::vector<std::string> to_ids) : QDialog(parent) {
	ui.setupUi(this);

	ui.flowlayout_placeholder_1->addLayout(from_layout);
	ui.flowlayout_placeholder_2->addLayout(to_layout);

	slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : from_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromStdString(slk.data("comment", i)));

		from_layout->addWidget(button);
		from_group->addButton(button);
	}

	for (auto&& i : to_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromStdString(slk.data("comment", i)));

		to_layout->addWidget(button);
		to_group->addButton(button);
	}

	to_group->buttons().first()->setChecked(true);
	from_group->buttons().first()->setChecked(true);

	connect(ui.buttonBox, &QDialogButtonBox::accepted, this, &TilePicker::completed);
	connect(ui.buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
	
	connect(from_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		ui.selectedTileLabel->setText("Tile: " + button->property("tileName").toString());
	});

	connect(to_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), [&](QAbstractButton* button) {
		ui.replacingTileLabel->setText("Tile: " + button->property("tileName").toString());
	});
}

void TilePicker::completed() {
	const std::string from_tile = from_group->checkedButton()->property("tileID").toString().toStdString();
	const std::string to_tile = to_group->checkedButton()->property("tileID").toString().toStdString();
	emit tile_chosen(from_tile, to_tile);
	close();
}
```

`src/Menus/TilePicker.h`:

```h
#pragma once

#include "ui_TilePicker.h"

#include <QDialog>
#include <QButtonGroup>

#include "FlowLayout.h"

class TilePicker : public QDialog {
	Q_OBJECT

public:
	TilePicker(QWidget* parent, std::vector<std::string> from_ids, std::vector<std::string> to_ids);

signals:
	void tile_chosen(std::string from_id, std::string to_id);

private:
	void completed();

	Ui::TilePicker ui;

	QButtonGroup* from_group = new QButtonGroup;
	QButtonGroup* to_group = new QButtonGroup;

	FlowLayout* from_layout = new FlowLayout;
	FlowLayout* to_layout = new FlowLayout;
};
```

`src/Menus/TilePicker.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TilePicker</class>
 <widget class="QWidget" name="TilePicker">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>579</width>
    <height>153</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>TilePicker</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Replace Tile:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="selectedTileLabel">
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_1"/>
   </item>
   <item>
    <widget class="QLabel" name="availableTilesLabel">
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;By Tile:&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="replacingTileLabel">
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_2"/>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>
```

`src/Menus/TileSetter.cpp`:

```cpp
#include "TileSetter.h"
#include "TilePicker.h"

#include "Globals.h"
import ResourceManager;

TileSetter::TileSetter(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);

	setAttribute(Qt::WA_DeleteOnClose);
	show();

	ui.flowlayout_placeholder_1->addLayout(selected_layout);
	ui.flowlayout_placeholder_2->addLayout(available_layout);

	slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&& i : map->terrain.tileset_ids) {
		const auto image = resource_manager.load<Texture>(slk.data("dir", i) + "\\" + slk.data("file", i));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(i));
		button->setProperty("tileName", QString::fromStdString(slk.data("comment", i)));

		selected_layout->addWidget(button);
		selected_group->addButton(button);
	}

	for (auto&& [key, value] : world_edit_data.section("TileSets")) {
//		const std::string tileset_key = split(value, ',').front();
		ui.tileset->addItem(QString::fromStdString(value[0]), QString::fromStdString(key));
	}

	update_available_tiles();

	connect(ui.tileset, &QComboBox::currentTextChanged, this, &TileSetter::update_available_tiles);
	connect(selected_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), this, &TileSetter::existing_tile_clicked);
	connect(available_group, QOverload<QAbstractButton*>::of(&QButtonGroup::buttonClicked), this, &TileSetter::available_tile_clicked);
	connect(ui.additionalAdd, &QPushButton::clicked, this, &TileSetter::add_tile);
	connect(ui.selectedRemove, &QPushButton::clicked, this, &TileSetter::remove_tile);
	connect(ui.selectedShiftLeft, &QPushButton::clicked, this, &TileSetter::shift_left);
	connect(ui.selectedShiftRight, &QPushButton::clicked, this, &TileSetter::shift_right);
	connect(ui.buttonBox, &QDialogButtonBox::accepted, this, &TileSetter::save_tiles);
	connect(ui.buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
}

void TileSetter::add_tile() const {
	const auto available_button = available_group->checkedButton();
	if (!available_button) {
		return;
	}

	QPushButton* button = new QPushButton;
	button->setIcon(available_button->icon());
	button->setFixedSize(64, 64);
	button->setIconSize({ 64, 64 });
	button->setCheckable(true);
	button->setProperty("tileID", available_button->property("tileID"));
	button->setProperty("tileName", available_button->property("tileName"));

	selected_layout->addWidget(button);
	selected_group->addButton(button);

	if (selected_group->buttons().size() >= 16) {
		ui.additionalAdd->setDisabled(true);
	}
}

void TileSetter::remove_tile() const {
	auto selected_button = selected_group->checkedButton();
	if (!selected_button) {
		return;
	}

	selected_layout->removeWidget(selected_button);
	selected_group->removeButton(selected_button);
	selected_button->deleteLater();

	ui.additionalAdd->setEnabled(true);
}

void TileSetter::update_available_tiles() const {
	available_layout->clear();

	std::string tileset = ui.tileset->currentData().toString().toStdString();

	slk::SLK& slk = map->terrain.terrain_slk;
	for (auto&&[key, value] : map->terrain.terrain_slk.row_headers) {
		if (key.front() != tileset.front()) {
			continue;
		}

		const auto image = resource_manager.load<Texture>(slk.data("dir", key) + "\\" + slk.data("file", key));
		const auto icon = ground_texture_to_icon(image->data.data(), image->width, image->height);

		QPushButton* button = new QPushButton;
		button->setIcon(icon);
		button->setFixedSize(64, 64);
		button->setIconSize({ 64, 64 });
		button->setCheckable(true);
		button->setProperty("tileID", QString::fromStdString(key));
		button->setProperty("tileName", QString::fromStdString(slk.data("comment", key)));

		available_layout->addWidget(button);
		available_group->addButton(button);
	}
}

void TileSetter::existing_tile_clicked(QAbstractButton* button) const {
	ui.selectedTileLabel->setText("Tile: " + button->property("tileName").toString());

	const int index = selected_layout->indexOf(button);
	ui.selectedShiftLeft->setEnabled(index != 0);
	ui.selectedShiftRight->setEnabled(index != selected_layout->count() - 1);

	// Check if cliff tile
	const std::string tile_id = button->property("tileID").toString().toStdString();
	auto& cliff_tiles = map->terrain.cliff_to_ground_texture;
	if (map->terrain.ground_texture_to_id.count(tile_id)) {
		const auto is_cliff_tile = std::find(cliff_tiles.begin(), cliff_tiles.end(), map->terrain.ground_texture_to_id[tile_id]);

		ui.selectedRemove->setEnabled(is_cliff_tile == cliff_tiles.end());
	}
}

void TileSetter::available_tile_clicked(QAbstractButton* button) const {
	ui.additionalTileLabel->setText("Tile: " + button->property("tileName").toString());

	// Check if tile was already in existing/modified tileset
	bool tile_already_added = false;
	for (auto&& i : selected_group->buttons()) {
		if (i->property("tileID") == button->property("tileID")) {
			tile_already_added = true;
		}
	}
	tile_already_added |= selected_group->buttons().size() >= 16;
	ui.additionalAdd->setDisabled(tile_already_added);
}

void TileSetter::shift_left() const {
	const auto selected_button = selected_group->checkedButton();
	if (!selected_button) {
		return;
	}

	const int index = selected_layout->indexOf(selected_button);
	selected_layout->move_widget(index - 1, selected_button);

	if (index - 1 == 0) {
		ui.selectedShiftLeft->setEnabled(false);
	}

	ui.selectedShiftRight->setEnabled(true);
}

void TileSetter::shift_right() const {
	const auto selected_button = selected_group->checkedButton();
	if (!selected_button) {
		return;
	}

	const int index = selected_layout->indexOf(selected_button);
	selected_layout->move_widget(index + 1, selected_button);

	if (index + 1 == selected_layout->count() - 1) {
		ui.selectedShiftRight->setEnabled(false);
	}

	ui.selectedShiftLeft->setEnabled(true);
}

void TileSetter::save_tiles() {
	std::vector<std::string> to_ids;
	for (auto&& j : selected_layout->items()) {
		to_ids.push_back(j->widget()->property("tileID").toString().toStdString());
	}

	from_to_id.resize(map->terrain.tileset_ids.size());
	for (size_t i = 0; i < map->terrain.tileset_ids.size(); i++) {
		const std::string from_id = map->terrain.tileset_ids[i];

		const auto found = std::find(to_ids.begin(), to_ids.end(), from_id);
		if (found != to_ids.end()) {
			from_to_id[i] =  found - to_ids.begin();
		} else {
			TilePicker replace_dialog(this, { from_id }, to_ids);
			connect(&replace_dialog, &TilePicker::tile_chosen, [&](std::string id, std::string to_id) {
				auto tile_found = std::find(to_ids.begin(), to_ids.end(), to_id);
				from_to_id[i] = tile_found - to_ids.begin();
			});
			replace_dialog.exec();
		}
	}

	map->terrain.change_tileset(to_ids, from_to_id);
	close();
}
```

`src/Menus/TileSetter.h`:

```h
#pragma once

#include <QDialog>

#include "ui_TileSetter.h"
#include <QButtonGroup>
#include "FlowLayout.h"

class TileSetter : public QDialog {
	Q_OBJECT

public:
	explicit TileSetter(QWidget* parent = nullptr);

private:
	void add_tile() const;
	void remove_tile() const;
	void update_available_tiles() const;
	void existing_tile_clicked(QAbstractButton* button) const;
	void available_tile_clicked(QAbstractButton* button) const;
	void shift_left() const;
	void shift_right() const;
	void save_tiles();

	Ui::TileSetter ui;

	QButtonGroup* selected_group = new QButtonGroup;
	QButtonGroup* available_group = new QButtonGroup;

	FlowLayout* selected_layout = new FlowLayout;
	FlowLayout* available_layout = new FlowLayout;

	std::vector<int> from_to_id;
};
```

`src/Menus/TileSetter.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TileSetter</class>
 <widget class="QWidget" name="TileSetter">
  <property name="windowModality">
   <enum>Qt::ApplicationModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>580</width>
    <height>340</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>0</width>
    <height>0</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>TileSetter</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <property name="sizeConstraint">
    <enum>QLayout::SetDefaultConstraint</enum>
   </property>
   <item>
    <widget class="QLabel" name="selectedTilesLabel">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>The tiles in the map tileset.</string>
     </property>
     <property name="text">
      <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Selected Tiles&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="selectedTileLabel">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>The current tilename.</string>
     </property>
     <property name="text">
      <string>Tile: </string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_1">
     <property name="sizeConstraint">
      <enum>QLayout::SetDefaultConstraint</enum>
     </property>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="selectedShiftLeft">
       <property name="toolTip">
        <string>Shifts the selected tile left.</string>
       </property>
       <property name="text">
        <string>Shift Left</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="selectedShiftRight">
       <property name="toolTip">
        <string>Shift the selected tile right.</string>
       </property>
       <property name="text">
        <string>Shift Right</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="selectedRemove">
       <property name="toolTip">
        <string>Removes the selected tile from the tleset.</string>
       </property>
       <property name="text">
        <string>Remove</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <widget class="QLabel" name="additionalTilesLabel">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Tiles you can add to the map tileset.</string>
       </property>
       <property name="text">
        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=&quot; font-size:10pt; font-weight:600;&quot;&gt;Additonal Tiles&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="tileset">
       <property name="toolTip">
        <string>The tileset to choose additional tiles from.</string>
       </property>
       <property name="maxVisibleItems">
        <number>20</number>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QLabel" name="additionalTileLabel">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="toolTip">
      <string>The current tilename.</string>
     </property>
     <property name="text">
      <string>Tile:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="flowlayout_placeholder_2">
     <property name="sizeConstraint">
      <enum>QLayout::SetDefaultConstraint</enum>
     </property>
    </layout>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QPushButton" name="additionalAdd">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="toolTip">
        <string>Adds the selected additional tile to the map tileset.</string>
       </property>
       <property name="text">
        <string>Add</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <resources/>
 <connections/>
</ui>
```

`src/Menus/UnitPalette.cpp`:

```cpp
#include "UnitPalette.h"

#include <QComboBox>
#include <QLineEdit>
#include <QListView>

#include "Globals.h"
#include "Selections.h"

#include "TableModel.h"
#include <QSortFilterProxyModel>

UnitPalette::UnitPalette(QWidget* parent) : Palette(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);
	show();

	for (const auto& player : map->info.players) {
		std::string color_lookup = std::to_string(player.internal_number);
		if (color_lookup.size() == 1) {
			color_lookup = "0" + color_lookup;
		}

		std::string player_name = map->trigger_strings.string(player.name) + " (" + world_edit_strings.data("WorldEditStrings", "WESTRING_UNITCOLOR_" + color_lookup) + ")";

		ui.player->addItem(QString::fromStdString(player_name), player.internal_number);
	}
	ui.player->addItem("Neutral Hostile", 24);
	ui.player->addItem("Neutral Passive", 27);

	QRibbonSection* selection_section = new QRibbonSection;
	selection_section->setText("Selection");

	selection_mode->setText("Selection\nMode");
	selection_mode->setIcon(QIcon("Data/Icons/Ribbon/select32x32.png"));
	selection_mode->setCheckable(true);
	selection_section->addWidget(selection_mode);

	find_this = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), this, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	find_parent = new QShortcut(QKeySequence(Qt::CTRL | Qt::Key_F), parent, nullptr, nullptr, Qt::ShortcutContext::WindowShortcut);
	selection_mode->setShortCut(Qt::Key_Space, { this, parent });

	ribbon_tab->addSection(selection_section);
	
	connect(selection_mode, &QRibbonButton::toggled, [&]() { brush.switch_mode(); });

	connect(ui.player, QOverload<int>::of(&QComboBox::currentIndexChanged), [&]() {
		brush.player_id = ui.player->currentData().toInt();
	});

	connect(find_this, &QShortcut::activated, [&]() {
		activateWindow();
		ui.selector->search->setFocus();
		ui.selector->search->selectAll();
	});

	connect(find_parent, &QShortcut::activated, [&]() {
		activateWindow();
		ui.selector->search->setFocus();
		ui.selector->search->selectAll();
	});

	
	connect(ui.selector, &UnitSelector::unitSelected, [&](const std::string& id) { 
		brush.set_unit(id); 
		selection_mode->setChecked(false);
	});
}

UnitPalette::~UnitPalette() {
	map->brush = nullptr;
}

bool UnitPalette::event(QEvent* e) {
	if (e->type() == QEvent::Close) {
		// Remove shortcut from parent
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
		selection_mode->disconnectShortcuts();
		ribbon_tab->setParent(nullptr);
		delete ribbon_tab;
	} else if (e->type() == QEvent::WindowActivate) {
		find_this->setEnabled(true);
		find_parent->setEnabled(true);
		selection_mode->enableShortcuts();
		map->brush = &brush;
		emit ribbon_tab_requested(ribbon_tab, "Unit Palette");
	}
	return QWidget::event(e);
}

void UnitPalette::deactivate(QRibbonTab* tab) {
	if (tab != ribbon_tab) {
		brush.clear_selection();
		selection_mode->disableShortcuts();
		find_this->setEnabled(false);
		find_parent->setEnabled(false);
	}
}
```

`src/Menus/UnitPalette.h`:

```h
#pragma once

#include "ui_UnitPalette.h"
#include "UnitBrush.h"
#include "Palette.h"
#include "QRibbon.h"
#include "UnitListModel.h"
//#include "UnitSelector.h"

class UnitPalette : public Palette {
	Q_OBJECT

public:
	UnitPalette(QWidget* parent = nullptr);
	~UnitPalette();

private:
	bool event(QEvent* e) override;

	Ui::UnitPalette ui;

	UnitBrush brush;

	QRibbonTab* ribbon_tab = new QRibbonTab;
	QRibbonButton* selection_mode = new QRibbonButton;

	QShortcut* find_this;
	QShortcut* find_parent;

public slots:
	void deactivate(QRibbonTab* tab) override;
};
```

`src/Menus/UnitPalette.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>UnitPalette</class>
 <widget class="QDialog" name="UnitPalette">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>244</width>
    <height>560</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Unit Palette</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Place as</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="player">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="UnitSelector" name="selector" native="true"/>
   </item>
  </layout>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <customwidgets>
  <customwidget>
   <class>UnitSelector</class>
   <extends>QWidget</extends>
   <header>UnitSelector.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`src/ModelEditor/ModelEditor.cpp`:

```cpp
#include "ModelEditor.h"

#include <QTableView>
#include <QLineEdit>
#include <QToolBar>
#include <QDialogButtonBox>
#include <QSortFilterProxyModel>
#include <QPushButton>
#include <QTimer>

#include "SingleModel.h"
#include "UnitSelector.h"

ModelEditor::ModelEditor(QWidget* parent) : QMainWindow(parent) {
	ui.setupUi(this);
	setAttribute(Qt::WA_DeleteOnClose);

	show();
}
```

`src/ModelEditor/ModelEditor.h`:

```h
#pragma once

#include <QMainWindow>

#include "ui_ModelEditor.h"

#include "DockManager.h"
#include "DockAreaWidget.h"
#include <QTreeView>
#include <QOpenGLWidget>

class ModelEditor : public QMainWindow {
	Q_OBJECT

public:
	ModelEditor(QWidget* parent = nullptr);

private:
	Ui::ModelEditor ui;

	//QOpenGLWidget opengl_widget;

	//std::shared_ptr<QIconResource> custom_unit_icon;
};
```

`src/ModelEditor/ModelEditor.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ModelEditor</class>
 <widget class="QMainWindow" name="ModelEditor">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1280</width>
    <height>720</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Model Editor</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QHBoxLayout" name="horizontalLayout">
    <item>
     <widget class="ModelEditorGLWidget" name="openGLWidget">
      <property name="minimumSize">
       <size>
        <width>0</width>
        <height>0</height>
       </size>
      </property>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <customwidgets>
  <customwidget>
   <class>ModelEditorGLWidget</class>
   <extends>QOpenGLWidget</extends>
   <header>ModelEditorGLWidget.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`src/ModelEditor/ModelEditorCamera.cpp`:

```cpp
#include "ModelEditorCamera.h"

#include "InputHandler.h"

void ModelEditorCamera::reset() {
	distance = 20;
	horizontal_angle = 0.0f;
	vertical_angle = -0.977f;
	update(0);
}

void ModelEditorCamera::update(double delta) {
	direction = glm::vec3(
		std::cos(vertical_angle) * std::sin(horizontal_angle),
		std::cos(vertical_angle) * std::cos(horizontal_angle),
		std::sin(vertical_angle));

	direction = glm::normalize(direction);
	// Calculate axis directions for camera as referential point:
	// Z axis is simply the direction we are facing
	// X axis is then the cross product between the "fake" up and Z
	X = glm::cross(direction, up);
	X = glm::normalize(X);
	// Y Axis is cross product between X and Z, e.g is the real up
	Y = glm::cross(X, direction);
	Y = glm::normalize(Y);

	// The vector that is perpendicular to the up vector, thus points forward
	forward = glm::cross(X, up);

	projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	view = glm::lookAt(position - direction * distance, position, up);
	projection_view = projection * view;

	// for billboarded animated mesh
	glm::vec3 opDirection = -direction; // camera->position - this->position;

	glm::vec3 opDirectionZ = glm::normalize(glm::vec3(opDirection.x, opDirection.y, 0));
	float angleZ = glm::atan(opDirectionZ.y, opDirectionZ.x);
	glm::vec3 axisZ = glm::vec3(0, 0, 1);

	glm::vec3 opDirectionY = glm::normalize(opDirection);
	glm::vec3 axisY = glm::vec3(0, -1, 0);

	decomposed_rotation = glm::angleAxis(angleZ, axisZ) * glm::angleAxis(glm::asin(opDirectionY.z), axisY);
}

void ModelEditorCamera::mouse_move_event(QMouseEvent* event, const InputHandler& my_input_handler) {
	glm::vec2 diff = my_input_handler.mouse - my_input_handler.previous_mouse;

	if (rolling || (event->buttons() == Qt::RightButton && event->modifiers() & Qt::ControlModifier)) {
		horizontal_angle += diff.x * 0.01f;
		vertical_angle -= diff.y * 0.01f;
		vertical_angle = std::max(-glm::pi<float>() / 2.f + 0.001f, std::min(vertical_angle, glm::pi<float>() / 2.f - 0.001f));
		update(0);
	} else if (event->buttons() == Qt::RightButton) {
		position += X * (-diff.x * 0.025f * (distance / 30.f));
		position += forward * (-diff.y * 0.025f * (distance / 30.f));
		update(0);
	}
}

void ModelEditorCamera::mouse_scroll_event(QWheelEvent* event) {
	distance = std::clamp(distance * std::pow(0.999f, static_cast<float>(event->angleDelta().y())), 0.001f, 1000.f);
	update(0);
}

void ModelEditorCamera::mouse_press_event(QMouseEvent* event) {
	switch (event->button()) {
		case Qt::MiddleButton:
			rolling = true;
			break;
		default:
			break;
	}
}

void ModelEditorCamera::mouse_release_event(QMouseEvent* event) {
	switch (event->button()) {
		case Qt::MiddleButton:
			rolling = false;
			break;
		default:
			break;
	}
}
```

`src/ModelEditor/ModelEditorCamera.h`:

```h
#pragma once

#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

#include <QEvent>
#include <QMouseEvent>
#include <InputHandler.h>

struct ModelEditorCamera {
	glm::vec3 position = { 0, 0, 0 };

	float distance = 20.f;

	glm::vec3 direction = { 0, 1, 0 };
	glm::vec3 X = { 1, 0, 0 };
	glm::vec3 Y = { 0, 1, 0 };
	glm::vec3 up = { 0, 0, 1 };
	glm::vec3 forward = { 0, 1, 0 };

	float fov = 70.f;
	float aspect_ratio = 16.f / 9.f;
	float draw_distance_close = 0.05f;
	float draw_distance_far = 2000.f;
	float fov_rad = (glm::pi<double>() / 180.f) * static_cast<double>(fov); // Need radians
	float tan_height = 2.f * glm::tan(fov_rad * 0.5f);

	glm::mat4 projection = glm::perspective(fov, aspect_ratio, draw_distance_close, draw_distance_far);
	glm::mat4 view = glm::lookAt(position - direction * distance, position, up);
	glm::mat4 projection_view;

	glm::vec4 frustum_planes[6];

	// Used for decomposing camera information to get rotation, for camera-centric Billboarded model elements
	glm::vec3 decomposed_scale;
	glm::quat decomposed_rotation;
	glm::vec3 decomposed_translation;
	glm::vec3 decomposed_skew;
	glm::vec4 decomposed_perspective;

	float horizontal_angle = 0.f;
	float vertical_angle = -0.977f;

	bool rolling = false;

	void update(double delta);

	void mouse_move_event(QMouseEvent* event, const InputHandler& my_input_handler);
	void mouse_scroll_event(QWheelEvent* event);
	void mouse_press_event(QMouseEvent* event);
	void mouse_release_event(QMouseEvent* event);
	void reset();
};
```

`src/ModelEditor/ModelEditorGLWidget.cpp`:

```cpp
#include "ModelEditorGLWidget.h"

#include "fmt/format.h"
#include <fstream>

//#include <glad/glad.h>

#include <QTimer>
#include <QPainter>
#include <QFileDialog>
#include <QSettings>
#include <QStandardPaths>
#include <QDesktopServices>

#include "InputHandler.h"
#include <QtImgui/QtImGui.h>
#include <imgui.h>

#include "Globals.h"

ModelEditorGLWidget::ModelEditorGLWidget(QWidget* parent) : QOpenGLWidget(parent) {
	makeCurrent();

	setMouseTracking(true);
	setFocus();
	setFocusPolicy(Qt::WheelFocus);
}

void ModelEditorGLWidget::initializeGL() {
	//gl = new QOpenGLFunctions_4_5_Core;
	//if (!gl->initializeOpenGLFunctions()) {
	//	std::cout << "Error initializing functions";
	//	throw;
	//}
	//
	//if (!gladLoadGL()) {
	//	std::cout << "Failed to initialize OpenGL context" << std::endl;
	//}
	
	QtImGui::initialize(this);

	gl->glEnable(GL_DEPTH_TEST);
	gl->glEnable(GL_CULL_FACE);
	gl->glDepthFunc(GL_LEQUAL);
	gl->glEnable(GL_BLEND);
	gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	gl->glClearColor(0, 0, 0, 1);
	
	gl->glGenVertexArrays(1, &vao);
	gl->glBindVertexArray(vao);

	mesh = resource_manager.load<EditableMesh>("units/human/footman/footman.mdx", "", std::nullopt);
	skeleton = SkeletalModelInstance(mesh->mdx);

	auto& extent = mesh->mdx->sequences[skeleton.sequence_index].extent;
	camera.position.z = (extent.maximum.z - extent.minimum.z) / 2.f;

	shader = resource_manager.load<Shader>({ "Data/Shaders/editable_mesh_hd.vs", "Data/Shaders/editable_mesh_hd.fs" });

	begin = std::chrono::steady_clock::now();

	QTimer::singleShot(16.67, this, &ModelEditorGLWidget::update_scene);
}

void ModelEditorGLWidget::resizeGL(const int w, const int h) {
	gl->glViewport(0, 0, w, h);
	camera.aspect_ratio = double(w) / h;
	camera.update(delta);
	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
}

void ModelEditorGLWidget::update_scene() {
	delta = elapsed_timer.nsecsElapsed() / 1'000'000'000.0;
	elapsed_timer.start();

	skeleton.update_location(glm::vec3(0.f), 0.f, glm::vec3(1.f));
	skeleton.update(delta);

	camera.update(16.666);

	update();

	QTimer::singleShot(16.67 - std::clamp(delta, 0.001, 16.60), this, &ModelEditorGLWidget::update_scene);
}

void ModelEditorGLWidget::paintGL() {
	makeCurrent();

	gl->glBindVertexArray(vao);
	gl->glEnable(GL_DEPTH_TEST);
	gl->glDepthMask(true);
	gl->glClearColor(0.3f, 0.3f, 0.3f, 1.f);
	gl->glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	shader->use();
	mesh->render(skeleton, camera.projection_view, camera.direction);

	gl->glEnable(GL_BLEND);

	gl->glBindVertexArray(0);

	gl->glEnable(GL_DEPTH_TEST);
	gl->glDepthFunc(GL_LEQUAL);
	gl->glEnable(GL_BLEND);
	gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	// ImGui
	QtImGui::newFrame();

	ImGui::Begin("General");

	if (ImGui::Button("Edit MDL")) {

		auto mdl = mesh->mdx->to_mdl();

		auto path = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/" + QString::fromStdString(mesh->mdx->name) + ".mdl";

		std::ofstream file(path.toStdString());
		file.write(mdl.data(), mdl.size());
		file.close();

		QDesktopServices::openUrl(QUrl(path, QUrl::TolerantMode));
	}

	if (ImGui::Button("Open Model")) {
		QSettings settings;

		QString file_name = QFileDialog::getOpenFileName(this, "Open Model File",
														 settings.value("openDirectory", QDir::current().path()).toString(),
														 "MDX (*.mdx *.MDX)");

		if (file_name == "") {
			return;
		}

		mesh = resource_manager.load<EditableMesh>(file_name.toStdString(), "", std::nullopt);
		skeleton = SkeletalModelInstance(mesh->mdx);
	}

	ImGui::Text(fmt::format("name: {}", mesh->mdx->name).c_str());

	size_t vertices = 0;
	size_t triangles = 0;
	for (const auto& i : mesh->mdx->geosets) {
		vertices += i.vertices.size();
		triangles += i.faces.size() / 3;
	}

	ImGui::Text(fmt::format("Vertices: {}", vertices).c_str());
	ImGui::Text(fmt::format("Triangles: {}", triangles).c_str());

	ImGui::End();

	ImGui::Begin("Animation");

	ImGui::Text("Animation");
	ImGui::SameLine();
	if (ImGui::BeginCombo("##combo", mesh->mdx->sequences[skeleton.sequence_index].name.c_str())) {
		for (size_t i = 0; i < mesh->mdx->sequences.size(); i++) {
			if (ImGui::Selectable(mesh->mdx->sequences[i].name.c_str(), i == skeleton.sequence_index)) {
				skeleton.set_sequence(i);
			}
			if (i == skeleton.sequence_index) {
				ImGui::SetItemDefaultFocus();
			}
		}
		ImGui::EndCombo();
	}

	//std::string name;
	//uint32_t start_frame;
	//uint32_t end_frame;
	//float movespeed;
	//uint32_t flags;
	//float rarity;
	//uint32_t sync_point;
	//Extent extent;

	//enum Flags {
	//	looping,
	//	non_looping
	//};

	ImGui::Text(fmt::format("Start frame: {}", mesh->mdx->sequences[skeleton.sequence_index].start_frame).c_str());
	ImGui::Text(fmt::format("End frame: {}", mesh->mdx->sequences[skeleton.sequence_index].end_frame).c_str());
	ImGui::Text(fmt::format("Current frame: {}", skeleton.current_frame).c_str());
	ImGui::Text(fmt::format("Looping: {}", mesh->mdx->sequences[skeleton.sequence_index].flags == mdx::Sequence::Flags::looping).c_str());

	ImGui::End();

	//for (const auto& i : mesh->model->textures) {
	//	ImGui::Text(i.file_name.string().c_str());
	//}
	

	// more widgets...

	ImGui::Render();
	QtImGui::render();

	//QPainter p(this);
	//p.setPen(QColor(Qt::GlobalColor::white));
	//p.setFont(QFont("Arial", 10, 100, false));

	//// Rendering time
	//p.drawText(10, 20, "Test text drawing");
}

void ModelEditorGLWidget::keyPressEvent(QKeyEvent* event) {
	my_input_handler.keys_pressed.emplace(event->key());
}

void ModelEditorGLWidget::keyReleaseEvent(QKeyEvent* event) {
	my_input_handler.keys_pressed.erase(event->key());
}

void ModelEditorGLWidget::mouseMoveEvent(QMouseEvent* event) {
	my_input_handler.mouse_move_event(event);
	camera.mouse_move_event(event, my_input_handler);
}

void ModelEditorGLWidget::mousePressEvent(QMouseEvent* event) {
	makeCurrent();
	
	camera.mouse_press_event(event);
}

void ModelEditorGLWidget::mouseReleaseEvent(QMouseEvent* event) {
	camera.mouse_release_event(event);
}

void ModelEditorGLWidget::wheelEvent(QWheelEvent* event) {
	camera.mouse_scroll_event(event);
}
```

`src/ModelEditor/ModelEditorGLWidget.h`:

```h
#pragma once

#include <QObject>
#include <QOpenGLWidget>

#include "Camera.h"
#include <QElapsedTimer>
#include "EditableMesh.h"
#include <ModelEditor/ModelEditorCamera.h>

class ModelEditorGLWidget : public QOpenGLWidget {
	Q_OBJECT

public:
	QElapsedTimer elapsed_timer;
	GLuint vao;

	//mdx::MDX model;

	double delta = 0.0;
	std::chrono::steady_clock::time_point begin;


	explicit ModelEditorGLWidget(QWidget* parent);
	~ModelEditorGLWidget() = default;

	void initializeGL() override;
	void resizeGL(int w, int h) override;
	void update_scene();
	void paintGL() override;

	void keyPressEvent(QKeyEvent* event) override;
	void keyReleaseEvent(QKeyEvent* event) override;
	void mouseMoveEvent(QMouseEvent* event) override;
	void mousePressEvent(QMouseEvent* event) override;
	void mouseReleaseEvent(QMouseEvent* event) override;
	void wheelEvent(QWheelEvent* event) override;

	std::shared_ptr<EditableMesh> mesh;
	SkeletalModelInstance skeleton;

	std::shared_ptr<Shader> shader;

	ModelEditorCamera camera;
	InputHandler my_input_handler;
};
```

`src/Models/AbilityTreeModel.cpp`:

```cpp
#include "AbilityTreeModel.h"

AbilityTreeModel::AbilityTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &abilities_slk;

	for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
		if (key == "Sort" || key == "NumValues") {
			continue;
		}

		categories[value[0]].name = value[1];
		categories[value[0]].item = new BaseTreeItem(rootItem);
		categories[value[0]].item->baseCategory = true;
		rowToCategory.push_back(value[0]);
	}

	for (const auto& i : rootItem->children) {
		for (const auto& subCategory : subCategories) {
			BaseTreeItem* item = new BaseTreeItem(i);
			item->subCategory = true;
		}
	}

	for (int i = 0; i < abilities_slk.rows(); i++) {
		const std::string& id = abilities_slk.index_to_row.at(i);

		BaseTreeItem* parent_item = getFolderParent(id);
		if (!parent_item) {
			continue;
		}

		BaseTreeItem* item = new BaseTreeItem(parent_item);
		item->id = id;
		items.emplace(id, item);
	}

	categoryChangeFields = { "race", "hero", "item" };
}

BaseTreeItem* AbilityTreeModel::getFolderParent(const std::string& id) const {
	std::string race = abilities_slk.data("race", id);
	if (race.empty()) {
		std::cout << "Empty race for " << id << " in abilities\n";
		return nullptr;
	}
	bool isHero = abilities_slk.data("hero", id) == "1";
	bool isItem = abilities_slk.data("item", id) == "1";

	int subIndex = 0;
	if (isHero) {
		subIndex = 1;
	} else if (isItem) {
		subIndex = 2;
	}

	return categories.at(race).item->children[subIndex];
}

QVariant AbilityTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else if (item->subCategory) {
				return QString::fromStdString(subCategories[index.row()]);
			} else {
				return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
			}
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/AbilityTreeModel.h`:

```h
#pragma once

#include <array>

#include "BaseTreeModel.h"

class AbilityTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	std::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	std::array<std::string, 3> subCategories = {
		"Units",
		"Heroes",
		"Items"
	};

	BaseTreeItem* getFolderParent(const std::string& id) const override;


public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit AbilityTreeModel(QObject* parent = nullptr);
};
```

`src/Models/BaseTreeModel.cpp`:

```cpp
#include "BaseTreeModel.h"

BaseTreeItem::BaseTreeItem(BaseTreeItem* parent) : parent(parent) {
	if (parent != nullptr) {
		parent->appendChild(this);
	}
}

BaseTreeItem::~BaseTreeItem() {
	qDeleteAll(children);
}

void BaseTreeItem::appendChild(BaseTreeItem* item) {
	item->parent = this;
	children.append(item);
}

void BaseTreeItem::removeChild(BaseTreeItem* item) {
	item->parent = nullptr;
	children.removeOne(item);
}

int BaseTreeItem::row() const {
	if (parent)
		return parent->children.indexOf(const_cast<BaseTreeItem*>(this));

	return 0;
}

BaseTreeModel::BaseTreeModel(QObject* parent) : QAbstractProxyModel(parent) {
	rootItem = new BaseTreeItem();

	QFileIconProvider icons;
	folderIcon = icons.icon(QFileIconProvider::Folder);
}

BaseTreeModel::~BaseTreeModel() {
	delete rootItem;
}

int BaseTreeModel::rowCount(const QModelIndex& parent) const {
	if (parent.column() > 0) {
		return 0;
	}

	BaseTreeItem* parentItem;

	if (!parent.isValid()) {
		parentItem = rootItem;
	} else {
		parentItem = static_cast<BaseTreeItem*>(parent.internalPointer());
	}

	return parentItem->children.count();
}

int BaseTreeModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

Qt::ItemFlags BaseTreeModel::flags(const QModelIndex& index) const {
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

QModelIndex BaseTreeModel::index(int row, int column, const QModelIndex& parent) const {
	if (!hasIndex(row, column, parent))
		return QModelIndex();

	BaseTreeItem* parentItem;

	if (!parent.isValid()) {
		parentItem = rootItem;
	} else {
		parentItem = static_cast<BaseTreeItem*>(parent.internalPointer());
	}

	BaseTreeItem* childItem = parentItem->children.at(row);
	if (childItem)
		return createIndex(row, column, childItem);
	return QModelIndex();
}

QModelIndex BaseTreeModel::parent(const QModelIndex& index) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* childItem = static_cast<BaseTreeItem*>(index.internalPointer());
	BaseTreeItem* parentItem = childItem->parent;

	if (parentItem == rootItem)
		return QModelIndex();

	return createIndex(parentItem->row(), 0, parentItem);
}

QModelIndex BaseTreeModel::mapFromSource(const QModelIndex& sourceIndex) const {
	if (!sourceIndex.isValid()) {
		return {};
	}

	const std::string id = slk->index_to_row.at(sourceIndex.row());
	const BaseTreeItem* parent_item = items.at(id)->parent;
	const int row = parent_item->children.indexOf(items.at(id));
	return createIndex(row, 0, items.at(id));
}

QModelIndex BaseTreeModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(proxyIndex.internalPointer());

	if (item->baseCategory || item->subCategory) {
		return {};
	}

	if (slk->column_headers.contains("name")) {
		return createIndex(slk->row_headers.at(item->id), slk->column_headers.at("name"), item);
	} else {
		return createIndex(slk->row_headers.at(item->id), slk->column_headers.at("bufftip"), item);
	}

}

void BaseTreeModel::rowsInserted(const QModelIndex& parent, int first, int last) {
	assert(first == last);

	const std::string id = slk->index_to_row.at(first);
	BaseTreeItem* parent_item = getFolderParent(id);

	beginInsertRows(createIndex(parent_item->row(), 0, parent_item), parent_item->children.size(), parent_item->children.size());
	BaseTreeItem* item = new BaseTreeItem(parent_item);
	item->id = id;
	items.emplace(id, item);
	endInsertRows();
}

void BaseTreeModel::rowsRemoved(const QModelIndex& parent, int first, int last) {
	assert(first == last);

	const std::string id = slk->index_to_row.at(first);
	BaseTreeItem* child = items.at(id);

	BaseTreeItem* parent_item = child->parent;
	const int row = parent_item->children.indexOf(child);

	beginRemoveRows(createIndex(parent_item->row(), 0, parent_item), row, row);
	parent_item->removeChild(child);
	items.erase(id);
	delete child;
	endRemoveRows();
}

void BaseTreeModel::sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles) {
	Q_ASSERT(topLeft.isValid());
	Q_ASSERT(topLeft.model() == this->sourceModel());
	Q_ASSERT(bottomRight.isValid());
	Q_ASSERT(bottomRight.model() == this->sourceModel());

	// If the changed field is one of those that determine the item's location in the tree we have to move it
	if (std::find(categoryChangeFields.begin(), categoryChangeFields.end(), slk->index_to_column[topLeft.column()]) != categoryChangeFields.end()) {
		const std::string id = slk->index_to_row.at(topLeft.row());

		BaseTreeItem* parent_item = items.at(id)->parent;
		int row = parent_item->children.indexOf(items.at(id));

		BaseTreeItem* new_parent = getFolderParent(id);
		const QModelIndex source_parent = createIndex(parent_item->row(), 0, parent_item);
		const QModelIndex target_parent = createIndex(new_parent->row(), 0, new_parent);

		beginMoveRows(source_parent, row, row, target_parent, new_parent->children.size());
		BaseTreeItem* child = parent_item->children[row];
		parent_item->removeChild(child);
		new_parent->appendChild(child);
		endMoveRows();
	}

	emit dataChanged(mapFromSource(topLeft), mapFromSource(bottomRight), roles);
}


void BaseTreeModel::setSourceModel(QAbstractItemModel* sourceModel) {
	beginResetModel();

	if (this->sourceModel()) {
		disconnect(sourceModel, &QAbstractItemModel::rowsInserted, this, &BaseTreeModel::rowsInserted);
		disconnect(sourceModel, &QAbstractItemModel::rowsAboutToBeRemoved, this, &BaseTreeModel::rowsRemoved);
		disconnect(sourceModel, &QAbstractItemModel::dataChanged, this, &BaseTreeModel::sourceDataChanged);
	}

	QAbstractProxyModel::setSourceModel(sourceModel);

	connect(sourceModel, &QAbstractItemModel::rowsInserted, this, &BaseTreeModel::rowsInserted);
	connect(sourceModel, &QAbstractItemModel::rowsAboutToBeRemoved, this, &BaseTreeModel::rowsRemoved);
	connect(sourceModel, &QAbstractItemModel::dataChanged, this, &BaseTreeModel::sourceDataChanged);

	endResetModel();
}

QModelIndex BaseTreeModel::getIdIndex(const std::string& id) {
	const BaseTreeItem* parent_item = items.at(id)->parent;
	const int row = parent_item->children.indexOf(items.at(id));
	return createIndex(row, 0, items.at(id));
}

QVariant BaseTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::DecorationRole:
			if (item->baseCategory || item->subCategory) {
				return folderIcon;
			}
			if (slk->column_headers.contains("art")) {
				return sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("art")), role);
			} else {
				return sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("buffart")), role);
			}
		case Qt::ForegroundRole:
			if (item->baseCategory || item->subCategory) {
				return {};
			}

			if (slk->shadow_data.contains(item->id)) {
				return QColor("violet");
			} else {
				return {};
			}
		default:
			return {};
	}
}

bool BaseFilter::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const {
	QModelIndex index0 = sourceModel()->index(sourceRow, 0, sourceParent);
	BaseTreeItem* item = static_cast<BaseTreeItem*>(index0.internalPointer());

	if (filterCustom) {
		if (item->baseCategory || item->subCategory) {
			return false;
		}

		if (!(slk->shadow_data.contains(item->id) && slk->shadow_data.at(item->id).contains("oldid"))) {
			return false;
		}
	}

	return sourceModel()->data(index0).toString().contains(filterRegularExpression());
}

void BaseFilter::setFilterCustom(bool filter) {
	filterCustom = filter;
	invalidateFilter();
}
```

`src/Models/BaseTreeModel.h`:

```h
#pragma once

#include <QAbstractProxyModel>
#include <QPainter>
#include <QFileIconProvider>
#include <QSortFilterProxyModel>
#include <QIdentityProxyModel>

#include <array>
#include <vector>

#include "Globals.h"

class BaseTreeItem {
public:
	QVector<BaseTreeItem*> children;
	BaseTreeItem* parent = nullptr;

	explicit BaseTreeItem(BaseTreeItem* parentItem = nullptr);
	~BaseTreeItem();

	void appendChild(BaseTreeItem* child);
	void removeChild(BaseTreeItem* child);

	int row() const;

	std::string id;
	bool baseCategory = false;
	bool subCategory = false;
};

class BaseTreeModel : public QAbstractProxyModel {
	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	Qt::ItemFlags flags(const QModelIndex& index) const override;

	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& child) const override;

	void rowsInserted(const QModelIndex& parent, int first, int last);
	void rowsRemoved(const QModelIndex& parent, int first, int last);
	void sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles);



	//BaseTreeItem* newItem(std::string id);
	//void removeItem(std::string id);


	virtual BaseTreeItem* getFolderParent(const std::string& id) const {
		return nullptr;
	};

  public:

	explicit BaseTreeModel(QObject* parent = nullptr);
	~BaseTreeModel();

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;

	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override;
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;

	void setSourceModel(QAbstractItemModel* sourceModel) override;

	QModelIndex getIdIndex(const std::string& id);

	BaseTreeItem* rootItem;
	QIcon folderIcon;

	std::vector<std::string> categoryChangeFields;
	
protected:
	slk::SLK* slk;
	std::unordered_map<std::string, BaseTreeItem*> items;
};


class BaseFilter : public QSortFilterProxyModel {
	Q_OBJECT

	bool filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const override;

	bool filterCustom = false;

 public:
	slk::SLK* slk;

	using QSortFilterProxyModel::QSortFilterProxyModel;

public slots:
	void setFilterCustom(bool filter);
};
```

`src/Models/BuffTreeModel.cpp`:

```cpp
#include "BuffTreeModel.h"

BuffTreeModel::BuffTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &buff_slk;

	for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
		if (key == "Sort" || key == "NumValues") {
			continue;
		}

		categories[value[0]].name = value[1];
		categories[value[0]].item = new BaseTreeItem(rootItem);
		categories[value[0]].item->baseCategory = true;
		rowToCategory.push_back(value[0]);
	}

	for (const auto& i : rootItem->children) {
		for (const auto& subCategory : subCategories) {
			BaseTreeItem* item = new BaseTreeItem(i);
			item->subCategory = true;
		}
	}

	for (int i = 0; i < buff_slk.rows(); i++) {
		const std::string& id = buff_slk.index_to_row.at(i);

		BaseTreeItem* parent_item = getFolderParent(id);
		if (!parent_item) {
			continue;
		}

		BaseTreeItem* item = new BaseTreeItem(parent_item);
		item->id = id;
		items.emplace(id, item);
	}

	categoryChangeFields = { "race", "iseffect" };
}

BaseTreeItem* BuffTreeModel::getFolderParent(const std::string& id) const {
	std::string race = buff_slk.data("race", id);
	if (race.empty()) {
		std::cout << "Empty race for " << id << " in buffs\n";
		return nullptr;
	}
	bool isEffect = buff_slk.data("iseffect", id) == "1";

	int subIndex = isEffect ? 1 : 0;

	return categories.at(race).item->children[subIndex];
}

QVariant BuffTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else if (item->subCategory) {
				return QString::fromStdString(subCategories[index.row()]);
			} else {
				const QString editorname = sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorname")), role).toString();
				if (editorname.isEmpty()) {
					return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
				} else {
					return editorname + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
				}
			}
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/BuffTreeModel.h`:

```h
#pragma once

#include <array>

#include "BaseTreeModel.h"

class BuffTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	std::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	std::array<std::string, 2> subCategories = {
		"Buffs",
		"Effects",
	};

	BaseTreeItem* getFolderParent(const std::string& id) const override;

public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit BuffTreeModel(QObject* parent = nullptr);
};
```

`src/Models/DestructableListModel.cpp`:

```cpp
#include "DestructableListModel.h"

#include "Globals.h"

DestructableListModel::DestructableListModel(QObject* parent) : QIdentityProxyModel(parent) {
	for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
		const std::string tileset_key = value.front();
		icons[key.front()] = resource_manager.load<QIconResource>(value[1]);
	}
}

QModelIndex DestructableListModel::mapFromSource(const QModelIndex& sourceIndex) const {
	if (!sourceIndex.isValid()) {
		return {};
	}

	return createIndex(sourceIndex.row(), 0);
}

QModelIndex DestructableListModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	return sourceModel()->index(proxyIndex.row(), destructibles_slk.column_headers.at("name"));
}

QVariant DestructableListModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	switch (role) {
		case Qt::DisplayRole:
			return sourceModel()->data(mapToSource(index), role).toString() + " " + QString::fromStdString(destructibles_slk.data("editorsuffix", index.row()));
		case Qt::DecorationRole: {
			char category = destructibles_slk.data("category", index.row()).front();
			if (icons.contains(category)) {
				return icons.at(category)->icon;
			} else {
				return {};
			}
		}
		case Qt::SizeHintRole:
			return QSize(0, 16);
		default:
			return sourceModel()->data(mapToSource(index), role);
	}
}

Qt::ItemFlags DestructableListModel::flags(const QModelIndex& index) const {
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

int DestructableListModel::rowCount(const QModelIndex& parent) const {
	return sourceModel()->rowCount();
}

int DestructableListModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

QModelIndex DestructableListModel::index(int row, int column, const QModelIndex& parent) const {
	return createIndex(row, column);
}

QModelIndex DestructableListModel::parent(const QModelIndex& child) const {
	return QModelIndex();
}

bool DestructableListFilter::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const {
	QModelIndex index0 = sourceModel()->index(sourceRow, 0);

	if (!filterRegularExpression().pattern().isEmpty()) {
		return sourceModel()->data(index0).toString().contains(filterRegularExpression());
	} else {
		const std::string tilesets = destructibles_slk.data("tilesets", sourceRow);
		return QString::fromStdString(destructibles_slk.data("category", sourceRow)) == filterCategory && (tilesets.find('*') != std::string::npos || tilesets.find(filterTileset) != std::string::npos || filterTileset == '*');;
	}
}

bool DestructableListFilter::lessThan(const QModelIndex& left, const QModelIndex& right) const {
	return destructibles_slk.data("name", left.row()) < destructibles_slk.data("name", right.row());
}

void DestructableListFilter::setFilterCategory(QString category) {
	filterCategory = category;
	invalidateFilter();
}

void DestructableListFilter::setFilterTileset(char tileset) {
	filterTileset = tileset;
	invalidateFilter();
}
```

`src/Models/DestructableListModel.h`:

```h
#pragma once

#include <QIdentityProxyModel>
#include <QSortFilterProxyModel>
#include <QIconResource.h>

class DestructableListModel : public QIdentityProxyModel {
	Q_OBJECT

public:
	explicit DestructableListModel(QObject* parent = nullptr);

	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override;
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	Qt::ItemFlags flags(const QModelIndex& index) const override;

	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& child) const override;

private:
	std::unordered_map<char, std::shared_ptr<QIconResource>> icons;
};

class DestructableListFilter : public QSortFilterProxyModel {
	bool filterAcceptsRow(int sourceRow,const QModelIndex& sourceParent) const override;
	bool lessThan(const QModelIndex& left,const QModelIndex& right) const override;
	QString filterCategory = "";
	char filterTileset = '*';

public:
	void setFilterCategory(QString category);
	void setFilterTileset(char tileset);
	using QSortFilterProxyModel::QSortFilterProxyModel;
};
```

`src/Models/DestructibleTreeModel.cpp`:

```cpp
#include "DestructibleTreeModel.h"

DestructibleTreeModel::DestructibleTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &destructibles_slk;

	for (const auto& [key, value] : world_edit_data.section("DestructibleCategories")) {
		categories[key.front()].name = value[0];
		categories[key.front()].icon = resource_manager.load<QIconResource>(value[1]);
		categories[key.front()].item = new BaseTreeItem(rootItem);
		categories[key.front()].item->baseCategory = true;
		rowToCategory.push_back(key.front());
	}

	for (const auto& [id, index] : destructibles_slk.row_headers) {
		BaseTreeItem* item = new BaseTreeItem(getFolderParent(id));
		item->id = id;
		items.emplace(id, item);
	}

	categoryChangeFields = { "category" };
}

BaseTreeItem* DestructibleTreeModel::getFolderParent(const std::string& id) const {
	std::string category = destructibles_slk.data("category", id);

	return categories.at(category.front()).item;
}

QVariant DestructibleTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else {
				return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
			}
		case Qt::DecorationRole:
			if (item->baseCategory || item->subCategory) {
				return folderIcon;
			}

			return categories.at(rowToCategory[index.parent().row()]).icon->icon;
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/DestructibleTreeModel.h`:

```h
#pragma once

#include <array>

#include "BaseTreeModel.h"
#include "QIconResource.h"

class DestructibleTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		std::shared_ptr<QIconResource> icon;
		BaseTreeItem* item;
	};

	std::unordered_map<char, Category> categories;
	std::vector<char> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override;

public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit DestructibleTreeModel(QObject* parent = nullptr);
};
```

`src/Models/DoodadListModel.cpp`:

```cpp
#include "DoodadListModel.h"

#include "Globals.h"

DoodadListModel::DoodadListModel(QObject* parent) : QIdentityProxyModel(parent) {
	for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
		const std::string tileset_key = value.front();
		icons[key.front()] = resource_manager.load<QIconResource>(value[1]);
	}
}

QModelIndex DoodadListModel::mapFromSource(const QModelIndex& sourceIndex) const {
	if (!sourceIndex.isValid()) {
		return {};
	}

	return createIndex(sourceIndex.row(), 0);
}

QModelIndex DoodadListModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	return sourceModel()->index(proxyIndex.row(), doodads_slk.column_headers.at("name"));
}

QVariant DoodadListModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	switch (role) {
		case Qt::DisplayRole:
			return sourceModel()->data(mapToSource(index), role).toString();
		case Qt::DecorationRole: {
			char category = doodads_slk.data("category", index.row()).front();
			if (icons.contains(category)) {
				return icons.at(category)->icon;
			} else {
				return {};
			}
		}
		case Qt::SizeHintRole:
			return QSize(0, 16);
		default:
			return sourceModel()->data(mapToSource(index), role);
	}
}

Qt::ItemFlags DoodadListModel::flags(const QModelIndex& index) const {
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

int DoodadListModel::rowCount(const QModelIndex& parent) const {
	return sourceModel()->rowCount();
}

int DoodadListModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

QModelIndex DoodadListModel::index(int row, int column, const QModelIndex& parent) const {
	return createIndex(row, column);
}

QModelIndex DoodadListModel::parent(const QModelIndex& child) const {
	return QModelIndex();
}

bool DoodadListFilter::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const {
	QModelIndex index0 = sourceModel()->index(sourceRow, 0);

	if (!filterRegularExpression().pattern().isEmpty()) {
		return sourceModel()->data(index0).toString().contains(filterRegularExpression());
	} else {
		const std::string tilesets = doodads_slk.data("tilesets", sourceRow);
		return QString::fromStdString(doodads_slk.data("category", sourceRow)) == filterCategory && (tilesets.find('*') != std::string::npos || tilesets.find(filterTileset) != std::string::npos || filterTileset == '*');
	}
}

bool DoodadListFilter::lessThan(const QModelIndex& left, const QModelIndex& right) const {
	return doodads_slk.data("name", left.row()) < doodads_slk.data("name", right.row());
}

void DoodadListFilter::setFilterCategory(QString category) {
	filterCategory = category;
	invalidateFilter();
}

void DoodadListFilter::setFilterTileset(char tileset) {
	filterTileset = tileset;
	invalidateFilter();
}
```

`src/Models/DoodadListModel.h`:

```h
#pragma once

#include <QIdentityProxyModel>
#include <QSortFilterProxyModel>
#include <QIconResource.h>

class DoodadListModel : public QIdentityProxyModel {
	Q_OBJECT

public:
	explicit DoodadListModel(QObject* parent = nullptr);

	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override;
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	Qt::ItemFlags flags(const QModelIndex& index) const override;

	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& child) const override;

private:
	std::unordered_map<char, std::shared_ptr<QIconResource>> icons;
};

class DoodadListFilter : public QSortFilterProxyModel {
	bool filterAcceptsRow(int sourceRow,const QModelIndex& sourceParent) const override;
	bool lessThan(const QModelIndex& left,const QModelIndex& right) const override;
	QString filterCategory = "";
	char filterTileset = '*';

public:
	void setFilterCategory(QString category);
	void setFilterTileset(char tileset);
	using QSortFilterProxyModel::QSortFilterProxyModel;
};
```

`src/Models/DoodadTreeModel.cpp`:

```cpp
#include "DoodadTreeModel.h"

DoodadTreeModel::DoodadTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &doodads_slk;

	for (const auto& [key, value] : world_edit_data.section("DoodadCategories")) {
		categories[key.front()].name = value[0];
		categories[key.front()].icon = resource_manager.load<QIconResource>(value[1]);
		categories[key.front()].item = new BaseTreeItem(rootItem);
		categories[key.front()].item->baseCategory = true;
		rowToCategory.push_back(key.front());
	}

	for (size_t i = 0; i < doodads_slk.rows(); i++) {
		const std::string& id = doodads_slk.index_to_row.at(i);
		BaseTreeItem* item = new BaseTreeItem(getFolderParent(id));
		item->id = id;
		items.emplace(id, item);
	}

	categoryChangeFields = { "category" };
}

BaseTreeItem* DoodadTreeModel::getFolderParent(const std::string& id) const {
	std::string category = doodads_slk.data("category", id);

	return categories.at(category.front()).item;
}

QVariant DoodadTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else {
				return QAbstractProxyModel::data(index, role).toString();
			}
		case Qt::DecorationRole:
			if (item->baseCategory || item->subCategory) {
				return folderIcon;
			}

			return categories.at(rowToCategory[index.parent().row()]).icon->icon;
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/DoodadTreeModel.h`:

```h
#pragma once

#include <array>

#include "BaseTreeModel.h"
#include "QIconResource.h"

class DoodadTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		std::shared_ptr<QIconResource> icon;
		BaseTreeItem* item;
	};


	std::unordered_map<char, Category> categories;
	std::vector<char> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override;

public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit DoodadTreeModel(QObject* parent = nullptr);
};
```

`src/Models/ItemTreeModel.cpp`:

```cpp
#include "ItemTreeModel.h"

ItemTreeModel::ItemTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &items_slk;

	for (const auto& [key, value] : unit_editor_data.section("itemClass")) {
		if (key == "Sort" || key == "NumValues") {
			continue;
		}

		categories[value[0]].name = value[1];
		categories[value[0]].item = new BaseTreeItem(rootItem);
		categories[value[0]].item->baseCategory = true;
		rowToCategory.push_back(value[0]);
	}

	for (int i = 0; i < items_slk.rows(); i++) {
		const std::string& id = items_slk.index_to_row.at(i);

		BaseTreeItem* parent_item = getFolderParent(id);
		if (!parent_item) {
			continue;
		}
		BaseTreeItem* item = new BaseTreeItem(parent_item);
		item->id = id;
		items.emplace(id, item);
	}

	categoryChangeFields = { "class" };
}

BaseTreeItem* ItemTreeModel::getFolderParent(const std::string& id) const {
	std::string itemClass = items_slk.data("class", id);
	if (itemClass.empty()) {
		std::cout << "Empty class for " << id << " in items\n";
		return nullptr;
	}

	return categories.at(itemClass).item;
}

QVariant ItemTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else {
				return QAbstractProxyModel::data(index, role);
			}
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/ItemTreeModel.h`:

```h
#pragma once

#include <array>

#include "BaseTreeModel.h"

class ItemTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	std::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override;

public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit ItemTreeModel(QObject* parent = nullptr);
};
```

`src/Models/SingleModel.cpp`:

```cpp
#include "SingleModel.h"

#include <QPen>
#include <QPainter>
#include <QLineEdit>
#include <QComboBox>
#include <QDialog>
#include <QPlainTextEdit>
#include <QDialogButtonBox>
#include <QTimer>
#include <QSpinBox>
#include <QCheckBox>
#include <QListWidget>
#include <QPushButton>
#include <QTreeView>
#include <QVBoxLayout>
#include <QHBoxLayout>

#include "UnitSelector.h"
#include "GenericSelectorList.h"
#include "IconView.h"
#include "AbilityTreeModel.h"

#include "fmt/format.h"

SingleModel::SingleModel(TableModel* table, QObject* parent) : QAbstractProxyModel(parent) {
	slk = table->slk;
	meta_slk = table->meta_slk;
	setSourceModel(table);
	connect(this, &SingleModel::dataChanged, [this](const auto& index) {
		if (!index.isValid()) {
			return;
		}
		if (id_mapping[index.row()].field == "levels" || id_mapping[index.row()].field == "maxlevel" || id_mapping[index.row()].field == "numvar") {
			buildMapping();
		}
	});
}

QModelIndex SingleModel::mapFromSource(const QModelIndex& sourceIndex) const {
	if (!sourceIndex.isValid()) {
		return {};
	}

	if (sourceIndex.row() != slk->row_headers.at(id)) {
		fmt::print("Invalid ID for SLK {}\n", id);
		return {};
	}

	const std::string& field = slk->index_to_column.at(sourceIndex.column());
	for (size_t i = 0; i < id_mapping.size(); i++) {
		if (id_mapping[i].field == field) {
			//fmt::print("Found {} at {} {} {}\n", field, i, headerData(i, Qt::Vertical, Qt::DisplayRole).toString().toStdString(), meta_slk->data("displayname", id_mapping[i].key));
			return createIndex(i, 0);
		}
	}
	fmt::print("Not found {}\t{}\n", sourceIndex.row(), sourceIndex.column());
	return {};
}

QModelIndex SingleModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	const std::string& column = id_mapping[proxyIndex.row()].field;
	return sourceModel()->index(slk->row_headers.at(id), slk->column_headers.at(column));
}

QVariant SingleModel::data(const QModelIndex& index, int role) const {
	if (role != Qt::ForegroundRole) {
		return QAbstractProxyModel::data(index, role);
	}

	if (slk->shadow_data.contains(id) && slk->shadow_data.at(id).contains(id_mapping[index.row()].field)) {
		return QColor("violet");
	}

	return {};
}

QVariant SingleModel::headerData(int section, Qt::Orientation orientation, int role) const {
	if (role == Qt::DisplayRole) {
		if (orientation == Qt::Orientation::Vertical) {
			std::string category = world_edit_data.data("ObjectEditorCategories", meta_slk->data("category", id_mapping[section].key));
			category = string_replaced(category, "&", "");
			std::string display_name = meta_slk->data("displayname", id_mapping[section].key);

			int level = id_mapping[section].level;

			if (id_mapping[section].level > 0) {
				return QString::fromStdString(fmt::format("{} - {} - Level {} ({})", category, display_name, id_mapping[section].level, id_mapping[section].key));
			} else {
				return QString::fromStdString(fmt::format("{} - {} ({})", category, display_name, id_mapping[section].key));
			}
		} else {
			return "UnitID";
		}
	} else if (role == Qt::ForegroundRole) {
		if (orientation == Qt::Orientation::Vertical) {
			if (slk->shadow_data.contains(id) && slk->shadow_data.at(id).contains(id_mapping[section].field)) {
				return QColor("violet");
			} else {
				return QColor("white");
			}
		}
	}
	return {};
}

int SingleModel::rowCount(const QModelIndex& parent) const {
	return id_mapping.size();
}

int SingleModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

QModelIndex SingleModel::index(int row, int column, const QModelIndex& parent) const {
	return createIndex(row, column);
}

QModelIndex SingleModel::parent(const QModelIndex& child) const {
	return QModelIndex();
}

void SingleModel::setSourceModel(QAbstractItemModel* sourceModel) {
	beginResetModel();

	if (this->sourceModel()) {
		disconnect(sourceModel, &QAbstractItemModel::dataChanged, this, &SingleModel::sourceDataChanged);
	}

	QAbstractProxyModel::setSourceModel(sourceModel);

	connect(sourceModel, &QAbstractItemModel::dataChanged, this, &SingleModel::sourceDataChanged);

	endResetModel();
}

std::string SingleModel::getID() const {
	return id;
}

void SingleModel::setID(const std::string newID) {
	id = newID;
	buildMapping();
}

void SingleModel::buildMapping() {
	beginResetModel();
	id_mapping.clear();

	for (const auto& [key, index] : meta_slk->row_headers) {
		if (meta_slk->column_headers.contains("usespecific")) {
			if (!meta_slk->data("usespecific", key).empty() && meta_slk->data("usespecific", key).find(id) == std::string::npos) {
				continue;
			}
		}

		std::string field_name = to_lowercase_copy(meta_slk->data("field", key));
		if (meta_slk->column_headers.contains("data") && meta_slk->data<int>("data", key) > 0) {
			field_name += static_cast<char>('a' + (meta_slk->data<int>("data", key) - 1));
		}

		if (meta_slk->column_headers.contains("repeat") && meta_slk->data<int>("repeat", key) > 0) {
			int iterations = 1;
			if (slk->column_headers.contains("levels")) {
				iterations = slk->data<int>("levels", id);
			} else if (slk->column_headers.contains("numvar")) {
				iterations = slk->data<int>("numvar", id);
			} else if (slk->column_headers.contains("maxlevel")) {
				iterations = slk->data<int>("maxlevel", id);
			}

			for (int i = 0; i < iterations; i++) {

				std::string new_field_name;
				if (meta_slk->column_headers.contains("appendindex") && meta_slk->data<int>("appendindex", key) > 0) {
					if (i == 0) {
						new_field_name = field_name;
					} else {
						new_field_name = field_name + std::to_string(i);
					}
				} else {
					new_field_name = field_name + std::to_string(i + 1);
				}


				// We add a virtual column if it does not exist in the base table
				if (!slk->column_headers.contains(new_field_name)) {
					slk->add_column(new_field_name);
				}

				id_mapping.push_back({ key, new_field_name, i + 1 });
			}
		} else {
			// We add a virtual column if it does not exist in the base table
			if (!slk->column_headers.contains(field_name)) {
				slk->add_column(field_name);
			}

			id_mapping.push_back({ key, field_name, 0 });
		}
	}

	std::sort(id_mapping.begin(), id_mapping.end(), [&](const auto& left, const auto& right) {
		std::string category = world_edit_data.data("ObjectEditorCategories", meta_slk->data("category", left.key));
		//category = string_replaced(category, "&", "");
		const std::string left_string = category + " - " + meta_slk->data("displayname", left.key) + left.field;

		category = world_edit_data.data("ObjectEditorCategories", meta_slk->data("category", right.key));
		//category = string_replaced(category, "&", "");
		const std::string right_string = category + " - " + meta_slk->data("displayname", right.key) + right.field;

		return left_string < right_string;
	});
	endResetModel();
}

void SingleModel::sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles) {
	Q_ASSERT(topLeft.isValid() ? topLeft.model() == sourceModel() : true);
	Q_ASSERT(bottomRight.isValid() ? bottomRight.model() == sourceModel() : true);

	emit dataChanged(mapFromSource(topLeft), mapFromSource(bottomRight), roles);
}

void AlterHeader::paintSection(QPainter* painter, const QRect& rect, int logicalIndex) const {
	Qt::Alignment align = (Qt::AlignLeft | Qt::AlignVCenter);

	if (logicalIndex % 2 > 0) {
		painter->fillRect(rect, palette().color(QPalette::AlternateBase));
	} else {
		painter->fillRect(rect, palette().color(QPalette::Base));
	}


	painter->setPen(QPen(model()->headerData(logicalIndex, orientation(), Qt::ForegroundRole).value<QColor>()));
	painter->drawText(rect.adjusted(2 * style()->pixelMetric(QStyle::PM_HeaderMargin, 0, this), 0, 0, 0), align, model()->headerData(logicalIndex, orientation(), Qt::DisplayRole).toString());
	painter->setPen(QPen(palette().color(QPalette::Base)));
	painter->drawLine(rect.x(), rect.bottom(), rect.right(), rect.bottom());
}

TableDelegate::TableDelegate(QWidget* parent) : QStyledItemDelegate(parent) {
}

// ToDo look into splitting/simplifying the following functions 
QWidget* TableDelegate::createEditor(QWidget* parent, const QStyleOptionViewItem&, const QModelIndex& index) const {
	auto model = static_cast<const SingleModel*>(index.model());
	auto& mapping = model->getMapping();

	std::string type = model->meta_slk->data("type", mapping[index.row()].key);
	std::string minVal = model->meta_slk->data("minval", mapping[index.row()].key);
	std::string maxVal = model->meta_slk->data("maxval", mapping[index.row()].key);

	if (type == "int") {
		QSpinBox* editor = new QSpinBox(parent);

		// handle empty minVal, maxVal
		editor->setMinimum(std::stoi(minVal));
		editor->setMaximum(std::stoi(maxVal));
		editor->setSingleStep(std::clamp((std::stoi(maxVal) - std::stoi(minVal)) / 10, 1, 10));
		return editor;
	} else if (type == "real" || type == "unreal") {
		QDoubleSpinBox* editor = new QDoubleSpinBox(parent);
		editor->setMinimum(std::stod(minVal));
		editor->setMaximum(std::stod(maxVal));
		editor->setSingleStep(std::clamp((std::stod(maxVal) - std::stod(minVal)) / 10.0, 0.1, 10.0));
		return editor;
	} else if (type == "string") {
		QLineEdit* editor = new QLineEdit(parent);
//		editor->setMaxLength(std::stoi(maxVal));
		return editor;
	} else if (type == "targetList") {
		QDialog* dialog = new QDialog(parent, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		dialog->setWindowModality(Qt::WindowModality::WindowModal);

		QVBoxLayout* layout = new QVBoxLayout(dialog);
		QGridLayout* flow = new QGridLayout;

		for (const auto& [key, value] : unit_editor_data.section(type)) {
			if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
				continue;
			}

			QString displayText = QString::fromStdString(value[1]);
			displayText.replace('&', "");

			QCheckBox* flag = new QCheckBox(displayText);
			flag->setObjectName(QString::fromStdString(value[0]));

			flow->addWidget(flag);
		}

		QDialogButtonBox* buttonBox = new QDialogButtonBox;
		buttonBox->setStandardButtons(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
		connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

		layout->addLayout(flow);
		layout->addWidget(buttonBox);

		dialog->show();

		return dialog;
	} else if (type == "unitList") {
		QDialog* dialog = new QDialog(parent, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		dialog->resize(256, 360);
		dialog->setWindowModality(Qt::WindowModality::WindowModal);

		QVBoxLayout* layout = new QVBoxLayout(dialog);

		QListWidget* list = new QListWidget;
		list->setObjectName("unitList");
		list->setIconSize(QSize(32, 32));
		list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
		layout->addWidget(list);

		QHBoxLayout* hbox = new QHBoxLayout;

		QPushButton* add = new QPushButton("Add");
		QPushButton* remove = new QPushButton("Remove");
		remove->setDisabled(true);
		hbox->addWidget(add);
		hbox->addWidget(remove);
		layout->addLayout(hbox);
		connect(add, &QPushButton::clicked, [=]() {
			QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
			selectdialog->resize(300, 560);
			selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

			QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);

			UnitSelector* selector = new UnitSelector(selectdialog);
			selectlayout->addWidget(selector);

			QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
			connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
			connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
			selectlayout->addWidget(buttonBox2);

			connect(selector, &UnitSelector::unitSelected, [selectdialog, list](const std::string& id) {
				QListWidgetItem* item = new QListWidgetItem;
				item->setText(QString::fromStdString(units_slk.data("name", id)));
				item->setData(Qt::StatusTipRole, QString::fromStdString(id));
				auto one = units_slk.row_headers.at(id);
				auto two = units_slk.column_headers.at("art");
				item->setIcon(units_table->data(units_table->index(one, two), Qt::DecorationRole).value<QIcon>());
				list->addItem(item);
				selectdialog->close();
			});

			connect(selectdialog, &QDialog::accepted, selector, &UnitSelector::forceSelection);

			selectdialog->show();
			selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
		});
		connect(remove, &QPushButton::clicked, [=]() {
			for (auto i : list->selectedItems()) {
				delete i;
			}
		});
		connect(list, &QListWidget::itemSelectionChanged, [=]() {
			remove->setEnabled(list->selectedItems().size() > 0);
		});

		QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
		connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
		layout->addWidget(buttonBox);

		dialog->show();

		return dialog;
	} else if (type == "abilityList" || type == "heroAbilityList" || type == "abilitySkinList") {
		QDialog* dialog = new QDialog(parent, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		dialog->resize(256, 360);
		dialog->setWindowModality(Qt::WindowModality::WindowModal);

		QVBoxLayout* layout = new QVBoxLayout(dialog);

		QListWidget* list = new QListWidget;
		list->setObjectName("abilityList");
		list->setIconSize(QSize(32, 32));
		list->setDragDropMode(QAbstractItemView::DragDropMode::InternalMove);
		layout->addWidget(list);

		QHBoxLayout* hbox = new QHBoxLayout;

		QPushButton* add = new QPushButton("Add");
		QPushButton* remove = new QPushButton("Remove");
		remove->setDisabled(true);
		hbox->addWidget(add);
		hbox->addWidget(remove);
		layout->addLayout(hbox);
		connect(add, &QPushButton::clicked, [=]() {
			QDialog* selectdialog = new QDialog(dialog, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
			selectdialog->resize(300, 560);
			selectdialog->setWindowModality(Qt::WindowModality::WindowModal);

			QVBoxLayout* selectlayout = new QVBoxLayout(selectdialog);

			AbilityTreeModel* abilityTreeModel = new AbilityTreeModel(dialog);
			abilityTreeModel->setSourceModel(abilities_table);
			QSortFilterProxyModel* filter = new QSortFilterProxyModel;
			filter->setSourceModel(abilityTreeModel);
			filter->setRecursiveFilteringEnabled(true);
			filter->setFilterCaseSensitivity(Qt::CaseSensitivity::CaseInsensitive);

			QLineEdit* search = new QLineEdit;
			search->setPlaceholderText("Search Abilities");
			QTreeView* view = new QTreeView;
			view->setModel(filter);
			view->header()->hide();
			view->expandAll();

			connect(search, &QLineEdit::textChanged, filter, QOverload<const QString&>::of(&QSortFilterProxyModel::setFilterFixedString));

			selectlayout->addWidget(search);
			selectlayout->addWidget(view);

			QDialogButtonBox* buttonBox2 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
			connect(buttonBox2, &QDialogButtonBox::accepted, selectdialog, &QDialog::accept);
			connect(buttonBox2, &QDialogButtonBox::rejected, selectdialog, &QDialog::reject);
			selectlayout->addWidget(buttonBox2);


			auto add = [filter, list, selectdialog](const QModelIndex& index) {
				QModelIndex sourceIndex = filter->mapToSource(index);
				BaseTreeItem* treeItem = static_cast<BaseTreeItem*>(sourceIndex.internalPointer());
				if (treeItem->baseCategory || treeItem->subCategory) {
					return;
				}

				fmt::print("Valid\n");

				QListWidgetItem* item = new QListWidgetItem;
				item->setText(QString::fromStdString(abilities_slk.data("name", treeItem->id)));
				item->setData(Qt::StatusTipRole, QString::fromStdString(treeItem->id));
				auto one = abilities_slk.row_headers.at(treeItem->id);
				auto two = abilities_slk.column_headers.at("art");
				item->setIcon(abilities_table->data(abilities_table->index(one, two), Qt::DecorationRole).value<QIcon>());
				list->addItem(item);
				selectdialog->close();
			};

			connect(view, &QTreeView::activated, [=](const QModelIndex& index) {
				add(index);
			});
			
			connect(selectdialog, &QDialog::accepted, [=]() {
				auto indices = view->selectionModel()->selectedIndexes();
				if (indices.size()) {
					add(indices.front());
				}
			});

			selectdialog->show();
			selectdialog->move(dialog->geometry().topRight() + QPoint(10, dialog->geometry().height() - selectdialog->geometry().height()));
		});
		connect(remove, &QPushButton::clicked, [=]() {
			for (auto i : list->selectedItems()) {
				delete i;
			}
		});
		connect(list, &QListWidget::itemSelectionChanged, [=]() {
			remove->setEnabled(list->selectedItems().size() > 0);
		});

		QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
		connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
		layout->addWidget(buttonBox);

		dialog->show();

		return dialog;
	} else if (type.ends_with("List")) {
		QDialog* dialog = new QDialog(parent, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		dialog->setWindowModality(Qt::WindowModality::WindowModal);
		
		QVBoxLayout* layout = new QVBoxLayout(dialog);

		QPlainTextEdit* editor = new QPlainTextEdit;
		editor->setObjectName("editor");

		QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
		connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

		layout->addWidget(editor);
		layout->addWidget(buttonBox);

		dialog->show();

		return dialog;
	} else if (unit_editor_data.section_exists(type)) {
		QComboBox* editor = new QComboBox(parent);
		for (const auto& [key, value] : unit_editor_data.section(type)) {
			if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
				continue;
			}

			QString displayText = QString::fromStdString(value[1]);
			displayText.replace('&', "");

			editor->addItem(displayText, QString::fromStdString(value[0]));
		}
		return editor;
	} else if (type == "icon") {
		QDialog* dialog = new QDialog(parent, Qt::WindowTitleHint | Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint);
		dialog->resize(530, 512);
		dialog->setWindowModality(Qt::WindowModality::WindowModal);

		IconView* view = new IconView;
		view->setObjectName("iconView");

		QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
		connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);

		QVBoxLayout* layout = new QVBoxLayout(dialog);
		layout->addWidget(view);
		layout->addWidget(buttonBox);

		dialog->show();
		return dialog;
	} else if (type == "doodadCategory") {
		QComboBox* editor = new QComboBox(parent);
		for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
			editor->addItem(QString::fromStdString(value[0]), QString::fromStdString(key));
		}
		return editor;
	} else if (type == "destructableCategory") {
		QComboBox* editor = new QComboBox(parent);
		for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
			editor->addItem(QString::fromStdString(value[0]), QString::fromStdString(key));
		}
		return editor;
	} else {
		return new QLineEdit(parent);
	}
}

void TableDelegate::setEditorData(QWidget* editor, const QModelIndex& index) const {
	auto model = static_cast<const SingleModel*>(index.model());
	auto& mapping = model->getMapping();

	std::string type = model->meta_slk->data("type", mapping[index.row()].key);

	if (type == "int") {
		static_cast<QSpinBox*>(editor)->setValue(model->data(index, Qt::EditRole).toInt());
	} else if (type == "real" || type == "unreal") {
		static_cast<QDoubleSpinBox*>(editor)->setValue(model->data(index, Qt::EditRole).toDouble());
	} else if (type == "string") {
		static_cast<QLineEdit*>(editor)->setText(model->data(index, Qt::EditRole).toString());
	} else if (type == "targetList") {
		auto parts = model->data(index, Qt::EditRole).toString().split(',');
		for (const auto& i : parts) {
			QCheckBox* box = editor->findChild<QCheckBox*>(i);
			if (box) {
				box->setChecked(true);
			}
		}
	} else if (type == "unitList") {
		QListWidget* list = editor->findChild<QListWidget*>("unitList");

		auto parts = model->data(index, Qt::EditRole).toString().split(',', Qt::SkipEmptyParts);
		for (const auto& i : parts) {
			QListWidgetItem* item = new QListWidgetItem;
			item->setText(QString::fromStdString(units_slk.data("name", i.toStdString())));
			item->setData(Qt::StatusTipRole, i);
			auto one = units_slk.row_headers.at(i.toStdString());
			auto two = units_slk.column_headers.at("art");
			item->setIcon(units_table->data(units_table->index(one, two), Qt::DecorationRole).value<QIcon>());
			list->addItem(item);
		}
	} else if (type == "abilityList" || type == "heroAbilityList" || type == "abilitySkinList") {
		QListWidget* list = editor->findChild<QListWidget*>("abilityList");

		auto parts = model->data(index, Qt::EditRole).toString().split(',', Qt::SkipEmptyParts);
		for (const auto& i : parts) {
			QListWidgetItem* item = new QListWidgetItem;
			item->setText(QString::fromStdString(abilities_slk.data("name", i.toStdString())));
			item->setData(Qt::StatusTipRole, i);
			auto one = abilities_slk.row_headers.at(i.toStdString());
			auto two = abilities_slk.column_headers.at("art");
			item->setIcon(abilities_table->data(abilities_table->index(one, two), Qt::DecorationRole).value<QIcon>());
			list->addItem(item);
		}
	} else if (type.ends_with("List")) {
		editor->findChild<QPlainTextEdit*>("editor")->setPlainText(model->data(index, Qt::EditRole).toString());
	} else if (unit_editor_data.section_exists(type)) {
		auto combo = static_cast<QComboBox*>(editor);
		// Find the item with the right userdata and set it as current index
		for (int i = 0; i < combo->count(); i++) {
			if (combo->itemData(i, Qt::UserRole).toString() == model->data(index, Qt::EditRole).toString()) {
				combo->setCurrentIndex(i);
			}
		}
	} else if (type == "icon") {
		IconView* list = editor->findChild<IconView*>("iconView");
		list->setCurrentIconPath(model->data(index, Qt::EditRole).toString());
	} else if (type == "doodadCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		for (int i = 0; i < combo->count(); i++) {
			if (combo->itemData(i, Qt::UserRole).toString() == model->data(index, Qt::EditRole).toString()) {
				combo->setCurrentIndex(i);
			}
		}
	} else if (type == "destructableCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		for (int i = 0; i < combo->count(); i++) {
			if (combo->itemData(i, Qt::UserRole).toString() == model->data(index, Qt::EditRole).toString()) {
				combo->setCurrentIndex(i);
			}
		}
	} else {
		static_cast<QLineEdit*>(editor)->setText(model->data(index, Qt::EditRole).toString());
	}
}

void TableDelegate::setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex& index) const {
	auto singlemodel = static_cast<SingleModel*>(model);
	auto& mapping = singlemodel->getMapping();

	std::string type = singlemodel->meta_slk->data("type", mapping[index.row()].key);

	if (type == "int") {
		singlemodel->setData(index, static_cast<QSpinBox*>(editor)->value());
	} else if (type == "real" || type == "unreal") {
		singlemodel->setData(index, static_cast<QDoubleSpinBox*>(editor)->value());
	} else if (type == "string") {
		singlemodel->setData(index, static_cast<QLineEdit*>(editor)->text());
	} else if (type == "unitList") {
		auto fd = dynamic_cast<QDialog*>(editor);
		if (!fd || fd->result() == QDialog::Rejected) {
			return;
		}
		QListWidget* list = editor->findChild<QListWidget*>("unitList");

		QString result;
		for (int i = 0; i < list->count(); i++) {
			QListWidgetItem* item = list->item(i);
			if (!result.isEmpty()) {
				result += ',';
			}
			result += item->data(Qt::StatusTipRole).toString();
		}
		model->setData(index, result, Qt::EditRole);
	} else if (type == "abilityList" || type == "heroAbilityList" || type == "abilitySkinList") {
		auto fd = dynamic_cast<QDialog*>(editor);
		if (!fd || fd->result() == QDialog::Rejected) {
			return;
		}
		QListWidget* list = editor->findChild<QListWidget*>("abilityList");

		QString result;
		for (int i = 0; i < list->count(); i++) {
			QListWidgetItem* item = list->item(i);
			if (!result.isEmpty()) {
				result += ',';
			}
			result += item->data(Qt::StatusTipRole).toString();
		}
		model->setData(index, result, Qt::EditRole);
	} else if (type == "targetList") {
		auto fd = dynamic_cast<QDialog*>(editor);
		if (!fd || fd->result() == QDialog::Rejected) {
			return;
		}
		QString result;
		for (const auto& [key, value] : unit_editor_data.section(type)) {
			if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
				continue;
			}

			QCheckBox* box = editor->findChild<QCheckBox*>(QString::fromStdString(value[0]));
			if (box && box->isChecked()) {
				if (!result.isEmpty()) {
					result += ",";
				}
				result += QString::fromStdString(value[0]);
			}
		}
		model->setData(index, result, Qt::EditRole);

	}  else if (type.ends_with("List")) {
		auto fd = dynamic_cast<QDialog*>(editor);
		if (!fd || fd->result() == QDialog::Rejected) {
			return;
		}
		singlemodel->setData(index, editor->findChild<QPlainTextEdit*>("editor")->toPlainText());
	} else if (unit_editor_data.section_exists(type)) {
		auto combo = static_cast<QComboBox*>(editor);
		singlemodel->setData(index, combo->currentData());
	} else if (type == "icon") {
		auto fd = dynamic_cast<QDialog*>(editor);
		if (!fd || fd->result() == QDialog::Rejected) {
			return;
		}

		IconView* list = editor->findChild<IconView*>("iconView");
		
		singlemodel->setData(index, list->currentIconPath());
	} else if (type == "doodadCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		singlemodel->setData(index, combo->currentData());
	} else if (type == "destructableCategory") {
		auto combo = static_cast<QComboBox*>(editor);
		singlemodel->setData(index, combo->currentData());
	} else {
		singlemodel->setData(index, static_cast<QLineEdit*>(editor)->text());
	}
}

void TableDelegate::updateEditorGeometry(QWidget* editor, const QStyleOptionViewItem& option, const QModelIndex&) const {
	if (dynamic_cast<QDialog*>(editor)) {
		
	} else {
		editor->setGeometry(option.rect);
	}
}
```

`src/Models/SingleModel.h`:

```h
#pragma once

#include <QAbstractProxyModel>
#include <QIdentityProxyModel>
#include <QHeaderView>
#include <QStyledItemDelegate>

#include <vector>

#include "TableModel.h"
#include "SLK.h"

class SingleModel : public QAbstractProxyModel {
	Q_OBJECT
		
public:
	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override;
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;
	
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role) const override;

	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& child) const override;

	void setSourceModel(QAbstractItemModel* sourceModel) override;

	explicit SingleModel(TableModel* table, QObject* parent = nullptr);
	void setID(const std::string id);
	std::string getID() const;

	struct Mapping {
		std::string key;
		std::string field;
		int level;
	};

	const std::vector<Mapping>& getMapping() const {
		return id_mapping;
	}

	slk::SLK* meta_slk;
private:
	void buildMapping();

	slk::SLK* slk;

	std::string id = "hpea";
	std::vector<Mapping> id_mapping;

	void sourceDataChanged(const QModelIndex& topLeft, const QModelIndex& bottomRight, const QVector<int>& roles);

};

// Provides row headers that have alternate colors
class AlterHeader : public QHeaderView {
	Q_OBJECT

public:
	using QHeaderView::QHeaderView;
protected:
	void paintSection(QPainter* painter, const QRect& rect, int logicalIndex) const;
};


class TableDelegate : public QStyledItemDelegate {
	Q_OBJECT

public:
	TableDelegate(QWidget* parent = nullptr);

	QWidget* createEditor(QWidget* parent, const QStyleOptionViewItem& option, const QModelIndex& index) const override;

	void setEditorData(QWidget* editor, const QModelIndex& index) const override;
	void setModelData(QWidget* editor, QAbstractItemModel* model, const QModelIndex& index) const override;

	void updateEditorGeometry(QWidget* editor, const QStyleOptionViewItem& option, const QModelIndex& index) const override;
};
```

`src/Models/TableModel.cpp`:

```cpp
#include "TableModel.h"
#include "QIconResource.h"
#include "Globals.h"

#include <absl/strings/str_split.h>

std::unordered_map<std::string, std::shared_ptr<QIconResource>> path_to_icon;

TableModel::TableModel(slk::SLK* slk, slk::SLK* meta_slk, QObject* parent) : QAbstractTableModel(parent), slk(slk), meta_slk(meta_slk) {
	/*for (const auto& [key, index] : meta_slk->row_headers) {
		meta_field_to_key.emplace(to_lowercase_copy(meta_slk->data("field", key)), key);
	}*/

	invalid_icon = resource_manager.load<QIconResource>("ReplaceableTextures/WorldEditUI/DoodadPlaceholder.dds");
}

int TableModel::rowCount(const QModelIndex& parent) const {
	return slk->rows();
}

int TableModel::columnCount(const QModelIndex& parent) const {
	return slk->columns();
}

QVariant TableModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	const std::string& id = slk->index_to_row.at(index.row());
	const std::string& field = slk->index_to_column.at(index.column());
	const std::string meta_id = fieldToMetaID(id, field);

	switch (role) {
		case Qt::DisplayRole: {
			const std::string field_data = slk->data(index.column(), index.row());

			if (field_data.starts_with("TRIGSTR")) {
				return QString::fromStdString(map->trigger_strings.string(field_data));
			}

			const std::string type = meta_slk->data("type", meta_id);
			if (type == "bool") {
				return field_data == "1" ? "true" : "false";
			} else if (type == "unitList") {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				QString result;
				for (size_t i = 0; i < parts.size(); i++) {
					if (!units_slk.row_headers.contains(parts[i])) {
						continue;
					}
					result += units_table->data(units_table->index(units_slk.row_headers.at(parts[i]), units_slk.column_headers.at("name")), role).toString();
					if (i < parts.size() - 1) {
						result += ", ";
					}
				}
				return result;
			} else if (type == "abilityList" || type == "abilitySkinList" || type == "heroAbilityList") {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				QString result;
				for (size_t i = 0; i < parts.size(); i++) {
					if (!abilities_slk.row_headers.contains(parts[i])) {
						continue;
					}
					result += abilities_table->data(abilities_table->index(abilities_slk.row_headers.at(parts[i]), abilities_slk.column_headers.at("name")), role).toString();
					if (i < parts.size() - 1) {
						result += ", ";
					}
				}
				return result;
			} else if (type == "upgradeList" ) {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				QString result;
				for (size_t i = 0; i < parts.size(); i++) {
					if (!upgrade_slk.row_headers.contains(parts[i])) {
						continue;
					}
					result += upgrade_table->data(upgrade_table->index(upgrade_slk.row_headers.at(parts[i]), upgrade_slk.column_headers.at("name1")), role).toString();
					if (i < parts.size() - 1) {
						result += ", ";
					}
				}
				return result;
			} else if (type == "buffList") {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				QString result;
				for (size_t i = 0; i < parts.size(); i++) {
					if (!buff_slk.row_headers.contains(parts[i])) {
						continue;
					}
					QString editorname = buff_table->data(buff_table->index(buff_slk.row_headers.at(parts[i]), buff_slk.column_headers.at("editorname")), role).toString();
					if (editorname.isEmpty()) {
						result += buff_table->data(buff_table->index(buff_slk.row_headers.at(parts[i]), buff_slk.column_headers.at("bufftip")), role).toString();
					} else {
						result += editorname;
					}

					if (i < parts.size() - 1) {
						result += ", ";
					}
				}
				return result;
			} else if (type == "targetList") {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				std::string result;
				for (size_t i = 0; i < parts.size(); i++) {
					for (const auto& [key, value] : unit_editor_data.section(type)) {
						if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
							continue;
						}
						
						if (value[0] == parts[i]) {
							result += value[1];
							if (i < parts.size() - 1) {
								result += ", ";
							}
						}
					}
				}
				QString result_qstring = QString::fromStdString(result);
				result_qstring.replace('&', "");
				return result_qstring;
			} else if (type == "tilesetList") {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				QString result;
				for (size_t i = 0; i < parts.size(); i++) {
					if (parts[i] == "*") {
						result += "All";
					} else {
						result += QString::fromStdString(world_edit_data.data("TileSets", std::string(parts[i])));
					}
					if (i < parts.size() - 1) {
						result += ", ";
					}
				}
				return result;
			} else if (unit_editor_data.section_exists(type)) {
				for (const auto& [key, value] : unit_editor_data.section(type)) {
					if (key == "NumValues" || key == "Sort" || key.ends_with("_Alt")) {
						continue;
					}

					if (slk->data(index.column(), index.row()) == value[0]) {
						QString displayText = QString::fromStdString(value[1]);
						displayText.replace('&', "");
						return displayText;
					}
				}
			} else if (type == "doodadCategory") {
				for (auto&& [key, value] : world_edit_data.section("DoodadCategories")) {
					if (field_data == key) {
						return QString::fromStdString(value[0]);
					}
				}
			} else if (type == "destructableCategory") {
				for (auto&& [key, value] : world_edit_data.section("DestructibleCategories")) {
					if (field_data == key) {
						return QString::fromStdString(value[0]);
					}
				}
			} else if (type == "techList") {
				std::vector<std::string_view> parts = absl::StrSplit(field_data, ',');
				QString result;
				for (size_t i = 0; i < parts.size(); i++) {
					if (units_slk.row_headers.contains(parts[i])) {
						result += units_table->data(units_table->index(units_slk.row_headers.at(parts[i]), units_slk.column_headers.at("name")), role).toString();
					} else if (upgrade_slk.row_headers.contains(parts[i])) {
						result += upgrade_table->data(upgrade_table->index(upgrade_slk.row_headers.at(parts[i]), upgrade_slk.column_headers.at("name1")), role).toString();
					} else {
						result += QString::fromStdString(std::string(parts[i]));
					}
					if (i < parts.size() - 1) {
						result += ", ";
					}
				}

				return result;
			}

			return QString::fromStdString(field_data);
		}
		case Qt::EditRole:
			return QString::fromStdString(slk->data(index.column(), index.row()));
		case Qt::CheckStateRole: {
			const std::string type = meta_slk->data("type", meta_id);
			if (type != "bool") {
				return {};
			}

			return (slk->data(index.column(), index.row()) == "1") ? Qt::Checked : Qt::Unchecked;
		}
		case Qt::DecorationRole:
			const std::string type = meta_slk->data("type", meta_id);
			if (type != "icon") {
				return {};
			}

			fs::path icon = slk->data(index.column(), index.row());
			if (icon.empty()) {
				return invalid_icon->icon;
			}

			if (path_to_icon.contains(icon.string())) {
				return path_to_icon.at(icon.string())->icon;
			}

			if (!hierarchy.file_exists(icon)) {
				icon.replace_extension(".dds");
				if (!hierarchy.file_exists(icon)) {
					return {};
				}
			}

			path_to_icon[icon.string()] = resource_manager.load<QIconResource>(icon);
			return path_to_icon.at(icon.string())->icon;
	}

	return {};
}

bool TableModel::setData(const QModelIndex& index, const QVariant& value, int role) {
	if (!index.isValid()) {
		return {};
	}

	switch (role) {
		case Qt::EditRole:
			slk->set_shadow_data(index.column(), index.row(), value.toString().toStdString());
			emit dataChanged(index, index, { Qt::DisplayRole, Qt::EditRole, Qt::DecorationRole });
			return true;
		case Qt::CheckStateRole: {
			const std::string& id = slk->index_to_row.at(index.row());
			const std::string& field = slk->index_to_column.at(index.column());
			const std::string type = meta_slk->data("type", fieldToMetaID(id, field));
			if (type != "bool") {
				return false;
			}

			slk->set_shadow_data(index.column(), index.row(), (value.toInt() == Qt::Checked) ? "1" : "0");
			emit dataChanged(index, index, { role });
			return true;
		}

	}
	return false;
}

QVariant TableModel::headerData(int section, Qt::Orientation orientation, int role) const {
	if (role != Qt::DisplayRole) {
		return {};
	}

	if (orientation == Qt::Orientation::Horizontal) {
		return QString::fromStdString(slk->data(section, 0));
	} else {
		return QString::fromStdString(slk->data(0, section));
	}
}

Qt::ItemFlags TableModel::flags(const QModelIndex& index) const {
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	Qt::ItemFlags flags = QAbstractTableModel::flags(index);

	const std::string& id = slk->index_to_row.at(index.row());
	const std::string& field = slk->index_to_column.at(index.column());
	const std::string type = meta_slk->data("type", fieldToMetaID(id, field));
	if (type == "bool") {
		flags |= Qt::ItemIsUserCheckable;
	}

	if (!(flags & Qt::ItemIsUserCheckable)) {
		flags |= Qt::ItemIsEditable;
	}

	return flags;
}

void TableModel::copyRow(std::string_view row_header, std::string_view new_row_header) {
	beginInsertRows(QModelIndex(), rowCount(), rowCount());

	slk->copy_row(row_header, new_row_header, true);
	endInsertRows();
}

void TableModel::deleteRow(const std::string_view row_header) {
	const int row = slk->row_headers.at(row_header);
	beginRemoveRows(QModelIndex(), row , row);

	slk->remove_row(row_header);
	endRemoveRows();
}

std::string TableModel::fieldToMetaID(const std::string& id, const std::string& field) const {
	if (meta_slk->meta_map.contains(field)) {
		return meta_slk->meta_map.at(field);
	}

	const size_t nr_position = field.find_first_of("0123456789");
	const std::string new_field = field.substr(0, nr_position);
	
	if (meta_slk->meta_map.contains(new_field)) {
		return meta_slk->meta_map.at(new_field);
	}

	return meta_slk->meta_map.at(new_field + id);
}
```

`src/Models/TableModel.h`:

```h
#pragma once

#include <QAbstractTableModel>

#include "QIconResource.h"
#include "SLK.h"

class TableModel : public QAbstractTableModel {
	//std::unordered_map<std::string, std::string> meta_field_to_key;
	std::shared_ptr<QIconResource> invalid_icon;

public: 
	slk::SLK* meta_slk;
	slk::SLK* slk;
	explicit TableModel(slk::SLK* slk, slk::SLK* meta_slk, QObject* parent = nullptr);
	
	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	bool setData(const QModelIndex& index, const QVariant& value, int role = Qt::EditRole) override;

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

	Qt::ItemFlags flags(const QModelIndex& index) const override;

	void copyRow(std::string_view row_header, std::string_view new_row_header);
	void deleteRow(const std::string_view);

	std::string fieldToMetaID(const std::string& id, const std::string& field) const;
};
```

`src/Models/UnitListModel.cpp`:

```cpp
#include "UnitListModel.h"

#include "Globals.h"

QModelIndex UnitListModel::mapFromSource(const QModelIndex& sourceIndex) const {
	if (!sourceIndex.isValid()) {
		return {};
	}

	return createIndex(sourceIndex.row(), 0);
}

QModelIndex UnitListModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	return sourceModel()->index(proxyIndex.row(), units_slk.column_headers.at("name"));
}

QVariant UnitListModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	switch (role) {
		case Qt::DisplayRole:
			return sourceModel()->data(mapToSource(index), role).toString() + " " + 
				sourceModel()->data(sourceModel()->index(index.row(), units_slk.column_headers.at("editorsuffix")), role).toString();
		case Qt::DecorationRole:
			return sourceModel()->data(sourceModel()->index(index.row(), units_slk.column_headers.at("art")), role);
		//case Qt::SizeHintRole:
			//return QSize(0, 24);
		default:
			return sourceModel()->data(mapToSource(index), role);
	}
}

Qt::ItemFlags UnitListModel::flags(const QModelIndex& index) const {
	if (!index.isValid()) {
		return Qt::NoItemFlags;
	}

	return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

int UnitListModel::rowCount(const QModelIndex& parent) const {
	return units_slk.rows();
}

int UnitListModel::columnCount(const QModelIndex& parent) const {
	return 1;
}

QModelIndex UnitListModel::index(int row, int column, const QModelIndex& parent) const {
	return createIndex(row, column);
}

QModelIndex UnitListModel::parent(const QModelIndex& child) const {
	return QModelIndex();
}

bool UnitListFilter::filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const {
	QModelIndex index0 = sourceModel()->index(sourceRow, 0);

	if (!filterRegularExpression().pattern().isEmpty()) {
		return sourceModel()->data(index0).toString().contains(filterRegularExpression());
	} else {
		return QString::fromStdString(units_slk.data(units_slk.column_headers.at("race"), sourceRow)) == filterRace;
	}
}

bool UnitListFilter::lessThan(const QModelIndex& left, const QModelIndex& right) const {

	QString leftIndex = "0";
	{
		bool isHostile = units_slk.data("hostilepal", left.row()) == "1";
		bool isBuilding = units_slk.data("isbldg", left.row()) == "1";
		bool isHero = isupper(units_slk.index_to_row.at(left.row()).front());
		bool isSpecial = units_slk.data("special", left.row()) == "1";

		if (isSpecial) {
			leftIndex = "3";
		} else if (isBuilding) {
			leftIndex = "1";
		} else if (isHero) {
			leftIndex = "2";
		}
		leftIndex += QString::fromStdString(units_slk.data("name", left.row()));
	}

	QString rightIndex = "0";
	{
		bool isHostile = units_slk.data("hostilepal", right.row()) == "1";
		bool isBuilding = units_slk.data("isbldg", right.row()) == "1";
		bool isHero = isupper(units_slk.index_to_row.at(right.row()).front());
		bool isSpecial = units_slk.data("special", right.row()) == "1";

		if (isSpecial) {
			rightIndex = "3";
		} else if (isBuilding) {
			rightIndex = "1";
		} else if (isHero) {
			rightIndex = "2";
		}
		rightIndex += QString::fromStdString(units_slk.data("name", right.row()));
	}

	return leftIndex < rightIndex;
}

void UnitListFilter::setFilterRace(QString race) {
	filterRace = race;
	invalidateFilter();
}
```

`src/Models/UnitListModel.h`:

```h
#pragma once

#include <QIdentityProxyModel>
#include <QSortFilterProxyModel>

class UnitListModel : public QIdentityProxyModel {
	Q_OBJECT

public:
	QModelIndex mapFromSource(const QModelIndex& sourceIndex) const override;
	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;

	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	Qt::ItemFlags flags(const QModelIndex& index) const override;

	int rowCount(const QModelIndex& parent = QModelIndex()) const override;
	int columnCount(const QModelIndex& parent = QModelIndex()) const override;

	QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
	QModelIndex parent(const QModelIndex& child) const override;

	using QIdentityProxyModel::QIdentityProxyModel;
};

class UnitListFilter : public QSortFilterProxyModel {
	Q_OBJECT

	bool filterAcceptsRow(int sourceRow,const QModelIndex& sourceParent) const override;
	bool lessThan(const QModelIndex& left,const QModelIndex& right) const override;
	QString filterRace = "human";

public:
	using QSortFilterProxyModel::QSortFilterProxyModel;
	
public slots:
	void setFilterRace(QString race);
};
```

`src/Models/UnitTreeModel.cpp`:

```cpp
#include "UnitTreeModel.h"

UnitTreeModel::UnitTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &units_slk;

	for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
		if (key == "Sort" || key == "NumValues") {
			continue;
		}

		categories[value[0]].name = value[1];
		categories[value[0]].item = new BaseTreeItem(rootItem);
		categories[value[0]].item->baseCategory = true;
		rowToCategory.push_back(value[0]);
	}

	for (const auto& i : rootItem->children) {
		for (const auto& subCategory : subCategories) {
			BaseTreeItem* item = new BaseTreeItem(i);
			item->subCategory = true;
		}
	}

	for (size_t i = 0; i < units_slk.rows(); i++) {
		const std::string id = units_slk.index_to_row.at(i); 
		BaseTreeItem* item = new BaseTreeItem(getFolderParent(id));
		item->id = id;
		items.emplace(id, item);	
	}

	categoryChangeFields = { "race", "isbldg", "special" };
}

BaseTreeItem* UnitTreeModel::getFolderParent(const std::string& id) const {
	std::string race = units_slk.data("race", id);
	bool isBuilding = units_slk.data("isbldg", id) == "1";
	bool isHero = isupper(id.front());
	bool isSpecial = units_slk.data("special", id) == "1";

	int subIndex = 0;
	if (isSpecial) {
		subIndex = 3;
	} else if (isBuilding) {
		subIndex = 1;
	} else if (isHero) {
		subIndex = 2;
	}

	return categories.at(race).item->children[subIndex];
}

QVariant UnitTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else if (item->subCategory) {
				return QString::fromStdString(subCategories[index.row()] + " (" + std::to_string(item->children.size()) + ")");
			} else {
				if (units_slk.data("campaign", item->id) == "1") {
					const std::string properNames = units_slk.data("propernames", item->id);

					if (!properNames.empty()) {
						return QString::fromStdString(properNames).split(',').first();
					}
				}

				return QAbstractProxyModel::data(index, role).toString() + " " + sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("editorsuffix")), role).toString();
			}
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/UnitTreeModel.h`:

```h
#pragma once

#include <array>

#include <QSortFilterProxyModel>

#include "Globals.h"
#include "BaseTreeModel.h"

class UnitTreeModel : public BaseTreeModel {
	Q_OBJECT

	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	std::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	std::array<std::string, 4> subCategories = {
		"Units",
		"Buildings",
		"Heroes",
		"Special",
	};

	BaseTreeItem* getFolderParent(const std::string& id) const override;
	
  public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit UnitTreeModel(QObject* parent = nullptr);
};
```

`src/Models/UpgradeTreeModel.cpp`:

```cpp
#include "UpgradeTreeModel.h"

UpgradeTreeModel::UpgradeTreeModel(QObject* parent) : BaseTreeModel(parent) {
	slk = &upgrade_slk;

	for (const auto& [key, value] : unit_editor_data.section("unitRace")) {
		if (key == "Sort" || key == "NumValues") {
			continue;
		}

		categories[value[0]].name = value[1];
		categories[value[0]].item = new BaseTreeItem(rootItem);
		categories[value[0]].item->baseCategory = true;
		rowToCategory.push_back(value[0]);
	}

	for (int i = 0; i < upgrade_slk.rows(); i++) {
		const std::string& id = upgrade_slk.index_to_row.at(i);

		std::string race = upgrade_slk.data("race", id);
		if (race.empty()) {
			std::cout << "Empty race for " << i << " in items\n";
			continue;
		}

		BaseTreeItem* parent_item = getFolderParent(id);
		if (!parent_item) {
			continue;
		}

		BaseTreeItem* item = new BaseTreeItem(parent_item);
		item->id = id;
		items.emplace(id, item);
	}

	categoryChangeFields = { "race" };
}

QModelIndex UpgradeTreeModel::mapToSource(const QModelIndex& proxyIndex) const {
	if (!proxyIndex.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(proxyIndex.internalPointer());

	if (item->baseCategory || item->subCategory) {
		return {};
	}

	return createIndex(slk->row_headers.at(item->id), slk->column_headers.at("name1"), item);
}

BaseTreeItem* UpgradeTreeModel::getFolderParent(const std::string& id) const {
	std::string race = upgrade_slk.data("race", id);
	if (race.empty()) {
		std::cout << "Empty race for " << id << " in items\n";
		return nullptr;
	}

	return categories.at(race).item;
}

QVariant UpgradeTreeModel::data(const QModelIndex& index, int role) const {
	if (!index.isValid()) {
		return {};
	}

	BaseTreeItem* item = static_cast<BaseTreeItem*>(index.internalPointer());

	switch (role) {
		case Qt::DecorationRole:
			if (item->baseCategory || item->subCategory) {
				return folderIcon;
			}
			return sourceModel()->data(sourceModel()->index(slk->row_headers.at(item->id), slk->column_headers.at("art1")), role);
		case Qt::EditRole:
		case Qt::DisplayRole:
			if (item->baseCategory) {
				return QString::fromStdString(categories.at(rowToCategory[index.row()]).name);
			} else {
				return QAbstractProxyModel::data(index, role).toString() + " " + QString::fromStdString(upgrade_slk.data("editorsuffix", item->id));
			}
		default:
			return BaseTreeModel::data(index, role);
	}
}
```

`src/Models/UpgradeTreeModel.h`:

```h
#pragma once

#include <array>

#include "BaseTreeModel.h"

class UpgradeTreeModel : public BaseTreeModel {
	struct Category {
		std::string name;
		BaseTreeItem* item;
	};

	std::unordered_map<std::string, Category> categories;
	std::vector<std::string> rowToCategory;

	BaseTreeItem* getFolderParent(const std::string& id) const override;

	QModelIndex mapToSource(const QModelIndex& proxyIndex) const override;

public:
	QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
	explicit UpgradeTreeModel(QObject* parent = nullptr);
};
```

`src/QtImgui/ImGuiRenderer.cpp`:

```cpp
#include "ImGuiRenderer.h"

#include <QDateTime>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QClipboard>
#include <QCursor>

#ifdef ANDROID
#define GL_VERTEX_ARRAY_BINDING           0x85B5 // Missing in android as of May 2020
#define USE_GLSL_ES
#endif

#ifdef USE_GLSL_ES
#define IMGUIRENDERER_GLSL_VERSION "#version 300 es\n"
#else
#define IMGUIRENDERER_GLSL_VERSION "#version 330\n"
#endif

namespace QtImGui {

namespace {

// Keyboard mapping. Dear ImGui use those indices to peek into the io.KeysDown[] array.
const QHash<int, ImGuiKey> keyMap = {
    { Qt::Key_Tab, ImGuiKey_Tab },
    { Qt::Key_Left, ImGuiKey_LeftArrow },
    { Qt::Key_Right, ImGuiKey_RightArrow },
    { Qt::Key_Up, ImGuiKey_UpArrow },
    { Qt::Key_Down, ImGuiKey_DownArrow },
    { Qt::Key_PageUp, ImGuiKey_PageUp },
    { Qt::Key_PageDown, ImGuiKey_PageDown },
    { Qt::Key_Home, ImGuiKey_Home },
    { Qt::Key_End, ImGuiKey_End },
    { Qt::Key_Insert, ImGuiKey_Insert },
    { Qt::Key_Delete, ImGuiKey_Delete },
    { Qt::Key_Backspace, ImGuiKey_Backspace },
    { Qt::Key_Space, ImGuiKey_Space },
    { Qt::Key_Enter, ImGuiKey_Enter },
    { Qt::Key_Return, ImGuiKey_Enter },
    { Qt::Key_Escape, ImGuiKey_Escape },
    { Qt::Key_A, ImGuiKey_A },
    { Qt::Key_C, ImGuiKey_C },
    { Qt::Key_V, ImGuiKey_V },
    { Qt::Key_X, ImGuiKey_X },
    { Qt::Key_Y, ImGuiKey_Y },
    { Qt::Key_Z, ImGuiKey_Z },
    { Qt::MiddleButton, ImGuiMouseButton_Middle }
};

#ifndef QT_NO_CURSOR
const QHash<ImGuiMouseCursor, Qt::CursorShape> cursorMap = {
    { ImGuiMouseCursor_Arrow,      Qt::CursorShape::ArrowCursor },
    { ImGuiMouseCursor_TextInput,  Qt::CursorShape::IBeamCursor },
    { ImGuiMouseCursor_ResizeAll,  Qt::CursorShape::SizeAllCursor },
    { ImGuiMouseCursor_ResizeNS,   Qt::CursorShape::SizeVerCursor },
    { ImGuiMouseCursor_ResizeEW,   Qt::CursorShape::SizeHorCursor },
    { ImGuiMouseCursor_ResizeNESW, Qt::CursorShape::SizeBDiagCursor },
    { ImGuiMouseCursor_ResizeNWSE, Qt::CursorShape::SizeFDiagCursor },
    { ImGuiMouseCursor_Hand,       Qt::CursorShape::PointingHandCursor },
    { ImGuiMouseCursor_NotAllowed, Qt::CursorShape::ForbiddenCursor },
};
#endif

QByteArray g_currentClipboardText;

} // namespace

void ImGuiRenderer::initialize(WindowWrapper *window) {
    m_window.reset(window);
    initializeOpenGLFunctions();

    g_ctx = ImGui::CreateContext();
    ImGui::SetCurrentContext(g_ctx);

    // Setup backend capabilities flags
    ImGuiIO &io = ImGui::GetIO();
    #ifndef QT_NO_CURSOR
    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors; // We can honor GetMouseCursor() values (optional)
    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;  // We can honor io.WantSetMousePos requests (optional, rarely used)
    #endif
    io.BackendPlatformName = "qtimgui";
    
    // Setup keyboard mapping
    for (ImGuiKey key : keyMap.values()) {
        io.KeyMap[key] = key;
    }
    
    // io.RenderDrawListsFn = [](ImDrawData *drawData) {
    //    instance()->renderDrawList(drawData);
    // };
    io.SetClipboardTextFn = [](void *user_data, const char *text) {
        Q_UNUSED(user_data);
        QGuiApplication::clipboard()->setText(text);
    };
    io.GetClipboardTextFn = [](void *user_data) {
        Q_UNUSED(user_data);
        g_currentClipboardText = QGuiApplication::clipboard()->text().toUtf8();
        return (const char *)g_currentClipboardText.data();
    };

    window->installEventFilter(this);
}

void ImGuiRenderer::renderDrawList(ImDrawData *draw_data)
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
    const ImGuiIO& io = ImGui::GetIO();
    int fb_width = (int)(io.DisplaySize.x * io.DisplayFramebufferScale.x);
    int fb_height = (int)(io.DisplaySize.y * io.DisplayFramebufferScale.y);
    if (fb_width == 0 || fb_height == 0)
        return;
    draw_data->ScaleClipRects(io.DisplayFramebufferScale);

    // Backup GL state
    GLint last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, &last_active_texture);
    glActiveTexture(GL_TEXTURE0);
    GLint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);
    GLint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    GLint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    GLint last_element_array_buffer; glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
    GLint last_vertex_array; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);
    GLint last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, &last_blend_src_rgb);
    GLint last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, &last_blend_dst_rgb);
    GLint last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, &last_blend_src_alpha);
    GLint last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, &last_blend_dst_alpha);
    GLint last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, &last_blend_equation_rgb);
    GLint last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, &last_blend_equation_alpha);
    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);
    GLint last_scissor_box[4]; glGetIntegerv(GL_SCISSOR_BOX, last_scissor_box);
    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);
    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);
    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);
    GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);

    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
    glEnable(GL_BLEND);
    glBlendEquation(GL_FUNC_ADD);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_CULL_FACE);
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_SCISSOR_TEST);

    // Setup viewport, orthographic projection matrix
    glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);
    const float ortho_projection[4][4] =
    {
        { 2.0f/io.DisplaySize.x, 0.0f,                   0.0f, 0.0f },
        { 0.0f,                  2.0f/-io.DisplaySize.y, 0.0f, 0.0f },
        { 0.0f,                  0.0f,                  -1.0f, 0.0f },
        {-1.0f,                  1.0f,                   0.0f, 1.0f },
    };
    glUseProgram(g_ShaderHandle);
    glUniform1i(g_AttribLocationTex, 0);
    glUniformMatrix4fv(g_AttribLocationProjMtx, 1, GL_FALSE, &ortho_projection[0][0]);
    glBindVertexArray(g_VaoHandle);

    for (int n = 0; n < draw_data->CmdListsCount; n++)
    {
        const ImDrawList* cmd_list = draw_data->CmdLists[n];
        const ImDrawIdx* idx_buffer_offset = 0;

        glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);
        glBufferData(GL_ARRAY_BUFFER, (GLsizeiptr)cmd_list->VtxBuffer.Size * sizeof(ImDrawVert), (const GLvoid*)cmd_list->VtxBuffer.Data, GL_STREAM_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ElementsHandle);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, (GLsizeiptr)cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx), (const GLvoid*)cmd_list->IdxBuffer.Data, GL_STREAM_DRAW);

        for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
        {
            const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
            if (pcmd->UserCallback)
            {
                pcmd->UserCallback(cmd_list, pcmd);
            }
            else
            {
                glBindTexture(GL_TEXTURE_2D, (GLuint)(size_t)pcmd->TextureId);
                glScissor((int)pcmd->ClipRect.x, (int)(fb_height - pcmd->ClipRect.w), (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));
                glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
            }
            idx_buffer_offset += pcmd->ElemCount;
        }
    }

    // Restore modified GL state
    glUseProgram(last_program);
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glActiveTexture(last_active_texture);
    glBindVertexArray(last_vertex_array);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);
    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);
    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);
    glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
    glScissor(last_scissor_box[0], last_scissor_box[1], (GLsizei)last_scissor_box[2], (GLsizei)last_scissor_box[3]);
}

bool ImGuiRenderer::createFontsTexture()
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Build texture atlas
    ImGuiIO& io = ImGui::GetIO();
    unsigned char* pixels;
    int width, height;
    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.

    // Upload texture to graphics system
    GLint last_texture;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    glGenTextures(1, &g_FontTexture);
    glBindTexture(GL_TEXTURE_2D, g_FontTexture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels);

    // Store our identifier
    io.Fonts->TexID = (void *)(size_t)g_FontTexture;

    // Restore state
    glBindTexture(GL_TEXTURE_2D, last_texture);

    return true;
}

bool ImGuiRenderer::createDeviceObjects()
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Backup GL state
    GLint last_texture, last_array_buffer, last_vertex_array;
    glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);

    const GLchar *vertex_shader =
        IMGUIRENDERER_GLSL_VERSION
        "uniform mat4 ProjMtx;\n"
        "in vec2 Position;\n"
        "in vec2 UV;\n"
        "in vec4 Color;\n"
        "out vec2 Frag_UV;\n"
        "out vec4 Frag_Color;\n"
        "void main()\n"
        "{\n"
        "	Frag_UV = UV;\n"
        "	Frag_Color = Color;\n"
        "	gl_Position = ProjMtx * vec4(Position.xy,0,1);\n"
        "}\n";

    const GLchar* fragment_shader =
        IMGUIRENDERER_GLSL_VERSION
        "precision mediump float;"
        "uniform sampler2D Texture;\n"
        "in vec2 Frag_UV;\n"
        "in vec4 Frag_Color;\n"
        "out vec4 Out_Color;\n"
        "void main()\n"
        "{\n"
        "	Out_Color = Frag_Color * texture( Texture, Frag_UV.st);\n"
        "}\n";

    g_ShaderHandle = glCreateProgram();
    g_VertHandle = glCreateShader(GL_VERTEX_SHADER);
    g_FragHandle = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(g_VertHandle, 1, &vertex_shader, 0);
    glShaderSource(g_FragHandle, 1, &fragment_shader, 0);
    glCompileShader(g_VertHandle);
    glCompileShader(g_FragHandle);
    glAttachShader(g_ShaderHandle, g_VertHandle);
    glAttachShader(g_ShaderHandle, g_FragHandle);
    glLinkProgram(g_ShaderHandle);

    g_AttribLocationTex = glGetUniformLocation(g_ShaderHandle, "Texture");
    g_AttribLocationProjMtx = glGetUniformLocation(g_ShaderHandle, "ProjMtx");
    g_AttribLocationPosition = glGetAttribLocation(g_ShaderHandle, "Position");
    g_AttribLocationUV = glGetAttribLocation(g_ShaderHandle, "UV");
    g_AttribLocationColor = glGetAttribLocation(g_ShaderHandle, "Color");

    glGenBuffers(1, &g_VboHandle);
    glGenBuffers(1, &g_ElementsHandle);

    glGenVertexArrays(1, &g_VaoHandle);
    glBindVertexArray(g_VaoHandle);
    glBindBuffer(GL_ARRAY_BUFFER, g_VboHandle);
    glEnableVertexAttribArray(g_AttribLocationPosition);
    glEnableVertexAttribArray(g_AttribLocationUV);
    glEnableVertexAttribArray(g_AttribLocationColor);

#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT))
    glVertexAttribPointer(g_AttribLocationPosition, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, pos));
    glVertexAttribPointer(g_AttribLocationUV, 2, GL_FLOAT, GL_FALSE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, uv));
    glVertexAttribPointer(g_AttribLocationColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(ImDrawVert), (GLvoid*)OFFSETOF(ImDrawVert, col));
#undef OFFSETOF

    createFontsTexture();

    // Restore modified GL state
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glBindVertexArray(last_vertex_array);

    return true;
}

void ImGuiRenderer::newFrame()
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    if (!g_FontTexture)
        createDeviceObjects();

    ImGuiIO& io = ImGui::GetIO();

    // Setup display size (every frame to accommodate for window resizing)
    io.DisplaySize = ImVec2(m_window->size().width(), m_window->size().height());
    io.DisplayFramebufferScale = ImVec2(m_window->devicePixelRatio(), m_window->devicePixelRatio());

    // Setup time step
    double current_time =  QDateTime::currentMSecsSinceEpoch() / double(1000);
    io.DeltaTime = g_Time > 0.0 ? (float)(current_time - g_Time) : (float)(1.0f/60.0f);
    g_Time = current_time;
    
    
    // If ImGui wants to set cursor position (for example, during navigation by using keyboard)
    // we need to do it here (before getting `QCursor::pos()` below).
    setCursorPos(io);

    // Setup inputs
    // (we already got mouse wheel, keyboard keys & characters from glfw callbacks polled in glfwPollEvents())
    if (m_window->isActive())
    {
        const QPoint pos = m_window->mapFromGlobal(QCursor::pos());
        io.MousePos = ImVec2(pos.x(), pos.y());   // Mouse position in screen coordinates (set to -1,-1 if no mouse / on another screen, etc.)
    }
    else
    {
        io.MousePos = ImVec2(-1,-1);
    }

    for (int i = 0; i < 3; i++)
    {
        io.MouseDown[i] = g_MousePressed[i];
    }

    io.MouseWheelH = g_MouseWheelH;
    io.MouseWheel = g_MouseWheel;
    g_MouseWheelH = 0;
    g_MouseWheel = 0;

    
    updateCursorShape(io);
    

    // Start the frame
    ImGui::NewFrame();
}

void ImGuiRenderer::render()
{
  // Select current context
  ImGui::SetCurrentContext(g_ctx);

  auto drawData = ImGui::GetDrawData();
  renderDrawList(drawData);
}

ImGuiRenderer::ImGuiRenderer()
  : g_ctx(nullptr)
{
}

ImGuiRenderer::~ImGuiRenderer()
{
  // remove this context
  ImGui::DestroyContext(g_ctx);
}

void ImGuiRenderer::onMousePressedChange(QMouseEvent *event)
{
    g_MousePressed[0] = event->buttons() & Qt::LeftButton;
    g_MousePressed[1] = event->buttons() & Qt::RightButton;
    g_MousePressed[2] = event->buttons() & Qt::MiddleButton;
}

void ImGuiRenderer::onWheel(QWheelEvent *event)
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    // Handle horizontal component
    if(event->pixelDelta().x() != 0)
    {
        g_MouseWheelH += event->pixelDelta().x() / (ImGui::GetTextLineHeight());
    } else {
        // Magic number of 120 comes from Qt doc on QWheelEvent::pixelDelta()
        g_MouseWheelH += event->angleDelta().x() / 120.0f;
    }

    // Handle vertical component
    if(event->pixelDelta().y() != 0)
    {
        // 5 lines per unit
        g_MouseWheel += event->pixelDelta().y() / (5.0 * ImGui::GetTextLineHeight());
    } else {
        // Magic number of 120 comes from Qt doc on QWheelEvent::pixelDelta()
        g_MouseWheel += event->angleDelta().y() / 120.0f;
    }
}

void ImGuiRenderer::onKeyPressRelease(QKeyEvent *event)
{
    // Select current context
    ImGui::SetCurrentContext(g_ctx);

    ImGuiIO& io = ImGui::GetIO();
    
    const bool key_pressed = (event->type() == QEvent::KeyPress);
    
    // Translate `Qt::Key` into `ImGuiKey`, and apply 'pressed' state for that key
    const auto key_it = keyMap.constFind( event->key() );
    if (key_it != keyMap.constEnd()) { // Qt's key found in keyMap
        const int imgui_key = *(key_it);
        io.KeysDown[imgui_key] = key_pressed;
    }

    if (key_pressed) {
        const QString text = event->text();
        if (text.size() == 1) {
            io.AddInputCharacter( text.at(0).unicode() );
        }
    }

#ifdef Q_OS_MAC
    io.KeyCtrl  = event->modifiers() & Qt::MetaModifier;
    io.KeyShift = event->modifiers() & Qt::ShiftModifier;
    io.KeyAlt   = event->modifiers() & Qt::AltModifier;
    io.KeySuper = event->modifiers() & Qt::ControlModifier; // Comamnd key
#else
    io.KeyCtrl  = event->modifiers() & Qt::ControlModifier;
    io.KeyShift = event->modifiers() & Qt::ShiftModifier;
    io.KeyAlt   = event->modifiers() & Qt::AltModifier;
    io.KeySuper = event->modifiers() & Qt::MetaModifier;
#endif
}

void ImGuiRenderer::updateCursorShape(const ImGuiIO& io)
{
    // NOTE: This code will be executed, only if the following flags have been set:
    // - backend flag: `ImGuiBackendFlags_HasMouseCursors`    - enabled
    // - config  flag: `ImGuiConfigFlags_NoMouseCursorChange` - disabled

#ifndef QT_NO_CURSOR
    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
        return;

    const ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
    if (io.MouseDrawCursor || (imgui_cursor == ImGuiMouseCursor_None))
    {
        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
        m_window->setCursorShape(Qt::CursorShape::BlankCursor);
    }
    else
    {
        // Show OS mouse cursor
        
        // Translate `ImGuiMouseCursor` into `Qt::CursorShape` and show it, if we can
        const auto cursor_it = cursorMap.constFind( imgui_cursor );
        if(cursor_it != cursorMap.constEnd()) // `Qt::CursorShape` found for `ImGuiMouseCursor`
        {
            const Qt::CursorShape qt_cursor_shape = *(cursor_it);
            m_window->setCursorShape(qt_cursor_shape);
        }
        else // shape NOT found - use default
        {
            m_window->setCursorShape(Qt::CursorShape::ArrowCursor);
        }
    }
#else
    Q_UNUSED(io);
#endif
}

void ImGuiRenderer::setCursorPos(const ImGuiIO& io)
{
    // NOTE: This code will be executed, only if the following flags have been set:
    // - backend flag: `ImGuiBackendFlags_HasSetMousePos`      - enabled
    // - config  flag: `ImGuiConfigFlags_NavEnableSetMousePos` - enabled
    
#ifndef QT_NO_CURSOR
    if(io.WantSetMousePos) {
        m_window->setCursorPos({(int)io.MousePos.x, (int)io.MousePos.y});
    }
#else
    Q_UNUSED(io);
#endif
}

bool ImGuiRenderer::eventFilter(QObject *watched, QEvent *event)
{
  if (watched == m_window->object()) {
    switch (event->type()) {
    case QEvent::MouseButtonDblClick:
    case QEvent::MouseButtonPress:
    case QEvent::MouseButtonRelease:
      this->onMousePressedChange(static_cast<QMouseEvent*>(event));
      break;
    case QEvent::Wheel:
      this->onWheel(static_cast<QWheelEvent*>(event));
      break;
    case QEvent::KeyPress:
    case QEvent::KeyRelease:
      this->onKeyPressRelease(static_cast<QKeyEvent*>(event));
      break;
    default:
      break;
    }
  }
  return QObject::eventFilter(watched, event);
}

ImGuiRenderer* ImGuiRenderer::instance() {
    static ImGuiRenderer* instance = nullptr;
    if (!instance) {
        instance = new ImGuiRenderer();
    }
    return instance;
}

} // namespace QtImGui

```

`src/QtImgui/ImGuiRenderer.h`:

```h
#pragma once

#include <QOpenGLExtraFunctions>
#include <QObject>
#include <QPoint>
#include <imgui.h>
#include <memory>

class QMouseEvent;
class QWheelEvent;
class QKeyEvent;

namespace QtImGui {

class WindowWrapper {
public:
    virtual ~WindowWrapper() {}
    virtual void installEventFilter(QObject *object) = 0;
    virtual QSize size() const = 0;
    virtual qreal devicePixelRatio() const = 0;
    virtual bool isActive() const = 0;
    virtual QPoint mapFromGlobal(const QPoint &p) const = 0;
    virtual QObject* object() = 0;
    
    virtual void setCursorShape(Qt::CursorShape shape) = 0;
    virtual void setCursorPos(const QPoint& local_pos) = 0;
};

class ImGuiRenderer : public QObject, QOpenGLExtraFunctions {
    Q_OBJECT
public:
    void initialize(WindowWrapper *window);
    void newFrame();
    void render();
    bool eventFilter(QObject *watched, QEvent *event);

    static ImGuiRenderer *instance();

public:
    ImGuiRenderer();
    ~ImGuiRenderer();

private:
    void onMousePressedChange(QMouseEvent *event);
    void onWheel(QWheelEvent *event);
    void onKeyPressRelease(QKeyEvent *event);
    
    void updateCursorShape(const ImGuiIO &io);
    void setCursorPos(const ImGuiIO &io);

    void renderDrawList(ImDrawData *draw_data);
    bool createFontsTexture();
    bool createDeviceObjects();

    std::unique_ptr<WindowWrapper> m_window;
    double       g_Time = 0.0f;
    bool         g_MousePressed[3] = { false, false, false };
    float        g_MouseWheel;
    float        g_MouseWheelH;
    GLuint       g_FontTexture = 0;
    int          g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;
    int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;
    int          g_AttribLocationPosition = 0, g_AttribLocationUV = 0, g_AttribLocationColor = 0;
    unsigned int g_VboHandle = 0, g_VaoHandle = 0, g_ElementsHandle = 0;

    ImGuiContext* g_ctx = nullptr;
};

} // namespace QtImGui

```

`src/QtImgui/QtImGui.cpp`:

```cpp
#include "QtImGui.h"

#include "ImGuiRenderer.h"
#include <QWindow>
#ifdef QT_WIDGETS_LIB
#include <QWidget>
#endif

namespace QtImGui {

class QWindowWrapper : public WindowWrapper
{
public:
  QWindowWrapper(ImGuiRenderer* r) 
    : r(r)
  {}
  ~QWindowWrapper() {
    if (r && (r != ImGuiRenderer::instance())) {
      delete r;
    }
  }

public:
  void newFrame() { r->newFrame(); }

  void render() { r->render(); }
private:
  ImGuiRenderer* r;
};

#ifdef QT_WIDGETS_LIB

namespace {

class QWidgetWindowWrapper : public QWindowWrapper {
public:
    QWidgetWindowWrapper(QWidget *w, ImGuiRenderer* r) 
      : QWindowWrapper(r), w(w)
    {}
    void installEventFilter(QObject *object) override {
        return w->installEventFilter(object);
    }
    QSize size() const override {
        return w->size();
    }
    qreal devicePixelRatio() const override {
        return w->devicePixelRatioF();
    }
    bool isActive() const override {
        return w->isActiveWindow();
    }
    QPoint mapFromGlobal(const QPoint &p) const override {
        return w->mapFromGlobal(p);
    }
    QObject* object() override {
        return w;
    }
    
    void setCursorShape(Qt::CursorShape shape) override
    {
        #ifndef QT_NO_CURSOR
            w->setCursor(shape);
        #else
            Q_UNUSED(shape);
        #endif
    }
    
    void setCursorPos(const QPoint& local_pos) override
    {
        #ifndef QT_NO_CURSOR
            // Convert position from widget-space into screen-space
            const QPoint global_pos = w->mapToGlobal(local_pos);

            QCursor cursor = w->cursor();
            cursor.setPos(global_pos);
            w->setCursor(cursor);
        #else
            Q_UNUSED(local_pos);
        #endif
    }
    
private:
    QWidget *w;
};
  
} // namespace

RenderRef initialize(QWidget *window, bool defaultRender) {
  if (defaultRender) {
    auto* wrapper = new QWidgetWindowWrapper(window, ImGuiRenderer::instance());
    ImGuiRenderer::instance()->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  } else {
    auto* render = new ImGuiRenderer();
    auto* wrapper = new QWidgetWindowWrapper(window, render);
    render->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  }
}

#endif // QT_WIDGETS_LIB

namespace {

class QWindowWindowWrapper : public QWindowWrapper {
public:
    QWindowWindowWrapper(QWindow *w, ImGuiRenderer* r) 
      : QWindowWrapper(r), w(w)
    {}
    void installEventFilter(QObject *object) override {
        return w->installEventFilter(object);
    }
    QSize size() const override {
        return w->size();
    }
    qreal devicePixelRatio() const override {
        return w->devicePixelRatio();
    }
    bool isActive() const override {
        return w->isActive();
    }
    QPoint mapFromGlobal(const QPoint &p) const override {
        return w->mapFromGlobal(p);
    }
    QObject* object() override {
        return w;
    }
    
    void setCursorShape(Qt::CursorShape shape) override
    {
        #ifndef QT_NO_CURSOR
            w->setCursor(shape);
        #else
            Q_UNUSED(shape);
        #endif
    }
    
    void setCursorPos(const QPoint& local_pos) override
    {
        #ifndef QT_NO_CURSOR
            // Convert position from window-space into screen-space
            const QPoint global_pos = w->mapToGlobal(local_pos);

            QCursor cursor = w->cursor();
            cursor.setPos(global_pos);
            w->setCursor(cursor);
        #else
            Q_UNUSED(local_pos);
        #endif
    }

private:
    QWindow *w;
};

} // namespace

RenderRef initialize(QWindow* window, bool defaultRender) {
  if (defaultRender) {
    auto* wrapper = new QWindowWindowWrapper(window, ImGuiRenderer::instance());
    ImGuiRenderer::instance()->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  }
  else {
    auto* render = new ImGuiRenderer();
    auto* wrapper = new QWindowWindowWrapper(window, render);
    render->initialize(wrapper);
    return reinterpret_cast<RenderRef>(dynamic_cast<QWindowWrapper*>(wrapper));
  }
}

void newFrame(RenderRef ref) {
  if (!ref) {
    ImGuiRenderer::instance()->newFrame();
  } else {
    auto wrapper = reinterpret_cast<QWindowWrapper*>(ref);
    wrapper->newFrame();
  }
}

void render(RenderRef ref)
{
  if (!ref) {
    ImGuiRenderer::instance()->render();
  } else {
    auto wrapper = reinterpret_cast<QWindowWrapper*>(ref);
    wrapper->render();
  }
}

} // namespace QtImGui

```

`src/QtImgui/QtImGui.h`:

```h
#pragma once

class QWidget;
class QWindow;

namespace QtImGui {

typedef void* RenderRef;

#ifdef QT_WIDGETS_LIB
RenderRef initialize(QWidget *window, bool defaultRender = true);
#endif

RenderRef initialize(QWindow *window, bool defaultRender = true);
void newFrame(RenderRef ref = nullptr);
void render(RenderRef ref = nullptr);

}

```

`src/Resources/CliffMesh.cpp`:

```cpp
#include "CliffMesh.h"

#include <QOpenGLFunctions_4_5_Core>
#include "Utilities.h"
import BinaryReader;
import MDX;
import Hierarchy;


CliffMesh::CliffMesh(const fs::path& path) {
	if (path.extension() == ".mdx" || path.extension() == ".MDX") {
		auto reader = BinaryReader(hierarchy.open_file(path));
		mdx::MDX model = mdx::MDX(reader);

		auto set = model.geosets.front();

		gl->glCreateBuffers(1, &vertex_buffer);
		gl->glNamedBufferData(vertex_buffer, static_cast<int>(set.vertices.size() * sizeof(glm::vec3)), set.vertices.data(), GL_STATIC_DRAW);

		gl->glCreateBuffers(1, &uv_buffer);
		gl->glNamedBufferData(uv_buffer, static_cast<int>(set.texture_coordinate_sets.front().size() * sizeof(glm::vec2)), set.texture_coordinate_sets.front().data(), GL_STATIC_DRAW);

		gl->glCreateBuffers(1, &normal_buffer);
		gl->glNamedBufferData(normal_buffer, static_cast<int>(set.normals.size() * sizeof(glm::vec3)), set.normals.data(), GL_STATIC_DRAW);

		gl->glCreateBuffers(1, &instance_buffer);

		indices = set.faces.size();
		gl->glCreateBuffers(1, &index_buffer);
		gl->glNamedBufferData(index_buffer, static_cast<int>(set.faces.size() * sizeof(uint16_t)), set.faces.data(), GL_STATIC_DRAW);
	}
}

CliffMesh::~CliffMesh() {
	gl->glDeleteBuffers(1, &vertex_buffer);
	gl->glDeleteBuffers(1, &uv_buffer);
	gl->glDeleteBuffers(1, &normal_buffer);
	gl->glDeleteBuffers(1, &instance_buffer);
	gl->glDeleteBuffers(1, &index_buffer);
}

void CliffMesh::render_queue(const glm::vec4 position) {
	render_jobs.push_back(position);
}

void CliffMesh::render() {
	if (render_jobs.empty()) {
		return;
	}

	gl->glNamedBufferData(instance_buffer, static_cast<int>(render_jobs.size() * sizeof(glm::vec4)), render_jobs.data(), GL_STATIC_DRAW);

	gl->glEnableVertexAttribArray(0);
	gl->glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	gl->glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glEnableVertexAttribArray(1);
	gl->glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
	gl->glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glEnableVertexAttribArray(2);
	gl->glBindBuffer(GL_ARRAY_BUFFER, normal_buffer);
	gl->glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glEnableVertexAttribArray(3);
	gl->glBindBuffer(GL_ARRAY_BUFFER, instance_buffer);
	gl->glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 0, nullptr);
	gl->glVertexAttribDivisor(3, 1);

	gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);
	gl->glDrawElementsInstanced(GL_TRIANGLES, indices, GL_UNSIGNED_SHORT, nullptr, static_cast<int>(render_jobs.size()));

	gl->glVertexAttribDivisor(3, 0); // ToDo use vao
	gl->glDisableVertexAttribArray(0);
	gl->glDisableVertexAttribArray(1);
	gl->glDisableVertexAttribArray(2);
	gl->glDisableVertexAttribArray(3);

	render_jobs.clear();
}
```

`src/Resources/CliffMesh.h`:

```h
#pragma once

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <QOpenGLFunctions_4_5_Core>


import ResourceManager;

#include <filesystem>
namespace fs = std::filesystem;

class CliffMesh : public Resource {
public:
	GLuint vertex_buffer;
	GLuint uv_buffer;
	GLuint normal_buffer;
	GLuint index_buffer;
	GLuint instance_buffer;
	size_t indices;

	static constexpr const char* name = "CliffMesh";

	std::vector<glm::vec4> render_jobs;

	explicit CliffMesh(const fs::path& path);
	virtual ~CliffMesh();

	void render_queue(glm::vec4 position);

	void render();
};
```

`src/Resources/EditableMesh.cpp`:

```cpp
import Hierarchy;

#include "EditableMesh.h"
#include <unordered_map>

EditableMesh::EditableMesh(const fs::path& path, std::optional<std::pair<int, std::string>> replaceable_id_override) {
	if (path.extension() != ".mdx" && path.extension() != ".MDX") {
		throw;
	}

	BinaryReader reader = hierarchy.open_file(path);
	this->path = path;

	size_t vertices = 0;
	size_t indices = 0;
	size_t matrices = 0;

	mdx = std::make_shared<mdx::MDX>(reader);

	gl->glGenVertexArrays(1, &vao);
	gl->glBindVertexArray(vao);

	has_mesh = mdx->geosets.size();
	if (!has_mesh) {
		return;
	}

	// Calculate required space
	for (const auto& i : mdx->geosets) {
		if (i.lod != 0) {
			continue;
		}
		vertices += i.vertices.size();
		indices += i.faces.size();
		matrices += i.matrix_groups.size();
	}

	// Allocate space
	gl->glCreateBuffers(1, &vertex_buffer);
	gl->glNamedBufferData(vertex_buffer, vertices * sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &uv_buffer);
	gl->glNamedBufferData(uv_buffer, vertices * sizeof(glm::vec2), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &normal_buffer);
	gl->glNamedBufferData(normal_buffer, vertices * sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &tangent_buffer);
	gl->glNamedBufferData(tangent_buffer, vertices * sizeof(glm::vec4), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &weight_buffer);
	gl->glNamedBufferData(weight_buffer, vertices * sizeof(glm::uvec2), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &index_buffer);
	gl->glNamedBufferData(index_buffer, indices * sizeof(uint16_t), nullptr, GL_DYNAMIC_DRAW);

	// Buffer Data
	int base_vertex = 0;
	int base_index = 0;

	for (const auto& i : mdx->geosets) {
		if (i.lod != 0) {
			continue;
		}
		MeshEntry entry;
		entry.vertices = static_cast<int>(i.vertices.size());
		entry.base_vertex = base_vertex;

		entry.indices = static_cast<int>(i.faces.size());
		entry.base_index = base_index;

		entry.material_id = i.material_id;
		entry.geoset_anim = nullptr;
		entry.extent = i.extent;

		geosets.push_back(entry);

		// If the skin vector is empty then the model has SD bone weights and we convert them to the HD skin weights.
		// Technically SD supports infinite bones per vertex, but we limit it to 4 like HD does.
		// This could cause graphical inconsistensies with the game, but after more than 4 bones the contribution per bone is low enough that we don't care
		if (i.skin.empty()) {
			std::vector<glm::u8vec4> groups;
			std::vector<glm::u8vec4> weights;

			int bone_offset = 0;
			for (const auto& group_size : i.matrix_groups) {
				int bone_count = std::min(group_size, 4u);
				glm::uvec4 indices(0);
				glm::uvec4 weightss(0);

				int weight = 255 / bone_count;
				for (int j = 0; j < bone_count; j++) {
					indices[j] = i.matrix_indices[bone_offset + j];
					weightss[j] = weight;
				}

				int remainder = 255 - weight * bone_count;
				weightss[0] += remainder;

				groups.push_back(indices);
				weights.push_back(weightss);
				bone_offset += group_size;
			}

			std::vector<glm::u8vec4> skin_weights;
			skin_weights.reserve(entry.vertices * 2);
			for (const auto& vertex_group : i.vertex_groups) {
				skin_weights.push_back(groups[vertex_group]);
				skin_weights.push_back(weights[vertex_group]);
			}

			gl->glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, skin_weights.data());
		} else {
			gl->glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, i.skin.data());
		}

		gl->glNamedBufferSubData(vertex_buffer, base_vertex * sizeof(glm::vec3), entry.vertices * sizeof(glm::vec3), i.vertices.data());
		gl->glNamedBufferSubData(uv_buffer, base_vertex * sizeof(glm::vec2), entry.vertices * sizeof(glm::vec2), i.texture_coordinate_sets.front().data());
		gl->glNamedBufferSubData(normal_buffer, base_vertex * sizeof(glm::vec3), entry.vertices * sizeof(glm::vec3), i.normals.data());
		gl->glNamedBufferSubData(tangent_buffer, base_vertex * sizeof(glm::vec4), entry.vertices * sizeof(glm::vec4), i.tangents.data());
		gl->glNamedBufferSubData(index_buffer, base_index * sizeof(uint16_t), entry.indices * sizeof(uint16_t), i.faces.data());

		base_vertex += entry.vertices;
		base_index += entry.indices;
	}

	// animations geoset ids > geosets
	for (auto& i : mdx->animations) {
		if (i.geoset_id >= 0 && i.geoset_id < geosets.size()) {
			geosets[i.geoset_id].geoset_anim = &i;
		}
	}

	for (size_t i = 0; i < mdx->textures.size(); i++) {
		const mdx::Texture& texture = mdx->textures[i];

		if (texture.replaceable_id != 0) {
			// Figure out if this is an HD texture
			// Unfortunately replaceable ID textures don't have any additional information on whether they are diffuse/normal/orm
			// So we take a guess using the index
			std::string suffix("");
			bool found = false;
			for (const auto& material : mdx->materials) {
				for (const auto& layer : material.layers) {
					for (size_t j = 0; j < layer.textures.size(); j++) {
						if (layer.textures[j].id != i) {
							continue;
						}

						found = true;

						if (layer.hd) {
							switch (j) {
								case 0:
									suffix = "_diffuse";
									break;
								case 1:
									suffix = "_normal";
									break;
								case 2:
									suffix = "_orm";
									break;
								case 3:
									suffix = "_emmisive";
									break;
							}
						}
						break;
					}
					if (found) {
						break;
					}
				}
				if (found) {
					break;
				}
			}

			if (replaceable_id_override && texture.replaceable_id == replaceable_id_override->first) {
				textures.push_back(resource_manager.load<GPUTexture>(replaceable_id_override->second + suffix, std::to_string(texture.flags)));
			} else {
				textures.push_back(resource_manager.load<GPUTexture>(mdx::replacable_id_to_texture.at(texture.replaceable_id) + suffix, std::to_string(texture.flags)));
			}
		} else {
			textures.push_back(resource_manager.load<GPUTexture>(texture.file_name, std::to_string(texture.flags)));
		}
		gl->glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_S, texture.flags & 1 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
		gl->glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_T, texture.flags & 2 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
	}

	gl->glEnableVertexAttribArray(0);
	gl->glEnableVertexAttribArray(1);
	gl->glEnableVertexAttribArray(2);
	gl->glEnableVertexAttribArray(3);
	gl->glEnableVertexAttribArray(4);

	gl->glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	gl->glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
	gl->glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, normal_buffer);
	gl->glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, tangent_buffer);
	gl->glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, weight_buffer);
	gl->glVertexAttribIPointer(4, 2, GL_UNSIGNED_INT, 0, nullptr);

	gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);
}

EditableMesh::~EditableMesh() {
	gl->glDeleteBuffers(1, &vertex_buffer);
	gl->glDeleteBuffers(1, &uv_buffer);
	gl->glDeleteBuffers(1, &normal_buffer);
	gl->glDeleteBuffers(1, &tangent_buffer);
	gl->glDeleteBuffers(1, &weight_buffer);
	gl->glDeleteBuffers(1, &index_buffer);
	gl->glDeleteBuffers(1, &layer_alpha);
	gl->glDeleteBuffers(1, &geoset_color);
}

void EditableMesh::render(const SkeletalModelInstance& skeleton, const glm::mat4 projection_view, glm::vec3 light_direction) {
	render_opaque_hd(skeleton, projection_view, light_direction);
}

// Opaque rendering doesn't have to be sorted and can thus be instanced
void EditableMesh::render_opaque_hd(const SkeletalModelInstance& skeleton, const glm::mat4 projection_view, glm::vec3 light_direction) {
	if (!has_mesh) {
		return;
	}
	glm::mat4 M = glm::mat4(1.f);
	glm::mat4 MVP = projection_view * M;

	gl->glBindVertexArray(vao);
	gl->glUniformMatrix4fv(0, 1, false, &MVP[0][0]);
	gl->glUniform1i(2, true);
	gl->glUniform1i(3, mdx->bones.size());
	gl->glUniformMatrix4fv(4, 1, false, &M[0][0]);
	gl->glUniform3fv(6, 1, &light_direction.x);
	gl->glUniformMatrix4fv(8, mdx->bones.size(), false, &skeleton.world_matrices[0][0][0]);

	for (const auto& i : geosets) {
		if (!i.hd) {
			continue;
		}

		const auto& layers = mdx->materials[i.material_id].layers;
		if (layers[0].blend_mode != 0 && layers[0].blend_mode != 1) {
			continue;
		}

		glm::vec3 geoset_color(1.f);
		float geoset_anim_visibility = 1.0f;
		if (i.geoset_anim && skeleton.sequence_index >= 0) {
			geoset_color = skeleton.get_geoset_animation_color(*i.geoset_anim);
			geoset_anim_visibility = skeleton.get_geoset_animation_visiblity(*i.geoset_anim);
		}

		float layer_visibility = 1.0f;
		if (skeleton.sequence_index >= 0) {
			layer_visibility = skeleton.get_layer_visiblity(layers[0]);
		}

		glm::vec4 layer_color = glm::vec4(geoset_color, layer_visibility * geoset_anim_visibility);

		gl->glUniform1f(1, layers[0].blend_mode == 1 ? 0.75f : -1.f);
		gl->glUniform4fv(5, 1, &layer_color[0]);

		if (layers[0].shading_flags & 0x10) {
			gl->glDisable(GL_CULL_FACE);
		} else {
			gl->glEnable(GL_CULL_FACE);
		}

		if (layers[0].shading_flags & 0x40) {
			gl->glDisable(GL_DEPTH_TEST);
		} else {
			gl->glEnable(GL_DEPTH_TEST);
		}

		if (layers[0].shading_flags & 0x80) {
			gl->glDepthMask(false);
		} else {
			gl->glDepthMask(true);
		}

		for (size_t texture_slot = 0; texture_slot < layers[0].textures.size(); texture_slot++) {
			gl->glBindTextureUnit(texture_slot, textures[layers[0].textures[texture_slot].id]->id);
		}

		gl->glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
	}
}
//
//void EditableMesh::render_transparent_sd(int instance_id) {
//	if (!has_mesh) {
//		return;
//	}
//
//	gl->glBindVertexArray(vao);
//
//	glm::mat4 MVP = camera->projection_view * render_jobs[instance_id];
//	gl->glUniformMatrix4fv(0, 1, false, &MVP[0][0]);
//
//	gl->glTextureBuffer(bone_matrix_texture, GL_RGBA32UI, bone_matrix_buffer);
//	gl->glBindTextureUnit(5, bone_matrix_texture);
//
//	gl->glUniform1i(3, model->bones.size());
//	gl->glUniform1i(4, instance_id);
//	gl->glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, layer_colors_ssbo);
//	gl->glBindBuffer(GL_SHADER_STORAGE_BUFFER, layer_colors_ssbo);
//
//	gl->glUniform1i(5, skip_count);
//
//	int laya = 0;
//	for (auto& i : geosets) {
//		auto& layers = model->materials[i.material_id].layers;
//		if (i.hd) {
//			laya += layers.size();
//			continue;
//		}
//
//		if (layers[0].blend_mode == 0 || layers[0].blend_mode == 1) {
//			laya += layers.size();
//			continue;
//		}
//
//		for (auto& j : layers) {
//			gl->glUniform1f(1, j.blend_mode == 1 ? 0.75f : -1.f);
//			gl->glUniform1i(6, laya);
//
//			switch (j.blend_mode) {
//				case 0:
//				case 1:
//					gl->glBlendFunc(GL_ONE, GL_ZERO);
//					break;
//				case 2:
//					gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
//					break;
//				case 3:
//					gl->glBlendFunc(GL_ONE, GL_ONE);
//					break;
//				case 4:
//					gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
//					break;
//				case 5:
//					gl->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
//					break;
//				case 6:
//					gl->glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
//					break;
//			}
//
//			if (j.shading_flags & 0x10) {
//				gl->glDisable(GL_CULL_FACE);
//			} else {
//				gl->glEnable(GL_CULL_FACE);
//			}
//
//			if (j.shading_flags & 0x40) {
//				gl->glDisable(GL_DEPTH_TEST);
//			} else {
//				gl->glEnable(GL_DEPTH_TEST);
//			}
//
//			if (j.shading_flags & 0x80) {
//				gl->glDepthMask(false);
//			} else {
//				gl->glDepthMask(true);
//			}
//
//			gl->glBindTextureUnit(0, textures[j.texture_id]->id);
//
//			gl->glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
//			laya++;
//		}
//	}
//}
//
//void EditableMesh::render_transparent_hd(int instance_id) {
//	if (!has_mesh) {
//		return;
//	}
//
//	gl->glBindVertexArray(vao);
//
//	glm::mat4 MVP = camera->projection_view * render_jobs[instance_id];
//	gl->glUniformMatrix4fv(0, 1, false, &MVP[0][0]);
//	gl->glUniformMatrix4fv(5, 1, false, &render_jobs[instance_id][0][0]);
//
//	gl->glTextureBuffer(bone_matrix_texture, GL_RGBA32UI, bone_matrix_buffer);
//	gl->glBindTextureUnit(5, bone_matrix_texture);
//
//	gl->glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, layer_colors_ssbo);
//	gl->glBindBuffer(GL_SHADER_STORAGE_BUFFER, layer_colors_ssbo);
//
//	gl->glUniform1i(3, model->bones.size());
//	gl->glUniform1i(4, instance_id);
//	gl->glUniform1i(6, skip_count);
//
//	int laya = 0;
//	for (auto& i : geosets) {
//		auto& layers = model->materials[i.material_id].layers;
//		if (!i.hd) {
//			laya += layers.size();
//			continue;
//		}
//
//		if (layers[0].blend_mode == 0 || layers[0].blend_mode == 1) {
//			laya += layers.size();
//			continue;
//		}
//
//		gl->glUniform1i(7, laya);
//		laya += layers.size();
//
//		switch (layers[0].blend_mode) {
//			case 2:
//				gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
//				break;
//			case 3:
//				gl->glBlendFunc(GL_ONE, GL_ONE);
//				break;
//			case 4:
//				gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
//				break;
//			case 5:
//				gl->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
//				break;
//			case 6:
//				gl->glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
//				break;
//		}
//
//		if (layers[0].shading_flags & 0x10) {
//			gl->glDisable(GL_CULL_FACE);
//		} else {
//			gl->glEnable(GL_CULL_FACE);
//		}
//
//		if (layers[0].shading_flags & 0x40) {
//			gl->glDisable(GL_DEPTH_TEST);
//		} else {
//			gl->glEnable(GL_DEPTH_TEST);
//		}
//
//		if (layers[0].shading_flags & 0x80) {
//			gl->glDepthMask(false);
//		} else {
//			gl->glDepthMask(true);
//		}
//
//		for (auto& texture : layers[0].textures) {
//			gl->glBindTextureUnit(texture.first, textures[texture.second]->id);
//		}
//
//		gl->glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
//	}
//}
//
//void EditableMesh::render_color_coded(const SkeletalModelInstance& skeleton, int id) {
//	if (!has_mesh) {
//		return;
//	}
//
//	gl->glBindVertexArray(vao);
//
//	glm::mat4 MVP = camera->projection_view * skeleton.matrix;
//	gl->glUniformMatrix4fv(0, 1, false, &MVP[0][0]);
//
//	gl->glUniform1i(3, model->bones.size());
//	gl->glUniform1i(7, id);
//
//	gl->glUniformMatrix4fv(8, model->bones.size(), false, &skeleton.world_matrices[0][0][0]);
//
//	for (auto& i : geosets) {
//		glm::vec3 geoset_color(1.0f);
//		float geoset_anim_visibility = 1.0f;
//		if (i.geoset_anim && skeleton.sequence_index >= 0) {
//			geoset_color = skeleton.get_geoset_animation_color(*i.geoset_anim);
//			geoset_anim_visibility = skeleton.get_geoset_animation_visiblity(*i.geoset_anim);
//		}
//
//		for (auto& j : model->materials[i.material_id].layers) {
//			if (j.blend_mode == 0) {
//				gl->glUniform1f(1, -1.f);
//			} else if (j.blend_mode == 1) {
//				gl->glUniform1f(1, 0.75f);
//			} else {
//				continue;
//			}
//
//			if (j.shading_flags & 0x40) {
//				gl->glDisable(GL_DEPTH_TEST);
//			} else {
//				gl->glEnable(GL_DEPTH_TEST);
//			}
//
//			if (j.shading_flags & 0x80) {
//				gl->glDepthMask(false);
//			} else {
//				gl->glDepthMask(true);
//			}
//
//			if (j.shading_flags & 0x10) {
//				gl->glDisable(GL_CULL_FACE);
//			} else {
//				gl->glEnable(GL_CULL_FACE);
//			}
//
//			float layer_visibility = 1.0f;
//			if (skeleton.sequence_index >= 0) {
//				layer_visibility = skeleton.get_layer_visiblity(j);
//			}
//			float final_visibility = layer_visibility * geoset_anim_visibility;
//
//			gl->glUniform3f(4, geoset_color.x, geoset_color.y, geoset_color.z);
//			gl->glUniform1f(5, final_visibility);
//
//			gl->glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
//			break;
//		}
//	}
//}
```

`src/Resources/EditableMesh.h`:

```h
#pragma once

#include <memory>

import MDX;
import ResourceManager;

#include <filesystem>
namespace fs = std::filesystem;

#include "GPUTexture.h"
#include "Shader.h"
#include "SkeletalModelInstance.h"

class EditableMesh : public Resource {
  public:
	struct MeshEntry {
		int vertices = 0;
		int indices = 0;
		int base_vertex = 0;
		int base_index = 0;

		int material_id = 0;
		mdx::Extent extent;

		bool hd = true;
		mdx::GeosetAnimation* geoset_anim; // can be nullptr, often
	};

	std::shared_ptr<mdx::MDX> mdx;

	std::vector<MeshEntry> geosets;
	bool has_mesh; // ToDo remove when added support for meshless

	GLuint vao;
	GLuint vertex_buffer;
	GLuint uv_buffer;
	GLuint normal_buffer;
	GLuint tangent_buffer;
	GLuint weight_buffer;
	GLuint index_buffer;
	GLuint layer_alpha;
	GLuint geoset_color;

	fs::path path;
	std::vector<std::shared_ptr<GPUTexture>> textures;

	static constexpr const char* name = "EditableMesh";

	explicit EditableMesh(const fs::path& path, std::optional<std::pair<int, std::string>> replaceable_id_override);
	virtual ~EditableMesh();

	void render(const SkeletalModelInstance& skeleton, const glm::mat4 projection_view, glm::vec3 light_direction);

private:
	//void render_queue(const SkeletalModelInstance& skeleton, glm::vec3 color);
	//void render_color_coded(const SkeletalModelInstance& skeleton, int id);

	//void render_opaque_sd();
  void render_opaque_hd(const SkeletalModelInstance& skeleton, const glm::mat4 projection_view, glm::vec3 light_direction);

	//void render_transparent_sd(int instance_id);
	//void render_transparent_hd(int instance_id);
};
```

`src/Resources/GPUTexture.cpp`:

```cpp
#include "GPUTexture.h"

#include <QOpenGLFunctions_4_5_Core>
#include <SOIL2/SOIL2.h>
#include <iostream>

import BLP;
import Hierarchy;

GPUTexture::GPUTexture(const fs::path& path) {
	fs::path new_path = path;

	if (hierarchy.hd) {
		new_path.replace_filename(path.stem().string() + "_diffuse.dds");
	}
	if (!hierarchy.file_exists(new_path)) {
		new_path = path;
		new_path.replace_extension(".blp");
		if (!hierarchy.file_exists(new_path)) {
			new_path.replace_extension(".dds");
			if (!hierarchy.file_exists(new_path)) {
				std::cout << "Error loading texture " << new_path << "\n";
				new_path = "Textures/btntempw.dds";
			}
		}
	}

	BinaryReader reader = hierarchy.open_file(new_path);

	if (new_path.extension() == ".blp" || new_path.extension() == ".BLP") {
		int width;
		int height;
		int channels;
		uint8_t* data = blp::load(reader, width, height, channels);

		gl->glCreateTextures(GL_TEXTURE_2D, 1, &id);
		gl->glTextureStorage2D(id, log2(std::max(width, height)) + 1, GL_RGBA8, width, height);
		gl->glTextureSubImage2D(id, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data);
		gl->glGenerateTextureMipmap(id);
		delete data;
	} else {
		id = SOIL_load_OGL_texture_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), SOIL_LOAD_AUTO, SOIL_LOAD_AUTO, SOIL_FLAG_DDS_LOAD_DIRECT | SOIL_FLAG_SRGB_COLOR_SPACE);
		if (id == 0) {
			gl->glCreateTextures(GL_TEXTURE_2D, 1, &id);
			std::cout << "Error loading texture: " << path << "\n";
		}
	}
	
	gl->glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	gl->glTextureParameteri(id, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	gl->glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}
```

`src/Resources/GPUTexture.h`:

```h
#pragma once

#include "Utilities.h"

#include <filesystem>
namespace fs = std::filesystem;

import ResourceManager;

class GPUTexture : public Resource {
public:
	GLuint id = 0;

	static constexpr const char* name = "GPUTexture";

	explicit GPUTexture(const fs::path& path);

	virtual ~GPUTexture() {
		gl->glDeleteTextures(1, &id);
	}
};
```

`src/Resources/GroundTexture.cpp`:

```cpp
#include "GroundTexture.h"

#include <SOIL2/SOIL2.h>

import BLP;

import Hierarchy;


GroundTexture::GroundTexture(const fs::path& path) {
	fs::path new_path = path;

	if (hierarchy.hd) {
		new_path.replace_filename(path.stem().string() + "_diffuse.dds");
	}
	if (!hierarchy.file_exists(new_path)) {
		new_path = path;
		new_path.replace_extension(".blp");
		if (!hierarchy.file_exists(new_path)) {
			new_path.replace_extension(".dds");
		}
	}
	
	BinaryReader reader = hierarchy.open_file(new_path);

	int width;
	int height;
	int channels;
	uint8_t* data;

	int upload_format = GL_RGBA;
	if (new_path.extension() == ".blp" || new_path.extension() == ".BLP") {
		data = blp::load(reader, width, height, channels);
		upload_format = GL_BGRA;
	} else {
		data = SOIL_load_image_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), &width, &height, &channels, SOIL_LOAD_AUTO);
		upload_format = GL_RGBA;
	}

	tile_size = height * 0.25;
	extended = (width == height * 2);
	int lods = log2(tile_size) + 1;
		
	gl->glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &id);
	gl->glTextureStorage3D(id, lods, GL_RGBA8, tile_size, tile_size, extended ? 32 : 16);
	gl->glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	gl->glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	gl->glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);


	gl->glPixelStorei(GL_UNPACK_ROW_LENGTH, width);
	for (int y = 0; y < 4; y++) {
		for (int x = 0; x < 4; x++) {
			gl->glTextureSubImage3D(id, 0, 0, 0, y * 4 + x, tile_size, tile_size, 1, upload_format, GL_UNSIGNED_BYTE, data + (y * tile_size * width + x * tile_size) * 4);

			if (extended) {
				gl->glTextureSubImage3D(id, 0, 0, 0, y * 4 + x + 16, tile_size, tile_size, 1, upload_format, GL_UNSIGNED_BYTE, data + (y * tile_size * width + (x + 4) * tile_size) * 4);
			}
		}
	}
	gl->glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
	gl->glGenerateTextureMipmap(id);

	gl->glGetTextureSubImage(id, lods - 1, 0, 0, 0, 1, 1, 1, GL_RGBA, GL_FLOAT, 16, &minimap_color);
	minimap_color *= 255.f;

	delete data;
}
```

`src/Resources/GroundTexture.h`:

```h
#pragma once

import ResourceManager;

#include <filesystem>
namespace fs = std::filesystem;

#include "Utilities.h"
#include <QOpenGLFunctions_4_5_Core>

class GroundTexture : public Resource {
public:
	GLuint id = 0;
	int tile_size;
	bool extended = false;
	glm::vec4 minimap_color;

	static constexpr const char* name = "GroundTexture";

	explicit GroundTexture(const fs::path& path);

	virtual ~GroundTexture() {
		gl->glDeleteTextures(1, &id);
	}
};
```

`src/Resources/PathingTexture.ixx`:

```ixx
module;

#include <vector>
#include <filesystem>
#include <SOIL2/SOIL2.h>
#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

export module PathingTexture;

namespace fs = std::filesystem;

import ResourceManager;
import Hierarchy;
import BLP;
import BinaryReader;

export class PathingTexture : public Resource {
  public:
	int width;
	int height;
	int channels;
	std::vector<uint8_t> data;

	bool homogeneous;

	static constexpr const char* name = "PathingTexture";

	explicit PathingTexture(const fs::path& path) {
		BinaryReader reader = hierarchy.open_file(path);
		uint8_t* image_data;

		if (path.extension() == ".blp" || path.extension() == ".BLP") {
			image_data = blp::load(reader, width, height, channels);
		} else {
			image_data = SOIL_load_image_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), &width, &height, &channels, SOIL_LOAD_AUTO);
		}
		data = std::vector<uint8_t>(image_data, image_data + width * height * channels);
		delete image_data;

		homogeneous = true;
		for (size_t i = 0; i < data.size(); i += channels) {
			if (channels == 3) {
				homogeneous = homogeneous && *reinterpret_cast<glm::u8vec3*>(data.data() + i) == *reinterpret_cast<glm::u8vec3*>(data.data());
			} else if (channels == 4) {
				homogeneous = homogeneous && *reinterpret_cast<glm::u8vec4*>(data.data() + i) == *reinterpret_cast<glm::u8vec4*>(data.data());
			}
		}
	}
};
```

`src/Resources/QIconResource.cpp`:

```cpp
#include "QIconResource.h"

#include <SOIL2/SOIL2.h>
#include <QImage>
#include <QPixmap>

import Hierarchy;
import BLP;
import BinaryReader;
import Texture;

QIconResource::QIconResource(const fs::path& path) {
	const auto image = resource_manager.load<Texture>(path);
	QImage temp_image(image->data.data(), image->width, image->height, image->channels == 3 ? QImage::Format::Format_RGB888 : QImage::Format::Format_RGBA8888);
	auto pix = QPixmap::fromImage(temp_image);
	icon = QIcon(pix);
}
```

`src/Resources/QIconResource.h`:

```h
#pragma once

import ResourceManager;

#include <filesystem>
namespace fs = std::filesystem;

#include <vector>

#include <QIcon>

class QIconResource : public Resource {
public:
	QIcon icon;

	static constexpr const char* name = "QIconResource";

	explicit QIconResource() = default;
	explicit QIconResource(const fs::path& path);
};
```

`src/Resources/Shader.cpp`:

```cpp
#include "Shader.h"

Shader::Shader(std::initializer_list<fs::path> paths) {
	program = compile_shader(*paths.begin(), *(paths.begin() + 1));
}
```

`src/Resources/Shader.h`:

```h
#pragma once

#include "Utilities.h"

import ResourceManager;

#include <filesystem>
namespace fs = std::filesystem;

class Shader : public Resource {
public:
	GLuint program;

	static constexpr const char* name = "Shader";

	Shader(std::initializer_list<fs::path> paths);

	virtual ~Shader() = default;

	void use() const {
		gl->glUseProgram(program);
	}
};
```

`src/Resources/SkinnedMesh.cpp`:

```cpp
#include "SkinnedMesh.h"

import Hierarchy;

#include "Camera.h"

#include "Globals.h"

SkinnedMesh::SkinnedMesh(const fs::path& path, std::optional<std::pair<int, std::string>> replaceable_id_override) {
	if (path.extension() != ".mdx" && path.extension() != ".MDX") {
		throw;
	}

	BinaryReader reader = hierarchy.open_file(path);
	this->path = path;

	size_t vertices = 0;
	size_t indices = 0;
	size_t matrices = 0;

	model = std::make_shared<mdx::MDX>(reader);

	gl->glGenVertexArrays(1, &vao);
	gl->glBindVertexArray(vao);

	has_mesh = model->geosets.size();
	if (!has_mesh) {
		return;
	}

	// Calculate required space
	for (const auto& i : model->geosets) {
		if (i.lod != 0) {
			continue;
		}
		vertices += i.vertices.size();
		indices += i.faces.size();
		matrices += i.matrix_groups.size();
	}

	// Allocate space
	gl->glCreateBuffers(1, &vertex_buffer);
	gl->glNamedBufferData(vertex_buffer, vertices * sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &uv_buffer);
	gl->glNamedBufferData(uv_buffer, vertices * sizeof(glm::vec2), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &normal_buffer);
	gl->glNamedBufferData(normal_buffer, vertices * sizeof(glm::vec3), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &tangent_buffer);
	gl->glNamedBufferData(tangent_buffer, vertices * sizeof(glm::vec4), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &weight_buffer);
	gl->glNamedBufferData(weight_buffer, vertices * sizeof(glm::uvec2), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &instance_buffer);

	gl->glCreateBuffers(1, &index_buffer);
	gl->glNamedBufferData(index_buffer, indices * sizeof(uint16_t), nullptr, GL_DYNAMIC_DRAW);

	gl->glCreateBuffers(1, &bone_matrix_buffer);
	gl->glCreateTextures(GL_TEXTURE_BUFFER, 1, &bone_matrix_texture);
	
	gl->glCreateBuffers(1, &layer_colors_ssbo);
	gl->glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, layer_colors_ssbo);

	// Buffer Data
	int base_vertex = 0;
	int base_index = 0;

	for (const auto& i : model->geosets) {
		if (i.lod != 0) {
			continue;
		}
		MeshEntry entry;
		entry.vertices = static_cast<int>(i.vertices.size());
		entry.base_vertex = base_vertex;

		entry.indices = static_cast<int>(i.faces.size());
		entry.base_index = base_index;

		entry.material_id = i.material_id;
		entry.geoset_anim = nullptr;
		entry.extent = i.extent;

		geosets.push_back(entry);

		// If the skin vector is empty then the model has SD bone weights and we convert them to the HD skin weights. 
		// Technically SD supports infinite bones per vertex, but we limit it to 4 like HD does.
		// This could cause graphical inconsistensies with the game, but after more than 4 bones the contribution per bone is low enough that we don't care
		if (i.skin.empty()) {
			std::vector<glm::u8vec4> groups;
			std::vector<glm::u8vec4> weights;

			int bone_offset = 0;
			for (const auto& group_size : i.matrix_groups) {
				int bone_count = std::min(group_size, 4u);
				glm::uvec4 indices(0);
				glm::uvec4 weightss(0);

				int weight = 255 / bone_count;
				for (int j = 0; j < bone_count; j++) {
					indices[j] = i.matrix_indices[bone_offset + j];
					weightss[j] = weight;
				}

				int remainder = 255 - weight * bone_count;
				weightss[0] += remainder;

				groups.push_back(indices);
				weights.push_back(weightss);
				bone_offset += group_size;
			}

			std::vector<glm::u8vec4> skin_weights;
			skin_weights.reserve(entry.vertices * 2);
			for (const auto& vertex_group : i.vertex_groups) {
				skin_weights.push_back(groups[vertex_group]);
				skin_weights.push_back(weights[vertex_group]);
			}

			gl->glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, skin_weights.data());
		} else {
			gl->glNamedBufferSubData(weight_buffer, base_vertex * sizeof(glm::uvec2), entry.vertices * 8, i.skin.data());
		}

		gl->glNamedBufferSubData(vertex_buffer, base_vertex * sizeof(glm::vec3), entry.vertices * sizeof(glm::vec3), i.vertices.data());
		gl->glNamedBufferSubData(uv_buffer, base_vertex * sizeof(glm::vec2), entry.vertices * sizeof(glm::vec2), i.texture_coordinate_sets.front().data());
		gl->glNamedBufferSubData(normal_buffer, base_vertex * sizeof(glm::vec3), entry.vertices * sizeof(glm::vec3), i.normals.data());
		gl->glNamedBufferSubData(tangent_buffer, base_vertex * sizeof(glm::vec4), entry.vertices * sizeof(glm::vec4), i.tangents.data());
		gl->glNamedBufferSubData(index_buffer, base_index * sizeof(uint16_t), entry.indices * sizeof(uint16_t), i.faces.data());

		base_vertex += entry.vertices;
		base_index += entry.indices;
	}

	for (auto& i : geosets) {
		for (auto& j : model->materials[i.material_id].layers) {
			skip_count++;
		}
	}

	// animations geoset ids > geosets
	for (auto& i : model->animations) {
		if (i.geoset_id >= 0 && i.geoset_id < geosets.size()) {
			geosets[i.geoset_id].geoset_anim = &i;
		}
	}

	for (size_t i = 0; i < model->textures.size(); i++) {
		const mdx::Texture& texture = model->textures[i];

		if (texture.replaceable_id != 0) {
			// Figure out if this is an HD texture
			// Unfortunately replaceable ID textures don't have any additional information on whether they are diffuse/normal/orm
			// So we take a guess using the index
			std::string suffix("");
			bool found = false;
			for (const auto& material : model->materials) {
				for (const auto& layer : material.layers) {
					for (size_t j = 0; j < layer.textures.size(); j++) {
						if (layer.textures[j].id != i) {
							continue;
						}

						found = true;

						if (layer.hd) {
							switch (j) {
								case 0:
									suffix = "_diffuse";
									break;
								case 1:
									suffix = "_normal";
									break;
								case 2:
									suffix = "_orm";
									break;
								case 3:
									suffix = "_emmisive";
									break;
							}
						}
						break;
					}
					if (found) {
						break;
					}
				}
				if (found) {
					break;
				}
			}

			if (replaceable_id_override && texture.replaceable_id == replaceable_id_override->first) {
				textures.push_back(resource_manager.load<GPUTexture>(replaceable_id_override->second + suffix, std::to_string(texture.flags)));
			} else {
				textures.push_back(resource_manager.load<GPUTexture>(mdx::replacable_id_to_texture.at(texture.replaceable_id) + suffix, std::to_string(texture.flags)));
			}
		} else {
			textures.push_back(resource_manager.load<GPUTexture>(texture.file_name, std::to_string(texture.flags)));
		}
		gl->glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_S, texture.flags & 1 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
		gl->glTextureParameteri(textures.back()->id, GL_TEXTURE_WRAP_T, texture.flags & 2 ? GL_REPEAT : GL_CLAMP_TO_EDGE);
	}

	gl->glEnableVertexAttribArray(0);
	gl->glEnableVertexAttribArray(1);
	gl->glEnableVertexAttribArray(2);
	gl->glEnableVertexAttribArray(3);
	gl->glEnableVertexAttribArray(4);
	gl->glEnableVertexAttribArray(5);
	gl->glEnableVertexAttribArray(6);
	gl->glEnableVertexAttribArray(7);
	gl->glEnableVertexAttribArray(8);

	gl->glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
	gl->glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);
	gl->glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, normal_buffer);
	gl->glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, tangent_buffer);
	gl->glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, 0, nullptr);

	gl->glBindBuffer(GL_ARRAY_BUFFER, weight_buffer);
	gl->glVertexAttribIPointer(4, 2, GL_UNSIGNED_INT, 0, nullptr);

	gl->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);

	gl->glBindBuffer(GL_ARRAY_BUFFER, instance_buffer);
	for (int i = 0; i < 4; i++) {
		gl->glEnableVertexAttribArray(5 + i);
		gl->glVertexAttribPointer(5 + i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), reinterpret_cast<const void*>(sizeof(glm::vec4) * i));
		gl->glVertexAttribDivisor(5 + i, 1);
	}
}

SkinnedMesh::~SkinnedMesh() {
	gl->glDeleteBuffers(1, &vertex_buffer);
	gl->glDeleteBuffers(1, &uv_buffer);
	gl->glDeleteBuffers(1, &normal_buffer);
	gl->glDeleteBuffers(1, &tangent_buffer);
	gl->glDeleteBuffers(1, &weight_buffer);
	gl->glDeleteBuffers(1, &index_buffer);
	gl->glDeleteBuffers(1, &instance_buffer);
	gl->glDeleteBuffers(1, &bone_matrix_buffer);
	gl->glDeleteBuffers(1, &layer_alpha);
	gl->glDeleteBuffers(1, &geoset_color);
}

void SkinnedMesh::render_queue(const SkeletalModelInstance& skeleton, glm::vec3 color) {

	if (!model->sequences.empty()) {
		mdx::Extent& extent = model->sequences[skeleton.sequence_index].extent;
		if (!camera->inside_frustrum(skeleton.matrix * glm::vec4(extent.minimum, 1.f), skeleton.matrix * glm::vec4(extent.maximum, 1.f))) {
			return;
		}
	}

	render_jobs.push_back(skeleton.matrix);
	render_colors.push_back(color);
	skeletons.push_back(&skeleton);

	// Register for opaque drawing
	if (render_jobs.size() == 1) {
		map->render_manager.skinned_meshes.push_back(this);
	}

	// Register for transparent drawing
	// If the mesh contains transparent parts then those need to be sorted and drawn on top/after all the opaque parts
	if (!has_mesh) {
		return;
	}

	for (const auto& i : geosets) {
		const auto& layer = model->materials[i.material_id].layers[0];
		if (layer.blend_mode != 0 && layer.blend_mode != 1) {
			RenderManager::SkinnedInstance t {
				.mesh = this,
				.instance_id = static_cast<int>(render_jobs.size() - 1),
				.distance = glm::distance(camera->position - camera->direction * camera->distance, glm::vec3(skeleton.matrix[3]))
			};
			// hack to improve performance
			if (t.distance > 256.f) {
				continue;
			}
			map->render_manager.skinned_transparent_instances.push_back(t);
			break;
		}
	}
}

void SkinnedMesh::upload_render_data() {
	if (!has_mesh) {
		return;
	}

	gl->glNamedBufferData(instance_buffer, render_jobs.size() * sizeof(glm::mat4), render_jobs.data(), GL_DYNAMIC_DRAW);

	for (int i = 0; i < render_jobs.size(); i++) {
		instance_bone_matrices.insert(instance_bone_matrices.end(), skeletons[i]->world_matrices.begin(), skeletons[i]->world_matrices.begin() + model->bones.size());
	}

	gl->glNamedBufferData(bone_matrix_buffer, instance_bone_matrices.size() * sizeof(glm::mat4), instance_bone_matrices.data(), GL_DYNAMIC_DRAW);

	layer_colors.clear();

	for (size_t k = 0; k < render_jobs.size(); k++) {
		for (const auto& i : geosets) {
			glm::vec3 geoset_color = render_colors[k];
			float geoset_anim_visibility = 1.0f;
			if (i.geoset_anim && skeletons[k]->sequence_index >= 0) {
				geoset_color *= skeletons[k]->get_geoset_animation_color(*i.geoset_anim);
				geoset_anim_visibility = skeletons[k]->get_geoset_animation_visiblity(*i.geoset_anim);
			}

			const auto& layers = model->materials[i.material_id].layers;
			for (auto& j : layers) {
				float layer_visibility = 1.0f;
				if (skeletons[k]->sequence_index >= 0) {
					layer_visibility = skeletons[k]->get_layer_visiblity(j);
				}
				layer_colors.push_back(glm::vec4(geoset_color, layer_visibility * geoset_anim_visibility));
			}
		}
	}

	gl->glNamedBufferData(layer_colors_ssbo, layer_colors.size() * sizeof(glm::vec4), layer_colors.data(), GL_DYNAMIC_DRAW);
}

void SkinnedMesh::render_opaque(bool render_hd) {
	if (!has_mesh) {
		return;
	}

	gl->glBindVertexArray(vao);

	gl->glTextureBuffer(bone_matrix_texture, GL_RGBA32UI, bone_matrix_buffer);
	gl->glBindTextureUnit(5, bone_matrix_texture);

	gl->glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, layer_colors_ssbo);
	gl->glBindBuffer(GL_SHADER_STORAGE_BUFFER, layer_colors_ssbo);

	gl->glUniform1i(3, model->bones.size());
	gl->glUniform1i(4, skip_count);

	int lay_index = 0;
	for (const auto& i : geosets) {
		const auto& layers = model->materials[i.material_id].layers;

		if (layers[0].blend_mode != 0 && layers[0].blend_mode != 1) {
			lay_index += layers.size();
			continue;
		}

		for (const auto& j : layers) {
			if (j.hd != render_hd) {
				lay_index += 1;
				continue;
			}

			gl->glUniform1f(1, j.blend_mode == 1 ? 0.75f : -1.f);
			gl->glUniform1i(5, lay_index);

			switch (j.blend_mode) {
				case 0:
				case 1:
					gl->glBlendFunc(GL_ONE, GL_ZERO);
					break;
				case 2:
					gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
					break;
				case 3:
					gl->glBlendFunc(GL_ONE, GL_ONE);
					break;
				case 4:
					gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
					break;
				case 5:
					gl->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
					break;
				case 6:
					gl->glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
					break;
			}

			if (j.shading_flags & 0x10) {
				gl->glDisable(GL_CULL_FACE);
			} else {
				gl->glEnable(GL_CULL_FACE);
			}

			if (j.shading_flags & 0x40) {
				gl->glDisable(GL_DEPTH_TEST);
			} else {
				gl->glEnable(GL_DEPTH_TEST);
			}

			if (j.shading_flags & 0x80) {
				gl->glDepthMask(false);
			} else {
				gl->glDepthMask(true);
			}

			for (size_t texture_slot = 0; texture_slot < j.textures.size(); texture_slot++) {
				gl->glBindTextureUnit(texture_slot, textures[j.textures[texture_slot].id]->id);
			}

			gl->glDrawElementsInstancedBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), render_jobs.size(), i.base_vertex);
			lay_index += 1;
		}
	}
}

void SkinnedMesh::render_transparent(int instance_id, bool render_hd) {
	if (!has_mesh) {
		return;
	}

	gl->glBindVertexArray(vao);

	glm::mat4 MVP = camera->projection_view * render_jobs[instance_id];
	gl->glUniformMatrix4fv(0, 1, false, &MVP[0][0]);
	if (render_hd) {
		gl->glUniformMatrix4fv(5, 1, false, &render_jobs[instance_id][0][0]);
	}

	gl->glTextureBuffer(bone_matrix_texture, GL_RGBA32UI, bone_matrix_buffer);
	gl->glBindTextureUnit(5, bone_matrix_texture);

	gl->glUniform1i(3, model->bones.size());
	gl->glUniform1i(4, instance_id);
	gl->glUniform1i(6, skip_count);

	gl->glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, layer_colors_ssbo);
	gl->glBindBuffer(GL_SHADER_STORAGE_BUFFER, layer_colors_ssbo);

	int lay_index = 0;
	for (const auto& i : geosets) {
		const auto& layers = model->materials[i.material_id].layers;

		if (layers[0].blend_mode == 0 || layers[0].blend_mode == 1) {
			lay_index += layers.size();
			continue;
		}

		for (auto& j : layers) {
			// We don't have to render fully transparent meshes
			if (layer_colors[instance_id * skip_count + lay_index].a <= 0.01) {
				lay_index += 1;
				continue;
			}

			if (j.hd != render_hd) {
				lay_index += 1;
				continue;
			}

			gl->glUniform1i(7, lay_index);

			switch (j.blend_mode) {
				case 2:
					gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
					break;
				case 3:
					gl->glBlendFunc(GL_ONE, GL_ONE);
					break;
				case 4:
					gl->glBlendFunc(GL_SRC_ALPHA, GL_ONE);
					break;
				case 5:
					gl->glBlendFunc(GL_ZERO, GL_SRC_COLOR);
					break;
				case 6:
					gl->glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);
					break;
			}

			if (j.shading_flags & 0x10) {
				gl->glDisable(GL_CULL_FACE);
			} else {
				gl->glEnable(GL_CULL_FACE);
			}

			if (j.shading_flags & 0x40) {
				gl->glDisable(GL_DEPTH_TEST);
			} else {
				gl->glEnable(GL_DEPTH_TEST);
			}

			//if (j.shading_flags & 0x80) {
			//	gl->glDepthMask(false);
			//} else {
			//	gl->glDepthMask(true);
			//}

			for (size_t texture_slot = 0; texture_slot < j.textures.size(); texture_slot++) {
				gl->glBindTextureUnit(texture_slot, textures[j.textures[texture_slot].id]->id);
			}

			gl->glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
			lay_index += 1;
		}
	}
}

void SkinnedMesh::render_color_coded(const SkeletalModelInstance& skeleton, int id) {
	if (!has_mesh) {
		return;
	}

	gl->glBindVertexArray(vao);

	glm::mat4 MVP = camera->projection_view * skeleton.matrix;
	gl->glUniformMatrix4fv(0, 1, false, &MVP[0][0]);

	gl->glUniform1i(3, model->bones.size());
	gl->glUniform1i(7, id);

	gl->glUniformMatrix4fv(8, model->bones.size(), false, &skeleton.world_matrices[0][0][0]);

	for (auto& i : geosets) {
		glm::vec3 geoset_color(1.0f);
		float geoset_anim_visibility = 1.0f;
		if (i.geoset_anim && skeleton.sequence_index >= 0) {
			geoset_color = skeleton.get_geoset_animation_color(*i.geoset_anim);
			geoset_anim_visibility = skeleton.get_geoset_animation_visiblity(*i.geoset_anim);
		}

		for (auto& j : model->materials[i.material_id].layers) {
			if (j.blend_mode == 0) {
				gl->glUniform1f(1, -1.f);
			} else if (j.blend_mode == 1) {
				gl->glUniform1f(1, 0.75f);
			} else {
				continue;
			}

			if (j.shading_flags & 0x40) {
				gl->glDisable(GL_DEPTH_TEST);
			} else {
				gl->glEnable(GL_DEPTH_TEST);
			}

			if (j.shading_flags & 0x80) {
				gl->glDepthMask(false);
			} else {
				gl->glDepthMask(true);
			}

			if (j.shading_flags & 0x10) {
				gl->glDisable(GL_CULL_FACE);
			} else {
				gl->glEnable(GL_CULL_FACE);
			}

			float layer_visibility = 1.0f;
			if (skeleton.sequence_index >= 0) {
				layer_visibility = skeleton.get_layer_visiblity(j);
			}
			float final_visibility = layer_visibility * geoset_anim_visibility;

			gl->glUniform3f(4, geoset_color.x, geoset_color.y, geoset_color.z);
			gl->glUniform1f(5, final_visibility);

			gl->glDrawElementsBaseVertex(GL_TRIANGLES, i.indices, GL_UNSIGNED_SHORT, reinterpret_cast<void*>(i.base_index * sizeof(uint16_t)), i.base_vertex);
			break;
		}
	}
}
```

`src/Resources/SkinnedMesh.h`:

```h
#pragma once

#include <memory>

import MDX;

import ResourceManager;

#include <filesystem>
namespace fs = std::filesystem;

#include "GPUTexture.h"
#include "Shader.h"
#include "SkeletalModelInstance.h"

class SkinnedMesh : public Resource {
  public:
	struct MeshEntry {
		int vertices = 0;
		int indices = 0;
		int base_vertex = 0;
		int base_index = 0;

		int material_id = 0;
		mdx::Extent extent;

		mdx::GeosetAnimation* geoset_anim; // can be nullptr, often
	};

	std::shared_ptr<mdx::MDX> model;

	std::vector<MeshEntry> geosets;
	bool has_mesh; // ToDo remove when added support for meshless

	GLuint vao;
	GLuint vertex_buffer;
	GLuint uv_buffer;
	GLuint normal_buffer;
	GLuint tangent_buffer;
	GLuint weight_buffer;
	GLuint index_buffer;
	GLuint instance_buffer;
	GLuint bone_matrix_buffer;
	GLuint bone_matrix_texture;
	GLuint layer_alpha;
	GLuint geoset_color;

	GLuint layer_colors_ssbo;

	int skip_count = 0;

	fs::path path;
//	int mesh_id;
	std::vector<std::shared_ptr<GPUTexture>> textures;
	std::vector<glm::mat4> render_jobs;
	std::vector<glm::vec3> render_colors;
	std::vector<const SkeletalModelInstance*> skeletons;
	std::vector<glm::mat4> instance_bone_matrices;
	std::vector<glm::vec4> layer_colors;

	static constexpr const char* name = "SkinnedMesh";

	explicit SkinnedMesh(const fs::path& path, std::optional<std::pair<int, std::string>> replaceable_id_override);
	virtual ~SkinnedMesh();

	void render_queue(const SkeletalModelInstance& skeleton, glm::vec3 color);
	void render_color_coded(const SkeletalModelInstance& skeleton, int id);

	//void render_opaque_sd();
	//void render_opaque_hd();

	void upload_render_data();

	void render_opaque(bool render_hd);
	void render_transparent(int instance_id, bool render_hd);
	//void render_transparent_sd(int instance_id);
	//void render_transparent_hd(int instance_id);
};
```

`src/Resources/SkinnedMesh/RenderNode.ixx`:

```ixx
module;

#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

export module RenderNode;

import MDX;
import MathOperations;

export struct RenderNode {
	mdx::Node* node;
	RenderNode* parent;
	glm::vec3 pivot;
	// local space
	//glm::vec3 position;
	//glm::quat rotation = glm::quat(1.f, 0.f, 0.f, 0.f);
	//glm::vec3 scale = glm::vec3(1, 1, 1);

	// world space (not including game unit X/Y, mdx-m3-viewer's name)
	//glm::vec3 worldLocation;
	//glm::quat worldRotation = glm::quat(1.f, 0.f, 0.f, 0.f);
	//glm::vec3 worldScale = glm::vec3(1, 1, 1);
	//glm::mat4 worldMatrix = glm::mat4(1.f);
	// inverse world space
	//glm::vec3 inverseWorldLocation;
	//glm::quat inverseWorldRotation;
	//glm::vec3 inverseWorldScale;
	// cached flags from node, could be removed for RAM
	bool dontInheritTranslation;
	bool dontInheritScaling;
	bool dontInheritRotation;

	bool billboarded;
	bool billboardedX;
	bool billboardedY;
	bool billboardedZ;
	// state flags
	bool visible;

	RenderNode() = default;
	RenderNode(mdx::Node& node, glm::vec3 pivot) {
		this->node = &node;
		this->pivot = pivot;

		dontInheritTranslation = node.flags & mdx::Node::Flags::dont_inherit_translation;
		dontInheritRotation = node.flags & mdx::Node::Flags::dont_inherit_rotation;
		dontInheritScaling = node.flags & mdx::Node::Flags::dont_inherit_scaling;
		billboarded = node.flags & mdx::Node::Flags::billboarded;
		billboardedX = node.flags & mdx::Node::Flags::billboarded_lock_x;
		billboardedY = node.flags & mdx::Node::Flags::billboarded_lock_y;
		billboardedZ = node.flags & mdx::Node::Flags::billboarded_lock_z;
	}
};
```

`src/Resources/SkinnedMesh/SkeletalModelInstance.cpp`:

```cpp
#include "SkeletalModelInstance.h"

#include "Camera.h"
#include "Utilities.h"

SkeletalModelInstance::SkeletalModelInstance(std::shared_ptr<mdx::MDX> model) : model(model) {
	size_t node_count = model->bones.size() +
		model->lights.size() +
		model->help_bones.size() +
		model->attachments.size() +
		model->emitters1.size() +
		model->emitters2.size() +
		model->ribbons.size() +
		model->event_objects.size() +
		model->collision_shapes.size() +
		model->corn_emitters.size();
	
	// ToDo: for each camera: add camera source node to renderNodes
	render_nodes.resize(node_count);
	world_matrices.resize(node_count);
	model->for_each_node([&](mdx::Node& node) {
		// Seen it happen with Emmitter1, is this an error in the model?
		// ToDo purge (when adding a validation layer or just crashing)
		if (node.id == -1) {
			return;
		}

		RenderNode renderNode = RenderNode(node, model->pivots[node.id]);
		if (node.parent_id != -1) {
			renderNode.parent = &render_nodes[node.parent_id];
		} else {
			renderNode.parent = nullptr;
		}

		render_nodes[node.id] = renderNode;
	});

	current_keyframes.resize(model->unique_tracks);

	for (size_t i = 0; i < model->sequences.size(); i++) {
		if (model->sequences[i].name.find("Stand") != std::string::npos) {
			set_sequence(static_cast<int>(i));
			break;
		}
	}
}

void SkeletalModelInstance::update_location(glm::vec3 position, float angle, const glm::vec3& scale) {
	glm::vec3 axis = glm::vec3(0, 0, 1);
	glm::quat rotation = glm::angleAxis(angle, axis);
	inverseInstanceRotation.x = -rotation.x;
	inverseInstanceRotation.y = -rotation.y;
	inverseInstanceRotation.z = -rotation.z;
	inverseInstanceRotation.w = rotation.w;
	fromRotationTranslationScaleOrigin(rotation, position, scale, matrix, glm::vec3(0, 0, 0));
}

void SkeletalModelInstance::update(double delta) {
	if (model->sequences.empty() || sequence_index == -1) {
		return;
	}

	// Advance current frame
	const mdx::Sequence& sequence = model->sequences[sequence_index];
	if (sequence.flags & mdx::Sequence::non_looping) {
		current_frame = std::min<int>(current_frame + delta * 1000.0, sequence.end_frame);
	} else {
		current_frame += delta * 1000.0;
		if (current_frame > sequence.end_frame) {
			current_frame = sequence.start_frame;
		}
	}

	for (const auto& i : render_nodes) {
		advance_keyframes(i.node->KGTR);
		advance_keyframes(i.node->KGRT);
		advance_keyframes(i.node->KGSC);
	}

	for (const auto& i : model->animations) {
		advance_keyframes(i.KGAC);
		advance_keyframes(i.KGAO);
	}

	for (const auto& i : model->materials) {
		for (const auto& j : i.layers) {
			advance_keyframes(j.KMTA);
			// Add more when required
		}
	}

	update_nodes();
}

void SkeletalModelInstance::update_nodes() {
	assert(sequence_index >= 0 && sequence_index < model->sequences.size());

	// update skeleton to position based on animation @ time
	for (auto& node : render_nodes) {
		//node.position = interpolate_keyframes(node.node->KGTR, TRANSLATION_IDENTITY);
		//node.rotation = interpolate_keyframes(node.node->KGRT, ROTATION_IDENTITY);
		//node.scale = interpolate_keyframes(node.node->KGSC, SCALE_IDENTITY);

		glm::vec3 position = interpolate_keyframes(node.node->KGTR, TRANSLATION_IDENTITY);
		glm::quat rotation = interpolate_keyframes(node.node->KGRT, ROTATION_IDENTITY);
		glm::vec3 scale = interpolate_keyframes(node.node->KGSC, SCALE_IDENTITY);

		fromRotationTranslationScaleOrigin(rotation, position, scale, world_matrices[node.node->id], node.pivot);

		if (node.node->parent_id != -1) {
			world_matrices[node.node->id] = world_matrices[node.node->parent_id] * world_matrices[node.node->id];
		}



		if (node.billboarded || node.billboardedX) {

			world_matrices[node.node->id][1][0] = 0.f;
			world_matrices[node.node->id][2][0] = 0.f;
			world_matrices[node.node->id][3][0] = 0.f;
			world_matrices[node.node->id][2][1] = 0.f;
			world_matrices[node.node->id][3][1] = 0.f;
			world_matrices[node.node->id][3][2] = 0.f;

			world_matrices[node.node->id][0][1] = 0.f;
			world_matrices[node.node->id][0][2] = 0.f;
			world_matrices[node.node->id][0][3] = 0.f;
			world_matrices[node.node->id][1][2] = 0.f;
			world_matrices[node.node->id][1][3] = 0.f;
			world_matrices[node.node->id][2][3] = 0.f;

			// Cancel the parent's rotation
			/*if (node.parent) {
				node.localRotation = node.parent->inverseWorldRotation * inverseInstanceRotation;
			} else {
				node.localRotation = inverseInstanceRotation;
			}

			node.localRotation *= camera->decomposed_rotation;*/
		}
	}
}

/// Sets the current sequence to sequence_index and recalculates required keyframe data
void SkeletalModelInstance::set_sequence(int sequence_index) {
	this->sequence_index = sequence_index;
	current_frame = model->sequences[sequence_index].start_frame;

	for (const auto& i : render_nodes) {
		calculate_sequence_extents(i.node->KGTR);
		calculate_sequence_extents(i.node->KGRT);
		calculate_sequence_extents(i.node->KGSC);
	}

	for (const auto& i : model->animations) {
		calculate_sequence_extents(i.KGAC);
		calculate_sequence_extents(i.KGAO);
	}

	for (const auto& i : model->materials) {
		for (const auto& j : i.layers) {
			calculate_sequence_extents(j.KMTA);
			// Add more when required
		}
	}
}

template <typename T>
void SkeletalModelInstance::calculate_sequence_extents(const mdx::TrackHeader<T>& header) {
	if (header.id == -1) {
		return;
	}

	const mdx::Sequence& sequence = model->sequences[sequence_index];
	int local_sequence_start = sequence.start_frame;
	int local_sequence_end = sequence.end_frame;

	if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
		local_sequence_start = 0;
		local_sequence_end = model->global_sequences[header.global_sequence_ID];
	}

	CurrentKeyFrame& current = current_keyframes[header.id];
	current.start = -1;
	current.right = -1;

	// Find the sequence start and end tracks, these are not always exactly at the sequence start/end
	for (int i = 0; i < header.tracks.size(); i++) {
		const mdx::Track<T>& track = header.tracks[i];

		if (track.frame > local_sequence_end) {
			break;
		}

		if (track.frame >= local_sequence_start && current.start == -1) {
			current.start = i;
		}

		current.end = i;
	}

	// Set the starting left/right track index
	if (current.start != -1) {
		current.left = current.start;

		if (current.end > current.start) {
			current.right = current.left + 1;
		} else {
			current.right = current.left;
		}
	}
}

template void SkeletalModelInstance::calculate_sequence_extents(const mdx::TrackHeader<glm::vec3>& header);
template void SkeletalModelInstance::calculate_sequence_extents(const mdx::TrackHeader<glm::quat>& header);

template <typename T>
void SkeletalModelInstance::advance_keyframes(const mdx::TrackHeader<T>& header) {
	if (header.id == -1) {
		return;
	}
	CurrentKeyFrame& current = current_keyframes[header.id];

	int local_current_frame = current_frame;

	if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
		int local_sequence_end = model->global_sequences[header.global_sequence_ID];
		if (local_sequence_end == 0) {
			local_current_frame = 0;
		} else {
			local_current_frame = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % local_sequence_end;
		}
	}

	// If there are no tracks in sequence
	if (current.start == -1) {
		return;
	}

	// If there is only 1 track
	if (current.start == current.end) {
		return;
	}

	// Detect if we looped
	if (header.tracks[current.left].frame > local_current_frame) {
		current.left = current.start;
		current.right = current.start + 1;
	}

	// Scan till we find two tracks
	while (header.tracks[current.right].frame < local_current_frame) {
		current.left = current.right;
		current.right++;

		// Reached last keyframe
		if (current.right > current.end) {
			break;
		}

		// No need for interpolation if current_frame is exactly on a track
		if (header.tracks[current.right].frame == local_current_frame) {
			current.left = current.right;
		}
	}

	// The first/last tracks are not always exactly at the sequence start/end
	const bool past_end = header.tracks[current.end].frame < local_current_frame;
	const bool before_start = header.tracks[current.start].frame > local_current_frame;
	if (past_end || before_start) {
		current.left = current.end;
		current.right = current.start;
	}
}

template void SkeletalModelInstance::advance_keyframes(const mdx::TrackHeader<glm::vec3>& header);
template void SkeletalModelInstance::advance_keyframes(const mdx::TrackHeader<glm::quat>& header);

glm::vec3 SkeletalModelInstance::get_geoset_animation_color(const mdx::GeosetAnimation& animation) const {
	return interpolate_keyframes(animation.KGAC, animation.color);
}

float SkeletalModelInstance::get_geoset_animation_visiblity(const mdx::GeosetAnimation& animation) const {
	return interpolate_keyframes(animation.KGAO, animation.alpha);
}

float SkeletalModelInstance::get_layer_visiblity(const mdx::Layer& layer) const {
	return interpolate_keyframes(layer.KMTA, layer.alpha);
}

template <typename T>
T SkeletalModelInstance::interpolate_keyframes(const mdx::TrackHeader<T>& header, const T& default_value) const {
	if (header.id == -1) {
		return default_value;
	}

	const CurrentKeyFrame& current = current_keyframes[header.id];
	const mdx::Sequence& sequence = model->sequences[sequence_index];

	int local_current_frame = current_frame;
	int local_sequence_start = sequence.start_frame;
	int local_sequence_end = sequence.end_frame;

	if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
		local_sequence_start = 0;
		local_sequence_end = model->global_sequences[header.global_sequence_ID];
		if (local_sequence_end == 0) {
			local_current_frame = 0;
		} else {
			local_current_frame = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % local_sequence_end;
		}
	}

	// If there are no tracks in sequence
	if (current.start == -1) {
		return default_value;
	}

	// If there is only 1 track
	if (current.start == current.end) {
		return header.tracks[current.left].value;
	}

	const T ceil_in_tan = header.tracks[current.right].inTan;
	const T floor_out_tan = header.tracks[current.left].outTan;

	int floor_time = header.tracks[current.left].frame;
	const int ceil_time = header.tracks[current.right].frame;
	const T floor_value = header.tracks[current.left].value;
	const T ceil_value = header.tracks[current.right].value;


	// This is the implementation that correctly handles missing start/end frames. 
	// The game and WE however have a buggy implementation which is the one we end up using for compatibility
	//float t;
	//if (ceil_time - floor_time < 0) {
	//	int duration = (local_sequence_end - floor_time) + (ceil_time - local_sequence_start);

	//	if (local_current_frame > floor_time) {
	//		t = (local_current_frame - floor_time) / (float)duration;
	//	} else {
	//		t = (local_current_frame - local_sequence_start + (local_sequence_end - floor_time)) / (float)duration;
	//	}
	//} else {
	//	t = (local_current_frame - floor_time) / static_cast<float>(ceil_time - floor_time);
	//}

	// The (incorrect) implementation both the game and WE use
	int time_between_frames = ceil_time - floor_time;
	if (time_between_frames < 0) {
		time_between_frames += (local_sequence_end - local_sequence_start);
		if (local_current_frame < floor_time) {
			floor_time = ceil_time;
		}
	}
	const float t = time_between_frames == 0 ? 0.f : ((local_current_frame - floor_time) / static_cast<float>(time_between_frames));

	return interpolate(floor_value, floor_out_tan, ceil_in_tan, ceil_value, t, header.interpolation_type);
}

template glm::vec3 SkeletalModelInstance::interpolate_keyframes(const mdx::TrackHeader<glm::vec3>& header, const glm::vec3& default_value) const;
template glm::quat SkeletalModelInstance::interpolate_keyframes(const mdx::TrackHeader<glm::quat>& header, const glm::quat& default_value) const;
```

`src/Resources/SkinnedMesh/SkeletalModelInstance.h`:

```h
#pragma once

#include <chrono>
#include <vector>
#include <memory>
#include <unordered_map>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

import RenderNode;
import MDX;


// Ghostwolf mentioned this to me once, so I used it,
// as 0.75, experimentally determined as a guess at
// whatever WC3 is doing. Do more research if necessary?
#define MAGIC_RENDER_SHOW_CONSTANT 0.75

// Instead of recalculating the extents of the current sequence every frame we can keep track of it
struct CurrentKeyFrame {
	int start = -1;
	int end = 0;
	int left = 0;
	int right = 0;
};

class SkeletalModelInstance {
  public:
	std::shared_ptr<mdx::MDX> model;

	int sequence_index = 0; // can be -1 if not animating
	int current_frame = 0;

	glm::quat inverseCameraRotationXSpin;
	glm::quat inverseCameraRotationYSpin;
	glm::quat inverseCameraRotationZSpin;

	glm::mat4 matrix = glm::mat4(1.f);
	glm::quat inverseInstanceRotation;

	std::vector<CurrentKeyFrame> current_keyframes;
	std::vector<RenderNode> render_nodes;
	std::vector<glm::mat4> world_matrices;

	SkeletalModelInstance() = default;
	explicit SkeletalModelInstance(std::shared_ptr<mdx::MDX> model);

	void update_location(glm::vec3 position, float angle, const glm::vec3& scale);

	void update(double delta);

	void update_nodes();

	void set_sequence(int sequence_index);

	template <typename T>
	void calculate_sequence_extents(const mdx::TrackHeader<T>& header);

	template <typename T>
	void advance_keyframes(const mdx::TrackHeader<T>& header);

	glm::vec3 get_geoset_animation_color(const mdx::GeosetAnimation& animation) const;
	float get_geoset_animation_visiblity(const mdx::GeosetAnimation& animation) const;
	float get_layer_visiblity(const mdx::Layer& layer) const;

	template <typename T>
	T interpolate_keyframes(const mdx::TrackHeader<T>& header, const T& default_value) const;
};
```

`src/Resources/SkinnedMesh/SkeletalModelInstance.ixx`:

```ixx
module;

#include <chrono>
#include <vector>
#include <memory>

#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

export module SkeletalModelInstance;

import MDX;
import RenderNode;
import MathOperations;

// Ghostwolf mentioned this to me once, so I used it,
// as 0.75, experimentally determined as a guess at
// whatever WC3 is doing. Do more reserach if necessary?
#define MAGIC_RENDER_SHOW_CONSTANT 0.75

// To keep track of what
struct CurrentKeyFrame {
	int start = -1;
	int end = 0;
	int left = 0;
	int right = 0;
};

export class SkeletalModelInstance {
  public:
	std::shared_ptr<mdx::MDX> model;

	int sequence_index = 0; // can be -1 if not animating
	int current_frame = 0;

	glm::quat inverseCameraRotationXSpin;
	glm::quat inverseCameraRotationYSpin;
	glm::quat inverseCameraRotationZSpin;

	glm::mat4 matrix = glm::mat4(1.f);
	glm::quat inverseInstanceRotation;

	std::vector<CurrentKeyFrame> current_keyframes;
	std::vector<RenderNode> render_nodes;
	std::vector<glm::mat4> world_matrices;

	SkeletalModelInstance() = default;
	explicit SkeletalModelInstance(std::shared_ptr<mdx::MDX> model)
		: model(model) {
		size_t node_count = model->bones.size() +
							model->lights.size() +
							model->help_bones.size() +
							model->attachments.size() +
							model->emitters1.size() +
							model->emitters2.size() +
							model->ribbons.size() +
							model->event_objects.size() +
							model->collision_shapes.size() +
							model->corn_emitters.size();

		// ToDo: for each camera: add camera source node to renderNodes
		render_nodes.resize(node_count);
		world_matrices.resize(node_count);
		model->forEachNode([&](mdx::Node& node) {
			// Seen it happen with Emmitter1, is this an error in the model?
			// ToDo purge (when adding a validation layer or just crashing)
			if (node.id == -1) {
				return;
			}

			RenderNode renderNode = RenderNode(node, model->pivots[node.id]);
			if (node.parent_id != -1) {
				renderNode.parent = &render_nodes[node.parent_id];
			} else {
				renderNode.parent = nullptr;
			}

			render_nodes[node.id] = renderNode;
		});

		current_keyframes.resize(model->unique_tracks);

		for (size_t i = 0; i < model->sequences.size(); i++) {
			if (model->sequences[i].name.find("Stand") != std::string::npos) {
				set_sequence(static_cast<int>(i));
				break;
			}
		}
	}

	void updateLocation(glm::vec3 position, float angle, const glm::vec3& scale) {
		glm::vec3 axis = glm::vec3(0, 0, 1);
		glm::quat rotation = glm::angleAxis(angle, axis);
		inverseInstanceRotation.x = -rotation.x;
		inverseInstanceRotation.y = -rotation.y;
		inverseInstanceRotation.z = -rotation.z;
		inverseInstanceRotation.w = rotation.w;
		fromRotationTranslationScaleOrigin(rotation, position, scale, matrix, glm::vec3(0, 0, 0));
	}

	void update(double delta) {
		if (model->sequences.empty() || sequence_index == -1) {
			return;
		}

		// Advance current frame
		const mdx::Sequence& sequence = model->sequences[sequence_index];
		if (sequence.flags & mdx::Sequence::non_looping) {
			current_frame = std::min<int>(current_frame + delta * 1000.0, sequence.end_frame);
		} else {
			current_frame += delta * 1000.0;
			if (current_frame > sequence.end_frame) {
				current_frame = sequence.start_frame;
			}
		}

		for (const auto& i : render_nodes) {
			advance_keyframes(i.node->KGTR);
			advance_keyframes(i.node->KGRT);
			advance_keyframes(i.node->KGSC);
		}

		for (const auto& i : model->animations) {
			advance_keyframes(i.KGAC);
			advance_keyframes(i.KGAO);
		}

		for (const auto& i : model->materials) {
			for (const auto& j : i.layers) {
				advance_keyframes(j.KMTA);
				// Add more when required
			}
		}

		updateNodes();
	}

	void updateNodes() {
		assert(sequence_index >= 0 && sequence_index < model->sequences.size());

		// update skeleton to position based on animation @ time
		for (auto& node : render_nodes) {
			// node.position = interpolate_keyframes(node.node->KGTR, TRANSLATION_IDENTITY);
			// node.rotation = interpolate_keyframes(node.node->KGRT, ROTATION_IDENTITY);
			// node.scale = interpolate_keyframes(node.node->KGSC, SCALE_IDENTITY);

			glm::vec3 position = interpolate_keyframes(node.node->KGTR, glm::vec3(0.f));
			glm::quat rotation = interpolate_keyframes(node.node->KGRT, glm::quat(1.f, 0.f, 0.f, 0.f));
			glm::vec3 scale = interpolate_keyframes(node.node->KGSC, glm::vec3(1.f));

			fromRotationTranslationScaleOrigin(rotation, position, scale, world_matrices[node.node->id], node.pivot);

			if (node.node->parent_id != -1) {
				world_matrices[node.node->id] = world_matrices[node.node->parent_id] * world_matrices[node.node->id];
			}

			// if (node.billboarded || node.billboardedX) {
			//	// Cancel the parent's rotation
			//	if (node.parent) {
			//		node.localRotation = node.parent->inverseWorldRotation * inverseInstanceRotation;
			//	} else {
			//		node.localRotation = inverseInstanceRotation;
			//	}

			//	node.localRotation *= camera->decomposed_rotation;
			//}

			// node.recalculateTransformation();
		}
	}

	/// Sets the current sequence to sequence_index and recalculates required keyframe data
	void set_sequence(int sequence_index) {
		this->sequence_index = sequence_index;
		current_frame = model->sequences[sequence_index].start_frame;

		for (const auto& i : render_nodes) {
			calculate_sequence_extents(i.node->KGTR);
			calculate_sequence_extents(i.node->KGRT);
			calculate_sequence_extents(i.node->KGSC);
		}

		for (const auto& i : model->animations) {
			calculate_sequence_extents(i.KGAC);
			calculate_sequence_extents(i.KGAO);
		}

		for (const auto& i : model->materials) {
			for (const auto& j : i.layers) {
				calculate_sequence_extents(j.KMTA);
				// Add more when required
			}
		}
	}

	template <typename T>
	void calculate_sequence_extents(const mdx::TrackHeader<T>& header) {
		if (header.id == -1) {
			return;
		}

		const mdx::Sequence& sequence = model->sequences[sequence_index];
		int local_sequence_start = sequence.start_frame;
		int local_sequence_end = sequence.end_frame;

		if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
			local_sequence_start = 0;
			local_sequence_end = model->global_sequences[header.global_sequence_ID];
		}

		CurrentKeyFrame& current = current_keyframes[header.id];
		current.start = -1;
		current.right = -1;

		// Find the sequence start and end tracks, these are not always exactly at the sequence start/end
		for (int i = 0; i < header.tracks.size(); i++) {
			const mdx::Track<T>& track = header.tracks[i];

			if (track.frame > local_sequence_end) {
				break;
			}

			if (track.frame >= local_sequence_start && current.start == -1) {
				current.start = i;
			}

			current.end = i;
		}

		// Set the starting left/right track index
		if (current.start != -1) {
			current.left = current.start;

			if (current.end > current.start) {
				current.right = current.left + 1;
			} else {
				current.right = current.left;
			}
		}
	}

	//template void calculate_sequence_extents(const mdx::TrackHeader<glm::vec3>& header);
	//template void calculate_sequence_extents(const mdx::TrackHeader<glm::quat>& header);

	template <typename T>
	void advance_keyframes(const mdx::TrackHeader<T>& header) {
		if (header.id == -1) {
			return;
		}
		CurrentKeyFrame& current = current_keyframes[header.id];

		int local_current_frame = current_frame;

		if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
			int local_sequence_end = model->global_sequences[header.global_sequence_ID];
			if (local_sequence_end == 0) {
				local_current_frame = 0;
			} else {
				local_current_frame = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % local_sequence_end;
			}
		}

		// If there are no tracks in sequence
		if (current.start == -1) {
			return;
		}

		// If there is only 1 track
		if (current.start == current.end) {
			return;
		}

		// Detect if we looped
		if (header.tracks[current.left].frame > local_current_frame) {
			current.left = current.start;
			current.right = current.start + 1;
		}

		// Scan till we find two tracks
		while (header.tracks[current.right].frame < local_current_frame) {
			current.left = current.right;
			current.right++;

			// Reached last keyframe
			if (current.right > current.end) {
				break;
			}

			// No need for interpolation if current_frame is exactly on a track
			if (header.tracks[current.right].frame == local_current_frame) {
				current.left = current.right;
			}
		}

		// The first/last tracks are not always exactly at the sequence start/end
		const bool past_end = header.tracks[current.end].frame < local_current_frame;
		const bool before_start = header.tracks[current.start].frame > local_current_frame;
		if (past_end || before_start) {
			current.left = current.end;
			current.right = current.start;
		}
	}

	//template void advance_keyframes(const mdx::TrackHeader<glm::vec3>& header);
	//template void advance_keyframes(const mdx::TrackHeader<glm::quat>& header);

	glm::vec3 get_geoset_animation_color(mdx::GeosetAnimation& animation) const {
		return interpolate_keyframes(animation.KGAC, animation.color);
	}

	float get_geoset_animation_visiblity(mdx::GeosetAnimation& animation) const {
		return interpolate_keyframes(animation.KGAO, animation.alpha);
	}

	float get_layer_visiblity(mdx::Layer& layer) const {
		return interpolate_keyframes(layer.KMTA, layer.alpha);
	}

	template <typename T>
	T interpolate_keyframes(mdx::TrackHeader<T>& header, const T& defaultValue) const {
		if (header.id == -1) {
			return defaultValue;
		}
		const CurrentKeyFrame& current = current_keyframes[header.id];
		const mdx::Sequence& sequence = model->sequences[sequence_index];

		int local_current_frame = current_frame;
		int local_sequence_start = sequence.start_frame;
		int local_sequence_end = sequence.end_frame;

		if (header.global_sequence_ID >= 0 && model->global_sequences.size()) {
			local_sequence_start = 0;
			local_sequence_end = model->global_sequences[header.global_sequence_ID];
			if (local_sequence_end == 0) {
				local_current_frame = 0;
			} else {
				local_current_frame = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() % local_sequence_end;
			}
		}

		// If there are no tracks in sequence
		if (current.start == -1) {
			return defaultValue;
		}

		// If there is only 1 track
		if (current.start == current.end) {
			return header.tracks[current.left].value;
		}

		const T ceilInTan = header.tracks[current.right].inTan;
		const T floorOutTan = header.tracks[current.left].outTan;

		int floor_time = header.tracks[current.left].frame;
		int ceil_time = header.tracks[current.right].frame;
		T floor_value = header.tracks[current.left].value;
		T ceil_value = header.tracks[current.right].value;

		// This is the implementation that correctly handles missing start/end frames.
		// The game and WE however have a buggy implementation which is the one we end up using for compatibility
		// float t;
		// if (ceil_time - floor_time < 0) {
		//	int duration = (local_sequence_end - floor_time) + (ceil_time - local_sequence_start);

		//	if (local_current_frame > floor_time) {
		//		t = (local_current_frame - floor_time) / (float)duration;
		//	} else {
		//		t = (local_current_frame - local_sequence_start + (local_sequence_end - floor_time)) / (float)duration;
		//	}
		//} else {
		//	t = (local_current_frame - floor_time) / static_cast<float>(ceil_time - floor_time);
		//}

		// The (incorrect) implementation both the game and WE use
		int timeBetweenFrames = ceil_time - floor_time;
		if (timeBetweenFrames < 0) {
			timeBetweenFrames += (local_sequence_end - local_sequence_start);
			if (local_current_frame < floor_time) {
				floor_time = ceil_time;
			}
		}
		float t = timeBetweenFrames == 0 ? 0.f : ((local_current_frame - floor_time) / static_cast<float>(timeBetweenFrames));

		return interpolate(floor_value, floorOutTan, ceilInTan, ceil_value, t, header.interpolation_type);
	}

	//template glm::vec3 interpolate_keyframes(mdx::TrackHeader<glm::vec3>& header, const glm::vec3& defaultValue) const;
	//template glm::quat interpolate_keyframes(mdx::TrackHeader<glm::quat>& header, const glm::quat& defaultValue) const;
};
```

`src/Resources/Texture.ixx`:

```ixx
module;

#include <vector>
#include <filesystem>
#include <SOIL2/SOIL2.h>

export module Texture;

namespace fs = std::filesystem;

import Hierarchy;
import BLP;
import BinaryReader;
import ResourceManager;

export class Texture : public Resource {
  public:
	int width;
	int height;
	int channels;
	std::vector<uint8_t> data;

	static constexpr const char* name = "Texture";

	explicit Texture() = default;
	Texture(const fs::path& path) {
		fs::path new_path = path;

		if (hierarchy.hd) {
			new_path.replace_filename(path.stem().string() + "_diffuse.dds");
		}
		if (!hierarchy.file_exists(new_path)) {
			new_path = path;
			new_path.replace_extension(".blp");
			if (!hierarchy.file_exists(new_path)) {
				new_path.replace_extension(".dds");
			}
		}

		BinaryReader reader = hierarchy.open_file(new_path);
		uint8_t* image_data;

		if (new_path.extension() == ".blp" || new_path.extension() == ".BLP") {
			image_data = blp::load(reader, width, height, channels);
		} else {
			image_data = SOIL_load_image_from_memory(reader.buffer.data(), static_cast<int>(reader.buffer.size()), &width, &height, &channels, SOIL_LOAD_AUTO);
		}
		data = std::vector<uint8_t>(image_data, image_data + width * height * channels);
		delete image_data;
	}
};
```

`src/Utilities.cpp`:

```cpp
#include "Utilities.h"

#include <sstream>
#include <iostream>
#include <fstream>
#include <algorithm> 
#include <cctype>
#include <locale>
#include <QSettings>
#include <QPainter>
#include <QIcon>
#include <QOpenGLFunctions_4_5_Core>

import Texture;
import ResourceManager;

#define GLM_FORCE_CXX17
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

#include <fmt/format.h>

QOpenGLFunctions_4_5_Core* gl;
Shapes shapes;


void Shapes::init() {
	gl->glCreateBuffers(1, &vertex_buffer);
	gl->glNamedBufferData(vertex_buffer, quad_vertices.size() * sizeof(glm::vec2), quad_vertices.data(), GL_STATIC_DRAW);

	gl->glCreateBuffers(1, &index_buffer);
	gl->glNamedBufferData(index_buffer, quad_indices.size() * sizeof(unsigned int) * 3, quad_indices.data(), GL_STATIC_DRAW);
}

std::string string_replaced(const std::string& source, const std::string& from, const std::string& to) {
	std::string new_string;
	new_string.reserve(source.length());  // avoids a few memory allocations

	size_t lastPos = 0;
	size_t findPos;

	while (std::string::npos != (findPos = source.find(from, lastPos))) {
		new_string.append(source, lastPos, findPos - lastPos);
		new_string += to;
		lastPos = findPos + from.length();
	}

	// Care for the rest after last occurrence
	new_string += source.substr(lastPos);

	return new_string;
}

std::string to_lowercase_copy(const std::string_view& string) {
	std::string output(string);
	std::transform(output.begin(), output.end(), output.begin(), [](unsigned char c) { return std::tolower(c); });
	return output;
}

void to_lowercase(std::string& string) {
	std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) { return std::tolower(c); });
}


// trim from start (in place)
void ltrim(std::string& s) {
	s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
		return !std::isspace(ch);
		}));
}

// trim from end (in place)
void rtrim(std::string& s) {
	s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
		return !std::isspace(ch);
		}).base(), s.end());
}

// trim from both ends (in place)
void trim(std::string& s) {
	ltrim(s);
	rtrim(s);
}

bool is_number(const std::string& s) {
	return !s.empty() && std::find_if(s.begin(), s.end(), [](char c) { return !std::isdigit(c); }) == s.end();
}

GLuint compile_shader(const fs::path& vertex_shader, const fs::path& fragment_shader) {
	char buffer[512];
	GLint status;

	std::string vertex_source = read_text_file(vertex_shader.string());
	std::string fragment_source = read_text_file(fragment_shader.string());

	const GLuint vertex = gl->glCreateShader(GL_VERTEX_SHADER);
	const GLuint fragment = gl->glCreateShader(GL_FRAGMENT_SHADER);

	// Vertex Shader
	const char* source = vertex_source.c_str();
	gl->glShaderSource(vertex, 1, &source, nullptr);
	gl->glCompileShader(vertex);


	gl->glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
	if (!status) {
		gl->glGetShaderInfoLog(vertex, 512, nullptr, buffer);
		fmt::print("{}\n{}\n", vertex_shader.string(), buffer);
		return -1;
	}

	// Fragment Shader
	source = fragment_source.c_str();
	gl->glShaderSource(fragment, 1, &source, nullptr);
	gl->glCompileShader(fragment);

	gl->glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
	if (!status) {
		gl->glGetShaderInfoLog(fragment, 512, nullptr, buffer);
		fmt::print("{}\n{}\n", fragment_shader.string(), buffer);
		return -1;
	}

	// Link
	const GLuint shader = gl->glCreateProgram();
	gl->glAttachShader(shader, vertex);
	gl->glAttachShader(shader, fragment);
	gl->glLinkProgram(shader);

	gl->glGetProgramiv(shader, GL_LINK_STATUS, &status);
	if (!status) {
		gl->glGetProgramInfoLog(shader, 512, nullptr, buffer);
		fmt::print("{}\n{}\n{}\n", vertex_shader.string(), fragment_shader.string(), buffer);
		return -1;
	}

	gl->glDeleteShader(vertex);
	gl->glDeleteShader(fragment);

	return shader;
}

std::string read_text_file(const fs::path& path) {
	std::ifstream textfile(path.c_str());
	std::string line;
	std::string text;

	if (!textfile.is_open())
		return "";

	while (getline(textfile, line)) {
		text += line + "\n";
	}

	return text;
}

fs::path find_warcraft_directory() {
	QSettings settings;
	if (settings.contains("warcraftDirectory")) {
		return settings.value("warcraftDirectory").toString().toStdString();
	} else if (fs::exists("C:/Program Files/Warcraft III")) {
		return "C:/Program Files/Warcraft III";
	} else if (fs::exists("C:/Program Files (x86)/Warcraft III")) {
		return "C:/Program Files (x86)/Warcraft III";
	} else {
		return "";
	}
}

void load_modification_file(const std::string file_name, slk::SLK& base_data, slk::SLK& meta_slk, bool optional_ints) {
	BinaryReader reader = hierarchy.map_file_read(file_name);

	const int version = reader.read<uint32_t>();
	if (version != 1 && version != 2 && version != 3) {
		std::cout << "Unknown modification table version of " << version << " detected. Attempting to load, but may crash.\n";
	}

	load_modification_table(reader, version, base_data, meta_slk, false, optional_ints);
	load_modification_table(reader, version, base_data, meta_slk, true, optional_ints);
}

void load_modification_table(BinaryReader& reader, uint32_t version, slk::SLK& slk, slk::SLK& meta_slk, const bool modification, bool optional_ints) {
	const uint32_t objects = reader.read<uint32_t>();
	for (size_t i = 0; i < objects; i++) {
		const std::string original_id = reader.read_string(4);
		const std::string modified_id = reader.read_string(4);

		if (version >= 3) {
			reader.advance(4 * reader.read<uint32_t>());
		}
		if (modification && !slk.base_data.contains(modified_id)) {
			slk.copy_row(original_id, modified_id, false);
		}

		const uint32_t modifications = reader.read<uint32_t>();

		for (size_t j = 0; j < modifications; j++) {
			const std::string modification_id = reader.read_string(4);
			const uint32_t type = reader.read<uint32_t>();

			std::string column_header = to_lowercase_copy(meta_slk.data("field", modification_id));
			if (optional_ints) {
				uint32_t level_variation = reader.read<uint32_t>();
				uint32_t data_pointer = reader.read<uint32_t>();
				if (data_pointer != 0) {
					column_header += char('a' + data_pointer - 1);
				}
				if (level_variation != 0) {
					column_header += std::to_string(level_variation);
				}

				// Can remove after checking whether this holds for many maps
				if (data_pointer != 0 && level_variation == 0) {
					assert(!(data_pointer != 0 && level_variation == 0));
				}
			}

			std::string data;
			switch (type) {
				case 0:
					data = std::to_string(reader.read<int>());
					break;
				case 1:
				case 2:
					data = std::to_string(reader.read<float>());
					break;
				case 3:
					data = reader.read_c_string();
					break;
				default: 
					std::cout << "Unknown data type " << type << " while loading modification table.";
			}
			reader.advance(4);

			if (column_header == "") {
				std::cout << "Unknown mod id: " << modification_id << "\n";
				continue;
			}

			if (modification) {
				slk.set_shadow_data(column_header, modified_id, data);
			} else {
				slk.set_shadow_data(column_header, original_id, data);
			}
		}
	}
}

void save_modification_file(const std::string file_name, slk::SLK& slk, slk::SLK& meta_slk, bool optional_ints, bool skin) {
	BinaryWriter writer;
	writer.write<uint32_t>(mod_table_write_version);

	save_modification_table(writer, slk, meta_slk, false, optional_ints, skin);
	save_modification_table(writer, slk, meta_slk, true, optional_ints, skin);

	hierarchy.map_file_write(file_name, writer.buffer);
}

// The idea of SLKs and mod files is quite bad, but I can deal with them
// The way they are implemented is horrible though
void save_modification_table(BinaryWriter& writer, slk::SLK& slk, slk::SLK& meta_slk, bool custom, bool optional_ints, bool skin) {
	// Create an temporary index to speed up field lookups
	absl::flat_hash_map<std::string, std::string> meta_index;
	for (const auto& [key, dontcare2] : meta_slk.row_headers) {
		std::string field = to_lowercase_copy(meta_slk.data("field", key));
		meta_index[field] = key;
	}

	BinaryWriter sub_writer;

	size_t count = 0;
	for (const auto& [id, properties] : slk.shadow_data) {
		// If we are writing custom objects then we only want rows with oldid set as the others are base rows
		if (!custom && properties.contains("oldid")) {
			continue;
		} else if (custom && !properties.contains("oldid")) {
			continue;
		}
		count++;

		if (custom) {
			sub_writer.write_string(properties.at("oldid"));
			sub_writer.write_string(id);
		} else {
			sub_writer.write_string(id);
			sub_writer.write<uint32_t>(0);
		}

		// 1.33 fields not yet researched
		sub_writer.write<uint32_t>(1);
		sub_writer.write<uint32_t>(0);

		// Split properties, or another way to save war3mapSkin.w3* files correctly?
		// netsafe slk field is probably what vanilla uses (if anyone wants to try this)
		// No changes in skin files and all in main ones is a valid state, but not nice
		if (skin) {
			sub_writer.write<uint32_t>(0); // "no changes"
			continue;
		}
		sub_writer.write<uint32_t>(properties.size() - (properties.contains("oldid") ? 1 : 0));

		const std::string base_id = custom ? properties.at("oldid") : id;
		std::string meta_id = custom ? properties.at("oldid") : id;
		if (slk.column_headers.contains("code")) {
			meta_id = slk.data("code", meta_id);
		}

		for (const auto& [property_id, value] : properties) {
			if (property_id == "oldid") {
				continue;
			}

			// Find the metadata ID for this field name since modification files are stupid
			std::string meta_data_key;

			int variation = 0;
			int data_pointer = 0;
			if (meta_index.contains(property_id)) {
				meta_data_key = meta_index.at(property_id);
			} else {
				// First strip off the variation/level
				size_t nr_position = property_id.find_first_of("0123456789");
				std::string without_numbers = property_id.substr(0, nr_position);

				if (nr_position != std::string::npos) {
					variation = std::stoi(property_id.substr(nr_position));
				}

				if (meta_index.contains(without_numbers)) {
					meta_data_key = meta_index.at(without_numbers);
				} else {
					// If it is a data field then it will contain a data_pointer/column at the end
					if (without_numbers.starts_with("data")) {
						data_pointer = without_numbers[4] - 'a' + 1;
						without_numbers = "data";
					}

					if (without_numbers == "data" || without_numbers == "unitid" || without_numbers == "cast") {
						// Unfortunately mapping a data field to a key is not easy so we have to iterate over the entire meta_slk
						for (const auto& [key, dontcare2] : meta_slk.row_headers) {
							if (meta_slk.data<int>("data", key) != data_pointer) {
								continue;
							}

							if (to_lowercase_copy(meta_slk.data("field", key)) != without_numbers) {
								continue;
							}

							std::string use_specific = meta_slk.data("usespecific", key);
							std::string not_specific = meta_slk.data("notspecific", key);

							// If we are in the exclude list
							if (not_specific.find(meta_id) != std::string::npos) {
								continue;
							}

							// If the include list is not empty and we are not inside
							if (!use_specific.empty() && use_specific.find(meta_id) == std::string::npos && use_specific.find(base_id) == std::string::npos) {
								continue;
							}

							meta_data_key = key;
							break;
						}
					}
				}

				if (meta_data_key.empty()) {
					puts("Empty meta data key");
					exit(0);
				}
			}

			if (meta_data_key.empty()) {
				puts("Empty meta data key");
				exit(0);
			}

			sub_writer.write_string(meta_data_key);
			
			int write_type = -1;
			const std::string type = meta_slk.data("type", meta_data_key);
			if (type == "int" 
				|| type == "bool" 
				|| type.ends_with("Flags") 
				|| type == "attackBits" 
				|| type == "channelType" 
				|| type == "deathType" 
				|| type == "defenseTypeInt" 
				|| type == "detectionType" 
				|| type == "spellDetail" 
				|| type == "teamColor" 
				|| type == "techAvail") {

				write_type = 0;
			} else if (type == "real") {
				write_type = 1;
			} else if (type == "unreal") {
				write_type = 2;
			} else { // string
				write_type = 3;
			}

			sub_writer.write<uint32_t>(write_type);

			if (optional_ints) {
				sub_writer.write<uint32_t>(variation);
				sub_writer.write<uint32_t>(data_pointer);
			}

			if (write_type == 0) {
				sub_writer.write<int>(std::stoi(value));
			} else if (write_type == 1 || write_type == 2) {
				sub_writer.write<float>(std::stof(value));
			} else {
				sub_writer.write_c_string(value);
			}

			sub_writer.write<uint32_t>(0);
		}
	}

	writer.write<uint32_t>(count);
	writer.write_vector(sub_writer.buffer);
}

QIcon ground_texture_to_icon(uint8_t* data, const int width, const int height) {
	QImage temp_image = QImage(data, width, height, QImage::Format::Format_RGBA8888);
	const int size = height / 4;

	auto pix = QPixmap::fromImage(temp_image.copy(0, 0, size, size));

	QIcon icon;
	icon.addPixmap(pix, QIcon::Normal, QIcon::Off);

	QPainter painter(&pix);
	painter.fillRect(0, 0, size, size, QColor(255, 255, 0, 64));
	painter.end();

	icon.addPixmap(pix, QIcon::Normal, QIcon::On);

	return icon;
}

QIcon texture_to_icon(fs::path path) { 
	auto tex = resource_manager.load<Texture>(path);
	QImage temp_image = QImage(tex->data.data(), tex->width, tex->height, tex->channels == 3 ? QImage::Format::Format_RGB888 : QImage::Format::Format_RGBA8888);
	auto pix = QPixmap::fromImage(temp_image);
	return QIcon(pix);
};

const glm::vec3 TRANSLATION_IDENTITY(0);
const glm::vec3 SCALE_IDENTITY(1);
const glm::quat ROTATION_IDENTITY(1, 0, 0, 0);

// Equivalent to, but much faster than
// worldMatrix = glm::translate(glm::mat4(1.f), position);
// worldMatrix = glm::translate(worldMatrix, pivot);
// worldMatrix *= glm::mat4_cast(rotation);
// worldMatrix = glm::scale(worldMatrix, scale);
// worldMatrix = glm::translate(worldMatrix, -pivot);
//#define TEST_MODE 1
void fromRotationTranslationScaleOrigin(const glm::quat& q, const glm::vec3& v, const glm::vec3& s, glm::mat4& out, const glm::vec3& pivot) {
	// ho tom bambadil
	// tom bombadillo
	// Retera was here
	// (This code is copied from the holy bible)
	float x = q.x;
	float y = q.y;
	float z = q.z;
	float w = q.w;
	float x2 = x + x;
	float y2 = y + y;
	float z2 = z + z;
	float xx = x * x2;
	float xy = x * y2;
	float xz = x * z2;
	float yy = y * y2;
	float yz = y * z2;
	float zz = z * z2;
	float wx = w * x2;
	float wy = w * y2;
	float wz = w * z2;
	float sx = s.x;
	float sy = s.y;
	float sz = s.z;
#ifdef TEST_MODE
	out[0][0] = (1 - (yy + zz)) * sx;
	out[1][0] = (xy + wz) * sx;
	out[2][0] = (xz - wy) * sx;
	out[3][0] = 0;
	out[0][1] = (xy - wz) * sy;
	out[1][1] = (1 - (xx + zz)) * sy;
	out[2][1] = (yz + wx) * sy;
	out[3][1] = 0;
	out[0][2] = (xz + wy) * sz;
	out[1][2] = (yz - wx) * sz;
	out[2][2] = (1 - (xx + yy)) * sz;
	out[3][2] = 0;
	out[0][3] = v.x + pivot.x - (out[0][0] * pivot.x + out[0][1] * pivot.y + out[0][2] * pivot.z);
	out[1][3] = v.y + pivot.y - (out[1][0] * pivot.x + out[1][1] * pivot.y + out[1][2] * pivot.z);
	out[2][3] = v.z + pivot.z - (out[2][0] * pivot.x + out[2][1] * pivot.y + out[2][2] * pivot.z);
	out[3][3] = 1;
#else
	out[0][0] = (1 - (yy + zz)) * sx;
	out[0][1] = (xy + wz) * sx;
	out[0][2] = (xz - wy) * sx;
	out[0][3] = 0;
	out[1][0] = (xy - wz) * sy;
	out[1][1] = (1 - (xx + zz)) * sy;
	out[1][2] = (yz + wx) * sy;
	out[1][3] = 0;
	out[2][0] = (xz + wy) * sz;
	out[2][1] = (yz - wx) * sz;
	out[2][2] = (1 - (xx + yy)) * sz;
	out[2][3] = 0;
	out[3][0] = v.x + pivot.x - (out[0][0] * pivot.x + out[1][0] * pivot.y + out[2][0] * pivot.z);
	out[3][1] = v.y + pivot.y - (out[0][1] * pivot.x + out[1][1] * pivot.y + out[2][1] * pivot.z);
	out[3][2] = v.z + pivot.z - (out[0][2] * pivot.x + out[1][2] * pivot.y + out[2][2] * pivot.z);
	out[3][3] = 1;
#endif
}


float hermite(float a, float aOutTan, float bInTan, float b, float t) {
	float factorTimes2 = t * t;
	float factor1 = factorTimes2 * (2 * t - 3) + 1;
	float factor2 = factorTimes2 * (t - 2) + t;
	float factor3 = factorTimes2 * (t - 1);
	float factor4 = factorTimes2 * (3 - 2 * t);
	return (a * factor1) + (aOutTan * factor2) + (bInTan * factor3) + (b * factor4);
}
float bezier(float a, float aOutTan, float bInTan, float b, float t) {
	float invt = 1 - t;
	float factorSquared = t * t;
	float inverseFactorSquared = invt * invt;
	float factor1 = inverseFactorSquared * invt;
	float factor2 = 3 * t * inverseFactorSquared;
	float factor3 = 3 * factorSquared * invt;
	float factor4 = factorSquared * t;
	return (a * factor1) + (aOutTan * factor2) + (bInTan * factor3) + (b * factor4);
}

//template <typename T>
//inline void interpolate(T& out, const T* start, const T* outTan, const T* inTan, const T* end, float t, int interpolationType) {
//	out = *start;
//}

float interpolate(const float start, const float outTan, const float inTan, const float end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::mix(start, end, t);
		case 2: // HERMITE
			return hermite(start, outTan, inTan, end, t);
		case 3: // BEZIER
			return bezier(start, outTan, inTan, end, t);
		default:
			return start;
	}
}

glm::vec3 interpolate(const glm::vec3 start, const glm::vec3 outTan, const glm::vec3 inTan, const glm::vec3 end, float t, int interpolationType) {
	switch (interpolationType) {
		glm::vec3 out;
		case 1: // LINEAR
			return glm::mix(start, end, t);
		case 2: // HERMITE
			out.x = hermite(start.x, outTan.x, inTan.x, end.x, t);
			out.y = hermite(start.y, outTan.y, inTan.y, end.y, t);
			out.z = hermite(start.z, outTan.z, inTan.z, end.z, t);
			return out;
		case 3: // BEZIER
			out.x = bezier(start.x, outTan.x, inTan.x, end.x, t);
			out.y = bezier(start.y, outTan.y, inTan.y, end.y, t);
			out.z = bezier(start.z, outTan.z, inTan.z, end.z, t);
			return out;
		default:
			return start;
	}
}
glm::quat interpolate(const glm::quat start, const glm::quat outTan, const glm::quat inTan, const glm::quat end, float t, int interpolationType) {
	switch (interpolationType) {
		case 1: // LINEAR
			return glm::slerp(start, end, t);
		case 2: // HERMITE
			// GLM uses both {x, y, z, w} and {w, x, y, z} convention, in different places, sometimes.
			// Their squad is {w, x, y, z} but we are elsewhere using {x, y, z, w}, so we will
			// continue using the copy of the Matrix Eater "ghostwolfSquad" for now.
			//out = glm::squad(*start, *outTan, *inTan, *end, t);
			return ghostwolfSquad(start, outTan, inTan, end, t);
		case 3: // BEZIER
			// GLM uses both {x, y, z, w} and {w, x, y, z} convention, in different places, sometimes.
			// Their squad is {w, x, y, z} but we are elsewhere using {x, y, z, w}, so we will
			// continue using the copy of the Matrix Eater "ghostwolfSquad" for now.
			//out = glm::squad(*start, *outTan, *inTan, *end, t);
			return ghostwolfSquad(start, outTan, inTan, end, t);
		default:
			return start;
	}
}
uint32_t interpolate(const uint32_t start, const uint32_t outTan, const uint32_t inTan, const uint32_t end, float t, int interpolationType) {
	return start;
}

glm::quat ghostwolfSquad(const glm::quat a, const glm::quat aOutTan, const glm::quat bInTan, const glm::quat b, float t) {
	glm::quat temp1;
	glm::quat temp2;
	temp1 = glm::slerp(a, b, t);
	temp2 = glm::slerp(aOutTan, bInTan, t);
	return glm::slerp(temp1, temp2, 2 * t * (1 - t));
}

glm::quat safeQuatLookAt(
	glm::vec3 const& lookFrom,
	glm::vec3 const& lookTo,
	glm::vec3 const& up,
	glm::vec3 const& alternativeUp) {
	glm::vec3 direction = lookTo - lookFrom;
	float directionLength = glm::length(direction);

	// Check if the direction is valid; Also deals with NaN
	if (!(directionLength > 0.0001))
		return glm::quat(1, 0, 0, 0); // Just return identity

	// Normalize direction
	direction /= directionLength;

	// Is the normal up (nearly) parallel to direction?
	if (glm::abs(glm::dot(direction, up)) > .9999f) {
		// Use alternative up
		return glm::quatLookAt(direction, alternativeUp);
	} else {
		return glm::quatLookAt(direction, up);
	}
}
```

`src/Utilities.h`:

```h
#pragma once

#include <vector>
#include <filesystem>
#include <QOpenGLFunctions_4_5_Core>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
import BinaryReader;
import BinaryWriter;
#include "SLK.h"

constexpr int mod_table_write_version = 3;
namespace fs = std::filesystem;

class Shapes {
public:
	void init();

	GLuint vertex_buffer;
	GLuint index_buffer;

	const std::vector<glm::vec2> quad_vertices = {
		{ 1, 1 },
		{ 0, 1 },
		{ 0, 0 },
		{ 1, 0 }
	};

	const std::vector<glm::uvec3> quad_indices = {
		{ 0, 1, 2 },
		{ 2, 3, 0 }
	};
};

// String functions
std::string string_replaced(const std::string& source, const std::string& from, const std::string& to);

std::string to_lowercase_copy(const std::string_view& string);
void to_lowercase(std::string& string);

void ltrim(std::string& s);
void rtrim(std::string& s);
void trim(std::string& s);

bool is_number(const std::string& s);

GLuint compile_shader(const fs::path& vertex_shader, const fs::path& fragment_shader);

std::string read_text_file(const fs::path& path);

fs::path find_warcraft_directory();

void load_modification_file(const std::string file_name, slk::SLK& base_data, slk::SLK& meta_slk, bool optional_ints);
void load_modification_table(BinaryReader& reader, uint32_t version, slk::SLK& slk, slk::SLK& meta_slk, bool modification, bool optional_ints);
void save_modification_file(const std::string file_name, slk::SLK& slk, slk::SLK& meta_slk, bool optional_ints, bool skin);
void save_modification_table(BinaryWriter& writer, slk::SLK& slk, slk::SLK& meta_slk, bool custom, bool optional_ints, bool skin);

/// Convert a Tground texture into an QIcon with two states
QIcon ground_texture_to_icon(uint8_t* data, int width, int height);

/// Loads a texture from the hierarchy and returns an icon
QIcon texture_to_icon(fs::path);

extern QOpenGLFunctions_4_5_Core* gl;
extern Shapes shapes;

struct ItemSet {
	std::vector<std::pair<std::string, int>> items;
};

extern const glm::vec3 TRANSLATION_IDENTITY;
extern const glm::quat ROTATION_IDENTITY;
extern const glm::vec3 SCALE_IDENTITY;

float interpolate(const float start, const float outTan, const float inTan, const float end, float t, int interpolationType);
glm::vec3 interpolate(const glm::vec3 start, const glm::vec3 outTan, const glm::vec3 inTan, const glm::vec3 end, float t, int interpolationType);
glm::quat interpolate(const glm::quat start, const glm::quat outTan, const glm::quat inTan, const glm::quat end, float t, int interpolationType);
uint32_t interpolate(const uint32_t start, const uint32_t outTan, const uint32_t inTan, const uint32_t end, float t, int interpolationType);

/* ToDo replace these with some library calls (glm?), Ghostwolf said it was bad
   practice for me to copy them everywhere (Retera here, also copied them in Matrix Eater)
*/
float hermite(float a, float aOutTan, float bInTan, float b, float t);
float bezier(float a, float aOutTan, float bInTan, float b, float t);
glm::quat ghostwolfSquad(const glm::quat a, const glm::quat aOutTan, const glm::quat bInTan, const glm::quat b, float interpolationFactor);

glm::quat safeQuatLookAt(
	glm::vec3 const& lookFrom,
	glm::vec3 const& lookTo,
	glm::vec3 const& up,
	glm::vec3 const& alternativeUp);

void fromRotationTranslationScaleOrigin(const glm::quat& localRotation, const glm::vec3& computedLocation, const glm::vec3& computedScaling, glm::mat4& localMatrix, const glm::vec3& pivot);
```

`src/Utilities/ModificationTables.ixx`:

```ixx
module;

#include <SLK.h>

export module ModificationTables;

import<vector>;
import<string>;
import<filesystem>;
import<fstream>;
import<iostream>;

import BinaryReader;
import BinaryWriter;


namespace fs = std::filesystem;
//
//export void load_modification_table(BinaryReader& reader, SLK& slk, const SLK& meta_slk, const bool modification, bool optional_ints) {
//	const uint32_t objects = reader.read<uint32_t>();
//	for (size_t i = 0; i < objects; i++) {
//		const std::string original_id = reader.read_string(4);
//		const std::string modified_id = reader.read_string(4);
//
//		if (modification) {
//			slk.copy_row(original_id, modified_id, false);
//		}
//
//		const uint32_t modifications = reader.read<uint32_t>();
//
//		for (size_t j = 0; j < modifications; j++) {
//			const std::string modification_id = reader.read_string(4);
//			const uint32_t type = reader.read<uint32_t>();
//
//			std::string column_header = to_lowercase_copy(meta_slk.data("field", modification_id));
//			if (optional_ints) {
//				uint32_t level_variation = reader.read<uint32_t>();
//				uint32_t data_pointer = reader.read<uint32_t>();
//				if (data_pointer != 0) {
//					column_header += char('a' + data_pointer - 1);
//				}
//				if (level_variation != 0) {
//					column_header += std::to_string(level_variation);
//				}
//
//				// Can remove after checking whether this holds for many maps
//				if (data_pointer != 0 && level_variation == 0) {
//					assert(!(data_pointer != 0 && level_variation == 0));
//				}
//			}
//
//			std::string data;
//			switch (type) {
//				case 0:
//					data = std::to_string(reader.read<int>());
//					break;
//				case 1:
//				case 2:
//					data = std::to_string(reader.read<float>());
//					break;
//				case 3:
//					data = reader.read_c_string();
//					break;
//				default:
//					std::cout << "Unknown data type " << type << " while loading modification table.";
//			}
//			reader.advance(4);
//
//			if (column_header == "") {
//				std::cout << "Unknown mod id: " << modification_id << "\n";
//				continue;
//			}
//
//			if (modification) {
//				slk.set_shadow_data(column_header, modified_id, data);
//			} else {
//				slk.set_shadow_data(column_header, original_id, data);
//			}
//		}
//	}
//}
//
//export void load_modification_file(const fs::path& file_name, SLK& base_data, const SLK& meta_slk, bool optional_ints) {
//	BinaryReader reader = hierarchy.map_file_read(file_name);
//
//	const int version = reader.read<uint32_t>();
//	if (version != 1 && version != 2) {
//		std::cout << "Unknown modification table version of " << version << " detected. Attempting to load, but may crash.\n";
//	}
//
//	load_modification_table(reader, base_data, meta_slk, false, optional_ints);
//	load_modification_table(reader, base_data, meta_slk, true, optional_ints);
//}
//
//// The idea of SLKs and mod files is quite bad, but I can deal with them
//// The way they are implemented is horrible though
//export void save_modification_table(BinaryWriter& writer, const SLK& slk, const SLK& meta_slk, bool custom, bool optional_ints) {
//	// Create an temporary index to speed up field lookups
//	absl::flat_hash_map<std::string, std::string> meta_index;
//	for (const auto& [key, dontcare2] : meta_slk.row_headers) {
//		std::string field = to_lowercase_copy(meta_slk.data("field", key));
//		meta_index[field] = key;
//	}
//
//	BinaryWriter sub_writer;
//
//	size_t count = 0;
//	for (const auto& [id, properties] : slk.shadow_data) {
//		// If we are writing custom objects then we only want rows with oldid set as the others are base rows
//		if (!custom && properties.contains("oldid")) {
//			continue;
//		} else if (custom && !properties.contains("oldid")) {
//			continue;
//		}
//		count++;
//
//		if (custom) {
//			sub_writer.write_string(properties.at("oldid"));
//			sub_writer.write_string(id);
//		} else {
//			sub_writer.write_string(id);
//			sub_writer.write<uint32_t>(0);
//		}
//
//		sub_writer.write<uint32_t>(properties.size() - (properties.contains("oldid") ? 1 : 0));
//
//		const std::string base_id = custom ? properties.at("oldid") : id;
//		std::string meta_id = custom ? properties.at("oldid") : id;
//		if (slk.column_headers.contains("code")) {
//			meta_id = slk.data("code", meta_id);
//		}
//
//		for (const auto& [property_id, value] : properties) {
//			if (property_id == "oldid") {
//				continue;
//			}
//
//			// Find the metadata ID for this field name since modification files are stupid
//			std::string meta_data_key;
//
//			int variation = 0;
//			int data_pointer = 0;
//			if (meta_index.contains(property_id)) {
//				meta_data_key = meta_index.at(property_id);
//			} else {
//				// First strip off the variation/level
//				size_t nr_position = property_id.find_first_of("0123456789");
//				std::string without_numbers = property_id.substr(0, nr_position);
//
//				if (nr_position != std::string::npos) {
//					variation = std::stoi(property_id.substr(nr_position));
//				}
//
//				if (meta_index.contains(without_numbers)) {
//					meta_data_key = meta_index.at(without_numbers);
//				} else {
//					// If it is a data field then it will contain a data_pointer/column at the end
//					if (without_numbers.starts_with("data")) {
//						data_pointer = without_numbers[4] - 'a' + 1;
//						without_numbers = "data";
//					}
//
//					if (without_numbers == "data" || without_numbers == "unitid" || without_numbers == "cast") {
//						// Unfortunately mapping a data field to a key is not easy so we have to iterate over the entire meta_slk
//						for (const auto& [key, dontcare2] : meta_slk.row_headers) {
//							if (meta_slk.data<int>("data", key) != data_pointer) {
//								continue;
//							}
//
//							if (to_lowercase_copy(meta_slk.data("field", key)) != without_numbers) {
//								continue;
//							}
//
//							std::string use_specific = meta_slk.data("usespecific", key);
//							std::string not_specific = meta_slk.data("notspecific", key);
//
//							// If we are in the exclude list
//							if (not_specific.find(meta_id) != std::string::npos) {
//								continue;
//							}
//
//							// If the include list is not empty and we are not inside
//							if (!use_specific.empty() && use_specific.find(meta_id) == std::string::npos && use_specific.find(base_id) == std::string::npos) {
//								continue;
//							}
//
//							meta_data_key = key;
//							break;
//						}
//					}
//				}
//
//				if (meta_data_key.empty()) {
//					puts("Empty meta data key");
//					exit(0);
//				}
//			}
//
//			if (meta_data_key.empty()) {
//				puts("Empty meta data key");
//				exit(0);
//			}
//
//			sub_writer.write_string(meta_data_key);
//
//			int write_type = -1;
//			const std::string type = meta_slk.data("type", meta_data_key);
//			if (type == "int" || type == "bool" || type.ends_with("Flags") || type == "attackBits" || type == "channelType" || type == "deathType" || type == "defenseTypeInt" || type == "detectionType" || type == "spellDetail" || type == "teamColor" || type == "techAvail") {
//
//				write_type = 0;
//			} else if (type == "real") {
//				write_type = 1;
//			} else if (type == "unreal") {
//				write_type = 2;
//			} else { // string
//				write_type = 3;
//			}
//
//			sub_writer.write<uint32_t>(write_type);
//
//			if (optional_ints) {
//				sub_writer.write<uint32_t>(variation);
//				sub_writer.write<uint32_t>(data_pointer);
//			}
//
//			if (write_type == 0) {
//				sub_writer.write<int>(std::stoi(value));
//			} else if (write_type == 1 || write_type == 2) {
//				sub_writer.write<float>(std::stof(value));
//			} else {
//				sub_writer.write_c_string(value);
//			}
//
//			sub_writer.write<uint32_t>(0);
//		}
//	}
//
//	writer.write<uint32_t>(count);
//	writer.write_vector(sub_writer.buffer);
//}
//
//export void save_modification_file(const fs::path& file_name, const SLK& slk, const SLK& meta_slk, bool optional_ints) {
//	BinaryWriter writer;
//	writer.write<uint32_t>(mod_table_write_version);
//
//	save_modification_table(writer, slk, meta_slk, false, optional_ints);
//	save_modification_table(writer, slk, meta_slk, true, optional_ints);
//
//	hierarchy.map_file_write(file_name, writer.buffer);
//}
```

`src/Utilities/OpenGLUtilities.cpp`:

```cpp
#include "OpenGLUtilities.h"

#include <sstream>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <cctype>
#include <locale>
#include <QSettings>
#include <QPainter>
#include <QIcon>
#include <QOpenGLFunctions_4_5_Core>

#include <filesystem>
namespace fs = std::filesystem;

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/quaternion.hpp>

#include <fmt/format.h>

import Texture;
import ResourceManager;
import Utilities;

QOpenGLFunctions_4_5_Core* gl;
Shapes shapes;

void Shapes::init() {
	const std::vector<glm::vec2> quad_vertices = {
		{ 1, 1 },
		{ 0, 1 },
		{ 0, 0 },
		{ 1, 0 }
	};

	const std::vector<glm::uvec3> quad_indices = {
		{ 0, 1, 2 },
		{ 2, 3, 0 }
	};

	gl->glCreateBuffers(1, &vertex_buffer);
	gl->glNamedBufferData(vertex_buffer, quad_vertices.size() * sizeof(glm::vec2), quad_vertices.data(), GL_STATIC_DRAW);

	gl->glCreateBuffers(1, &index_buffer);
	gl->glNamedBufferData(index_buffer, quad_indices.size() * sizeof(unsigned int) * 3, quad_indices.data(), GL_STATIC_DRAW);
}

GLuint compile_shader(const fs::path& vertex_shader, const fs::path& fragment_shader) {
	char buffer[512];
	GLint status;

	std::string vertex_source = read_text_file(vertex_shader.string());
	std::string fragment_source = read_text_file(fragment_shader.string());

	const GLuint vertex = gl->glCreateShader(GL_VERTEX_SHADER);
	const GLuint fragment = gl->glCreateShader(GL_FRAGMENT_SHADER);

	// Vertex Shader
	const char* source = vertex_source.c_str();
	gl->glShaderSource(vertex, 1, &source, nullptr);
	gl->glCompileShader(vertex);

	gl->glGetShaderiv(vertex, GL_COMPILE_STATUS, &status);
	if (!status) {
		gl->glGetShaderInfoLog(vertex, 512, nullptr, buffer);
		fmt::print("{}\n{}\n", vertex_shader.string(), buffer);
		return -1;
	}

	// Fragment Shader
	source = fragment_source.c_str();
	gl->glShaderSource(fragment, 1, &source, nullptr);
	gl->glCompileShader(fragment);

	gl->glGetShaderiv(fragment, GL_COMPILE_STATUS, &status);
	if (!status) {
		gl->glGetShaderInfoLog(fragment, 512, nullptr, buffer);
		fmt::print("{}\n{}\n", fragment_shader.string(), buffer);
		return -1;
	}

	// Link
	const GLuint shader = gl->glCreateProgram();
	gl->glAttachShader(shader, vertex);
	gl->glAttachShader(shader, fragment);
	gl->glLinkProgram(shader);

	gl->glGetProgramiv(shader, GL_LINK_STATUS, &status);
	if (!status) {
		gl->glGetProgramInfoLog(shader, 512, nullptr, buffer);
		fmt::print("{}\n{}\n{}\n", vertex_shader.string(), fragment_shader.string(), buffer);
		return -1;
	}

	gl->glDeleteShader(vertex);
	gl->glDeleteShader(fragment);

	return shader;
}

QIcon ground_texture_to_icon(uint8_t* data, const int width, const int height) {
	QImage temp_image = QImage(data, width, height, QImage::Format::Format_RGBA8888);
	const int size = height / 4;

	auto pix = QPixmap::fromImage(temp_image.copy(0, 0, size, size));

	QIcon icon;
	icon.addPixmap(pix, QIcon::Normal, QIcon::Off);

	QPainter painter(&pix);
	painter.fillRect(0, 0, size, size, QColor(255, 255, 0, 64));
	painter.end();

	icon.addPixmap(pix, QIcon::Normal, QIcon::On);

	return icon;
}

QIcon texture_to_icon(fs::path path) {
	auto tex = resource_manager.load<Texture>(path);
	QImage temp_image = QImage(tex->data.data(), tex->width, tex->height, tex->channels == 3 ? QImage::Format::Format_RGB888 : QImage::Format::Format_RGBA8888);
	auto pix = QPixmap::fromImage(temp_image);
	return QIcon(pix);
};

fs::path find_warcraft_directory() {
	QSettings settings;
	if (settings.contains("warcraftDirectory")) {
		return settings.value("warcraftDirectory").toString().toStdString();
	} else if (fs::exists("C:/Program Files/Warcraft III")) {
		return "C:/Program Files/Warcraft III";
	} else if (fs::exists("C:/Program Files (x86)/Warcraft III")) {
		return "C:/Program Files (x86)/Warcraft III";
	} else {
		return "";
	}
}
```

`src/Utilities/OpenGLUtilities.h`:

```h
#pragma once

#include <vector>
#include <filesystem>

#include <QOpenGLFunctions_4_5_Core>

import BinaryReader;
import BinaryWriter;
#include <SLK.h>

namespace fs = std::filesystem;

class Shapes {
  public:
	void init();

	GLuint vertex_buffer;
	GLuint index_buffer;

	static constexpr int vertex_count = 4;
	static constexpr int index_count = 2;
};

GLuint compile_shader(const fs::path& vertex_shader, const fs::path& fragment_shader);

/// Convert a Tground texture into an QIcon with two states
QIcon ground_texture_to_icon(uint8_t* data, int width, int height);

/// Loads a texture from the hierarchy and returns an icon
QIcon texture_to_icon(fs::path);

fs::path find_warcraft_directory();

extern QOpenGLFunctions_4_5_Core* gl;
extern Shapes shapes;

```

`src/Utilities/Timer.ixx`:

```ixx
module;

#include <chrono>

export module Timer;

export class Timer {
	std::chrono::steady_clock::time_point start_time;

  public:
	Timer() {
		start_time = std::chrono::steady_clock::now();
	}

	double elapsed_ms() {
		return (std::chrono::steady_clock::now() - start_time).count() / 1'000'000;
	}

	void reset() {
		start_time = std::chrono::steady_clock::now();
	}
};
```

`src/Utilities/Utilities.ixx`:

```ixx
module;

#include <vector>
#include <string>
#include <filesystem>
#include <fstream>

#define GLM_FORCE_CXX17
#define GLM_FORCE_RADIANS
#define GLM_FORCE_SILENT_WARNINGS
#include <glm/glm.hpp>

export module Utilities;

namespace fs = std::filesystem;

// String functions
export std::string string_replaced(const std::string& source, const std::string& from, const std::string& to) {
	std::string new_string;
	new_string.reserve(source.length()); // avoids a few memory allocations

	size_t lastPos = 0;
	size_t findPos;

	while (std::string::npos != (findPos = source.find(from, lastPos))) {
		new_string.append(source, lastPos, findPos - lastPos);
		new_string += to;
		lastPos = findPos + from.length();
	}

	// Care for the rest after last occurrence
	new_string += source.substr(lastPos);

	return new_string;
}

export std::string to_lowercase_copy(const std::string_view& string) {
	std::string output(string);
	std::transform(output.begin(), output.end(), output.begin(), [](unsigned char c) { return std::tolower(c); });
	return output;
}

export void to_lowercase(std::string& string) {
	std::transform(string.begin(), string.end(), string.begin(), [](unsigned char c) { return std::tolower(c); });
}

// trim from start (in place)
export void ltrim(std::string& s) {
	s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
				return !std::isspace(ch);
			}));
}

// trim from end (in place)
export void rtrim(std::string& s) {
	s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
				return !std::isspace(ch);
			}).base(),
			s.end());
}

// trim from both ends (in place)
export void trim(std::string& s) {
	ltrim(s);
	rtrim(s);
}

export bool is_number(const std::string& s) {
	return !s.empty() && std::find_if(s.begin(), s.end(), [](char c) { return !std::isdigit(c); }) == s.end();
}

export std::string read_text_file(const fs::path& path) {
	std::ifstream textfile(path.c_str());
	std::string line;
	std::string text;

	if (!textfile.is_open())
		return "";

	while (getline(textfile, line)) {
		text += line + "\n";
	}

	return text;
}

export struct ItemSet {
	std::vector<std::pair<std::string, int>> items;
};
```

`src/main.cpp`:

```cpp
#include <QApplication>
#include <QCoreApplication>
#include <QFile>
#include <QFont>
#include <QPalette>
#include <QSurfaceFormat>
#include <QSettings>
#include <QStyleFactory>

#include "DockManager.h"
#include "MainWindow/HiveWE.h"
#include "test.h"

import MDX;

#ifdef WIN32
// To force HiveWE to run on the discrete GPU if available
extern "C" {
	__declspec(dllexport) int AmdPowerXpressRequestHighPerformance = 1;
	__declspec(dllexport) unsigned long NvOptimusEnablement = 1;
}
#endif

int main(int argc, char *argv[]) {
//	std::string b = R"(
//Version {
//	FormatVersion 1000,
//}
//Model "Wi sp" {
//	BlendTime 150,
//	MinimumExtent { -134.261, -213.936, -143.006 },
//	MaximumExtent { 154.078, 213.709, 284.64 },
//}
//)";

	//mdx::MDX::from_mdl(b);


	QSurfaceFormat format;
	format.setDepthBufferSize(24);
	format.setStencilBufferSize(8);
	format.setVersion(4, 5);
	format.setProfile(QSurfaceFormat::CoreProfile);
	format.setSwapInterval(0);
	//format.setColorSpace(QSurfaceFormat::sRGBColorSpace);
	QSurfaceFormat::setDefaultFormat(format);

	QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
	QCoreApplication::setOrganizationName("HiveWE");
	QCoreApplication::setApplicationName("HiveWE");

	QLocale::setDefault(QLocale("en_US"));
	
	// Create a dark palette
	// For some magically unknown reason Qt draws Qt::white text as black, so we use QColor(255, 254, 255) instead
	QPalette darkPalette;
	darkPalette.setColor(QPalette::Window, QColor(53, 53, 53));
	darkPalette.setColor(QPalette::WindowText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Disabled, QPalette::WindowText, QColor(127, 127, 127));
	darkPalette.setColor(QPalette::Base, QColor(42, 42, 42));
	darkPalette.setColor(QPalette::AlternateBase, QColor(66, 66, 66));
	darkPalette.setColor(QPalette::ToolTipBase, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::ToolTipText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Text, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::PlaceholderText, Qt::gray);
	darkPalette.setColor(QPalette::Disabled, QPalette::Text, QColor(127, 127, 127));
	darkPalette.setColor(QPalette::Dark, QColor(35, 35, 35));
	darkPalette.setColor(QPalette::Shadow, QColor(20, 20, 20));
	darkPalette.setColor(QPalette::Button, QColor(53, 53, 53));
	darkPalette.setColor(QPalette::ButtonText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Disabled, QPalette::ButtonText, QColor(127, 127, 127));
	darkPalette.setColor(QPalette::BrightText, Qt::red);
	darkPalette.setColor(QPalette::Link, QColor(42, 130, 218));
	darkPalette.setColor(QPalette::Highlight, QColor(42, 130, 218));
	darkPalette.setColor(QPalette::Disabled, QPalette::Highlight, QColor(80, 80, 80));
	darkPalette.setColor(QPalette::HighlightedText, QColor(255, 254, 255));
	darkPalette.setColor(QPalette::Disabled, QPalette::HighlightedText, QColor(127, 127, 127));

	QApplication::setPalette(darkPalette);
	QApplication::setStyle("Fusion");
	
	QApplication a(argc, argv);

	ads::CDockManager::setConfigFlag(ads::CDockManager::FocusHighlighting);
	ads::CDockManager::setConfigFlag(ads::CDockManager::AllTabsHaveCloseButton);
	ads::CDockManager::setConfigFlag(ads::CDockManager::DockAreaDynamicTabsMenuButtonVisibility);
	ads::CDockManager::setConfigFlag(ads::CDockManager::OpaqueSplitterResize);
	ads::CDockManager::setConfigFlag(ads::CDockManager::MiddleMouseButtonClosesTab);

	QSettings settings;
	QFile file("Data/Themes/" + settings.value("theme", "Dark").toString() + ".qss");
	file.open(QFile::ReadOnly);
	a.setStyleSheet(QLatin1String(file.readAll()));

	HiveWE w;
	return QApplication::exec();
}
```

`src/resource.h`:

```h

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`src/test.cpp`:

```cpp
#include "test.h"

#include <string>
#include <vector>
#include <fstream>
#include <execution>
#include <filesystem>
namespace fs = std::filesystem;

#include "fmt/format.h"

import BinaryReader;
import MDX;

void execute_tests() {
	fmt::print("[INFO] Parsing all MDX files\n");
	auto begin = std::chrono::steady_clock::now();
	parse_all_mdx();
	auto delta = (std::chrono::steady_clock::now() - begin).count() / 1'000'000.f;
	fmt::print("[INFO] Done parsing in {}ms\n", delta);
}

void parse_all_mdx() {
	std::vector<fs::path> paths;

	for (const auto i : fs::recursive_directory_iterator("C:/Users/User/Desktop/1.00/")) {
		if (i.is_regular_file() && (i.path().extension() == ".mdx" || i.path().extension() == ".MDX")) {
			paths.push_back(i.path());
		}
	}

	std::for_each(std::execution::par_unseq, paths.begin(), paths.end(), [&](const fs::path& path) {
		std::ifstream stream(path, std::ios::binary);
		auto buffer = std::vector<uint8_t, default_init_allocator<uint8_t>>(std::istreambuf_iterator<char>(stream), std::istreambuf_iterator<char>());

		BinaryReader reader(buffer);
		auto mdx = mdx::MDX(reader);
	});
}
```

`src/test.h`:

```h
#pragma once

void execute_tests();

void parse_all_mdx();
```

`tabs.editorconfig`:

```editorconfig
root = true

[*]
end_of_line = lf
insert_final_newline = false
indent_style = tab
indent_size = 4
```

`vcpkg.json`:

```json
{
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "name": "hivewe",
  "version": "0.7.0",
  "dependencies": [
    "qtbase",
    "glm",
    {
      "name": "glad",
      "features": [ "loader", "extensions", "gl-api-46" ]
    },
    "imgui",
    "soil2",
    "stormlib",
    "casclib",
    "libjpeg-turbo",
    "bullet3",
    "qt-advanced-docking-system",
    {
      "name": "abseil",
      "features": [ "cxx17" ]
    },
    "fmt",
    "tbb",
    "outcome"
  ]
}



```