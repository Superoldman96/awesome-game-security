Project Path: arc_gmh5225_NoMoreBugCheckReloaded_a004u_85

Source Tree:

```txt
arc_gmh5225_NoMoreBugCheckReloaded_a004u_85
├── BootKit
│   ├── BootKit.vcxproj
│   ├── drv.h
│   ├── drvmain.c
│   ├── hook.c
│   ├── hook.h
│   ├── nt.h
│   ├── util.c
│   └── util.h
├── BootKit.default.props
├── BootKit.props
├── BootKit.sln
└── README.md

```

`BootKit.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>$(SolutionDir)..\VisualUefi\edk2</EDK_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\Include</IncludePath>
    <LibraryPath>$(SolutionDir)..\VisualUefi\EDK-II\$(Platform)\$(Configuration)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`BootKit.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <TargetExt>.efi</TargetExt>
  </PropertyGroup>
  <PropertyGroup>
    <LocalDebuggerCommand>..\debugger\qemu.exe</LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>-name "VisualUEFI Debugger" -drive file=OVMF_CODE-need-smm.fd,if=pflash,format=raw,unit=0,readonly=on -drive file=OVMF_VARS-need-smm.fd,if=pflash,format=raw,unit=1 -drive file=fat:rw:..\samples\$(Platform)\$(Configuration)\,media=disk,if=virtio,format=raw -drive file=UefiShell.iso,format=raw -m 512 -machine q35,smm=on -nodefaults -vga std -global driver=cfi.pflash01,property=secure,value=on -global ICH9-LPC.disable_s3=1</LocalDebuggerCommandArguments>
    <LocalDebuggerWorkingDirectory>..\..\debugger</LocalDebuggerWorkingDirectory>
    <LocalDebuggerDebuggerType>Script</LocalDebuggerDebuggerType>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>$(SolutionDir)..\VisualUefi\EDK-II\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib</AdditionalDependencies>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.xdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
</Project>

```

`BootKit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BootKit", "BootKit\BootKit.vcxproj", "{B8CE018B-0E28-4EFB-BF39-288C275E56D3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B8CE018B-0E28-4EFB-BF39-288C275E56D3}.Release|x64.ActiveCfg = Release|x64
		{B8CE018B-0E28-4EFB-BF39-288C275E56D3}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ECB1D2EC-1021-4B09-A8EA-85A942CB4A7A}
	EndGlobalSection
EndGlobal

```

`BootKit/BootKit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{B8CE018B-0E28-4EFB-BF39-288C275E56D3}</ProjectGuid>
    <ProjectName>NoMoreBugCheckReloaded</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(SolutionDir)\BootKit.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <Import Project="$(SolutionDir)\BootKit.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>UefiDriverEntryPoint.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>EFI Runtime</SubSystem>
    </Link>
    <ClCompile>
      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">CompileAsC</CompileAs>
      <IntrinsicFunctions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</IntrinsicFunctions>
      <InlineFunctionExpansion Condition="'$(Configuration)|$(Platform)'=='Release|x64'">OnlyExplicitInline</InlineFunctionExpansion>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <StructMemberAlignment Condition="'$(Configuration)|$(Platform)'=='Release|x64'">8Bytes</StructMemberAlignment>
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdcpp20</LanguageStandard>
      <TreatWarningAsError Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="hook.c" />
    <ClCompile Include="drvmain.c" />
    <ClInclude Include="hook.h" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nt.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
</Project>
```

`BootKit/drv.h`:

```h
extern CONST UINT32 _gUefiDriverRevision = 0;
CHAR8* gEfiCallerBaseName = "ShellSample";

CONST UINT8  _gDriverUnloadImageCount = 1;

EFI_STATUS EFIAPI UefiUnload(IN EFI_HANDLE ImageHandle)
{
    return EFI_SUCCESS;
}
```

`BootKit/drvmain.c`:

```c
#include "nt.h"
#include "hook.h"
#include "drv.h"

extern EFI_RUNTIME_SERVICES* gRT;
extern EFI_BOOT_SERVICES* gBS;
EFI_EXIT_BOOT_SERVICES    gOriginalEBS;

VOID* gKernelBase = NULL;
VOID* WinloadReturnAddress = NULL;

VOID(*KeBugCheckEx)(UINT32 BugCheckCode,
    UINT64 Code1,
    UINT64 Code2,
    UINT64 Code3,
    UINT64 Code4
);

VOID EFIAPI NotifySetVirtualAddressMap(EFI_EVENT Event, VOID* Context)
{
    /*
        winload!OslpLogOsLaunch+0x21:
        00000000`0090f949 488b83f0000000  mov     rax,qword ptr [rbx+0F0h]
        00000000`0090f950 4c8b88c0090000  mov     r9,qword ptr [rax+9C0h]
        00000000`0090f957 48b877be9f1a2fdd2406 mov rax,624DD2F1A9FBE77h
        00000000`0090f961 49f7e1          mul     rax,r9
        00000000`0090f964 488b050d241e00  mov     rax,qword ptr [winload!OslLoaderBlock (00000000`00af1d78)]
    */
    UINT8 LogSig[] = { 0x48, 0xB8, 0x77, 0xBE, 0x9F, 0x1A, 0x2F, 0xDD }; // Signature around OslpLogOsLaunch+0x21 which has the move containing the LoaderBlock
    UINT8 LogMsk[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // All bytes are significant.
    UINT64 LogOsLaunchScanBase = (UINT64)FindPattern(WinloadReturnAddress, 0x10000, LogSig, sizeof(LogSig), LogMsk);

    PLOADER_PARAMETER_BLOCK LoaderBlock = *(PLOADER_PARAMETER_BLOCK*)(*(UINT32*)(LogOsLaunchScanBase + 0x10) + LogOsLaunchScanBase + 0x14);
    if (LoaderBlock == NULL)
    {
        Print(L"[-] LPB was null, crashing on purpose.");
        return;
    }

    KLDR_DATA_TABLE_ENTRY* KernelEntry = GetKernelModuleFromList(&LoaderBlock->LoadOrderListHead, L"ntoskrnl.exe");
    gKernelBase = KernelEntry->ModuleBase;

    // Disable write protection
    UINT64 cr0 = AsmReadCr0();
    AsmWriteCr0(cr0 & ~0x10000ull);
#pragma warning (push)
#pragma warning (disable : 4152)
    KeBugCheckEx = FindExport(gKernelBase, "KeBugCheckEx");
#pragma warning (pop)
    SetupKeBugCheckExHook(KeBugCheckEx, KeBugCheckExHook);

    AsmWriteCr0(cr0);
    return;
}


EFI_STATUS EFIAPI ExitBootServicesHook(IN EFI_HANDLE ImageHandle, IN UINTN MapKey)
{
    Print(L"[*] EBS hook triggered, gathering Winload return address\n");

    gBS->ExitBootServices = gOriginalEBS;
    Print(L"[*] Handing back control to unmodified EBS @ 0x%lx\n", gOriginalEBS);

    WinloadReturnAddress = _ReturnAddress();
    Print(L"[+] Found Winload return address: 0x%lx\n", WinloadReturnAddress);

    Print(L"\n[*] We are now waiting for the virtual address space. See ya in the kernel!\n");
    return gOriginalEBS(ImageHandle, MapKey);
}


EFI_STATUS EFIAPI UefiMain(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE* SystemTable)
{
    Print(L"[*] Hello, world!\n");
    Print(L"[*] Our handle is 0x%lx\n", ImageHandle);
    Print(L"[*] System table: 0x%lx\n", SystemTable);

    gOriginalEBS = gBS->ExitBootServices;

    // Disable write protection
    UINT64 cr0 = AsmReadCr0();
    AsmWriteCr0(cr0 & ~0x10000ull);

    gBS->ExitBootServices = ExitBootServicesHook;
    Print(L"[+] ExitBootServices hook installed: 0x%lx\n", gBS->ExitBootServices);

    AsmWriteCr0(cr0);

    EFI_EVENT addressSpaceEvent = { 0 };
    Print(L"[*] Subscribing to EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE\n");
    return gBS->CreateEvent(EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE, TPL_NOTIFY, NotifySetVirtualAddressMap, NULL, &addressSpaceEvent);
}

```

`BootKit/hook.c`:

```c
#include "hook.h"

BYTE KeBugCheckExOriginalBytes[13] = { 0 };

extern EFI_RUNTIME_SERVICES* gRT;

VOID(*DbgPrint)(
    INT8* Format,
    ...
);

NTSTATUS(*KeDelayExecutionThread)(
    KPROCESSOR_MODE WaitMode,
    BOOLEAN         Alertable,
    PLARGE_INTEGER  Interval
);

HANDLE(*PsGetCurrentProcessId)();
HANDLE(*PsGetCurrentThreadId)();

#define IRQL_NOT_GREATER_OR_EQUAL 0x9
#define IRQL_NOT_LESS_OR_EQUAL 0xA
#define KMODE_EXCEPTION_NOT_HANDLED 0x1E
#define SYSTEM_THREAD_EXCEPTION_NOT_HANDLED 0x7E
#define SYSTEM_SERVICE_EXCEPTION 0x3B

VOID KeBugCheckExHook(UINT32 BugCheckCode, UINT64 Code1, UINT64 Code2, UINT64 Code3, UINT64 Code4)
{
    // This sounds so wrong...
    UINT32 BugChecksThatCanBeSafelyIgnored[] = { SYSTEM_THREAD_EXCEPTION_NOT_HANDLED, SYSTEM_SERVICE_EXCEPTION, IRQL_NOT_GREATER_OR_EQUAL, IRQL_NOT_LESS_OR_EQUAL, KMODE_EXCEPTION_NOT_HANDLED };
    UINT8 CanWeIgnoreThis = 0;
    for (INT32 i = 0; i < 5; i++) {
        if (BugCheckCode == BugChecksThatCanBeSafelyIgnored[i]) {
            CanWeIgnoreThis = 1;
            break;
        }
    }

    // Check if it was thrown by the kernel or driver
    if (CanWeIgnoreThis) {
        // This was called by the kernel or a core system process.
        // This is a bad way to check but I am in a hurry.
        if (PsGetCurrentProcessId() <= 480) {
            CanWeIgnoreThis = 0;
        }
    }

    // CHECK THE BUG
    if (!CanWeIgnoreThis) {
        Overwrite((VOID*)KeBugCheckEx, KeBugCheckExOriginalBytes, 13);
        KeBugCheckEx(BugCheckCode, Code1, Code2, Code3, Code4);
    }

    DbgPrint("[*] KeBugCheckEx was called by Process %d, thread id %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId());
    DbgPrint("[*] KeBugCheckEx(0x%llx, 0x%llx, 0x%llx, 0x%llx)\n", BugCheckCode,
        Code1, Code2, Code3, Code4);
    LARGE_INTEGER Delay;

    Delay.u.LowPart = 0;
    Delay.u.HighPart = 0x80000000;

    KeDelayExecutionThread(KernelMode, FALSE, &Delay);
}

VOID SetupKeBugCheckExHook(UINT8* KeBugCheckExPtr, VOID* HookFunc)
{
#pragma warning (push)
#pragma warning (disable : 4152)
    DbgPrint = FindExport(gKernelBase, "DbgPrint");
    KeDelayExecutionThread = FindExport(gKernelBase, "KeDelayExecutionThread");
    PsGetCurrentProcessId = FindExport(gKernelBase, "PsGetCurrentProcessId");
    PsGetCurrentThreadId = FindExport(gKernelBase, "PsGetCurrentThreadId");
#pragma warning (pop)
    Memcpy(&KeBugCheckExOriginalBytes, KeBugCheckExPtr, 13);

    gRT->ConvertPointer(EFI_OPTIONAL_PTR, &HookFunc);

    UINT8 Patch[] =
    {
        0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r10, address
        0x41, 0xFF, 0xE2                                            // jmp r10
    };

    Overwrite(KeBugCheckExPtr, Patch, 13);

    VOID* ThunkAddress = KeBugCheckExPtr;
    gRT->ConvertPointer(EFI_OPTIONAL_PTR, &ThunkAddress);

    Overwrite(KeBugCheckExPtr + 2, &HookFunc, 8);
}

```

`BootKit/hook.h`:

```h
#include "util.h"
#include "nt.h"

extern BYTE KeBugCheckExOriginalBytes[13];
extern VOID(*KeBugCheckEx)(UINT32 BugCheckCode,
    UINT64 Code1,
    UINT64 Code2,
    UINT64 Code3,
    UINT64 Code4
);
extern VOID* gKernelBase;

VOID SetupKeBugCheckExHook(UINT8* KeBugCheckExPtr, VOID* HookFunc);
VOID KeBugCheckExHook(UINT32 BugCheckCode, UINT64 Code1, UINT64 Code2, UINT64 Code3, UINT64 Code4);

```

`BootKit/nt.h`:

```h
#pragma once
#pragma warning( push )
#pragma warning (disable : 4201 4324)

#include <ntstatus.h>

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (char*)(address) - \
                                                  (UINT64)(&((type *)0)->field)))

typedef struct _UNICODE_STRING
{
    UINT16 Length;
    UINT16 MaximumLength;
    CHAR16* Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef short CSHORT;
typedef unsigned short USHORT;
typedef long LONG;
typedef unsigned long ULONG;
typedef VOID* PVOID;
typedef void* HANDLE;
typedef HANDLE* PHANDLE;
typedef CHAR8 CCHAR;
typedef CCHAR KPROCESSOR_MODE;
typedef ULONG DEVICE_TYPE, ACCESS_MASK;
typedef long NTSTATUS;
typedef PVOID PIO_TIMER, PVPB, PSECURITY_DESCRIPTOR, PDRIVER_EXTENSION, PFAST_IO_DISPATCH, PDRIVER_INITIALIZE, PDRIVER_STARTIO, PDRIVER_UNLOAD, PDRIVER_DISPATCH;
typedef unsigned char BYTE;
typedef struct _OBJECT_TYPE OBJECT_TYPE, * POBJECT_TYPE;
typedef CHAR16 WCHAR;
typedef CONST WCHAR* PCWSTR;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG           Length;
    HANDLE          RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG           Attributes;
    PVOID           SecurityDescriptor;
    PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef __int64 LONGLONG;
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    } DUMMYSTRUCTNAME;
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER* PLARGE_INTEGER;

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,                   // 2
    FileBothDirectoryInformation,                   // 3
    FileBasicInformation,                           // 4
    FileStandardInformation,                        // 5
    FileInternalInformation,                        // 6
    FileEaInformation,                              // 7
    FileAccessInformation,                          // 8
    FileNameInformation,                            // 9
    FileRenameInformation,                          // 10
    FileLinkInformation,                            // 11
    FileNamesInformation,                           // 12
    FileDispositionInformation,                     // 13
    FilePositionInformation,                        // 14
    FileFullEaInformation,                          // 15
    FileModeInformation,                            // 16
    FileAlignmentInformation,                       // 17
    FileAllInformation,                             // 18
    FileAllocationInformation,                      // 19
    FileEndOfFileInformation,                       // 20
    FileAlternateNameInformation,                   // 21
    FileStreamInformation,                          // 22
    FilePipeInformation,                            // 23
    FilePipeLocalInformation,                       // 24
    FilePipeRemoteInformation,                      // 25
    FileMailslotQueryInformation,                   // 26
    FileMailslotSetInformation,                     // 27
    FileCompressionInformation,                     // 28
    FileObjectIdInformation,                        // 29
    FileCompletionInformation,                      // 30
    FileMoveClusterInformation,                     // 31
    FileQuotaInformation,                           // 32
    FileReparsePointInformation,                    // 33
    FileNetworkOpenInformation,                     // 34
    FileAttributeTagInformation,                    // 35
    FileTrackingInformation,                        // 36
    FileIdBothDirectoryInformation,                 // 37
    FileIdFullDirectoryInformation,                 // 38
    FileValidDataLengthInformation,                 // 39
    FileShortNameInformation,                       // 40
    FileIoCompletionNotificationInformation,        // 41
    FileIoStatusBlockRangeInformation,              // 42
    FileIoPriorityHintInformation,                  // 43
    FileSfioReserveInformation,                     // 44
    FileSfioVolumeInformation,                      // 45
    FileHardLinkInformation,                        // 46
    FileProcessIdsUsingFileInformation,             // 47
    FileNormalizedNameInformation,                  // 48
    FileNetworkPhysicalNameInformation,             // 49
    FileIdGlobalTxDirectoryInformation,             // 50
    FileIsRemoteDeviceInformation,                  // 51
    FileUnusedInformation,                          // 52
    FileNumaNodeInformation,                        // 53
    FileStandardLinkInformation,                    // 54
    FileRemoteProtocolInformation,                  // 55

    //
    //  These are special versions of these operations (defined earlier)
    //  which can be used by kernel mode drivers only to bypass security
    //  access checks for Rename and HardLink operations.  These operations
    //  are only recognized by the IOManager, a file system should never
    //  receive these.
    //

    FileRenameInformationBypassAccessCheck,         // 56
    FileLinkInformationBypassAccessCheck,           // 57

    //
    // End of special information classes reserved for IOManager.
    //

    FileVolumeNameInformation,                      // 58
    FileIdInformation,                              // 59
    FileIdExtdDirectoryInformation,                 // 60
    FileReplaceCompletionInformation,               // 61
    FileHardLinkFullIdInformation,                  // 62
    FileIdExtdBothDirectoryInformation,             // 63
    FileDispositionInformationEx,                   // 64
    FileRenameInformationEx,                        // 65
    FileRenameInformationExBypassAccessCheck,       // 66
    FileDesiredStorageClassInformation,             // 67
    FileStatInformation,                            // 68
    FileMemoryPartitionInformation,                 // 69
    FileStatLxInformation,                          // 70
    FileCaseSensitiveInformation,                   // 71
    FileLinkInformationEx,                          // 72
    FileLinkInformationExBypassAccessCheck,         // 73
    FileStorageReserveIdInformation,                // 74
    FileCaseSensitiveInformationForceAccessCheck,   // 75
    FileKnownFolderInformation,   // 76

    FileMaximumInformation
} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

typedef struct _FILE_STANDARD_INFORMATION {
    UINT64 AllocationSize;
    UINT64 EndOfFile;
    ULONG         NumberOfLinks;
    BOOLEAN       DeletePending;
    BOOLEAN       Directory;
} FILE_STANDARD_INFORMATION, * PFILE_STANDARD_INFORMATION;
typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32,

} POOL_TYPE;

typedef struct _RELOC_BLOCK_HDR
{
    UINT32 PageRVA;
    UINT32 BlockSize;
} RELOC_BLOCK_HDR, * PRELOC_BLOCK_HDR;

typedef struct _RELOC_ENTRY
{
    UINT16 Offset : 12;
    UINT16 Type : 4;
} RELOC_ENTRY, * PRELOC_ENTRY;

typedef struct _RELOC_NAME_TABLE_ENTRY
{
    UINT16 Hint;
    CHAR8 Name[];
} RELOC_NAME_TABLE_ENTRY, PRELOC_NAME_TABLE_ENTRY;

//
//  The following are masks for the predefined standard access types
//

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define SYNCHRONIZE                      (0x00100000L)

#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)

#define STANDARD_RIGHTS_READ             (READ_CONTROL)
#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)
#define STANDARD_RIGHTS_EXECUTE          (READ_CONTROL)

#define STANDARD_RIGHTS_ALL              (0x001F0000L)

#define SPECIFIC_RIGHTS_ALL              (0x0000FFFFL)

//
// AccessSystemAcl access type
//

#define ACCESS_SYSTEM_SECURITY           (0x01000000L)

//
// MaximumAllowed access type
//

#define MAXIMUM_ALLOWED                  (0x02000000L)

//
//  These are the generic rights.
//

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)

#define OBJ_INHERIT                         0x00000002L
#define OBJ_PERMANENT                       0x00000010L
#define OBJ_EXCLUSIVE                       0x00000020L
#define OBJ_CASE_INSENSITIVE                0x00000040L
#define OBJ_OPENIF                          0x00000080L
#define OBJ_OPENLINK                        0x00000100L
#define OBJ_KERNEL_HANDLE                   0x00000200L
#define OBJ_FORCE_ACCESS_CHECK              0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP   0x00000800L
#define OBJ_DONT_REPARSE                    0x00001000L
#define OBJ_VALID_ATTRIBUTES                0x00001FF2L


//
// Define the create disposition values
//

#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the create/open option flags
//

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#define FILE_DISALLOW_EXCLUSIVE                 0x00020000

#define FILE_SESSION_AWARE                      0x00040000

//
//  CreateOptions flag to pass in call to CreateFile to allow the write through xro.sys
//

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe


typedef  NTSTATUS(*p_ObReferenceObjectByName)(PUNICODE_STRING ObjectName,

    ULONG Attributes,

    PVOID AccessState,

    ACCESS_MASK DesiredAccess,

    POBJECT_TYPE ObjectType,

    KPROCESSOR_MODE AccessMode,

    PVOID ParseContext OPTIONAL,

    PVOID* Object);

#define IRP_MJ_MAXIMUM_FUNCTION 0x1b

extern p_ObReferenceObjectByName ObReferenceObjectByName;

typedef struct _MDL {
    struct _MDL* Next;
    CSHORT Size;
    CSHORT MdlFlags;

    struct _EPROCESS* Process;
    PVOID MappedSystemVa;   /* see creators for field size annotations. */
    PVOID StartVa;   /* see creators for validity; could be address 0.  */
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, * PMDL;

typedef struct __declspec(align(16)) _DEVICE_OBJECT {
    CSHORT                   Type;
    USHORT                   Size;
    LONG                     ReferenceCount;
    struct _DRIVER_OBJECT* DriverObject;
    struct _DEVICE_OBJECT* NextDevice;
    struct _DEVICE_OBJECT* AttachedDevice;
    struct _IRP* CurrentIrp;
    PIO_TIMER                Timer;
    ULONG                    Flags;
    ULONG                    Characteristics;
    volatile PVPB            Vpb;
    PVOID                    DeviceExtension;
    DEVICE_TYPE              DeviceType;
    CCHAR                    StackSize;
    union {
        LIST_ENTRY         ListEntry;
        BYTE               Wcb[0x48];
    } Queue;
    ULONG                    AlignmentRequirement;
    ULONG                    pad0;
    BYTE                     DeviceQueue[0x28];
    BYTE                     Dpc[0x40];
    ULONG                    ActiveThreadCount;
    ULONG                    pad1;
    PSECURITY_DESCRIPTOR     SecurityDescriptor;
    BYTE                     DeviceLock[0x18];
    USHORT                   SectorSize;
    USHORT                   Spare1;
    struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
    PVOID                    Reserved;
} DEVICE_OBJECT, * PDEVICE_OBJECT;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    //
    // The remaining fields are reserved for system use.
    //

    ULONG           PowerFlags;
    struct          _DEVICE_OBJECT_POWER_EXTENSION* Dope;
    ULONG ExtensionFlags;
    PVOID           DeviceNode;
    PDEVICE_OBJECT  AttachedTo;
    volatile LONG StartIoCount;
    LONG           StartIoKey;
    ULONG          StartIoFlags;
    PVPB           Vpb;
    PVOID DependencyNode;
    PVOID InterruptContext;
    volatile LONG InterruptCount;

    volatile PVOID VerifierContext;

} DEVOBJ_EXTENSION, * PDEVOBJ_EXTENSION;

typedef struct _DRIVER_OBJECT {
    CSHORT             Type;
    CSHORT             Size;
    PDEVICE_OBJECT     DeviceObject;
    ULONG              Flags;
    PVOID              DriverStart;
    ULONG              DriverSize;
    PVOID              DriverSection;
    PDRIVER_EXTENSION  DriverExtension;
    UNICODE_STRING     DriverName;
    PUNICODE_STRING    HardwareDatabase;
    PFAST_IO_DISPATCH  FastIoDispatch;
    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO    DriverStartIo;
    PDRIVER_UNLOAD     DriverUnload;
    PDRIVER_DISPATCH   MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];
} DRIVER_OBJECT, * PDRIVER_OBJECT;

typedef struct _LOADER_PARAMETER_BLOCK
{
    UINT32 OsMajorVersion;
    UINT32 OsMinorVersion;
    UINT32 Size;
    UINT32 OsLoaderSecurityVersion;
    struct _LIST_ENTRY LoadOrderListHead;
    struct _LIST_ENTRY MemoryDescriptorListHead;
    struct _LIST_ENTRY BootDriverListHead;
    struct _LIST_ENTRY EarlyLaunchListHead;
    struct _LIST_ENTRY CoreDriverListHead;
    struct _LIST_ENTRY CoreExtensionsDriverListHead;
    struct _LIST_ENTRY TpmCoreDriverListHead;
} LOADER_PARAMETER_BLOCK, * PLOADER_PARAMETER_BLOCK;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;
    VOID* ExceptionTable;
    UINT32 ExceptionTableSize;
    VOID* GpValue;
    struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;
    VOID* ModuleBase;
    VOID* EntryPoint;
    UINT32 SizeOfImage;
    struct _UNICODE_STRING FullModuleName;
    struct _UNICODE_STRING BaseModuleName;
    UINT32 Flags;
    UINT16 LoadCount;
    union
    {
        UINT16 SignatureLevel : 4;
        UINT16 SignatureType : 3;
        UINT16 Unused : 9;
        UINT16 EntireField;
    } u1;
    VOID* SectionPointer;
    UINT32 CheckSum;
    UINT32 CoverageSectionSize;
    VOID* CoverageSection;
    VOID* LoadedImports;
    VOID* Spare;
    UINT32 SizeOfImageNotRounded;
    UINT32 TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

typedef struct _IMAGE_FILE_HEADER
{
    UINT16 Machine;
    UINT16 NumberOfSections;
    UINT32 TimeDateStamp;
    UINT32 PointerToSymbolTable;
    UINT32 NumberOfSymbols;
    UINT16 SizeOfOptionalHeader;
    UINT16 Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
    UINT32 VirtualAddress;
    UINT32 Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16

typedef struct _IMAGE_OPTIONAL_HEADER64
{
    UINT16 Magic;
    UINT8 MajorLinkerVersion;
    UINT8 MinorLinkerVersion;
    UINT32 SizeOfCode;
    UINT32 SizeOfInitializedData;
    UINT32 SizeOfUninitializedData;
    UINT32 AddressOfEntryPoint;
    UINT32 BaseOfCode;
    UINT64 ImageBase;
    UINT32 SectionAlignment;
    UINT32 FileAlignment;
    UINT16 MajorOperatingSystemVersion;
    UINT16 MinorOperatingSystemVersion;
    UINT16 MajorImageVersion;
    UINT16 MinorImageVersion;
    UINT16 MajorSubsystemVersion;
    UINT16 MinorSubsystemVersion;
    UINT32 Win32VersionValue;
    UINT32 SizeOfImage;
    UINT32 SizeOfHeaders;
    UINT32 CheckSum;
    UINT16 Subsystem;
    UINT16 DllCharacteristics;
    UINT64 SizeOfStackReserve;
    UINT64 SizeOfStackCommit;
    UINT64 SizeOfHeapReserve;
    UINT64 SizeOfHeapCommit;
    UINT32 LoaderFlags;
    UINT32 NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64
{
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64, IMAGE_NT_HEADERS, * PIMAGE_NT_HEADERS;

typedef struct _IMAGE_DOS_HEADER
{
    UINT16 e_magic;                     // Magic number
    UINT16 e_cblp;                      // Bytes on last page of file
    UINT16 e_cp;                        // Pages in file
    UINT16 e_crlc;                      // Relocations
    UINT16 e_cparhdr;                   // Size of header in paragraphs
    UINT16 e_minalloc;                  // Minimum extra paragraphs needed
    UINT16 e_maxalloc;                  // Maximum extra paragraphs needed
    UINT16 e_ss;                        // Initial (relative) SS value
    UINT16 e_sp;                        // Initial SP value
    UINT16 e_csum;                      // Checksum
    UINT16 e_ip;                        // Initial IP value
    UINT16 e_cs;                        // Initial (relative) CS value
    UINT16 e_lfarlc;                    // File address of relocation table
    UINT16 e_ovno;                      // Overlay number
    UINT16 e_res[4];                    // Reserved words
    UINT16 e_oemid;                     // OEM identifier (for e_oeminfo)
    UINT16 e_oeminfo;                   // OEM information; e_oemid specific
    UINT16 e_res2[10];                  // Reserved words
    INT32 e_lfanew;                     // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

#define IMAGE_SIZEOF_SHORT_NAME 8

typedef struct _IMAGE_SECTION_HEADER
{
    UINT8 Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        UINT32 PhysicalAddress;
        UINT32 VirtualSize;
    } Misc;
    UINT32 VirtualAddress;
    UINT32 SizeOfRawData;
    UINT32 PointerToRawData;
    UINT32 PointerToRelocations;
    UINT32 PointerToLinenumbers;
    UINT16 NumberOfRelocations;
    UINT16 NumberOfLinenumbers;
    UINT32 Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_EXPORT_DIRECTORY
{
    UINT32 Characteristics;
    UINT32 TimeDateStamp;
    UINT16 MajorVersion;
    UINT16 MinorVersion;
    UINT32 Name;
    UINT32 Base;
    UINT32 NumberOfFunctions;
    UINT32 NumberOfNames;
    UINT32 AddressOfFunctions;
    UINT32 AddressOfNames;
    UINT32 AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    UINT32   LookupTableRVA;             // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    UINT32   TimeDateStamp;                  // 0 if not bound,
    // -1 if bound, and real date\time stamp
    //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
    // O.W. date/time stamp of DLL bound to (Old BIND)

    UINT32   ForwarderChain;                 // -1 if no forwarders
    UINT32   Name;
    UINT32   ImportAddressTable;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef IMAGE_IMPORT_DESCRIPTOR* PIMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_IMPORT_BY_NAME {
    UINT16    Hint;
    CHAR8   Name[];
} IMAGE_IMPORT_BY_NAME, * PIMAGE_IMPORT_BY_NAME;

typedef struct _IO_STATUS_BLOCK {
    union {
        UINT32 Status;
        VOID* Pointer;
    };

    UINT64 Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    UINT32 SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, * PKDEVICE_QUEUE_ENTRY, * PRKDEVICE_QUEUE_ENTRY;

typedef struct _KAPC {
    UINT8 Type;
    UINT8 AllFlags;
    UINT8 Size;
    UINT8 SpareByte1;
    UINT32 SpareLong0;
    struct _KTHREAD* Thread;
    LIST_ENTRY ApcListEntry;
    VOID* Reserved[3];
    VOID* NormalContext;
    VOID* SystemArgument1;
    VOID* SystemArgument2;
    CHAR8 ApcStateIndex;
    CHAR8 ApcMode;
    BOOLEAN Inserted;
} KAPC, * PKAPC, * PRKAPC;


// TODO: Clean this up
typedef struct _IO_STACK_LOCATION {
    UINT8 MajorFunction;
    UINT8 MinorFunction;
    UINT8 Flags;
    UINT8 Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    // Stupid me deleted all the declspec aligns and they need to be added back
    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            VOID* SecurityContext;
            UINT32 Options;
            UINT16  FileAttributes;
            UINT16 ShareAccess;
            UINT32  EaLength;
        } Create;

        //
        // System service parameters for:  NtCreateNamedPipeFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            VOID* SecurityContext;
            UINT32 Options;
            UINT16  Reserved;
            UINT16 ShareAccess;
            VOID* Parameters;
        } CreatePipe;

        //
        // System service parameters for:  NtCreateMailslotFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            VOID* SecurityContext;
            UINT32 Options;
            UINT16  Reserved;
            UINT16 ShareAccess;
            VOID* Parameters;
        } CreateMailslot;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            UINT32 Length;
            UINT32  Key;
#if defined(_WIN64)
            UINT32 Flags;
#endif
            UINT64 ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            UINT32 Length;
            UINT32  Key;
#if defined(_WIN64)
            UINT32 Flags;
#endif
            UINT64 ByteOffset;
        } Write;

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            UINT32 Length;
            PUNICODE_STRING FileName;
            UINT32 FileInformationClass;
            UINT32  FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile / NtNotifyChangeDirectoryFileEx
        //

        struct {
            UINT32 Length;
            UINT32  CompletionFilter;
        } NotifyDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile / NtNotifyChangeDirectoryFileEx
        //
        // For minor code IRP_MN_NOTIFY_CHANGE_DIRECTORY_EX
        // N.B. Keep Length and CompletionFilter aligned with NotifyDirectory.
        //

        struct {
            UINT32 Length;
            UINT32  CompletionFilter;
            UINT32  DirectoryNotifyInformationClass;
        } NotifyDirectoryEx;

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FileInformationClass;
            VOID* FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                UINT32 ClusterCount;
                VOID* DeleteHandle;
            };
        } SetFile;



        //
        // System service parameters for:  NtQueryEaFile
        //

        struct {
            UINT32 Length;
            VOID* EaList;
            UINT32 EaListLength;
            UINT32  EaIndex;
        } QueryEa;

        //
        // System service parameters for:  NtSetEaFile
        //

        struct {
            UINT32 Length;
        } SetEa;



        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FsInformationClass;
        } QueryVolume;



        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            UINT32 Length;
            UINT32  FsInformationClass;
        } SetVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            UINT32 OutputBufferLength;
            UINT32  InputBufferLength;
            UINT32  FsControlCode;
            VOID* Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            UINT64* Length;
            UINT32  Key;
            UINT64 ByteOffset;
        } LockControl;

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //



        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //



        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            UINT32 OutputBufferLength;
            UINT32 __declspec(align(8)) InputBufferLength;
            UINT32 __declspec(align(8)) IoControlCode;
            VOID* Type3InputBuffer;
        } DeviceIoControl;

        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            UINT32 SecurityInformation;
            UINT32  Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            UINT32 SecurityInformation;
            VOID* SecurityDescriptor;
        } SetSecurity;

        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            VOID* Vpb;
            VOID* DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            VOID* Vpb;
            VOID* DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device control.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK* Srb;
        } Scsi;



        //
        // System service parameters for:  NtQueryQuotaInformationFile
        //

        struct {
            UINT32 Length;
            VOID* StartSid;
            VOID* SidList;
            UINT32 SidListLength;
        } QueryQuota;

        //
        // System service parameters for:  NtSetQuotaInformationFile
        //

        struct {
            UINT32 Length;
        } SetQuota;



        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            UINT32 Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID* InterfaceType;
            UINT16 Size;
            UINT16 Version;
            VOID* Interface;
            VOID* InterfaceSpecificData;
        } QueryInterface;

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            VOID* Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            VOID* IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            UINT32 WhichSpace;
            VOID* Buffer;
            UINT32 Offset;
            UINT32  Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            UINT32 IdType;
        } QueryId;

        //
        // Parameters for StartDevice
        //

        struct {
            VOID* AllocatedResources;
            VOID* AllocatedResourcesTranslated;
        } StartDevice;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            UINT32 ProviderId;
            VOID* DataPath;
            UINT32 BufferSize;
            VOID* Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            VOID* Argument1;
            VOID* Argument2;
            VOID* Argument3;
            VOID* Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    VOID* DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    // request.
    //

    VOID* FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    VOID* CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    VOID* Context;

} IO_STACK_LOCATION, * PIO_STACK_LOCATION;

typedef struct _IRP {
    INT16 Type;
    UINT16 Size;


    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    VOID* MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    UINT32 Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP* MasterIrp;
        INT32 IrpCount;
        VOID* SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queuing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requester mode - mode of the original requester of this operation.
    //

    CHAR8 RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR8 StackCount;
    CHAR8 CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    UINT8 CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CHAR8 ApcEnvironment;

    //
    // Allocation control flags.
    //

    UINT8 AllocationFlags;

    //
    // User parameters.
    //

    union {
        PIO_STATUS_BLOCK UserIosb;

        //
        // Context used when the Irp is managed by IoRing and is used by IoRing.
        // UserIosb is used to cancel an Irp, so sharing space with UserIosb
        // let IoRing cancel an Irp based on its context.
        //

        VOID* IoRingContext;
    };

    VOID* UserEvent;
    union {
        struct {
            union {
                VOID* UserApcRoutine;
                VOID* IssuingProcess;
            };
            union {
                VOID* UserApcContext;

                //
                // IoRing object that rolled this Irp, if any.  The completion
                // is processed through this IoRing object.  UserApcRoutine and
                // UserApcContext is not supported when issuing IOs through an
                // IoRing so we union this with UserApcContext.  We did not use
                // UserApcRoutine because IssuingProcess use the same location
                // and is used when an Irp is queued to FileObject and when the
                // Irp is managed by IoRing it is queued to the FileObject.
                //

                struct _IORING_OBJECT* IoRing;
            };
        } AsynchronousParameters;
        UINT64 AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    VOID* CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    VOID* UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    VOID* DriverContext[4];

                };

            };

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            VOID* Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            CHAR8* AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION* CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    UINT32 PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            VOID* OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file VOID*.
        //

        VOID* CompletionKey;

    } Tail;

} IRP;

typedef IRP* PIRP;

typedef struct _IF_LH_PHYSICAL_ADDRESS
{
    UINT16 Length;
    BYTE Address[32];
} IF_LH_PHYSICAL_ADDRESS;

#pragma warning( pop )

```

`BootKit/util.c`:

```c
#include <intrin.h>
#include "util.h"
#include "nt.h"

UINT64 AsciiToInt(CHAR8* ascii)
{
    UINT64 retInt = 0;
    while (*ascii)
    {
        if (*ascii <= '0' || *ascii >= '9')
            return 0;
        retInt *= 10;
        retInt += *ascii - '0';
        ascii++;
    }
    return retInt;
}

CHAR16 WideCharToLower(CHAR16 c)
{
    if (c >= 'A' && c <= 'Z') return c += ('a' - 'A');
    else return c;
}

INTN WCSNICMP(const CHAR16* First, const CHAR16* Second, UINTN Length)
{
    for (int i = 0; i < Length && First[i] && Second[i]; ++i)
        if (WideCharToLower(First[i]) != WideCharToLower(Second[i]))
            return First[i] - Second[i];

    return 0;
}


UINT32* FindExportEntry(VOID* Module, const CHAR8* RoutineName)
{
    PIMAGE_DOS_HEADER dos = Module;
    if (dos->e_magic != 0x5A4D)
        return NULL;

    PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS)((UINT8*)Module + dos->e_lfanew);
    UINT32 exportsRVA = nt->OptionalHeader.DataDirectory[0].VirtualAddress;
    if (!exportsRVA)
        return NULL;

    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((UINT8*)Module + exportsRVA);
    UINT32* nameTable = (UINT32*)((UINT8*)Module + exportDirectory->AddressOfNames);


    for (int lower = 0, upper = exportDirectory->NumberOfNames - 1; upper >= lower;)
    {
        int i = (upper + lower) / 2;
        const CHAR8* funcName = (CHAR8*)((UINT8*)Module + nameTable[i]);
        INTN diff = AsciiStrCmp(RoutineName, funcName);
        if (diff > 0)
            lower = i + 1;
        else if (diff < 0)
            upper = i - 1;
        else
        {
            UINT32* exportFuncTable = (UINT32*)((UINT8*)Module + exportDirectory->AddressOfFunctions);
            UINT16* ordinalTable = (UINT16*)((UINT8*)Module + exportDirectory->AddressOfNameOrdinals);

            UINT16 index = ordinalTable[i];
            if (exportFuncTable[index] < nt->OptionalHeader.DataDirectory[0].VirtualAddress ||
                exportFuncTable[index] > nt->OptionalHeader.DataDirectory[0].VirtualAddress + nt->OptionalHeader.DataDirectory[0].Size)
                return exportFuncTable + index;
            else
            {
                CHAR16 buffer[260];
                CHAR8* forwarderRVAString = (CHAR8*)Module + exportFuncTable[index];
                UINT16 dllNameLen;
                for (dllNameLen = 0; dllNameLen < 259; ++dllNameLen)
                    if (forwarderRVAString[dllNameLen] == '.') break;
                for (int j = 0; j < dllNameLen; ++j)
                    buffer[j] = (CHAR16)forwarderRVAString[j];
                buffer[dllNameLen] = L'\0';
                if (forwarderRVAString[dllNameLen + 1] == '#')
                    return FindExportEntryByOrdinal(GetLoadedModuleBase(buffer), (UINT16)AsciiToInt(&forwarderRVAString[dllNameLen + 2]));
                else
                    return FindExportEntry(GetLoadedModuleBase(buffer), forwarderRVAString + dllNameLen + 1);
            }
        }
    }
    return NULL;
}

UINT32* FindExportEntryByOrdinal(VOID* Module, UINT16 Ordinal)
{
    PIMAGE_DOS_HEADER dos = Module;
    if (dos->e_magic != 0x5A4D)
        return NULL;

    PIMAGE_NT_HEADERS64 nt = (PIMAGE_NT_HEADERS)((UINT8*)Module + dos->e_lfanew);
    UINT32 exportsRVA = nt->OptionalHeader.DataDirectory[0].VirtualAddress;
    if (!exportsRVA)
        return NULL;

    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY)((UINT8*)Module + exportsRVA);
    UINT16 index = Ordinal - (UINT16)exportDirectory->Base;

    UINT32* exportFuncTable = (UINT32*)((UINT8*)Module + exportDirectory->AddressOfFunctions);
    if (exportFuncTable[index] < nt->OptionalHeader.DataDirectory[0].VirtualAddress ||
        exportFuncTable[index] > nt->OptionalHeader.DataDirectory[0].VirtualAddress + nt->OptionalHeader.DataDirectory[0].Size)
        return exportFuncTable + index;
    else
    {
        CHAR16 buffer[260];
        CHAR8* forwarderRVAString = (CHAR8*)Module + exportFuncTable[index];
        UINT16 dllNameLen;
        for (dllNameLen = 0; dllNameLen < 259; ++dllNameLen)
            if (forwarderRVAString[dllNameLen] == '.') break;
        for (int i = 0; i < dllNameLen; ++i)
            buffer[i] = (CHAR16)forwarderRVAString[i];
        buffer[dllNameLen] = L'\0';
        if (forwarderRVAString[dllNameLen + 1] == '#')
            return FindExportEntryByOrdinal(GetLoadedModuleBase(buffer), (UINT16)AsciiToInt(&forwarderRVAString[dllNameLen + 2]));
        else
            return FindExportEntry(GetLoadedModuleBase(buffer), forwarderRVAString + dllNameLen + 1);
    }
}

VOID* FindExport(VOID* Module, const CHAR8* RoutineName)
{
    UINT32* entry = FindExportEntry(Module, RoutineName);
    if (!entry)
        return NULL;
    return (VOID*)((UINT8*)Module + *entry);
}

VOID* FindExportByOrdinal(VOID* Module, UINT16 Ordinal)
{
    UINT32* entry = FindExportEntryByOrdinal(Module, Ordinal);
    if (!entry)
        return NULL;
    return (VOID*)((UINT8*)Module + *entry);
}


extern VOID* gKernelBase;
VOID* GetLoadedModuleBase(const CHAR16* ModName)
{
    static LIST_ENTRY* PsLoadedModuleList;
    if (!PsLoadedModuleList)
        PsLoadedModuleList = FindExport(gKernelBase, "PsLoadedModuleList");

    KLDR_DATA_TABLE_ENTRY* module = GetKernelModuleFromList(PsLoadedModuleList, ModName);
    if (!module)
        return NULL;
    return module->ModuleBase;
}

VOID* FindPattern(VOID* StartAddress, UINTN SearchLimit, UINT8* Pattern, UINTN PatternSize, UINT8* Mask) {
    UINT8* CurrentAddress = (UINT8*)StartAddress;
    UINT8* EndAddress = CurrentAddress + SearchLimit;

    for (UINTN i = 0; CurrentAddress + i + PatternSize <= EndAddress; i++)
    {
        BOOLEAN Match = TRUE;
        for (UINTN j = 0; j < PatternSize; j++)
        {
            if (Mask[j] == 0x00 && CurrentAddress[i + j] != Pattern[j])
            {
                Match = FALSE;
                break;
            }
        }

        if (Match) return (VOID*)(CurrentAddress + i);
    }

    return NULL;
}


// Thanks NSG
KLDR_DATA_TABLE_ENTRY* GetKernelModuleFromList(LIST_ENTRY* Head, const CHAR16* ModuleName)
{
    for (LIST_ENTRY* it = Head->ForwardLink; it && it != Head; it = it->ForwardLink)
    {
        KLDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(it, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (!WCSNICMP(entry->BaseModuleName.Buffer, ModuleName, entry->BaseModuleName.Length))
        {
            return entry;
        }
    }
    return NULL;
}

#pragma warning (push)
#pragma warning (disable : 4090)
void Memcpy(const VOID* Destination, const VOID* Source, UINTN Length)
{
    __movsb(Destination, Source, Length);
}
#pragma warning (pop)

void Overwrite(const VOID* Destination, const VOID* Source, UINTN Length)
{
    UINT64 interruptsEnabled = __readeflags() & 0x200;
    if (interruptsEnabled)
        _disable();
    UINT64 cr4 = __readcr4();
    __writecr4(cr4 & ~0x800000ull);
    UINT64 cr0 = __readcr0();
    __writecr0(cr0 & ~0x10000ull);

    Memcpy(Destination, Source, Length);

    __writecr0(cr0);
    __writecr4(cr4);
    if (interruptsEnabled)
        _enable();
}

```

`BootKit/util.h`:

```h
#pragma once
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/BaseMemoryLib.h>
#include "nt.h"

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (char*)(address) - \
                                                  (UINT64)(&((type *)0)->field)))


VOID* GetLoadedModuleBase(const CHAR16* ModName);

UINT32* FindExportEntry(VOID* Module, const CHAR8* RoutineName);
VOID* FindExport(VOID* Module, const CHAR8* RoutineName);

UINT32* FindExportEntryByOrdinal(VOID* Module, UINT16 Ordinal);
VOID* FindExportByOrdinal(VOID* Module, UINT16 Ordinal);


KLDR_DATA_TABLE_ENTRY* GetKernelModuleFromList(LIST_ENTRY* Head, const CHAR16* ModuleName);

VOID* FindPattern(VOID* StartAddress, UINTN SearchLimit, UINT8* Pattern, UINTN PatternSize, UINT8* Mask);

void Memcpy(const VOID* Destination, const VOID* Source, UINTN Length);
void Overwrite(const VOID* Destination, const VOID* Source, UINTN Length);

```

`README.md`:

```md
# NoMoreBugCheckReloaded 
Prevent Windows from BSODing no matter what happens!

This time the kernel is patched on boot by an EFI driver instead of an Windows driver.

# Warning
Please do not use this on your main system. Even though I added code to let severe bsods pass through it is not guranteed that it would stop any hardware from getting damaged.
Like all issues in life one should try to resolve it instead of ignoring.
Please try to resolve the BSOD instead of ignoring it by using this tool.

# Usage
Load the EFI driver before booting Windows. Either via the EFI shell or configuring firmware settings.

# Demo


https://github.com/user-attachments/assets/4e8b9b5f-c3b0-41ac-9f6f-167c101b0bcc



# Note
I have not tested this on any other Windows version other than Windows 10 21H2.

### Original Readme
A simple UEFI bootkit made by [NSG650](https://github.com/NSG650) and me.

Credits:
https://github.com/0mWindyBug/WFPCalloutReserach/blob/15d968e93bc7bc85f23e0b7d1dededf65726d3e8/WFPDrivers/WFPEnumDriver/utils.cpp
For FindExport

```