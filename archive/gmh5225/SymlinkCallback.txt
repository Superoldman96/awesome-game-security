Project Path: arc_gmh5225_SymlinkCallback_h3c0e_fv

Source Tree:

```txt
arc_gmh5225_SymlinkCallback_h3c0e_fv
├── README.md
├── SymlinkCallback
│   ├── Main.cpp
│   ├── SymlinkCallback.vcxproj
│   └── SymlinkCallback.vcxproj.filters
└── SymlinkCallback.sln

```

`README.md`:

```md
# SymlinkCallback

Write-ups: https://windows-internals.com/dkom-now-with-symbolic-links/, https://windows-internals.com/symhooks-part-two/, https://windows-internals.com/symhooks-part-three/, https://windows-internals.com/symhooks-part-four/
           
This driver uses the option to set a dynamic target for a symbolic link and hooks the symlink of the C: volume.

It modifies the symlink object and replaces the LinkTarget string with a callback function which will be called whenever the symlink is accessed.

Then, it creates a device object and redirects the symlink target to the device object, adding a "\Foo" suffix in order to avoid direct volume open attempts (which cannot be reparsed). This allows it to intercept all file open operations on the C: volume through its IRP_MJ_CREATE handler. This handler then reparses the name back to the original C: volume target device object, removing the "\Foo" suffix that was added.

Created by @aionescu (https://github.com/ionescu007/) and @yarden_shafir

```

`SymlinkCallback.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.852
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SymlinkCallback", "SymlinkCallback\SymlinkCallback.vcxproj", "{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|ARM.ActiveCfg = Debug|ARM
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|ARM.Build.0 = Debug|ARM
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|ARM.Deploy.0 = Debug|ARM
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|ARM64.Build.0 = Debug|ARM64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|x64.ActiveCfg = Debug|x64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|x64.Build.0 = Debug|x64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|x64.Deploy.0 = Debug|x64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|x86.ActiveCfg = Debug|Win32
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|x86.Build.0 = Debug|Win32
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Debug|x86.Deploy.0 = Debug|Win32
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|ARM.ActiveCfg = Release|ARM
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|ARM.Build.0 = Release|ARM
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|ARM.Deploy.0 = Release|ARM
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|ARM64.ActiveCfg = Release|ARM64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|ARM64.Build.0 = Release|ARM64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|ARM64.Deploy.0 = Release|ARM64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|x64.ActiveCfg = Release|x64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|x64.Build.0 = Release|x64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|x64.Deploy.0 = Release|x64
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|x86.ActiveCfg = Release|Win32
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|x86.Build.0 = Release|Win32
		{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C08C45C2-5EDC-414A-BD98-B715D5CC7A81}
	EndGlobalSection
EndGlobal

```

`SymlinkCallback/Main.cpp`:

```cpp
#include <ntifs.h>
#include <wdm.h>
#include <ntstrsafe.h>

#pragma warning (disable: 4201)

#define OBJECT_SYMBOLIC_LINK_USE_CALLBACK 0x10

NTSTATUS
typedef (SYMLINK_CALLBACK_FUNCTION) (
    _In_ struct _OBJECT_SYMBOLIC_LINK* Symlink,
    _In_ PVOID SymlinkContext,
    _Out_ PUNICODE_STRING SymlinkPath,
    _Outptr_ PVOID* Object
);
typedef SYMLINK_CALLBACK_FUNCTION *PSYMLINK_CALLBACK_FUNCTION;

typedef struct _OBJECT_SYMBOLIC_LINK
{
    LARGE_INTEGER CreationTime;
    union
    {
        UNICODE_STRING LinkTarget;
        struct
        {
            PSYMLINK_CALLBACK_FUNCTION Callback;
            PVOID CallbackContext;
        };
    };
    ULONG DosDeviceDriveIndex;
    ULONG Flags;
    ACCESS_MASK AccessMask;
} OBJECT_SYMBOLIC_LINK, *POBJECT_SYMBOLIC_LINK;
C_ASSERT(sizeof(OBJECT_SYMBOLIC_LINK) == 0x28);

EXTERN_C_START
__declspec(code_seg(".call$1")) SYMLINK_CALLBACK_FUNCTION SymLinkCallback;
DRIVER_INITIALIZE DriverEntry;
DRIVER_UNLOAD DriverUnload;
DRIVER_DISPATCH SymHookCreate;
EXTERN_C_END

DECLARE_GLOBAL_CONST_UNICODE_STRING(g_TailName, L"\\Foo");
DECLARE_UNICODE_STRING_SIZE(g_DeviceName, 64);
UNICODE_STRING g_LinkPath;
POBJECT_SYMBOLIC_LINK g_SymLinkObject;
PDEVICE_OBJECT g_DeviceObject;

_Use_decl_annotations_
VOID
DriverUnload (
    PDRIVER_OBJECT DriverObject
    )
{
    UNREFERENCED_PARAMETER(DriverObject);

    //
    // Undo the patch, restoring the original target string
    //
    g_SymLinkObject->Flags &= ~OBJECT_SYMBOLIC_LINK_USE_CALLBACK;
    MemoryBarrier();
    g_SymLinkObject->LinkTarget = g_LinkPath;

    //
    // Delete our device object
    //
    IoDeleteDevice(g_DeviceObject);

    //
    // Dereference the symbolic link object
    //
    ObDereferenceObject(g_SymLinkObject);
}

//
// To avoid a race condition when modifying the symlink object
// we are using a trick:
// We make sure our callback function is aligned to 64k so
// while the flags are not yet changed and the callback is still
// treated as a unicode string, the last 2 bytes are 0000 so the
// string length is 0, and the buffer is ignored.
// To achieve that, we create a section that contains a buffer
// sized 0xb000 and make sure our callback function is located after it,
// and so it is aligned to 64k.
//
#pragma section(".call$0", write)
__declspec(allocate(".call$0")) UCHAR _pad_[0xB000] = { 0 };

#pragma code_seg(".text")
NTSTATUS
SymHookCreate (
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp
    )
{
    PIO_STACK_LOCATION ioStack;
    PFILE_OBJECT fileObject;
    USHORT bufferLength;
    NTSTATUS status;
    PWCHAR buffer;
    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Get the FILE_OBJECT from the I/O Stack Location
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = ioStack->FileObject;

    //
    // If this is someone directly trying to access our device object,
    // fail them, so that we do not crash the system (since we should
    // not reparse direct opens).
    //
    if (fileObject->FileName.Length < g_TailName.Length)
    {
        status = STATUS_ACCESS_DENIED;
        goto Exit;
    }

    //
    // Allocate space for the original device name, plus the size of the
    // file name, minus "\Foo", and adding space for the terminating NUL.
    //
    bufferLength = fileObject->FileName.Length -
                   g_TailName.Length +
                   g_LinkPath.Length +
                   sizeof(UNICODE_NULL);
    buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, bufferLength, 'maNF');
    if (buffer == NULL)
    {
        status =  STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    //
    // Append the original device name first
    //
    buffer[0] = UNICODE_NULL;
    NT_VERIFY(NT_SUCCESS(RtlStringCbCatNW(buffer,
                                          bufferLength,
                                          g_LinkPath.Buffer,
                                          g_LinkPath.Length)));

    //
    // Then add the name of the file name, minus "\Foo"
    //
    NT_VERIFY(NT_SUCCESS(RtlStringCbCatNW(buffer,
                                          bufferLength,
                                          fileObject->FileName.Buffer +
                                          (g_TailName.Length / sizeof(g_TailName.Buffer[0])),
                                          fileObject->FileName.Length -
                                          g_TailName.Length)));

    //
    // Ask the I/O manager to free the original file name and use ours instead
    //
    status = IoReplaceFileObjectName(fileObject,
                                     buffer,
                                     bufferLength - sizeof(UNICODE_NULL));
    if (!NT_SUCCESS(status))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "Failed to swap file object name: %lx\n",
                   status);
        ExFreePool(buffer);
        goto Exit;
    }

    //
    // Return a reparse operation so that the I/O manager uses the new file
    // object name for its lookup, and starts over
    //
    Irp->IoStatus.Information = IO_REPARSE;
    status = STATUS_REPARSE;

Exit:
    //
    // Complete the IRP with the relevant status code
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

_Use_decl_annotations_
NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    HANDLE symLinkHandle;
    DECLARE_CONST_UNICODE_STRING(symlinkName, L"\\GLOBAL??\\c:");
    OBJECT_ATTRIBUTES objAttr = RTL_CONSTANT_OBJECT_ATTRIBUTES(&symlinkName,
                                                               OBJ_KERNEL_HANDLE |
                                                               OBJ_CASE_INSENSITIVE);
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // Make sure our alignment trick worked out
    //
    if (((ULONG_PTR)SymLinkCallback & 0xFFFF) != 0)
    {
        status = STATUS_CONFLICTING_ADDRESSES;
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "Callback function not aligned correctly!\n");
        goto Exit;
    }

    //
    // Set an unload routine so we can update during testing
    //
    DriverObject->DriverUnload = DriverUnload;

    //
    // Open a handle to the symbolic link object for C: directory,
    // so we can hook it
    //
    status = ZwOpenSymbolicLinkObject(&symLinkHandle,
                                      SYMBOLIC_LINK_ALL_ACCESS,
                                      &objAttr);
    if (!NT_SUCCESS(status))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "Failed opening symbolic link with error: %lx\n",
                   status);
        goto Exit;
    }

    //
    // Get the symbolic link object and close the handle since we
    // no longer need it
    //
    status = ObReferenceObjectByHandle(symLinkHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&g_SymLinkObject,
                                       NULL);
    ObCloseHandle(symLinkHandle, KernelMode);
    if (!NT_SUCCESS(status))
    {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "Failed referencing symbolic link with error: %lx\n",
                   status);
        goto Exit;
    }

    //
    // Create our device object hook
    //
    RtlAppendUnicodeToString(&g_DeviceName, L"\\Device\\HarddiskVolume0");
    status = IoCreateDevice(DriverObject,
                            0,
                            &g_DeviceName,
                            FILE_DEVICE_UNKNOWN,
                            FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL,
                            FALSE,
                            &g_DeviceObject);
    if (!NT_SUCCESS(status))
    {
        //
        // Fail, and drop the symlink object reference
        //
        ObDereferenceObject(g_SymLinkObject);
        DbgPrintEx(DPFLTR_IHVDRIVER_ID,
                   DPFLTR_ERROR_LEVEL,
                   "Failed create devobj with error: %lx\n",
                   status);
        goto Exit;
    }

    //
    // Attach our create handler
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SymHookCreate;

    //
    // Save the original string that the symlink points to
    // so we can change the object back when we unload
    //
    g_LinkPath = g_SymLinkObject->LinkTarget;

    //
    // Modify the symlink to point to our callback instead of the string
    // and change the flags so the union will be treated as a callback.
    // Set CallbackContext to the original string so we can 
    // return it from the callback and allow the system to run normally.
    //
    g_SymLinkObject->Callback = SymLinkCallback;
    RtlAppendUnicodeStringToString(&g_DeviceName, &g_TailName);
    g_SymLinkObject->CallbackContext = &g_DeviceName;
    MemoryBarrier();
    g_SymLinkObject->Flags |= OBJECT_SYMBOLIC_LINK_USE_CALLBACK;

Exit:
    //
    // Return the result back to the system
    //
    return status;
}

#pragma section(".call$1", execute)
__declspec(code_seg(".call$1"))
NTSTATUS
SymLinkCallback (
    _In_ POBJECT_SYMBOLIC_LINK Symlink,
    _In_ PVOID SymlinkContext,
    _Out_ PUNICODE_STRING SymlinkPath,
    _Outptr_ PVOID* Object
    )
{
    UNREFERENCED_PARAMETER(Symlink);

    //
    // We need to either return the right object for this symlink
    // or the correct target string.
    // It's a lot easier to get the string, so we can set Object to Null. 
    //
    *Object = NULL;
    *SymlinkPath = *(PUNICODE_STRING)(SymlinkContext);
    return STATUS_SUCCESS;
}

```

`SymlinkCallback/SymlinkCallback.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F8E9A538-16D0-4077-83CA-4C5A563D1BD7}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>SymlinkCallback</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <SpecifySectionAttributes>INIT,d;.call,align=0x10000</SpecifySectionAttributes>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <SpecifySectionAttributes>INIT,d</SpecifySectionAttributes>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SymlinkCallback/SymlinkCallback.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```