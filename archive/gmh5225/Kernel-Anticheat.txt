Project Path: arc_gmh5225_Kernel-Anticheat_frx5pyyr

Source Tree:

```txt
arc_gmh5225_Kernel-Anticheat_frx5pyyr
├── Client
│   ├── Client.cpp
│   ├── Client.h
│   ├── Client.ico
│   ├── Client.rc
│   ├── Client.vcxproj
│   ├── Client.vcxproj.filters
│   ├── Client.vcxproj.user
│   ├── Communication
│   │   ├── Driver.h
│   │   └── Server.h
│   ├── Detection
│   │   └── OverlayScan.h
│   ├── Globals.h
│   ├── Resource.h
│   ├── Utils
│   │   ├── Defs.h
│   │   ├── HideImports.h
│   │   ├── Loader.h
│   │   ├── SymParser.cpp
│   │   ├── SymParser.h
│   │   ├── Utils.h
│   │   └── xorstr.h
│   ├── framework.h
│   ├── small.ico
│   └── targetver.h
├── DLL
│   ├── DLL.vcxproj
│   ├── DLL.vcxproj.filters
│   ├── DLL.vcxproj.user
│   ├── Globals.h
│   ├── Hooks
│   │   ├── Hooks.h
│   │   └── MinHook.h
│   ├── MinHook.x64.lib
│   ├── Utils
│   │   ├── Defs.h
│   │   ├── HideImports.h
│   │   ├── Utils.h
│   │   └── xorstr.h
│   └── dllmain.cpp
├── Driver
│   ├── Callbacks
│   │   └── Callbacks.h
│   ├── Communication
│   │   └── IO_Handler.h
│   ├── Detections
│   │   └── Detections.h
│   ├── Driver.cpp
│   ├── Driver.inf
│   ├── Driver.vcxproj
│   ├── Driver.vcxproj.filters
│   ├── Driver.vcxproj.user
│   ├── Globals.h
│   ├── ImportLibs
│   │   ├── x64
│   │   │   └── ci.lib
│   │   └── x86
│   │       └── ci.lib
│   └── Utils
│       ├── Defs.h
│       ├── HideImports.h
│       ├── Utils.h
│       ├── skCrypt.h
│       └── stdint.h
├── FireShark_AntiCheat.sln
├── README.md
└── Server
    ├── Globals.h
    ├── Server
    │   ├── SQL.h
    │   └── Server.h
    ├── Server.cpp
    ├── Server.vcxproj
    ├── Server.vcxproj.filters
    ├── Server.vcxproj.user
    └── Utils
        ├── Defs.h
        └── Processing.h

```

`Client/Client.cpp`:

```cpp

#include "Globals.h"

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    FILE* pFile = nullptr;
    AllocConsole();
    freopen_s(&pFile, "CONOUT$", "w", stdout);

    std::cout << E("Hello from client!\n");

    Loader::LoadDriver(E("C:\\Windows\\System32\\drivers\\WolfyZ_NtDrv.sys"), E("WolfyZ_NtDrv.sys"));

    OverlayWindow = GetConsoleWindow();

    STARTUPINFOW SA = { 0 };
    PROCESS_INFORMATION PI = { 0 };

    if (!CreateProcessW(E(L"ProtectionTest.exe"), NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &SA, &PI))
    {
        printf(E("Failed to start protected process: %d\n"), GetLastError());
        Sleep(4000);
        return false;
    }

    GamePID = GetProcessId(PI.hProcess); 

    std::cout << E("Status: ") << Driver::GetStatus() << std::endl;
  
    Driver::SendNtOffsets();
    CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Server::SendThread, 0, 0, 0);

    while (!GetAsyncKeyState(VK_END))
        Sleep(30);

    Loader::UnloadDriver(E("WolfyZ_NtDrv.sys"));

    Sleep(5000);
    return 1;
}

```

`Client/Client.h`:

```h
#pragma once

#include "resource.h"

```

`Client/Client.rc`:

```rc
//Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#define APSTUDIO_HIDDEN_SYMBOLS
#include "windows.h"
#undef APSTUDIO_HIDDEN_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.

IDI_CLIENT       ICON         "Client.ico"
IDI_SMALL               ICON         "small.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDC_CLIENT MENU
BEGIN
    POPUP "&File"
    BEGIN
        MENUITEM "E&xit",                IDM_EXIT
    END
    POPUP "&Help"
    BEGIN
        MENUITEM "&About ...",           IDM_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDC_CLIENT ACCELERATORS
BEGIN
    "?",            IDM_ABOUT,              ASCII,  ALT
    "/",            IDM_ABOUT,              ASCII,  ALT
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About Client"
FONT 8, "MS Shell Dlg"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "Client, Version 1.0",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (c) 2021",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "OK",IDOK,113,41,50,14,WS_GROUP
END

/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END
END
#endif    // APSTUDIO_INVOKED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//
1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "#include ""windows.h""\r\n"
    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
   IDC_CLIENT   "CLIENT"
   IDS_APP_TITLE       "Client"
END

#endif
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE resource.
//

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`Client/Client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{9ae432c5-7e22-4dd9-ad5c-5b74d1fed2a5}</ProjectGuid>
    <RootNamespace>Client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Client.h" />
    <ClInclude Include="Communication\Driver.h" />
    <ClInclude Include="Communication\Server.h" />
    <ClInclude Include="Detection\OverlayScan.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="Globals.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="Utils\Defs.h" />
    <ClInclude Include="Utils\HideImports.h" />
    <ClInclude Include="Utils\Loader.h" />
    <ClInclude Include="Utils\SymParser.h" />
    <ClInclude Include="Utils\Utils.h" />
    <ClInclude Include="Utils\xorstr.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Client.cpp" />
    <ClCompile Include="Utils\SymParser.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Client.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="Client.ico" />
    <Image Include="small.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Client/Client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\Communication">
      <UniqueIdentifier>{477ac3d2-6454-4fbe-a916-41de4afde163}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Utils">
      <UniqueIdentifier>{d8a42d13-7394-4361-b38c-69075c0323de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Detection">
      <UniqueIdentifier>{832065bc-0b02-4619-b397-e52eb4546272}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="framework.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Client.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Globals.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Communication\Driver.h">
      <Filter>Source Files\Communication</Filter>
    </ClInclude>
    <ClInclude Include="Utils\xorstr.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Defs.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\HideImports.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\SymParser.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Detection\OverlayScan.h">
      <Filter>Source Files\Detection</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Utils.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Communication\Server.h">
      <Filter>Source Files\Communication</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Loader.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Client.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils\SymParser.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Client.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="small.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="Client.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Client/Client.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Client/Communication/Driver.h`:

```h
#pragma once

namespace Driver
{
	HANDLE Drv = NULL;

	__forceinline void SecureIO(uint32_t Code, void* InBuf, uint32_t InBufSize, void* OutBuf, uint32_t OutBufSize)
	{
		IO_STATUS_BLOCK IO;
		NtDeviceIoControlFile(Drv, 0, 0, 0, &IO, Code, InBuf, InBufSize, OutBuf, OutBufSize);
	}

	bool GetStatus()
	{
		OBJECT_ATTRIBUTES Params; IO_STATUS_BLOCK IO;
		UNICODE_STRING Device = { 40, 42, (PWSTR)(L"\\Device\\WolfyZ_NtDrv") };
		InitializeObjectAttributes(&Params, &Device, OBJ_CASE_INSENSITIVE, nullptr, nullptr);
		NtOpenFile(&Drv, 0x100003, &Params, &IO, 0x7, FILE_NON_DIRECTORY_FILE);

		IO_GetStatus Struct = { 0 };
		Struct.Send = getRand() % 100000;
		SecureIO(IO_GETSTATUS, &Struct, sizeof(IO_GetStatus), &Struct, sizeof(IO_GetStatus));

		if ((Struct.Send * 2) != Struct.Recv)
		{
			NtClose(Drv);
			return false;
		}

		return true;
	}

	void SendNtOffsets()
	{
		IO_SendOffsets Struct = { 0 };

		SymParser Parser;
		if (!Parser.IsInitialized())
			return;

		Parser.LoadModule(L"C:\\Windows\\System32\\ntoskrnl.exe");

		SymParser::SYM_INFO Info = {};

		Parser.DumpSymbol(L"KeSuspendThread", Info);
	//	std::wcout << L"KeSuspendThread offset = 0x" << std::hex << Info.Offset << std::endl;

		Struct.KeSuspendThread = Info.Offset;

		Parser.DumpSymbol(L"KeResumeThread", Info);
	//	std::wcout << L"KeResumeThread offset = 0x" << std::hex << Info.Offset << std::endl;

		Struct.KeResumeThread = Info.Offset;

		SecureIO(IO_SENDOFFSETS, &Struct, sizeof(IO_SendOffsets), &Struct, sizeof(IO_SendOffsets));
	}

	SCAN_RESULTS ScanKernelDetections()
	{
		SCAN_RESULTS Struct = { 0 };
		SecureIO(IO_SCANDETECTIONS, &Struct, sizeof(SCAN_RESULTS), &Struct, sizeof(SCAN_RESULTS));

		return Struct;
	}
}
```

`Client/Communication/Server.h`:

```h
#pragma once

namespace Server
{
	void EncDec(char* Buff, uint32_t Size)
	{
		for (uint32_t i = 0; i < Size; i++)
			Buff[i] = (char)(Buff[i] ^ ((i + 13 * i + 93) + 46 + i));
	}

	bool SendInfo(SERVER_INFO Output)
	{
		WSADATA WSAData;
		SOCKET server;
		SOCKADDR_IN addr;
		WSAStartup(MAKEWORD(2, 0), &WSAData);

		if ((server = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
		{
			WSACleanup();
			return false;
		}

		addr.sin_addr.s_addr = inet_addr(xorstr_("127.0.0.1"));
		addr.sin_family = AF_INET;
		addr.sin_port = htons(3768);

		if (connect(server, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR)
		{
			WSACleanup();
			printf("Failed to connect\n");
			return false;
		}

		char OutBuf[3184] = { 0 };
		memcpy(&OutBuf, &Output, sizeof(SERVER_INFO));
		EncDec(OutBuf, sizeof(SERVER_INFO));

		send(server, OutBuf, sizeof(SERVER_INFO), 0);

		char InpBuf[8] = { 0 };
		recv(server, InpBuf, sizeof(InpBuf), 0);
		EncDec(InpBuf, sizeof(uint64_t));

		closesocket(server);
		WSACleanup();

		return true;
	}

	void SendThread()
	{
		const char* UserName = "TestUser2";

		while (TRUE)
		{
			SERVER_INFO Info = { 0 };
			Info.OverlayInfo = OverlayDetection::Enumerate();
			Info.KernelDetections = Driver::ScanKernelDetections();

			strncpy(Info.Username, UserName, strlen(UserName));

			if (!SendInfo(Info))
				printf("Failed to send info to the server!\n");

			std::this_thread::sleep_for(std::chrono::minutes(1));
		}
	}
}
```

`Client/Detection/OverlayScan.h`:

```h
#pragma once

namespace OverlayDetection
{
	OVERLAY_RESULTS Enumerate()
	{
		OVERLAY_RESULTS Struct = { 0 };
		uint32_t WindowsFound = 0;

		HWND TopWindow = GetTopWindow(0);

		if (TopWindow)
		{
			while (TopWindow && TopWindow != OverlayWindow && WindowsFound < 15)
			{
				Struct.Windows[WindowsFound].Style = GetWindowLongA(TopWindow, GWL_STYLE);

				if (Struct.Windows[WindowsFound].Style & WS_VISIBLE)
				{
					GetWindowTextA(TopWindow, Struct.Windows[WindowsFound].WindowName, 50);
					GetClassNameA(TopWindow, Struct.Windows[WindowsFound].ClassName, 50);

					DWORD pID = 0;
					GetWindowThreadProcessId(TopWindow, &pID);

					const wchar_t* ProcessName = Utils::GetProcessName(pID);
					wcstombs(Struct.Windows[WindowsFound].ProcessName, ProcessName, 40);

					HANDLE hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pID);

					if (hProc)
					{
						wchar_t FullImageName[1024];
						DWORD TrashRet = 1024;

						if (QueryFullProcessImageNameW(hProc, 0, FullImageName, &TrashRet))
						{
							if (Utils::IsFileAllowed(FullImageName))
								Struct.Windows[WindowsFound].IsSigned = true;
							else
								Struct.Windows[WindowsFound].IsSigned = false;
						} 

						NtClose(hProc);
					}

					Struct.Windows[WindowsFound].ExStyle = GetWindowLongA(TopWindow, GWL_EXSTYLE);
					GetWindowRect(TopWindow, &Struct.Windows[WindowsFound].Rect);

					printf("Window (0x%lX): Name - %s, Class - %s, Process - %s, Style - 0x%llX, ExStyle - 0x%llX\n", TopWindow,
						Struct.Windows[WindowsFound].WindowName, Struct.Windows[WindowsFound].ClassName, Struct.Windows[WindowsFound].ProcessName,
						Struct.Windows[WindowsFound].Style, Struct.Windows[WindowsFound].ExStyle);

					WindowsFound++;
				}

				TopWindow = GetWindow(TopWindow, GW_HWNDNEXT);
			}
		}

		return Struct;
	}
}



```

`Client/Globals.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include "framework.h"
#include "Client.h"

#include <Windows.h>
#include <stdint.h>
#include <winternl.h>
#include <iostream>
#include <intrin.h>
#include <Psapi.h>
#include <fstream>
#include <vector>
#include <assert.h>
#include <ntstatus.h>
#include <TlHelp32.h>
#include <Uxtheme.h>
#include <dwmapi.h>
#include <string>
#include <winioctl.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <mscat.h>
#include <SoftPub.h>
#include <winsock.h>
#include <thread>

#pragma comment(lib, "wintrust")
#pragma comment(lib, "ws2_32.lib")

int GamePID = -1;

HWND OverlayWindow = 0;

#include "Utils/xorstr.h"
#include "Utils/Defs.h"
#include "Utils/HideImports.h"
#include "Utils/SymParser.h"
#include "Utils/Utils.h"
#include "Communication/Driver.h"
#include "Detection/OverlayScan.h"
#include "Communication/Server.h"
#include "Utils/Loader.h"
```

`Client/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Client.rc

#define IDS_APP_TITLE			103

#define IDR_MAINFRAME			128
#define IDD_CLIENT_DIALOG	102
#define IDD_ABOUTBOX			103
#define IDM_ABOUT				104
#define IDM_EXIT				105
#define IDI_CLIENT			107
#define IDI_SMALL				108
#define IDC_CLIENT			109
#define IDC_MYICON				2
#ifndef IDC_STATIC
#define IDC_STATIC				-1
#endif
// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC					130
#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_COMMAND_VALUE		32771
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		110
#endif
#endif

```

`Client/Utils/Defs.h`:

```h
#pragma once

#define IO_GETSTATUS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x4812984, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_SENDOFFSETS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x91278493, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_SCANDETECTIONS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x6218949, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _IO_GetStatus
{
	uint64_t Send;
	uint64_t Recv;
} IO_GetStatus, * pIO_GetStatus;

typedef struct _IO_SendOffsets
{
	ULONG KeSuspendThread;
	ULONG KeResumeThread;
} IO_SendOffsets, * pIO_SendOffsets;

typedef struct _SCAN_RESULTS
{
	uint32_t InvalidThreads;
	uint32_t TrampolineThreads;
	uint32_t InvalidStacks;
	uint32_t InvalidDispatches;
	bool PiDDB_VulnerableDriver;
} SCAN_RESULTS, * PSCAN_RESULTS;

typedef struct _WINDOW_STRUCT
{
	char WindowName[50];
	char ClassName[50];
	char ProcessName[40];
	bool IsSigned;
	LONG Style;
	LONG ExStyle;
	RECT Rect;
} WINDOW_STRUCT, * PWINDOW_STRUCT;

typedef struct _OVERLAY_RESULTS
{
	WINDOW_STRUCT Windows[15];
} OVERLAY_RESULTS, * POVERLAY_RESULTS;

typedef struct _SERVER_INFO
{
	char Username[30];
	RECT GameWindowRect;
	SCAN_RESULTS KernelDetections;
	OVERLAY_RESULTS OverlayInfo;
} SERVER_INFO, * PSERVER_INFO;
```

`Client/Utils/HideImports.h`:

```h
#pragma once

NTSYSAPI ULONG NTAPI RtlRandomEx(PULONG Seed);
NTSYSAPI VOID NTAPI RtlExitUserProcess(NTSTATUS);
NTSYSAPI NTSTATUS NTAPI NtLoadDriver(PUNICODE_STRING);
NTSYSAPI NTSTATUS NTAPI NtUnloadDriver(PUNICODE_STRING);
extern "C" NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);
NTSYSAPI NTSTATUS NTAPI NtUnmapViewOfSection(HANDLE, PVOID);
NTSYSAPI NTSTATUS NTAPI LdrLoadDll(PWCHAR, PULONG, PUNICODE_STRING, PHANDLE);
NTSYSAPI NTSTATUS NTAPI RtlGetVersion(LPOSVERSIONINFOEXW);
NTSYSAPI PVOID NTAPI RtlImageDirectoryEntryToData(_In_ PVOID ImageBase, _In_ BOOLEAN MappedAsImage, _In_ USHORT DirectoryEntry, _Out_ PULONG Size);

uintptr_t GetNtDll()
{
	//get ntdll base
#if defined _M_IX86
	PPEB_LDR_DATA Ldr = ((PTEB)__readfsdword(FIELD_OFFSET(NT_TIB, Self)))->ProcessEnvironmentBlock->Ldr;
#elif defined _M_X64
	PPEB_LDR_DATA Ldr = ((PTEB)__readgsqword(FIELD_OFFSET(NT_TIB, Self)))->ProcessEnvironmentBlock->Ldr;
#endif

	//process modules
	for (PLIST_ENTRY CurEnt = Ldr->InMemoryOrderModuleList.Flink; CurEnt != &Ldr->InMemoryOrderModuleList; CurEnt = CurEnt->Flink) {
		PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(CurEnt, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		if ((pEntry->BaseDllName.Length == 18) && (*(uint64_t*)pEntry->BaseDllName.Buffer == 0x6C00640074006E))
			return (uintptr_t)pEntry->DllBase;
	} return 0;
}
uintptr_t GetNtDll64_Export(const char* Name)
{
	//parse info
	static uintptr_t hNtDll = 0;
	static PIMAGE_EXPORT_DIRECTORY ExportDir = nullptr;
	if (!hNtDll) {
		hNtDll = GetNtDll();
		PIMAGE_NT_HEADERS NT_Head = (PIMAGE_NT_HEADERS)(hNtDll + ((PIMAGE_DOS_HEADER)hNtDll)->e_lfanew);
		ExportDir = (PIMAGE_EXPORT_DIRECTORY)(hNtDll + NT_Head->OptionalHeader.DataDirectory[0].VirtualAddress);
	}

	//process list
	for (uint32_t i = 0; i < ExportDir->NumberOfNames; i++)
	{
		//get ordinal & name
		uint16_t Ordinal = ((uint16_t*)(hNtDll + ExportDir->AddressOfNameOrdinals))[i];
		const char* ExpName = (const char*)hNtDll + ((uint32_t*)(hNtDll + ExportDir->AddressOfNames))[i];

		//check name
		for (int i = 0; ExpName[i] == Name[i]; i++) if (!ExpName[i])
			return hNtDll + ((uint32_t*)(hNtDll + ExportDir->AddressOfFunctions))[Ordinal];
	} return 0;
}

//LoadLibrary & GetProcAddr
uintptr_t LoadLibUnc(UNICODE_STRING Mod)
{
	typedef NTSTATUS(__stdcall* _LdrLoadDll)(PWCHAR, PULONG, PUNICODE_STRING, HMODULE*);
	static _LdrLoadDll LdrLoadDllFn = nullptr; HMODULE hMod;
	if (!LdrLoadDllFn) LdrLoadDllFn = (_LdrLoadDll)GetNtDll64_Export(xorstr_("LdrLoadDll"));
	LdrLoadDllFn(nullptr, nullptr, &Mod, &hMod); return (uintptr_t)hMod;
}
uintptr_t GetProcAddrAnsi(uintptr_t Mod, ANSI_STRING Func)
{
	typedef NTSTATUS(__stdcall* _LdrGetProcAddr)(HMODULE, PANSI_STRING, WORD, PVOID*);
	static _LdrGetProcAddr LdrGetProcAddr = nullptr; void* FuncAddr;
	if (!LdrGetProcAddr) LdrGetProcAddr = (_LdrGetProcAddr)GetNtDll64_Export(xorstr_("LdrGetProcedureAddress"));
	LdrGetProcAddr((HMODULE)Mod, &Func, 0, &FuncAddr); return (uintptr_t)FuncAddr;
}

//Secure Call Func
#define UNC_STR(a) { sizeof(a) - 2, sizeof(a), (PWSTR)xorstr_(a) }
#define ANS_STR(a) { sizeof(a) - 1, sizeof(a), (PCHAR)xorstr_(a) }

#define FC(Mod, Name, ...) [&](){ \
	static uintptr_t ModBase = 0; \
	if(!ModBase) \
		ModBase = LoadLibUnc({ sizeof(L#Mod) - 2, sizeof(L#Mod), (PWSTR)xorstr_(L#Mod) }); \
	static uintptr_t Func = 0; \
	if (!Func) \
		Func = GetProcAddrAnsi(ModBase, { sizeof(#Name) - 1, sizeof(#Name), (PCHAR)xorstr_(#Name) }); \
	using _OVar = decltype(&Name); \
	return _OVar(Func)(__VA_ARGS__); \
}()

#define FC_err(Mod, Name, Tmplt, ...) [&](){ \
	static uintptr_t ModBase = 0; \
	if(!ModBase) \
		ModBase = LoadLibUnc({ sizeof(L#Mod) - 2, sizeof(L#Mod), (PWSTR)xorstr_(L#Mod) }); \
	static uintptr_t Func = 0; \
	if (!Func) \
		Func = GetProcAddrAnsi(ModBase, { sizeof(#Name) - 1, sizeof(#Name), (PCHAR)xorstr_(#Name) }); \
	using _OVar = decltype(&Tmplt); \
	return _OVar(Func)(__VA_ARGS__); \
}()

char* __CRTDECL strstrFn(char* const _String, char const* const _SubString);
wchar_t* __cdecl wcsstrFn(const wchar_t* Str, const wchar_t* SubStr);
errno_t __cdecl wcscpy_sFn(wchar_t* Dst, rsize_t SizeInWords, const wchar_t* Src);

NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(
	HANDLE    ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerResolution(



	IN ULONG                DesiredResolution,
	IN BOOLEAN              SetResolution,
	OUT PULONG              CurrentResolution);

//ntdll funcs
#define NtClose(a) FC(ntdll, NtClose, a)
#define strlen(a) FC(ntdll, strlen, a)
#define strstr(...) FC_err(ntdll, strstr, strstrFn, __VA_ARGS__)
#define memset(a, b) FC(ntdll, memset, a, 0, b)
#define memcpy(...) FC(ntdll, memcpy, __VA_ARGS__)
#define wcscat(...) FC(ntdll, wcscat, __VA_ARGS__)
#define wcscpy(a, b) FC(ntdll, wcscpy, a, b)
#define NtDeviceIoControlFile(...) FC(ntdll, NtDeviceIoControlFile, __VA_ARGS__)
#define wcscpy_s(...) FC_err(ntdll, wcscpy_s, wcscpy_sFn, __VA_ARGS__)
#define wcslen(...) FC(ntdll, wcslen, __VA_ARGS__)
#define RtlGetVersion(a) FC(ntdll, RtlGetVersion, a)
#define ExitProcess() FC(ntdll, RtlExitUserProcess, 0)
#define NtOpenFile(...) FC(ntdll, NtOpenFile, __VA_ARGS__)
#define NtQuerySystemInformation(...) FC(ntdll, NtQuerySystemInformation, __VA_ARGS__)
#define NtSetTimerResolution(...) FC(ntdll, NtSetTimerResolution, __VA_ARGS__)
#define RtlImageDirectoryEntryToData(...) FC(ntdll, RtlImageDirectoryEntryToData, __VA_ARGS__)

//Shell32 funcs
#define CommandLineToArgvW(a, b) FC(shell32, CommandLineToArgvW, a, b)

//Kernel32 funcs
#define Sleep(a) FC(kernel32, Sleep, a)
#define LocalFree(a) FC(kernel32, LocalFree, a)
#define GetModuleFileNameW(...) FC(kernel32, GetModuleFileNameW, __VA_ARGS__)
#define GetModuleHandleW(...) FC(kernel32, GetModuleHandleW, __VA_ARGS__)
#define VirtualQuery(...) FC(kernel32, VirtualQuery, __VA_ARGS__)
#define FreeLibrary(a) FC(kernel32, FreeLibrary, a)
#define GetCommandLineW() FC(kernel32, GetCommandLineW)
#define LoadLibraryA(a) FC(kernel32, LoadLibraryA, a)
#define GetConsoleWindow() FC(kernel32, GetConsoleWindow)
#define ReadFile(...) FC(kernel32, ReadFile, __VA_ARGS__)
#define WriteFile(...) FC(kernel32, WriteFile, __VA_ARGS__)
#define free(a) FC(kernel32, VirtualFree, a, 0, MEM_RELEASE)
#define SetConsoleTitleW(a) FC(kernel32, SetConsoleTitleW, a)
#define MoveFileExW(...) FC(kernel32, MoveFileExW, __VA_ARGS__)
#define CreateFileW(...) FC(kernel32, CreateFileW, __VA_ARGS__)
#define CloseHandle(...) FC(kernel32, CloseHandle, __VA_ARGS__)
#define DeleteFileW(...) FC(kernel32, DeleteFileW, __VA_ARGS__)
#define GetFileSize(...) FC(kernel32, GetFileSize, __VA_ARGS__)
#define GetCurrentProcessId() FC(kernel32, GetCurrentProcessId)
#define GetTempPathW(...) FC(kernel32, GetTempPathW, __VA_ARGS__)
#define MapViewOfFile(...) FC(kernel32, MapViewOfFile, __VA_ARGS__)
#define WriteConsoleA(...) FC(kernel32, WriteConsoleA, __VA_ARGS__)
#define GetConsoleOutHandle() FC(kernel32, GetStdHandle, STD_OUTPUT_HANDLE);
#define DeviceIoControl(...) FC(kernel32, DeviceIoControl, __VA_ARGS__)
#define UnmapViewOfFile(...) FC(kernel32, UnmapViewOfFile, __VA_ARGS__)
#define LoadLibraryExA(a, b) FC(kernel32, LoadLibraryExA, a, nullptr, b)
#define CreateFileMappingA(...) FC(kernel32, CreateFileMappingA, __VA_ARGS__)
#define GetProcAddress(...) (uintptr_t)FC(kernel32, GetProcAddress, __VA_ARGS__)
#define SetConsoleTextAttribute(...) FC(kernel32, SetConsoleTextAttribute, __VA_ARGS__)
#define GetConsoleScreenBufferInfo(...) FC(kernel32, GetConsoleScreenBufferInfo, __VA_ARGS__)
#define malloc(a) FC(kernel32, VirtualAlloc, nullptr, a, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
#define Wow64DisableWow64FsRedirection(...) FC(kernel32, Wow64DisableWow64FsRedirection, __VA_ARGS__)
#define Wow64RevertWow64FsRedirection(...) FC(kernel32, Wow64RevertWow64FsRedirection, __VA_ARGS__)
#define QueryFullProcessImageNameW(...) FC(kernel32, QueryFullProcessImageNameW, __VA_ARGS__)
#define GetFileSize(...) FC(kernel32, GetFileSize, __VA_ARGS__)
#define IsBadReadPtr(...) FC(kernel32, IsBadReadPtr, __VA_ARGS__)
#define CreateProcessW(...) FC(kernel32, CreateProcessW, __VA_ARGS__)
#define CreateThread(...) FC(kernel32, CreateThread, __VA_ARGS__)
#define GetProcessId(...) FC(kernel32, GetProcessId, __VA_ARGS__)
#define OpenProcess(...) FC(kernel32, OpenProcess, __VA_ARGS__)

//Advapi32 funcs
#define RegOpenKeyA(...) FC(advapi32, RegOpenKeyA, __VA_ARGS__)
#define RegCloseKey(...) FC(advapi32, RegCloseKey, __VA_ARGS__)
#define RegCreateKeyW(...) FC(advapi32, RegCreateKeyW, __VA_ARGS__)
#define RegDeleteKeyW(...) FC(advapi32, RegDeleteKeyW, __VA_ARGS__)
#define RegSetValueExA(...) FC(advapi32, RegSetValueExA, __VA_ARGS__)
#define RegSetValueExW(...) FC(advapi32, RegSetValueExW, __VA_ARGS__)
#define OpenProcessToken(...) FC(advapi32, OpenProcessToken, __VA_ARGS__)
#define LookupPrivilegeValueA(...) FC(advapi32, LookupPrivilegeValueA, __VA_ARGS__)
#define AdjustTokenPrivileges(...) FC(advapi32, AdjustTokenPrivileges, __VA_ARGS__)
#define CryptCreateHash(...) FC(advapi32, CryptCreateHash, __VA_ARGS__)
#define CryptHashData(...) FC(advapi32, CryptHashData, __VA_ARGS__)
#define CryptGetHashParam(...) FC(advapi32, CryptGetHashParam, __VA_ARGS__)
#define CryptDestroyHash(...) FC(advapi32, CryptDestroyHash, __VA_ARGS__)
#define CryptReleaseContext(...) FC(advapi32, CryptReleaseContext, __VA_ARGS__)

//Crypt32 funcs
#define CertFindCertificateInStore(...) FC(crypt32, CertFindCertificateInStore, __VA_ARGS__)
#define CryptMsgGetParam(...) FC(crypt32, CryptMsgGetParam, __VA_ARGS__)
#define CryptQueryObject(...) FC(crypt32, CryptQueryObject, __VA_ARGS__)
#define CertGetNameStringW(...) FC(crypt32, CertGetNameStringW, __VA_ARGS__)
#define CertFreeCertificateContext(...) FC(crypt32, CertFreeCertificateContext, __VA_ARGS__)
#define CertCloseStore(...) FC(crypt32, CertCloseStore, __VA_ARGS__)
#define CryptMsgClose(...) FC(crypt32, CryptMsgClose, __VA_ARGS__)

//User32 funcs
#define FindWindowW(...) FC(user32, FindWindowW, __VA_ARGS__)
#define EnableWindow(...) FC(user32, EnableWindow, __VA_ARGS__)
#define SetWindowsHookExW(...) FC(user32, SetWindowsHookExW, __VA_ARGS__)
#define UnhookWindowsHookEx(...) FC(user32, UnhookWindowsHookEx, __VA_ARGS__)
#define PostThreadMessageW(...) FC(user32, PostThreadMessageW, __VA_ARGS__)
#define GetWindowThreadProcessId(...) FC(user32, GetWindowThreadProcessId, __VA_ARGS__)
#define GetWindow(...) FC(user32, GetWindow, __VA_ARGS__)
#define GetTopWindow(...) FC(user32, GetTopWindow, __VA_ARGS__)
#define GetWindowTextA(...) FC(user32, GetWindowTextA, __VA_ARGS__)
#define GetWindowTextW(...) FC(user32, GetWindowTextW, __VA_ARGS__)
#define GetClassNameA(...) FC(user32, GetClassNameA, __VA_ARGS__)
#define GetClassNameW(...) FC(user32, GetClassNameW, __VA_ARGS__)
#define GetWindowLongA(...) FC(user32, GetWindowLongA, __VA_ARGS__)
#define GetWindowRect(...) FC(user32, GetWindowRect, __VA_ARGS__)

//FltLib funcs
#define FltSendMessage(...) FC(FltLib, FilterSendMessage, __VA_ARGS__)
#define FltGetMessage(...) FC(FltLib, FilterGetMessage, __VA_ARGS__)
#define FltConnectCommunicationPort(...) FC(FltLib, FilterConnectCommunicationPort, __VA_ARGS__)
#define FltReplyMessage(...) FC(FltLib, FilterReplyMessage, __VA_ARGS__)

//wintrust funcs
#define CryptCATAdminAcquireContext(...) FC(wintrust, CryptCATAdminAcquireContext, __VA_ARGS__)
#define CryptCATAdminCalcHashFromFileHandle(...) FC(wintrust, CryptCATAdminCalcHashFromFileHandle, __VA_ARGS__)
#define CryptCATAdminEnumCatalogFromHash(...) FC(wintrust, CryptCATAdminEnumCatalogFromHash, __VA_ARGS__)
#define CryptCATCatalogInfoFromContext(...) FC(wintrust, CryptCATCatalogInfoFromContext, __VA_ARGS__)
#define WinVerifyTrust(...) FC(wintrust, WinVerifyTrust, __VA_ARGS__)
#define CryptCATAdminReleaseCatalogContext(...) FC(wintrust, CryptCATAdminReleaseCatalogContext, __VA_ARGS__)
#define CryptCATAdminReleaseContext(...) FC(wintrust, CryptCATAdminReleaseContext, __VA_ARGS__)

//winsocket func
#define send(...) FC(Ws2_32, send, __VA_ARGS__)
#define recv(...) FC(Ws2_32, recv, __VA_ARGS__)
#define socket(...) FC(Ws2_32, socket, __VA_ARGS__)
#define connect(...) FC(Ws2_32, connect, __VA_ARGS__)
#define closesocket(...) FC(Ws2_32, closesocket, __VA_ARGS__)
#define inet_addr(...) FC(Ws2_32, inet_addr, __VA_ARGS__)
#define htons(...) FC(Ws2_32, htons, __VA_ARGS__)
#define WSAStartup(...) FC(Ws2_32, WSAStartup, __VA_ARGS__)
#define WSACleanup(...) FC(Ws2_32, WSACleanup, __VA_ARGS__)

uint32_t getRand()
{
	uint32_t seed = (uint32_t)__rdtsc();
	return FC(ntdll, RtlRandomEx, (PULONG)&seed);
}

//inline funcs
#define SizeAlign(a) ((a + 4095) & 0xFFFFF000)

void toWchar(wchar_t* Dst, const char* Str)
{
	for (;; Str++, Dst++)
	{
		char Tmp = *Str;
		*Dst = Tmp;
		if (!Tmp)
			break;
	}
}

void toChar(char* Dst, const wchar_t* Str)
{
	for (;; Str++, Dst++)
	{
		wchar_t Tmp = *Str;
		*Dst = (char)Tmp;
		if (!Tmp)
			break;
	}
}
```

`Client/Utils/Loader.h`:

```h
#pragma once

namespace Loader
{
	bool LoadDriver(std::string DriverPath, std::string DriverName)
	{
		SC_HANDLE SCM_Handle = OpenSCManagerA(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);

		if (!SCM_Handle)
			return false;

		SC_HANDLE ServiceHandle = CreateServiceA(SCM_Handle, DriverName.c_str(), DriverName.c_str(), SERVICE_START | SERVICE_STOP | DELETE,
			SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, DriverPath.c_str(), nullptr, nullptr, nullptr, nullptr, nullptr);

		if (!ServiceHandle)
		{
			ServiceHandle = OpenServiceA(SCM_Handle, DriverName.c_str(), SERVICE_START);

			if (!ServiceHandle)
			{
				CloseServiceHandle(SCM_Handle);
				return false;
			}
		}

		bool Result = StartServiceA(ServiceHandle, 0, nullptr);

		if (!Result)
			std::cout << GetLastError() << std::endl;

		CloseServiceHandle(ServiceHandle);
		CloseServiceHandle(SCM_Handle);

		return Result;
	}

	bool UnloadDriver(std::string DriverName)
	{
		SC_HANDLE SCM_Handle = OpenSCManagerA(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);

		if (!SCM_Handle)
			return false;

		SC_HANDLE ServiceHandle = OpenServiceA(SCM_Handle, DriverName.c_str(), SERVICE_STOP | DELETE);

		if (!ServiceHandle)
		{
			CloseServiceHandle(SCM_Handle);
			return false;
		}

		SERVICE_STATUS Status = { 0 };
		bool Result = ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &Status) && DeleteService(ServiceHandle);

		CloseServiceHandle(ServiceHandle);
		CloseServiceHandle(SCM_Handle);

		return Result;
	}
}
```

`Client/Utils/SymParser.cpp`:

```cpp
#include <windows.h>
#include <vector>
#include <string>
#include "SymParser.h"

// Using Wide-versions of DbgHelp functions:
#define DBGHELP_TRANSLATE_TCHAR

// Expose additional declarations from DbgHelp.h:
#define _NO_CVCONST_H 

#include <dbghelp.h>
#pragma comment(lib, "dbghelp.lib")

SymParser::SymParser(OPTIONAL LPCWSTR SymbolsPath)
    : Initialized(FALSE), hProcess(GetCurrentProcess()), ModuleBase(NULL)
{
    Initialized = SymInitialize(
        hProcess,
        SymbolsPath ? SymbolsPath : DefaultSymbolsPath,
        FALSE
    );
}

SymParser::~SymParser() {
    if (Initialized) SymCleanup(hProcess);
}


BOOL SymParser::LoadModule(LPCWSTR ModulePath, OPTIONAL DWORD64 ImageBase, OPTIONAL DWORD ImageSize) {
    ModuleBase = SymLoadModuleEx(hProcess, NULL, ModulePath, NULL, ImageBase, ImageSize, NULL, 0);
    return ModuleBase != NULL;
}


std::wstring SymParser::GetSymName(ULONG Index, OPTIONAL OUT PBOOL Status) {
    LPCWSTR Name = NULL;
    if (SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_SYMNAME, &Name) && Name) {
        std::wstring SymName = Name;
        VirtualFree(const_cast<LPWSTR>(Name), 0, MEM_RELEASE);
        if (Status) *Status = TRUE;
        return SymName;
    }
    if (Status) *Status = FALSE;
    return L"";
}

std::wstring SymParser::GetSymTypeName(ULONG Index, OPTIONAL OUT PUINT64 BaseTypeSize, OPTIONAL OUT PBOOL Status) {
    if (!Index) return L"";

    UINT64 SymSize = GetSymSize(Index, Status);
    if (BaseTypeSize) *BaseTypeSize = SymSize;
    std::wstring TypeName = GetSymName(Index, Status);
    if (!TypeName.empty()) return TypeName;

    enum SymTagEnum Tag = GetSymTag(Index, Status);
    switch (Tag) {
    case SymTagBaseType: {
        enum SymParser::BasicType Type = GetSymBaseType(Index, Status);
        switch (Type) {
        case btNoType:
            TypeName = L"NO_TYPE";
            break;
        case btVoid:
            TypeName = L"VOID";
            break;
        case btChar:
            TypeName = L"CHAR";
            break;
        case btWChar:
            TypeName = L"WCHAR";
            break;
        case btInt:
            TypeName = SymSize == sizeof(INT64) ? L"INT64" : L"INT";
            break;
        case btUInt:
            TypeName = SymSize == sizeof(UINT64) ? L"UINT64" : L"UINT";
            break;
        case btFloat:
            TypeName = L"float";
            break;
        case btBCD:
            TypeName = L"BCD"; // Binary-coded decimal
            break;
        case btBool:
            TypeName = L"BOOL";
            break;
        case btLong:
            TypeName = SymSize == sizeof(LONGLONG) ? L"LONGLONG" : L"LONG";
            break;
        case btULong:
            TypeName = SymSize == sizeof(ULONGLONG) ? L"ULONGLONG" : L"ULONG";
            break;
        case btCurrency:
            TypeName = L"CurrencyType"; // ???
            break;
        case btDate:
            TypeName = L"DateType"; // ???
            break;
        case btVariant:
            TypeName = L"VariantType"; // ???
            break;
        case btComplex:
            TypeName = L"ComplexType"; // ???
            break;
        case btBit:
            TypeName = L"Bit";
            break;
        case btBSTR:
            TypeName = L"BSTR"; // Binary string
            break;
        case btHresult:
            TypeName = L"HRESULT";
            break;
        }
        break;
    }
    case SymTagPointerType: {
        ULONG Type = GetSymType(Index, Status);
        TypeName = GetSymTypeName(Type, BaseTypeSize, Status) + L"*";
        break;
    }
    case SymTagArrayType: {
        ULONG Type = GetSymArrayTypeId(Index, Status);
        TypeName = GetSymTypeName(Type, BaseTypeSize, Status);
        break;
    }
    default: {
        ULONG Type = GetSymType(Index, Status);
        TypeName = GetSymTypeName(Type, BaseTypeSize, Status);
    }
    }

    return TypeName;
}

UINT64 SymParser::GetSymSize(ULONG Index, OPTIONAL OUT PBOOL Status) {
    UINT64 Size = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_LENGTH, &Size);
    if (Status) *Status = SymStatus;
    return Size;
}

ULONG SymParser::GetSymOffset(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Offset = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_OFFSET, &Offset);
    if (Status) *Status = SymStatus;
    return Offset;
}

ULONG SymParser::GetSymAddressOffset(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Offset = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_ADDRESSOFFSET, &Offset);
    if (Status) *Status = SymStatus;
    return Offset;
}

ULONG SymParser::GetSymBitPosition(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG BitPosition = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_BITPOSITION, &BitPosition);
    if (Status) *Status = SymStatus;
    return BitPosition;
}

ULONG SymParser::GetSymTypeId(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG TypeId = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_TYPEID, &TypeId);
    if (Status) *Status = SymStatus;
    return TypeId;
}

ULONG SymParser::GetSymArrayTypeId(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG TypeId = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_ARRAYINDEXTYPEID, &TypeId);
    if (Status) *Status = SymStatus;
    return TypeId;
}

enum SymTagEnum SymParser::GetSymTag(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Tag = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_SYMTAG, &Tag);
    if (Status) *Status = SymStatus;
    return static_cast<enum SymTagEnum>(Tag);
}

enum SymParser::BasicType SymParser::GetSymType(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG Type = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_TYPE, &Type);
    if (Status) *Status = SymStatus;
    return static_cast<enum BasicType>(Type);
}

enum SymParser::BasicType SymParser::GetSymBaseType(ULONG Index, OPTIONAL OUT PBOOL Status) {
    ULONG BasicType = 0;
    BOOL SymStatus = SymGetTypeInfo(hProcess, ModuleBase, Index, TI_GET_BASETYPE, &BasicType);
    if (Status) *Status = SymStatus;
    return static_cast<enum BasicType>(BasicType);
}


BOOL SymParser::DumpSymbol(LPCWSTR SymbolName, OUT SYM_INFO& SymInfo) {
    SymInfo = {};

    // Obtaining root symbol:
    const ULONG SymNameLength = 128;
    const ULONG SymInfoSize = sizeof(SYMBOL_INFO) + SymNameLength * sizeof(WCHAR);
    std::vector<BYTE> RootSymbolInfoBuffer(SymInfoSize);
    auto RootSymbolInfo = reinterpret_cast<PSYMBOL_INFO>(&RootSymbolInfoBuffer[0]);
    RootSymbolInfo->SizeOfStruct = SymInfoSize;
    BOOL Status = SymGetTypeFromName(hProcess, ModuleBase, SymbolName, RootSymbolInfo);
    if (!Status) return FALSE;

    ULONG RootIndex = RootSymbolInfo->Index;

    SymInfo.Name = GetSymName(RootIndex);
    SymInfo.Size = GetSymSize(RootIndex);
    SymInfo.Offset = GetSymOffset(RootIndex, &Status);
    if (!Status) SymInfo.Offset = GetSymAddressOffset(RootIndex);

    // Obtaining root symbol children count:
    ULONG ChildrenCount = 0;
    Status = SymGetTypeInfo(hProcess, ModuleBase, RootIndex, TI_GET_CHILDRENCOUNT, &ChildrenCount);
    if (!Status) return FALSE;

    SymInfo.Name = SymbolName;
    SymGetTypeInfo(hProcess, ModuleBase, RootIndex, TI_GET_LENGTH, &SymInfo.Size);

    if (ChildrenCount) {
        // Obtaining children indices:
        std::vector<BYTE> FindChildrenParamsBuffer(sizeof(TI_FINDCHILDREN_PARAMS) + ChildrenCount * sizeof(ULONG));
        auto Children = reinterpret_cast<TI_FINDCHILDREN_PARAMS*>(&FindChildrenParamsBuffer[0]);
        Children->Count = ChildrenCount;
        Status = SymGetTypeInfo(hProcess, ModuleBase, RootIndex, TI_FINDCHILDREN, Children);
        if (!Status) return FALSE;

        for (unsigned int i = 0; i < ChildrenCount; i++) {
            SYM_CHILD_ENTRY Entry = {};
            ULONG ChildIndex = Children->ChildId[i];
            ULONG TypeId = GetSymTypeId(ChildIndex);
            Entry.Name = GetSymName(ChildIndex);
            Entry.Size = GetSymSize(TypeId);
            Entry.Offset = GetSymOffset(ChildIndex);
            Entry.BitPosition = GetSymBitPosition(ChildIndex, &Entry.IsBitField);
            UINT64 BaseTypeSize = 0;
            Entry.TypeName = GetSymTypeName(TypeId, &BaseTypeSize);
            Entry.ElementsCount = BaseTypeSize != 0 ? Entry.Size / BaseTypeSize : 1;

            if (Entry.Name.empty()) Entry.Name = L"UNKNOWN_NAME";
            if (Entry.TypeName.empty()) Entry.TypeName = L"UNKNOWN_TYPE";

            SymInfo.Entries.emplace_back(Entry);
        }
    }

    return TRUE;
}
```

`Client/Utils/SymParser.h`:

```h
#pragma once

class SymParser {
private:
    // From cvconst.h:
    enum BasicType {
        btNoType = 0,
        btVoid = 1,
        btChar = 2,
        btWChar = 3,
        btInt = 6,
        btUInt = 7,
        btFloat = 8,
        btBCD = 9,
        btBool = 10,
        btLong = 13,
        btULong = 14,
        btCurrency = 25,
        btDate = 26,
        btVariant = 27,
        btComplex = 28,
        btBit = 29,
        btBSTR = 30,
        btHresult = 31
    };

    BOOL Initialized;
    HANDLE hProcess;
    DWORD64 ModuleBase;
    LPCWSTR DefaultSymbolsPath = L"srv*C:\\Symbols*https://msdl.microsoft.com/download/symbols";

    std::wstring GetSymName(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    std::wstring GetSymTypeName(ULONG Index, OPTIONAL OUT PUINT64 BaseTypeSize = NULL, OPTIONAL OUT PBOOL Status = NULL);
    UINT64 GetSymSize(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymOffset(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymAddressOffset(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymBitPosition(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymTypeId(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    ULONG GetSymArrayTypeId(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    enum SymTagEnum GetSymTag(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    enum BasicType GetSymType(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
    enum BasicType GetSymBaseType(ULONG Index, OPTIONAL OUT PBOOL Status = NULL);
public:
    using SYM_CHILD_ENTRY = struct {
        std::wstring Name;
        std::wstring TypeName;
        UINT64 ElementsCount;
        UINT64 Size;
        ULONG Offset;
        BOOL IsBitField;
        ULONG BitPosition;
    };
    using SYM_INFO = struct {
        std::wstring Name;
        UINT64 Size;
        ULONG Offset;
        std::vector<SYM_CHILD_ENTRY> Entries;
    };

    SymParser(OPTIONAL LPCWSTR SymbolsPath = NULL);
    ~SymParser();

    BOOL IsInitialized() const { return Initialized; }

    // Load symbols for specified module (*.exe/*.dll/*.sys etc.):
    BOOL LoadModule(LPCWSTR ModulePath, OPTIONAL DWORD64 ImageBase = NULL, OPTIONAL DWORD ImageSize = 0);

    BOOL DumpSymbol(LPCWSTR SymbolName, OUT SYM_INFO& SymInfo);
};
```

`Client/Utils/Utils.h`:

```h
#pragma once

namespace Utils
{
#define SafeDeleteArraySize(pData) { if(pData){delete []pData;pData=NULL;} }

	bool RedirectionCreateFile(const wchar_t* FilePath, HANDLE& hFile)
	{
		bool Ret = false;

		if (!FilePath)
			return Ret;

		PVOID OldVal = NULL;
		bool Val = Wow64DisableWow64FsRedirection(&OldVal);

		hFile = CreateFileW(FilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
			return true;

		OldVal = NULL;

		if (Val)
			Wow64RevertWow64FsRedirection(&OldVal);

		return Val;
	}

	wchar_t* GetCertName(const wchar_t* FilePath)
	{
		CERT_INFO CertInfo;
		memset(&CertInfo, sizeof(CertInfo));

		if (IsBadReadPtr(FilePath, sizeof(DWORD)))
			return NULL;

		wchar_t* CertName = NULL;
		PCCERT_CONTEXT pCertContext = NULL;
		HCERTSTORE hStore = NULL;
		HCRYPTMSG hMsg = NULL;

		do
		{
			DWORD NumberOfBytesRead = 0;
			HANDLE hFile = INVALID_HANDLE_VALUE;

			if (!RedirectionCreateFile(FilePath, hFile))
				break;

			DWORD FileSize = GetFileSize(hFile, NULL);
			BYTE* pBuff = new BYTE[FileSize + 1];

			if (!pBuff)
				break;

			RtlZeroMemory(pBuff, FileSize + 1);

			BOOL Status = ReadFile(hFile, pBuff, FileSize, &NumberOfBytesRead, NULL);
			CloseHandle(hFile);

			if (!Status)
				break;

			CERT_BLOB Object = { 0 };
			Object.cbData = FileSize;
			Object.pbData = pBuff;

			DWORD dwEncoding = 0, dwContentType = 0, dwFormatType = 0;

			Status = CryptQueryObject(CERT_QUERY_OBJECT_FILE, FilePath, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0, &dwEncoding, &dwContentType, &dwFormatType, &hStore, &hMsg, NULL);

			if (!Status)
			{
				PVOID OldVal = 0;
				BOOL IsDisabled = Wow64DisableWow64FsRedirection(&OldVal);
				OldVal = 0;

				Status = CryptQueryObject(CERT_QUERY_OBJECT_FILE, FilePath, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0, &dwEncoding, &dwContentType, &dwFormatType, &hStore, &hMsg, NULL);

				if (Status)
					Wow64RevertWow64FsRedirection(&OldVal);

				if (!Status)
					break;
			}

			DWORD dwSignerInfo = 0;
			Status = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &dwSignerInfo);

			if (!Status)
				break;

			PCMSG_SIGNER_INFO pSignerInfo = (PCMSG_SIGNER_INFO)new char[dwSignerInfo];

			if (!pSignerInfo)
				break;

			ZeroMemory(pSignerInfo, dwSignerInfo);

			Status = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pSignerInfo, &dwSignerInfo);

			if (!Status)
				break;

			CertInfo.Issuer = pSignerInfo->Issuer;
			CertInfo.SerialNumber = pSignerInfo->SerialNumber;

			pCertContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_CERT, (PVOID)&CertInfo, NULL);

			if (!pCertContext)
				break;

			DWORD dwData = CertGetNameStringW(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);
			if (1 >= dwData)
				break;

			CertName = new wchar_t[dwData + 1];

			if (!CertName)
				break;

			ZeroMemory(CertName, (dwData + 1) * sizeof(wchar_t));

			if (!(CertGetNameStringW(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, CertName, dwData)))
				break;

		} while (false);

		if (pCertContext != NULL)
			CertFreeCertificateContext(pCertContext);

		if (hStore != NULL)
			CertCloseStore(hStore, 0);

		if (hMsg != NULL)
			CryptMsgClose(hMsg);

		return CertName;
	}

	wchar_t* GetFileCat(wchar_t* lpFileName)
	{
		WINTRUST_DATA wd = { 0 };
		WINTRUST_FILE_INFO wfi = { 0 };
		WINTRUST_CATALOG_INFO wci = { 0 };
		CATALOG_INFO ci = { 0 };
		HCATADMIN hCatAdmin = NULL;
		HANDLE hFile = INVALID_HANDLE_VALUE;
		DWORD dwCnt = 0;
		PBYTE pbyHash = NULL;
		wchar_t* pszMemberTag = NULL;
		HCATINFO hCatInfo = NULL;
		HRESULT hr;
		static GUID action = WINTRUST_ACTION_GENERIC_VERIFY_V2;
		const GUID gSubsystem = DRIVER_ACTION_VERIFY;
		wchar_t* pCatalogFile = NULL;

		do
		{

			if (!CryptCATAdminAcquireContext(&hCatAdmin, &gSubsystem, 0))
				break;

			if (!RedirectionCreateFile(lpFileName, hFile))
				break;

			if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwCnt, pbyHash, 0) && dwCnt > 0 && ERROR_INSUFFICIENT_BUFFER == GetLastError())
			{
				pbyHash = new BYTE[dwCnt];
				ZeroMemory(pbyHash, dwCnt);
				if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwCnt, pbyHash, 0) == FALSE)
				{
					CloseHandle(hFile);
					break;
				}
			}
			else
			{
				CloseHandle(hFile);
				break;
			}

			CloseHandle(hFile);

			hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbyHash, dwCnt, 0, NULL);

			if (NULL == hCatInfo)
			{
				wfi.cbStruct = sizeof(WINTRUST_FILE_INFO);
				wfi.pcwszFilePath = lpFileName;
				wfi.hFile = NULL;
				wfi.pgKnownSubject = NULL;
				wd.cbStruct = sizeof(WINTRUST_DATA);
				wd.dwUnionChoice = WTD_CHOICE_FILE;
				wd.pFile = &wfi;
				wd.dwUIChoice = WTD_UI_NONE;
				wd.fdwRevocationChecks = WTD_REVOKE_NONE;
				wd.dwStateAction = WTD_STATEACTION_IGNORE;
				wd.dwProvFlags = WTD_SAFER_FLAG;
				wd.hWVTStateData = NULL;
				wd.pwszURLReference = NULL;
			}
			else
			{
				if (CryptCATCatalogInfoFromContext(hCatInfo, &ci, 0))
				{
					pszMemberTag = new wchar_t[dwCnt * 2 + 1];
					ZeroMemory(pszMemberTag, (dwCnt * 2 + 1) * sizeof(wchar_t));

					for (DWORD dw = 0; dw < dwCnt; ++dw)
						wsprintfW(&pszMemberTag[dw * 2], L"%02X", pbyHash[dw]);

					wci.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
					wci.pcwszCatalogFilePath = ci.wszCatalogFile;
					wci.pcwszMemberFilePath = lpFileName;
					wci.pcwszMemberTag = pszMemberTag;

					wd.cbStruct = sizeof(WINTRUST_DATA);
					wd.pCatalog = &wci;
					wd.dwUIChoice = WTD_UI_NONE;
					wd.dwUnionChoice = WTD_CHOICE_CATALOG;
					wd.fdwRevocationChecks = WTD_STATEACTION_VERIFY;
					wd.dwStateAction = WTD_STATEACTION_VERIFY;
					wd.dwProvFlags = 0;
					wd.hWVTStateData = NULL;
					wd.pwszURLReference = NULL;

				}
			}

			hr = WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &action, &wd);

			if (SUCCEEDED(hr) || wcslen(ci.wszCatalogFile) > 0)
			{
				pCatalogFile = new wchar_t[MAX_PATH];
				ZeroMemory(pCatalogFile, MAX_PATH * sizeof(wchar_t));
				CopyMemory(pCatalogFile, ci.wszCatalogFile, wcslen(ci.wszCatalogFile) * sizeof(wchar_t));
			}

			if (NULL != hCatInfo)
				CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);


		} while (FALSE);


		if (hCatAdmin)
			CryptCATAdminReleaseContext(hCatAdmin, 0);

		SafeDeleteArraySize(pbyHash);
		SafeDeleteArraySize(pszMemberTag);
		return pCatalogFile;
	}

	wchar_t* GetFileCertName(wchar_t* pFilePath)
	{
		wchar_t* pCertName = NULL;
		wchar_t* pCatFilePath = NULL;

		pCertName = GetCertName(pFilePath);

		if (pCertName == NULL)
		{
			pCatFilePath = GetFileCat(pFilePath);

			if (pCatFilePath)
				pCertName = GetCertName(pCatFilePath);
		}

		SafeDeleteArraySize(pCatFilePath);
		return pCertName;
	}

	bool IsFileAllowed(wchar_t* pFilePath)
	{
		HANDLE hFile = NULL;

		if (!RedirectionCreateFile(pFilePath, hFile))
			return false;

		if (GetFileCertName(pFilePath) == NULL)
			return false;

		return true;
	}

	wchar_t* GetProcessName(uint32_t pID)
	{
		HANDLE hSnap = INVALID_HANDLE_VALUE;
		HANDLE hProcess = INVALID_HANDLE_VALUE;
		PROCESSENTRY32 ProcessStruct;
		ProcessStruct.dwSize = sizeof(PROCESSENTRY32);
		hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (hSnap == INVALID_HANDLE_VALUE)
			return 0;
		if (Process32First(hSnap, &ProcessStruct) == FALSE)
			return 0;
		do
		{
			if (pID == ProcessStruct.th32ProcessID)
			{
				CloseHandle(hSnap);
				return (wchar_t*)ProcessStruct.szExeFile;
			}

		} while (Process32Next(hSnap, &ProcessStruct));

		CloseHandle(hSnap);
		return 0;
	}

	std::string WtoS(const std::wstring& wstr)
	{
		if (wstr.empty()) return std::string();
		int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
		std::string strTo(size_needed, 0);
		WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
		return strTo;
	}
}
```

`Client/Utils/xorstr.h`:

```h
/*
 * Copyright 2017 - 2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP
#define JM_XORSTR_DISABLE_AVX_INTRINSICS

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                              \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()
#define E(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

 // you can define this macro to get possibly faster code on gcc/clang
 // at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

    namespace detail {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1> {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2> {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4> {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type {
            using type = decltype(C);
        };

        template<std::size_t Size>
        constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<auto... Cs>
        struct tstring_ {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...(Cs);
            constexpr static value_type  str[size] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
            constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((sizeof(str) > 16) ? 32 : 16);
#else
                16;
#endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for (char c : __TIMESTAMP__)
                value = static_cast<std::uint32_t>((value ^ c) * 78920519ull);
            return value;
        }

        template<std::size_t S>
        constexpr std::uint64_t key8()
        {
            constexpr auto first_part = key4<4784258102 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T, std::uint64_t... Keys>
        struct string_storage {
            std::uint64_t storage[T::buffer_size];

            XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... }
            {
                using cast_type =
                    typename unsigned_<sizeof(typename T::value_type)>::type;
                constexpr auto value_size = sizeof(typename T::value_type);
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / value_size)] ^=
                    (std::uint64_t{ static_cast<cast_type>(T::str[i]) }
                << ((i % (8 / value_size)) * 8 * value_size));
            }
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string {
        alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

        // _single functions needed because MSVC crashes without them
        XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept

        {
            _mm256_store_si256(
                reinterpret_cast<__m256i*>(storage),
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept
        {
            (_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
        }

        XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept
        {
            _mm_store_si128(
                reinterpret_cast<__m128i*>(storage),
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept
        {
            (_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
        }

        // loop generates vectorized code which places constants in data dir
        XORSTR_FORCEINLINE constexpr void _copy() noexcept
        {
            constexpr detail::string_storage<T, Keys::key...> storage;
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
                    storage.storage[Keys::idx]... });
        }

    public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
            alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
                    Keys::key... });

            _copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
            if constexpr (T::buffer_size % 4 != 0)
                _crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
            _crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
        {
            crypt();
            return reinterpret_cast<const_pointer>(_storage);
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr(Tstr str_lambda,
            std::index_sequence<StringIndices...>,
            std::index_sequence<KeyIndices...>) noexcept
    {
        return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```

`Client/framework.h`:

```h
// header.h : include file for standard system include files,
// or project specific include files
//

#pragma once

#include "targetver.h"
#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>
// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

```

`Client/targetver.h`:

```h
#pragma once

// // Including SDKDDKVer.h defines the highest available Windows platform.
// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
#include <SDKDDKVer.h>

```

`DLL/DLL.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6f735f4f-3d54-4359-a88f-0e23b59eb49b}</ProjectGuid>
    <RootNamespace>DLL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Globals.h" />
    <ClInclude Include="Hooks\Hooks.h" />
    <ClInclude Include="Hooks\MinHook.h" />
    <ClInclude Include="Utils\Defs.h" />
    <ClInclude Include="Utils\HideImports.h" />
    <ClInclude Include="Utils\Utils.h" />
    <ClInclude Include="Utils\xorstr.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DLL/DLL.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Source Files\Utils">
      <UniqueIdentifier>{7481e039-ac24-4d1c-af20-369d17daa5c2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Hooks">
      <UniqueIdentifier>{8eff9ee3-e1a7-4db7-89ad-5b36f8e00a91}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Globals.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils\xorstr.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Defs.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\HideImports.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Hooks\Hooks.h">
      <Filter>Source Files\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Hooks\MinHook.h">
      <Filter>Source Files\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Utils.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DLL/DLL.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`DLL/Globals.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>
#include <intrin.h>
#include <stdio.h>
#include <cfloat>
#include <TlHelp32.h>
#include <cstdlib>
#include <stdint.h>
#include <Psapi.h>
#include <mutex>
#include <sstream>
#include <iostream>
#include <vector>
#include <Uxtheme.h>
#include <dwmapi.h>
#include <assert.h>
#include <fstream>
#include <ostream>
#include <wincrypt.h>
#include <wintrust.h>
#include <mscat.h>
#include <SoftPub.h>

#pragma comment(lib, "MinHook.x64.lib")
#pragma comment(lib, "wintrust")

const bool DebugEnabled = true;

#include "Utils/xorstr.h"
#include "Utils/Defs.h"
#include "Utils/HideImports.h"

#define printf(a, ...) if (DebugEnabled) printf(E(a), __VA_ARGS__)

#include "Utils/Utils.h"
#include "Hooks/MinHook.h"
#include "Hooks/Hooks.h"
```

`DLL/Hooks/Hooks.h`:

```h
#pragma once

namespace Hooks
{
	using def_LoadLibraryA = decltype(&LoadLibraryA);
    using def_LoadLibraryW = decltype(&LoadLibraryW);
    using def_LoadLibraryExA = decltype(&LoadLibraryExA);
    using def_LoadLibraryExW = decltype(&LoadLibraryExW);

	def_LoadLibraryA fn_LoadLibraryA = nullptr, o_LoadLibraryA = nullptr;
    def_LoadLibraryW fn_LoadLibraryW = nullptr, o_LoadLibraryW = nullptr;
    def_LoadLibraryExA fn_LoadLibraryExA = nullptr, o_LoadLibraryExA = nullptr;
    def_LoadLibraryExW fn_LoadLibraryExW = nullptr, o_LoadLibraryExW = nullptr;

    HMODULE hk_LoadLibraryA(LPCSTR lpLibFileName)
    {
        std::string sFileName = lpLibFileName;
        std::wstring wFileName = std::wstring(sFileName.begin(), sFileName.end());

        if (Utils::IsFileAllowed((wchar_t*)wFileName.c_str()))
        {
            printf("DLL %ws is allowed!\n", wFileName.c_str());
            return o_LoadLibraryA(lpLibFileName);
        }

        printf("DLL %ws is blocked!\n", wFileName.c_str());
		return (HMODULE)0;
	}

    HMODULE hk_LoadLibraryW(LPCWSTR lpLibFileName)
    {
        if (Utils::IsFileAllowed((wchar_t*)lpLibFileName))
        {
            printf("DLL %ws is allowed!\n", lpLibFileName);
            return o_LoadLibraryW(lpLibFileName);
        }

        printf("DLL %ws is blocked!\n", lpLibFileName);
        return (HMODULE)0;
    }

    HMODULE hk_LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        std::string sFileName = lpLibFileName;
        std::wstring wFileName = std::wstring(sFileName.begin(), sFileName.end());

        if (Utils::IsFileAllowed((wchar_t*)wFileName.c_str()))
        {
            printf("DLL %ws is allowed!\n", wFileName.c_str());
            return fn_LoadLibraryExA(lpLibFileName, hFile, dwFlags);
        }

        printf("DLL %ws is blocked!\n", wFileName.c_str());
        return (HMODULE)0;
    }

    HMODULE hk_LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        if (Utils::IsFileAllowed((wchar_t*)lpLibFileName))
        {
            printf("DLL %ws is allowed!\n", lpLibFileName);
            return o_LoadLibraryExW(lpLibFileName, hFile, dwFlags);
        }

        printf("DLL %ws is blocked!\n", lpLibFileName);
        return (HMODULE)0;
    }

	bool InitializeHooks()
	{
        uint64_t Kernel32 = GetModHandle(kernel32);

        fn_LoadLibraryA = (def_LoadLibraryA)GetProc(Kernel32, LoadLibraryA);
        fn_LoadLibraryW = (def_LoadLibraryW)GetProc(Kernel32, LoadLibraryW);
        fn_LoadLibraryExA = (def_LoadLibraryExA)GetProc(Kernel32, LoadLibraryExA);
        fn_LoadLibraryExW = (def_LoadLibraryExW)GetProc(Kernel32, LoadLibraryExW);

        printf("LoadLibraryA: 0x%llX\n", fn_LoadLibraryA);
        printf("LoadLibraryW: 0x%llX\n", fn_LoadLibraryW);
        printf("LoadLibraryExA: 0x%llX\n", fn_LoadLibraryExA);
        printf("LoadLibraryExW: 0x%llX\n", fn_LoadLibraryExW); 
  
        MH_CreateHook(fn_LoadLibraryA, hk_LoadLibraryA, reinterpret_cast<LPVOID*>(&o_LoadLibraryA));
        MH_EnableHook(fn_LoadLibraryA);

        MH_CreateHook(fn_LoadLibraryW, hk_LoadLibraryW, reinterpret_cast<LPVOID*>(&o_LoadLibraryW));
        MH_EnableHook(fn_LoadLibraryW);

        MH_CreateHook(fn_LoadLibraryExA, hk_LoadLibraryExA, reinterpret_cast<LPVOID*>(&o_LoadLibraryExA));
        MH_EnableHook(fn_LoadLibraryExA);

        MH_CreateHook(fn_LoadLibraryExW, hk_LoadLibraryExW, reinterpret_cast<LPVOID*>(&o_LoadLibraryExW));
        MH_EnableHook(fn_LoadLibraryExW);

		return true;
	}
}


/*    void* DetourFunction64(void* pSource, void* pDestination, int dwLen)
    {
        DWORD MinLen = 14;

        if (dwLen < MinLen) return NULL;

        BYTE stub[] =
        {
            0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, // jmp qword ptr [$+6]
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // ptr
        };

        void* pTrampoline = VirtualAlloc(0, dwLen + sizeof(stub), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

        DWORD dwOld = 0;
        VirtualProtect(pSource, dwLen, PAGE_EXECUTE_READWRITE, &dwOld);

        DWORD64 retto = (DWORD64)pSource + dwLen;

        memcpy(stub + 6, &retto, 8);
        memcpy((void*)((DWORD_PTR)pTrampoline), pSource, dwLen);
        memcpy((void*)((DWORD_PTR)pTrampoline + dwLen), stub, sizeof(stub));

        memcpy(stub + 6, &pDestination, 8);
        memcpy(pSource, stub, sizeof(stub));

        for (int i = MinLen; i < dwLen; i++)
        {
            *(BYTE*)((DWORD_PTR)pSource + i) = 0x90;
        }

        VirtualProtect(pSource, dwLen, dwOld, &dwOld);
        return (void*)((DWORD_PTR)pTrampoline);
    } */
```

`DLL/Hooks/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`DLL/Utils/Defs.h`:

```h
#pragma once

```

`DLL/Utils/HideImports.h`:

```h
#pragma once

NTSYSAPI ULONG NTAPI RtlRandomEx(PULONG Seed);
NTSYSAPI VOID NTAPI RtlExitUserProcess(NTSTATUS);
NTSYSAPI NTSTATUS NTAPI NtLoadDriver(PUNICODE_STRING);
NTSYSAPI NTSTATUS NTAPI NtUnloadDriver(PUNICODE_STRING);
extern "C" NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);
NTSYSAPI NTSTATUS NTAPI NtUnmapViewOfSection(HANDLE, PVOID);
NTSYSAPI NTSTATUS NTAPI LdrLoadDll(PWCHAR, PULONG, PUNICODE_STRING, PHANDLE);
NTSYSAPI NTSTATUS NTAPI RtlGetVersion(LPOSVERSIONINFOEXW);
NTSYSAPI PVOID NTAPI RtlImageDirectoryEntryToData(_In_ PVOID ImageBase, _In_ BOOLEAN MappedAsImage, _In_ USHORT DirectoryEntry, _Out_ PULONG Size);

uintptr_t GetNtDll()
{
	//get ntdll base
#if defined _M_IX86
	PPEB_LDR_DATA Ldr = ((PTEB)__readfsdword(FIELD_OFFSET(NT_TIB, Self)))->ProcessEnvironmentBlock->Ldr;
#elif defined _M_X64
	PPEB_LDR_DATA Ldr = ((PTEB)__readgsqword(FIELD_OFFSET(NT_TIB, Self)))->ProcessEnvironmentBlock->Ldr;
#endif

	//process modules
	for (PLIST_ENTRY CurEnt = Ldr->InMemoryOrderModuleList.Flink; CurEnt != &Ldr->InMemoryOrderModuleList; CurEnt = CurEnt->Flink) {
		PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(CurEnt, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
		if ((pEntry->BaseDllName.Length == 18) && (*(uint64_t*)pEntry->BaseDllName.Buffer == 0x6C00640074006E))
			return (uintptr_t)pEntry->DllBase;
	} return 0;
}
uintptr_t GetNtDll64_Export(const char* Name)
{
	//parse info
	static uintptr_t hNtDll = 0;
	static PIMAGE_EXPORT_DIRECTORY ExportDir = nullptr;
	if (!hNtDll) {
		hNtDll = GetNtDll();
		PIMAGE_NT_HEADERS NT_Head = (PIMAGE_NT_HEADERS)(hNtDll + ((PIMAGE_DOS_HEADER)hNtDll)->e_lfanew);
		ExportDir = (PIMAGE_EXPORT_DIRECTORY)(hNtDll + NT_Head->OptionalHeader.DataDirectory[0].VirtualAddress);
	}

	//process list
	for (uint32_t i = 0; i < ExportDir->NumberOfNames; i++)
	{
		//get ordinal & name
		uint16_t Ordinal = ((uint16_t*)(hNtDll + ExportDir->AddressOfNameOrdinals))[i];
		const char* ExpName = (const char*)hNtDll + ((uint32_t*)(hNtDll + ExportDir->AddressOfNames))[i];

		//check name
		for (int i = 0; ExpName[i] == Name[i]; i++) if (!ExpName[i])
			return hNtDll + ((uint32_t*)(hNtDll + ExportDir->AddressOfFunctions))[Ordinal];
	} return 0;
}

//LoadLibrary & GetProcAddr
uintptr_t LoadLibUnc(UNICODE_STRING Mod)
{
	typedef NTSTATUS(__stdcall* _LdrLoadDll)(PWCHAR, PULONG, PUNICODE_STRING, HMODULE*);
	static _LdrLoadDll LdrLoadDllFn = nullptr; HMODULE hMod;
	if (!LdrLoadDllFn) LdrLoadDllFn = (_LdrLoadDll)GetNtDll64_Export(xorstr_("LdrLoadDll"));
	LdrLoadDllFn(nullptr, nullptr, &Mod, &hMod); return (uintptr_t)hMod;
}
uintptr_t GetProcAddrAnsi(uintptr_t Mod, ANSI_STRING Func)
{
	typedef NTSTATUS(__stdcall* _LdrGetProcAddr)(HMODULE, PANSI_STRING, WORD, PVOID*);
	static _LdrGetProcAddr LdrGetProcAddr = nullptr; void* FuncAddr;
	if (!LdrGetProcAddr) LdrGetProcAddr = (_LdrGetProcAddr)GetNtDll64_Export(xorstr_("LdrGetProcedureAddress"));
	LdrGetProcAddr((HMODULE)Mod, &Func, 0, &FuncAddr); return (uintptr_t)FuncAddr;
}

//Secure Call Func
#define UNC_STR(a) { sizeof(a) - 2, sizeof(a), (PWSTR)xorstr_(a) }
#define ANS_STR(a) { sizeof(a) - 1, sizeof(a), (PCHAR)xorstr_(a) }

#define GetModHandle(Mod) LoadLibUnc({ sizeof(L#Mod) - 2, sizeof(L#Mod), (PWSTR)xorstr_(L#Mod) });
#define GetProc(Mod, Name) GetProcAddrAnsi(Mod, { sizeof(#Name) - 1, sizeof(#Name), (PCHAR)xorstr_(#Name) });

#define FC(Mod, Name, ...) [&](){ \
	static uintptr_t ModBase = 0; \
	if(!ModBase) \
		ModBase = LoadLibUnc({ sizeof(L#Mod) - 2, sizeof(L#Mod), (PWSTR)xorstr_(L#Mod) }); \
	static uintptr_t Func = 0; \
	if (!Func) \
		Func = GetProcAddrAnsi(ModBase, { sizeof(#Name) - 1, sizeof(#Name), (PCHAR)xorstr_(#Name) }); \
	using _OVar = decltype(&Name); \
	return _OVar(Func)(__VA_ARGS__); \
}()

#define FC_err(Mod, Name, Tmplt, ...) [&](){ \
	static uintptr_t ModBase = 0; \
	if(!ModBase) \
		ModBase = LoadLibUnc({ sizeof(L#Mod) - 2, sizeof(L#Mod), (PWSTR)xorstr_(L#Mod) }); \
	static uintptr_t Func = 0; \
	if (!Func) \
		Func = GetProcAddrAnsi(ModBase, { sizeof(#Name) - 1, sizeof(#Name), (PCHAR)xorstr_(#Name) }); \
	using _OVar = decltype(&Tmplt); \
	return _OVar(Func)(__VA_ARGS__); \
}()

char* __CRTDECL strstrFn(char* const _String, char const* const _SubString);
wchar_t* __cdecl wcsstrFn(const wchar_t* Str, const wchar_t* SubStr);
errno_t __cdecl wcscpy_sFn(wchar_t* Dst, rsize_t SizeInWords, const wchar_t* Src);

NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(
	HANDLE    ProcessHandle,
	PVOID* BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerResolution(



	IN ULONG                DesiredResolution,
	IN BOOLEAN              SetResolution,
	OUT PULONG              CurrentResolution);

//ntdll funcs
#define NtClose(a) FC(ntdll, NtClose, a)
#define strlen(a) FC(ntdll, strlen, a)
#define strstr(...) FC_err(ntdll, strstr, strstrFn, __VA_ARGS__)
#define memset(a, b) FC(ntdll, memset, a, 0, b)
#define memcpy(...) FC(ntdll, memcpy, __VA_ARGS__)
#define wcscat(...) FC(ntdll, wcscat, __VA_ARGS__)
#define wcscpy(a, b) FC(ntdll, wcscpy, a, b)
#define NtDeviceIoControlFile(...) FC(ntdll, NtDeviceIoControlFile, __VA_ARGS__)
#define wcscpy_s(...) FC_err(ntdll, wcscpy_s, wcscpy_sFn, __VA_ARGS__)
#define wcslen(...) FC(ntdll, wcslen, __VA_ARGS__)
#define RtlGetVersion(a) FC(ntdll, RtlGetVersion, a)
#define ExitProcess() FC(ntdll, RtlExitUserProcess, 0)
#define NtOpenFile(...) FC(ntdll, NtOpenFile, __VA_ARGS__)
#define NtQuerySystemInformation(...) FC(ntdll, NtQuerySystemInformation, __VA_ARGS__)
#define NtSetTimerResolution(...) FC(ntdll, NtSetTimerResolution, __VA_ARGS__)
#define RtlImageDirectoryEntryToData(...) FC(ntdll, RtlImageDirectoryEntryToData, __VA_ARGS__)

//Shell32 funcs
#define CommandLineToArgvW(a, b) FC(shell32, CommandLineToArgvW, a, b)

//Kernel32 funcs
#define Sleep(a) FC(kernel32, Sleep, a)
#define LocalFree(a) FC(kernel32, LocalFree, a)
#define GetModuleFileNameW(...) FC(kernel32, GetModuleFileNameW, __VA_ARGS__)
#define GetModuleHandleW(...) FC(kernel32, GetModuleHandleW, __VA_ARGS__)
#define VirtualQuery(...) FC(kernel32, VirtualQuery, __VA_ARGS__)
#define FreeLibrary(a) FC(kernel32, FreeLibrary, a)
#define GetCommandLineW() FC(kernel32, GetCommandLineW)
#define LoadLibraryA(a) FC(kernel32, LoadLibraryA, a)
#define GetConsoleWindow() FC(kernel32, GetConsoleWindow)
#define ReadFile(...) FC(kernel32, ReadFile, __VA_ARGS__)
#define WriteFile(...) FC(kernel32, WriteFile, __VA_ARGS__)
#define free(a) FC(kernel32, VirtualFree, a, 0, MEM_RELEASE)
#define SetConsoleTitleW(a) FC(kernel32, SetConsoleTitleW, a)
#define MoveFileExW(...) FC(kernel32, MoveFileExW, __VA_ARGS__)
#define CreateFileW(...) FC(kernel32, CreateFileW, __VA_ARGS__)
#define CloseHandle(...) FC(kernel32, CloseHandle, __VA_ARGS__)
#define DeleteFileW(...) FC(kernel32, DeleteFileW, __VA_ARGS__)
#define GetFileSize(...) FC(kernel32, GetFileSize, __VA_ARGS__)
#define GetCurrentProcessId() FC(kernel32, GetCurrentProcessId)
#define GetTempPathW(...) FC(kernel32, GetTempPathW, __VA_ARGS__)
#define MapViewOfFile(...) FC(kernel32, MapViewOfFile, __VA_ARGS__)
#define WriteConsoleA(...) FC(kernel32, WriteConsoleA, __VA_ARGS__)
#define GetConsoleOutHandle() FC(kernel32, GetStdHandle, STD_OUTPUT_HANDLE);
#define DeviceIoControl(...) FC(kernel32, DeviceIoControl, __VA_ARGS__)
#define UnmapViewOfFile(...) FC(kernel32, UnmapViewOfFile, __VA_ARGS__)
//#define LoadLibraryExA(a, b) FC(kernel32, LoadLibraryExA, a, nullptr, b)
#define CreateFileMappingA(...) FC(kernel32, CreateFileMappingA, __VA_ARGS__)
#define GetProcAddress(...) (uintptr_t)FC(kernel32, GetProcAddress, __VA_ARGS__)
#define SetConsoleTextAttribute(...) FC(kernel32, SetConsoleTextAttribute, __VA_ARGS__)
#define GetConsoleScreenBufferInfo(...) FC(kernel32, GetConsoleScreenBufferInfo, __VA_ARGS__)
#define malloc(a) FC(kernel32, VirtualAlloc, nullptr, a, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
#define Wow64DisableWow64FsRedirection(...) FC(kernel32, Wow64DisableWow64FsRedirection, __VA_ARGS__)
#define Wow64RevertWow64FsRedirection(...) FC(kernel32, Wow64RevertWow64FsRedirection, __VA_ARGS__)
#define GetFileSize(...) FC(kernel32, GetFileSize, __VA_ARGS__)
#define IsBadReadPtr(...) FC(kernel32, IsBadReadPtr, __VA_ARGS__)
#define CreateProcessW(...) FC(kernel32, CreateProcessW, __VA_ARGS__)
#define CreateThread(...) FC(kernel32, CreateThread, __VA_ARGS__)
#define GetProcessId(...) FC(kernel32, GetProcessId, __VA_ARGS__)

//Advapi32 funcs
#define RegOpenKeyA(...) FC(advapi32, RegOpenKeyA, __VA_ARGS__)
#define RegCloseKey(...) FC(advapi32, RegCloseKey, __VA_ARGS__)
#define RegCreateKeyW(...) FC(advapi32, RegCreateKeyW, __VA_ARGS__)
#define RegDeleteKeyW(...) FC(advapi32, RegDeleteKeyW, __VA_ARGS__)
#define RegSetValueExA(...) FC(advapi32, RegSetValueExA, __VA_ARGS__)
#define RegSetValueExW(...) FC(advapi32, RegSetValueExW, __VA_ARGS__)
#define OpenProcessToken(...) FC(advapi32, OpenProcessToken, __VA_ARGS__)
#define LookupPrivilegeValueA(...) FC(advapi32, LookupPrivilegeValueA, __VA_ARGS__)
#define AdjustTokenPrivileges(...) FC(advapi32, AdjustTokenPrivileges, __VA_ARGS__)
#define CryptCreateHash(...) FC(advapi32, CryptCreateHash, __VA_ARGS__)
#define CryptHashData(...) FC(advapi32, CryptHashData, __VA_ARGS__)
#define CryptGetHashParam(...) FC(advapi32, CryptGetHashParam, __VA_ARGS__)
#define CryptDestroyHash(...) FC(advapi32, CryptDestroyHash, __VA_ARGS__)
#define CryptReleaseContext(...) FC(advapi32, CryptReleaseContext, __VA_ARGS__)

//Crypt32 funcs
#define CertFindCertificateInStore(...) FC(crypt32, CertFindCertificateInStore, __VA_ARGS__)
#define CryptMsgGetParam(...) FC(crypt32, CryptMsgGetParam, __VA_ARGS__)
#define CryptQueryObject(...) FC(crypt32, CryptQueryObject, __VA_ARGS__)
#define CertGetNameStringW(...) FC(crypt32, CertGetNameStringW, __VA_ARGS__)
#define CertFreeCertificateContext(...) FC(crypt32, CertFreeCertificateContext, __VA_ARGS__)
#define CertCloseStore(...) FC(crypt32, CertCloseStore, __VA_ARGS__)
#define CryptMsgClose(...) FC(crypt32, CryptMsgClose, __VA_ARGS__)

//User32 funcs
#define FindWindowW(...) FC(user32, FindWindowW, __VA_ARGS__)
#define EnableWindow(...) FC(user32, EnableWindow, __VA_ARGS__)
#define SetWindowsHookExW(...) FC(user32, SetWindowsHookExW, __VA_ARGS__)
#define UnhookWindowsHookEx(...) FC(user32, UnhookWindowsHookEx, __VA_ARGS__)
#define PostThreadMessageW(...) FC(user32, PostThreadMessageW, __VA_ARGS__)
#define GetWindowThreadProcessId(...) FC(user32, GetWindowThreadProcessId, __VA_ARGS__)

//FltLib funcs
#define FltSendMessage(...) FC(FltLib, FilterSendMessage, __VA_ARGS__)
#define FltGetMessage(...) FC(FltLib, FilterGetMessage, __VA_ARGS__)
#define FltConnectCommunicationPort(...) FC(FltLib, FilterConnectCommunicationPort, __VA_ARGS__)
#define FltReplyMessage(...) FC(FltLib, FilterReplyMessage, __VA_ARGS__)

//wintrust funcs
#define CryptCATAdminAcquireContext(...) FC(wintrust, CryptCATAdminAcquireContext, __VA_ARGS__)
#define CryptCATAdminCalcHashFromFileHandle(...) FC(wintrust, CryptCATAdminCalcHashFromFileHandle, __VA_ARGS__)
#define CryptCATAdminEnumCatalogFromHash(...) FC(wintrust, CryptCATAdminEnumCatalogFromHash, __VA_ARGS__)
#define CryptCATCatalogInfoFromContext(...) FC(wintrust, CryptCATCatalogInfoFromContext, __VA_ARGS__)
#define WinVerifyTrust(...) FC(wintrust, WinVerifyTrust, __VA_ARGS__)
#define CryptCATAdminReleaseCatalogContext(...) FC(wintrust, CryptCATAdminReleaseCatalogContext, __VA_ARGS__)
#define CryptCATAdminReleaseContext(...) FC(wintrust, CryptCATAdminReleaseContext, __VA_ARGS__)

uint32_t getRand()
{
	uint32_t seed = (uint32_t)__rdtsc();
	return FC(ntdll, RtlRandomEx, (PULONG)&seed);
}

//inline funcs
#define SizeAlign(a) ((a + 4095) & 0xFFFFF000)

void toWchar(wchar_t* Dst, const char* Str)
{
	for (;; Str++, Dst++)
	{
		char Tmp = *Str;
		*Dst = Tmp;
		if (!Tmp)
			break;
	}
}

void toChar(char* Dst, const wchar_t* Str)
{
	for (;; Str++, Dst++)
	{
		wchar_t Tmp = *Str;
		*Dst = (char)Tmp;
		if (!Tmp)
			break;
	}
}
```

`DLL/Utils/Utils.h`:

```h
#pragma once

namespace Utils
{
#define SafeDeleteArraySize(pData) { if(pData){delete []pData;pData=NULL;} }

	bool RedirectionCreateFile(const wchar_t* FilePath, HANDLE& hFile)
	{
		bool Ret = false;

		if (!FilePath)
			return Ret;

		PVOID OldVal = NULL;
		bool Val = Wow64DisableWow64FsRedirection(&OldVal);

		hFile = CreateFileW(FilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
			return true;

		OldVal = NULL;

		if (Val)
			Wow64RevertWow64FsRedirection(&OldVal);

		return Val;
	}

	wchar_t* GetCertName(const wchar_t* FilePath)
	{
		CERT_INFO CertInfo;
		memset(&CertInfo, sizeof(CertInfo));

		if (IsBadReadPtr(FilePath, sizeof(DWORD)))
			return NULL;

		wchar_t* CertName = NULL;
		PCCERT_CONTEXT pCertContext = NULL;
		HCERTSTORE hStore = NULL;
		HCRYPTMSG hMsg = NULL;

		do
		{
			DWORD NumberOfBytesRead = 0;
			HANDLE hFile = INVALID_HANDLE_VALUE;

			if (!RedirectionCreateFile(FilePath, hFile))
				break;

			DWORD FileSize = GetFileSize(hFile, NULL);
			BYTE* pBuff = new BYTE[FileSize + 1];

			if (!pBuff)
				break;

			RtlZeroMemory(pBuff, FileSize + 1);

			BOOL Status = ReadFile(hFile, pBuff, FileSize, &NumberOfBytesRead, NULL);
			CloseHandle(hFile);

			if (!Status)
				break;

			CERT_BLOB Object = { 0 };
			Object.cbData = FileSize;
			Object.pbData = pBuff;

			DWORD dwEncoding = 0, dwContentType = 0, dwFormatType = 0;

			Status = CryptQueryObject(CERT_QUERY_OBJECT_FILE, FilePath, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0, &dwEncoding, &dwContentType, &dwFormatType, &hStore, &hMsg, NULL);

			if (!Status)
			{
				PVOID OldVal = 0;
				BOOL IsDisabled = Wow64DisableWow64FsRedirection(&OldVal);
				OldVal = 0;

				Status = CryptQueryObject(CERT_QUERY_OBJECT_FILE, FilePath, CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED, CERT_QUERY_FORMAT_FLAG_BINARY, 0, &dwEncoding, &dwContentType, &dwFormatType, &hStore, &hMsg, NULL);

				if (Status)
					Wow64RevertWow64FsRedirection(&OldVal);

				if (!Status)
					break;
			}

			DWORD dwSignerInfo = 0;
			Status = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, NULL, &dwSignerInfo);

			if (!Status)
				break;

			PCMSG_SIGNER_INFO pSignerInfo = (PCMSG_SIGNER_INFO)new char[dwSignerInfo];

			if (!pSignerInfo)
				break;

			ZeroMemory(pSignerInfo, dwSignerInfo);

			Status = CryptMsgGetParam(hMsg, CMSG_SIGNER_INFO_PARAM, 0, (PVOID)pSignerInfo, &dwSignerInfo);

			if (!Status)
				break;

			CertInfo.Issuer = pSignerInfo->Issuer;
			CertInfo.SerialNumber = pSignerInfo->SerialNumber;

			pCertContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_CERT, (PVOID)&CertInfo, NULL);

			if (!pCertContext)
				break;

			DWORD dwData = CertGetNameStringW(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, NULL, 0);
			if (1 >= dwData)
				break;

			CertName = new wchar_t[dwData + 1];

			if (!CertName)
				break;

			ZeroMemory(CertName, (dwData + 1) * sizeof(wchar_t));

			if (!(CertGetNameStringW(pCertContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, CertName, dwData)))
				break;

		} while (false);

		if (pCertContext != NULL)
			CertFreeCertificateContext(pCertContext);

		if (hStore != NULL)
			CertCloseStore(hStore, 0);

		if (hMsg != NULL)
			CryptMsgClose(hMsg);

		return CertName;
	}

	wchar_t* GetFileCat(wchar_t* lpFileName)
	{
		WINTRUST_DATA wd = { 0 };
		WINTRUST_FILE_INFO wfi = { 0 };
		WINTRUST_CATALOG_INFO wci = { 0 };
		CATALOG_INFO ci = { 0 };
		HCATADMIN hCatAdmin = NULL;
		HANDLE hFile = INVALID_HANDLE_VALUE;
		DWORD dwCnt = 0;
		PBYTE pbyHash = NULL;
		wchar_t* pszMemberTag = NULL;
		HCATINFO hCatInfo = NULL;
		HRESULT hr;
		static GUID action = WINTRUST_ACTION_GENERIC_VERIFY_V2;
		const GUID gSubsystem = DRIVER_ACTION_VERIFY;
		wchar_t* pCatalogFile = NULL;

		do
		{

			if (!CryptCATAdminAcquireContext(&hCatAdmin, &gSubsystem, 0))
				break;

			if (!RedirectionCreateFile(lpFileName, hFile))
				break;

			if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwCnt, pbyHash, 0) && dwCnt > 0 && ERROR_INSUFFICIENT_BUFFER == GetLastError())
			{
				pbyHash = new BYTE[dwCnt];
				ZeroMemory(pbyHash, dwCnt);
				if (CryptCATAdminCalcHashFromFileHandle(hFile, &dwCnt, pbyHash, 0) == FALSE)
				{
					CloseHandle(hFile);
					break;
				}
			}
			else
			{
				CloseHandle(hFile);
				break;
			}

			CloseHandle(hFile);

			hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, pbyHash, dwCnt, 0, NULL);

			if (NULL == hCatInfo)
			{
				wfi.cbStruct = sizeof(WINTRUST_FILE_INFO);
				wfi.pcwszFilePath = lpFileName;
				wfi.hFile = NULL;
				wfi.pgKnownSubject = NULL;
				wd.cbStruct = sizeof(WINTRUST_DATA);
				wd.dwUnionChoice = WTD_CHOICE_FILE;
				wd.pFile = &wfi;
				wd.dwUIChoice = WTD_UI_NONE;
				wd.fdwRevocationChecks = WTD_REVOKE_NONE;
				wd.dwStateAction = WTD_STATEACTION_IGNORE;
				wd.dwProvFlags = WTD_SAFER_FLAG;
				wd.hWVTStateData = NULL;
				wd.pwszURLReference = NULL;
			}
			else
			{
				if (CryptCATCatalogInfoFromContext(hCatInfo, &ci, 0))
				{
					pszMemberTag = new wchar_t[dwCnt * 2 + 1];
					ZeroMemory(pszMemberTag, (dwCnt * 2 + 1) * sizeof(wchar_t));

					for (DWORD dw = 0; dw < dwCnt; ++dw)
						wsprintfW(&pszMemberTag[dw * 2], L"%02X", pbyHash[dw]);

					wci.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
					wci.pcwszCatalogFilePath = ci.wszCatalogFile;
					wci.pcwszMemberFilePath = lpFileName;
					wci.pcwszMemberTag = pszMemberTag;

					wd.cbStruct = sizeof(WINTRUST_DATA);
					wd.pCatalog = &wci;
					wd.dwUIChoice = WTD_UI_NONE;
					wd.dwUnionChoice = WTD_CHOICE_CATALOG;
					wd.fdwRevocationChecks = WTD_STATEACTION_VERIFY;
					wd.dwStateAction = WTD_STATEACTION_VERIFY;
					wd.dwProvFlags = 0;
					wd.hWVTStateData = NULL;
					wd.pwszURLReference = NULL;

				}
			}

			hr = WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &action, &wd);

			if (SUCCEEDED(hr) || wcslen(ci.wszCatalogFile) > 0)
			{
				pCatalogFile = new wchar_t[MAX_PATH];
				ZeroMemory(pCatalogFile, MAX_PATH * sizeof(wchar_t));
				CopyMemory(pCatalogFile, ci.wszCatalogFile, wcslen(ci.wszCatalogFile) * sizeof(wchar_t));
			}

			if (NULL != hCatInfo)
				CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);


		} while (FALSE);


		if (hCatAdmin)
			CryptCATAdminReleaseContext(hCatAdmin, 0);

		SafeDeleteArraySize(pbyHash);
		SafeDeleteArraySize(pszMemberTag);
		return pCatalogFile;
	}

	wchar_t* GetFileCertName(wchar_t* pFilePath)
	{
		wchar_t* pCertName = NULL;
		wchar_t* pCatFilePath = NULL;

		pCertName = GetCertName(pFilePath);

		if (pCertName == NULL)
		{
			pCatFilePath = GetFileCat(pFilePath);

			if (pCatFilePath)
				pCertName = GetCertName(pCatFilePath);
		}

		SafeDeleteArraySize(pCatFilePath);
		return pCertName;
	}

	bool IsFileAllowed(wchar_t* pFilePath)
	{
		HANDLE hFile = NULL;

		if (!RedirectionCreateFile(pFilePath, hFile))
			return false;

		if (GetFileCertName(pFilePath) == NULL)
			return false;

		return true;
	}
}
```

`DLL/Utils/xorstr.h`:

```h

#pragma once
#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>

#define xorstr(str)                                              \
    ::jm::make_xorstr(                                           \
        []() { return str; },                                    \
        std::make_index_sequence<sizeof(str) / sizeof(*str)>{},  \
        std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()
#define E(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

// you can define this macro to get possibly faster code on gcc/clang
// at the expense of constants being put into data section.
#if !defined(XORSTR_ALLOW_DATA)
// MSVC - no volatile
// GCC and clang - volatile everywhere
#if defined(__clang__) || defined(__GNUC__)
#define XORSTR_VOLATILE volatile
#endif

#endif
#ifndef XORSTR_VOLATILE
#define XORSTR_VOLATILE
#endif

namespace jm {

    namespace detail {

        template<std::size_t S>
        struct unsigned_;

        template<>
        struct unsigned_<1> {
            using type = std::uint8_t;
        };
        template<>
        struct unsigned_<2> {
            using type = std::uint16_t;
        };
        template<>
        struct unsigned_<4> {
            using type = std::uint32_t;
        };

        template<auto C, auto...>
        struct pack_value_type {
            using type = decltype(C);
        };

        template<std::size_t Size>
        constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<auto... Cs>
        struct tstring_ {
            using value_type = typename pack_value_type<Cs...>::type;
            constexpr static std::size_t size = sizeof...(Cs);
            constexpr static value_type  str[size] = { Cs... };

            constexpr static std::size_t buffer_size = _buffer_size<sizeof(str)>();
            constexpr static std::size_t buffer_align =
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            ((sizeof(str) > 16) ? 32 : 16);
#else
                16;
#endif
        };

        template<std::size_t I, std::uint64_t K>
        struct _ki {
            constexpr static std::size_t   idx = I;
            constexpr static std::uint64_t key = K;
        };

        template<std::uint32_t Seed>
        constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for (char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        constexpr std::uint64_t key8()
        {
            constexpr auto first_part = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T, std::uint64_t... Keys>
        struct string_storage {
            std::uint64_t storage[T::buffer_size];

            XORSTR_FORCEINLINE constexpr string_storage() noexcept : storage{ Keys... }
            {
                using cast_type =
                    typename unsigned_<sizeof(typename T::value_type)>::type;
                constexpr auto value_size = sizeof(typename T::value_type);
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / value_size)] ^=
                    (std::uint64_t{ static_cast<cast_type>(T::str[i]) }
                << ((i % (8 / value_size)) * 8 * value_size));
            }
        };

    } // namespace detail

    template<class T, class... Keys>
    class xor_string {
        alignas(T::buffer_align) std::uint64_t _storage[T::buffer_size];

        // _single functions needed because MSVC crashes without them
        XORSTR_FORCEINLINE void _crypt_256_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept

        {
            _mm256_store_si256(
                reinterpret_cast<__m256i*>(storage),
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(storage)),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_256(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept
        {
            (_crypt_256_single(keys + Idxs * 4, _storage + Idxs * 4), ...);
        }

        XORSTR_FORCEINLINE void _crypt_128_single(const std::uint64_t* keys,
            std::uint64_t* storage) noexcept
        {
            _mm_store_si128(
                reinterpret_cast<__m128i*>(storage),
                _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(storage)),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(keys))));
        }

        template<std::size_t... Idxs>
        XORSTR_FORCEINLINE void _crypt_128(const std::uint64_t* keys,
            std::index_sequence<Idxs...>) noexcept
        {
            (_crypt_128_single(keys + Idxs * 2, _storage + Idxs * 2), ...);
        }

        // loop generates vectorized code which places constants in data dir
        XORSTR_FORCEINLINE constexpr void _copy() noexcept
        {
            constexpr detail::string_storage<T, Keys::key...> storage;
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(_storage))[Keys::idx] =
                    storage.storage[Keys::idx]... });
        }

    public:
        using value_type = typename T::value_type;
        using size_type = std::size_t;
        using pointer = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept { _copy(); }

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return T::size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
            alignas(T::buffer_align) std::uint64_t keys[T::buffer_size];
            static_cast<void>(std::initializer_list<std::uint64_t>{
                (const_cast<XORSTR_VOLATILE std::uint64_t*>(keys))[Keys::idx] =
                    Keys::key... });

            _copy();

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
            _crypt_256(keys, std::make_index_sequence<T::buffer_size / 4>{});
            if constexpr (T::buffer_size % 4 != 0)
                _crypt_128(keys, std::index_sequence<T::buffer_size / 2 - 1>{});
#else
            _crypt_128(keys, std::make_index_sequence<T::buffer_size / 2>{});
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
        {
            crypt();
            return reinterpret_cast<const_pointer>(_storage);
        }
    };

    template<class Tstr, std::size_t... StringIndices, std::size_t... KeyIndices>
    XORSTR_FORCEINLINE constexpr auto
        make_xorstr(Tstr str_lambda,
            std::index_sequence<StringIndices...>,
            std::index_sequence<KeyIndices...>) noexcept
    {
        return xor_string<detail::tstring_<str_lambda()[StringIndices]...>,
            detail::_ki<KeyIndices, detail::key8<KeyIndices>()>...>{};
    }

} // namespace jm

#endif // include guard
```

`DLL/dllmain.cpp`:

```cpp

#include "Globals.h"

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
        {
            std::cout << E("Hello from dll\n");
            MH_Initialize();

            DisableThreadLibraryCalls(hModule);

            Hooks::InitializeHooks();

        } break;

//    case DLL_THREAD_ATTACH:
 //   case DLL_THREAD_DETACH:

        case DLL_PROCESS_DETACH:
        {
            
        } break;

        default:
            break;
    }
    return TRUE;
}


```

`Driver/Callbacks/Callbacks.h`:

```h
#pragma once

namespace Callbacks
{
	PVOID hRegistration = NULL;

	VOID LoadImageNotifyRoutine(PUNICODE_STRING FullImageName, HANDLE ProcessID, PIMAGE_INFO ImageInfo)
	{
		UNREFERENCED_PARAMETER(ImageInfo);

		if (ImpCall(wcsstr, FullImageName->Buffer, skCrypt(L"\\ProtectionTest.exe")))
		{
			const BYTE DigestBuffer[] = { 0x83, 0x65, 0x52, 0x4F, 0x61, 0x49, 0xA3, 0x34, 0xD7, 0xF5, 0x6C, 0xE1, 0x16, 0xBF, 0xA1, 0xC1, 0x2E, 0x87, 0xE2, 0x64 };

			if (Utils::AuthenticateApplication(FullImageName, (PVOID)DigestBuffer, 1))
			{
				GamePID = (uint32_t)ProcessID;
				Log("\n");
			}
		}
	}

	OB_PREOP_CALLBACK_STATUS PreObCallback(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
	{
		UNREFERENCED_PARAMETER(RegistrationContext);
		PEPROCESS OpenedProcess = (PEPROCESS)OperationInformation->Object;

		if (GamePID < 1)
			return OB_PREOP_SUCCESS;

		if (OperationInformation->KernelHandle)
			return OB_PREOP_SUCCESS;

		if ((int)ImpCall(PsGetCurrentProcessId) == GamePID)
			return OB_PREOP_SUCCESS;

		if (ImpCall(PsIsSystemProcess, OpenedProcess) || ImpCall(PsIsProtectedProcess, OpenedProcess))
			return OB_PREOP_SUCCESS;

		uint32_t RequestPID = (uint32_t)ImpCall(PsGetProcessId, (PEPROCESS)OperationInformation->Object);

		if (RequestPID == GamePID)
		{
			if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE || OperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
			{
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_TERMINATE) == PROCESS_TERMINATE)
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_TERMINATE;
			
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_OPERATION) == PROCESS_VM_OPERATION)
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
			
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_READ) == PROCESS_VM_READ)
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_READ;
			
				if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_WRITE) == PROCESS_VM_WRITE)
					OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
			}
		}

		return OB_PREOP_SUCCESS;
	}

	NTSTATUS RegisterCallbacks(PDRIVER_OBJECT pDrv)
	{
		NTSTATUS Status = STATUS_UNSUCCESSFUL;

		PKLDR_DATA_TABLE_ENTRY Entry = (PKLDR_DATA_TABLE_ENTRY)pDrv->DriverSection;
		Entry->Flags |= 0x20;

		Status = ImpCall(PsSetLoadImageNotifyRoutine, LoadImageNotifyRoutine);

		if (!NT_SUCCESS(Status))
			return Status;

		OB_CALLBACK_REGISTRATION obRegistration = { 0, };
		OB_OPERATION_REGISTRATION opRegistration = { 0, };

		obRegistration.Version = ImpCall(ObGetFilterVersion);
		obRegistration.OperationRegistrationCount = 1;
		ImpCall(RtlInitUnicodeString, &obRegistration.Altitude, L"320070");
		obRegistration.RegistrationContext = NULL;

		opRegistration.ObjectType = PsProcessType;
		opRegistration.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
		opRegistration.PreOperation = PreObCallback;
		opRegistration.PostOperation = NULL;
		obRegistration.OperationRegistration = &opRegistration;

		Status = ImpCall(ObRegisterCallbacks, &obRegistration, &hRegistration);

		if (!NT_SUCCESS(Status))
		{
			if (hRegistration)
				ImpCall(ObUnRegisterCallbacks, hRegistration);

			Log("Failed to register PreObCallback: 0x%llX\n", Status);
		}

		return Status;
	}

	VOID UnregisterCallbacks()
	{
		ImpCall(PsRemoveLoadImageNotifyRoutine, LoadImageNotifyRoutine);

		if (hRegistration)
			ImpCall(ObUnRegisterCallbacks, hRegistration);
	}
}
```

`Driver/Communication/IO_Handler.h`:

```h
#pragma once

NTSTATUS IO_Handler(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS Status = STATUS_SUCCESS;
	ULONG Bytes = 0;

	PIO_STACK_LOCATION IO = ImpCall(IoGetCurrentIrpStackLocation, Irp);

	uint32_t CurrentPID = (uint32_t)ImpCall(PsGetCurrentProcessId);

	if (CurrentPID == GamePID || CurrentPID == ClientPID)
	{
		switch (IO->Parameters.DeviceIoControl.IoControlCode)
		{
			case IO_GETSTATUS:
			{
				pIO_GetStatus Struct = (pIO_GetStatus)Irp->AssociatedIrp.SystemBuffer;
				Bytes = sizeof(IO_GetStatus);

				Struct->Recv = Struct->Send * 2;

			} break;

			case IO_SENDOFFSETS:
			{
				pIO_SendOffsets Struct = (pIO_SendOffsets)Irp->AssociatedIrp.SystemBuffer;
				Bytes = sizeof(IO_SendOffsets);

				KeResumeThreadOffset = Struct->KeResumeThread;
				KeSuspendThreadOffset = Struct->KeSuspendThread;

			} break;

			case IO_SCANDETECTIONS:
			{
				PSCAN_RESULTS Struct = (PSCAN_RESULTS)Irp->AssociatedIrp.SystemBuffer;
				Bytes = sizeof(SCAN_RESULTS);

				ImpCall(RtlSecureZeroMemory, &Detections::ScanResults, sizeof(SCAN_RESULTS));

				Detections::ScanSystemThreads();
				Detections::ValidateDispatches();

				/*We don't need to use ntoskrnl.exe's memcpy import cause VisualStudio uses it's own API for mem funcs*/
				memcpy(Struct, &Detections::ScanResults, sizeof(SCAN_RESULTS));

			} break;

			default:
				break;
		}
	}

	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = Bytes;
	ImpCall(IofCompleteRequest, Irp, IO_NO_INCREMENT);

	return Status;
}


```

`Driver/Detections/Detections.h`:

```h
#pragma once

namespace Detections
{
	SCAN_RESULTS ScanResults = { 0 };

	void ScanSystemThreads()
	{
		PRTL_PROCESS_MODULES pModList = (PRTL_PROCESS_MODULES)Utils::GetDriversList();

		if (!pModList)
		{
			Log("Failed to retrieve Modules List\n");
			return;
		}

		for (ULONG ThreadID = 4; ThreadID < 0x30000; ThreadID += 4)
		{
			PETHREAD pThread = 0;

			if (!NT_SUCCESS(ImpCall(PsLookupThreadByThreadId, reinterpret_cast<HANDLE>(ThreadID), &pThread)))
				continue;

			if (ImpCall(KeGetCurrentThread) == pThread || !ImpCall(PsIsSystemThread, pThread))
				continue;

			uint64_t StartAddress = Utils::GetThreadStartAddress(pThread);

			if (!Utils::IsAddressInDriversList(StartAddress, pModList))
			{
				Log("Thread StartAddress out of legit drivers! pETHREAD: 0x%llX, Address: 0x%llX\n", pThread, StartAddress);
				ScanResults.InvalidThreads++;
			}

			if (StartAddress && !memcmp((PVOID)StartAddress, "\xFF\xE1", 2))
			{
				Log("Thread StartAddress trampoline detected! pETHREAD: 0x%llX\n", pThread);
				ScanResults.TrampolineThreads++;
			}

			StackWalkList WalkResults[0x20];
			RtlZeroMemory(&WalkResults[0], sizeof(WalkResults));

			Utils::StackWalkThread(pThread, &WalkResults[0]);

			bool IsStackAdded = false;

			for (int i = 0; i < 0x20; i++)
			{
				if (WalkResults[i].Rsp == 0)
					break;

				if (!Utils::IsAddressInDriversList(WalkResults[i].Rip, pModList))
				{
					Log("Thread stack out of legit drivers!\n");
					bool IsStackInvalid = false;
					Utils::ScanBigPool(WalkResults[i].Rip, &IsStackInvalid);

					if (IsStackInvalid && !IsStackAdded)
					{
						ScanResults.InvalidStacks++;
						IsStackAdded = true;
					}
				}
			} 
		}

		ImpCall(ExFreePoolWithTag, pModList, 0);
	}

	void ValidateDispatches()
	{
		HANDLE hDir = NULL;
		UNICODE_STRING DriverString;
		OBJECT_ATTRIBUTES ObjAttr;
		PVOID Object;

		ImpCall(RtlInitUnicodeString, &DriverString, L"\\Driver");
		InitializeObjectAttributes(&ObjAttr, &DriverString, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

		if (!NT_SUCCESS(ImpCall(ZwOpenDirectoryObject, &hDir, DIRECTORY_QUERY, &ObjAttr)))
		{
			Log("Failed to open \\Driver directory\n");
			return;
		}

		if (!NT_SUCCESS(ImpCall(ObReferenceObjectByHandle, hDir, DIRECTORY_QUERY, nullptr, KernelMode, &Object, nullptr)))
		{
			Log("Failed to reference \\Driver directory\n");
			return;
		}

		ImpCall(ZwClose, hDir);

		POBJECT_TYPE ObjType = ImpCall(ObGetObjectType, Object);
		ImpCall(ObfDereferenceObject, Object);
		
		HANDLE hObj = NULL;

		if (!NT_SUCCESS(ImpCall(ObOpenObjectByName, &ObjAttr, ObjType, KernelMode, NULL, DIRECTORY_QUERY, nullptr, &hObj)))
		{
			Log("Failed to open object!\n");
			return;
		}

		PRTL_PROCESS_MODULES pModList = (PRTL_PROCESS_MODULES)Utils::GetDriversList();

		PDIRECTORY_BASIC_INFORMATION DirInfo = (PDIRECTORY_BASIC_INFORMATION)ImpCall(ExAllocatePool, NonPagedPool, PAGE_SIZE);
		ULONG Ctx = 0, RetBytes = 0;

		while (NT_SUCCESS(ImpCall(ZwQueryDirectoryObject, hObj, DirInfo, PAGE_SIZE, TRUE, FALSE, &Ctx, &RetBytes)))
		{
			PDRIVER_OBJECT pDrv;
			UNICODE_STRING ObjName;

			wchar_t wsDriverName[100] = L"\\Driver\\";
			wcscat(wsDriverName, DirInfo->ObjectName.Buffer);

			ObjName.Length = ObjName.MaximumLength = wcslen(wsDriverName) * 2;
			ObjName.Buffer = wsDriverName;

			if (NT_SUCCESS(ImpCall(ObReferenceObjectByName, &ObjName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
				NULL, NULL, *IoDriverObjectType, KernelMode, nullptr, (PVOID*)&pDrv)))
			{
				if (!Utils::IsAddressInDriversList(reinterpret_cast<uint64_t>(pDrv->MajorFunction[IRP_MJ_DEVICE_CONTROL]), pModList))
				{
					Log("Dispatch of driver %wZ is hijacked: 0x%llX\n", pDrv->DriverName,
						reinterpret_cast<uint64_t>(pDrv->MajorFunction[IRP_MJ_DEVICE_CONTROL]));
					ScanResults.InvalidDispatches++;
				}

				if (!Utils::IsAddressInDriversList(reinterpret_cast<uint64_t>(pDrv->DriverStart), pModList))
				{
					Log("Driver start of driver %wZ is hijacked!\n", pDrv->DriverName);
					ScanResults.InvalidDispatches++;
				}

				if (!Utils::IsAddressInDriversList(reinterpret_cast<uint64_t>(pDrv->FastIoDispatch), pModList))
				{
					Log("FastIoDispatch of driver %wZ is hijacked!\n", pDrv->DriverName);
					ScanResults.InvalidDispatches++;
				}

				if (reinterpret_cast<uint64_t>(pDrv->MajorFunction[IRP_MJ_DEVICE_CONTROL]) < 
					reinterpret_cast<uint64_t>(pDrv->DriverStart) ||
					reinterpret_cast<uint64_t>(pDrv->MajorFunction[IRP_MJ_DEVICE_CONTROL]) > 
					(reinterpret_cast<uint64_t>(pDrv->DriverStart) + pDrv->DriverSize))
				{
					Log("Dispatch of driver %wZ is hijacked!\n", pDrv->DriverName);
					ScanResults.InvalidDispatches++;
				}
			}
		}

		ImpCall(ZwClose, hObj);
		ImpCall(ExFreePoolWithTag, pModList, 0);
	}

	void ScanPiDDBCache()
	{
		PERESOURCE PiDDBLock;
		PRTL_AVL_TABLE Table;

		if (!Utils::LocatePiDDB(&PiDDBLock, &Table))
			return;

		ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

		for (PiDDBCacheEntry* p = (PiDDBCacheEntry*)RtlEnumerateGenericTableAvl(Table, TRUE);
			p != NULL; p = (PiDDBCacheEntry*)RtlEnumerateGenericTableAvl(Table, FALSE))
		{
			if (p->TimeDateStamp == 0x5284EAC3)
			{
				Log("iqvw64e.sys timestamp detected, DrvName: %wZ\n", p->DriverName);
				ScanResults.PiDDB_VulnerableDriver = true;
			}

			if (p->TimeDateStamp == 0x57CD1415)
			{
				Log("Capcom.sys timestamp detected, DrvName: %wZ\n", p->DriverName);
				ScanResults.PiDDB_VulnerableDriver = true;
			}
		}
	}
}
```

`Driver/Driver.cpp`:

```cpp

#include "Globals.h"

VOID UnloadRoutine(PDRIVER_OBJECT pDrv)
{
	Callbacks::UnregisterCallbacks();

	ImpCall(IoDeleteDevice, pDrv->DeviceObject);
}

NTSTATUS Create(PDEVICE_OBJECT pDevObj, PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	ImpCall(IofCompleteRequest, Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS Close(PDEVICE_OBJECT pDevObj, PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	ImpCall(IofCompleteRequest, Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDrv, PUNICODE_STRING pRegPath)
{
	UNREFERENCED_PARAMETER(pRegPath);

	NTSTATUS Status = STATUS_ENTRYPOINT_NOT_FOUND;

	pDrv->DriverUnload = UnloadRoutine;

	if (!SetImports())
		return Status;

	UNICODE_STRING DevName;
	PDEVICE_OBJECT pDevObj;

	ImpCall(RtlInitUnicodeString, &DevName, L"\\Device\\WolfyZ_NtDrv");
	ImpCall(IoCreateDevice, pDrv, 0, &DevName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDevObj);

	pDrv->MajorFunction[IRP_MJ_CREATE] = Create;
	pDrv->MajorFunction[IRP_MJ_CLOSE] = Close;
	pDrv->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IO_Handler;

	Status = Callbacks::RegisterCallbacks(pDrv);

	if (NT_SUCCESS(Status))
		Log("Callbacks registered!\n");
	else
		Log("Failed to register callbacks: 0x%llX\n", Status);

	return Status;
}
```

`Driver/Driver.inf`:

```inf
;
; Driver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Driver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
Driver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Driver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Driver.DeviceDesc%=Driver_Device, Root\Driver ; TODO: edit hw-id

[Driver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Driver.sys

;-------------- Service installation
[Driver_Device.NT.Services]
AddService = Driver,%SPSVCINST_ASSOCSERVICE%, Driver_Service_Inst

; -------------- Driver driver install sections
[Driver_Service_Inst]
DisplayName    = %Driver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Driver.sys

;
;--- Driver_Device Coinstaller installation ------
;

[Driver_Device.NT.CoInstallers]
AddReg=Driver_Device_CoInstaller_AddReg
CopyFiles=Driver_Device_CoInstaller_CopyFiles

[Driver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Driver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Driver_Device.NT.Wdf]
KmdfService =  Driver, Driver_wdfsect
[Driver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Driver Installation Disk"
Driver.DeviceDesc = "Driver Device"
Driver.SVCDESC = "Driver Service"

```

`Driver/Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{25BEAC46-ED49-4DF3-A12D-300BB3553C79}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Driver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>
    </DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ImportLibs\x64\ci.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib</AdditionalDependencies>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Driver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Callbacks\Callbacks.h" />
    <ClInclude Include="Communication\IO_Handler.h" />
    <ClInclude Include="Detections\Detections.h" />
    <ClInclude Include="Globals.h" />
    <ClInclude Include="Utils\Defs.h" />
    <ClInclude Include="Utils\HideImports.h" />
    <ClInclude Include="Utils\skCrypt.h" />
    <ClInclude Include="Utils\stdint.h" />
    <ClInclude Include="Utils\Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Driver/Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Source Files\Utils">
      <UniqueIdentifier>{2ea5895b-51ee-4405-8328-e3b156c499b6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Callbacks">
      <UniqueIdentifier>{beeaaca3-30ec-453c-a470-fb58b75da20c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Communication">
      <UniqueIdentifier>{0bda1fa4-e8d1-4d3c-8c9f-35cf7dbfacb8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Detections">
      <UniqueIdentifier>{d23734dd-0d5d-4dbf-851d-54de30928dd7}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Driver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Globals.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils\stdint.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Defs.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\skCrypt.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\HideImports.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Utils.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Callbacks\Callbacks.h">
      <Filter>Source Files\Callbacks</Filter>
    </ClInclude>
    <ClInclude Include="Communication\IO_Handler.h">
      <Filter>Source Files\Communication</Filter>
    </ClInclude>
    <ClInclude Include="Detections\Detections.h">
      <Filter>Source Files\Detections</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Driver/Driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Driver/Globals.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <intrin.h>
#include <ntstrsafe.h>

#include "Utils/stdint.h"

PVOID NtBase = 0, CiBase = 0;
const bool DebugEnabled = true;

uint32_t GamePID = 0, ClientPID = 0;

PEPROCESS GameProcess = 0, ClientProcess = 0;

uint64_t KeSuspendThreadOffset = 0, KeResumeThreadOffset = 0;

LARGE_INTEGER Timeout;

#include "Utils/Defs.h"
#include "Utils/skCrypt.h"
#include "Utils/HideImports.h"

#define Log(a, ...) if (DebugEnabled) ImpCall(DbgPrintEx, 0, 0, skCrypt(a), __VA_ARGS__)
#define Sleep(a) Timeout.QuadPart = a; ImpCall(KeDelayExecutionThread, KernelMode, FALSE, &Timeout); Timeout.QuadPart = 0;

#include "Utils/Utils.h"
#include "Detections/Detections.h"
#include "Communication/IO_Handler.h"
#include "Callbacks/Callbacks.h"

```

`Driver/Utils/Defs.h`:

```h
#pragma once

#define IO_GETSTATUS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x4812984, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_SENDOFFSETS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x91278493, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_SCANDETECTIONS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x6218949, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _IO_GetStatus
{
	uint64_t Send;
	uint64_t Recv;
} IO_GetStatus, * pIO_GetStatus;

typedef struct _IO_SendOffsets
{
	ULONG KeSuspendThread;
	ULONG KeResumeThread;
} IO_SendOffsets, * pIO_SendOffsets;

typedef struct _SCAN_RESULTS
{
	uint32_t InvalidThreads;
	uint32_t TrampolineThreads;
	uint32_t InvalidStacks;
	uint32_t InvalidDispatches;
	bool PiDDB_VulnerableDriver;
} SCAN_RESULTS, * PSCAN_RESULTS;

#define PROCESS_QUERY_LIMITED_INFORMATION      0x1000
#define PROCESS_TERMINATE         0x0001  
#define PROCESS_VM_OPERATION      0x0008  
#define PROCESS_VM_READ           0x0010  
#define PROCESS_VM_WRITE          0x0020 

typedef struct _WIN_CERTIFICATE
{
	DWORD dwLength;
	WORD  wRevision;
	WORD  wCertificateType;
	BYTE  bCertificate[ANYSIZE_ARRAY];
} WIN_CERTIFICATE, * LPWIN_CERTIFICATE;

typedef struct _Asn1BlobPtr
{
	int size;
	PVOID ptrToData;
} Asn1BlobPtr, * pAsn1BlobPtr;

typedef struct _CertificatePartyName
{
	PVOID pointerToName;
	short nameLen;
	short unknown;
} CertificatePartyName, * pCertificatePartyName;

typedef struct _CertChainMember
{
	int digestIdetifier;
	int digestSize;
	BYTE digestBuffer[64];
	CertificatePartyName subjectName;
	CertificatePartyName issuerName;
	Asn1BlobPtr certificate;
} CertChainMember, * pCertChainMember;

typedef struct _CertChainInfoHeader
{
	int bufferSize;
	pAsn1BlobPtr ptrToPublicKeys;
	int numberOfPublicKeys;
	pAsn1BlobPtr ptrToEkus;
	int numberOfEkus;
	pCertChainMember ptrToCertChainMembers;
	int numberOfCertChainMembers;
	int unknown;
	Asn1BlobPtr variousAuthenticodeAttributes;
} CertChainInfoHeader, * pCertChainInfoHeader;

typedef struct _PolicyInfo
{
	int structSize;
	NTSTATUS verificationStatus;
	int flags;
	pCertChainInfoHeader certChainInfo;
	FILETIME revocationTime;
	FILETIME notBeforeTime;
	FILETIME notAfterTime;
} PolicyInfo, * pPolicyInfo;

extern "C" __declspec(dllimport) NTSTATUS _stdcall CiCheckSignedFile(
	const PVOID digestBuffer,
	int digestSize,
	int digestIdentifier,
	const LPWIN_CERTIFICATE winCert,
	int sizeOfSecurityDirectory,
	PolicyInfo * policyInfoForSigner,
	LARGE_INTEGER * signingTime,
	PolicyInfo * policyInfoForTimestampingAuthority);

extern "C" __declspec(dllimport) PVOID _stdcall CiFreePolicyInfo(PolicyInfo * policyInfo);

extern "C" __declspec(dllimport) NTSTATUS _stdcall CiValidateFileObject(
	struct _FILE_OBJECT* fileObject,
	int a2,
	int a3,
	PolicyInfo * policyInfoForSigner,
	PolicyInfo * policyInfoForTimestampingAuthority,
	LARGE_INTEGER * signingTime,
	BYTE * digestBuffer,
	int* digestSize,
	int* digestIdentifier
);

extern "C" POBJECT_TYPE * IoDriverObjectType;

struct StackWalkList
{
	uint64_t Rsp, Rip;
};

typedef struct _IMAGE_FILE_HEADER
{
	WORD    Machine;
	WORD    NumberOfSections;
	DWORD   TimeDateStamp;
	DWORD   PointerToSymbolTable;
	DWORD   NumberOfSymbols;
	WORD    SizeOfOptionalHeader;
	WORD    Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
	DWORD   VirtualAddress;
	DWORD   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
	WORD        Magic;
	BYTE        MajorLinkerVersion;
	BYTE        MinorLinkerVersion;
	DWORD       SizeOfCode;
	DWORD       SizeOfInitializedData;
	DWORD       SizeOfUninitializedData;
	DWORD       AddressOfEntryPoint;
	DWORD       BaseOfCode;
	ULONGLONG   ImageBase;
	DWORD       SectionAlignment;
	DWORD       FileAlignment;
	WORD        MajorOperatingSystemVersion;
	WORD        MinorOperatingSystemVersion;
	WORD        MajorImageVersion;
	WORD        MinorImageVersion;
	WORD        MajorSubsystemVersion;
	WORD        MinorSubsystemVersion;
	DWORD       Win32VersionValue;
	DWORD       SizeOfImage;
	DWORD       SizeOfHeaders;
	DWORD       CheckSum;
	WORD        Subsystem;
	WORD        DllCharacteristics;
	ULONGLONG   SizeOfStackReserve;
	ULONGLONG   SizeOfStackCommit;
	ULONGLONG   SizeOfHeapReserve;
	ULONGLONG   SizeOfHeapCommit;
	DWORD       LoaderFlags;
	DWORD       NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64
{
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	ULONG   Characteristics;
	ULONG   TimeDateStamp;
	USHORT  MajorVersion;
	USHORT  MinorVersion;
	ULONG   Name;
	ULONG   Base;
	ULONG   NumberOfFunctions;
	ULONG   NumberOfNames;
	ULONG   AddressOfFunctions;     // RVA from base of image
	ULONG   AddressOfNames;         // RVA from base of image
	ULONG   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY	 InLoadOrderLinks;
	void* ExceptionTable;
	unsigned int	 ExceptionTableSize;
	void* GpValue;
	void* NonPagedDebugInfo;
	void* DllBase;
	void* EntryPoint;
	unsigned int	 SizeOfImage;
	UNICODE_STRING	 FullDllName;
	UNICODE_STRING	 BaseDllName;
	unsigned int	 Flags;
	unsigned __int16 LoadCount;
	unsigned __int16 u1;
	void* SectionPointer;
	unsigned int	 CheckSum;
	unsigned int	 CoverageSectionSize;
	void* CoverageSection;
	void* LoadedImports;
	void* Spare;
	unsigned int	 SizeOfImageNotRounded;
	unsigned int	 TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;


typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG                   NextEntryOffset;
	ULONG                   NumberOfThreads;
	LARGE_INTEGER           Reserved[3];
	LARGE_INTEGER           CreateTime;
	LARGE_INTEGER           UserTime;
	LARGE_INTEGER           KernelTime;
	UNICODE_STRING          ImageName;
	ULONG                   BasePriority;
	HANDLE                  ProcessId;
	HANDLE                  InheritedFromProcessId;
} SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
	SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
	SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
	SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
	SystemPathInformation, // not implemented
	SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
	SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
	SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
	SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
	SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
	SystemModuleInformation, // q: RTL_PROCESS_MODULES
	SystemLocksInformation, // q: RTL_PROCESS_LOCKS
	SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
	SystemPagedPoolInformation, // not implemented
	SystemNonPagedPoolInformation, // not implemented
	SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
	SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
	SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
	SystemVdmInstemulInformation, // q
	SystemVdmBopInformation, // not implemented // 20
	SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
	SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
	SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
	SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
	SystemFullMemoryInformation, // not implemented
	SystemLoadGdiDriverInformation, // s (kernel-mode only)
	SystemUnloadGdiDriverInformation, // s (kernel-mode only)
	SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
	SystemSummaryMemoryInformation, // not implemented
	SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
	SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
	SystemObsolete0, // not implemented
	SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
	SystemCrashDumpStateInformation, // s (requires SeDebugPrivilege)
	SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
	SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
	SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
	SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
	SystemPrioritySeperation, // s (requires SeTcbPrivilege)
	SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
	SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
	SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
	SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
	SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
	SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
	SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
	SystemSessionCreate, // not implemented
	SystemSessionDetach, // not implemented
	SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
	SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
	SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
	SystemVerifierThunkExtend, // s (kernel-mode only)
	SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
	SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
	SystemNumaProcessorMap, // q
	SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
	SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemRecommendedSharedDataAlignment, // q
	SystemComPlusPackage, // q; s
	SystemNumaAvailableMemory, // 60
	SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
	SystemEmulationBasicInformation, // q
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
	SystemLostDelayedWriteInformation, // q: ULONG
	SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
	SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
	SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
	SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
	SystemObjectSecurityMode, // q: ULONG // 70
	SystemWatchdogTimerHandler, // s (kernel-mode only)
	SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
	SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
	SystemWow64SharedInformationObsolete, // not implemented
	SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
	SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
	SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
	SystemVerifierTriageInformation, // not implemented
	SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
	SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
	SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
	SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
	SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
	SystemVerifierCancellationInformation, // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
	SystemProcessorPowerInformationEx, // not implemented
	SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
	SystemSpecialPoolInformation, // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
	SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
	SystemErrorPortInformation, // s (requires SeTcbPrivilege)
	SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
	SystemHypervisorInformation, // q; s (kernel-mode only)
	SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
	SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
	SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
	SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
	SystemPrefetchPatchInformation, // not implemented
	SystemVerifierFaultsInformation, // s (requires SeDebugPrivilege)
	SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
	SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
	SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
	SystemNumaProximityNodeInformation, // q
	SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
	SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
	SystemProcessorMicrocodeUpdateInformation, // s
	SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
	SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
	SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
	SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
	SystemStoreInformation, // q; s // SmQueryStoreInformation
	SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
	SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
	SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
	SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
	SystemNativeBasicInformation, // not implemented
	SystemSpare1, // not implemented
	SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
	SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
	SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
	SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
	SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
	SystemNodeDistanceInformation, // q
	SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
	SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
	SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
	SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
	SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
	SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
	SystemBadPageInformation,
	SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
	SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
	SystemEntropyInterruptTimingCallback,
	SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
	SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
	SystemThrottleNotificationInformation,
	SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
	SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
	SystemDeviceDataEnumerationInformation,
	SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
	SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
	SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
	SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
	SystemSpare0,
	SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
	SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
	SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
	SystemEntropyInterruptTimingRawInformation,
	SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
	SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
	SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
	SystemBootMetadataInformation, // 150
	SystemSoftRebootInformation,
	SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
	SystemOfflineDumpConfigInformation,
	SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
	SystemRegistryReconciliationInformation,
	SystemEdidInformation,
	SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
	SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
	SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
	SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
	SystemVmGenerationCountInformation,
	SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
	SystemKernelDebuggerFlags,
	SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
	SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
	SystemHardwareSecurityTestInterfaceResultsInformation,
	SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
	SystemAllowedCpuSetsInformation,
	SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
	SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
	SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
	SystemCodeIntegrityPolicyFullInformation,
	SystemAffinitizedInterruptProcessorInformation,
	SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
	SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
	SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
	SystemWin32WerStartCallout,
	SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
	SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
	SystemInterruptSteeringInformation, // 180
	SystemSupportedProcessorArchitectures,
	SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
	SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
	SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
	SystemControlFlowTransition,
	SystemKernelDebuggingAllowed,
	SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
	SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
	SystemCodeIntegrityPoliciesFullInformation,
	SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
	SystemIntegrityQuotaInformation,
	SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
	SystemProcessorIdleMaskInformation, // since REDSTONE3
	SystemSecureDumpEncryptionInformation,
	SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
	SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
	SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
	SystemFirmwareBootPerformanceInformation,
	SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
	SystemFirmwarePartitionInformation, // 200
	SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
	SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
	SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
	SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
	SystemCodeIntegrityUnlockModeInformation,
	SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
	SystemFlags2Information,
	MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE 
{
	ULONG                Reserved1;
	ULONG                Reserved2;
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	BYTE                 Name[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION 
{
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[0];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

#define IMAGE_SIZEOF_SHORT_NAME              8
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000

typedef struct _IMAGE_SECTION_HEADER
{
	char    Name[8];
	ULONG   VirtualSize;
	ULONG   VirtualAddress;
	ULONG   SizeOfRawData;
	ULONG   PointerToRawData;
	ULONG   PointerToRelocations;
	ULONG   PointerToLinenumbers;
	__int16 NumberOfRelocations;
	__int16 NumberOfLinenumbers;
	ULONG   Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_SECTION_HEADER2
{
	BYTE    Name[8];
	union {
		DWORD   PhysicalAddress;
		DWORD   VirtualSize;
	} Misc;
	DWORD   VirtualAddress;
	DWORD   SizeOfRawData;
	DWORD   PointerToRawData;
	DWORD   PointerToRelocations;
	DWORD   PointerToLinenumbers;
	WORD    NumberOfRelocations;
	WORD    NumberOfLinenumbers;
	DWORD   Characteristics;
} IMAGE_SECTION_HEADER2, * PIMAGE_SECTION_HEADER2;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	CHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _IMAGE_DOS_HEADER
{
	WORD e_magic;
	WORD e_cblp;
	WORD e_cp;
	WORD e_crlc;
	WORD e_cparhdr;
	WORD e_minalloc;
	WORD e_maxalloc;
	WORD e_ss;
	WORD e_sp;
	WORD e_csum;
	WORD e_ip;
	WORD e_cs;
	WORD e_lfarlc;
	WORD e_ovno;
	WORD e_res[4];
	WORD e_oemid;
	WORD e_oeminfo;
	WORD e_res2[10];
	LONG e_lfanew;
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY 
{
	DWORD BeginAddress;
	DWORD EndAddress;
	union 
	{
		DWORD UnwindInfoAddress;
		DWORD UnwindData;
	} DUMMYUNIONNAME;
} RUNTIME_FUNCTION, * PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, * _PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
	union
	{
		uintptr_t VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union 
	{
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION 
{
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _DIRECTORY_BASIC_INFORMATION
{
	UNICODE_STRING ObjectName;
	UNICODE_STRING ObjectTypeName;
} DIRECTORY_BASIC_INFORMATION, * PDIRECTORY_BASIC_INFORMATION;

#define ABSOLUTE(wait) (wait)

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) \
(((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) \
(((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) \
(((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) \
(((signed __int64)(seconds)) * MILLISECONDS(1000L))

typedef uint64_t(NTAPI* ThreadProtoDef)(void* pThread);

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

BYTE PiDDBLockPtr_sig[] = "\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x8C";
BYTE PiDDBCacheTablePtr_sig[] = "\x66\x03\xD2\x48\x8D\x0D";

struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16];
};

/*
typedef enum _THREAD_INFORMATION_CLASS
{
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger
} THREAD_INFORMATION_CLASS, * PTHREAD_INFORMATION_CLASS; */

EXTERN_C {
	NTSTATUS NTAPI MmCopyVirtualMemory
	(
		PEPROCESS SourceProcess,
		PVOID SourceAddress,
		PEPROCESS TargetProcess,
		PVOID TargetAddress,
		SIZE_T BufferSize,
		KPROCESSOR_MODE PreviousMode,
		PSIZE_T ReturnSize
	);

	NTSYSAPI NTSTATUS NTAPI NtQueryInformationThread(
			IN HANDLE               ThreadHandle,
			IN THREADINFOCLASS		ThreadInformationClass,
			OUT PVOID               ThreadInformation,
			IN ULONG                ThreadInformationLength,
			OUT PULONG              ReturnLength OPTIONAL);

	NTSTATUS ZwQueryInformationThread(
		_In_      HANDLE          ThreadHandle,
		_In_      THREADINFOCLASS ThreadInformationClass,
		_In_      PVOID           ThreadInformation,
		_In_      ULONG           ThreadInformationLength,
		_Out_opt_ PULONG          ReturnLength
	);

	NTSTATUS ZwQuerySystemInformation(
		IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
		IN OUT PVOID SystemInformation,
		IN ULONG SystemInformationLength,
		OUT PULONG ReturnLength OPTIONAL);
	NTKERNELAPI PPEB NTAPI PsGetProcessPeb(PEPROCESS);
	NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process(PEPROCESS);
	NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID);
	NTKERNELAPI NTSTATUS ObReferenceObjectByName(
		IN PUNICODE_STRING ObjectName,
		IN ULONG Attributes,
		IN PACCESS_STATE PassedAccessState,
		IN ACCESS_MASK DesiredAccess,
		IN POBJECT_TYPE ObjectType,
		IN KPROCESSOR_MODE AccessMode,
		IN OUT PVOID ParseContext,
		OUT PVOID * Object
	);

	PVOID RtlImageDirectoryEntryToData(PVOID BaseAddress, BOOLEAN MappedAsImage, USHORT Directory, PULONG Size);

	NTKERNELAPI UCHAR* PsGetProcessImageFileName(__in PEPROCESS Process);

	NTSYSAPI BOOLEAN
		NTAPI
		PsIsProtectedProcess(
			_In_ PEPROCESS Process
		);

	NTSYSAPI
		BOOLEAN
		NTAPI
		PsIsSystemProcess(
			_In_ PEPROCESS Process
		);

	NTSYSAPI PRUNTIME_FUNCTION RtlLookupFunctionEntry(
		DWORD64               ControlPc,
		PDWORD64              ImageBase,
		PDWORD64			  HistoryTable
	);

	NTSYSAPI PEXCEPTION_ROUTINE RtlVirtualUnwind(
		DWORD                          HandlerType,
		DWORD64                        ImageBase,
		DWORD64                        ControlPc,
		PRUNTIME_FUNCTION              FunctionEntry,
		PCONTEXT                       ContextRecord,
		PVOID *						   HandlerData,
		PDWORD64                       EstablisherFrame,
		PDWORD64					   ContextPointers
	);

	POBJECT_TYPE NTAPI ObGetObjectType(
		__in PVOID Object
	);

	NTSTATUS NTAPI ZwQueryDirectoryObject(
		IN HANDLE DirectoryHandle,
		OUT PVOID Buffer,
		IN ULONG BufferLength,
		IN BOOLEAN ReturnSingleEntry,
		IN BOOLEAN RestartScan,
		IN OUT PULONG Context,
		OUT PULONG ReturnLength OPTIONAL
	);

	NTKERNELAPI
		NTSTATUS
		ObOpenObjectByName(
			__in POBJECT_ATTRIBUTES ObjectAttributes,
			__in_opt POBJECT_TYPE ObjectType,
			__in KPROCESSOR_MODE AccessMode,
			__inout_opt PACCESS_STATE AccessState,
			__in_opt ACCESS_MASK DesiredAccess,
			__inout_opt PVOID ParseContext,
			__out PHANDLE Handle
		);


	DRIVER_INITIALIZE DriverEntry;
}
```

`Driver/Utils/HideImports.h`:

```h
#pragma once

#define NT_HEADER(ModBase) (PIMAGE_NT_HEADERS)((ULONG64)(ModBase) + ((PIMAGE_DOS_HEADER)(ModBase))->e_lfanew)

template <typename Type>
__forceinline Type EPtr(Type Ptr)
{
	auto Key = (ULONG64)SharedUserData->Cookie *
		SharedUserData->Cookie *
		SharedUserData->Cookie *
		SharedUserData->Cookie;
	return (Type)((ULONG64)Ptr ^ Key);
}

template <typename StrType, typename StrType2>
__forceinline bool StrICmp(StrType Str, StrType2 InStr, bool Two)
{
#define ToLower(Char) ((Char >= 'A' && Char <= 'Z') ? (Char + 32) : Char)

	if (!Str || !InStr)
		return false;

	wchar_t c1, c2; do
	{
		c1 = *Str++; c2 = *InStr++;
		c1 = ToLower(c1); c2 = ToLower(c2);
		if (!c1 && (Two ? !c2 : 1))
			return true;
	} while (c1 == c2);

	return false;
}

PVOID GetProcAdress(PVOID ModBase, const char* Name)
{
	PIMAGE_NT_HEADERS NT_Head = NT_HEADER(ModBase);
	PIMAGE_EXPORT_DIRECTORY ExportDir = (PIMAGE_EXPORT_DIRECTORY)((ULONG64)ModBase + NT_Head->OptionalHeader.DataDirectory[0].VirtualAddress);

	for (ULONG i = 0; i < ExportDir->NumberOfNames; i++)
	{
		USHORT Ordinal = ((USHORT*)((ULONG64)ModBase + ExportDir->AddressOfNameOrdinals))[i];
		const char* ExpName = (const char*)ModBase + ((ULONG*)((ULONG64)ModBase + ExportDir->AddressOfNames))[i];

		if (StrICmp(Name, ExpName, true))
			return (PVOID)((ULONG64)ModBase + ((ULONG*)((ULONG64)ModBase + ExportDir->AddressOfFunctions))[Ordinal]);
	}

	return nullptr;
}

#define ImpSet(a) a##Fn = (a##Def)EPtr(GetProcAdress(NtBase, skCrypt(#a)));
#define ImpDef(a) using a##Def = decltype(&a); a##Def a##Fn = nullptr;
#define ImpCall(a, ...) ((a##Def)EPtr(a##Fn))(__VA_ARGS__)

#define CiSet(a) a##Fn = (a##Def)EPtr(GetProcAdress(CiBase, skCrypt(#a)));
#define CiDef(a) using a##Def = decltype(&a); a##Def a##Fn = nullptr;
#define CiCall(a, ...) ((a##Def)EPtr(a##Fn))(__VA_ARGS__)

ImpDef(KeAttachProcess); ImpDef(KeDetachProcess); ImpDef(memcpy); ImpDef(ZwOpenFile);
ImpDef(PsLookupProcessByProcessId); ImpDef(MmCopyVirtualMemory); ImpDef(PsGetProcessId);
ImpDef(MmCopyMemory); ImpDef(PsLookupThreadByThreadId); ImpDef(PsIsSystemThread);
ImpDef(RtlInitUnicodeString); ImpDef(IoCreateDevice); ImpDef(PsIsSystemProcess);
ImpDef(IoDeleteSymbolicLink); ImpDef(IoDeleteDevice); ImpDef(IofCompleteRequest);
ImpDef(MmIsAddressValid); ImpDef(PsGetProcessImageFileName); ImpDef(ZwClose); ImpDef(wcsstr);
ImpDef(KeDelayExecutionThread); ImpDef(ExAllocatePool); ImpDef(ExFreePoolWithTag);
ImpDef(IoGetCurrentProcess); ImpDef(DbgPrintEx); ImpDef(PsSetLoadImageNotifyRoutine);
ImpDef(PsRemoveLoadImageNotifyRoutine); ImpDef(PsIsProtectedProcess); ImpDef(ZwCreateSection);
ImpDef(ObGetFilterVersion); ImpDef(ObRegisterCallbacks); ImpDef(ObUnRegisterCallbacks);
ImpDef(ObReferenceObjectByHandle); ImpDef(MmMapViewInSystemSpace); ImpDef(ObfDereferenceObject);
ImpDef(RtlImageDirectoryEntryToData); ImpDef(MmUnmapViewInSystemSpace); ImpDef(IoCreateFileEx);
ImpDef(PsSetCreateProcessNotifyRoutineEx); ImpDef(PsGetCurrentProcessId); ImpDef(KeGetCurrentThread)
ImpDef(ObCloseHandle); ImpDef(ZwQuerySystemInformation); ImpDef(MmGetSystemRoutineAddress);
ImpDef(PsGetCurrentThread); ImpDef(ObOpenObjectByPointer); ImpDef(NtQueryInformationThread);
ImpDef(PsIsThreadTerminating); ImpDef(MmGetPhysicalAddress); ImpDef(MmMapIoSpace);
ImpDef(MmUnmapIoSpace); ImpDef(ZwOpenDirectoryObject); ImpDef(RtlImageNtHeader);
ImpDef(RtlInitAnsiString); ImpDef(RtlCompareString); ImpDef(ZwQueryInformationThread);
ImpDef(IoGetCurrentIrpStackLocation); ImpDef(RtlSecureZeroMemory); ImpDef(KeRaiseIrqlToDpcLevel);
ImpDef(RtlLookupFunctionEntry); ImpDef(KeLowerIrql); ImpDef(ObGetObjectType); 
ImpDef(ObOpenObjectByName); ImpDef(ZwQueryDirectoryObject); ImpDef(ObReferenceObjectByName);

CiDef(CiCheckSignedFile); CiDef(CiFreePolicyInfo); CiDef(CiValidateFileObject);


bool SetImports()
{
	if (!NtBase)
	{
		ULONG Size = 0;
		NTSTATUS Status = 0;

	retry:

		Status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &Size);

		if (STATUS_INFO_LENGTH_MISMATCH != Status)
			return false;


		PRTL_PROCESS_MODULES Modules = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPool, Size);
		if (!Modules)
			return false;


		if (!NT_SUCCESS(Status = ZwQuerySystemInformation(SystemModuleInformation, Modules, Size, 0)))
		{
			ExFreePoolWithTag(Modules, 0);

			if (Status == STATUS_INFO_LENGTH_MISMATCH)
				goto retry;
			else
				return false;
		}

		for (ULONG i = 0; i < Modules->NumberOfModules; ++i)
		{
			RTL_PROCESS_MODULE_INFORMATION m = Modules->Modules[i];

			if (strstr((PCHAR)m.FullPathName, skCrypt("ntoskrnl.exe")))
				NtBase = m.ImageBase;

			if (strstr((PCHAR)m.FullPathName, skCrypt("CI.dll")))
				CiBase = m.ImageBase;

			if (NtBase && CiBase)
				break;
		}

		ExFreePoolWithTag(Modules, 0);
	}

	if (!NtBase || !CiBase)
		return false;

	ImpSet(KeAttachProcess); ImpSet(KeDetachProcess); ImpSet(memcpy); ImpSet(ZwOpenFile);
	ImpSet(PsLookupProcessByProcessId); ImpSet(MmCopyVirtualMemory); ImpSet(PsGetProcessId);
	ImpSet(MmCopyMemory); ImpSet(PsLookupThreadByThreadId); ImpSet(PsIsSystemThread);
	ImpSet(RtlInitUnicodeString); ImpSet(IoCreateDevice); ImpSet(PsIsSystemProcess);
	ImpSet(IoDeleteSymbolicLink); ImpSet(IoDeleteDevice); ImpSet(IofCompleteRequest);
	ImpSet(MmIsAddressValid); ImpSet(PsGetProcessImageFileName); ImpSet(ZwClose); ImpSet(wcsstr);
	ImpSet(KeDelayExecutionThread); ImpSet(ExAllocatePool); ImpSet(ExFreePoolWithTag);
	ImpSet(IoGetCurrentProcess); ImpSet(DbgPrintEx); ImpSet(PsSetLoadImageNotifyRoutine);
	ImpSet(PsRemoveLoadImageNotifyRoutine); ImpSet(PsIsProtectedProcess); ImpSet(ZwCreateSection);
	ImpSet(ObGetFilterVersion); ImpSet(ObRegisterCallbacks); ImpSet(ObUnRegisterCallbacks);
	ImpSet(ObReferenceObjectByHandle); ImpSet(MmMapViewInSystemSpace); ImpSet(ObfDereferenceObject);
	ImpSet(RtlImageDirectoryEntryToData); ImpSet(MmUnmapViewInSystemSpace); ImpSet(IoCreateFileEx);
	ImpSet(PsSetCreateProcessNotifyRoutineEx); ImpSet(PsGetCurrentProcessId); ImpSet(KeGetCurrentThread)
	ImpSet(ObCloseHandle); ImpSet(ZwQuerySystemInformation); ImpSet(MmGetSystemRoutineAddress);
	ImpSet(PsGetCurrentThread); ImpSet(ObOpenObjectByPointer); ImpSet(NtQueryInformationThread);
	ImpSet(PsIsThreadTerminating); ImpSet(MmGetPhysicalAddress); ImpSet(MmMapIoSpace);
	ImpSet(MmUnmapIoSpace); ImpSet(ZwOpenDirectoryObject); ImpSet(RtlImageNtHeader);
	ImpSet(RtlInitAnsiString); ImpSet(RtlCompareString); ImpSet(ZwQueryInformationThread);
	ImpSet(IoGetCurrentIrpStackLocation); ImpSet(RtlSecureZeroMemory); ImpSet(KeRaiseIrqlToDpcLevel);
	ImpSet(RtlLookupFunctionEntry); ImpSet(KeLowerIrql); ImpSet(ObGetObjectType);
	ImpSet(ObOpenObjectByName); ImpSet(ZwQueryDirectoryObject); ImpSet(ObReferenceObjectByName);


	CiSet(CiCheckSignedFile); CiSet(CiFreePolicyInfo); CiSet(CiValidateFileObject);

	return true;
}
```

`Driver/Utils/Utils.h`:

```h
#pragma once

namespace Utils
{
	bool inRange(const BYTE* rangeStartAddr, const BYTE* rangeEndAddr, const BYTE* addrToCheck)
	{
		if (addrToCheck > rangeEndAddr || addrToCheck < rangeStartAddr)
		{
			return false;
		}

		return true;
	}

	bool AuthenticateApplication(PCUNICODE_STRING ImageFileName, PVOID DigestBuffer, int SHAtype)
	{
		IO_STATUS_BLOCK IoBlock = { 0 };
		OBJECT_ATTRIBUTES ObjAttr = { 0 }, ObjAttr2 = { 0 };
		HANDLE FileHandle = NULL, SectionHandle = NULL;
		PVOID SectionObject = NULL, BaseAddress = NULL;
		SIZE_T BaseSize = NULL;

		InitializeObjectAttributes(&ObjAttr, const_cast<PUNICODE_STRING>(ImageFileName), OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, nullptr, nullptr);

		NTSTATUS Status = ImpCall(ZwOpenFile, &FileHandle, SYNCHRONIZE | FILE_READ_DATA, &ObjAttr, &IoBlock, FILE_SHARE_READ, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

		if (!NT_SUCCESS(Status) || !NT_SUCCESS(IoBlock.Status) || !FileHandle)
		{
			Log("Failed to open file: 0x%llX | 0x%llX\n", Status, IoBlock.Status);
			return false;
		}

		InitializeObjectAttributes(&ObjAttr2, nullptr, OBJ_KERNEL_HANDLE, nullptr, nullptr);

		Status = ImpCall(ZwCreateSection, &SectionHandle, SECTION_MAP_READ, &ObjAttr2, nullptr, PAGE_READONLY, SEC_COMMIT, FileHandle);
		ImpCall(ZwClose, FileHandle);

		if (!NT_SUCCESS(Status) || !SectionHandle)
		{
			Log("Failed to create section: 0x%llX\n", Status);
			return false;
		}

		Status = ImpCall(ObReferenceObjectByHandle, SectionHandle, SECTION_MAP_READ, nullptr, KernelMode, &SectionObject, nullptr);

		if (!NT_SUCCESS(Status))
		{
			Log("Failed to reference object: 0x%llX\n", Status);
			return false;
		}

		ImpCall(ZwClose, SectionHandle);

		Status = ImpCall(MmMapViewInSystemSpace, SectionObject, &BaseAddress, &BaseSize);
		ImpCall(ObfDereferenceObject, SectionObject);

		if (!NT_SUCCESS(Status))
		{
			Log("Failed to map section: 0x%llX\n", Status);
			return false;
		}

		ULONG SecurityDirectoryEntrySize = NULL;
		PVOID SecurityDirectoryEntry = ImpCall(RtlImageDirectoryEntryToData, BaseAddress, TRUE, 4, &SecurityDirectoryEntrySize);

		if (!SecurityDirectoryEntry)
		{
			Log("Failed to get security directory!\n");
			ImpCall(MmUnmapViewInSystemSpace, BaseAddress);
			return false;
		}

		const BYTE* EndOfFileAddress = static_cast<BYTE*>(BaseAddress) + BaseSize;
		const BYTE* EndOfSecurityDirectory = static_cast<BYTE*>(SecurityDirectoryEntry) + SecurityDirectoryEntrySize;

		if (EndOfSecurityDirectory > EndOfFileAddress || SecurityDirectoryEntry < BaseAddress)
		{
			Log("Security Directory is not contained in the file view!\n");
			ImpCall(MmUnmapViewInSystemSpace, BaseAddress);
			return false;
		}

		LPWIN_CERTIFICATE WinCert = static_cast<LPWIN_CERTIFICATE>(SecurityDirectoryEntry);

		PolicyInfo SignerPolicyInfo, TAPolicyInfo;
		LARGE_INTEGER SigningTime = { 0 };
		const int DigestSize = SHAtype == 1? 20 : 32; // SHA1 / SHA256 size
		const int DigestIdentifier = SHAtype == 1 ? 0x8004 : 0x800C; // SHA1 / SHA256 identifier

		Status = CiCall(CiCheckSignedFile, DigestBuffer, DigestSize, DigestIdentifier, WinCert, SecurityDirectoryEntrySize, &SignerPolicyInfo, &SigningTime, &TAPolicyInfo);

		if (NT_SUCCESS(Status))
		{
			Log("Signed file found!\n");
			ImpCall(MmUnmapViewInSystemSpace, BaseAddress);

			if (DebugEnabled)
			{
				const pCertChainInfoHeader ChainInfoHeader = SignerPolicyInfo.certChainInfo;
				const BYTE* StartOfCertChainInfo = (BYTE*)ChainInfoHeader;
				const BYTE* EndOfCertChainInfo = (BYTE*)SignerPolicyInfo.certChainInfo + ChainInfoHeader->bufferSize;

				if (!inRange(StartOfCertChainInfo, EndOfCertChainInfo, (BYTE*)ChainInfoHeader->ptrToCertChainMembers))
					return true;

				if (!inRange(StartOfCertChainInfo, EndOfCertChainInfo, (BYTE*)ChainInfoHeader->ptrToCertChainMembers + sizeof(CertChainMember)))
					return true;
				
				pCertChainMember SignerChainMember = ChainInfoHeader->ptrToCertChainMembers;

				Log("Subject: %.*s\nIssuer: %.*s\n", SignerChainMember->subjectName.nameLen, static_cast<char*>(SignerChainMember->subjectName.pointerToName), 
					SignerChainMember->issuerName.nameLen, static_cast<char*>(SignerChainMember->issuerName.pointerToName));
			}

			return true;
		}
		else
			Log("Failed to get signed file0x%llX\n", Status);

		ImpCall(MmUnmapViewInSystemSpace, BaseAddress);
		return false;
	}

	bool ValidateDLL(PUNICODE_STRING FullDllName)
	{
		OBJECT_ATTRIBUTES ObjAttr;
		InitializeObjectAttributes(&ObjAttr, const_cast<PUNICODE_STRING>(FullDllName), OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, nullptr, nullptr);
		PVOID Object;
		HANDLE FileHandle;
		IO_STATUS_BLOCK IoBlock;

		NTSTATUS Status = ImpCall(ZwOpenFile, &FileHandle, SYNCHRONIZE | FILE_READ_DATA, &ObjAttr, &IoBlock, FILE_SHARE_READ, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

		if (!NT_SUCCESS(Status))
		{
			Log("Failed to open file: 0x%llX\n", Status);
			return false;
		}

		Status = ImpCall(ObReferenceObjectByHandle, FileHandle, FILE_READ_DATA, *IoFileObjectType, KernelMode, &Object, NULL);

		if (!NT_SUCCESS(Status))
		{
			Log("Failed to reference object: 0x%llX\n", Status);
			ImpCall(ObCloseHandle, FileHandle, KernelMode);

			return false;
		}

		PFILE_OBJECT FileObject = (PFILE_OBJECT)Object;

		PolicyInfo SignerPolicyInfo, TSAPolicyInfo;
		LARGE_INTEGER SigningTime = { 0 };
		int DigestSize = 64, DigestIdentifier = 0;
		BYTE DigestBuffer[64] = { 0 };

		Status = CiCall(CiValidateFileObject, FileObject, 0, 0, &SignerPolicyInfo, &TSAPolicyInfo, &SigningTime, DigestBuffer, &DigestSize, &DigestIdentifier);
		ImpCall(ObCloseHandle, FileHandle, KernelMode);

		if (NT_SUCCESS(Status))
		{
			if (DebugEnabled)
			{
				const pCertChainInfoHeader ChainInfoHeader = SignerPolicyInfo.certChainInfo;
				const BYTE* StartOfCertChainInfo = (BYTE*)ChainInfoHeader;
				const BYTE* EndOfCertChainInfo = (BYTE*)SignerPolicyInfo.certChainInfo + ChainInfoHeader->bufferSize;

				if (!inRange(StartOfCertChainInfo, EndOfCertChainInfo, (BYTE*)ChainInfoHeader->ptrToCertChainMembers))
				{
					CiCall(CiFreePolicyInfo, &SignerPolicyInfo);
					CiCall(CiFreePolicyInfo, &TSAPolicyInfo);
					return true;
				}

				if (!inRange(StartOfCertChainInfo, EndOfCertChainInfo, (BYTE*)ChainInfoHeader->ptrToCertChainMembers + sizeof(CertChainMember)))
				{
					CiCall(CiFreePolicyInfo, &SignerPolicyInfo);
					CiCall(CiFreePolicyInfo, &TSAPolicyInfo);
					return true;
				}

				pCertChainMember SignerChainMember = ChainInfoHeader->ptrToCertChainMembers;

				Log("DLL: %ws\nSubject: %.*s\nIssuer: %.*s\n\n", FullDllName->Buffer, SignerChainMember->subjectName.nameLen, static_cast<char*>(SignerChainMember->subjectName.pointerToName), SignerChainMember->issuerName.nameLen, static_cast<char*>(SignerChainMember->issuerName.pointerToName));
			}

			CiCall(CiFreePolicyInfo, &SignerPolicyInfo);
			CiCall(CiFreePolicyInfo, &TSAPolicyInfo);

			return true;
		}

		CiCall(CiFreePolicyInfo, &SignerPolicyInfo);
		CiCall(CiFreePolicyInfo, &TSAPolicyInfo);

		Log("Failed to validate file object: 0x%llX\n", Status);

		return false;
	}

	NTSTATUS BBSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound, int index = 0)
	{
		ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
		if (ppFound == NULL || pattern == NULL || base == NULL)
			return STATUS_ACCESS_DENIED;
		int cIndex = 0;
		for (ULONG_PTR i = 0; i < size - len; i++)
		{
			BOOLEAN found = TRUE;
			for (ULONG_PTR j = 0; j < len; j++)
			{
				if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
				{
					found = FALSE;
					break;
				}
			}

			if (found != FALSE && cIndex++ == index)
			{
				*ppFound = (PUCHAR)base + i;
				return STATUS_SUCCESS;
			}
		}

		return STATUS_NOT_FOUND;
	}

	NTSTATUS BBScanSection(IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound, PVOID base = nullptr)
	{
		if (ppFound == NULL)
			return STATUS_ACCESS_DENIED;

		if (nullptr == base)
			base = NtBase;
		if (base == nullptr)
			return STATUS_ACCESS_DENIED;

		PIMAGE_NT_HEADERS64 pHdr = ImpCall(RtlImageNtHeader, base);
		if (!pHdr)
			return STATUS_ACCESS_DENIED;

		PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)((uintptr_t)&pHdr->FileHeader + pHdr->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER));

		for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)
		{
			ANSI_STRING s1, s2;
			ImpCall(RtlInitAnsiString, &s1, section);
			ImpCall(RtlInitAnsiString, &s2, (PCCHAR)pSection->Name);

			if (ImpCall(RtlCompareString, &s1, &s2, TRUE) == 0)
			{
				PVOID ptr = NULL;
				NTSTATUS status = BBSearchPattern(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->VirtualSize, &ptr);
				if (NT_SUCCESS(status)) 
				{
					*(PULONG64)ppFound = (ULONG_PTR)(ptr);
					return status;
				}
			}
		}

		return STATUS_ACCESS_DENIED;
	}

	PVOID ResolveRelativeAddress(
		_In_ PVOID Instruction,
		_In_ ULONG OffsetOffset,
		_In_ ULONG InstructionSize
	)
	{
		ULONG_PTR Instr = (ULONG_PTR)Instruction;
		LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
		PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

		return ResolvedAddr;
	}

	PVOID GetDriversList()
	{
		ULONG RequiredSize = 0;
		ImpCall(ZwQuerySystemInformation, SystemModuleInformation, 0, 0, &RequiredSize);

		RequiredSize += (10 * 1024);

		PVOID pModList = ImpCall(ExAllocatePool, NonPagedPool, RequiredSize);

		if (!pModList)
			return 0;

		ImpCall(ZwQuerySystemInformation, SystemModuleInformation, pModList, RequiredSize, &RequiredSize);

		return pModList;
	}

	bool IsAddressInDriversList(uint64_t Address, PRTL_PROCESS_MODULES pDrvList)
	{
		if (!pDrvList)
			return false;

		if (!Address)
			return true;

		for (uint32_t i = 0; i < pDrvList->NumberOfModules; i++)
		{
			PRTL_PROCESS_MODULE_INFORMATION pMod = &pDrvList->Modules[i];

			if (Address >= (uint64_t)pMod->ImageBase &&
				Address < ((uint64_t)pMod->ImageBase + pMod->ImageSize))
				return true;
		}

		return false;
	}

	ULONG GetThreadStackBaseOffset()
	{
		UNICODE_STRING s = RTL_CONSTANT_STRING(L"PsGetCurrentThreadStackBase");

		auto CurrentThreadStackBase = (uint64_t(NTAPI*)())ImpCall(MmGetSystemRoutineAddress, &s);
		auto CurrentThread = (uint64_t)ImpCall(PsGetCurrentThread);
		auto CurrentStack = CurrentThreadStackBase();

		ULONG Offset = NULL;
		while (*(uint64_t*)(CurrentThread + Offset) != CurrentStack)
			Offset += 8;

		return Offset;
	}

	ULONG GetThreadStackLimitOffset()
	{
		UNICODE_STRING s = RTL_CONSTANT_STRING(L"PsGetCurrentThreadStackLimit");

		auto CurrentThreadStackLimit = (uint64_t(NTAPI*)())ImpCall(MmGetSystemRoutineAddress, &s);
		auto CurrentThread = (uint64_t)ImpCall(PsGetCurrentThread);
		auto CurrentStack = CurrentThreadStackLimit();

		ULONG Offset = NULL;
		while (*(uint64_t*)(CurrentThread + Offset) != CurrentStack)
			Offset += 8;

		return Offset;
	}

	ULONG GetInitialThreadStackOffset()
	{
		UNICODE_STRING s = RTL_CONSTANT_STRING(L"IoGetInitialStack");

		auto CurrentThreadStack = (uint64_t(NTAPI*)())ImpCall(MmGetSystemRoutineAddress, &s);
		auto CurrentThread = (uint64_t)ImpCall(PsGetCurrentThread);
		auto CurrentStack = CurrentThreadStack();

		ULONG Offset = NULL;
		while (*(uint64_t*)(CurrentThread + Offset) != CurrentStack)
			Offset += 8;

		return Offset;
	}

	ULONG GetThreadCurrentStackLocationOffset(uint64_t pThreadObj, ULONG StackBaseOffset, ULONG StackLimitOffset, ULONG InitialStackOffset)
	{
		auto ThreadStackBase = StackBaseOffset ? *(uint64_t*)(pThreadObj + StackBaseOffset) : 0;
		auto ThreadStackLimit = StackLimitOffset ? *(uint64_t*)(pThreadObj + StackLimitOffset) : 0;

		if (!ThreadStackBase || !ThreadStackLimit || !InitialStackOffset)
			return 0;

		ULONG Offset = 0;

		while (Offset < 0x2F8) 
		{
			if (Offset != InitialStackOffset && *(uint64_t*)(pThreadObj + Offset) < ThreadStackBase && *(uint64_t*)(pThreadObj + Offset) > ThreadStackLimit)
				return Offset;

			Offset += 8;
		}

		return 0;
	}

	uint64_t GetThreadStartAddress(PETHREAD pThread)
	{
		NTSTATUS Status = STATUS_SUCCESS;
		uint64_t StartAddress = NULL;
		HANDLE hThread = NULL;
		ULONG RetBytes = NULL;

		Status = ImpCall(ObOpenObjectByPointer, pThread, OBJ_KERNEL_HANDLE, nullptr, GENERIC_READ, *PsThreadType, KernelMode, &hThread);

		if (!NT_SUCCESS(Status))
		{
			Log("Failed to open object: 0x%llX\n", Status);
			return StartAddress;
		}

		Status = ImpCall(ZwQueryInformationThread, hThread, ThreadQuerySetWin32StartAddress, &StartAddress, sizeof(StartAddress), &RetBytes);
		
		if (!NT_SUCCESS(Status))
			Log("Failed to query thread info: 0x%llX\n", Status);

		ImpCall(ZwClose, hThread);

		return StartAddress;
	}
	
	ULONG CopyStack(PETHREAD pThread, PVOID CopiedStack, ULONG StackBufferLen)
	{
		RtlZeroMemory(CopiedStack, StackBufferLen);

		ULONG StackBaseOffset = GetThreadStackBaseOffset();
		ULONG StackLimitOffset = GetThreadStackLimitOffset();
		ULONG InitialStackOffset = GetInitialThreadStackOffset();

		auto StackBase = StackBaseOffset ? *(uint64_t*)((uint64_t)pThread + StackBaseOffset) : 0;
		auto StackLimit = StackLimitOffset ? *(uint64_t*)((uint64_t)pThread + StackLimitOffset) : 0;
		auto InitialStack = InitialStackOffset ? *(uint64_t*)((uint64_t)pThread + InitialStackOffset) : 0;
		auto CurrentStackLocationOffset = GetThreadCurrentStackLocationOffset((uint64_t)pThread, StackBaseOffset, StackLimitOffset, InitialStackOffset);
		auto pCurrentStackLocation = CurrentStackLocationOffset ? (uint64_t*)((uint64_t)pThread + CurrentStackLocationOffset) : nullptr;

		if (pThread == ImpCall(KeGetCurrentThread) || !StackBase || !StackLimit || !InitialStack || !CurrentStackLocationOffset || ImpCall(PsIsThreadTerminating, pThread) || pCurrentStackLocation == nullptr)
			return NULL;

		ThreadProtoDef KeSuspendThread = (ThreadProtoDef)((uint64_t)NtBase + KeSuspendThreadOffset);
		ThreadProtoDef KeResumeThread = (ThreadProtoDef)((uint64_t)NtBase + KeResumeThreadOffset);

		KeSuspendThread(pThread);

		auto CurrentStackLocation = *pCurrentStackLocation;
		auto CurrentStackSize = StackBase - CurrentStackLocation;

		if (CurrentStackLocation > StackLimit && CurrentStackLocation < StackBase && ImpCall(MmGetPhysicalAddress, (PVOID)CurrentStackLocation).QuadPart) 
		{
			if (CurrentStackSize > StackBufferLen)
				CurrentStackSize = StackBufferLen;

			if (!ImpCall(MmIsAddressValid, (PVOID)CurrentStackLocation))
			{
				KeResumeThread(pThread);
				return NULL;
			}

			memmove(CopiedStack, (PVOID)CurrentStackLocation, CurrentStackSize);
		}
		else
			CurrentStackSize = NULL;

		KeResumeThread(pThread);

		return CurrentStackSize;
	}

	uint64_t GetNtTextSection(ULONG* Len)
	{
		PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)NtBase;
		PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((BYTE*)pDos + pDos->e_lfanew);

		uint64_t StartAddress = 0;

		uint64_t HeaderOffset = (uint64_t)IMAGE_FIRST_SECTION(pNtHeaders);

		for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; ++i)
		{
			PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)HeaderOffset;

			if (StrICmp(pSection->Name, ".text", false))
			{
				StartAddress = pSection->PointerToRawData;
				*Len = pSection->SizeOfRawData;

				return StartAddress;
			}

			HeaderOffset += sizeof(IMAGE_SECTION_HEADER);
		}

		return StartAddress;
	}

	void StackWalkThread(PETHREAD pThread, StackWalkList* Results)
	{
		BYTE CopiedStack[0x1000];

		if (ULONG StackLen = CopyStack(pThread, CopiedStack, sizeof(CopiedStack)))
		{
			if (StackLen >= 0x48 && StackLen != 0x1000)
			{
				int FuncCount = 0;
				CONTEXT Ctx;

				RtlZeroMemory(&Ctx, sizeof(Ctx));

				Ctx.Rip = *(uint64_t*)(&CopiedStack[0] + 0x38);
				Ctx.Rsp = reinterpret_cast<uint64_t>(&CopiedStack[0] + 0x40);

				ULONG TextLen = 0;
				uint64_t TextAddress = GetNtTextSection(&TextLen);

				if (!TextAddress || !TextLen)
					return;

				static bool IsLogged = false;

				if (!IsLogged)
				{
					Log("NTOS .text Address: 0x%llX | Size: 0x%lX\n", TextAddress, TextLen);
					IsLogged = true;
				}

				if (Ctx.Rip >= TextAddress && Ctx.Rip < (TextAddress + TextLen))
				{
					__try
					{
						do
						{
							if (Ctx.Rip < reinterpret_cast<uint64_t>(MmSystemRangeStart) || Ctx.Rsp < reinterpret_cast<uint64_t>(MmSystemRangeStart))
								break;

							if (!ImpCall(MmIsAddressValid, (PVOID)Ctx.Rip) || !ImpCall(MmIsAddressValid, (PVOID)Ctx.Rsp))
								break;

							Results[FuncCount].Rip = Ctx.Rip;
							Results[FuncCount].Rsp = Ctx.Rsp;
							
							uint64_t ImageBase = 0;
							
							auto OldIRQL = ImpCall(KeRaiseIrqlToDpcLevel);
							auto Func = ImpCall(RtlLookupFunctionEntry, Ctx.Rip, &ImageBase, NULL);
							ImpCall(KeLowerIrql, OldIRQL);

							if (!Func)
								break;

							PVOID HandlerData = 0;
							uint64_t EstablisherFrame = 0;

							RtlVirtualUnwind(NULL, ImageBase, Ctx.Rip, Func, &Ctx, &HandlerData, &EstablisherFrame, nullptr);

							++FuncCount;

							if (!Ctx.Rip)
								break;

						} while (FuncCount < 0x20);
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Log("Exception thrown while walking stack for thread 0x%llX\n", (uint64_t)pThread);
					}
				}
			}
		}
	}

	void ScanBigPool(uint64_t Address, bool* Result)
	{
		ULONG Length = 4 * 1024 * 1024;

		PVOID MemPool = ImpCall(ExAllocatePool, NonPagedPool, Length);

		if (NT_SUCCESS(ImpCall(ZwQuerySystemInformation, SystemBigPoolInformation, MemPool, Length, &Length)))
		{
			PSYSTEM_BIGPOOL_INFORMATION pBuf = reinterpret_cast<PSYSTEM_BIGPOOL_INFORMATION>(MemPool);

			for (ULONG i = 0; i < pBuf->Count; i++)
			{
				if ((pBuf->AllocatedInfo->TagUlong == 'enoN' || pBuf->AllocatedInfo->TagUlong == 'tnoC') && Address >= pBuf->AllocatedInfo->VirtualAddress && Address < (pBuf->AllocatedInfo->VirtualAddress + pBuf->AllocatedInfo->SizeInBytes))
				{
					__try
					{
						BYTE ZeroHeaders[0x1000]{};		
						PHYSICAL_ADDRESS phAddress = ImpCall(MmGetPhysicalAddress, (PVOID)pBuf->AllocatedInfo[i].VirtualAddress);

						if (auto PeHeader = ImpCall(MmMapIoSpace, phAddress, PAGE_SIZE, MmNonCached))
						{
							if (memcmp(PeHeader, ZeroHeaders, PAGE_SIZE))
							{
								Log("System thread running in a mapped memory region\n");
								*Result = true;
							}

							ImpCall(MmUnmapIoSpace, PeHeader, PAGE_SIZE);
						}
						else
						{
							Log("Unable to map physmem, but thread is still running in an invalid region!\n");
							*Result = true;
						}
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Log("Exception thrown while scanning bigpoolinfo\n");
					}
				}
			}
		}
	}

	bool LocatePiDDB(PERESOURCE* lock, PRTL_AVL_TABLE* table)
	{
		PVOID PiDDBLockPtr = nullptr, PiDDBCacheTablePtr = nullptr;
		if (!NT_SUCCESS(BBScanSection("PAGE", PiDDBLockPtr_sig, 0, sizeof(PiDDBLockPtr_sig) - 1, reinterpret_cast<PVOID*>(&PiDDBLockPtr)))) 
		{
			Log("Unable to find PiDDBLockPtr sig.\n");
			return false;
		}

		if (!NT_SUCCESS(BBScanSection("PAGE", PiDDBCacheTablePtr_sig, 0, sizeof(PiDDBCacheTablePtr_sig) - 1, reinterpret_cast<PVOID*>(&PiDDBCacheTablePtr))))
		{
			Log("Unable to find PiDDBCacheTablePtr sig.\n");
			return false;
		}

		PiDDBCacheTablePtr = PVOID((uintptr_t)PiDDBCacheTablePtr + 3);

		*lock = (PERESOURCE)(ResolveRelativeAddress(PiDDBLockPtr, 3, 7));
		*table = (PRTL_AVL_TABLE)(ResolveRelativeAddress(PiDDBCacheTablePtr, 3, 7));

		return true;
	}
}

```

`Driver/Utils/skCrypt.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________
Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file
skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+
							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________
MIT License
Copyright (c) 2020 skadro
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
________________________________________________________________________________*/

```

`Driver/Utils/stdint.h`:

```h
//
// stdint.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdint.h> header.
//
#pragma once
#define _STDINT

#ifndef RC_INVOKED

//#include <vcruntime.h>

typedef unsigned int UINT;
typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned long DWORD;
typedef unsigned long long DWORD64;

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64

#define INT_LEAST8_MIN   INT8_MIN
#define INT_LEAST16_MIN  INT16_MIN
#define INT_LEAST32_MIN  INT32_MIN
#define INT_LEAST64_MIN  INT64_MIN
#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX
#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_MIN    INT8_MIN
#define INT_FAST16_MIN   INT32_MIN
#define INT_FAST32_MIN   INT32_MIN
#define INT_FAST64_MIN   INT64_MIN
#define INT_FAST8_MAX    INT8_MAX
#define INT_FAST16_MAX   INT32_MAX
#define INT_FAST32_MAX   INT32_MAX
#define INT_FAST64_MAX   INT64_MAX
#define UINT_FAST8_MAX   UINT8_MAX
#define UINT_FAST16_MAX  UINT32_MAX
#define UINT_FAST32_MAX  UINT32_MAX
#define UINT_FAST64_MAX  UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN   INT64_MIN
#define INTPTR_MAX   INT64_MAX
#define UINTPTR_MAX  UINT64_MAX
#else
#define INTPTR_MIN   INT32_MIN
#define INTPTR_MAX   INT32_MAX
#define UINTPTR_MAX  UINT32_MAX
#endif

#define INTMAX_MIN       INT64_MIN
#define INTMAX_MAX       INT64_MAX
#define UINTMAX_MAX      UINT64_MAX

#define PTRDIFF_MIN      INTPTR_MIN
#define PTRDIFF_MAX      INTPTR_MAX

#ifndef SIZE_MAX
#define SIZE_MAX     UINTPTR_MAX
#endif

#define SIG_ATOMIC_MIN   INT32_MIN
#define SIG_ATOMIC_MAX   INT32_MAX

#define WCHAR_MIN        0x0000
#define WCHAR_MAX        0xffff

#define WINT_MIN         0x0000
#define WINT_MAX         0xffff

#define INT8_C(x)    (x)
#define INT16_C(x)   (x)
#define INT32_C(x)   (x)
#define INT64_C(x)   (x ## LL)

#define UINT8_C(x)   (x)
#define UINT16_C(x)  (x)
#define UINT32_C(x)  (x ## U)
#define UINT64_C(x)  (x ## ULL)

#define INTMAX_C(x)  INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)



#endif // RC_INVOKED

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */


```

`FireShark_AntiCheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31105.61
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Driver", "Driver\Driver.vcxproj", "{25BEAC46-ED49-4DF3-A12D-300BB3553C79}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Client", "Client\Client.vcxproj", "{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DLL", "DLL\DLL.vcxproj", "{6F735F4F-3D54-4359-A88F-0E23B59EB49B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Server", "Server\Server.vcxproj", "{73B673F5-8A77-4F86-AB6A-09A09929CE3B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Debug|x64.ActiveCfg = Debug|x64
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Debug|x64.Build.0 = Debug|x64
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Debug|x64.Deploy.0 = Debug|x64
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Debug|x86.ActiveCfg = Debug|Win32
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Debug|x86.Build.0 = Debug|Win32
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Debug|x86.Deploy.0 = Debug|Win32
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Release|x64.ActiveCfg = Release|x64
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Release|x64.Build.0 = Release|x64
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Release|x64.Deploy.0 = Release|x64
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Release|x86.ActiveCfg = Release|Win32
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Release|x86.Build.0 = Release|Win32
		{25BEAC46-ED49-4DF3-A12D-300BB3553C79}.Release|x86.Deploy.0 = Release|Win32
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Debug|x64.ActiveCfg = Debug|x64
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Debug|x64.Build.0 = Debug|x64
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Debug|x86.ActiveCfg = Debug|Win32
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Debug|x86.Build.0 = Debug|Win32
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Release|x64.ActiveCfg = Release|x64
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Release|x64.Build.0 = Release|x64
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Release|x86.ActiveCfg = Release|Win32
		{9AE432C5-7E22-4DD9-AD5C-5B74D1FED2A5}.Release|x86.Build.0 = Release|Win32
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Debug|x64.ActiveCfg = Debug|x64
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Debug|x64.Build.0 = Debug|x64
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Debug|x86.ActiveCfg = Debug|Win32
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Debug|x86.Build.0 = Debug|Win32
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Release|x64.ActiveCfg = Release|x64
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Release|x64.Build.0 = Release|x64
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Release|x86.ActiveCfg = Release|Win32
		{6F735F4F-3D54-4359-A88F-0E23B59EB49B}.Release|x86.Build.0 = Release|Win32
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Debug|x64.ActiveCfg = Debug|x64
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Debug|x64.Build.0 = Debug|x64
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Debug|x86.ActiveCfg = Debug|Win32
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Debug|x86.Build.0 = Debug|Win32
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Release|x64.ActiveCfg = Release|x64
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Release|x64.Build.0 = Release|x64
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Release|x86.ActiveCfg = Release|Win32
		{73B673F5-8A77-4F86-AB6A-09A09929CE3B}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B946F8F1-ECF0-4F8A-B93D-5DBA7D2056D0}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# KernelMode AntiCheat Demo Project
---------------------------------------------------------------------------------------------------------

Just a sample of how you can code a basic AntiCheat nowadays. Please note that this project is completely unfinished as it was just a part of my Bachelor's Final Project.
This shit has been developed in less that a week so don't expect something serious here as I only made basic process protection as well as basic manually mapped drivers detection.
I'll probably contribute more in the future if I'll get more free time.

# What's done here?

## Driver
- Uses IOCTL for UM client to communicate with the Driver (access allowed for Client & Game only)
- Dynamic imports resolver for both ntoskrnl.exe & CI.dll
- Strip handles for Protected Process via PreObCallback
- Runtime Protected Process pickup via LoadImage Callback
- Protected Process validation by verifying it's Digital Signature via MS Code Integrity (CI.dll) -> honestly the most interesting part here.
- Various System Threads scans for mapped drivers (Win32StartAddress + KernelStack)
- Driver Dispatch scanning for mapped drivers
- PiDDBCache scanning (doing this in 2021 is pretty meme but who cares lol)

### TODO:
MINIFILTER!!! Never do that shitty LoadLibrary hooking in UM I've done here!
The only reason I made it this way is that I had no time to develop proper MiniFilter.
That's probably the first thing I should fix in this project.

## Client
- Load the Driver, spawning Protected Process
- Dump ntoskrnl's PDB for some offsets
- Send requests for Driver to collect Kernel Detection info
- Scan and collect all Windows on-top of test "Game" Window
- Send all the info to the server via sockets

## Server
- Multithreaded TCP done via Poco Library
- Receive data from Clients and update SQL DB using collected data

## DLL
- The most useless part here as only thing it does is just hooking LoadLibrary
- No real internal detection were done here



```

`Server/Globals.h`:

```h
#pragma once
#include <iostream>
#include <Poco/Net/TCPServer.h>
#include <Poco/Net/TCPServerParams.h>
#include <Poco/Net/TCPServerConnectionFactory.h>
#include <Poco/Net/TCPServerConnection.h>
#include <Poco/Net/Socket.h>
#include "Poco/NumberParser.h"
#include "Poco/Logger.h"
#include "Poco/Process.h"
#include "Poco/NamedEvent.h"

using Poco::Net::TCPServer;
using Poco::Net::TCPServerConnectionFilter;
using Poco::Net::TCPServerConnection;
using Poco::Net::TCPServerConnectionFactory;
using Poco::Net::TCPServerConnectionFactoryImpl;
using Poco::Net::StreamSocket;
using Poco::UInt16;
using Poco::NumberParser;
using Poco::Logger;
using Poco::Event;
using Poco::NamedEvent;
using Poco::Process;
using Poco::ProcessImpl;
using Poco::Exception;

#include "Utils/Defs.h"
#include "Server/SQL.h"
#include "Utils/Processing.h"
#include "Server/Server.h"
```

`Server/Server.cpp`:

```cpp

#include "Globals.h"

int main()
{
	try
	{
		Poco::UInt16 port = 3768;

		TCPServer srv(new TCPFactory1(), port);
		srv.start();

		std::cout << "TCP server listening on port " << port << '.'
			<< std::endl << "Press Ctrl-C to quit." << std::endl;

		terminator.wait();
	}
	catch (Exception& exc)
	{
		std::cerr << exc.displayText() << std::endl;
		return 1;
	}
}

```

`Server/Server.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{73b673f5-8a77-4f86-ab6a-09a09929ce3b}</ProjectGuid>
    <RootNamespace>Server</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);D:\poco-1.10.1\Net\include;D:\poco-1.10.1\Foundation\include;C:\Program Files\MySQL\MySQL Server 5.7\include;</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);D:\poco-1.10.1\lib64;C:\Program Files\MySQL\MySQL Server 5.7\lib</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Server.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Globals.h" />
    <ClInclude Include="Server\SQL.h" />
    <ClInclude Include="Server\Server.h" />
    <ClInclude Include="Utils\Defs.h" />
    <ClInclude Include="Utils\Processing.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Server/Server.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\Server">
      <UniqueIdentifier>{d39e6b12-e7a3-4e46-8100-0705fd1ba6aa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Utils">
      <UniqueIdentifier>{4a750dc5-e41d-4569-8d98-086709753ba9}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Server.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Globals.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Server\Server.h">
      <Filter>Source Files\Server</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Defs.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Processing.h">
      <Filter>Source Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Server\SQL.h">
      <Filter>Source Files\Server</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Server/Server.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Server/Server/SQL.h`:

```h
#define _CRT_SECURE_NO_WARNINGS
#define HAVE_STRUCT_TIMESPEC

#pragma comment(lib, "C:\\Program Files\\MySQL\\MySQL Server 5.7\\lib\\libmysql.lib")
#pragma once
#include <Windows.h>
#include <stdio.h>
#include <string>
#include <iostream>
#include <conio.h>
#include <cstring>
//#include <my_global.h>
#include <mysql.h>
#include <time.h>
#include <sstream>
#include <urlmon.h>
#include <wincrypt.h>

#pragma comment(lib, "ws2_32.lib")
#pragma comment (lib, "urlmon.lib")

namespace SQL
{
	MYSQL* Link;
	MYSQL_RES* Result = 0;
	MYSQL_ROW Row;

	std::string Host = ("CENSORED");
	std::string User = ("CENSORED");
	std::string Pass = ("CENSORED");
	std::string DBase = ("CENSORED");

	bool Connect()
	{
		Link = mysql_init(0);

		if (!mysql_real_connect(Link, Host.c_str(), User.c_str(), Pass.c_str(), DBase.c_str(), 0, 0, 0))
			return false;

		return true;
	}

	void Disconnect()
	{
		mysql_close(Link);
	}

	inline std::string MySQL_Ret(std::string Request)
	{
		if (mysql_query(Link, Request.c_str()))
			return ("E");

		std::string RetVal;
		Result = mysql_store_result(Link);

		if (Result)
			while (Row = mysql_fetch_row(Result))
				RetVal += Row[0];
		else
			RetVal = ("E");

		return RetVal;
	}

	inline bool MySQL(std::string Request)
	{
		if (mysql_query(Link, Request.c_str()))
			return false;

		return true;
	}
}
```

`Server/Server/Server.h`:

```h
#pragma once

void EncDec(char* Buff, uint32_t Size)
{
	for (uint32_t i = 0; i < Size; i++)
		Buff[i] = (char)(Buff[i] ^ ((i + 13 * i + 93) + 46 + i));
}

namespace
{
	class ClientConnection1 : public TCPServerConnection
	{
	public:
		ClientConnection1(const StreamSocket& s) : TCPServerConnection(s)
		{
		}

		void run()
		{
			StreamSocket& ss = socket();
			try
			{
				char InpBuf[3192];
				char OutBuf[8];

				int n = ss.receiveBytes(InpBuf, sizeof(InpBuf));

				while (n > 0)
				{
					uint64_t Success = 1337;

					SERVER_INFO Input = { 0 };
					EncDec(InpBuf, sizeof(SERVER_INFO));
					memcpy(&Input, &InpBuf, sizeof(SERVER_INFO));

					int DetectionScore = 0;
					Processing::CalcScore(&Input, &DetectionScore);

					if (SQL::Connect())
					{
						Processing::SendInfo(&Input, DetectionScore);
						SQL::Disconnect();
					}

					memcpy(&OutBuf, &Success, sizeof(uint64_t));
					EncDec(OutBuf, sizeof(uint64_t));

					ss.sendBytes(OutBuf, sizeof(uint64_t), 0);

					n = ss.receiveBytes(InpBuf, sizeof(InpBuf));
				}

			}
			catch (Exception& exc)
			{
				std::cerr << ("ClientConnection: ") << exc.displayText() << std::endl;
			}
		}
	};

	typedef TCPServerConnectionFactoryImpl<ClientConnection1> TCPFactory1;

#if defined(POCO_OS_FAMILY_WINDOWS)
	NamedEvent terminator(ProcessImpl::terminationEventName(Process::id()));
#else
	Event terminator;
#endif
}
```

`Server/Utils/Defs.h`:

```h
#pragma once

typedef struct _SCAN_RESULTS
{
	uint32_t InvalidThreads;
	uint32_t TrampolineThreads;
	uint32_t InvalidStacks;
	uint32_t InvalidDispatches;
	bool PiDDB_VulnerableDriver;
} SCAN_RESULTS, * PSCAN_RESULTS;

typedef struct _WINDOW_STRUCT
{
	char WindowName[50];
	char ClassName[50];
	char ProcessName[40];
	bool IsSigned;
	LONG Style;
	LONG ExStyle;
	RECT Rect;
} WINDOW_STRUCT, * PWINDOW_STRUCT;

typedef struct _OVERLAY_RESULTS
{
	WINDOW_STRUCT Windows[15];
} OVERLAY_RESULTS, * POVERLAY_RESULTS;

typedef struct _SERVER_INFO
{
	char Username[30];
	RECT GameWindowRect;
	SCAN_RESULTS KernelDetections;
	OVERLAY_RESULTS OverlayInfo;
} SERVER_INFO, * PSERVER_INFO;

```

`Server/Utils/Processing.h`:

```h
#pragma once

namespace Processing
{
	void CalcScore(PSERVER_INFO pInfo, int* DetectionScore)
	{
		int Score = 0;

		int GameWindowSizeX = pInfo->GameWindowRect.right - pInfo->GameWindowRect.left;
		int GameWindowSizeY = pInfo->GameWindowRect.bottom - pInfo->GameWindowRect.top;

		for (int i = 0; i < 15; i++)
		{
			int PreScore = 0;

			WINDOW_STRUCT Struct = pInfo->OverlayInfo.Windows[i];

			int WindowSizeX = Struct.Rect.right - Struct.Rect.left;
			int WindowSizeY = Struct.Rect.bottom - Struct.Rect.top;

			if (Struct.IsSigned == false)
				PreScore += 3;

			if ((Struct.ExStyle & WS_EX_TRANSPARENT) && (Struct.ExStyle & WS_EX_TOPMOST) && (Struct.ExStyle & WS_EX_LAYERED))
				PreScore += 4;
			else if ((Struct.ExStyle & WS_EX_TRANSPARENT) && (Struct.ExStyle & WS_EX_LAYERED))
				PreScore += 5;
			else if ((Struct.ExStyle & WS_EX_TOPMOST) && (Struct.ExStyle & WS_EX_LAYERED))
				PreScore += 3;
			else if (Struct.ExStyle & WS_EX_LAYERED)
				PreScore += 2;

			if ((GameWindowSizeX - WindowSizeX) < 200 && (GameWindowSizeY - WindowSizeY) < 200)
				PreScore *= 2;

			if (PreScore > Score)
				Score = PreScore;
		}

		SCAN_RESULTS Struct = pInfo->KernelDetections;

		if (Struct.InvalidDispatches)
			Score += 5;

		if (Struct.InvalidThreads)
			Score += 5;

		if (Struct.InvalidStacks)
			Score += 2;

		if (Struct.TrampolineThreads)
			Score += 3;

		if (Struct.PiDDB_VulnerableDriver)
			Score += 8;

		*DetectionScore = Score;
	}

	void SendInfo(PSERVER_INFO pInfo, int DetectionScore)
	{
		std::string Username = pInfo->Username;

		int Ban = 0;

		if (DetectionScore >= 15)
			Ban = 1;

		std::string Req1 = ("SELECT `Score` FROM `DetectionScore` WHERE `Username`='") + Username +("'");
		std::string Ret1 = SQL::MySQL_Ret(Req1);

		if (Ret1 != "E" && Ret1.size() > 0)
		{
			int DetSc = atoi(Ret1.c_str());

			if (DetSc < DetectionScore)
			{
				std::string Req2 = ("UPDATE `DetectionScore` SET `Score` = '") + std::to_string(DetectionScore) + ("',`IsBanned` = '") + std::to_string(Ban) + ("' WHERE `Username` = '") + Username + "'";
				SQL::MySQL(Req2);
			}
		}
		else
		{
			std::string Req2 = ("INSERT INTO `DetectionScore` (`Username`, `IsBanned`, `Score`) VALUES ('") + Username + ("', '") + std::to_string(Ban) + ("', '") + std::to_string(DetectionScore) + ("')");
			SQL::MySQL(Req2);
		}
	
		for (int i = 0; i < 15; i++)
		{
			std::string WindowName = pInfo->OverlayInfo.Windows[i].WindowName;
			std::string ClassName = pInfo->OverlayInfo.Windows[i].ClassName;
			std::string ProcessName = pInfo->OverlayInfo.Windows[i].ProcessName;

			if (ProcessName.size() < 3)
				continue;

			std::string Req3 = ("SELECT `ExStyle` FROM `Overlays` WHERE `Username`='") + Username + ("' AND `Name`='") + WindowName + ("' AND `Class`='") + ClassName + ("' AND `Process`='") + ProcessName + "'";
			std::string Ret3 = SQL::MySQL_Ret(Req3);

			if (Ret3.size() < 5)
			{
				int SizeX = pInfo->OverlayInfo.Windows[i].Rect.right - pInfo->OverlayInfo.Windows[i].Rect.left;
				int SizeY = pInfo->OverlayInfo.Windows[i].Rect.bottom - pInfo->OverlayInfo.Windows[i].Rect.top;

				std::string Size = std::to_string(SizeX) + "/" + std::to_string(SizeY);
				std::string Style = std::to_string(pInfo->OverlayInfo.Windows[i].Style);
				std::string ExStyle = std::to_string(pInfo->OverlayInfo.Windows[i].ExStyle);

				std::string Req4 = ("INSERT INTO `Overlays` (`Username`, `Process`, `Name`, `Class`, `Style`, `ExStyle`, `Size`, `IsSigned`) VALUES ('") + Username + ("', '") + ProcessName + ("', '") + WindowName + 
					("', '") + ClassName + ("', '") + Style + ("', '") + ExStyle + ("', '") + Size + ("', '") + std::to_string(pInfo->OverlayInfo.Windows[i].IsSigned) + ("')");

				SQL::MySQL(Req4);
			}
		}
	}
}


```