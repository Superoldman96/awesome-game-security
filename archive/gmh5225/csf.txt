Project Path: arc_gmh5225_csf_mt6npn6r

Source Tree:

```txt
arc_gmh5225_csf_mt6npn6r
├── CMakeLists.txt
├── LICENCE
├── README.md
├── config.cfg
├── csf
│   ├── CMakeLists.txt
│   ├── include
│   │   ├── cs
│   │   │   ├── cs_convar.h
│   │   │   ├── cs_engine.h
│   │   │   ├── cs_inputsystem.h
│   │   │   ├── cs_interfaces.h
│   │   │   ├── cs_netvars.h
│   │   │   ├── cs_player.h
│   │   │   └── cs_types.h
│   │   ├── u_config.h
│   │   └── u_process.h
│   └── src
│       ├── aimassist.cpp
│       ├── cs
│       │   ├── cs_convar.cpp
│       │   ├── cs_engine.cpp
│       │   ├── cs_inputsystem.cpp
│       │   ├── cs_interfaces.cpp
│       │   ├── cs_netvars.cpp
│       │   └── cs_player.cpp
│       └── u_config.cpp
├── makeconfig
├── run
└── rx

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.6)
add_subdirectory(rx)
add_subdirectory(csf)


```

`LICENCE`:

```
free use for non commercial projects
credit me if you like.


```

`README.md`:

```md
# CSF
##### external sdk for csgo
----
## usage
* git clone https://github.com/ekknod/csf --recursive
* cd csf
* ./run
----
## what in future?
* windows support
----
## features
* external interfaces
* external netvars
* external convars
----
## video
[![IMAGE ALT TEXT](https://i.ytimg.com/vi/P655rd45cQ8/maxresdefault.jpg)](https://www.youtube.com/watch?v=P655rd45cQ8a "linux csgo csf tutorial")
----
## licence
* free use for non commercial projects
* credit me if you like.

```

`config.cfg`:

```cfg
[aimbot]
{
    enable: 1
    button: 107
    fov:    2.000000
    smooth: 10.000000
    bone:   8
}
[triggerbot]
{
    enable: 1
    button: 111
}

```

`csf/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 2.6)
project(csf)
set(OUT csf)

add_executable ( ${OUT}
    src/aimassist.cpp src/u_config.cpp src/cs/cs_convar.cpp src/cs/cs_inputsystem.cpp src/cs/cs_netvars.cpp src/cs/cs_engine.cpp src/cs/cs_interfaces.cpp src/cs/cs_player.cpp )


set_target_properties(${OUT} PROPERTIES LINKER_LANGUAGE CXX)


set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wall -DNDEBUG -Wno-format-truncation -Wno-strict-aliasing -O2 -s")
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Wno-format-truncation -Wno-strict-aliasing")

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()
target_link_libraries(${OUT} rx "-Wall -DNDEBUG -pthread -s -O2")


```

`csf/include/cs/cs_convar.h`:

```h
#ifndef CS_CONVAR_H
#define CS_CONVAR_H

#include "cs_types.h"
#include "../../../rx/include/rx_types.h"

class cs_convar
{
	uintptr_t self;

public:
	SHORT_STRING GetName(void);
	void SetString(const char *v);
	void SetInt(int v);
	void SetFloat(float v);
	SHORT_STRING GetString(void);
	int GetInt(void);
	float GetFloat(void);
};

namespace cvar
{

	cs_convar find(const char *name);

}

#endif // CS_CONVAR_H

```

`csf/include/cs/cs_engine.h`:

```h
#ifndef CS_ENGINE_H
#define CS_ENGINE_H

#include "cs_interfaces.h"
#include "cs_netvars.h"
#include "cs_convar.h"
#include "cs_inputsystem.h"
#include "cs_player.h"

/*
 * initializes everything, must be called first
 */
bool cs_initialize(void);

namespace engine
{
	int IsRunning(void);
	int GetLocalPlayer(void);
	vec3 GetViewAngles(void);
	void SetViewAngles(vec3 v);
	int GetMaxClients(void);
	bool IsInGame(void);
}

namespace entity
{
	cs_player GetClientEntity(int index);
}

#endif // CS_ENGINE_H

```

`csf/include/cs/cs_inputsystem.h`:

```h
#ifndef CS_INPUTSYSTEM_H
#define CS_INPUTSYSTEM_H

#include "cs_types.h"
namespace inputsystem
{
	typedef enum _CS_BUTTONCODE : int
	{
		MOUSE_1 = 107,
		MOUSE_2 = 108,
		MOUSE_3 = 109,
		MOUSE_4 = 110,
		MOUSE_5 = 111
	} CS_BUTTONCODE;
	bool IsButtonDown(CS_BUTTONCODE button);
	vec2i GetMouseAnalog(void);
	vec2i GetMouseAnalogDelta(void);
}

#endif // CS_INPUTSYSTEM_H

```

`csf/include/cs/cs_interfaces.h`:

```h
#ifndef CS_INTERFACES_H
#define CS_INTERFACES_H

#include <inttypes.h>

class cs_virtual_table
{
	uintptr_t self;

public:
	uintptr_t address(void) const;
	uintptr_t function(uint32_t index);
};

class cs_interface_reg
{
	uintptr_t self;

public:
	cs_virtual_table find(const char *name);
};

namespace interfaces
{
	cs_interface_reg find(const char *module_name);
}

#endif // CS_INTERFACES_H

```

`csf/include/cs/cs_netvars.h`:

```h
#ifndef CS_NETVARS_H
#define CS_NETVARS_H

#include <inttypes.h>

class cs_netvar_table
{
	uintptr_t self;

public:
	uint32_t offset(const char *name);

private:
	uint32_t offset_ex(uintptr_t, const char *);
};

namespace netvars
{
	cs_netvar_table find(const char *name);
}

#endif // CS_NETVARS_H

```

`csf/include/cs/cs_player.h`:

```h
#ifndef CS_PLAYER_H
#define CS_PLAYER_H

#include "cs_types.h"

class cs_player
{
	uintptr_t self;

public:
	int GetTeam(void);
	int GetHealth(void);
	int GetLifeState(void);
	int GetTickCount(void);
	int GetShotsFired(void);
	bool IsScoped(void);
	bool IsDormant(void);
	uintptr_t GetWeapon(void);
	vec3 GetOrigin(void);
	vec3 GetVecView(void);
	vec3 GetEyePos(void);
	vec3 GetVecVelocity(void);
	vec3 GetVecPunch(void);
	int GetFov(void);
	void GetBoneMatrix(int index, matrix3x4_t *out);
	bool IsValid(void);
};

#endif // CS_PLAYER_H

```

`csf/include/cs/cs_types.h`:

```h
#ifndef CS_TYPES_H
#define CS_TYPES_H

#include <inttypes.h>

typedef struct
{
	float x, y, z;
} vec3;

typedef struct
{
	int x, y;
} vec2i;

typedef float matrix3x4_t[3][4];

#endif // CS_TYPES_H

```

`csf/include/u_config.h`:

```h
#ifndef U_CONFIG_H
#define U_CONFIG_H

typedef __SIZE_TYPE__ size_t;

class u_config_table
{
	int _fd;

public:
	int GetInt(const char *name);
	float GetFloat(const char *name);

private:
	bool SetPos(const char *name);
	bool GetVal(const char *name, char buffer[32]);
};

class u_config
{
	const char *_path;
	int _fd;

public:
	u_config(const char *path);
	~u_config(void);
	bool exists(void);
	void open_config(void);
	void close_config(void);
	u_config_table table(const char *name);
	void write_config(void *buffer, size_t length);
};

#endif // U_CONFIG_H

```

`csf/include/u_process.h`:

```h
#ifndef U_PROCESS_H
#define U_PROCESS_H

#include "../../rx/rx.h"
#include <inttypes.h>
#include <string.h>
#include <stdio.h>

class u_process
{
	const char *_name;
	rx_handle _handle;

public:
	u_process(const char *name) : _name(name), _handle(0) {}
	~u_process(void) { detach(); }
	inline bool attach(void)
	{
		rx_handle s = rx_create_snapshot(RX_SNAP_TYPE_PROCESS, 0);
		RX_PROCESS_ENTRY e;

		while (rx_next_process(s, &e))
		{
			if (strcmp(e.name, _name) == 0)
			{
				_handle = rx_open_process(e.pid, RX_ALL_ACCESS);
				break;
			}
		}
		rx_close_handle(s);
		return _handle != 0;
	}
	inline void detach(void)
	{
		if (_handle != 0)
		{
			rx_close_handle(_handle);
			_handle = 0;
		}
	}
	inline int exists(void)
	{
		return rx_process_exists(_handle);
	}
	inline uintptr_t find_module(const char *name)
	{
		return rx_find_module_ex(_handle, name);
	}
	inline uintptr_t module_base(uintptr_t module)
	{
		return rx_module_base_ex(_handle, module);
	}
	inline LONG_STRING module_path(uintptr_t module)
	{
		return rx_module_path_ex(_handle, module);
	}
	inline uintptr_t find_export(uintptr_t module, const char *name)
	{
		return rx_find_export_ex(_handle, module, name);
	}
	template <typename t>
	inline t read(uintptr_t address)
	{
		t v;
		rx_read_process(_handle, address, &v, sizeof(t));
		return v;
	}
	template <typename t>
	inline t read_ptr(uintptr_t address)
	{
		return read<t>(read<uintptr_t>(address));
	}
	inline __ssize_t read(uintptr_t address, void *buffer, size_t length)
	{
		return rx_read_process(_handle, address, buffer, length);
	}
	inline __ssize_t read_ptr(uintptr_t address, void *buffer, size_t length)
	{
		return read(read<uintptr_t>(address), buffer, length);
	}
	template <typename t>
	inline void write(uintptr_t address, t value)
	{
		rx_write_process(_handle, address, &value, sizeof(t));
	}
	template <typename t>
	inline void write_ptr(uintptr_t address, t value)
	{
		write<t>(read<uintptr_t>(address), value);
	}
};

#endif // U_PROCESS_H

```

`csf/src/aimassist.cpp`:

```cpp
#include "../include/u_config.h"
#include "../include/cs/cs_engine.h"
#include "../../rx/include/rx_input.h"
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

class config
{
	const char *_path;

public:
	struct
	{
		bool enable;
		inputsystem::CS_BUTTONCODE button;
		float fov;
		float smooth;
		int bone;
	} aimbot;

	struct
	{
		bool enable;
		inputsystem::CS_BUTTONCODE button;
	} triggerbot;

	config(const char *path) : _path(path)
	{
		u_config c(path);
		u_config_table t;

		if (!c.exists())
		{
			aimbot.enable = true;
			aimbot.button = inputsystem::MOUSE_1;
			aimbot.fov = 2.0f;
			aimbot.smooth = 10.0f;
			aimbot.bone = 8;
			triggerbot.enable = true;
			triggerbot.button = inputsystem::MOUSE_5;
		}
		else
		{
			c.open_config();
			t = c.table("[aimbot]");
			aimbot.enable = t.GetInt("enable");
			aimbot.button = (inputsystem::CS_BUTTONCODE)t.GetInt("button");
			aimbot.fov = t.GetFloat("fov");
			aimbot.smooth = t.GetFloat("smooth");
			aimbot.bone = t.GetInt("bone");
			t = c.table("[triggerbot]");
			triggerbot.enable = t.GetInt("enable");
			triggerbot.button = (inputsystem::CS_BUTTONCODE)t.GetInt("button");
			c.close_config();
		}
		aimbot.fov = aimbot.fov / 180.0f;
		// casts between pointers / enums, really c++ :DDDDDDDDD
	}
	~config(void)
	{
		if (exists())
		{
			update();
		}
	}
	bool exists(void)
	{
		return u_config(_path).exists();
	}
	void update(void)
	{
		u_config c(_path);
		int length;
		char buffer[512];

		aimbot.fov *= 180.0f;
		length = snprintf(
		    buffer,
		    sizeof(buffer),
		    "[aimbot]\n{\n"
		    "    enable: %d\n"
		    "    button: %d\n"
		    "    fov:    %f\n"
		    "    smooth: %f\n"
		    "    bone:   %d\n}\n"
		    "[triggerbot]\n{\n"
		    "    enable: %d\n"
		    "    button: %d\n}\n",
		    aimbot.enable,
		    aimbot.button,
		    aimbot.fov,
		    aimbot.smooth,
		    aimbot.bone,
		    triggerbot.enable,
		    triggerbot.button);
		aimbot.fov /= 180.0f;
		c.open_config();
		c.write_config(buffer, length);
		c.close_config();
	}
	void print(void)
	{
		aimbot.fov *= 180.0f;
		printf(
		    "[aimbot]\n{\n"
		    "    enable: %d\n"
		    "    button: %d\n"
		    "    fov:    %f\n"
		    "    smooth: %f\n"
		    "    bone:   %d\n}\n"
		    "[triggerbot]\n{\n"
		    "    enable: %d\n"
		    "    button: %d\n}\n",
		    aimbot.enable,
		    aimbot.button,
		    aimbot.fov,
		    aimbot.smooth,
		    aimbot.bone,
		    triggerbot.enable,
		    triggerbot.button);
		aimbot.fov /= 180.0f;
	}
};

static config _cfg("config.cfg");
static rx_handle _mouse;
static cs_player _target;
static int _target_bone;
static cs_convar _sensitivity;
static cs_convar _mp_teammates_are_enemies;
static float _flsensitivity;
static int _current_tick, _previous_tick;

static void sincos(float radians, float *sine, float *cosine)
{
	*sine = (float)sin(radians);
	*cosine = (float)cos(radians);
}

#define RAD2DEG(x) ((float)(x) * (float)(180.f / 3.14159265358979323846f))
#define DEG2RAD(x) ((float)(x) * (float)(3.14159265358979323846f / 180.f))

static void angle_vec(vec3 angles, vec3 *forward)
{
	float sp, sy, cp, cy;
	sincos(DEG2RAD(angles.x), &sp, &cp);
	sincos(DEG2RAD(angles.y), &sy, &cy);
	forward->x = cp * cy;
	forward->y = cp * sy;
	forward->z = -sp;
}

static float vec_dot(vec3 v0, vec3 v1)
{
	return (v0.x * v1.x + v0.y * v1.y + v0.z * v1.z);
}

static float vec_length(vec3 v)
{
	return (v.x * v.x + v.y * v.y + v.z * v.z);
}

static vec3 vec_sub(vec3 p0, vec3 p1)
{
	vec3 r;

	r.x = p0.x - p1.x;
	r.y = p0.y - p1.y;
	r.z = p0.z - p1.z;
	return r;
}

static float vec_length_sqrt(vec3 p0)
{
	return sqrt(p0.x * p0.x + p0.y * p0.y + p0.z * p0.z);
}

static vec3 vec_delta(vec3 p0, vec3 p1)
{
	vec3 d;
	float l;

	d = vec_sub(p0, p1);
	l = (float)vec_length_sqrt(d);
	d.x /= l;
	d.y /= l;
	d.z /= l;
	return d;
}

static float vec_distance(vec3 p0, vec3 p1)
{
	return vec_length_sqrt(vec_sub(p0, p1));
}

static void vec_clamp(vec3 *v)
{
	if (v->x > 89.0f && v->x <= 180.0f)
	{
		v->x = 89.0f;
	}
	if (v->x > 180.0f)
	{
		v->x = v->x - 360.0f;
	}
	if (v->x < -89.0f)
	{
		v->x = -89.0f;
	}
	v->y = fmodf(v->y + 180, 360) - 180;
	v->z = 0;
}

static void vec_normalize(vec3 *vec)
{
	float radius;

	radius = 1.f / (float)(sqrt(vec->x * vec->x + vec->y * vec->y + vec->z * vec->z) + 1.192092896e-07f);
	vec->x *= radius, vec->y *= radius, vec->z *= radius;
}

static vec3 vec_transform(vec3 p0, matrix3x4_t p1)
{
	vec3 v;

	v.x = (p0.x * p1[0][0] + p0.y * p1[0][1] + p0.z * p1[0][2]) + p1[0][3];
	v.y = (p0.x * p1[1][0] + p0.y * p1[1][1] + p0.z * p1[1][2]) + p1[1][3];
	v.z = (p0.x * p1[2][0] + p0.y * p1[2][1] + p0.z * p1[2][2]) + p1[2][3];
	return v;
}

vec3 vec_atd(vec3 vangle)
{
	double y[2], p[2];

	vangle.x *= (3.14159265358979323846f / 180.f);
	vangle.y *= (3.14159265358979323846f / 180.f);
	y[0] = sin(vangle.y), y[1] = cos(vangle.y);
	p[0] = sin(vangle.x), p[1] = cos(vangle.x);
	vangle.x = (float)(p[1] * y[1]);
	vangle.y = (float)(p[1] * y[0]);
	vangle.z = (float)-p[0];
	return vangle;
}

typedef struct
{
	int bone;
	float radius;
	vec3 min;
	vec3 max;
} HITBOX;

static HITBOX _hitbox_list[2][6] = {
    {{5, 6.200000f, {4.800000f, 0.150000f, -4.100000f}, {4.800000f, 0.150000f, 4.100000f}},
     {4, 6.500000f, {3.800000f, 0.800000f, -2.400000f}, {3.800000f, 0.400000f, 2.400000f}},
     {3, 6.000000f, {1.400000f, 0.800000f, 3.100000f}, {1.400000f, 0.800000f, -3.100000f}},
     {0, 6.000000f, {-2.700000f, 1.100000f, -3.200000f}, {-2.700000f, 1.100000f, 3.200000f}},
     {7, 3.500000f, {-1.300000f, -0.200000f, 0.000000f}, {1.400000f, 0.600000f, 0.000000f}},
     {8, 4.300000f, {-1.100000f, 1.400000f, 0.100000f}, {3.000000f, 0.800000f, 0.100000f}}},

    {{5, 6.200000f, {4.800000f, 0.150000f, -4.100000f}, {4.800000f, 0.150000f, 4.100000f}},
     {4, 6.500000f, {3.800000f, 0.800000f, -2.400000f}, {3.800000f, 0.400000f, 2.400000f}},
     {3, 6.000000f, {1.400000f, 0.800000f, 3.100000f}, {1.400000f, 0.800000f, -3.100000f}},
     {0, 6.000000f, {-2.700000f, 1.100000f, -3.200000f}, {-2.700000f, 1.100000f, 3.200000f}},
     {7, 3.500000f, {-1.300000f, 0.900000f, 0.000000f}, {1.400000f, 1.300000f, 0.000000f}},
     {8, 3.200000f, {-0.200000f, 1.100000f, 0.000000f}, {3.600000f, 0.100000f, 0.000000f}}}};

static bool vec_min_max(vec3 eye, vec3 dir, vec3 min, vec3 max, float radius)
{
	vec3 delta;
	uint32_t i;
	vec3 q;
	float v;

	//
	// original maths by superdoc1234
	//
	delta = vec_delta(max, min);
	for (i = 0; i < vec_distance(min, max); i++)
	{
		q.x = min.x + delta.x * (float)i - eye.x;
		q.y = min.y + delta.y * (float)i - eye.y;
		q.z = min.z + delta.z * (float)i - eye.z;
		if ((v = vec_dot(q, dir)) < 1.0f)
		{
			return false;
		}
		v = radius * radius - (vec_length(q) - v * v);
		if (v <= -100.f)
		{
			return false;
		}
		if (v >= 1.19209290E-07F)
		{
			return true;
		}
	}
	return false;
}

static int crosshair_id(vec3 vangle, cs_player self)
{
	vec3 dir, eye;
	int i;
	cs_player entity;
	int id, j;
	matrix3x4_t matrix;
	bool status;

	dir = vec_atd(vangle);
	eye = self.GetEyePos();
	for (i = 1; i < engine::GetMaxClients(); i++)
	{
		entity = entity::GetClientEntity(i);
		if (!entity.IsValid())
			continue;
		id = entity.GetTeam();
		if (!_mp_teammates_are_enemies.GetInt() && self.GetTeam() == id)
			continue;

		id -= 2;
		for (j = 6; j--;)
		{
			entity.GetBoneMatrix(_hitbox_list[id][j].bone, &matrix);
			status = vec_min_max(
			    eye,
			    dir,
			    vec_transform(_hitbox_list[id][j].min, matrix),
			    vec_transform(_hitbox_list[id][j].max, matrix),
			    _hitbox_list[id][j].radius);
			if (status)
			{
				return i;
			}
		}
	}
	return 0;
}

static void vec_angles(vec3 forward, vec3 *angles)
{
	float tmp, yaw, pitch;

	if (forward.y == 0.f && forward.x == 0.f)
	{
		yaw = 0;
		if (forward.z > 0)
		{
			pitch = 270;
		}
		else
		{
			pitch = 90.f;
		}
	}
	else
	{
		yaw = (float)(atan2(forward.y, forward.x) * 180.f / 3.14159265358979323846f);
		if (yaw < 0)
		{
			yaw += 360.f;
		}
		tmp = (float)sqrt(forward.x * forward.x + forward.y * forward.y);
		pitch = (float)(atan2(-forward.z, tmp) * 180.f / 3.14159265358979323846f);
		if (pitch < 0)
		{
			pitch += 360.f;
		}
	}
	angles->x = pitch;
	angles->y = yaw;
	angles->z = 0.f;
}

static float get_fov(vec3 vangle, vec3 angle)
{
	vec3 a0, a1;

	angle_vec(vangle, &a0);
	angle_vec(angle, &a1);
	return RAD2DEG(acos(vec_dot(a0, a1) / vec_length(a0)));
}

static vec3 get_target_angle(cs_player self, cs_player target, int bone_id)
{
	matrix3x4_t m;
	vec3 c, p;

	target.GetBoneMatrix(bone_id, &m);
	c = self.GetEyePos();
	m[0][3] -= c.x, m[1][3] -= c.y, m[2][3] -= c.z;
	c.x = m[0][3], c.y = m[1][3], c.z = m[2][3];
	vec_normalize(&c);
	vec_angles(c, &c);
	if (self.GetShotsFired() > 1)
	{
		p = self.GetVecPunch();
		c.x -= p.x * 2.0f, c.y -= p.y * 2.0f, c.z -= p.z * 2.0f;
	}
	vec_clamp(&c);
	return c;
}

static bool get_target(cs_player self, vec3 vangle)
{
	float best_fov;
	int i;
	cs_player entity;
	float fov;
	int j;

	best_fov = 9999.0f;
	for (i = 1; i < engine::GetMaxClients(); i++)
	{

		entity = entity::GetClientEntity(i);
		if (!entity.IsValid())
			continue;

		if (!_mp_teammates_are_enemies.GetInt() && self.GetTeam() == entity.GetTeam())
			continue;

		if (_cfg.aimbot.bone == 0)
		{
			for (j = 7; j--;)
			{
				fov = get_fov(vangle, get_target_angle(self, entity, _hitbox_list[0][j].bone));
				if (fov < best_fov)
				{
					best_fov = fov;
					_target = entity;
					_target_bone = _hitbox_list[0][j].bone;
				}
			}
		}
		else
		{
			fov = get_fov(vangle, get_target_angle(self, entity, _cfg.aimbot.bone));
			if (fov < best_fov)
			{
				best_fov = fov;
				_target = entity;
				_target_bone = _cfg.aimbot.bone;
			}
		}
	}
	return best_fov != 9999.0f;
}

static void mouse_move(int x, int y)
{
	rx_send_input_axis(_mouse, RX_MOUSE_X, x);
	rx_send_input_axis(_mouse, RX_MOUSE_Y, y);
}

static void mouse1_down(void)
{
	rx_send_input_button(_mouse, RX_BTN_LEFT, 1);
}

static void mouse1_up(void)
{
	rx_send_input_button(_mouse, RX_BTN_LEFT, 0);
}

static void aim_at_target(vec3 vangle, vec3 angle)
{
	float x, y, sx, sy;

	y = vangle.x - angle.x, x = vangle.y - angle.y;
	if (y > 89.0f)
		y = 89.0f;
	else if (y < -89.0f)
		y = -89.0f;
	if (x > 180.0f)
		x -= 360.0f;
	else if (x < -180.0f)
		x += 360.0f;

	if (abs(x) / 180.0f >= _cfg.aimbot.fov)
		return;
	if (abs(y) / 89.0f >= _cfg.aimbot.fov)
		return;
	x = ((x / _flsensitivity) / 0.022f);
	y = ((y / _flsensitivity) / -0.022f);
	if (_cfg.aimbot.smooth)
	{
		sx = 0.0f, sy = 0.0f;
		if (sx < x)
		{
			sx += 1.0f + (x / _cfg.aimbot.smooth);
		}
		else if (sx > x)
		{
			sx -= 1.0f - (x / _cfg.aimbot.smooth);
		}
		if (sy < y)
		{
			sy += 1.0f + (y / _cfg.aimbot.smooth);
		}
		else if (sy > y)
		{
			sy -= 1.0f - (y / _cfg.aimbot.smooth);
		}
	}
	else
	{
		sx = x, sy = y;
	}
	if (_current_tick - _previous_tick > 0)
	{
		_previous_tick = _current_tick;
		mouse_move((int)sx, (int)sy);
	}
}

static void aim(void)
{
	cs_player self;
	vec3 vangle;
	

	self = entity::GetClientEntity(engine::GetLocalPlayer());
	vangle = engine::GetViewAngles();
	_current_tick = self.GetTickCount();
	_flsensitivity = _sensitivity.GetFloat();

	if (self.IsScoped())
	{
		_flsensitivity = (self.GetFov() / 90.0f) * _flsensitivity;
	}

	bool triggerbot_button = inputsystem::IsButtonDown(_cfg.triggerbot.button);
	bool aimbot_button = inputsystem::IsButtonDown(_cfg.aimbot.button);
	bool aimassist_button = triggerbot_button+aimbot_button;

	if (_cfg.triggerbot.enable && triggerbot_button)
	{
		if (crosshair_id(vangle, self))
		{
			mouse1_down();
			usleep(10000);
			mouse1_up();
		}
	}

	if (_cfg.aimbot.enable)
	{
		if (aimassist_button)
		{
			
			if (!_target.IsValid() && !get_target(self, vangle))
				return;
			aim_at_target(vangle, get_target_angle(self, _target, _target_bone));
		}
		else
		{
			_target = {};
		}
	}
}

static int parameters(int argc, char **argv)
{
	int i;

	if (argc == 1)
	{
		if (!_cfg.exists())
		{
			printf("[!]config file not found!\n");
			goto help;
		}
		if (getuid() != 0)
		{
			printf("[!]root is required\n");
			return -1;
		}
		return 0;
	}

	for (i = 1; i < argc; i++)
	{
		if (!strcmp(argv[i], "--help"))
		{
		help:
			printf(
			    "[*]commands:\n"
			    "   --read:  print config\n"
			    "   --write: write new config file to disk\n");
			return -1;
		}
		if (!strcmp(argv[i], "--write"))
		{
			if (getuid() == 0)
			{
				printf("[!]writing config file with root access is not allowed!\n");
			}
			else
			{
				_cfg.update();
			}
			return -1;
		}
		if (!strcmp(argv[i], "--read"))
		{
			if (_cfg.exists())
			{
				_cfg.print();
			}
			else
			{
				printf(
				    "[!]config file not found!\n"
				    "   --write: write new config file to disk\n");
			}
			return -1;
		}
	}
	printf("[*]commands: --help\n");
	return -1;
}

int main(int argc, char **argv)
{
	if (parameters(argc, argv) == -1)
		return 0;
	if (!cs_initialize())
	{
		printf("[!]game is not running!\n");
		return -1;
	}
	_mouse = rx_open_input(RX_INPUT_TYPE_MOUSE, RX_INPUT_MODE_SEND);
	if (_mouse == 0)
	{
		printf("[!]mouse device not found\n");
		return -1;
	}
	_sensitivity = cvar::find("sensitivity");
	_mp_teammates_are_enemies = cvar::find("mp_teammates_are_enemies");
	while (engine::IsRunning())
	{
		if (engine::IsInGame())
		{
			aim();
			usleep(1000);
		}
	}
	rx_close_handle(_mouse);
}

```

`csf/src/cs/cs_convar.cpp`:

```cpp
#include "../../include/cs/cs_convar.h"
#include "../../include/cs/cs_interfaces.h"
#include "../../include/u_process.h"
#include <string.h>

extern u_process cs_p;
extern cs_virtual_table cs_vt_cvar;

SHORT_STRING cs_convar::GetName(void)
{
	return cs_p.read_ptr<SHORT_STRING>(self + 0x18);
}

void cs_convar::SetString(const char *v)
{
	SHORT_STRING a0;
	memcpy(&a0, v, strlen(v));
	cs_p.write_ptr<SHORT_STRING>(self + 0x48, a0);
}

void cs_convar::SetInt(int v)
{
	cs_p.write<uint32_t>(self + 0x58, v ^ self);
}

void cs_convar::SetFloat(float v)
{
	cs_p.write<uint32_t>(self + 0x54, *(uint32_t *)&v ^ self);
}

SHORT_STRING cs_convar::GetString(void)
{
	return cs_p.read_ptr<SHORT_STRING>(self + 0x48);
}

int cs_convar::GetInt(void)
{
	return cs_p.read<int>(self + 0x58) ^ self;
}

float cs_convar::GetFloat(void)
{
	uint32_t v;
	v = cs_p.read<uint32_t>(self + 0x54) ^ self;
	return *(float *)&v;
}

cs_convar cvar::find(const char *name)
{
	uintptr_t a0;

	a0 = cs_p.read_ptr<uintptr_t>(cs_vt_cvar.address() + 0x70);
	while ((a0 = cs_p.read<uintptr_t>(a0 + 0x8)))
	{
		if (!strcmp(name, cs_p.read_ptr<SHORT_STRING>(a0 + 0x18).value))
		{
			return *(cs_convar *)&a0;
		}
	}
	return {};
}

```

`csf/src/cs/cs_engine.cpp`:

```cpp
#include "../../include/cs/cs_engine.h"
#include "../../include/u_process.h"
#include <stdio.h>

u_process cs_p("csgo_linux64");
cs_virtual_table cs_vt_client;
cs_virtual_table cs_vt_entity;
cs_virtual_table cs_vt_engine;
cs_virtual_table cs_vt_cvar;
cs_virtual_table cs_vt_inputsystem;
uintptr_t cs_nv_dwEntityList;
uintptr_t cs_nv_dwClientState;
uint32_t cs_nv_m_dwGetLocalPlayer;
uint32_t cs_nv_m_dwViewAngles;
uint32_t cs_nv_m_dwMaxClients;
uint32_t cs_nv_m_dwState;
uint32_t cs_nv_m_dwButton;
uint32_t cs_nv_m_dwAnalogDelta;
uint32_t cs_nv_m_dwAnalog;
uint32_t cs_nv_m_iHealth;
uint32_t cs_nv_m_vecViewOffset;
uint32_t cs_nv_m_lifeState;
uint32_t cs_nv_m_nTickBase;
uint32_t cs_nv_m_vecVelocity;
uint32_t cs_nv_m_vecPunch;
uint32_t cs_nv_m_iFOV;
uint32_t cs_nv_m_iTeamNum;
uint32_t cs_nv_m_vecOrigin;
uint32_t cs_nv_m_hActiveWeapon;
uint32_t cs_nv_m_iShotsFired;
uint32_t cs_nv_m_bIsScoped;
uint32_t cs_nv_m_dwBoneMatrix;

static void initialize_vt(void);
static void initialize_nv(void);

bool cs_initialize(void)
{
	if (!cs_p.attach())
	{
		return false;
	}
	initialize_vt();
	initialize_nv();

	printf(
	    "[*]vtables:\n"
	    "    VClient:                         0x%lx\n"
	    "    VClientEntityList:               0x%lx\n"
	    "    VEngineClient:                   0x%lx\n"
	    "    VEngineCvar:                     0x%lx\n"
	    "    InputSystemVersion:              0x%lx\n"
	    "[*]offsets:\n"
	    "    dwEntityList:                    0x%lx\n"
	    "    dwClientState:                   0x%lx\n"
	    "    m_dwGetLocalPlayer:              0x%x\n"
	    "    m_dwViewAngles:                  0x%x\n"
	    "    m_dwMaxClients:                  0x%x\n"
	    "    m_dwState:                       0x%x\n"
	    "    m_dwButton:                      0x%x\n"
	    "    m_dwAnalog:                      0x%x\n"
	    "    m_dwAnalogDelta:                 0x%x\n"
	    "[*]netvars:\n"
	    "    DT_BasePlayer:                   m_iHealth:           0x%x\n"
	    "    DT_BasePlayer:                   m_vecViewOffset:     0x%x\n"
	    "    DT_BasePlayer:                   m_lifeState:         0x%x\n"
	    "    DT_BasePlayer:                   m_nTickBase:         0x%x\n"
	    "    DT_BasePlayer:                   m_vecVelocity:       0x%x\n"
	    "    DT_BasePlayer:                   m_vecPunch:          0x%x\n"
	    "    DT_BasePlayer:                   m_iFOV:              0x%x\n"
	    "    DT_BaseEntity:                   m_iTeamNum:          0x%x\n"
	    "    DT_BaseEntity:                   m_vecOrigin:         0x%x\n"
	    "    DT_CSPlayer:                     m_hActiveWeapon:     0x%x\n"
	    "    DT_CSPlayer:                     m_iShotsFired:       0x%x\n"
	    "    DT_CSPlayer:                     m_bIsScoped:         0x%x\n"
	    "    DT_BaseAnimating:                m_dwBoneMatrix:      0x%x\n"
	    "[*]convar demo:\n"
	    "    sensitivity:                     %ff\n"
	    "    volume:                          %ff\n"
	    "    cl_crosshairsize:                %ff\n"
	    "[*]sdk info:\n"
	    "   creator:                          ekknod\n"
	    "   repo:                             github.com/ekknod/csf\n",
	    cs_vt_client.address(),
	    cs_vt_entity.address(),
	    cs_vt_engine.address(),
	    cs_vt_cvar.address(),
	    cs_vt_inputsystem.address(),
	    cs_nv_dwEntityList,
	    cs_nv_dwClientState,
	    cs_nv_m_dwGetLocalPlayer,
	    cs_nv_m_dwViewAngles,
	    cs_nv_m_dwMaxClients,
	    cs_nv_m_dwState,
	    cs_nv_m_dwButton,
	    cs_nv_m_dwAnalog,
	    cs_nv_m_dwAnalogDelta,
	    cs_nv_m_iHealth,
	    cs_nv_m_vecViewOffset,
	    cs_nv_m_lifeState,
	    cs_nv_m_nTickBase,
	    cs_nv_m_vecVelocity,
	    cs_nv_m_vecPunch,
	    cs_nv_m_iFOV,
	    cs_nv_m_iTeamNum,
	    cs_nv_m_vecOrigin,
	    cs_nv_m_hActiveWeapon,
	    cs_nv_m_iShotsFired,
	    cs_nv_m_bIsScoped,
	    cs_nv_m_dwBoneMatrix,
	    cvar::find("sensitivity").GetFloat(),
	    cvar::find("volume").GetFloat(),
	    cvar::find("cl_crosshairsize").GetFloat());
	return true;
}

int engine::IsRunning(void)
{
	return cs_p.exists();
}

int engine::GetLocalPlayer(void)
{
	return cs_p.read<int>(cs_nv_dwClientState + cs_nv_m_dwGetLocalPlayer) + 1;
}

vec3 engine::GetViewAngles(void)
{
	return cs_p.read<vec3>(cs_nv_dwClientState + cs_nv_m_dwViewAngles);
}

void engine::SetViewAngles(vec3 v)
{
	cs_p.write<vec3>(cs_nv_dwClientState + cs_nv_m_dwViewAngles, v);
}

int engine::GetMaxClients(void)
{
	return cs_p.read<int>(cs_nv_dwClientState + cs_nv_m_dwMaxClients);
}

bool engine::IsInGame(void)
{
	return cs_p.read<unsigned char>(cs_nv_dwClientState + cs_nv_m_dwState) >> 2;
}

cs_player entity::GetClientEntity(int index)
{
	return cs_p.read<cs_player>(cs_nv_dwEntityList + index * 0x20);
}

static void initialize_vt(void)
{
	cs_interface_reg t;

	t = interfaces::find("client_client.so");
	cs_vt_client = t.find("VClient");
	cs_vt_entity = t.find("VClientEntityList");
	t = interfaces::find("engine_client.so");
	cs_vt_engine = t.find("VEngineClient");
	t = interfaces::find("materialsystem_client.so");
	cs_vt_cvar = t.find("VEngineCvar");
	t = interfaces::find("inputsystem_client.so");
	cs_vt_inputsystem = t.find("InputSystemVersion");
}

static uintptr_t offset_entitylist(void)
{
	return cs_vt_entity.address() - cs_p.read<uint32_t>(cs_vt_entity.function(4) + 3) + 0x08;
}

static uintptr_t offset_clientstate(void)
{
	uintptr_t a0;
	uint32_t a1, a2;

	a0 = cs_vt_engine.function(18);
	a1 = cs_p.read<uint32_t>(a0 + 0x11 + 1) + 0x16;
	a2 = cs_p.read<uint32_t>(a0 + a1 + 5 + 3) + 0xC;
	return cs_p.read<uintptr_t>(a0 + a1 + a2 + 0x8) + 0x8;
}

static void initialize_nv(void)
{
	cs_netvar_table t;

	cs_nv_dwEntityList = offset_entitylist();
	cs_nv_dwClientState = offset_clientstate();
	cs_nv_m_dwGetLocalPlayer = cs_p.read<uint32_t>(cs_vt_engine.function(12) + 0x11);
	cs_nv_m_dwViewAngles = cs_p.read<uint32_t>(cs_vt_engine.function(18) + 0x1A);
	cs_nv_m_dwMaxClients = cs_p.read<uint32_t>(cs_vt_engine.function(20) + 0x0C);
	cs_nv_m_dwState = cs_p.read<uint32_t>(cs_vt_engine.function(26) + 0x0C);
	cs_nv_m_dwButton = cs_p.read<uint32_t>(cs_vt_inputsystem.function(15) + 0x019);
	cs_nv_m_dwAnalogDelta = cs_p.read<uint32_t>(cs_vt_inputsystem.function(18) + 0x01a);
	cs_nv_m_dwAnalog = cs_p.read<uint32_t>(cs_vt_inputsystem.function(19) + 0x170);

	t = netvars::find("DT_BasePlayer");
	cs_nv_m_iHealth = t.offset("m_iHealth");
	cs_nv_m_vecViewOffset = t.offset("m_vecViewOffset[0]");
	cs_nv_m_lifeState = t.offset("m_lifeState");
	cs_nv_m_nTickBase = t.offset("m_nTickBase");
	cs_nv_m_vecVelocity = t.offset("m_vecVelocity[0]");
	cs_nv_m_vecPunch = t.offset("m_aimPunchAngle");
	cs_nv_m_iFOV = t.offset("m_iFOV");
	t = netvars::find("DT_BaseEntity");
	cs_nv_m_iTeamNum = t.offset("m_iTeamNum");
	cs_nv_m_vecOrigin = t.offset("m_vecOrigin");
	t = netvars::find("DT_CSPlayer");
	cs_nv_m_hActiveWeapon = t.offset("m_hActiveWeapon");
	cs_nv_m_iShotsFired = t.offset("m_iShotsFired");
	cs_nv_m_bIsScoped = t.offset("m_bIsScoped");
	t = netvars::find("DT_BaseAnimating");
	cs_nv_m_dwBoneMatrix = t.offset("m_nForceBone") + 0x2C;
}

```

`csf/src/cs/cs_inputsystem.cpp`:

```cpp
#include "../../include/cs/cs_inputsystem.h"
#include "../../include/u_process.h"
#include "../../include/cs/cs_interfaces.h"

extern u_process cs_p;
extern cs_virtual_table cs_vt_inputsystem;
extern uint32_t cs_nv_m_dwButton;
extern uint32_t cs_nv_m_dwAnalog;
extern uint32_t cs_nv_m_dwAnalogDelta;

bool inputsystem::IsButtonDown(CS_BUTTONCODE button)
{
	uint32_t v;
	v = cs_p.read<uint32_t>(cs_vt_inputsystem.address() + (((button >> 5) * 4) + cs_nv_m_dwButton));
	return (v >> (button & 31)) & 1;
}

vec2i inputsystem::GetMouseAnalog(void)
{
	return cs_p.read<vec2i>(cs_vt_inputsystem.address() + cs_nv_m_dwAnalog);
}

vec2i inputsystem::GetMouseAnalogDelta(void)
{
	return cs_p.read<vec2i>(cs_vt_inputsystem.address() + cs_nv_m_dwAnalogDelta);
}

```

`csf/src/cs/cs_interfaces.cpp`:

```cpp
#include "../../include/cs/cs_interfaces.h"
#include "../../include/u_process.h"
#include <string.h>

extern u_process cs_p;

uintptr_t cs_virtual_table::address(void) const
{
	return self;
}

uintptr_t cs_virtual_table::function(uint32_t index)
{
	return cs_p.read<uintptr_t>(cs_p.read<uintptr_t>(self) + index * 8);
}

cs_virtual_table cs_interface_reg::find(const char *name)
{
	uintptr_t a0, a1;

	a0 = self;
	do
	{
		a1 = a0;
		if ((strcmp(cs_p.read_ptr<SHORT_STRING>(a0 + 0x08).value, name) >> 4) == 3)
		{
			a0 = cs_p.read<uintptr_t>(a0);
			if (cs_p.read<unsigned char>(a0) != 0x48)
			{
				a0 = a0 + cs_p.read<uint32_t>(a0 + 1 + 3) + 8;
			}
			else
			{
				a0 = cs_p.read_ptr<uintptr_t>(a0 + (cs_p.read<uint32_t>(a0 + 0 + 3) + 7));
			}
			return *(cs_virtual_table *)&a0;
		}
	} while ((a0 = cs_p.read<uintptr_t>(a0 + 0x10)) != a1);
	throw name;
}

cs_interface_reg interfaces::find(const char *module_name)
{
	uintptr_t v;

	v = cs_p.find_export(cs_p.find_module(module_name), "s_pInterfaceRegs");
	if (v == 0)
	{
		throw module_name;
	}
	return cs_p.read<cs_interface_reg>(v);
}

```

`csf/src/cs/cs_netvars.cpp`:

```cpp
#include "../../include/cs/cs_netvars.h"
#include "../../include/u_process.h"
#include "../../include/cs/cs_interfaces.h"
#include <string.h>

extern u_process cs_p;
extern cs_virtual_table cs_vt_client;

uint32_t cs_netvar_table::offset(const char *name)
{
	return offset_ex(self, name);
}

uint32_t cs_netvar_table::offset_ex(uintptr_t address, const char *name)
{
	uint32_t a0;
	uint32_t a1;
	uintptr_t a2;
	uint32_t a3;
	uintptr_t a4;
	uint32_t a5;

	a0 = 0;
	for (a1 = cs_p.read<uint32_t>(address + 0x8); a1--;)
	{
		a2 = a1 * 96 + cs_p.read<uintptr_t>(address);
		a3 = cs_p.read<uint32_t>(a2 + 0x48);
		if ((a4 = cs_p.read<uintptr_t>(a2 + 0x40)) && cs_p.read<uint32_t>(a4 + 0x8))
		{
			if ((a5 = offset_ex(a4, name)))
			{
				a0 += a3 + a5;
			}
		}
		if (strcmp(cs_p.read_ptr<SHORT_STRING>(a2).value, name) == 0)
		{
			return a3 + a0;
		}
	}
	return a0;
}

cs_netvar_table netvars::find(const char *name)
{
	uintptr_t a0, a1;

	a0 = cs_vt_client.function(8);
	a0 = cs_p.read_ptr<uintptr_t>(a0 + cs_p.read<uint32_t>(a0 + 0 + 3) + 7);
	do
	{
		a1 = cs_p.read<uintptr_t>(a0 + 0x18);
		if (strcmp(cs_p.read_ptr<SHORT_STRING>(a1 + 0x18).value, name) == 0)
		{
			return *(cs_netvar_table *)&a1;
		}
	} while ((a0 = cs_p.read<uintptr_t>(a0 + 0x20)));
	throw name;
}

/*
 *  0:  48 8b 05 69 77 71 01    mov    rax,QWORD PTR [rip+0x1717769] # 0x1717770
 *  7:  55                      push   rbp
 *  8:  48 89 e5                mov    rbp,rsp
 *  b:  5d                      pop    rbp
 *  c:  48 8b 00                mov    rax,QWORD PTR [rax]
 *  f:  c3                      ret
 *
 */

```

`csf/src/cs/cs_player.cpp`:

```cpp
#include "../../include/cs/cs_player.h"
#include "../../include/u_process.h"
#include "../../include/cs/cs_interfaces.h"

extern u_process cs_p;
extern uintptr_t cs_nv_dwEntityList;
extern uint32_t cs_nv_m_iHealth;
extern uint32_t cs_nv_m_vecViewOffset;
extern uint32_t cs_nv_m_lifeState;
extern uint32_t cs_nv_m_nTickBase;
extern uint32_t cs_nv_m_vecVelocity;
extern uint32_t cs_nv_m_vecPunch;
extern uint32_t cs_nv_m_iFOV;
extern uint32_t cs_nv_m_iTeamNum;
extern uint32_t cs_nv_m_vecOrigin;
extern uint32_t cs_nv_m_hActiveWeapon;
extern uint32_t cs_nv_m_iShotsFired;
extern uint32_t cs_nv_m_bIsScoped;
extern uint32_t cs_nv_m_dwBoneMatrix;

int cs_player::GetTeam(void)
{
	return cs_p.read<int>(self + cs_nv_m_iTeamNum);
}

int cs_player::GetHealth(void)
{
	return cs_p.read<int>(self + cs_nv_m_iHealth);
}

int cs_player::GetLifeState(void)
{
	return cs_p.read<int>(self + cs_nv_m_lifeState);
}

int cs_player::GetTickCount(void)
{
	return cs_p.read<int>(self + cs_nv_m_nTickBase);
}

int cs_player::GetShotsFired(void)
{
	return cs_p.read<int>(self + cs_nv_m_iShotsFired);
}

bool cs_player::IsScoped(void)
{
	return cs_p.read<bool>(self + cs_nv_m_bIsScoped);
}

bool cs_player::IsDormant(void)
{
	uintptr_t a;

	a = (uintptr_t)(self + 0x8);
	return cs_p.read<bool>(a + cs_p.read<unsigned char>((*(cs_virtual_table *)&a).function(9) + 0x8));
}

uintptr_t cs_player::GetWeapon(void)
{
	uint32_t v;

	v = cs_p.read<uintptr_t>(self + cs_nv_m_hActiveWeapon);
	return cs_p.read<uintptr_t>(cs_nv_dwEntityList + ((v & 0xFFF) - 1) * 0x10);
}

vec3 cs_player::GetOrigin(void)
{
	return cs_p.read<vec3>(self + cs_nv_m_vecOrigin);
}

vec3 cs_player::GetVecView(void)
{
	return cs_p.read<vec3>(self + cs_nv_m_vecViewOffset);
}
vec3 cs_player::GetEyePos(void)
{
	vec3 v, o, r;
	v = this->GetVecView();
	o = this->GetOrigin();
	r.x = v.x += o.x;
	r.y = v.y += o.y;
	r.z = v.z += o.z;
	return r;
}

vec3 cs_player::GetVecVelocity(void)
{
	return cs_p.read<vec3>(self + cs_nv_m_vecViewOffset);
}

vec3 cs_player::GetVecPunch(void)
{
	return cs_p.read<vec3>(self + cs_nv_m_vecPunch);
}

int cs_player::GetFov(void)
{
	return cs_p.read<int>(self + cs_nv_m_iFOV);
}

void cs_player::GetBoneMatrix(int index, matrix3x4_t *out)
{
	cs_p.read(cs_p.read<uintptr_t>(self + cs_nv_m_dwBoneMatrix) + 0x30 * index, out, sizeof(matrix3x4_t));
}

bool cs_player::IsValid(void)
{
	int health;

	health = GetHealth();
	return self && GetLifeState() == 0 && health > 0 && health < 1337;
}

```

`csf/src/u_config.cpp`:

```cpp
#include "../include/u_config.h"
#include <inttypes.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

int u_config_table::GetInt(const char *name)
{
	char b[32];
	GetVal(name, b);
	return atoi(b);
}

float u_config_table::GetFloat(const char *name)
{
	char b[32];
	GetVal(name, b);
	return atof(b);
}

bool u_config_table::SetPos(const char *name)
{
	const char *n;
	char c;

	n = name;
	while (1)
	{
		if (read(_fd, &c, sizeof(c)) == 0)
			break;
		if (c == '}')
			break;
		if (*n != c)
		{
			n = name;
			continue;
		}
		if (*(char *)(n + 1) == '\0')
		{
			lseek(_fd, 2, SEEK_CUR);
			return true;
		}
		n++;
	}
	return false;
}

bool u_config_table::GetVal(const char *name, char buffer[32])
{
	uintptr_t c;
	bool s;
	int i;

	c = lseek(_fd, 0, SEEK_CUR);
	if ((s = SetPos(name)) == false)
	{
		goto end;
	}
	i = 0;
	while (i < 32)
	{
		if (read(_fd, &buffer[i], 1) == 0)
			break;
		if (buffer[i] == '\n')
		{
			buffer[i] = '\0';
			s = true;
			break;
		}
		i++;
	}
end:
	lseek(_fd, c, SEEK_SET);
	return s;
}

u_config::u_config(const char *path) : _path(path) {}
u_config::~u_config(void) {}

bool u_config::exists(void)
{
	return access(_path, F_OK) != -1;
}

void u_config::open_config(void)
{
	_fd = open(_path, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
}

void u_config::close_config(void)
{
	close(_fd);
}

void u_config::write_config(void *buffer, size_t length)
{
	write(_fd, buffer, length);
}

u_config_table u_config::table(const char *name)
{
	const char *n;
	char c;

	lseek(_fd, 0, SEEK_SET);
	n = name;
	while (1)
	{
		if (read(_fd, &c, sizeof(c)) == 0)
			break;
		if (*n != c)
		{
			n = name;
			continue;
		}
		if (*(char *)(n + 1) == 0)
		{
			return *(u_config_table *)&_fd;
		}
		n++;
	}
	throw name;
}

```

`makeconfig`:

```
./build/csf/csf --write
```

`run`:

```
mkdir build
cd build
cmake ..
make -j8
cd ..
./build/csf/csf --write
sudo ./build/csf/csf

```