Project Path: arc_gmh5225_HotkeybasedKeyloggerDetector_895vki6a

Source Tree:

```txt
arc_gmh5225_HotkeybasedKeyloggerDetector_895vki6a
├── HotkeybasedKeyloggerDetector
│   ├── HotKeyStructs.h
│   ├── HotkeybasedKeyloggerDetector.cpp
│   ├── HotkeybasedKeyloggerDetector.inf
│   ├── HotkeybasedKeyloggerDetector.vcxproj
│   └── HotkeybasedKeyloggerDetector.vcxproj.filters
├── HotkeybasedKeyloggerDetector.sln
├── LICENSE
└── README.md

```

`HotkeybasedKeyloggerDetector.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35514.174 d17.12
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HotkeybasedKeyloggerDetector", "HotkeybasedKeyloggerDetector\HotkeybasedKeyloggerDetector.vcxproj", "{B8DB6683-2BBA-4229-8414-B669F6D45E5F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Debug|ARM64.Build.0 = Debug|ARM64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Debug|x64.ActiveCfg = Debug|x64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Debug|x64.Build.0 = Debug|x64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Debug|x64.Deploy.0 = Debug|x64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Release|ARM64.ActiveCfg = Release|ARM64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Release|ARM64.Build.0 = Release|ARM64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Release|ARM64.Deploy.0 = Release|ARM64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Release|x64.ActiveCfg = Release|x64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Release|x64.Build.0 = Release|x64
		{B8DB6683-2BBA-4229-8414-B669F6D45E5F}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`HotkeybasedKeyloggerDetector/HotKeyStructs.h`:

```h
#pragma once

#ifndef HOTKEY_STRUCTS_H
#define HOTKEY_STRUCTS_H

#include <ntifs.h>
#include <ntimage.h>
#include <ntddk.h>
#include <ntdef.h>
#include <windef.h>
#include <ntstrsafe.h>
#include <wdm.h>

#define POOL_TAG 'HotK'
#define MOD_ALT         0x0001
#define MOD_CONTROL     0x0002
#define MOD_SHIFT       0x0004
#define MOD_WIN         0x0008

typedef PVOID PWND;
typedef UINT64 PADDING64;
typedef UINT32 PADDING32;
typedef struct _THREADINFO {
    PETHREAD thread;
} *PTHREADINFO;

typedef struct _WNDINFO {
    HWND wnd;
} *PWNDINFO;

typedef struct _HOT_KEY {
    PTHREADINFO thdinfo;
    PVOID callback;
    PWNDINFO wndinfo;
    UINT16 modifiers1;		//eg:MOD_CONTROL(0x0002)
    UINT16 modifiers2;		//eg:MOD_NOREPEAT(0x4000)
    UINT32 vk;
    UINT32 id;
#ifdef _AMD64_
    PADDING32 pad;
#endif
    struct _HOT_KEY* pNext;
} HOT_KEY, * PHOT_KEY;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    PVOID ExceptionTable;
    ULONG ExceptionTableSize;
    PVOID GpValue;
    PNON_PAGED_DEBUG_INFO NonPagedDebugInfo;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Unused5;
    PVOID SectionPointer;
    ULONG CheckSum;
    PVOID LoadedImports;
    PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45,
    SystemCodeIntegrityInformation = 103,
    SystemPolicyInformation = 134,
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER Reserved[3];
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    ULONG BasePriority;
    HANDLE ProcessId;
    HANDLE InheritedFromProcessId;
} SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;


EXTERN_C PVOID NTAPI RtlFindExportedRoutineByName(_In_ PVOID ImageBase, _In_ PCCH RoutineName);
typedef NTSTATUS(*ZWQUERYSYSTEMINFORMATION)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength OPTIONAL);

#endif // HOTKEY_STRUCTS_H
```

`HotkeybasedKeyloggerDetector/HotkeybasedKeyloggerDetector.cpp`:

```cpp
#include "HotKeyStructs.h"

UINT hotkeyCounter = 0;

/*
 * Function: GetSystemModuleBase
 * -----------------------------
 * Retrieves the base address of a system module given its name.
 *
 * Parameters:
 *   moduleName - A constant reference to a UNICODE_STRING that specifies the name of the module.
 *
 * Returns:
 *   A pointer (PVOID) to the base address of the module if found;
 *   otherwise, returns nullptr.
 *
 * Reference:
 * https://m0uk4.gitbook.io/notebooks/mouka/windowsinternal/find-kernel-module-address-todo
 */

PVOID GetSystemModuleBase(
    _In_ const UNICODE_STRING& moduleName)
{
    // Get the address of the PsLoadedModuleList function
    UNICODE_STRING psLoadedModuleListName;
    RtlInitUnicodeString(&psLoadedModuleListName, L"PsLoadedModuleList");
    PLIST_ENTRY moduleList = reinterpret_cast<PLIST_ENTRY>(MmGetSystemRoutineAddress(&psLoadedModuleListName));

    if (!moduleList || IsListEmpty(moduleList))
    {
        return nullptr;
    }

    // Iterate over the module list
    for (PLIST_ENTRY pListEntry = moduleList->Flink;
        pListEntry != moduleList; pListEntry = pListEntry->Flink)
    {
        PKLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (RtlEqualUnicodeString(&pEntry->BaseDllName, &moduleName, TRUE))
        {
            // If the module names match, return the module base address.
            return pEntry->DllBase;
        }
    }
    return nullptr;
}

/*
 * Function: GetSystemModuleBase
 * -----------------------------
 * Retrieves the PID for a process name matches the provided Unicode string.
 *
 * Parameters:
 *   processName - A constant reference to a UNICODE_STRING that specifies the name of the target process.
 *
 * Return Value:
 *   A HANDLE representing the process ID of the matching process if found; otherwise, returns nullptr.
 *
 * Reference:
 *   https://www.unknowncheats.me/forum/general-programming-and-reversing/572734-pid-process-name.html
 */

HANDLE GetPidFromProcessName(
    _In_ const UNICODE_STRING& processName)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PVOID buffer = NULL;
    ULONG bufferSize = 0;
    UNICODE_STRING funcName;

    //
    // [1] Get the address of ZwQuerySystemInformation
    //
    RtlInitUnicodeString(&funcName, L"ZwQuerySystemInformation");
    ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&funcName);
    if (!ZwQuerySystemInformation)
    {
        KdPrint(("[-] Failed to locate ZwQuerySystemInformation.\n"));
        return nullptr;
    }

    //
    // [2] Retrieve running process list using ZwQuerySystemInformation
    //

    // First call to determine the required buffer size for system process information.
    ntStatus = ZwQuerySystemInformation(SystemProcessInformation, buffer,
                                        bufferSize, &bufferSize);
    if (STATUS_INFO_LENGTH_MISMATCH != ntStatus)
    {
        KdPrint(("[-] ZwQuerySystemInformation failed to get buffer size: 0x%X\n", ntStatus));
        return nullptr;
    }

    // Allocate a buffer with the size returned.
    buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, bufferSize, POOL_TAG);
    if (!buffer)
    {
        KdPrint(("[-] ExAllocatePool2 failed to allocate buffer of size %lu.\n", bufferSize));
        return nullptr;
    }

    // Retrieve the actual process information.
    ntStatus = ZwQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &bufferSize);
    if (!NT_SUCCESS(ntStatus))
    {
        KdPrint(("[-] ZwQuerySystemInformation failed: 0x%X\n", ntStatus));
        ExFreePoolWithTag(buffer, POOL_TAG);
        return nullptr;
    }

    //
    // [3] Iterate through the process list to find a matching process name.
    //
    auto pProcInfoBuffer = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(buffer);
    while (pProcInfoBuffer)
    {
        // If the process has a valid image name, compare it with the provided process name.
        if (NULL != pProcInfoBuffer->ImageName.Buffer)
        {
            if (RtlCompareUnicodeString(&(pProcInfoBuffer->ImageName), &processName, TRUE) == 0)
            {
                ExFreePoolWithTag(buffer, POOL_TAG);
                return pProcInfoBuffer->ProcessId;
            }
        }
        if (0 == pProcInfoBuffer->NextEntryOffset) {
            pProcInfoBuffer = nullptr;
        }
        else
        {
            pProcInfoBuffer = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(
                reinterpret_cast<PUCHAR>(pProcInfoBuffer) + pProcInfoBuffer->NextEntryOffset);
        }
    }
    // Free the allocated buffer if no matching process was found.
    ExFreePoolWithTag(buffer, POOL_TAG);
    return nullptr;
}

/*
 * Function: FindIsHotKeyFunction
 * -----------------------------
 * Scans a memory region for a CALL instruction (opcode 0xE8 [32bit offset]) 
 * that likely calls the IsHotKey function. When found, it calculates the absolute address
 * of the target function using the offset.
 * Note - This function is expected to scan the "EditionIsHotkey" function.
 *
 * EditionIsHotKey function
 * 48 83 EC 28       sub     rsp, 28h
 * E8 7F 74 EE FF    call    IsHotKey
 * 33 C9             xor     ecx, ecx
 * 48 85 C0          test    rax, rax
 * 0F 95 C1          setnz   cl
 * 8B C1             mov     eax, ecx
 * 48 83 C4 28       add     rsp, 28h
 * C3                retn
 * 
 * Parameters:
 *   address - A pointer to the beginning of the memory region to scan.
 *
 * Return Value:
 *   The absolute address of the function called by the CALL instruction if found; otherwise, nullptr.
 *
 * Reference:
 *   https://eversinc33.com/posts/kernel-mode-keylogging.html
 */

PVOID
FindIsHotKeyFunction(
    _In_ const PULONG& address)
{
    USHORT i;
    PVOID isHotKeyAddr = nullptr;
    PBYTE baseAddr = (PBYTE)address;
    if (!address)
    {
        KdPrint(("[-] Invalid address\n"));
        return nullptr;
    }

    // Scan the first 30 bytes of the memory region.
    for (i = 0; i < 30; i++)
    {
        // Check if the current byte is the CALL opcode (0xE8).
        if (*(BYTE*)(baseAddr + i) == 0xE8)
        {
            INT32 offset = 0;
            // Copy the 32-bit offset located immediately after the CALL opcode.
            RtlCopyMemory(&offset, reinterpret_cast<PVOID>(baseAddr + i + 1), sizeof(offset));
            // Calculate the absolute address of the called function.
            isHotKeyAddr = (PVOID)(baseAddr + i + offset + 5);
            break;
        }
        // If a RET instruction (opcode 0xC3) is encountered, stop scanning.
        if (*(BYTE*)(baseAddr + i) == 0xC3)
        {
            break;
        }
    }
    return isHotKeyAddr;
}

/*
 * Function: ResolvegphkHashTableAddress
 * -----------------------------
 * Scans a memory region for a LEA rbx (opcode 0x48, 0x8D, 0x1D [32bit offset]) 
 * that stores the gphkHashTable address (offset). When found, it calculates the 
 * absolute address using the offset.
 * Note - This function is expected to scan the "IsHotkey" function.
 *
 * IsHotKey function
 * 48 89 5C 24 08         mov     [rsp+arg_0], rbx
 * 48 89 74 24 10         mov     [rsp+arg_8], rsi
 * 57                     push    rdi
 * 48 83 EC 50            sub     rsp, 50h
 * 0F B6 C2               movzx   eax, dl
 * 48 8D 1D 1F 8D 26 00   lea     rbx, ?gphkHashTable@@3PAPEAUtagHOTKEY@@A
 * 83 E0 7F               and     eax, 7Fh
 * 8B FA                  mov     edi, edx
 * 8B F1                  mov     esi, ecx
 * 48 8B 1C C3            mov     rbx, [rbx+rax*8]
  *
  * Parameters:
  *   address - A pointer to the beginning of the memory region to scan.
  *
  * Return Value:
  *   The absolute address of gphkHashTable if found; otherwise, nullptr.
  * 
  * Reference:
  *   https://eversinc33.com/posts/kernel-mode-keylogging.html
  */

PVOID
ResolvegphkHashTableAddress(
    _In_ const PVOID& address)
{

    USHORT i;
    PVOID gphkHashTableAddr = nullptr;
    PBYTE baseAddress = (PBYTE)address;
    if (!address)
    {
        KdPrint(("[-] Invalid address\n"));
        return nullptr;
    }

    // Scan the first 30 bytes of the memory region.
    for (i = 0; i < 30; i++)
    {
        // Check if the current byte is the LEA rbx (0x48,0x8D,0x1D)
        if ((*(BYTE*)(baseAddress + i) == 0x48) &&
            (*(BYTE*)(baseAddress + i + 1) == 0x8D) &&
            (*(BYTE*)(baseAddress + i + 2) == 0x1D))
        {
            INT32 offset = 0;
            // Copy the 32-bit offset located immediately after the LEA rbx opcode.
            RtlCopyMemory(&offset, reinterpret_cast<PVOID>(baseAddress + i + 3), sizeof(offset));
            // Calculate the absolute address
            gphkHashTableAddr = (PVOID)(baseAddress + i + offset + 7);
            break;
        }
        // If a RET instruction (opcode 0xC3) is encountered, stop scanning.
        if (*(BYTE*)(baseAddress + i) == 0xC3)
        {
            break;
        }
    }
    return gphkHashTableAddr;
}

/*
 * Function: FindgphkHashTableAddress
 * ----------------------------------
 * Attempts to resolve the address of the gphkHashTable from the Win32kfull module.
 *
 * Parameters:
 *   Win32kfullBaseAddr - A pointer to the base address of the Win32kfull module.
 *
 * Return Value:
 *   Returns the address of the gphkHashTable if successfully resolved; otherwise, returns nullptr.
 */

PVOID
FindgphkHashTableAddress(
    _In_ const PVOID& Win32kfullBaseAddr)
{

    PVOID gphkHashTable = nullptr;
    if (!Win32kfullBaseAddr)
    {
        KdPrint(("[-] Invalid Win32kfullBaseAddr\n"));
        goto Cleanup;
    }

    // [1] Retrieve the address of the "EditionIsHotKey" funtion.
    //     This exported function calls "IsHotKey" function which contains gphkHashTable
    PULONG editionIsHotKeyAddr = (PULONG)RtlFindExportedRoutineByName(Win32kfullBaseAddr, "EditionIsHotKey");
    if (!editionIsHotKeyAddr)
    {
        KdPrint(("[-] Failed to resolve EditionIsHotKey address.\n"));
        goto Cleanup;
    }

    // [2] Retrieve the address of the "IsHotKey" Function.
    PVOID isHotKeyAddr = FindIsHotKeyFunction(editionIsHotKeyAddr);
    if (!isHotKeyAddr)
    {
        KdPrint(("[-] Failed to resolve IsHotKey address.\n"));
        goto Cleanup;
    }

    // [3] Finally, resolve the address of gphkHashTable.
    gphkHashTable = ResolvegphkHashTableAddress(isHotKeyAddr);
    if (!gphkHashTable)
    {
        KdPrint(("[-] Failed to resolve gphkHashTable address.\n"));
    }
Cleanup:
    return gphkHashTable;
}


/*
 * Function: CheckHotkeyNode
 * ----------------------------------
 * Recursively checks a hotkey node.
 *
 * Parameters:
 *   hk - A pointer of HOT_KEY object.
 *
 * Reference:
 *   http://blog.blackint3.com:88/posts/2020/enum-windows-hotkey/
 */

VOID
CheckHotkeyNode(
    _In_ const PHOT_KEY& hk)
{
    if (MmIsAddressValid(hk->pNext)) {
        CheckHotkeyNode(hk->pNext);
    }

    // Check whether this is a single numeric hotkey.
    if ((hk->vk >= 0x30) && (hk->vk <= 0x39) && (hk->modifiers1 == 0))
    {
        KdPrint(("[+] hk->id: %u hk->vk: %x\n", hk->id, hk->vk));
        hotkeyCounter++;
    }
    // Check whether this is a single alphabet hotkey.
    else if ((hk->vk >= 0x41) && (hk->vk <= 0x5A) && (hk->modifiers1 == 0))
    {
        KdPrint(("[+] hk->id: %u hk->vk: %x\n", hk->id, hk->vk));
        hotkeyCounter++;
    }
    //We can also check a hotkey with modifieres such as SHIFT + A like following
    /*
    else if ((hk->vk >= 0x41) && (hk->vk <= 0x5A) && (hk->modifiers1 == MOD_SHIFT))
    {
        KdPrint(("[+] hk->id: %u hk->vk: %x\n", hk->id, hk->vk));
        hotkeyCounter++;
    }
    */
}

/*
 * Function: CheckRegisteredHotKeys
 * ----------------------------------
 * Checks the registered hotkeys from a given hash table address.
 *
 * Parameters:
 *   gphkHashTableAddr - A pointer holding the address of the hotkey hash table.
 *
 * Return Value:
 *   TRUE if it finishes scanning the hotkey table; FALSE if the provided address is invalid.
 * 
 * Reference:
 *   http://blog.blackint3.com:88/posts/2020/enum-windows-hotkey/
 */

BOOL
CheckRegisteredHotKeys(
    _In_ const PVOID& gphkHashTableAddr)
{
    if (!gphkHashTableAddr)
    {
        KdPrint(("[-] Invalid gphkHashTableAddr\n"));
        return FALSE;
    }

    // Cast the gphkHashTable address to an array of pointers.
    PVOID* tableArray = static_cast<PVOID*>(gphkHashTableAddr);
    // Iterate through the hash table entries.
    for (USHORT j = 0; j < 0x80; j++)
    {
        PVOID item = tableArray[j];
        PHOT_KEY hk = reinterpret_cast<PHOT_KEY>(item);
        if (hk)
        {
            CheckHotkeyNode(hk);
        }
    }
    return TRUE;
}

/*
 * Function: DetectHotKeyBasedKeylogger
 * --------------------------------------
 * Scans the system's hotkey hash table to determine whether all alphanumeric keys are
 * registered as hotkeys. If 36 or more such hotkeys are found, it strongly suggests that
 * every alphanumeric key is hijacked—indicating the possible presence of a hotkey-based keylogger.
 *
 * Return Value:
 *   Returns TRUE if a keylogger is likely detected; FALSE otherwise.
 */
BOOL DetectHotKeyBasedKeylogger() {

    BOOL detected = FALSE;

    //
    // [1] Resolve Win32kfull module base address.
    // 
    UNICODE_STRING win32kfull;
    RtlInitUnicodeString(&win32kfull, L"win32kfull.sys");
    PVOID Win32kfullBaseAddr = GetSystemModuleBase(win32kfull);
    if (!Win32kfullBaseAddr)
    {
        KdPrint(("[-] Failed to get Win32kfull base address.\n"));
        return FALSE;
    }

    //
    // [2] Get EPROCESS of winlogon and attach it. 
    // 
    KAPC_STATE apc;
    PEPROCESS winlogon;
    UNICODE_STRING processName;

    RtlInitUnicodeString(&processName, L"winlogon.exe");
    HANDLE procId = GetPidFromProcessName(processName);
    if (!procId)
    {
        KdPrint(("[-] Failed to get the process id of winlogon.exe.\n"));
        return FALSE;
    }
    NTSTATUS status = PsLookupProcessByProcessId(procId, &winlogon);
    if (!NT_SUCCESS(status))
    {
        KdPrint(("[-] PsLookupProcessByProcessId failed: 0x%x.\n", status));
        return FALSE;
    }
    KeStackAttachProcess(winlogon, &apc);

    //
    // [3] Find and resolve gphkHashTable Address.
    //
    PVOID gphkHashTableAddr = FindgphkHashTableAddress(Win32kfullBaseAddr);
    if (!gphkHashTableAddr)
    {
        KdPrint(("[-] Failed to resolve gphkHashTable address\n"));
        goto Cleanup;
    }

    //
    // [4] Scan the hotkey table to count how many single alphanumeric hotkeys are registered.
    //     If 36 or more are found, it implies that every alphanumeric key is hijacked,
    //     which strongly suggests the presence of a hotkey-based keylogger.
    //
    if (CheckRegisteredHotKeys(gphkHashTableAddr) && hotkeyCounter >= 36)
    {
        detected = TRUE;
        goto Cleanup;
    }

Cleanup:
    KeUnstackDetachProcess(&apc);
    ObDereferenceObject(winlogon);
    return detected;
}

VOID
DriverUnload(
    _In_ PDRIVER_OBJECT DriverObject)
{
    UNREFERENCED_PARAMETER(DriverObject);
    KdPrint(("[+] Unloading the driver..\n"));
}

extern "C"
NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);
    UNREFERENCED_PARAMETER(DriverObject);

    // Set the unload routine
    DriverObject->DriverUnload = DriverUnload;

    KdPrint(("[+] Start Hotkey-based keylogger detector!"));

    if (DetectHotKeyBasedKeylogger())
    {
        KdPrint(("============================================\n"));
        KdPrint(("          [** SECURITY ALERT **]            \n"));
        KdPrint(("      Hotkey-based keylogger detected!      \n"));
        KdPrint(("============================================\n"));
    }
    else
    {
        KdPrint(("[+] Finished the scan. Nothing detected!\n"));
    }

    return STATUS_SUCCESS;
}
```

`HotkeybasedKeyloggerDetector/HotkeybasedKeyloggerDetector.inf`:

```inf
;
; HotkeybasedKeyloggerDetector.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=02/12/2025,1.0.0.0
CatalogFile=HotkeybasedKeyloggerDetector.cat
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12

[SourceDisksNames]
1 = %DiskName%,,,  ; Disk description

[SourceDisksFiles]
HotkeybasedKeyloggerDetector.sys = 1  ; Driver binary file

[Manufacturer]
%ManufacturerName%=Standard,NTamd64  ; Assuming 64-bit Windows

[Standard.NTamd64]
%DeviceName%=HotkeyKeyloggerDetector_Install, ROOT\HotkeyKeyloggerDetector

[HotkeyKeyloggerDetector_Install]
CopyFiles=HotkeyKeyloggerDetector.CopyFiles

[HotkeyKeyloggerDetector_Install.Services]
AddService=HotkeyKeyloggerDetector,0x00000002,HotkeyKeyloggerDetector_ServiceInstall

[HotkeyKeyloggerDetector.CopyFiles]
HotkeybasedKeyloggerDetector.sys

[HotkeyKeyloggerDetector_ServiceInstall]
DisplayName=%ServiceName%
ServiceType=1                  ; SERVICE_KERNEL_DRIVER
StartType=3                    ; SERVICE_DEMAND_START
ErrorControl=1                 ; SERVICE_ERROR_NORMAL
ServiceBinary=%12%\HotkeybasedKeyloggerDetector.sys

[Strings]
ManufacturerName="Hotkey-based Keylogger Detector";
DeviceName="Hotkey-based Keylogger Detector"
ServiceName="Hotkey-based Keylogger Detector"
DiskName="HotkeybasedKeyloggerDetector"

```

`HotkeybasedKeyloggerDetector/HotkeybasedKeyloggerDetector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B8DB6683-2BBA-4229-8414-B669F6D45E5F}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>HotkeybasedKeyloggerDetector</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="HotkeybasedKeyloggerDetector.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HotkeybasedKeyloggerDetector.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HotKeyStructs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HotkeybasedKeyloggerDetector/HotkeybasedKeyloggerDetector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="HotkeybasedKeyloggerDetector.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HotkeybasedKeyloggerDetector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HotKeyStructs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Asuka Nakajima

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Hotkey-based Keylogger Detector

## Introduction
Hotkey-based Keylogger Detector is a Windows kernel-mode driver designed to detect hotkey-based keyloggers that hijack and record keystrokes using system hotkeys (RegisterHotKey API). To detect such keyloggers, the driver scans the win32kfull.sys module, resolves the address of the global hotkey table (gphkHashTable), and then checks the registered hotkeys.

## Usage

To install this driver, you must first enable test mode; please do so at your own risk.
https://learn.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option

* **Install the driver (Open the Command Prompt as Administrator)**
```
sc create HotkeybasedKeyloggerDetector type=kernel start=demand binPath="C:<path_to_driver>\HotkeybasedKeyloggerDetector.sys"
sc start HotkeybasedKeyloggerDetector
```

* **Uninstall the driver**
```
sc stop HotkeybasedKeyloggerDetector
sc delete HotkeybasedKeyloggerDetector
```

* **Demo Video**

This demo showcases how this detection tool detects [Hotkeyz](https://github.com/yo-yo-yo-jbo/hotkeyz), a proof-of-concept hotkey-based keylogger created by [Jonathan Bar Or](https://jonathanbaror.com/)

https://github.com/user-attachments/assets/4eacaa4e-6d6d-4014-ae4c-b1c1c7d8fd2e

(To view log messages in [DebugView](https://learn.microsoft.com/en-us/sysinternals/downloads/debugview), you need to build the driver in "Debug" mode.)

## Disclamer

* This driver is provided for educational and testing purposes only.
* This driver has been tested only on Windows 10 version 22H2 (OS Build 19045.5487). It has not been tested on other versions, so it may not work properly on different Windows builds.
* Use at Your Own Risk: Running this driver is entirely at your own risk. I disclaim all responsibility for any consequences, damages, or disruptions resulting from the use of this driver.
 
## License
This project is released under the MIT License. See the LICENSE file for details.

## Acknowledgement
I would like to express my heartfelt gratitude to [Jonathan Bar Or](https://jonathanbaror.com/) for teaching me about hotkey-based keylogging techniques and, moreover, for kindly sharing [Hotkeyz](https://github.com/yo-yo-yo-jbo/hotkeyz), a proof-of-concept for hotkey-based keyloggers.

```