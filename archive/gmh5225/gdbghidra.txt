Project Path: arc_gmh5225_gdbghidra__tx9azfh

Source Tree:

```txt
arc_gmh5225_gdbghidra__tx9azfh
├── LICENSE
├── Module.manifest
├── README.md
├── build.gradle
├── data
│   ├── README.txt
│   ├── Testing.jpage
│   ├── build.xml
│   ├── gdb_ghidra_bridge_client.py
│   ├── gdbghidra.gif
│   └── languages
│       ├── skel.cspec
│       ├── skel.ldefs
│       ├── skel.opinion
│       ├── skel.pspec
│       ├── skel.sinc
│       └── skel.slaspec
├── dist
│   ├── ghidra_9.0.1_PUBLIC_20190524_gdbghidra.zip
│   └── ghidra_9.0.4_PUBLIC_20190526_gdbghidra.zip
├── extension.properties
├── ghidra_scripts
│   └── README.txt
├── lib
│   ├── README.txt
│   └── json-simple-1.1.1.jar
├── os
│   ├── linux64
│   │   └── README.txt
│   ├── osx64
│   │   └── README.txt
│   └── win64
│       └── README.txt
├── resources
│   └── images
│       ├── running.png
│       └── stopped.png
└── src
    ├── main
    │   ├── help
    │   │   └── help
    │   │       ├── TOC_Source.xml
    │   │       ├── shared
    │   │       │   └── Frontpage.css
    │   │       └── topics
    │   │           └── gdbghidra
    │   │               └── help.html
    │   ├── java
    │   │   └── gdbghidra
    │   │       ├── DeleteBreakpointAction.java
    │   │       ├── GDBGhidraPlugin.java
    │   │       ├── GDBGhidraProvider.java
    │   │       ├── GDBReceiver.java
    │   │       ├── RegisterChangeListener.java
    │   │       ├── RestoreBreakpointsAction.java
    │   │       ├── ToggleBreakpointAction.java
    │   │       └── events
    │   │           ├── BreakpointEvent.java
    │   │           ├── CursorEvent.java
    │   │           ├── Event.java
    │   │           ├── EventParser.java
    │   │           ├── EventType.java
    │   │           ├── HelloEvent.java
    │   │           ├── MemoryEvent.java
    │   │           ├── ParseException.java
    │   │           └── RegisterEvent.java
    │   └── resources
    │       └── images
    │           └── README.txt
    └── test
        └── java
            └── README.test.txt

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Module.manifest`:

```manifest
Module.manifest||Public Domain|||END|


```

`README.md`:

```md
# gdbghidra - a visual bridge between a GDB session and GHIDRA

The purpose of gdbghidra is to provide means during interactive debug sessions in
gdb to quickly follow the flow in GHIDRA; similar to our [gdbida](https://github.com/Comsecuris/gdbida) plugin for IDA Pro. gdbghidra is not meant to be a full debugger. Instead, it merely serves as a small helper tool to assist during interactive debug 
sessions that make use of a mixture of tools. It provides simple means to quickly follow along a gdb debug
session in GHIDRA. Also it does not need any dependencies on the Python side.

gdbghidra consists of the following two parts:
* dist/ghidra_9.0.1_PUBLIC_*_GDBGHIDRA.zip
* data/gdb\_ghidra\_bridge\_client.py : gdb python script

![data/gdbghidra](data/gdbghidra.gif)

Features
========
* Sync/colorize cursor inside GHIDRA to PC of GDB session
* Sync stack to GHIDRA on GDB break
* Automatically set register values within GHIDRA for better decompilation
* GHIDRA register window
* Set/Toggle/Delete breakpoints from GHIDRA
* Automatic relocation

Installation
============
Make a change the ~/.gdbinit configuration file to include the plugin:
```
source ~/gdb_ghidra_bridge_client.py
```

To install the plugin in GHIDRA follow these steps:

* Open GHIDRA and select `File/Install Extensions`. 
* Press the green `+` button and select `dist/ghidra_9.0.1_PUBLIC_*_GDBGHIDRA.zip`. 
* Make sure the Plugin has a tick in the box left.
* Start GHIDRA CodeBrowser.
* Open `File/Configure` and press the adapter icon in above left oft 'Ghidra Core'.
* Filter for `gdb` and make sure `GDBGhidraPlugin` is enabled.

Now you should see the `GDBGhidraPlugin` window. You can now configure the listener port using the `configuration` button and start the server using the `refresh` button.

Next, configure the gdb stub to connect to gdbghidras's port (either command line or gdbinit):
```
ghidrabridge 10.0.10.10:2305
```

Building
========
To build this plugin using gradle run the following command inside gdbghidra directory
```bash
gradle -PGHIDRA_INSTALL_DIR=<PATH_TO_GHIDRA_FOLDER>
```
This produces a fresh extension zip within the `gdbghidra/dist` folder. 

Development
===========
If you want to build gdbghidra from source using GHIDRA's eclipse environment make sure to add `json-simple-1.1.1.jar` to the classpath as follows:

* Click the `Run` Menu and select `Run Configurations`.
* Navigate to `Ghidra/GDBGhidra` and select `Classpath`.
* Navigate down the list to `User Entries`, select `User Entries` and click on `ADD JARS...`.
* Select `lib/json-simple-1.1.1.jar`

Between GHIDRA and GDB a simple JSON message format is spoken which could also be used to connect other tools/debuggers to this GHIDRA plugin.


Notes
=====
Please be aware that this is not considered to be finished. Specifically, the following thoughts are on my mind:
* Network listening input masks untested for errors.
* The network connection is not authenticated in any way.
* A lot of potential for additional commands. For now, I kept it super simple.

```

`build.gradle`:

```gradle
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

```

`data/README.txt`:

```txt
The "data" directory is intended to hold data files that will be used by this module and will
not end up in the .jar file, but will be present in the zip or tar file.  Typically, data
files are placed here rather than in the resources directory if the user may need to edit them.

An optional data/languages directory can exist for the purpose of containing various Sleigh language
specification files and importer opinion files.  

The data/build.xml is used for building the contents of the data/languages directory.

The skel language definition has been commented-out within the skel.ldefs file so that the 
skeleton language does not show-up within Ghidra.

See the Sleigh language documentation (docs/languages/sleigh.htm or sleigh.pdf) for details
on Sleigh language specification syntax.
 

```

`data/Testing.jpage`:

```jpage
System.out.println("test");

//var jp = new org.json.simple.parser.JSONParser();//var r = jp.parse("{\"type\":\"CURSOR\",\"data\":[{\"ADDRESS\":\"0x23\"}]}");
//System.out.println(r);
//System.out.println(((org.json.simple.JSONObject)r).get("type"));
//var da = (org.json.simple.JSONArray)((org.json.simple.JSONObject)r).get("data");
//var d = (org.json.simple.JSONObject)da.get(0);
//System.out.println(d.get("ADDRESS"));
Syntax error, insert ";" to complete BlockStatementsvar l = new java.util.ArrayList<generic.json.JSONToken>();var p = new generic.json.JSONParser();
p.parse("{\"type\":\"CURSOR\",\"data\":[{\"ADDRESS\":\"0x23\"}]}".toCharArray(), l);
System.out.println(l);
System.out.println(l.get(1).start);
System.out.println(l.get(1).size);


System.out.println(Long.decode("0x555555554000"));

System.out.println("0x555555554000".substring(2));
```

`data/build.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!--
  + Compile sleigh languages within this module.
  + Eclipse: right-click on this file and choose menu item "Run As->Ant Build"
  + From command line (requires ant install)
  +    - cd to data directory containing this file
  +    - run ant
  -->
                                     
<project name="privateBuildDeveloper" default="sleighCompile">
	
	<property name="sleigh.compile.class" value="ghidra.pcodeCPort.slgh_compile.SleighCompile"/>

	<property name="repo.dir" value="../../../.." />
	<property name="repo.marker.dir" value="${repo.dir}/.git" />
	
	<!--Import optional ant properties.  GhidraDev Eclipse plugin produces this so this file can find the Ghidra installation-->
	<import file="../.antProperties.xml" optional="true" />
	
	<condition property="devmode">
		<available file="${repo.marker.dir}" type="dir" />
	</condition>

	<target name="buildSleighClasspathDev" if="devmode">
		
		<property name="framework.path" value="${repo.dir}/../ghidra.git/Ghidra/Framework"/>
		<property name="libs.path" value="${repo.dir}/../ghidra.bin.git/ExternalLibraries/libsForRuntime"/>
		
		<path id="sleigh.class.path">
			<pathelement location="${framework.path}/SoftwareModeling/bin"/>
			<pathelement location="${framework.path}/Generic/bin"/>
			<pathelement location="${framework.path}/Utility/bin"/>
			<fileset dir="${libs.path}">
				<include name="*.jar"/>
			</fileset>
		</path>
			
		<available classname="${sleigh.compile.class}" classpathref="sleigh.class.path" property="sleigh.compile.exists"/>
			
	</target>
	
	<target name="buildSleighClasspathDist" unless="devmode">

		<!-- If language module is detached from installation, get Ghidra installation directory path from imported properties -->
		<condition property="framework.path" value="${ghidra.install.dir}/Ghidra/Framework" else="../../../Framework">
			<available file="${ghidra.install.dir}" type="dir" />
		</condition>
		
		<path id="sleigh.class.path">
			<fileset dir="${framework.path}/SoftwareModeling/lib">
				<include name="*.jar"/>
			</fileset>
			<fileset dir="${framework.path}/Generic/lib">
				<include name="*.jar"/>
			</fileset>
			<fileset dir="${framework.path}/Utility/lib">
				<include name="*.jar"/>
			</fileset>
		</path>
		<available classname="${sleigh.compile.class}" classpathref="sleigh.class.path" property="sleigh.compile.exists"/>
			
	</target>	
		
	<target name="sleighCompile" depends="buildSleighClasspathDist, buildSleighClasspathDev">
	    
		<fail unless="sleigh.compile.exists" />
		
		<java classname="${sleigh.compile.class}"
			classpathref="sleigh.class.path"
			fork="true"
			failonerror="true">
			<jvmarg value="-Xmx2048M"/>
			<arg value="-a"/>
			<arg value="./languages"/>
		</java>
		
 	</target>

</project>

```

`data/gdb_ghidra_bridge_client.py`:

```py
# MIT License                                                                     
#                                                                                 
# Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
#                                                                               
# Permission is hereby granted, free of charge, to any person obtaining a copy       
# of this software and associated documentation files (the "Software"), to deal   
# in the Software without restriction, including without limitation the rights       
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
# copies of the Software, and to permit persons to whom the Software is           
# furnished to do so, subject to the following conditions:                        
#                                                                                 
# The above copyright notice and this permission notice shall be included in all  
# copies or substantial portions of the Software.                                 
#                                                                               
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
# SOFTWARE.   
# 
# https://sourceware.org/gdb/onlinedocs/gdb/Events-In-Python.html#Events-In-Python

from __future__ import print_function
import os
import socket
import struct
import json
import base64
import gzip
import tempfile
from threading import Thread

GHIDRA_BRIGE_IP = '127.0.0.1'
GHIDRA_BRIDGE_PORT = 2305
GDB_BRIDGE_IP = '127.0.0.1'
GDB_BRIDGE_PORT = 2306

socket.setdefaulttimeout(0.1)

class GhidraBridge():
    def __init__(self, ip, port):
        self._connected = False
        self._socket = None
        self._ghidra_ip = ip
        self._ghidra_port = port
        
    def connect(self):
        if self._connected and not self._socket._closed:
            return
        
        socket.setdefaulttimeout(10)
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._socket.connect((self._ghidra_ip, self._ghidra_port))
        self._connected = True
        
    def disconnect(self):
        if self._connected:
            self._socket.close()
            self._connected = False

    def send_message(self, message):
        try:
            if not self._connected:
                self.connect()
            if not message: return
                
            self._socket.send(bytes(message + "\n", 'UTF-8'))
        except Exception as e:
            print(e)
            self.disconnect()
            self.connect()
            
    def close(self):
        self.disconnect()

class GDBBridge(Thread):
    # this is the connection from GHIDRA -> GDB
    def __init__(self, ip, port, ghidra_bridge):
        Thread.__init__(self)
        self.exit = False
        self._ghidra_bridge = ghidra_bridge
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._sock.bind((ip, port))
        self._sock.listen(1)
        self._sock.settimeout(10)
        
    def run(self):
        while not self.exit:
            try:
                (con, (ghidra_ip, ghidra_port)) = self._sock.accept()
                line = []
                while True:
                    c = con.recv(1)
                    if c == b'\n':
                        msg = json.loads(b"".join(line))
                        if msg["type"] == "BREAKPOINT":
                            self.handle_breakpoint(msg)
                        elif msg['type'] == "REGISTER":
                            self.handle_register(msg)
                        break                 
                    else:
                        line.append(c)
            
            except socket.timeout:
                pass
            
    def handle_register(self, msg):
        data = msg["data"][0]
        if data["action"] == "change":
            r = data["register"]
            v = data["value"]
            print("[GDBBridge] setting register '%s' to '%s'\n" % (r, v))
            GDBUtils.set_register(r, v)
            
    def handle_breakpoint(self, msg):
        data = msg["data"][0]
        for address in data["breakpoints"]:
            if not( "0x" in address):
                print("[GDBBridge] unknown address (missing 0x) '%s'\n" % address) 
                continue
            
            action = data["action"]
            
            if action == "toggle":
                bpnr, bpenabled = GDBUtils.return_breakpoint_at(address)
                if not bpnr:
                    print("[GDBBridge] adding breakpoint at address: %s\n" % address)
                    GDBUtils.query_gdb("break *%s" % address, "set breakpoint")
                    self._ghidra_bridge.send_message( GhidraMessages.breakpoint(address, "enable"))
                    continue
            
                if bpenabled == "y":
                    print("[GDBBridge] disabling breakpoint at address: %s\n" % address)
                    GDBUtils.query_gdb("disable %s" % bpnr, "disable breakpoint")
                    self._ghidra_bridge.send_message( GhidraMessages.breakpoint(address, "disable"))
                    continue
                
                elif bpenabled == "n":
                    print("[GDBBridge] enabling breakpoint at address: %s\n" % address)
                    GDBUtils.query_gdb("enable %s" % bpnr, "enable breakpoint")
                    self._ghidra_bridge.send_message( GhidraMessages.breakpoint(address, "enable"))
                    continue
            elif action == "delete":
                bpnr, bpenabled = GDBUtils.return_breakpoint_at(address)
                
                GDBUtils.query_gdb("delete %s" % bpnr, "delete breakpoint\n")
                self._ghidra_bridge.send_message( GhidraMessages.breakpoint(address, "delete"))
                continue
            else:
                print("[GDBBridge] unknown breakpoint action '%s'\n" % action)
                continue
            
    def close(self):
        self.exit = True
    

class GhidraMessages:
    @staticmethod
    def encode(msg):
        return json.dumps(msg)

    @staticmethod
    def update_cursor_to(address, using_relocation):
        # "data":[ {"address":hex(gdb.selected_frame().pc()), "relocate":relocate } ],
        msg = {
            "type":"CURSOR",
            "data":[ {
                "address":address, 
                "relocate":using_relocation 
            } ],
        }
        return GhidraMessages.encode(msg)
    
    @staticmethod
    def hello(arch, endian, gdb_ip, gdb_port):
        msg = {
            "type":"HELLO",
            "data":[ {
                "arch":arch,
                "endian":endian,
                "answer_ip":gdb_ip,
                "answer_port":str(gdb_port),
            } ], 
        }
        return GhidraMessages.encode(msg)
    
    @staticmethod
    def breakpoint(address, action):
        msg = {
            "type":"BREAKPOINT",
            "data":[ {
                "breakpoint":address,
                "action":action,
            } ], 
        }
        return GhidraMessages.encode(msg)
    
    @staticmethod
    def update_register(address, register, value):
        msg = {
            "type":"REGISTER",
            "data":[{
                "address":address,
                "name":register,
                "value":value
            }]
        }
        return GhidraMessages.encode(msg)
    
    @staticmethod
    def memory(address, mapping, data, read, write, execute):
        if mapping and data:
            msg ={
                "type":"MEMORY",
                "data":[{
                    "address":mapping["begin"], 
                    "name":mapping["name"], 
                    "data":data, 
                    "size":mapping["size"], 
                    "read":str(read), 
                    "write":str(write), 
                    "execute":str(execute)
                }]
            }
            return GhidraMessages.encode(msg)    
        
        return None
        
    
    
            
class GhidraBridgeCommand(gdb.Command):
    def __init__(self):
        super (GhidraBridgeCommand, self).__init__("ghidrabridge", gdb.COMMAND_USER)
        self._register_and_values = {}
        
        self._ghidra_ip = GHIDRA_BRIGE_IP
        self._ghidra_port = GHIDRA_BRIDGE_PORT
        
        self._ghidra_bridge = GhidraBridge(self._ghidra_ip, self._ghidra_port)
        
        self._gdb_ip = GDB_BRIDGE_IP
        self._gdb_port = GDB_BRIDGE_PORT
        
        self._gdb_bridge = GDBBridge(self._gdb_ip, self._gdb_port, self._ghidra_bridge)
        self._gdb_bridge.daemon = True
        self._gdb_bridge.start()
        
        self._ghidra_bridge.send_message( GhidraMessages.hello(GDBUtils.get_arch(), GDBUtils.get_endian(), self._gdb_ip, self._gdb_port) )
        
        

    def hdl_stop_event(self, event):
        self._ghidra_bridge.send_message( GhidraMessages.update_cursor_to( GDBUtils.get_instruction_pointer(), GDBUtils.get_relocation()) )
        self._update_register_values()
        self._ghidra_bridge.send_message( GhidraMessages.memory( GDBUtils.get_instruction_pointer(), GDBUtils.get_mapping("[stack]"), GDBUtils.get_encoded_stack(), True, True, False ))


    def _update_register_values(self):
        address = GDBUtils.get_instruction_pointer()
        
        for register, value in GDBUtils.get_registers_and_values():
            if register in self._register_and_values and self._register_and_values[register] == value: continue
            
            self._register_and_values[register] = value
            self._ghidra_bridge.send_message( GhidraMessages.update_register(address, register, value))
    
    def hdl_exit_event(self, event):
        self.close()

    def invoke(self, arg, from_tty):
            argv = arg.split(' ')
            if len(argv) < 1:
                    print("ghidrabridge <ip:port>\n")
                    return

            target = argv[0].split(':')

            if not '.' in target[0] or len(target) < 2:
                    print("please specify ip:port combination\n")
                    return

            self._ghidra_ip = target[0]
            self._ghidra_port = int(target[1])
            print("ghidrabridge: using ip: %s port: %d\n" %(self._ghidra_ip, self._ghidra_port))

            gdb.events.stop.connect(self.hdl_stop_event)
            gdb.events.exited.connect(self.hdl_exit_event)

    def close(self):
        self._gdb_bridge.close()
        self._gdb_bridge.join(2000)
        self._ghidra_bridge.close()

class GDBUtils:
    @staticmethod
    def get_relocation():
        r = GDBUtils.query_gdb('info proc stat', 'relocation', 'Start of text: ', 'End of text: ')
        if r == "unknown":
            return "0x0"
        
        return r
    
    @staticmethod
    def get_instruction_pointer():
        return hex(gdb.selected_frame().pc())
        
    @staticmethod
    def get_registers_and_values():
        result = []
        query_result = GDBUtils.query_gdb("info registers", "info registers")
        for register, value in map(lambda x: x.split()[:2], query_result.split("\n")[:-1]):
            result.append( [register, value] )
        return result

    @staticmethod
    def query_gdb(cmd, name, extract_begin=None, extract_end=None):
        val = gdb.execute(cmd, to_string=True)
        if not( extract_begin and extract_end ):
            return val
        
        s_text = val.find(extract_begin)
        e_text = val.find(extract_end)
        if s_text == -1:
            print("[GDBGHIDRA] could not determine %s setting to 'unknown'\n" % name)
            return 'unknown'
        result = val[s_text + len(extract_begin):e_text].strip()
        print("[GDBGHIDRA] found %s '%s'\n" % (name, result))
        return result
    
    @staticmethod
    def return_breakpoint_at(address):
        result = GDBUtils.query_gdb("info breakpoints", "info breakpoint").split("\n")
        for line in result:
            tokens = line.split()
            if "0x" in address:
                if address[2:] in line:
                    return ( tokens[0], tokens[3] )
            else:
                if address in line:
                    return ( tokens[0], tokens[3] ) 
        return (None, None)

    @staticmethod
    def get_encoded_memory(address, name, end, size):
        f = tempfile.NamedTemporaryFile(delete=False)
        gdb.execute("dump memory %s %s %s" % (f.name, address, end))
        with open(f.name, "rb") as m:
            data = base64.b64encode(gzip.compress(m.read())).decode('utf-8')
        
        f.delete
        return data


    @staticmethod
    def get_mapping(named):
        m = GDBUtils.query_gdb("info proc mappings", "mappings")
        if "unable to open" in m:
            return None
        
        x = list(filter(lambda e: named in e, m.split("\n")))[0].split()
        return {"begin":x[0], "end":x[1], "size":x[2], "name":named}
        
    @staticmethod
    def get_encoded_stack():
        mapping = GDBUtils.get_mapping("[stack]")
        if mapping:
            return GDBUtils.get_encoded_memory(mapping["begin"], "stack", mapping["end"], mapping["size"])
        return None

    @staticmethod
    def get_arch():
        return GDBUtils.query_gdb('show arch', 'architecture', "(currently ", ")")   
    
    @staticmethod
    def get_endian():
        return GDBUtils.query_gdb('show endian', 'endianess', "(currently ", " endian)")         


    @staticmethod
    def set_register(register, value):
        gdb.execute("set $%s = %s" % (register, value))

GhidraBridgeCommand()
```

`data/languages/skel.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>

<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg -->

<compiler_spec>
  <data_organization>
	<pointer_size value="2" />
  </data_organization>
  <global>
    <range space="ram"/>
    <range space="io"/>
  </global>
  <stackpointer register="SP" space="ram"/>
  <segmentop space="ram" userop="segment" baseinsize="2" innerinsize="2" farpointer="yes">
    <baseop code="INT_ZEXT"/>
    <baseop code="INT_LEFT" value="12"/>
    <innerop code="INT_ZEXT"/>
    <constresolve>
      <register name="rBBR"/>
    </constresolve>
  </segmentop>
  <default_proto>
    <prototype name="__asmA" extrapop="2" stackshift="2" strategy="register">
      <input>
        <pentry minsize="1" maxsize="1">
          <register name="A"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="BC"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="HL"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="DE"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="IY"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="IX"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="2">
          <addr offset="2" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="1">
          <register name="A"/>
        </pentry>
      </output>
      <unaffected>
        <register name="SP"/>
        <register name="BC_"/>
        <register name="HL_"/>
        <register name="DE_"/>
        <register name="AF_"/>
        <register name="rBBR"/>
      </unaffected>
    </prototype>
  </default_proto>
  <prototype name="__asmAF" extrapop="2" stackshift="2" strategy="register">
      <input>
        <pentry minsize="1" maxsize="1">
          <register name="A"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="BC"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="HL"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="DE"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="IY"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="IX"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="2">
          <addr offset="2" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="2">
          <register name="AF"/>
        </pentry>
      </output>
      <unaffected>
        <register name="SP"/>
        <register name="rBBR"/>
        <register name="BC_"/>
        <register name="HL_"/>
        <register name="DE_"/>
        <register name="AF_"/>
      </unaffected>
  </prototype>
  <prototype name="__stdcall" extrapop="2" stackshift="2">
      <input>
        <pentry minsize="1" maxsize="1">
          <register name="A"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="BC"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="HL"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="2">
          <addr offset="2" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="1">
          <register name="AF"/>
        </pentry>
      </output>
      <unaffected>
        <register name="SP"/>
        <register name="rBBR"/>
        <register name="BC_"/>
        <register name="HL_"/>
        <register name="DE_"/>
        <register name="AF_"/>
      </unaffected>
    </prototype>
</compiler_spec>

```

`data/languages/skel.ldefs`:

```ldefs
<?xml version="1.0" encoding="UTF-8"?>

<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/language_definitions.rxg -->

<language_definitions>
<!-- Uncomment the following to make the language available in Ghidra -->
<!-- 
   <language processor="Skel"
            endian="little"
            size="16"
            variant="default"
            version="1.0"
            slafile="skel.sla"
            processorspec="skel.pspec"
            id="skel:LE:16:default">
    <description>Skeleton Language Module</description>
    <compiler name="default" spec="skel.cspec" id="default"/>
  </language> 
-->
</language_definitions>

```

`data/languages/skel.opinion`:

```opinion
<opinions>
<!-- Example of importer opinions - commented-out to prevent use by Ghidra -->
<!-- The primary and secondary constraint values must be specifide as a decimal string -->
<!--
    <constraint loader="Executable and Linking Format (ELF)" compilerSpecID="default">
    		<constraint primary="40"   secondary="123"  processor="Skel"  size="16" variant="default" />
    </constraint>
    <constraint loader="MS Common Object File Format (COFF)" compilerSpecID="default">
        <constraint primary="61"                    processor="Skel"  size="16" variant="default" />
    </constraint>
-->
</opinions>

```

`data/languages/skel.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>

<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/processor_spec.rxg -->

<processor_spec>
  <programcounter register="PC"/>
  <register_data>
    <register name="AF_" group="Alt"/>
    <register name="BC_" group="Alt"/>
    <register name="DE_" group="Alt"/>
    <register name="HL_" group="Alt"/>
  </register_data>
  <default_symbols>
    <symbol name="RST0" address="ram:0000" entry="true"/>
    <symbol name="RST1" address="ram:0008" entry="false"/>
    <symbol name="RST2" address="ram:0010" entry="false"/>
    <symbol name="RST3" address="ram:0018" entry="false"/>
    <symbol name="RST4" address="ram:0020" entry="false"/>
    <symbol name="RST5" address="ram:0028" entry="false"/>
    <symbol name="RST6" address="ram:0030" entry="false"/>
    <symbol name="RST7" address="ram:0038" entry="false"/>
  </default_symbols>
</processor_spec>

```

`data/languages/skel.sinc`:

```sinc
# sleigh include file for Skeleton language instructions

define token opbyte (8)
   op0_8     = (0,7)
   op6_2     = (6,7)
   
   dRegPair4_2    = (4,5)
   pRegPair4_2    = (4,5)
   sRegPair4_2    = (4,5)
   qRegPair4_2    = (4,5)
   qRegPair4_2a   = (4,5)
   qRegPair4_2b   = (4,5)
   rRegPair4_2    = (4,5)

   reg3_3 = (3,5)
   bits3_3   = (3,5)
   
   bits0_4   = (0,3)
   
   reg0_3 = (0,2)
   bits0_3   = (0,2)
;

define token data8 (8)
   imm8		= (0,7)
   sign8	= (7,7)
   simm8	= (0,7) signed
;

define token data16 (16)
   timm4        = (12,15)
   imm16        = (0,15)
   sign16		= (15,15)
   simm16		= (0,15) signed
;

attach variables [ reg0_3 reg3_3 ] [ B C D E H L _ A ];

attach variables [ sRegPair4_2 dRegPair4_2 ] [ BC DE HL SP ];

attach variables [ qRegPair4_2 ] [ BC DE HL AF ];
attach variables [ qRegPair4_2a ] [ B D H A ];
attach variables [ qRegPair4_2b ] [ C E L F ];

attach variables [ pRegPair4_2 ] [ BC DE IX SP ];
attach variables [ rRegPair4_2 ] [ BC DE IY SP ];

################################################################
# Macros
################################################################

macro setResultFlags(result) {
	$(Z_flag) = (result == 0);
	$(S_flag) = (result s< 0);
}

macro setAddCarryFlags(op1,op2) {
	$(C_flag) = (carry(op1,zext($(C_flag))) || carry(op2,op1 + zext($(C_flag))));
}

macro setAddFlags(op1,op2) {
	$(C_flag) = carry(op1,op2);
}

macro setSubtractCarryFlags(op1,op2) {
	notC = ~$(C_flag);
	$(C_flag) = ((op1 < sext(notC)) || (op2 < (op1 - sext(notC))));
}

macro setSubtractFlags(op1,op2) {
	$(C_flag) = (op1 < op2);
}

macro push16(val16) {
	SP = SP - 2;
	*:2 SP = val16; 
}

macro pop16(ret16) {
	ret16 = *:2 SP;
	SP = SP + 2; 
}

macro push8(val8) {
	SP = SP - 1;
	ptr:2 = SP;
	*:1 ptr = val8; 
}

macro pop8(ret8) {
    ptr:2 = SP;
	ret8 = *:1 ptr;
	SP = SP + 1; 
}

################################################################

ixMem8: (IX+simm8)  is IX & simm8								{ ptr:2 = IX + simm8; export *:1 ptr; }
ixMem8: (IX-val)    is IX & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IX + simm8; export *:1 ptr; }

iyMem8: (IY+simm8)  is IY & simm8								{ ptr:2 = IY + simm8; export *:1 ptr; }
iyMem8: (IY-val)    is IY & simm8 & sign8=1	[ val = -simm8; ]	{ ptr:2 = IY + simm8; export *:1 ptr; }

Addr16: imm16		is imm16									{ export *:1 imm16; }

Mem16: (imm16)		is imm16									{ export *:2 imm16; }

RelAddr8: loc		is simm8  [ loc = inst_next + simm8; ]		{ export *:1 loc; }

cc: "NZ"            is bits3_3=0x0                              { c:1 = ($(Z_flag) == 0); export c; }
cc: "Z"             is bits3_3=0x1                              { c:1 = $(Z_flag); export c; }
cc: "NC"            is bits3_3=0x2                              { c:1 = ($(C_flag) == 0); export c; }
cc: "C"             is bits3_3=0x3                              { c:1 = $(C_flag); export c; }
cc: "PO"            is bits3_3=0x4                              { c:1 = ($(PV_flag) == 0); export c; }
cc: "PE"            is bits3_3=0x5                              { c:1 = $(PV_flag); export c; }
cc: "P"             is bits3_3=0x6                              { c:1 = ($(S_flag) == 0); export c; }
cc: "M"             is bits3_3=0x7                              { c:1 = $(S_flag); export c; }

cc2: "NZ"            is bits3_3=0x4                              { c:1 = ($(Z_flag) == 0); export c; }
cc2: "Z"             is bits3_3=0x5                              { c:1 = $(Z_flag); export c; }
cc2: "NC"            is bits3_3=0x6                              { c:1 = ($(C_flag) == 0); export c; }
cc2: "C"             is bits3_3=0x7                              { c:1 = $(C_flag); export c; }

################################################################


:LD IX,Mem16  is op0_8=0xdd & IX; op0_8=0x2a; Mem16 {
	IX = Mem16;
}

:LD IY,Mem16  is op0_8=0xfd & IY; op0_8=0x2a; Mem16 {
	IY = Mem16;
}

:LD Mem16,HL  is op0_8=0x22 & HL; Mem16 {
	Mem16 = HL;
}

:LD Mem16,dRegPair4_2  is op0_8=0xed; op6_2=0x1 & dRegPair4_2 & bits0_4=0x3; Mem16 {
	Mem16 = dRegPair4_2;
}

:LD Mem16,IX  is op0_8=0xdd & IX; op0_8=0x22; Mem16 {
	Mem16 = IX;
}

:LD Mem16,IY  is op0_8=0xfd & IY; op0_8=0x22; Mem16 {
	Mem16 = IY;
}

:NEG  is op0_8=0xed; op0_8=0x44 {
	$(PV_flag) = (A == 0x80);
	$(C_flag) = (A != 0);
	A = -A;
	setResultFlags(A);
}

:SET bits3_3,ixMem8  is op0_8=0xdd; op0_8=0xcb; ixMem8; op6_2=0x3 & bits3_3 & bits0_3=0x6 {
	mask:1 = (1 << bits3_3);
	val:1 = ixMem8;
	ixMem8 = val | mask;
}

:SET bits3_3,iyMem8  is op0_8=0xfd; op0_8=0xcb; iyMem8; op6_2=0x3 & bits3_3 & bits0_3=0x6 {
	mask:1 = (1 << bits3_3);
	val:1 = iyMem8;
	iyMem8 = val | mask;
}

:JP Addr16  is op0_8=0xc3; Addr16 {
	goto Addr16;	
}

:JP cc,Addr16  is op6_2=0x3 & cc & bits0_3=0x2; Addr16 {
	if (!cc) goto Addr16;
}

:JR RelAddr8  is op0_8=0x18; RelAddr8 {
	goto RelAddr8;
}

:JR cc2,RelAddr8  is op6_2=0x0 & cc2 & bits0_3=0x0; RelAddr8 {
	if (cc2) goto RelAddr8;
}

:JP (HL)  is op0_8=0xe9 & HL {
	goto [HL];
}

:JP (IX)  is op0_8=0xdd & IX; op0_8=0xe9 {
	goto [IX];
}

:JP (IY)  is op0_8=0xfd & IY; op0_8=0xe9 {
	goto [IY];
}

:CALL Addr16  is op0_8=0xcd; Addr16 {
    push16(&:2 inst_next);
	call Addr16;
}

:CALL cc,Addr16  is op6_2=0x3 & cc & bits0_3=0x4; Addr16 {
	if (!cc) goto inst_next;
    push16(&:2 inst_next);
	call Addr16;
}

:RET  is op0_8=0xc9 {
	pop16(PC);
	ptr:2 = zext(PC);
	return [ptr];
}

:RET cc  is op6_2=0x3 & cc & bits0_3=0x0 {
	if (!cc) goto inst_next;
	pop16(PC);
	ptr:2 = zext(PC);
	return [ptr];
}	

```

`data/languages/skel.slaspec`:

```slaspec
# sleigh specification file for Skeleton Processor
#   >> see docs/languages/sleigh.htm or sleigh.pdf for Sleigh syntax
# Other language modules (see Ghidra/Processors) may provide better examples
# when creating a new language module.

define endian=little;
define alignment=1;

define space ram     type=ram_space      size=2  default;

define space io      type=ram_space      size=2;
define space register type=register_space size=1;

define register offset=0x00 size=1 [ F A C B E D L H I R ];
define register offset=0x00 size=2 [ AF  BC  DE  HL ];
define register offset=0x20 size=1 [ A_ F_ B_ C_ D_ E_ H_ L_ ]; # Alternate registers
define register offset=0x20 size=2 [ AF_   BC_   DE_   HL_ ]; # Alternate registers

define register offset=0x40 size=2 [ _  PC SP IX IY ];

define register offset=0x50 size=1 [ rCBAR rCBR rBBR ];

# Define context bits (if defined, size must be multiple of 4-bytes)
define register offset=0xf0 size=4   contextreg;

define context contextreg
  assume8bitIOSpace		= (0,0)
;

# Flag bits (?? manual is very confusing - could be typos!)
@define C_flag "F[0,1]"		# C: Carry
@define N_flag "F[1,1]"		# N: Add/Subtract
@define PV_flag "F[2,1]"	# PV: Parity/Overflow
@define H_flag "F[4,1]"		# H: Half Carry
@define Z_flag "F[6,1]"		# Z: Zero
@define S_flag "F[7,1]"		# S: Sign

# Include contents of skel.sinc file
@include "skel.sinc"

```

`extension.properties`:

```properties
name=@extname@
description=A visual bridge between a GDB session and GHIDRA.
author=
createdOn=
version=@extversion@

```

`ghidra_scripts/README.txt`:

```txt
Java source directory to hold module-specific Ghidra scripts.

```

`lib/README.txt`:

```txt
The "lib" directory is intended to hold Jar files which this module
is dependent upon.  This directory may be eliminated from a specific
module if no other Jar files are needed.

```

`os/linux64/README.txt`:

```txt
The "os/linux64" directory is intended to hold Linux native binaries
which this module is dependent upon.   This directory may be eliminated for a specific 
module if native binaries are not provided for the corresponding platform.

```

`os/osx64/README.txt`:

```txt
The "os/osx64" directory is intended to hold macOS (OS X) native binaries
which this module is dependent upon.   This directory may be eliminated for a specific 
module if native binaries are not provided for the corresponding platform.

```

`os/win64/README.txt`:

```txt
The "os/win64" directory is intended to hold MS Windows native binaries (.exe)
which this module is dependent upon.   This directory may be eliminated for a specific 
module if native binaries are not provided for the corresponding platform.

```

`src/main/help/help/TOC_Source.xml`:

```xml
<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- 

	This is an XML file intended to be parsed by the Ghidra help system.  It is loosely based 
	upon the JavaHelp table of contents document format.  The Ghidra help system uses a 
	TOC_Source.xml file to allow a module with help to define how its contents appear in the 
	Ghidra help viewer's table of contents.  The main document (in the Base module) 
	defines a basic structure for the 
	Ghidra table of contents system.  Other TOC_Source.xml files may use this structure to insert
	their files directly into this structure (and optionally define a substructure).
	
	
	In this document, a tag can be either a <tocdef> or a <tocref>.  The former is a definition
	of an XML item that may have a link and may contain other <tocdef> and <tocref> children.  
	<tocdef> items may be referred to in other documents by using a <tocref> tag with the 
	appropriate id attribute value.  Using these two tags allows any module to define a place 
	in the table of contents system (<tocdef>), which also provides a place for 
	other TOC_Source.xml files to insert content (<tocref>).  
	
	During the help build time, all TOC_Source.xml files will be parsed and	validated to ensure
	that all <tocref> tags point to valid <tocdef> tags.  From these files will be generated
	<module name>_TOC.xml files, which are table of contents files written in the format 
	desired by the JavaHelp system.   Additionally, the genated files will be merged together
	as they are loaded by the JavaHelp system.  In the end, when displaying help in the Ghidra
	help GUI, there will be on table of contents that has been created from the definitions in 
	all of the modules' TOC_Source.xml files.

	
	Tags and Attributes
	
	<tocdef>
	-id          - the name of the definition (this must be unique across all TOC_Source.xml files)	
	-text        - the display text of the node, as seen in the help GUI
	-target**    - the file to display when the node is clicked in the GUI
	-sortgroup   - this is a string that defines where a given node should appear under a given
	               parent.  The string values will be sorted by the JavaHelp system using
	               a javax.text.RulesBasedCollator.  If this attribute is not specified, then
	               the text of attribute will be used.

	<tocref>
	-id			 - The id of the <tocdef> that this reference points to 
	
	**The URL for the target is relative and should start with 'help/topics'.  This text is 
	used by the Ghidra help system to provide a universal starting point for all links so that
	they can be resolved at runtime, across modules.
	
	
-->


<tocroot>
	<!-- Uncomment and adjust fields to add help topic to help system's Table of Contents
	<tocref id="Ghidra Functionality">
		<tocdef id="HelpAnchor" text="My Feature" target="help/topics/my_topic/help.html" />
	</tocref>
	-->
</tocroot>

```

`src/main/help/help/shared/Frontpage.css`:

```css
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
									WARNING!
    This file is copied to all help directories.  If you change this file, you must copy it 
    to each src/main/help/help/shared directory.									
									
	
	Java Help Note:  JavaHelp does not accept sizes (like in 'margin-top') in anything but 
	px (pixel) or with no type marking. 

*/ 

body { margin-bottom: 50px; margin-left: 10px; margin-right: 10px; margin-top: 10px; } /* some padding to improve readability */ 
li { font-family:times new roman; font-size:14pt; }
h1 { color:#000080; font-family:times new roman; font-size:36pt; font-style:italic; font-weight:bold; text-align:center; }
h2 { margin: 10px; margin-top: 20px; color:#984c4c; font-family:times new roman; font-size:18pt; font-weight:bold; }
h3 { margin-left: 10px; margin-top: 20px; color:#0000ff; font-family:times new roman; font-size:14pt; font-weight:bold;  }
h4 { margin-left: 10px; margin-top: 20px; font-family:times new roman; font-size:14pt; font-style:italic; }
 
/*
	 P tag code.  Most of the help files nest P tags inside of blockquote tags (the was the 
	 way it had been done in the beginning).  The net effect is that the text is indented.  In 
	 modern HTML we would use CSS to do this.  We need to support the Ghidra P tags, nested in
	 blockquote tags, as well as naked P tags.  The following two lines accomplish this.  Note
	 that the 'blockquote p' definition will inherit from the first 'p' definition.
*/
p { margin-left: 40px; font-family:times new roman; font-size:14pt; }
blockquote p { margin-left: 10px; }

p.providedbyplugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px  }
p.ProvidedByPlugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px }
p.relatedtopic { color:#800080; margin-left: 10px; font-size:14pt; }
p.RelatedTopic { color:#800080; margin-left: 10px; font-size:14pt; }

/* 
	We wish for a tables to have space between it and the preceding element, so that text
	is not too close to the top of the table.  Also, nest the table a bit so that it is clear
	the table relates to the preceding text.
*/
table { margin-left: 20px; margin-top: 10px; width: 80%;}
td { font-family:times new roman; font-size:14pt; vertical-align: top; }
th { font-family:times new roman; font-size:14pt; font-weight:bold; background-color: #EDF3FE; }

code { color: black; font-family: courier new; font-size: 14pt; }

```

`src/main/help/help/topics/gdbghidra/help.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Skeleton Help File for a Module</TITLE>
    <LINK rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
  </HEAD>

  <BODY>
    <H1><a name="HelpAnchor"></a>Skeleton Help File for a Module</H1>

    <P>This is a simple skeleton help topic. For a better description of what should and should not
    go in here, see the "sample" Ghidra extension in the Extensions/Ghidra directory, or see your 
    favorite help topic. In general, language modules do not have their own help topics.</P>
  </BODY>
</HTML>

```

`src/main/java/gdbghidra/DeleteBreakpointAction.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra;

import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.MenuData;
import ghidra.app.context.ListingActionContext;
import ghidra.program.model.address.Address;
import ghidra.program.util.MarkerLocation;

class DeleteBreakpointAction extends DockingAction {
	private GDBReceiver gdbReceiver;

	DeleteBreakpointAction(GDBGhidraPlugin pl) {
		super("Delete Breakpoint", pl.getName());
		setDescription("Delete breakpoint at current location");
		setPopupMenuData(new MenuData(new String[] {"Delete breakpoint"}, null, "Breakpoint"));
		this.gdbReceiver = null;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		Address address = getAddress(context);
		if(this.gdbReceiver != null) {
			this.gdbReceiver.deleteBreakpoint(address);
		}
	}
	
	public void setGDBReceiver(GDBReceiver gdbReceiver) {
		this.gdbReceiver = gdbReceiver;
	}
	
	private Address getAddress(ActionContext context) {
		Object contextObject = context.getContextObject();
		if(MarkerLocation.class.isAssignableFrom(contextObject.getClass())) {
			return ((MarkerLocation) contextObject).getAddr();
		} else if (context instanceof ListingActionContext ) {
			return ((ListingActionContext) context).getAddress();
		}
		return null;
	}
	
}

```

`src/main/java/gdbghidra/GDBGhidraPlugin.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra;

import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.framework.plugintool.*;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.program.util.ProgramLocation;

//@formatter:off
@PluginInfo(
	status = PluginStatus.STABLE,
	packageName = "GDBGhidra",
	category = PluginCategoryNames.DEBUGGER,
	shortDescription = "GDB to Ghidra bridge.",
	description = "Syncs the current instruction pointer from a gdbserver session to the current cursor of Ghidra."
)
//@formatter:on
public class GDBGhidraPlugin extends ProgramPlugin {

	GDBGhidraProvider provider;
	
	public GDBGhidraPlugin(PluginTool tool) {
		super(tool, true, true);

		String pluginName = getName();
		provider = new GDBGhidraProvider(this, pluginName);
	}
	
	@Override
	public void init() {
		super.init();
	}
	
	@Override
	public void locationChanged(ProgramLocation loc) {
		provider.locationChanged(currentProgram, loc);
	}

	public GDBGhidraProvider getProvider() {
		return this.provider;
	}
}

```

`src/main/java/gdbghidra/GDBGhidraProvider.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionEvent;

import javax.swing.AbstractAction;
import javax.swing.BoxLayout;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import javax.swing.border.BevelBorder;
import javax.swing.table.DefaultTableModel;
import docking.ActionContext;
import docking.WindowPosition;
import docking.action.DockingAction;
import docking.action.ToolBarData;
import docking.widgets.table.GTable;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;
import ghidra.app.script.*;
import ghidra.framework.plugintool.ComponentProviderAdapter;
import resources.Icons;

public class GDBGhidraProvider extends ComponentProviderAdapter {
	private JPanel panel;
	private DockingAction action;
	private DockingAction portAction;
	private DockingAction stopAction;
	private ProgramLocation currentLocation;
	private GDBReceiver gdbReceiver;
	private Program currentProgram;
	private GDBGhidraPlugin plugin;
	private Thread gdbReceiverThread = null;
	private DefaultTableModel model = null;
	private JLabel status = new JLabel();
	private Address previousAddress;
	private Color previousColor;
	
	
	public GDBGhidraProvider(GDBGhidraPlugin plugin, String owner) {
		super(plugin.getTool(), owner, owner);
		this.model = new DefaultTableModel( new String[] {"register", "value"}, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				if(column == 0) {
					return false;
				}
				return true;
			}
		};
		this.plugin = plugin;
		buildTable();
		
		this.gdbReceiver = new GDBReceiver(2305, plugin, model);
		
		createActions();
		setWindowGroup("core.GDBGhidra");
		setIntraGroupPosition(WindowPosition.RIGHT);
	}

	public void buildTable() {
		panel = new JPanel(new BorderLayout());
		var table = new GTable(this.model);
		panel.add(new JScrollPane(table));

		var statusPanel = new JPanel();
		statusPanel.setBorder(new BevelBorder(BevelBorder.LOWERED));
		panel.add(statusPanel, BorderLayout.SOUTH);
		statusPanel.setLayout(new BoxLayout(statusPanel, BoxLayout.X_AXIS));

		status.setText("stopped");
		status.setHorizontalAlignment(SwingConstants.LEFT);
		statusPanel.add(status);
		
		var a = new AbstractAction() {
			public void actionPerformed(ActionEvent a) {
				RegisterChangeListener l = (RegisterChangeListener)a.getSource();
				if(l.getColumn() != 1) {
					return;
				}
				gdbReceiver.ChangeRegister((String)table.getValueAt(l.getRow(), 0), (String)l.getNewValue());
			}
		};
		
		new RegisterChangeListener(table, a);
		
		setVisible(true);
	}
	
	private void createActions() {		
		action = new DockingAction("Run", getName()) {

			@Override
			public void actionPerformed(ActionContext context) {
				System.out.println("[GDBGhidra] Starting server on port " + gdbReceiver.getPort() + "\n");
				gdbReceiverThread = new Thread(gdbReceiver);
				gdbReceiverThread.start();
				status.setText("running");
			}
		};
		action.setToolBarData(new ToolBarData(Icons.REFRESH_ICON, null));
		action.setEnabled(true);
		action.markHelpUnnecessary();
		dockingTool.addLocalAction(this, action);
		
		stopAction = new DockingAction("Stop", getName()) {

			@Override
			public void actionPerformed(ActionContext context) {
				System.out.println("[GDBGhidra] Stopping server\n");
				gdbReceiver.stop();
				try {
					if(gdbReceiverThread != null && gdbReceiverThread.isAlive()) {
						gdbReceiverThread.join(2000);
					}
					gdbReceiverThread = null;
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				gdbReceiverThread = null;
				status.setText("stopped");
			}
		};
		stopAction.setToolBarData(new ToolBarData(Icons.STOP_ICON, null));
		stopAction.setEnabled(true);
		stopAction.markHelpUnnecessary();
		dockingTool.addLocalAction(this, stopAction);

		portAction = new DockingAction("Configure", "Port") {
			@Override
			public void actionPerformed(ActionContext context) {
				AskDialog<Integer> d = new AskDialog<>("Listener port configuration", "Please enter TCP listener port:", AskDialog.INT, gdbReceiver.getPort());
				if(d.isCanceled()) {
					// WAAAAH!
				}
				gdbReceiver.setPort( Integer.valueOf(d.getValueAsString()).intValue() );
			}
		};
		portAction.setToolBarData(new ToolBarData(Icons.CONFIGURE_FILTER_ICON, null));
		portAction.setEnabled(true);
		portAction.markHelpUnnecessary();
		dockingTool.addLocalAction(this, portAction);
		
		DeleteBreakpointAction deleteBreakpointAction = new DeleteBreakpointAction(this.plugin);
		deleteBreakpointAction.setEnabled(true);
		deleteBreakpointAction.setGDBReceiver(gdbReceiver);
		dockingTool.addAction(deleteBreakpointAction);
		
		/*
		RestoreBreakpointsAction restoreBreakpointsAction = new RestoreBreakpointsAction(this.plugin);
		 
		restoreBreakpointsAction.setEnabled(true);
		restoreBreakpointsAction.setGDBReceiver(gdbReceiver);
		dockingTool.addAction(restoreBreakpointsAction); */
		
		
		ToggleBreakpointAction breakpointAction = new ToggleBreakpointAction(this.plugin);
		breakpointAction.setEnabled(true);
		breakpointAction.setGDBReceiver(gdbReceiver);
		dockingTool.addAction(breakpointAction);
		
	}

	@Override
	public JComponent getComponent() {
		return panel;
	}

	public void locationChanged(Program cp, ProgramLocation loc) {
		this.currentProgram = cp;
		this.currentLocation = loc;		
		
		gdbReceiver.updateState(currentProgram, currentLocation);
	}

	public void setPreviousAddress(Address newAddress) {
		this.previousAddress = newAddress;
	}
	public Address getPreviousAddress() {
		return this.previousAddress;
	}

	public void setPreviousColor(Color previousColor) {
		this.previousColor = previousColor;		
	}

	public Color getPreviousColor() {
		return this.previousColor;
	}
	
}

```

`src/main/java/gdbghidra/GDBReceiver.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.HashMap;

import javax.swing.table.DefaultTableModel;

import org.json.simple.JSONObject;
import gdbghidra.events.BreakpointEvent;
import gdbghidra.events.CursorEvent;
import gdbghidra.events.EventParser;
import gdbghidra.events.HelloEvent;
import gdbghidra.events.MemoryEvent;
import gdbghidra.events.RegisterEvent;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;

public class GDBReceiver implements Runnable{

	private int port;
	private GDBGhidraPlugin plugin;
	private boolean stop;
	private ServerSocket socket;
	private HelloEvent helloEvent;
	private long relocate = 0;
	private Program currentProgram;
	private ProgramLocation currentLocation;
	private HashMap<String, BigInteger> registers;
	private DefaultTableModel model;
	
	public GDBReceiver(int port, GDBGhidraPlugin plugin, DefaultTableModel model) {
		this.port = port;
		this.plugin = plugin;
		this.stop = false;
		this.helloEvent = null;
		this.registers = new HashMap<String, BigInteger>();
		this.model = model;
	}

	@Override
	public void run() {
		this.stop = false;
		
		try { 
			this.socket = new ServerSocket(port);
			while(!this.stop) {
				handleConnection(socket.accept());
			}
		} catch(SocketException e) {
			if(!e.getMessage().contentEquals("Socket closed")) {
				e.printStackTrace();	
			}
			this.stop = true;
			return;
		}catch (IOException|gdbghidra.events.ParseException e) {
			e.printStackTrace();
			this.stop = true;
			return;
		}
		
	}
	
	private void handleConnection(Socket sock) throws IOException, gdbghidra.events.ParseException {
		String msgBuffer;
		try (
				var is = sock.getInputStream();
				var isr = new InputStreamReader(is);
				var read = new BufferedReader(isr);
				var os = sock.getOutputStream();
		) {				
			while(true) {
				msgBuffer = read.readLine();
				if(msgBuffer == null || msgBuffer.length() == 0) {
					continue;
				}
				System.out.println("[GDBGhidra] received message: " + String.valueOf(msgBuffer.length()) + " bytes: '" + msgBuffer + "'\n");

				var tmpEvent = EventParser.fromJsonString(msgBuffer);
				switch(tmpEvent.getType()) {
					case HELLO:
						var helloEvent = (HelloEvent)tmpEvent;
						this.helloEvent = helloEvent;
						break;
					case CURSOR:
						var cursorEvent = (CursorEvent)tmpEvent;
						this.relocate = CursorEvent.handleEvent(cursorEvent, currentProgram, this.plugin);
						
						break;
					case REGISTER:
						var registerEvent = (RegisterEvent)tmpEvent;
						RegisterEvent.handleEvent(registerEvent, currentProgram, this.plugin, currentLocation);
						updateTable(registerEvent);
						
						break;
					case BREAKPOINT:
						var breakpoint = (BreakpointEvent)tmpEvent;
						BreakpointEvent.handleEvent(breakpoint, currentProgram, this.plugin, this.relocate);
						
						break;
					case MEMORY:
						var memEvent = (MemoryEvent)tmpEvent;
						MemoryEvent.handleEvent(memEvent, currentProgram);
						break;
				}				
			}
		} catch (SocketTimeoutException e) {
			return;
		}
	}
	
	private void updateTable(RegisterEvent registerEvent) {
		var k = registerEvent.getName();
		var v = registerEvent.getValue();
		if(this.registers.containsKey(k)) {
			this.registers.replace(k, v);
		}else {
			this.registers.put(k, v);
		}
		int i=0;
		boolean found = false;
		for(i=0; i < this.model.getRowCount(); i++) {
			String key = (String)this.model.getValueAt(i, 0);
			if(key.contentEquals(registerEvent.getName())) {
				this.model.setValueAt(registerEvent.getHexString(), i, 1);								
				found = true;
				break;
			}
		}
		if(!found) {
			this.model.addRow(new Object[] {registerEvent.getName(), registerEvent.getHexString()});
		}		
	}

	public void setPort(int port) {
		this.port = port;
	}

	public void updateState(Program cp, ProgramLocation cl) {
		this.currentProgram = cp;
		this.currentLocation = cl;		
	}

	public void stop() {
		this.stop = true;
		if(this.socket != null) {
			try {
				this.socket.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	public int getPort() {
		return this.port;
	}
	
	public void addBreakpoint(Address address) {
		if(this.helloEvent == null) {
			return;
		}
		
		var response = BreakpointEvent.constructJSONResponse(this.relocate + address.subtract(currentProgram.getImageBase()), "toggle");
		sendResponse(response);
	}

	public void sendResponse(JSONObject response) {
		System.out.println("[GDBGhidra] sending message:\t"+response.toJSONString()+"\n");
		
		try(
				var s = new Socket(this.helloEvent.getAnswerIp(), this.helloEvent.getAnswerPort());
				var dos = new DataOutputStream(s.getOutputStream());
				) {
			dos.write((response.toJSONString() + "\n").getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void deleteBreakpoint(Address address) {
		if(this.helloEvent == null) {
			return;
		}
		
		var response = BreakpointEvent.constructJSONResponse(this.relocate + address.subtract(currentProgram.getImageBase()), "delete");
		sendResponse(response);
	}

	public void restoreBreakpoints() {
		var it = currentProgram.getBookmarkManager().getBookmarksIterator("breakpoint");
		while(it.hasNext()) {
			var bm = it.next();
			
			var response = BreakpointEvent.constructJSONResponse(this.relocate + bm.getAddress().subtract(currentProgram.getImageBase()), "toggle");
			sendResponse(response);	
		}		
	}

	public void ChangeRegister(String register, String newValue) {
		if(this.helloEvent == null) {
			return;
		}
		
		var response = RegisterEvent.constructJSONResponse(register, newValue, "change");
		sendResponse(response);
	}
}

```

`src/main/java/gdbghidra/RegisterChangeListener.java`:

```java
package gdbghidra;

import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import javax.swing.Action;
import javax.swing.JTable;
import javax.swing.SwingUtilities;

public class RegisterChangeListener implements PropertyChangeListener, Runnable {
	private JTable table;
	private Action action;

	private int row;
	private int column;
	private Object oldValue;
	private Object newValue;

	public RegisterChangeListener(JTable table, Action action) {
		this.table = table;
		this.action = action;
		this.table.addPropertyChangeListener(this);
	}

	private RegisterChangeListener(JTable table, int row, int column, Object oldValue, Object newValue) {
		this.table = table;
		this.row = row;
		this.column = column;
		this.oldValue = oldValue;
		this.newValue = newValue;
	}

	public int getColumn() {
		return column;
	}

	public Object getNewValue() {
		return newValue;
	}

	public Object getOldValue() {
		return oldValue;
	}

	public int getRow() {
		return row;
	}

	public JTable getTable() {
		return table;
	}
	
	@Override
	public void propertyChange(PropertyChangeEvent e) {
		if ("tableCellEditor".equals(e.getPropertyName())) {
			if (table.isEditing())
				processEditingStarted();
			else
				processEditingStopped();
		}
	}

	private void processEditingStarted() {
		SwingUtilities.invokeLater(this);
	}

	@Override
	public void run() {
		row = table.convertRowIndexToModel(table.getEditingRow());
		column = table.convertColumnIndexToModel(table.getEditingColumn());
		oldValue = table.getModel().getValueAt(row, column);
		newValue = null;
	}

	private void processEditingStopped() {
		newValue = table.getModel().getValueAt(row, column);

		if (!newValue.equals(oldValue)) {
			RegisterChangeListener tcl = new RegisterChangeListener(getTable(), getRow(), getColumn(), getOldValue(),
					getNewValue());

			ActionEvent event = new ActionEvent(tcl, ActionEvent.ACTION_PERFORMED, "");
			action.actionPerformed(event);
		}
	}
}

```

`src/main/java/gdbghidra/RestoreBreakpointsAction.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra;

import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.MenuData;

class RestoreBreakpointsAction extends DockingAction {
	private GDBReceiver gdbReceiver;

	RestoreBreakpointsAction(GDBGhidraPlugin pl) {
		super("Restore Breakpoints", pl.getName());
		setDescription("Restore all saved breakpoints");
		setPopupMenuData(new MenuData(new String[] {"Restore breakpoints"}, null, "Breakpoint"));
		//setKeyBindingData(new KeyBindingData(KeyEvent.VK_B, InputEvent.CTRL_DOWN_MASK)); 
		this.gdbReceiver = null;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		if(this.gdbReceiver != null) {
			this.gdbReceiver.restoreBreakpoints();
		}
	}
	
	public void setGDBReceiver(GDBReceiver gdbReceiver) {
		this.gdbReceiver = gdbReceiver;
	}
	
}

```

`src/main/java/gdbghidra/ToggleBreakpointAction.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra;

import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.MenuData;
import ghidra.app.context.ListingActionContext;
import ghidra.program.model.address.Address;
import ghidra.program.util.MarkerLocation;

class ToggleBreakpointAction extends DockingAction {
	private GDBReceiver gdbReceiver;

	ToggleBreakpointAction(GDBGhidraPlugin pl) {
		super("Toggle Breakpoint", pl.getName());
		setDescription("Enable/Disable breakpoint at current location");
		setPopupMenuData(new MenuData(new String[] {"Toggle breakpoint"}, null, "Breakpoint"));
		//setKeyBindingData(new KeyBindingData(KeyEvent.VK_B, InputEvent.CTRL_DOWN_MASK)); 
		this.gdbReceiver = null;
	}

	@Override
	public void actionPerformed(ActionContext context) {
		Address address = getAddress(context);
		if(this.gdbReceiver != null) {
			this.gdbReceiver.addBreakpoint(address);
		}
	}
	
	public void setGDBReceiver(GDBReceiver gdbReceiver) {
		this.gdbReceiver = gdbReceiver;
	}
	
	private Address getAddress(ActionContext context) {
		Object contextObject = context.getContextObject();
		if(MarkerLocation.class.isAssignableFrom(contextObject.getClass())) {
			return ((MarkerLocation) contextObject).getAddr();
		} else if (context instanceof ListingActionContext ) {
			return ((ListingActionContext) context).getAddress();
		}
		return null;
	}
	
}

```

`src/main/java/gdbghidra/events/BreakpointEvent.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

import java.awt.Color;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.plugin.core.colorizer.ColorizingService;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;

public class BreakpointEvent implements Event{
	private String address;
	private BreakpointEventAction action;

	public BreakpointEvent(String address, String action) {
		this.address = address;
		this.action = BreakpointEventAction.valueOf(action.toUpperCase());
	}
	
	public String getAddress() {
		return this.address;
	}
	
	public BreakpointEventAction getAction() {
		return this.action;
	}

	@Override
	public EventType getType() {
		return EventType.BREAKPOINT;
	}
	
	public enum BreakpointEventAction {
		ENABLE,
		DISABLE,
		DELETE
	}

	private static Address getBreakpointAddress(BreakpointEvent breakpoint, Program currentProgram, long relocate) {
		return 	currentProgram.getAddressFactory().getAddress(breakpoint.getAddress()).subtract(relocate).add(currentProgram.getImageBase().getOffset());
	}
	
	private static void doBreakpointTransaction(String action, BreakpointEvent breakpoint, Program currentProgram, ProgramPlugin plugin, long relocate) {
		var caddress = getBreakpointAddress(breakpoint, currentProgram, relocate);
		var category = "breakpoint";

		var tx = currentProgram.startTransaction(action);
		
		/*==================== Begin Transaction ====================================*/
		var service = plugin.getTool().getService(ColorizingService.class);
		var bm = currentProgram.getBookmarkManager().getBookmark(caddress, category, category);
		
		switch(breakpoint.getAction()) {
			case ENABLE:
				service.setBackgroundColor(caddress, caddress, Color.RED);
				break;
			case DISABLE:
				service.setBackgroundColor(caddress, caddress, Color.LIGHT_GRAY);
				break;
			case DELETE:
				service.setBackgroundColor(caddress, caddress, Color.WHITE);
				break;
		}

		if(bm != null) {
			if(breakpoint.action == BreakpointEventAction.DELETE) {
				currentProgram.getBookmarkManager().removeBookmark(bm);
				service = plugin.getTool().getService(ColorizingService.class);
			}else {
				bm.set(category, action);
			}
		}else {
			currentProgram.getBookmarkManager().setBookmark(caddress, category, category, action);
		}
		/*==================== END Transaction ====================================*/
		currentProgram.endTransaction(tx, true);
		
	}
	
	public static void handleEvent(BreakpointEvent breakpoint, Program currentProgram, ProgramPlugin plugin, long relocate) {
		switch(breakpoint.getAction()) {
		case ENABLE:		
			doBreakpointTransaction("enabled", breakpoint, currentProgram, plugin, relocate);
			break;
		case DISABLE:
			doBreakpointTransaction("disabled", breakpoint, currentProgram, plugin, relocate);
			break;
			
		case DELETE:
			doBreakpointTransaction("delete", breakpoint, currentProgram, plugin, relocate);
			break;
		}
		
	}

	public static JSONObject constructJSONResponse(long address, String action) {
		var response = new JSONObject();
		var datamap = new JSONObject();
		var data = new JSONArray();
		var jbreakpoints = new JSONArray();
		
		response.put("type", "BREAKPOINT");
		
		jbreakpoints.add("0x"+Long.toHexString(address));
		
		datamap.put("breakpoints", jbreakpoints);
		datamap.put("action", action);
		data.add(datamap);
		response.put("data", data);
		
		return response;
	}
}
```

`src/main/java/gdbghidra/events/CursorEvent.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

import java.awt.Color;

import gdbghidra.GDBGhidraPlugin;
import ghidra.app.plugin.core.colorizer.ColorizingService;
import ghidra.app.services.GoToService;
import ghidra.program.model.listing.Program;

public class CursorEvent implements Event {
	private String address;
	private String relocate;

	public CursorEvent(String address, String relocate) {
		this.address = address;
		this.relocate = relocate;
	}
	
	public String getAddressString() {
		return this.address;
	}
	
	public long getRelocationAddress() {
		return Long.decode(relocate);
	}
	
	public String getRelocationAddressString() {
		return this.relocate;
	}
	
	public long getOffset() {
		if(relocate == "unknown") {
			return Long.decode(address); 
		}
		
		return Long.decode(address) - Long.decode(relocate);
	}
	
	@Override
	public EventType getType() {
		return EventType.CURSOR;
	}

	public static long handleEvent(CursorEvent cursor, Program currentProgram, GDBGhidraPlugin plugin) {
		var newAddress = currentProgram.getImageBase().add(cursor.getOffset());
		plugin.getTool().getService(GoToService.class).goTo(newAddress);
		
		var tx = currentProgram.startTransaction("change cursor color");
		
		/*==================== Begin Transaction ====================================*/
		var service = plugin.getTool().getService(ColorizingService.class);
		var currentColor = service.getBackgroundColor(newAddress);
		
		var previousAddress = plugin.getProvider().getPreviousAddress();
		
		service.setBackgroundColor(newAddress, newAddress, Color.GREEN);
		
		if(previousAddress != null ) {	
			service.setBackgroundColor(plugin.getProvider().getPreviousAddress(), plugin.getProvider().getPreviousAddress(), plugin.getProvider().getPreviousColor());
		}
		plugin.getProvider().setPreviousAddress(newAddress);
		if(currentColor == null) {
			plugin.getProvider().setPreviousColor(Color.WHITE);
		}else {
			plugin.getProvider().setPreviousColor(currentColor);
		}
		/*==================== END Transaction ====================================*/
		currentProgram.endTransaction(tx, true);
		
		
		if(!cursor.getRelocationAddressString().equals("unknown")) {
			return cursor.getRelocationAddress();
		}
		return 0;
	}

}

```

`src/main/java/gdbghidra/events/Event.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

public interface Event {
	public EventType getType();
	
}

```

`src/main/java/gdbghidra/events/EventParser.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

import java.util.EnumSet;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

public class EventParser {
	private static String getKeyOrThrow(JSONObject o, String key, String sectionName) throws ParseException {
		if(!o.containsKey(key)) { throw new ParseException("Missing '"+key+"' field in "+sectionName+" section of message."); }
		return (String)o.get(key);
	}
	
	public static Event fromJsonString(String json) throws ParseException {
		var jp = new JSONParser();
		JSONObject r;
		try {
			r = (JSONObject)jp.parse(json);
			if(r == null) { throw new ParseException("Could not initialize json parser"); } 
			
			if(!r.containsKey("type")) { throw new ParseException("Missing type field inside event message"); }
			
			EnumSet<EventType> types = EnumSet.allOf(EventType.class);
			
			var type = EventType.valueOf((String)r.get("type"));
			
			if(!types.contains(type)) { throw new ParseException("Unknown event type. Should be one of: "); }
			
			if(!r.containsKey("data")) { throw new ParseException("Missing 'data' section inside event message."); }
			
			var da = (JSONArray)r.get("data");
			
			if(da.size() == 0) { throw new ParseException("'data' section inside event message should not be empty"); }
			
			var d = (JSONObject)da.get(0);
			
			switch(type) {
				case HELLO:					
					return new HelloEvent(
							getKeyOrThrow(d, "arch", "data"), 
							getKeyOrThrow(d, "endian", "data"), 
							getKeyOrThrow(d, "answer_ip", "data"),
							getKeyOrThrow(d, "answer_port", "data"));
							
				case CURSOR:		
					return new CursorEvent(
							getKeyOrThrow(d, "address", "data"), 
							getKeyOrThrow(d, "relocate", "data"));				
				case REGISTER:					
					return new RegisterEvent(
							getKeyOrThrow(d, "address", "data"), 
							getKeyOrThrow(d, "name", "data"),
							getKeyOrThrow(d, "value", "data"));
				case BREAKPOINT:
					return new BreakpointEvent(	
							getKeyOrThrow(d, "breakpoint", "data" ),
							getKeyOrThrow(d, "action", "data" ));
				case MEMORY:
					return new MemoryEvent(	
							getKeyOrThrow(d, "address", "data" ),
							getKeyOrThrow(d, "name", "data" ),
							getKeyOrThrow(d, "data", "data" ),
							getKeyOrThrow(d, "size", "data" ),
							getKeyOrThrow(d, "read", "data" ).equals("True"),
							getKeyOrThrow(d, "write", "data" ).equals("True"),
							getKeyOrThrow(d, "execute", "data" ).equals("True")
							);
			}
			
			
		} catch (org.json.simple.parser.ParseException e) {
			throw new ParseException(e.getMessage());
		}
		
		// we should never reach this!
		return null;
	}
}

```

`src/main/java/gdbghidra/events/EventType.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

public enum EventType {
	HELLO,
	CURSOR,
	REGISTER,
	BREAKPOINT,
	MEMORY,
}

```

`src/main/java/gdbghidra/events/HelloEvent.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

public class HelloEvent implements Event{
	private String architecture;
	private Integer answerPort;
	private String endianess;
	private String answerIp;

	public HelloEvent(String architecture, String endianess, String answerIp, String answerPort) {
		this.architecture = architecture;
		this.endianess = endianess;
		this.answerIp = answerIp;
		this.answerPort = Integer.valueOf(answerPort);
	}
	
	public String getEndianess() {
		return this.endianess;
	}
	
	public String getAnswerIp() {
		return this.answerIp;
	}
	
	public Integer getAnswerPort() {
		return this.answerPort;
	}
	
	public String getArchitecture() {
		return this.architecture;
	}

	@Override
	public EventType getType() {
		return EventType.HELLO;
	}
}

```

`src/main/java/gdbghidra/events/MemoryEvent.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.GZIPInputStream;

import ch.ethz.ssh2.crypto.Base64;
import ghidra.app.util.MemoryBlockUtil;
import ghidra.app.util.importer.MemoryConflictHandler;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOverflowException;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;

public class MemoryEvent implements Event {
	private String name;
	private String address;
	private String data;
	private boolean readPermission;
	private boolean writePermission;
	private boolean executePermission;
	private long size;

	public MemoryEvent(String address, String name, String data, String size, boolean readPermission, boolean writePermission, boolean executePermission) {
		this.address = address;
		this.name = name;
		this.data = data;
		this.size = Long.decode(size);
		this.readPermission = readPermission;
		this.writePermission = writePermission;
		this.executePermission = executePermission;
	}
	
	public String getName() {
		return this.name;
	}
	
	@Override
	public EventType getType() {
		return EventType.MEMORY;
	}

	public Address getAddress(Program currentProgram) {
		return currentProgram.getAddressFactory().getAddress(address);
	}

	public boolean getReadPermission() {
		return readPermission;
	}

	public boolean getWritePermission() {
		return writePermission;
	}

	public boolean getExecutePermission() {
		return executePermission;
	}

	public InputStream getData() {
		try {
			var decoded = Base64.decode(this.data.toCharArray());
			ByteArrayInputStream bis = new ByteArrayInputStream(decoded);
			return new GZIPInputStream(bis);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	public long getDataSize() {
		return this.size;
	}

	public static void handleEvent(MemoryEvent memEvent, Program currentProgram)  {
		MemoryConflictHandler memoryConflictHandler = MemoryConflictHandler.ALWAYS_OVERWRITE;
		MemoryBlockUtil mbu = new MemoryBlockUtil( currentProgram, memoryConflictHandler );
		try {
			var tx = currentProgram.startTransaction("adding memory");
			
			
			var r = mbu.createInitializedBlock(
					memEvent.getName(), 
					memEvent.getAddress(currentProgram), 
					memEvent.getData(), 
					memEvent.getDataSize(), 
					"", // comment?
					"gdb", 
					memEvent.getReadPermission(), 
					memEvent.getWritePermission(), 
					memEvent.getExecutePermission(), 
					TaskMonitor.DUMMY);
			if(r == null) {
				var msg = mbu.getMessages();
				if(msg.contains("Overwrote memory")) {
					System.out.println("[GDBGhidra] "+ mbu.getMessages());
				} else {
					System.err.println("[GDBGhidra] could not write new memory block: "+ mbu.getMessages());
				}
			} else {
				System.out.println("[GDBGhidra]" + r.toString());
			}
			
			currentProgram.endTransaction(tx, true);
		} catch (AddressOverflowException e) {
			e.printStackTrace();
		}
	}
}

```

`src/main/java/gdbghidra/events/ParseException.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

public class ParseException extends Exception {
	public ParseException(String message) {
		super(message);
	}
}

```

`src/main/java/gdbghidra/events/RegisterEvent.java`:

```java
/*
MIT License                                                                     
                                                                                
Copyright (c) 2019 Comsecuris UG (haftungsbeschränkt)                           
                                                                                
Permission is hereby granted, free of charge, to any person obtaining a copy       
of this software and associated documentation files (the "Software"), to deal   
in the Software without restriction, including without limitation the rights       
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell          
copies of the Software, and to permit persons to whom the Software is           
furnished to do so, subject to the following conditions:                        
                                                                                
The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.                                 
                                                                                
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR         
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,        
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE        
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER          
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   
SOFTWARE.       
 */
package gdbghidra.events;

import java.math.BigInteger;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import ghidra.app.cmd.register.SetRegisterCmd;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.framework.cmd.CompoundCmd;
import ghidra.program.model.lang.RegisterManager;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramLocation;

public class RegisterEvent implements Event {
	private String name;
	private String value;
	private String address;

	public RegisterEvent(String address, String name, String value) {
		this.address = address;
		this.name = name;
		this.value = value;
	}
	
	public String getName() {
		return this.name;
	}
	
	public String getHexString() {
		return this.value;
	}
	
	public BigInteger getValue() {
		if(this.value.startsWith("0x")) {
			return new BigInteger(this.value.substring(2), 16);
		}
		return new BigInteger(this.value, 16);

	}
	
	public String getAddress() {
		return this.address;
	}
	
	@Override
	public EventType getType() {
		return EventType.REGISTER;
	}

	public static void handleEvent(RegisterEvent registerEvent, Program currentProgram, ProgramPlugin plugin, ProgramLocation currentLocation) {
		var register = currentProgram.getRegister(registerEvent.getName());
		if(register == null) {
			register = currentProgram.getRegister(registerEvent.getName().toUpperCase());
			if(register == null) {
				System.err.println("[GDBGHIDRA] Error unknown register: "+registerEvent.getName()+"\n");
				return;
			}
		}
		var address = currentLocation.getAddress();
		var cmd = new CompoundCmd("Set Register Values");
		var regCmd = new SetRegisterCmd(
				register, 
				address, 
				address,
				registerEvent.getValue());
		cmd.add(regCmd);
		plugin.getTool().execute(cmd, currentProgram);
	}

	public static JSONObject constructJSONResponse(String register, String newValue, String action) {
		var response = new JSONObject();
		var datamap = new JSONObject();
		var data = new JSONArray();
		
		response.put("type", "REGISTER");
		datamap.put("register", register);
		datamap.put("value", newValue);
		datamap.put("action", action);
		data.add(datamap);
		response.put("data", data);
		
		return response;
	}

}
```

`src/main/resources/images/README.txt`:

```txt
The "src/resources/images" directory is intended to hold all image/icon files used by
this module.

```

`src/test/java/README.test.txt`:

```txt
The "test" directory is intended to hold unit test cases.  The package structure within
this folder should correspond to that found in the "src" folder.

```