Project Path: arc_gmh5225_Obfusk8_uelxvne6

Source Tree:

```txt
arc_gmh5225_Obfusk8_uelxvne6
├── Obfusk8
│   ├── Obfusk8Core.hpp
│   ├── Resolve8.hpp
│   ├── k8_CryptographyAPIs
│   │   └── k8_CryptographyAPIs.hpp
│   ├── k8_NetworkingAPIs
│   │   └── k8_NetworkingAPIs.hpp
│   ├── k8_ProcessManipulationAPIs
│   │   └── k8_ProcessManipulationAPIs.hpp
│   ├── k8_RegistryAPIs
│   │   └── k8_RegistryAPIs.hpp
│   ├── main.cpp
│   └── xtea8.hpp
└── README.md

```

`Obfusk8/Obfusk8Core.hpp`:

```hpp
#pragma once

#include <array>
#include <string>
#include <ctime>
#include <cstdint>
#include <random>
#include <type_traits>

#pragma region XTEA 
// --------------------------------------

    #include "xtea8.hpp"

// --------------------------------------
#pragma endregion XTEA 

#pragma region API_OBF
// --------------------------------------

    #include "Resolve8.hpp"

    #define STEALTH_API_OBF(dll, api) \
            find_export_byhash(find_module_base(CT_HASH(dll)), CT_HASH(api))

    #define STEALTH_API_OBFSTR(dll_lit, api_lit) \
            STEALTH_API_OBF(OBFUSCATE_STRING(dll_lit).c_str(), OBFUSCATE_STRING(api_lit).c_str())

// --------------------------------------
#pragma endregion API_OBF

#pragma region ProcMAN
// --------------------------------------

    #include "k8_ProcessManipulationAPIs/k8_ProcessManipulationAPIs.hpp"
    using namespace K8_ProcessManipulationAPIs;

// --------------------------------------
#pragma endregion ProcMAN

#pragma region Crypt
// --------------------------------------

    #include "k8_CryptographyAPIs/k8_CryptographyAPIs.hpp"
    using namespace k8_CryptographyAPIs;

// --------------------------------------
#pragma endregion Crypt

#pragma region NET
// --------------------------------------

    #include "k8_NetworkingAPIs/k8_NetworkingAPIs.hpp"
    using namespace k8_NetworkingAPIs;

// --------------------------------------
#pragma endregion NET

#pragma region Reg
// --------------------------------------

    #include "k8_RegistryAPIs/k8_RegistryAPIs.hpp"
    using namespace RegistryAPIs;

// --------------------------------------
#pragma endregion Reg

#pragma region dec
// --------------------------------------

    #if defined(_MSC_VER)
    #include <intrin.h>
    #endif

    inline volatile int _obf_global_opaque_seed = 777 + (int)__TIME__[1] + (int)__TIME__[2];


    #define NOP() \
        do { \
            volatile int __obf_nop_val = __COUNTER__ ^ (int)__LINE__; \
            _obf_global_opaque_seed = (_obf_global_opaque_seed ^ __obf_nop_val ^ (int)std::time(nullptr)); \
            (void)__obf_nop_val; \
        } while(0)

    #if defined(_MSC_VER)
        #define K8_ASSUME(x) __assume(x)
    #else
        #define K8_ASSUME(x) ((void)0)
    #endif

    #if defined(_MSC_VER)
        #define K8_FORCEINLINE __forceinline
        #define K8_NOINLINE __declspec(noinline)
    #else
        #define K8_FORCEINLINE inline
        #define K8_NOINLINE
    #endif

// --------------------------------------
#pragma region dec

#pragma region _Opaque_Predicate
// --------------------------------------

    // --- Opaque predicates for flattening ---
    //
    //
    /*
        #define OBF_OPAQUE_PREDICATE_TRUE_1()  ((~0u >> 1) > 0 && (((__COUNTER__ + _obf_global_opaque_seed)) % 2 == ((__COUNTER__ + _obf_global_opaque_seed)) % 2))
        #define OBF_OPAQUE_PREDICATE_TRUE_2(x) (((unsigned int)(x) ^ (0x49382668U + __COUNTER__ + (unsigned int)_obf_global_opaque_seed)) != (0xDEADBEEFU + __LINE__))
        #define OBF_OPAQUE_PREDICATE_FALSE_1() (0 && (((__COUNTER__ + _obf_global_opaque_seed)) % 2 != ((__COUNTER__ + _obf_global_opaque_seed)) % 2))
        #define OBF_OPAQUE_PREDICATE_FALSE_2(x) (((unsigned int)(x) == ((unsigned int)(x)+1U)) && ((unsigned int)(x) != ((unsigned int)(x)+1U)))
    */
    //
    //
    #ifndef _obf_global_opaque_seed
    extern volatile int _obf_global_opaque_seed;
    #endif

    #define OBF_OPAQUE_PREDICATE_TRUE_1() \
        ( \
            ( \
                ( ((~0u >> 1) > 0u) && \
                (((unsigned int)(__COUNTER__) + (unsigned int)_obf_global_opaque_seed) % 2u == \
                ((unsigned int)(__COUNTER__) + (unsigned int)_obf_global_opaque_seed) % 2u) && \
                ((__LINE__ | (unsigned int)_obf_global_opaque_seed) >= 0u) \
                ) \
            ) \
            && ( \
                (((unsigned int)_obf_global_opaque_seed | 0xCAFEBABEu) ^ 0xCAFEBABEu) <= (unsigned int)_obf_global_opaque_seed \
                || (((unsigned int)(__COUNTER__) ^ (unsigned int)(__LINE__)) & 1u) == (((unsigned int)(__COUNTER__) ^ (unsigned int)(__LINE__)) & 1u) \
            ) \
            && ( \
                (((unsigned int)_obf_global_opaque_seed + 0x12345678u) ^ 0x87654321u) != (unsigned int)-1 \
            ) \
        )

    #define OBF_OPAQUE_PREDICATE_TRUE_2(x) \
        ( \
            ( \
                (((unsigned int)(x) ^ (0x12345678u + (unsigned int)(__COUNTER__) + (unsigned int)_obf_global_opaque_seed)) != (0xDEADBEEFu + (unsigned int)(__LINE__))) \
                || ((((unsigned int)(x) + (unsigned int)_obf_global_opaque_seed) & 0xFu) == (((unsigned int)_obf_global_opaque_seed) & 0xFu)) \
            ) \
            && ( \
                (((unsigned int)(x) | 0xF00DFACEu) == ((unsigned int)(x) | 0xF00DFACEu)) && \
                ((((unsigned int)(x) & 0xFFu) ^ ((unsigned int)_obf_global_opaque_seed & 0xFFu)) < 0x100u) \
            ) \
            && ( \
                ((((unsigned int)(x) + (unsigned int)_obf_global_opaque_seed + __LINE__) & 1u) == (((unsigned int)(x) + (unsigned int)_obf_global_opaque_seed + __LINE__) % 2u)) \
            ) \
        )

    #define OBF_OPAQUE_PREDICATE_FALSE_1() \
        ( \
            0 && \
            ( \
                ((((unsigned int)(__COUNTER__) + (unsigned int)_obf_global_opaque_seed) % 2u) != \
                (((unsigned int)(__COUNTER__) + (unsigned int)_obf_global_opaque_seed) % 2u)) \
                && (((unsigned int)(__LINE__) ^ (unsigned int)_obf_global_opaque_seed) == 0xDEADBEEF) \
            ) \
            && ( \
                (((unsigned int)_obf_global_opaque_seed + 0xDEADu) == 0xBEEFu) \
            ) \
        )

    #define OBF_OPAQUE_PREDICATE_FALSE_2(x) \
        ( \
            ( \
                (((unsigned int)(x) == ((unsigned int)(x) + 1u)) && ((unsigned int)(x) != ((unsigned int)(x) + 1u))) \
                || (((unsigned int)(x) == ((unsigned int)(x) + 1u)) && ((unsigned int)_obf_global_opaque_seed == 0xDEADBEEF)) \
            ) \
            && ( \
                (((unsigned int)(x) ^ 0xABADBABAu) == (((unsigned int)(x) ^ 0xABADBABAu) + 1u)) \
            ) \
            && ( \
                ((((unsigned int)(x) + 0x1234u) | 0xFEDCu) == (((unsigned int)(x) + 0x1234u) | 0xFEDCu) - 1u) \
            ) \
        )

// --------------------------------------
#pragma endregion _Opaque_Predicate

#pragma region MBA
// --------------------------------------

    #define OBF_MBA_ADD(a, b) ( \
        ( ((unsigned int)(a) | (unsigned int)(b)) + ((unsigned int)(a) & (unsigned int)(b)) ) \
        - ( ((unsigned int)(a) ^ (unsigned int)(b)) ) \
        + ( ((unsigned int)(a) ^ (unsigned int)(b)) + 2U * ((unsigned int)(a) & (unsigned int)(b)) ) \
        - ( ((unsigned int)(a) | (unsigned int)(b)) - ((unsigned int)(a) & (unsigned int)(b)) ) \
        + ( ((unsigned int)(a) & ~(unsigned int)(b)) + ((unsigned int)(b) & ~(unsigned int)(a)) + 2U * ((unsigned int)(a) & (unsigned int)(b)) ) \
        ^ ( (((unsigned int)(a) | (unsigned int)(b))) - ((unsigned int)(a) & (unsigned int)(b)) ) \
        ^ ( (((unsigned int)(a)) | ((unsigned int)(b))) & ~(((unsigned int)(a)) & ((unsigned int)(b))) ) \
    )

    #define OBF_MBA_SUB(a, b) ( \
        ( ((unsigned int)(a)) + (~(unsigned int)(b)) + 1U ) \
        ^ ( ((unsigned int)(a)) ^ ((~(unsigned int)(b)) ^ 1U) ) \
        + ( ((unsigned int)(a) ^ ((unsigned int)(b) ^ 0xFFFFFFFFU)) + 2U * ((unsigned int)(a) & ((unsigned int)(b) ^ 0xFFFFFFFFU)) + 1U ) \
        - ( ((unsigned int)(a)) & (((unsigned int)(a)) - ((unsigned int)(b))) ) \
        + ( (((unsigned int)(a) | ~(unsigned int)(b))) - (~(unsigned int)(b)) ) \
        ^ ( (((unsigned int)(a)) | ((unsigned int)(b))) - ((unsigned int)(a) & (unsigned int)(b)) ) \
    )

    #define OBF_MBA_XOR(a, b) ( \
        ( (((unsigned int)(a)) & (~(unsigned int)(b))) | ((~(unsigned int)(a)) & ((unsigned int)(b))) ) \
        ^ ( ((unsigned int)(a) | (unsigned int)(b)) - ((unsigned int)(a) & (unsigned int)(b)) ) \
        ^ ( ~(~(unsigned int)(a) & ~(unsigned int)(b)) & ~( (unsigned int)(a) & (unsigned int)(b) ) ) \
        ^ ( (((unsigned int)(a)) | ((unsigned int)(b))) & (~((unsigned int)(a)) | ~(unsigned int)(b)) ) \
        + ( ((unsigned int)(a) + (unsigned int)(b)) - 2 * ((unsigned int)(a) & (unsigned int)(b)) ) \
    )

    #define OBF_MBA_NOT(a) ( \
        ( ((unsigned int)(a)) ^ 0xFFFFFFFFU ) \
        ^ ( ~((unsigned int)(a)) ) \
        + ( (0U - 1U) ^ ((unsigned int)(a)) ) \
        - ( 2 * (~((unsigned int)(a)) & ((unsigned int)(a))) ) \
        + ( 0xFFFFFFFFU - ((unsigned int)(a)) ) \
        ^ ( ~((unsigned int)(a)) | 0U ) \
    )

    #define OBF_MBA_MUL_CONST3(x) ( \
        ( (((unsigned int)(x)) << 1) + ((unsigned int)(x)) ) \
        ^ ( ((unsigned int)(x) << 2) - ((unsigned int)(x)) ) \
        + ( ((unsigned int)(x)) + ((unsigned int)(x)) + ((unsigned int)(x)) ) \
        - ( ((unsigned int)(x)) & (~( ((unsigned int)(x)) << 1 )) ) \
        + ( (((unsigned int)(x)) | ((unsigned int)(x)) << 1 ) - ( ((unsigned int)(x)) & ((unsigned int)(x)) << 1 ) ) \
    )

    #define OBF_MBA_MUL_CONST_ALT(x, c) ( \
        ( ((unsigned int)(x)) << (c) ) - ((unsigned int)(x)) \
        ^ ( ((unsigned int)(x)) * ((1U << (c)) - 1U) ) \
        + ( ( ( ((unsigned int)(x)) << (c) ) ^ ((unsigned int)(x)) ) - ( ( ( ((unsigned int)(x)) << (c) ) & ((unsigned int)(x)) ) << 1 ) ) \
        + ( (((unsigned int)(x)) << (c)) | ((unsigned int)(x)) ) - ( ((unsigned int)(x)) & ((unsigned int)(x)) << (c) ) \
    )

// --------------------------------------
#pragma endregion MBA

#pragma region JUNK
// --------------------------------------

    #ifndef _obf_global_opaque_seed
    extern volatile int _obf_global_opaque_seed;
    #endif

    #define OBF_JUNK_BODY_1 \
        volatile int x_jb = __COUNTER__ + 11 + _obf_global_opaque_seed; \
        x_jb ^= (0xDEADBEEFU + (int)__TIME__[0]); \
        x_jb += (int)std::time(nullptr); \
        return x_jb;
    #define OBF_JUNK_BODY_2 \
        volatile int x_jb = (__COUNTER__ * 3) ^ (_obf_global_opaque_seed); \
        for(int i_jb=0; i_jb<((__COUNTER__%2)+2); ++i_jb) x_jb ^= i_jb; \
        return x_jb;
    #define OBF_JUNK_BODY_3 \
        volatile int x_jb = (0x1234 | (99 + __COUNTER__)) ^ _obf_global_opaque_seed; \
        x_jb &= (0xFFFFU + (int)__TIME__[1]); \
        x_jb ^= (x_jb << (((__COUNTER__)%3)+1)%32); \
        return x_jb;
    #define OBF_JUNK_BODY_4 \
        volatile int x_jb4 = __COUNTER__ ^ _obf_global_opaque_seed, y_jb4 = 7 + (__COUNTER__ % 5); \
        x_jb4 += y_jb4 * y_jb4; \
        x_jb4 ^= y_jb4; \
        x_jb4 = (x_jb4 << 1) | (x_jb4 >> 31); \
        return x_jb4;
    #define OBF_JUNK_BODY_5 \
        volatile int x_jb5 = (((int)std::time(nullptr) ^ _obf_global_opaque_seed + __COUNTER__) % 7); \
        if (x_jb5 == 0) x_jb5 = 1; \
        x_jb5 = (x_jb5 * 13) + 71; \
        return x_jb5;
    #define OBF_JUNK_BODY_6 \
        volatile int x_jb = (int)std::time(nullptr) ^ (_obf_global_opaque_seed * __COUNTER__); \
        int z = ((x_jb & 0xFF) * 0x1F1F1F1F) ^ (__COUNTER__ + _obf_global_opaque_seed); \
        x_jb = z ^ (x_jb << 2); \
        x_jb ^= ((int)__TIME__[2] | (int)__TIME__[3]); \
        return x_jb;
    #define OBF_JUNK_BODY_7 \
        volatile int x_jb = ((int)std::time(nullptr) + _obf_global_opaque_seed + __COUNTER__) ^ 0x0F0F0F0F; \
        x_jb = ((x_jb << 3) | (x_jb >> 29)) ^ (int)__LINE__; \
        return x_jb;

    #define OBF_DECLARE_JUNK_FUNC(N, body) K8_FORCEINLINE static int obf_junk_func_##N() { body }

    namespace obf_junk_ns {
        OBF_DECLARE_JUNK_FUNC(1, OBF_JUNK_BODY_1) 
        OBF_DECLARE_JUNK_FUNC(2, OBF_JUNK_BODY_2)
        OBF_DECLARE_JUNK_FUNC(3, OBF_JUNK_BODY_3)
        OBF_DECLARE_JUNK_FUNC(4, OBF_JUNK_BODY_4)
        OBF_DECLARE_JUNK_FUNC(5, OBF_JUNK_BODY_5)
        OBF_DECLARE_JUNK_FUNC(6, OBF_JUNK_BODY_6)
        OBF_DECLARE_JUNK_FUNC(7, OBF_JUNK_BODY_7)
        OBF_DECLARE_JUNK_FUNC(8, OBF_JUNK_BODY_1)
        OBF_DECLARE_JUNK_FUNC(9, OBF_JUNK_BODY_2)
        OBF_DECLARE_JUNK_FUNC(10, OBF_JUNK_BODY_3)
        OBF_DECLARE_JUNK_FUNC(11, OBF_JUNK_BODY_4)
        OBF_DECLARE_JUNK_FUNC(12, OBF_JUNK_BODY_5)
        OBF_DECLARE_JUNK_FUNC(13, OBF_JUNK_BODY_6)
        OBF_DECLARE_JUNK_FUNC(14, OBF_JUNK_BODY_7)
        OBF_DECLARE_JUNK_FUNC(15, OBF_JUNK_BODY_1)
        OBF_DECLARE_JUNK_FUNC(16, OBF_JUNK_BODY_2)
        OBF_DECLARE_JUNK_FUNC(17, OBF_JUNK_BODY_3)
        OBF_DECLARE_JUNK_FUNC(18, OBF_JUNK_BODY_4)
        OBF_DECLARE_JUNK_FUNC(19, OBF_JUNK_BODY_5)
        OBF_DECLARE_JUNK_FUNC(20, OBF_JUNK_BODY_6)
        OBF_DECLARE_JUNK_FUNC(21, OBF_JUNK_BODY_7)
        OBF_DECLARE_JUNK_FUNC(22, OBF_JUNK_BODY_1)
        OBF_DECLARE_JUNK_FUNC(23, OBF_JUNK_BODY_2)
        OBF_DECLARE_JUNK_FUNC(24, OBF_JUNK_BODY_3)
        OBF_DECLARE_JUNK_FUNC(25, OBF_JUNK_BODY_4)
        OBF_DECLARE_JUNK_FUNC(26, OBF_JUNK_BODY_5)
        OBF_DECLARE_JUNK_FUNC(27, OBF_JUNK_BODY_6)
        OBF_DECLARE_JUNK_FUNC(28, OBF_JUNK_BODY_7)

        using obf_junk_func_ptr = int(*)();
        static obf_junk_func_ptr obf_junk_func_table[] = {
            obf_junk_func_1, obf_junk_func_2, obf_junk_func_3, obf_junk_func_4, obf_junk_func_5, obf_junk_func_6, obf_junk_func_7,
            obf_junk_func_8, obf_junk_func_9, obf_junk_func_10, obf_junk_func_11, obf_junk_func_12, obf_junk_func_13, obf_junk_func_14,
            obf_junk_func_15, obf_junk_func_16, obf_junk_func_17, obf_junk_func_18, obf_junk_func_19, obf_junk_func_20, obf_junk_func_21,
            obf_junk_func_22, obf_junk_func_23, obf_junk_func_24, obf_junk_func_25, obf_junk_func_26, obf_junk_func_27, obf_junk_func_28
        };
        constexpr size_t obf_junk_func_table_size = sizeof(obf_junk_func_table)/sizeof(obf_junk_func_ptr);
    }

    #define OBF_CALL_ANY_LOCAL_JUNK() \
        (obf_junk_ns::obf_junk_func_table[ \
            ((_obf_global_opaque_seed ^ __COUNTER__ ^ (int)std::time(nullptr) ^ (int)__LINE__) & 0x7FFFFFFF) % obf_junk_ns::obf_junk_func_table_size \
        ]())

// --------------------------------------
#pragma endregion JUNK

#pragma region OBF_JUMPS
// --------------------------------------

    // --- Anti-Disassembly Jump Instructions ---
    // --- Jump Instructions with the Same Target ---
    // These will always jump to TARGET_LABEL, but through obfuscated means
    #define OBF_JUMP_SKEW_1(TARGET_LABEL) \
        do { \
            NOP(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)__LINE__ + OBF_CALL_ANY_LOCAL_JUNK()); \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_2(TARGET_LABEL) \
        do { \
            volatile unsigned int _skew_val = OBF_MBA_ADD((unsigned int)__COUNTER__, (unsigned int)_obf_global_opaque_seed); \
            _skew_val = OBF_MBA_XOR(_skew_val, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_skew_val)) { \
                NOP(); \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_3(TARGET_LABEL) \
        do { \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, (int)__TIME__[0] ^ (int)__COUNTER__); \
            if (((_obf_global_opaque_seed ^ (int)__LINE__) | 1) != 0) { \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_4(TARGET_LABEL) \
        do { \
            volatile int _s4_decoy = OBF_MBA_MUL_CONST3(_obf_global_opaque_seed ^ (int)__LINE__); \
            _s4_decoy += OBF_CALL_ANY_LOCAL_JUNK(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1() && (_s4_decoy != _s4_decoy + 1)) { \
                NOP(); \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_5(TARGET_LABEL) \
        do { \
            _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            unsigned int val_a = (unsigned int)__LINE__ ^ (unsigned int)_obf_global_opaque_seed; \
            unsigned int val_b = OBF_MBA_XOR(val_a, 0U); \
            if (OBF_MBA_ADD(val_a, OBF_MBA_NOT(val_b)) == 0xFFFFFFFFU) { \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_6(TARGET_LABEL) \
        do { \
            NOP(); NOP(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2((unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)_obf_global_opaque_seed)) { \
                 _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)__COUNTER__); \
                 goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_7(TARGET_LABEL) \
        do { \
            volatile int _s7_temp1 = OBF_CALL_ANY_LOCAL_JUNK(); \
            volatile int _s7_temp2 = OBF_CALL_ANY_LOCAL_JUNK(); \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, _s7_temp1 ^ _s7_temp2 ^ (int)__LINE__); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1() || OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_8(TARGET_LABEL) \
        do { \
            unsigned int _s8_v = (unsigned int)_obf_global_opaque_seed + (unsigned int)__COUNTER__; \
            if (OBF_MBA_XOR(_s8_v, OBF_MBA_XOR(_s8_v, 0U)) == 0U) { \
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, OBF_CALL_ANY_LOCAL_JUNK()); \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_9(TARGET_LABEL) \
        do { \
            int junk_res = OBF_CALL_ANY_LOCAL_JUNK(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2((unsigned int)junk_res)) { \
                _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, junk_res ^ (int)__TIME__[1]); \
                NOP(); \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)

    #define OBF_JUMP_SKEW_10(TARGET_LABEL) \
        do { \
            if (!OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)OBF_CALL_ANY_LOCAL_JUNK() + (int)__LINE__); \
                goto TARGET_LABEL; \
            } \
            K8_ASSUME(0); \
        } while(0)



    // --- Jump Instructions with a Constant Condition ---
    // These will use opaque predicates to determine if the jump to TARGET_LABEL occurs
    // FALLTHROUGH_CODE_BLOCK will be executed if the jump is NOT taken (predicate is false).
    #define OBF_JUMP_CONST_COND_TRUE_1(TARGET_LABEL, FALLTHROUGH_CODE_BLOCK) \
        do { \
            volatile int _cc_val1 = OBF_MBA_ADD(__COUNTER__, _obf_global_opaque_seed); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, _cc_val1 ^ (int)__LINE__); \
                OBF_CALL_ANY_LOCAL_JUNK(); \
                goto TARGET_LABEL; \
            } else { \
                K8_ASSUME(0);  \
                FALLTHROUGH_CODE_BLOCK \
            } \
        } while(0)

    #define OBF_JUMP_CONST_COND_FALSE_1(TARGET_LABEL, FALLTHROUGH_CODE_BLOCK) \
        do { \
            volatile int _cc_val2 = OBF_MBA_SUB(__COUNTER__, _obf_global_opaque_seed); \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                 \
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, _cc_val2 ^ (int)__LINE__ ^ OBF_CALL_ANY_LOCAL_JUNK()); \
                goto TARGET_LABEL; \
            } else { \
                 \
                FALLTHROUGH_CODE_BLOCK \
            } \
            NOP(); \
        } while(0)

    #define OBF_JUMP_CONST_COND_TRUE_2(TARGET_LABEL, FALLTHROUGH_CODE_BLOCK) \
        do { \
            unsigned int _cc_val3 = (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)__TIME__[2]; \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_cc_val3)) { \
                _obf_global_opaque_seed = OBF_MBA_MUL_CONST3(_obf_global_opaque_seed ^ (int)_cc_val3); \
                goto TARGET_LABEL; \
            } else { \
                K8_ASSUME(0); \
                FALLTHROUGH_CODE_BLOCK \
            } \
        } while(0)

    #define OBF_JUMP_CONST_COND_FALSE_2(TARGET_LABEL, FALLTHROUGH_CODE_BLOCK) \
        do { \
            unsigned int _cc_val4 = (unsigned int)_obf_global_opaque_seed + (unsigned int)__COUNTER__; \
            if (OBF_OPAQUE_PREDICATE_FALSE_2(_cc_val4)) { \
                _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed + (int)_cc_val4); \
                OBF_CALL_ANY_LOCAL_JUNK(); \
                goto TARGET_LABEL; \
            } else { \
                FALLTHROUGH_CODE_BLOCK \
            } \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_cc_val4); \
        } while(0)

    #define OBF_JUMP_MERGED_COND_SKEW_TRUE(TARGET_LABEL, FALLTHROUGH_CODE_BLOCK) \
        do { \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                OBF_JUMP_SKEW_1(TARGET_LABEL); \
            } else { \
                K8_ASSUME(0); \
                FALLTHROUGH_CODE_BLOCK \
            } \
        } while(0)

// --------------------------------------
#pragma endregion OBF_JUMPS

#pragma region OBF_STATE_TRANSITIONS
// --------------------------------------

    namespace obf_dispatch_helpers
    {
                            enum class DispatchBlockID 
                            {
                                INITIALIZE_DISPATCH_LOOP, CHECK_MAIN_LOOP_CONDITION,
                                DETERMINE_AND_EXECUTE_HANDLER, MAYBE_CALL_EXTRA_JUNK,
                                EXECUTE_EXTRA_JUNK, DETERMINE_PC_UPDATE_PATH,
                                EXECUTE_PC_UPDATE_PATH_A, EXECUTE_PC_UPDATE_PATH_B,
                                INCREMENT_MAIN_LOOP_COUNTER, EXIT_DISPATCH_LOOP,
                                DEAD_CODE_TARGET_BLOCK
                            };
    }

    // --- Anti-Disassembly State Transition ---
    // Shared next_state_var_name will be passed to these.
    // Example: OBF_SET_NEXT_STATE_SKEW_1(DispatchBlockID::SOME_TARGET, local_next_state_var);

    // --- Unconditional State Transitions ---
    // These will always set next_state_var_name to TARGET_BLOCK_ID
    #define OBF_SET_NEXT_STATE_SKEW_1(TARGET_BLOCK_ID, next_state_var_name) \
        do { \
            NOP(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)__LINE__ + OBF_CALL_ANY_LOCAL_JUNK()); \
                (next_state_var_name) = (TARGET_BLOCK_ID); \
            } else { \
                K8_ASSUME(0); \
                (next_state_var_name) = obf_dispatch_helpers::DispatchBlockID::DEAD_CODE_TARGET_BLOCK; \
            } \
        } while(0)

    #define OBF_SET_NEXT_STATE_SKEW_2(TARGET_BLOCK_ID, next_state_var_name) \
        do { \
            volatile unsigned int _skew_val = OBF_MBA_ADD((unsigned int)__COUNTER__, (unsigned int)_obf_global_opaque_seed); \
            _skew_val = OBF_MBA_XOR(_skew_val, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_skew_val)) { \
                NOP(); \
                (next_state_var_name) = (TARGET_BLOCK_ID); \
            } else { \
                K8_ASSUME(0); \
                (next_state_var_name) = obf_dispatch_helpers::DispatchBlockID::DEAD_CODE_TARGET_BLOCK; \
            } \
        } while(0)

    #define OBF_SET_NEXT_STATE_SKEW_3(TARGET_BLOCK_ID, next_state_var_name) \
        do { \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, (int)__TIME__[0] ^ (int)__COUNTER__); \
            if (((_obf_global_opaque_seed ^ (int)__LINE__) | 1) != 0) { \
                (next_state_var_name) = (TARGET_BLOCK_ID); \
            } else { K8_ASSUME(0); (next_state_var_name) = obf_dispatch_helpers::DispatchBlockID::DEAD_CODE_TARGET_BLOCK; } \
        } while(0)

    #define OBF_SET_NEXT_STATE_SKEW_4(TARGET_BLOCK_ID, next_state_var_name) \
        do { \
            if (OBF_OPAQUE_PREDICATE_TRUE_1() && OBF_OPAQUE_PREDICATE_TRUE_2(0xCAFE)) { \
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, OBF_CALL_ANY_LOCAL_JUNK()); \
                (next_state_var_name) = (TARGET_BLOCK_ID); \
            } else { K8_ASSUME(0); (next_state_var_name) = obf_dispatch_helpers::DispatchBlockID::DEAD_CODE_TARGET_BLOCK; } \
        } while(0)

    #define OBF_SET_NEXT_STATE_SKEW_5(TARGET_BLOCK_ID, next_state_var_name) \
        OBF_SET_NEXT_STATE_SKEW_1(TARGET_BLOCK_ID, next_state_var_name)

    #define OBF_SET_NEXT_STATE_SKEW_6(TARGET_BLOCK_ID, next_state_var_name) \
        OBF_SET_NEXT_STATE_SKEW_2(TARGET_BLOCK_ID, next_state_var_name)

    #define OBF_SET_NEXT_STATE_SKEW_7(TARGET_BLOCK_ID, next_state_var_name) \
        OBF_SET_NEXT_STATE_SKEW_3(TARGET_BLOCK_ID, next_state_var_name)

    #define OBF_SET_NEXT_STATE_SKEW_8(TARGET_BLOCK_ID, next_state_var_name) \
        OBF_SET_NEXT_STATE_SKEW_4(TARGET_BLOCK_ID, next_state_var_name)

    #define OBF_SET_NEXT_STATE_SKEW_9(TARGET_BLOCK_ID, next_state_var_name) \
        OBF_SET_NEXT_STATE_SKEW_1(TARGET_BLOCK_ID, next_state_var_name)

    #define OBF_SET_NEXT_STATE_SKEW_10(TARGET_BLOCK_ID, next_state_var_name) \
        OBF_SET_NEXT_STATE_SKEW_2(TARGET_BLOCK_ID, next_state_var_name)


    // --- Conditional State Transitions ---
    // These will use opaque predicates to determine if next_state_var_name is set to
    // TARGET_BLOCK_ID_IF_TRUE or TARGET_BLOCK_ID_IF_FALSE
    #define OBF_SET_NEXT_STATE_CONST_COND_TRUE_1(TARGET_BLOCK_ID_IF_TRUE, TARGET_BLOCK_ID_IF_FALSE, next_state_var_name) \
        do { \
            volatile int _cc_val1 = OBF_MBA_ADD(__COUNTER__, _obf_global_opaque_seed); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, _cc_val1 ^ (int)__LINE__); \
                OBF_CALL_ANY_LOCAL_JUNK(); \
                (next_state_var_name) = (TARGET_BLOCK_ID_IF_TRUE); \
            } else { \
                K8_ASSUME(0); \
                (next_state_var_name) = (TARGET_BLOCK_ID_IF_FALSE); \
            } \
        } while(0)

    #define OBF_SET_NEXT_STATE_CONST_COND_FALSE_1(TARGET_BLOCK_ID_IF_TRUE_PATH_IS_DEAD, TARGET_BLOCK_ID_IF_FALSE_PATH_IS_LIVE, next_state_var_name) \
        do { \
            volatile int _cc_val2 = OBF_MBA_SUB(__COUNTER__, _obf_global_opaque_seed); \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, _cc_val2 ^ (int)__LINE__ ^ OBF_CALL_ANY_LOCAL_JUNK()); \
                (next_state_var_name) = (TARGET_BLOCK_ID_IF_TRUE_PATH_IS_DEAD); \
            } else { \
                (next_state_var_name) = (TARGET_BLOCK_ID_IF_FALSE_PATH_IS_LIVE); \
            } \
            NOP(); \
        } while(0)

    #define OBF_SET_NEXT_STATE_CONST_COND_TRUE_2(TARGET_BLOCK_ID_IF_TRUE, TARGET_BLOCK_ID_IF_FALSE, next_state_var_name) \
        OBF_SET_NEXT_STATE_CONST_COND_TRUE_1(TARGET_BLOCK_ID_IF_TRUE, TARGET_BLOCK_ID_IF_FALSE, next_state_var_name)


    #define OBF_SET_NEXT_STATE_CONST_COND_FALSE_2(TARGET_BLOCK_ID_IF_TRUE_PATH_IS_DEAD, TARGET_BLOCK_ID_IF_FALSE_PATH_IS_LIVE, next_state_var_name) \
        OBF_SET_NEXT_STATE_CONST_COND_FALSE_1(TARGET_BLOCK_ID_IF_TRUE_PATH_IS_DEAD, TARGET_BLOCK_ID_IF_FALSE_PATH_IS_LIVE, next_state_var_name)

    #define OBF_SET_NEXT_STATE_MERGED_COND_SKEW_TRUE(TARGET_BLOCK_ID_ULTIMATE_IF_TRUE, TARGET_BLOCK_ID_IF_OUTER_FALSE, next_state_var_name) \
        do { \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                OBF_SET_NEXT_STATE_SKEW_1(TARGET_BLOCK_ID_ULTIMATE_IF_TRUE, next_state_var_name); \
            } else { \
                K8_ASSUME(0); \
                (next_state_var_name) = (TARGET_BLOCK_ID_IF_OUTER_FALSE); \
            } \
        } while(0)

// --------------------------------------
#pragma endregion OBF_STATE_TRANSITIONS

#pragma region VM_ENGINE
// --------------------------------------
        namespace obf_vm_engine {

            struct VMState {
                volatile unsigned int r0, r1, r2;
                volatile unsigned int pc;
                volatile unsigned int dispatch_key;
                volatile int& global_seed_ref;

                VMState(volatile int& seed_ref_param)
                    : r0(0U), r1(0U), r2(0U), pc(0U), dispatch_key(0U), global_seed_ref(seed_ref_param) {}
            };

            using vm_handler_ptr_t = void (*)(VMState&, int, char**);

            #define VM_OPQ_TRUE()   (((((unsigned int)(__LINE__ ^ _obf_global_opaque_seed)) | 1u) & 1u) == 1u)
            #define VM_OPQ_FALSE()  ((((unsigned int)(__LINE__ ^ _obf_global_opaque_seed)) & 1u) == 0u && 0)

            K8_NOINLINE static void vm_handle_op_arith(VMState& s, int ac, char** av) {
                NOP();
                unsigned int tmp = OBF_MBA_XOR(s.r1, (unsigned int)(__LINE__));
                tmp = OBF_MBA_ADD(tmp, s.global_seed_ref ^ s.pc);
                s.r0 = OBF_MBA_ADD(s.r0, tmp);
                s.r1 = OBF_MBA_SUB(s.r1, (s.r2 + (unsigned int)ac + (s.pc * 7U)) ^ OBF_CALL_ANY_LOCAL_JUNK());
                s.r2 = OBF_MBA_XOR(s.r2, s.dispatch_key ^ (unsigned int)(av && ac > 0 && av[0] ? (std::uintptr_t)av[0] : __COUNTER__));
                s.dispatch_key = OBF_MBA_ADD(s.dispatch_key, s.r0 ^ 0x1A2B3C4DU ^ s.r1);
                s.pc = OBF_MBA_ADD(s.pc, 1U ^ (s.r2 & 1U));
                s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)(s.r0 ^ s.r1 ^ s.pc));
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
            }

            K8_NOINLINE static void vm_handle_op_bitwise_logic(VMState& s, int ac, char** av) {
                NOP();
                s.r0 = OBF_MBA_XOR((s.r0 & s.r1) | (OBF_MBA_NOT(s.r0) & s.r2), (s.r1 ^ s.r2));
                s.r1 = (s.r1 << ((s.pc % 3) + 1)) | (s.r1 >> (32 - ((s.pc % 3) + 1)));
                if (OBF_OPAQUE_PREDICATE_TRUE_1()) {
                    s.r2 = OBF_MBA_XOR(s.r2, 0xDEADBEEFU + (unsigned int)s.global_seed_ref);
                } else {
                    s.r2 = OBF_MBA_ADD(s.r2, 0xCAFEFACU);
                }
                s.dispatch_key = OBF_MBA_SUB(s.dispatch_key, (s.r1 ^ 0x55AA55AAU) ^ s.r2);
                s.pc = OBF_MBA_ADD(s.pc, ((s.r0 & 1U) ? 2U : 1U) + ((s.r1 & 1U) ? 1U : 0U));
                s.global_seed_ref = OBF_MBA_ADD(s.global_seed_ref, (int)(s.r2 ^ s.dispatch_key ^ s.pc));
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
            }

            K8_NOINLINE static void vm_handle_op_key_mangle(VMState& s, int ac, char** av) {
                NOP();
                unsigned int temp_key = s.dispatch_key ^ (unsigned int)__LINE__;
                temp_key = OBF_MBA_MUL_CONST3(temp_key ^ (s.r0 | s.r1));
                temp_key = OBF_MBA_ADD(temp_key, s.r0 ^ s.r1 ^ s.r2 ^ s.pc);
                temp_key = (temp_key << ((s.global_seed_ref % 5) + 1)) | (temp_key >> (32 - ((s.global_seed_ref % 5) + 1)));
                temp_key ^= (unsigned int)OBF_CALL_ANY_LOCAL_JUNK();
                s.dispatch_key = temp_key;
                s.r0 = OBF_MBA_XOR(s.r0, s.dispatch_key ^ s.r2);
                s.pc = OBF_MBA_SUB(s.pc, (s.r1 & 7U) ? 1U : 3U);
                s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)s.dispatch_key ^ s.r2);
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
            }

            K8_NOINLINE static void vm_handle_op_junk_sequence(VMState& s, int ac, char** av) {
                NOP();
                s.r0 = OBF_MBA_ADD(s.r0, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ s.r1);
                s.r1 = OBF_MBA_XOR(s.r1, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ s.r2 ^ (unsigned int)ac);
                s.r2 = OBF_MBA_SUB(s.r2, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)(av && ac > 0 && av[0] ? av[0][0] : __LINE__));
                s.dispatch_key = OBF_MBA_NOT(s.dispatch_key ^ s.r0 ^ s.r2);
                s.pc = OBF_MBA_ADD(s.pc, 1U + (s.r2 & 3U));
                s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)(s.r0 ^ s.r1 ^ s.r2 ^ s.pc));
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
                NOP();
            }

            K8_NOINLINE static void vm_handle_op_conditional_update(VMState& s, int ac, char** av) {
                NOP();
                if (OBF_OPAQUE_PREDICATE_TRUE_2(s.r0 ^ s.dispatch_key ^ (unsigned int)s.global_seed_ref)) {
                    s.r0 = OBF_MBA_ADD(s.r0, s.r1 ^ (s.pc | 0xA5A5U));
                    s.r1 = OBF_MBA_SUB(s.r1, s.r2 ^ (s.pc & 0x5A5AU));
                    s.dispatch_key = OBF_MBA_XOR(s.dispatch_key, (s.pc * 0x1001U) ^ s.r1);
                } else {
                    s.r0 = OBF_MBA_XOR(s.r0, 0xBAD0BAD0U ^ s.r2);
                    s.r1 = OBF_MBA_NOT(s.r1 ^ s.r0);
                    s.dispatch_key = OBF_MBA_ADD(s.dispatch_key, 0xC001C001U ^ s.r0);
                }
                s.r2 = OBF_MBA_XOR(s.r2, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ s.r0);
                s.pc = OBF_MBA_ADD(s.pc, ((s.r1 & 1U) + 1U) ^ (s.r2 & 3U));
                s.global_seed_ref = OBF_MBA_SUB(s.global_seed_ref, (int)(s.r0 + s.r1 + s.pc));
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
            }

            K8_NOINLINE static void vm_handle_op_mem_sim(VMState& s, int ac, char** av) {
                NOP();
                static unsigned int obf_vm_memory[32];
                unsigned int addr1 = (s.r0 ^ s.pc ^ s.dispatch_key) % 32;
                unsigned int addr2 = (s.r1 ^ s.dispatch_key ^ s.r2) % 32;
                if (OBF_OPAQUE_PREDICATE_TRUE_1()) { obf_vm_memory[addr1] = OBF_MBA_ADD(s.r2, s.dispatch_key ^ (s.r1 & 0xAA55U)); }
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { obf_vm_memory[addr2] = OBF_MBA_XOR(s.r0, s.r1 ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); }
                s.r0 = OBF_MBA_XOR(s.r0, obf_vm_memory[addr2]);
                s.r1 = OBF_MBA_ADD(s.r1, obf_vm_memory[addr1 % 8] ^ s.r2);
                s.dispatch_key = OBF_MBA_SUB(s.dispatch_key, obf_vm_memory[(addr1 + addr2) % 32]);
                s.pc = OBF_MBA_ADD(s.pc, 1U ^ (s.dispatch_key & 1U));
                s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)obf_vm_memory[s.pc % 32]);
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
            }

            K8_NOINLINE static void vm_handle_op_pc_mangle(VMState& s, int ac, char** av) {
                NOP();
                s.pc = OBF_MBA_XOR(s.pc, s.r0 ^ s.r1 ^ s.dispatch_key ^ s.r2);
                s.pc = OBF_MBA_ADD(s.pc, (unsigned int)__LINE__ + (s.dispatch_key & 0x3F));
                s.pc %= 256;
                s.r0 = OBF_MBA_ADD(s.r0, s.pc ^ (s.r1 & 0xF0F0U));
                s.dispatch_key = OBF_MBA_NOT(s.dispatch_key ^ s.pc);
                s.global_seed_ref = OBF_MBA_ADD(s.global_seed_ref, (int)s.pc ^ (int)OBF_CALL_ANY_LOCAL_JUNK());
                if (!OBF_OPAQUE_PREDICATE_FALSE_1()) { s.r1 = OBF_MBA_XOR(s.r1, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ s.r2); }
            }

            K8_NOINLINE 
            static 
            void 
            vm_handle_op_multi_mba(VMState& s, 
                                   int ac, 
                                   char** av) 
            {
                NOP();
                s.r0 = OBF_MBA_ADD(OBF_MBA_XOR(s.r0, s.dispatch_key ^ s.pc), OBF_MBA_MUL_CONST3(s.r1 ^ s.r2));
                s.r1 = OBF_MBA_SUB(OBF_MBA_NOT(s.r1 ^ s.r0), OBF_MBA_XOR(s.r2 ^ s.r0, s.pc));
                s.r2 = OBF_MBA_ADD(OBF_MBA_MUL_CONST_ALT(s.r2, 3), OBF_MBA_SUB(s.r0, s.r1) ^ s.dispatch_key);
                s.dispatch_key = OBF_MBA_XOR(s.dispatch_key, OBF_MBA_NOT(s.r0 ^ s.r1 ^ s.r2));
                s.pc = OBF_MBA_ADD(s.pc, 1U + (s.r0 & 1U));
                s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)OBF_CALL_ANY_LOCAL_JUNK() ^ (int)s.dispatch_key);
                if (VM_OPQ_TRUE() || VM_OPQ_FALSE()) { OBF_CALL_ANY_LOCAL_JUNK(); }
            }

            K8_NOINLINE static void _obf_dummy_func_A_impl(VMState& s, int i) {
                OBF_CALL_ANY_LOCAL_JUNK();
                s.r0 = OBF_MBA_ADD(s.r0, (unsigned int)i ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)__LINE__);
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)s.r0);
            }

            K8_NOINLINE static void _obf_dummy_func_B_impl(VMState& s, int i) {
                OBF_CALL_ANY_LOCAL_JUNK();
                s.r1 = OBF_MBA_XOR(s.r1, (unsigned int)i + (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() + (unsigned int)__COUNTER__);
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)s.r1);
            }

            K8_NOINLINE static void _obf_exit_path_norm_impl(VMState& s, int i) {
                OBF_CALL_ANY_LOCAL_JUNK();
                s.r2 = OBF_MBA_SUB(s.r2, (unsigned int)i ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)s.pc);
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)s.r2 + i);
            }

            K8_NOINLINE static void _obf_exit_path_alt_impl(VMState& s, int i) {
                OBF_CALL_ANY_LOCAL_JUNK();
                s.dispatch_key = OBF_MBA_NOT(s.dispatch_key + (unsigned int)i + (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, (int)s.dispatch_key ^ i);
            }


            // Static functions SEH (C2712-safe versions)
            K8_NOINLINE static void _seh_wrapped_vm_register_modification(VMState& s, unsigned int val) {
                #if defined(_MSC_VER)
                __try {
                    if (((s.global_seed_ref ^ __COUNTER__) % 13) == 1 && OBF_OPAQUE_PREDICATE_TRUE_1()) {
                        volatile int* p_crash = nullptr; *p_crash = val;
                    }
                    s.r0 = OBF_MBA_ADD(s.r0, val ^ (unsigned int)__TIME__[0] ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    s.r0 = OBF_MBA_XOR(s.r0, 0xDEADBEEF ^ (unsigned int)GetExceptionCode() ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                    s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)GetExceptionCode());
                }
                #else
                s.r0 = OBF_MBA_ADD(s.r0, val ^ (unsigned int)__TIME__[0] ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                #endif
                OBF_CALL_ANY_LOCAL_JUNK(); NOP();
            }


            K8_NOINLINE static void _seh_forced_exception_effect(VMState& s) {
                #if defined(_MSC_VER)
                __try {
                    if (OBF_OPAQUE_PREDICATE_TRUE_1()) {
                        volatile int* _seh_p_force = nullptr; *_seh_p_force = __LINE__ ^ OBF_CALL_ANY_LOCAL_JUNK();
                    } else { K8_ASSUME(0); }
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    s.r1 = OBF_MBA_XOR(s.r1, 0xBADCAFE ^ (unsigned int)GetExceptionCode() ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                    s.global_seed_ref = OBF_MBA_XOR(s.global_seed_ref, (int)GetExceptionCode() ^ (int)s.pc);
                }
                #else
                s.r1 = OBF_MBA_XOR(s.r1, 0xBADCAFE ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                #endif
                OBF_CALL_ANY_LOCAL_JUNK(); NOP();
            }


            static vm_handler_ptr_t handler_table_raw[8] = {
                vm_handle_op_arith, vm_handle_op_bitwise_logic, vm_handle_op_key_mangle,
                vm_handle_op_junk_sequence, vm_handle_op_conditional_update, vm_handle_op_mem_sim,
                vm_handle_op_pc_mangle, vm_handle_op_multi_mba
            };

            constexpr size_t HANDLER_COUNT = sizeof(handler_table_raw)/sizeof(vm_handler_ptr_t);

            static vm_handler_ptr_t* get_mem_dispatch_table(VMState& s) {
                static vm_handler_ptr_t scrambled[HANDLER_COUNT] = {};
                static bool inited = false;
                if (!inited) {
                    unsigned int k = (unsigned int)s.global_seed_ref ^ (unsigned int)std::time(nullptr);
                    for (size_t i = 0; i < HANDLER_COUNT; ++i) scrambled[i] = nullptr;
                    for (size_t i = 0; i < HANDLER_COUNT; ++i) {
                        size_t idx = (k + i*5 + (k>>3) + (i<<2)) % HANDLER_COUNT;
                        while (scrambled[idx]) idx = (idx+1)%HANDLER_COUNT;
                        scrambled[idx] = handler_table_raw[i];
                    }
                    inited = true;
                }
                return scrambled;
            }

            static 
            size_t 
            reg_dispatch_idx(const VMState& s) 
            {
                unsigned int h = s.r0 ^ ((s.r1<<5)|(s.r1>>27)) ^ (s.r2*19U) ^ (s.pc*7U) ^ s.dispatch_key ^ (unsigned int)s.global_seed_ref;
                h ^= (h >> 13) ^ (h << 17);
                h *= 0x9e3779b1U;
                return (h ^ (h>>11)) % HANDLER_COUNT;
            }

            static 
            size_t 
            mixed_dispatch_idx(VMState& s) 
            {
                size_t idx = reg_dispatch_idx(s);
                if (OBF_OPAQUE_PREDICATE_TRUE_1() && ((s.r0 ^ s.r1 ^ s.r2 ^ s.dispatch_key) & 1U)) {
                    idx = (idx + 3 + (s.pc & 2U)) % HANDLER_COUNT;
                }
                if (OBF_OPAQUE_PREDICATE_TRUE_2(s.global_seed_ref) && ((s.dispatch_key & 4U) == 0)) {
                    idx = (idx ^ 5U) % HANDLER_COUNT;
                }
                if (OBF_OPAQUE_PREDICATE_FALSE_1() || (s.r2 & 2U)) {
                    idx = (idx + HANDLER_COUNT - 1) % HANDLER_COUNT;
                }
                idx = (idx + ((unsigned int)OBF_CALL_ANY_LOCAL_JUNK() & 3U)) % HANDLER_COUNT;
                return idx;
            }

            K8_NOINLINE
            static
            void
            dsptch(VMState& s,
                             int argc,
                             char** argv,
                             unsigned int steps)
            {
                using obf_dispatch_helpers::DispatchBlockID;

                auto* mem_table = get_mem_dispatch_table(s);
                unsigned int i = 0;
                size_t idx = 0;

                DispatchBlockID current_block_id = DispatchBlockID::INITIALIZE_DISPATCH_LOOP;
                DispatchBlockID next_block_id_for_switch = DispatchBlockID::INITIALIZE_DISPATCH_LOOP;
                bool machine_is_running = true;

                while (machine_is_running) {
                    current_block_id = next_block_id_for_switch;

                    switch (current_block_id) {
                        case DispatchBlockID::INITIALIZE_DISPATCH_LOOP:
                            NOP();
                            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, __LINE__ ^ (int)i);
                            OBF_SET_NEXT_STATE_SKEW_1(DispatchBlockID::CHECK_MAIN_LOOP_CONDITION, next_block_id_for_switch);
                            break;

                        case DispatchBlockID::CHECK_MAIN_LOOP_CONDITION:
                            if (i < steps) {
                                OBF_SET_NEXT_STATE_SKEW_2(DispatchBlockID::DETERMINE_AND_EXECUTE_HANDLER, next_block_id_for_switch);
                            } else {
                                OBF_SET_NEXT_STATE_SKEW_3(DispatchBlockID::EXIT_DISPATCH_LOOP, next_block_id_for_switch);
                            }
                            break;

                        case DispatchBlockID::DETERMINE_AND_EXECUTE_HANDLER:
                        {
                            int dispatcher_type = ((s.dispatch_key ^ s.pc ^ s.global_seed_ref ^ i ^ (int)std::time(nullptr)) & 3);
                            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, dispatcher_type ^ (int)__COUNTER__ ^ (int)OBF_CALL_ANY_LOCAL_JUNK());

                            size_t local_idx_for_handler = 0;

                            if (dispatcher_type == 0) {
                                if (OBF_OPAQUE_PREDICATE_TRUE_1()) {
                                    local_idx_for_handler = reg_dispatch_idx(s);
                                    handler_table_raw[local_idx_for_handler](s, argc, argv);
                                } else { K8_ASSUME(0); }
                            } else if (dispatcher_type == 1) {
                                if (OBF_OPAQUE_PREDICATE_FALSE_1()) {
                                    K8_ASSUME(0);
                                } else {
                                    unsigned int mem_mix = (s.dispatch_key + s.r1 * 7 + s.r2 * 13 + i * 5) ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK();
                                    local_idx_for_handler = (mem_mix % HANDLER_COUNT);
                                    mem_table[local_idx_for_handler](s, argc, argv);
                                }
                            } else if (dispatcher_type == 2) {
                                local_idx_for_handler = mixed_dispatch_idx(s);
                                if (OBF_OPAQUE_PREDICATE_TRUE_1()) {
                                    handler_table_raw[local_idx_for_handler](s, argc, argv);
                                } else {
                                    K8_ASSUME(0);
                                    mem_table[(local_idx_for_handler + 5) % HANDLER_COUNT](s, argc, argv);
                                }
                            } else { 
                                local_idx_for_handler = ((s.pc ^ s.r0 ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ s.dispatch_key) % HANDLER_COUNT);
                                if (OBF_OPAQUE_PREDICATE_TRUE_2(s.r1 ^ s.r2)) {
                                    mem_table[local_idx_for_handler](s, argc, argv);
                                } else {
                                    handler_table_raw[(local_idx_for_handler + 3) % HANDLER_COUNT](s, argc, argv);
                                }
                            }
                            OBF_CALL_ANY_LOCAL_JUNK(); 
                            OBF_SET_NEXT_STATE_SKEW_4(DispatchBlockID::MAYBE_CALL_EXTRA_JUNK, next_block_id_for_switch);
                            break;
                        }

                        case DispatchBlockID::MAYBE_CALL_EXTRA_JUNK:
                            if ((i & 2) && OBF_OPAQUE_PREDICATE_TRUE_2(s.r0 ^ s.dispatch_key)) {
                                OBF_SET_NEXT_STATE_MERGED_COND_SKEW_TRUE(
                                    DispatchBlockID::EXECUTE_EXTRA_JUNK,
                                    DispatchBlockID::DETERMINE_PC_UPDATE_PATH,
                                    next_block_id_for_switch
                                );
                            } else {
                                OBF_SET_NEXT_STATE_SKEW_5(DispatchBlockID::DETERMINE_PC_UPDATE_PATH, next_block_id_for_switch);
                            }
                            break;

                        case DispatchBlockID::EXECUTE_EXTRA_JUNK:
                            OBF_CALL_ANY_LOCAL_JUNK();
                            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)__TIME__[1] ^ (int)i ^ (int)OBF_CALL_ANY_LOCAL_JUNK());
                            OBF_SET_NEXT_STATE_SKEW_6(DispatchBlockID::DETERMINE_PC_UPDATE_PATH, next_block_id_for_switch);
                            break;

                        case DispatchBlockID::DETERMINE_PC_UPDATE_PATH:
                            if (((i & 1) == 0)) {
                                OBF_SET_NEXT_STATE_SKEW_7(DispatchBlockID::EXECUTE_PC_UPDATE_PATH_A, next_block_id_for_switch);
                            } else {
                                OBF_SET_NEXT_STATE_SKEW_8(DispatchBlockID::EXECUTE_PC_UPDATE_PATH_B, next_block_id_for_switch);
                            }
                            break;

                        case DispatchBlockID::EXECUTE_PC_UPDATE_PATH_A:
                            s.pc = (s.pc + mixed_dispatch_idx(s) + (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()) % HANDLER_COUNT;
                            OBF_SET_NEXT_STATE_SKEW_9(DispatchBlockID::INCREMENT_MAIN_LOOP_COUNTER, next_block_id_for_switch);
                            break;

                        case DispatchBlockID::EXECUTE_PC_UPDATE_PATH_B:
                            s.pc = (s.pc + reg_dispatch_idx(s)) % HANDLER_COUNT;
                            OBF_SET_NEXT_STATE_SKEW_10(DispatchBlockID::INCREMENT_MAIN_LOOP_COUNTER, next_block_id_for_switch);
                            break;

                        case DispatchBlockID::INCREMENT_MAIN_LOOP_COUNTER:
                            NOP();
                            i++;
                            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)i ^ (int)__LINE__ ^ (int)OBF_CALL_ANY_LOCAL_JUNK());
                            OBF_SET_NEXT_STATE_SKEW_1(DispatchBlockID::CHECK_MAIN_LOOP_CONDITION, next_block_id_for_switch);
                            break;

                        case DispatchBlockID::DEAD_CODE_TARGET_BLOCK:
                            _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed ^ 0xBEEFBABE);
                            OBF_CALL_ANY_LOCAL_JUNK(); OBF_CALL_ANY_LOCAL_JUNK();
                            OBF_SET_NEXT_STATE_CONST_COND_FALSE_2(
                                DispatchBlockID::DEAD_CODE_TARGET_BLOCK,
                                DispatchBlockID::EXIT_DISPATCH_LOOP,
                                next_block_id_for_switch
                            );
                            K8_ASSUME(0);
                            break;

                        case DispatchBlockID::EXIT_DISPATCH_LOOP:
                            NOP();
                            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)std::time(nullptr) ^ (int)__COUNTER__ ^ s.pc);
                            machine_is_running = false;
                            break;

                        default:
                            NOP();
                            K8_ASSUME(0);
                            machine_is_running = false;
                            break;
                    }
                }
            }

            static 
            vm_handler_ptr_t vm_handler_table[8] = 
            {
                    vm_handle_op_arith, vm_handle_op_bitwise_logic, 
                    vm_handle_op_key_mangle, vm_handle_op_junk_sequence, 
                    vm_handle_op_conditional_update, vm_handle_op_mem_sim,
                    vm_handle_op_pc_mangle, vm_handle_op_multi_mba
            };

            constexpr 
            size_t 
            VM_HANDLER_TABLE_SIZE = sizeof(vm_handler_table)/sizeof(vm_handler_ptr_t);
        }

// --------------------------------------
#pragma endregion VM_ENGINE 

#pragma region CALLERS
// --------------------------------------

    #ifndef PASTE_TOKENS_HELPER
    #define PASTE_TOKENS_HELPER(a, b) a##b
    #endif
    #ifndef PASTE_TOKENS
    #define PASTE_TOKENS(a, b) PASTE_TOKENS_HELPER(a, b)
    #endif

    /// --- JUMP --- 
    // These use goto Wrapping them in an OBF_OPAQUE_PREDICATE_FALSE_1() ensures they are compiled
    // but dont necessarily execute their jump logic during a normal call to CALLERS
    // preventing premature exit from this combined
    #define OBF_JMP(UNIQUE_ID) \
        do { \
            PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID): \
                NOP(); \
                OBF_JUMP_SKEW_1(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_2(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_3(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_4(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_5(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_6(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_7(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_8(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_9(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_SKEW_10(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID)); \
                OBF_JUMP_CONST_COND_TRUE_1(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID), { NOP(); _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, 1); }); \
                OBF_JUMP_CONST_COND_FALSE_1(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID), { NOP(); _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, 1); }); \
                OBF_JUMP_CONST_COND_TRUE_2(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID), { NOP(); _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, 2); }); \
                OBF_JUMP_CONST_COND_FALSE_2(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID), { NOP(); _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, 2); }); \
                OBF_JUMP_MERGED_COND_SKEW_TRUE(PASTE_TOKENS(_DUMMY_LABEL_JUMPS_, UNIQUE_ID), { NOP(); _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, 0xFF); }); \
        } while(0) 


    #define CALLER() \
        do { \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                OBF_JMP(__COUNTER__); \
            }\
            \
        } while(0)

// --------------------------------------
#pragma endregion CALLERS

#pragma region _ANTI_RE_
// --------------------------------------

    // --- Anti-RE (Conceptual) ---
    ///////////////////////////////////////////////
    #define OBF_CALL_VIA_OBF_PTR(func_ptr_type, real_func, arg1, arg2) \
        do { \
            volatile func_ptr_type _obf_fp_internal = (real_func); \
            unsigned int _obf_key_fp = OBF_MBA_XOR((unsigned int)__LINE__, (unsigned int)_obf_global_opaque_seed ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            _obf_fp_internal = (func_ptr_type)((std::uintptr_t)_obf_fp_internal ^ _obf_key_fp); \
            NOP(); \
            _obf_fp_internal = (func_ptr_type)((std::uintptr_t)_obf_fp_internal ^ _obf_key_fp); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                ((func_ptr_type)_obf_fp_internal)((arg1), (arg2)); \
            } else { K8_ASSUME(0); } \
        } while(0)

    #define OBF_CONDITIONAL_EXIT(state_var, val_for_normal_exit, val_for_alt_exit) \
        do { \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(OBF_CALL_ANY_LOCAL_JUNK() ^ _obf_global_opaque_seed)) { \
                (state_var) = (val_for_normal_exit);\
            } else { \
                K8_ASSUME(0); \
                (state_var) = (val_for_alt_exit); \
            } \
            NOP(); \
        } while(0)



    #if defined(_MSC_VER)
        #if defined(_MSC_VER)
            #include <malloc.h>
            #define K8_ALLOCA _alloca
        #endif
        #define OBF_STACK_ALLOC_MANIP(var_name, base_size) \
            volatile unsigned int _obf_alloc_size = OBF_MBA_ADD((base_size), ((unsigned int)OBF_CALL_ANY_LOCAL_JUNK() & 0xFFU)); \
            _obf_alloc_size = (_obf_alloc_size == 0) ? 16 : _obf_alloc_size; \
            volatile char* var_name = (volatile char*)K8_ALLOCA(_obf_alloc_size); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1() && var_name) { \
                for(unsigned int _i_sa = 0; _i_sa < (_obf_alloc_size > 4 ? 4: _obf_alloc_size) ; ++_i_sa) { \
                    var_name[_i_sa] = (char)(_obf_global_opaque_seed ^ _i_sa ^ __COUNTER__); \
                } \
            } \
            NOP();
    #endif

    #define OBF_OBF_ARRAY_ACCESS(array_ptr, real_idx, obf_val_to_write) \
        do { \
            volatile unsigned int _obf_idx_calc1 = OBF_MBA_XOR((unsigned int)(real_idx), (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            volatile unsigned int _obf_idx_calc2 = OBF_MBA_ADD((unsigned int)_obf_global_opaque_seed, (unsigned int)__LINE__); \
            volatile unsigned int _obf_final_idx = OBF_MBA_SUB(OBF_MBA_ADD(_obf_idx_calc1, _obf_idx_calc2), OBF_MBA_XOR(_obf_idx_calc2, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK())); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_obf_final_idx)) { \
               (array_ptr)[(real_idx)] = (char)((obf_val_to_write) ^ _obf_global_opaque_seed); \
            } else { K8_ASSUME(0); } \
            NOP(); \
        } while(0)

    #define OBF_STACK_AND_ACCESS(base_size, idx_to_access, val_to_write) \
        do { \
            OBF_STACK_ALLOC_MANIP(_temp_stack_ptr_sa, base_size); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1() && _temp_stack_ptr_sa && (idx_to_access) < (base_size) ) { \
                OBF_OBF_ARRAY_ACCESS(_temp_stack_ptr_sa, idx_to_access, val_to_write); \
            } \
        } while(0)


    #define OBF_FAKE_PROLOGUE_MANIP() \
        do { \
            volatile std::uintptr_t _fake_ebp = (std::uintptr_t)&_obf_global_opaque_seed - (OBF_CALL_ANY_LOCAL_JUNK() & 0xFF); \
            volatile std::uintptr_t _fake_esp = _fake_ebp - ((OBF_CALL_ANY_LOCAL_JUNK() & 0x7F) + 16); \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_fake_ebp ^ (int)_fake_esp); \
            NOP(); \
        } while(0)

    #define OBF_PREPARE_OBF_RETURN(real_ret_val, temp_var) \
        do { \
            (temp_var) = (real_ret_val); \
            (temp_var) = OBF_MBA_XOR((temp_var), (unsigned int)_obf_global_opaque_seed ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            (temp_var) = OBF_MBA_XOR((temp_var), (unsigned int)_obf_global_opaque_seed ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            NOP(); \
        } while(0)

    #define OBF_STACK_AND_PROLOGUE_JUNK(stack_var_name, base_size) \
        do { \
            OBF_FAKE_PROLOGUE_MANIP(); \
            OBF_STACK_ALLOC_MANIP(stack_var_name, base_size); \
            OBF_CALL_ANY_LOCAL_JUNK(); \
        } while(0)


    K8_NOINLINE static void _obf_dummy_func_A(obf_vm_engine::VMState& s, int i) { s.r0 = OBF_MBA_ADD(s.r0, i ^ OBF_CALL_ANY_LOCAL_JUNK()); }
    K8_NOINLINE static void _obf_dummy_func_B(obf_vm_engine::VMState& s, int i) { s.r1 = OBF_MBA_XOR(s.r1, i + OBF_CALL_ANY_LOCAL_JUNK()); }
    #define OBF_CHAINED_OBF_CALLS(vm_state_ref, val) \
        do { \
            using dummy_func_t = void(*)(obf_vm_engine::VMState&, int); \
            OBF_CALL_VIA_OBF_PTR(dummy_func_t, obf_vm_engine::_obf_dummy_func_A_impl, vm_state_ref, val); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                OBF_CALL_VIA_OBF_PTR(dummy_func_t, obf_vm_engine::_obf_dummy_func_B_impl, vm_state_ref, (val) + 1 + (OBF_CALL_ANY_LOCAL_JUNK() & 1)); \
            } \
            NOP(); \
        } while(0)


    K8_NOINLINE static void _obf_exit_path_norm(obf_vm_engine::VMState& s, int i) { s.r2 = OBF_MBA_SUB(s.r2, i ^ OBF_CALL_ANY_LOCAL_JUNK()); }
    K8_NOINLINE static void _obf_exit_path_alt(obf_vm_engine::VMState& s, int i) { s.dispatch_key = OBF_MBA_NOT(s.dispatch_key + i + OBF_CALL_ANY_LOCAL_JUNK()); }
    #define OBF_EXIT_CHOICE_DRIVES_CALL(vm_state_ref, val, exit_choice_var, normal_choice_val) \
        do { \
            using exit_func_t = void(*)(obf_vm_engine::VMState&, int); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                volatile int _obf_choice = OBF_MBA_XOR((exit_choice_var), OBF_CALL_ANY_LOCAL_JUNK() & 1); \
                _obf_choice = OBF_MBA_XOR(_obf_choice, OBF_CALL_ANY_LOCAL_JUNK() & 1); \
                if (_obf_choice == (normal_choice_val)) { \
                    OBF_CALL_VIA_OBF_PTR(exit_func_t, obf_vm_engine::_obf_exit_path_norm_impl, vm_state_ref, val); \
                } else { \
                    OBF_CALL_VIA_OBF_PTR(exit_func_t, obf_vm_engine::_obf_exit_path_alt_impl, vm_state_ref, val); \
                } \
            } else { K8_ASSUME(0); } \
            NOP(); \
        } while(0)

    #define OBF_HEAVY_JUNK_OP(var_to_modify, val_to_add) \
        do { \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); OBF_CALL_ANY_LOCAL_JUNK(); \
            unsigned int _temp_junk_val1 = (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)__LINE__; \
            unsigned int _temp_junk_val2 = (unsigned int)_obf_global_opaque_seed + (unsigned int)__COUNTER__; \
            (var_to_modify) = OBF_MBA_ADD((var_to_modify), _temp_junk_val1); \
            (var_to_modify) = OBF_MBA_XOR((var_to_modify), _temp_junk_val2); \
            (var_to_modify) = OBF_MBA_SUB((var_to_modify), _temp_junk_val1); \
            (var_to_modify) = OBF_MBA_ADD((var_to_modify), (unsigned int)(val_to_add)); \
            (var_to_modify) = OBF_MBA_XOR((var_to_modify), _temp_junk_val2); \
            NOP(); OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
        } while(0)

// --------------------------------------
#pragma endregion _ANTI_RE_

#pragma region _BOGUS_CONTROL_FLOW_
// --------------------------------------

    #define V2()\
        do { \
            volatile unsigned int _bfl_counter = (unsigned int)__COUNTER__ ^ (unsigned int)_obf_global_opaque_seed; \
            volatile unsigned int _bfl_loop_var = OBF_MBA_XOR(_bfl_counter, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            _bfl_loop_var %= (5 + (OBF_CALL_ANY_LOCAL_JUNK() & 3)); \
            volatile unsigned int _bfl_selector = 0; \
            \
        kk_bfl_loop_start_point: \
            NOP(); \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto Z_bfl_dead_path_alpha; \
            \
            _bfl_selector = OBF_MBA_ADD(_bfl_selector, (_bfl_loop_var ^ (unsigned int)_obf_global_opaque_seed ^ (unsigned int)__LINE__)) % 7; \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_bfl_selector + (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                switch (_bfl_selector) { \
                    case 0: goto _bfl_path_Z; \
                    case 1: if (OBF_OPAQUE_PREDICATE_TRUE_2(_bfl_counter)) goto _bfl_path_ZZ; else goto _bfl_path_CZ; \
                    case 2: goto _bfl_path_CZ; \
                    case 3: if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto Z_bfl_dead_path_beta; else goto _bfl_path_Z; \
                    case 4: goto _bfl_path_ZZ; \
                    case 5: OBF_CALL_ANY_LOCAL_JUNK(); goto _bfl_path_Z_after_junk; \
                    default: goto _bfl_loop_decrementZ; \
                } \
            } else { \
                K8_ASSUME(0); \
                goto Z_bfl_dead_path_gamma; \
            } \
            \
        _bfl_path_Z: \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, 0xAAAA ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            NOP(); \
            goto _bfl_path_Z_after_junk; \
        _bfl_path_Z_after_junk: \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, 0x1111); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) goto _bfl_loop_decrementZ; else goto Z_bfl_dead_path_delta; \
            \
        _bfl_path_ZZ: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, 0xBBBB ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            NOP(); NOP(); \
            goto _bfl_loop_decrementZ; \
            \
        _bfl_path_CZ: \
            _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed ^ 0xCCCC); \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_bfl_selector)) goto _bfl_loop_decrementZ; else goto Z_bfl_dead_path_epsilon; \
            \
        _bfl_loop_decrementZ: \
            _bfl_loop_var = OBF_MBA_SUB(_bfl_loop_var, 1U); \
            _bfl_counter = OBF_MBA_ADD(_bfl_counter, 1U); \
            if (OBF_MBA_ADD(_bfl_loop_var, 1U) > 0U && OBF_OPAQUE_PREDICATE_TRUE_1()) {\
                goto kk_bfl_loop_start_point; \
            } \
            goto _bfl_exit_labyrinthZ; \
            \
        Z_bfl_dead_path_alpha: K8_ASSUME(0); _obf_global_opaque_seed++; goto _bfl_loop_decrementZ; \
        Z_bfl_dead_path_beta:  K8_ASSUME(0); _obf_global_opaque_seed--; goto _bfl_path_ZZ; \
        Z_bfl_dead_path_gamma: K8_ASSUME(0); _obf_global_opaque_seed ^= 1; goto _bfl_loop_decrementZ; \
        Z_bfl_dead_path_delta: K8_ASSUME(0); _obf_global_opaque_seed += 2; goto _bfl_path_CZ; \
        Z_bfl_dead_path_epsilon: K8_ASSUME(0); _obf_global_opaque_seed -=3; goto _bfl_exit_labyrinthZ; \
            \
        _bfl_exit_labyrinthZ: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)0x1AB71214); \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
        } while(0)


    #define OBF_BOGUS_FLOW_LABYRINTH() \
        do { \
            volatile unsigned int _bfl_counter = (unsigned int)__COUNTER__ ^ (unsigned int)_obf_global_opaque_seed; \
            volatile unsigned int _bfl_loop_var = OBF_MBA_XOR(_bfl_counter, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            _bfl_loop_var %= (5 + (OBF_CALL_ANY_LOCAL_JUNK() & 3)); \
            volatile unsigned int _bfl_selector = 0; \
            \
        _bfl_loop_start_point: \
            NOP(); \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto _bfl_dead_path_alpha; \
            \
            _bfl_selector = OBF_MBA_ADD(_bfl_selector, (_bfl_loop_var ^ (unsigned int)_obf_global_opaque_seed ^ (unsigned int)__LINE__)) % 7; \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_bfl_selector + (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                switch (_bfl_selector) { \
                    case 0: goto _bfl_path_A; \
                    case 1: if (OBF_OPAQUE_PREDICATE_TRUE_2(_bfl_counter)) goto _bfl_path_B; else goto _bfl_path_C; \
                    case 2: goto _bfl_path_C; \
                    case 3: if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto _bfl_dead_path_beta; else goto _bfl_path_A; \
                    case 4: goto _bfl_path_B; \
                    case 5: OBF_CALL_ANY_LOCAL_JUNK(); goto _bfl_path_A_after_junk; \
                    default: goto _bfl_loop_decrement; \
                } \
            } else { \
                K8_ASSUME(0); \
                goto _bfl_dead_path_gamma; \
            } \
            \
        _bfl_path_A: \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, 0xAAAA ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            NOP(); \
            goto _bfl_path_A_after_junk; \
        _bfl_path_A_after_junk: \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, 0x1111); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) goto _bfl_loop_decrement; else goto _bfl_dead_path_delta; \
            \
        _bfl_path_B: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, 0xBBBB ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            NOP(); NOP(); \
            goto _bfl_loop_decrement; \
            \
        _bfl_path_C: \
            _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed ^ 0xCCCC); \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_bfl_selector)) goto _bfl_loop_decrement; else goto _bfl_dead_path_epsilon; \
            \
        _bfl_loop_decrement: \
            _bfl_loop_var = OBF_MBA_SUB(_bfl_loop_var, 1U); \
            _bfl_counter = OBF_MBA_ADD(_bfl_counter, 1U); \
            if (OBF_MBA_ADD(_bfl_loop_var, 1U) > 0U && OBF_OPAQUE_PREDICATE_TRUE_1()) {\
                goto _bfl_loop_start_point; \
            } \
            goto _bfl_exit_labyrinth; \
            \
        _bfl_dead_path_alpha: K8_ASSUME(0); _obf_global_opaque_seed++; goto _bfl_loop_decrement; \
        _bfl_dead_path_beta:  K8_ASSUME(0); _obf_global_opaque_seed--; goto _bfl_path_B; \
        _bfl_dead_path_gamma: K8_ASSUME(0); _obf_global_opaque_seed ^= 1; goto _bfl_loop_decrement; \
        _bfl_dead_path_delta: K8_ASSUME(0); _obf_global_opaque_seed += 2; goto _bfl_path_C; \
        _bfl_dead_path_epsilon: K8_ASSUME(0); _obf_global_opaque_seed -=3; goto _bfl_exit_labyrinth; \
            \
        _bfl_exit_labyrinth: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)0x1AB71214); \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
        } while(0)


    #define OBF_BOGUS_FLOW_GRID() \
        do { \
            volatile unsigned int _bfg_state_x = (unsigned int)__LINE__ % 3; \
            volatile unsigned int _bfg_state_y = (unsigned int)__TIME__[0] % 3; \
            volatile unsigned int _bfg_initial_iter_val_obf = OBF_MBA_ADD(3U, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() & 1U); \
            volatile unsigned int _bfg_iter = (_bfg_initial_iter_val_obf % 2U) + 3U; \
            \
        _bfg_grid_main_loop: \
            NOP(); \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)(_bfg_state_x + _bfg_state_y) ^ OBF_CALL_ANY_LOCAL_JUNK()); \
            \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()){\
                if (_bfg_state_x == 0) goto _bfg_row0_logic; \
                if (_bfg_state_x == 1) goto _bfg_row1_logic; \
                goto _bfg_row2_logic; \
            } else { K8_ASSUME(0); goto _bfg_grid_dead_end_A; } \
            \
        _bfg_row0_logic: \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_bfg_state_y)) _bfg_state_y = OBF_MBA_ADD(_bfg_state_y, 1U) % 3; \
            else { K8_ASSUME(0); _bfg_state_y = 0; } \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto _bfg_grid_dead_end_B; \
            _bfg_state_x = 1; \
            goto _bfg_grid_check_iter; \
            \
        _bfg_row1_logic: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)0x621D0001 ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()){ \
                unsigned int _temp_y_before = _bfg_state_y; \
                _bfg_state_y = OBF_MBA_SUB(_bfg_state_y, 1U); \
                if (_temp_y_before == 0 && _bfg_state_y > 2) { \
                     _bfg_state_y = 2; \
                } else if (_bfg_state_y > 2 && _temp_y_before != 0) { \
                     _bfg_state_y = _temp_y_before % 3; \
                } \
                _bfg_state_y %= 3; \
            } else { K8_ASSUME(0); } \
            _bfg_state_x = 2; \
            goto _bfg_grid_check_iter; \
            \
        _bfg_row2_logic: \
            NOP(); NOP(); \
            if (OBF_OPAQUE_PREDICATE_FALSE_2(_bfg_state_x)) goto _bfg_grid_dead_end_C; \
            _bfg_state_y = (_bfg_state_y + _bfg_state_x) % 3; \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, (int)0x621D0002); \
            _bfg_state_x = 0; \
            goto _bfg_grid_check_iter; \
            \
        _bfg_grid_check_iter: \
            if (_bfg_iter > 0U && OBF_OPAQUE_PREDICATE_TRUE_2(_bfg_iter)) { \
                _bfg_iter--; \
                goto _bfg_grid_main_loop; \
            } \
            goto _bfg_grid_exit; \
            \
        _bfg_grid_dead_end_A: K8_ASSUME(0); _obf_global_opaque_seed++; goto _bfg_grid_exit; \
        _bfg_grid_dead_end_B: K8_ASSUME(0); _obf_global_opaque_seed--; goto _bfg_grid_exit; \
        _bfg_grid_dead_end_C: K8_ASSUME(0); _obf_global_opaque_seed^=0xFF; goto _bfg_grid_exit; \
            \
        _bfg_grid_exit: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)0x621D3E17 ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            OBF_CALL_ANY_LOCAL_JUNK(); \
        } while(0)

    #define OBF_BOGUS_FLOW_SCRAMBLE() \
        do { \
            volatile unsigned int _bfs_mode = ((unsigned int)__TIME__[1] + (unsigned int)_obf_global_opaque_seed) % 4; \
            volatile int _bfs_accumulator = OBF_CALL_ANY_LOCAL_JUNK(); \
            int _bfs_loop_count = 2 + (OBF_CALL_ANY_LOCAL_JUNK() & 1); \
            V2();\
            \
        _bfs_outer_loop: \
            NOP(); \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, _bfs_accumulator ^ (int)_bfs_mode); \
        \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                goto _bfs_decision_point_1; \
            } \
            K8_ASSUME(0); goto _bfs_dead_branch_X; \
        \
        _bfs_decision_point_1: \
            _bfs_accumulator = OBF_MBA_XOR(_bfs_accumulator, (int)__LINE__ + (int)_bfs_mode); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2((unsigned int)_bfs_accumulator)) { \
                if ((_bfs_mode % 2) == 0) goto _bfs_path_EVEN; else goto _bfs_path_ODD; \
            } else { \
                K8_ASSUME(0); goto _bfs_dead_branch_Y; \
            } \
        \
        _bfs_path_EVEN: \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            _bfs_accumulator = OBF_MBA_ADD(_bfs_accumulator, 0xE0E0); \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, _bfs_accumulator); \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto _bfs_dead_branch_Z; \
            _bfs_mode = (_bfs_mode + 1) % 4; \
            goto _bfs_decision_point_2; \
        \
        _bfs_path_ODD: \
            NOP(); NOP(); \
            _bfs_accumulator = OBF_MBA_SUB(_bfs_accumulator, 0xD0D0); \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, _bfs_accumulator); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _bfs_mode = (_bfs_mode + 3) % 4; \
                goto _bfs_decision_point_2; \
            } \
            K8_ASSUME(0); goto _bfs_dead_branch_W; \
        \
        _bfs_decision_point_2: \
            _bfs_accumulator = OBF_MBA_NOT(_bfs_accumulator ^ (int)_obf_global_opaque_seed); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2((unsigned int)_bfs_mode)) { \
                goto _bfs_inner_processing; \
            } else { \
                K8_ASSUME(0); goto _bfs_dead_branch_V; \
            } \
        \
        _bfs_inner_processing: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, _bfs_accumulator + (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            _bfs_loop_count--; \
            if (_bfs_loop_count > 0 && OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                goto _bfs_outer_loop; \
            } \
            goto _bfs_scramble_exit; \
        \
        _bfs_dead_branch_X: K8_ASSUME(0); _bfs_accumulator += 100; goto _bfs_scramble_exit; \
        _bfs_dead_branch_Y: K8_ASSUME(0); _bfs_accumulator -= 200; goto _bfs_scramble_exit; \
        _bfs_dead_branch_Z: K8_ASSUME(0); _bfs_accumulator *= 2; goto _bfs_scramble_exit; \
        _bfs_dead_branch_W: K8_ASSUME(0); _bfs_accumulator /= 2; goto _bfs_scramble_exit; \
        _bfs_dead_branch_V: K8_ASSUME(0); _bfs_accumulator = 0; goto _bfs_scramble_exit; \
        \
        _bfs_scramble_exit: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, 0x5C2A3B1E ^ _bfs_accumulator); \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); OBF_CALL_ANY_LOCAL_JUNK(); \
        } while(0)

// --------------------------------------
#pragma endregion _BOGUS_CONTROL_FLOW_

#pragma region _CONTROL_FLOW_
// --------------------------------------

    #define OBF_BOGUS_FLOW_WEAVER() \
        do { \
            volatile unsigned int _weave_idx = (unsigned int)__COUNTER__ ^ (unsigned int)_obf_global_opaque_seed; \
            volatile unsigned int _weave_max_hops = 3U + (OBF_CALL_ANY_LOCAL_JUNK() & 3U); \
            volatile unsigned int _weave_current_hop = 0; \
            volatile unsigned int _weave_state_var = OBF_MBA_XOR(_weave_idx, (unsigned int)__TIME__[0]); \
            \
        _weave_hop_entry_point: \
            NOP(); \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)_weave_state_var ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            if (OBF_OPAQUE_PREDICATE_FALSE_1()) goto _weave_impossible_fork; \
            \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _weave_state_var = OBF_MBA_XOR(_weave_state_var, (unsigned int)__LINE__ + _weave_current_hop); \
                if ((_weave_state_var % 5) == 0) goto _weave_path_alpha; \
                if ((_weave_state_var % 5) == 1) goto _weave_path_beta; \
                if ((_weave_state_var % 5) == 2) goto _weave_path_gamma; \
                if ((_weave_state_var % 5) == 3) goto _weave_path_delta; \
                goto _weave_path_epsilon; \
            } else { \
                K8_ASSUME(0); goto _weave_never_reached_A; \
            } \
            \
        _weave_path_alpha: \
            _weave_state_var = OBF_MBA_ADD(_weave_state_var, 0xDEAD0001U ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_weave_idx)) goto _weave_common_junction; else goto _weave_path_beta; \
            \
        _weave_path_beta: \
            _weave_state_var = OBF_MBA_SUB(_weave_state_var, 0xBEEF0002U + (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            if (!OBF_OPAQUE_PREDICATE_FALSE_1()) goto _weave_common_junction; else goto _weave_path_gamma; \
            \
        _weave_path_gamma: \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            _weave_state_var = OBF_MBA_NOT(_weave_state_var ^ 0xCAFE0003U); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) goto _weave_common_junction; else goto _weave_path_delta; \
            \
        _weave_path_delta: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_weave_state_var); \
            _weave_state_var = OBF_MBA_ADD(_weave_state_var, (_weave_current_hop << 3) ^ 0xF00D0004U); \
            if (OBF_OPAQUE_PREDICATE_TRUE_2(_weave_state_var)) goto _weave_common_junction; else goto _weave_path_epsilon; \
            \
        _weave_path_epsilon: \
            NOP(); \
            _weave_state_var = OBF_MBA_XOR(_weave_state_var, 0xBADC0005U + (unsigned int)_obf_global_opaque_seed); \
            \
        _weave_common_junction: \
            _weave_current_hop = OBF_MBA_ADD(_weave_current_hop, 1U); \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)_weave_current_hop); \
            if (_weave_current_hop < _weave_max_hops && OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                goto _weave_hop_entry_point; \
            } \
            goto _weave_exit_point; \
            \
        _weave_impossible_fork: K8_ASSUME(0); _weave_state_var ^= 0xFFFFFFFFU; goto _weave_common_junction; \
        _weave_never_reached_A: K8_ASSUME(0); _weave_state_var += 1; goto _weave_path_alpha; \
            \
        _weave_exit_point: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)0xDEADBEEF ^ (int)_weave_state_var); \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
        } while(0)


    #define OBF_BOGUS_FLOW_CASCADE() \
        do { \
            volatile unsigned int _cas_level = 0; \
            volatile unsigned int _cas_seed = (unsigned int)__TIME__[1] ^ (unsigned int)_obf_global_opaque_seed ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK(); \
            volatile unsigned int _cas_val_A = OBF_MBA_ADD(_cas_seed, 0x11223344U); \
            volatile unsigned int _cas_val_B = OBF_MBA_SUB(_cas_seed, 0x55667788U); \
            \
            NOP(); \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                _cas_level = OBF_MBA_ADD(_cas_level, 1U); \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_cas_val_A + (int)OBF_CALL_ANY_LOCAL_JUNK()); \
                _cas_val_A = OBF_MBA_XOR(_cas_val_A, _cas_val_B ^ (unsigned int)__LINE__); \
                \
                if (OBF_OPAQUE_PREDICATE_TRUE_2(_cas_val_A)) { \
                    _cas_level = OBF_MBA_ADD(_cas_level, 1U); \
                    _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)_cas_val_B ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
                    _cas_val_B = OBF_MBA_NOT(_cas_val_A + _cas_val_B); \
                    \
                    if (!OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                        _cas_level = OBF_MBA_ADD(_cas_level, 1U); \
                        _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, (int)_cas_val_A - (int)_cas_val_B); \
                        _cas_val_A = OBF_MBA_MUL_CONST3(_cas_val_A ^ _cas_seed); \
                        \
                        if (OBF_OPAQUE_PREDICATE_TRUE_1() || OBF_OPAQUE_PREDICATE_FALSE_2(_cas_seed)) { \
                            _cas_level = OBF_MBA_ADD(_cas_level, 1U); \
                            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)OBF_CALL_ANY_LOCAL_JUNK() ^ (int)__COUNTER__); \
                            _cas_val_B = OBF_MBA_ADD(_cas_val_B, _cas_val_A | (unsigned int)__LINE__); \
                        } else { \
                            K8_ASSUME(0); \
                            _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed); \
                        } \
                    } else { \
                        K8_ASSUME(0); \
                         _cas_val_A = OBF_MBA_XOR(_cas_val_A, 0xBAD0BAD0); \
                    } \
                } else { \
                    K8_ASSUME(0);\
                     _cas_val_B = OBF_MBA_ADD(_cas_val_B, 0xC0DEC0DE); \
                } \
            } else { \
                K8_ASSUME(0); \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, 0xFEEDF00D); \
            } \
            \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_cas_level ^ (int)_cas_val_A ^ (int)_cas_val_B); \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
        } while(0)


    #define OBF_BOGUS_FLOW_CYCLONE() \
        do { \
            volatile unsigned int _cyc_state = ((unsigned int)__TIME__[2] + (unsigned int)_obf_global_opaque_seed) % 5; \
            volatile int _cyc_counter = OBF_CALL_ANY_LOCAL_JUNK() & 0x7; \
            volatile unsigned int _cyc_acc = (unsigned int)__COUNTER__; \
            \
        _cyclone_main_hub: \
            NOP(); \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_cyc_state ^ (int)_cyc_acc ^ (int)OBF_CALL_ANY_LOCAL_JUNK()); \
            _cyc_acc = OBF_MBA_ADD(_cyc_acc, _cyc_state ^ (unsigned int)__LINE__); \
            \
            switch(_cyc_state) { \
                case 0: \
                    if(OBF_OPAQUE_PREDICATE_TRUE_1()) goto _cyclone_path_red; else goto _cyclone_path_blue; \
                case 1: \
                    _cyc_acc = OBF_MBA_XOR(_cyc_acc, 0x1001F00D); \
                    if(OBF_OPAQUE_PREDICATE_TRUE_2(_cyc_acc)) goto _cyclone_path_green; else goto _cyclone_path_yellow; \
                case 2: \
                    OBF_CALL_ANY_LOCAL_JUNK(); \
                    if(!OBF_OPAQUE_PREDICATE_FALSE_1()) goto _cyclone_path_blue; else goto _cyclone_path_red; \
                case 3: \
                    _cyc_acc = OBF_MBA_NOT(_cyc_acc + 0xABCDEF01U); \
                    if(OBF_OPAQUE_PREDICATE_TRUE_1()) goto _cyclone_path_yellow; else goto _cyclone_path_green; \
                case 4: \
                    goto _cyclone_check_loop; \
                default: \
                    K8_ASSUME(0); goto _cyclone_exit_loop; \
            } \
            \
        _cyclone_path_red: \
            _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, 1 + (int)_cyc_acc); \
            _cyc_state = (_cyc_state + 2 + (_cyc_acc & 1)) % 5; \
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) goto _cyclone_check_loop; else { K8_ASSUME(0); goto _cyclone_path_green; } \
            \
        _cyclone_path_blue: \
            _obf_global_opaque_seed = OBF_MBA_SUB(_obf_global_opaque_seed, 2 - (int)_cyc_acc); \
            _cyc_state = (_cyc_state + 3 + ((_cyc_acc>>1) & 1)) % 5; \
            if (!OBF_OPAQUE_PREDICATE_FALSE_2(_cyc_state)) goto _cyclone_check_loop; else { K8_ASSUME(0); goto _cyclone_path_yellow; } \
            \
        _cyclone_path_green: \
            OBF_CALL_ANY_LOCAL_JUNK(); \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, 3 * (int)_cyc_acc); \
            _cyc_state = (_cyc_state + 1) % 5; \
            goto _cyclone_check_loop; \
            \
        _cyclone_path_yellow: \
            NOP(); NOP(); \
            _obf_global_opaque_seed = OBF_MBA_NOT(_obf_global_opaque_seed ^ (4 + (int)_cyc_acc)); \
            _cyc_state = (_cyc_state + 4 + ((_cyc_acc>>2) & 1)) % 5; \
            goto _cyclone_check_loop; \
            \
        _cyclone_check_loop: \
            _cyc_counter = OBF_MBA_SUB(_cyc_counter, 1); \
            if (_cyc_counter > 0 && OBF_OPAQUE_PREDICATE_TRUE_2((unsigned int)_cyc_counter)) { \
                goto _cyclone_main_hub; \
            } \
            \
        _cyclone_exit_loop: \
            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)0xC1C0FFEE ^ (int)_cyc_acc); \
            OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
        } while(0)


        #pragma region OBF_ICFF_COMMON_DEFS
        // --------------------------------------

            namespace obf_icff_ns_dcff {
                    enum class _ObfICFF_BlockId_DCFF : unsigned int {
                        BLOCK_INIT_SELECTOR,

                        BLOCK_CASE_0,
                        BLOCK_CASE_1,
                        BLOCK_CASE_2,
                        BLOCK_CASE_3,
                        BLOCK_CASE_4,
                        BLOCK_CASE_5,
                        BLOCK_CASE_6,
                        BLOCK_CASE_7,
                        BLOCK_CASE_8,
                        BLOCK_CASE_9,
                        BLOCK_DEFAULT,

                        BLOCK_COMMON_CONTINUE,
                        BLOCK_EXIT_ICFF_LOOP,

                        BLOCK_DECOY_A,
                        BLOCK_DECOY_B,

                        COUNT_DCFF
                    };

                    K8_FORCEINLINE unsigned int _obf_icff_gen_key_dcff(
                        int i_dcff,
                        const obf_vm_engine::VMState& vm_s_ref,
                        volatile int& global_seed_ref,
                        unsigned int unique_salt
                    ) {
                        return OBF_MBA_XOR(
                                   OBF_MBA_ADD((unsigned int)i_dcff * OBF_MBA_ADD(0xADDECFFA, unique_salt ^ (unsigned int)__TIME__[0]), vm_s_ref.dispatch_key ^ (unsigned int)__TIME__[(i_dcff ^ unique_salt) % 8]),
                                   OBF_MBA_SUB((unsigned int)global_seed_ref * OBF_MBA_SUB(0x10CCFB1A, unique_salt ^ (unsigned int)__TIME__[1]), vm_s_ref.pc ^ vm_s_ref.r0 ^ vm_s_ref.r1 ^ vm_s_ref.r2 ^ unique_salt ^ (unsigned int)__TIME__[2])
                               );
                    }

                    #define OBF_ICFF_ENCODE_STATE_DCFF(state_id, i_dcff_val, vm_s_ref, global_seed_ref, unique_salt_for_transition) \
                        OBF_MBA_XOR( (unsigned int)(state_id), _obf_icff_gen_key_dcff(i_dcff_val, vm_s_ref, global_seed_ref, unique_salt_for_transition) )

                    #define OBF_ICFF_DECODE_STATE_DCFF(encoded_state_val, i_dcff_val, vm_s_ref, global_seed_ref, unique_salt_for_transition) \
                        (_ObfICFF_BlockId_DCFF)OBF_MBA_XOR( (unsigned int)(encoded_state_val), _obf_icff_gen_key_dcff(i_dcff_val, vm_s_ref, global_seed_ref, unique_salt_for_transition) )

                    K8_FORCEINLINE _ObfICFF_BlockId_DCFF _obf_icff_map_selector_to_block_id_dcff(unsigned int selector_val, volatile int& global_seed_ref) {
                        unsigned int s = OBF_MBA_XOR(selector_val, (unsigned int)global_seed_ref ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK());
                        s = OBF_MBA_ADD(s, (unsigned int)__TIME__[s % 8] ^ (unsigned int)__LINE__);
                        s %= 10; 

                        switch (s) {
                            case 0: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_0;
                            case 1: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_1;
                            case 2: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_2;
                            case 3: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_3;
                            case 4: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_4;
                            case 5: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_5;
                            case 6: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_6;
                            case 7: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_7;
                            case 8: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_8;
                            case 9: return _ObfICFF_BlockId_DCFF::BLOCK_CASE_9;
                            default: 
                                K8_ASSUME(s >=0 && s <= 9);
                                return _ObfICFF_BlockId_DCFF::BLOCK_DEFAULT;
                        }
                    }
            }

            using namespace obf_icff_ns_dcff;


            namespace obf_icff_ns_epd {
                    enum class _ObfICFF_BlockId_EPD : unsigned int {
                        BLOCK_INIT_SELECTOR,

                        BLOCK_CASE_0,
                        BLOCK_CASE_1,
                        BLOCK_CASE_2,
                        BLOCK_CASE_3,
                        BLOCK_CASE_4,
                        BLOCK_CASE_5,
                        BLOCK_CASE_6,
                        BLOCK_CASE_7,
                        BLOCK_DEFAULT,

                        BLOCK_COMMON_CONTINUE,
                        BLOCK_EXIT_ICFF_LOOP,

                        BLOCK_DECOY_A,
                        BLOCK_DECOY_B,

                        COUNT_EPD
                    };

                    K8_FORCEINLINE unsigned int _obf_icff_gen_key_epd(
                        int i_epd,
                        unsigned int epi_val,
                        const obf_vm_engine::VMState& vm_s_ref,
                        volatile int& global_seed_ref,
                        unsigned int unique_salt
                    ) {
                        return OBF_MBA_XOR(
                                   OBF_MBA_SUB((unsigned int)i_epd * OBF_MBA_XOR(0xBEEFB00B, unique_salt ^ (unsigned int)__TIME__[3]), epi_val ^ (unsigned int)__TIME__[(i_epd ^ epi_val ^ unique_salt) % 8]),
                                   OBF_MBA_ADD((unsigned int)global_seed_ref * OBF_MBA_NOT(0xF00DBAAC + unique_salt), vm_s_ref.dispatch_key ^ vm_s_ref.r1 ^ vm_s_ref.r2 ^ epi_val ^ unique_salt ^ (unsigned int)__TIME__[4])
                               );
                    }

                    #define OBF_ICFF_ENCODE_STATE_EPD(state_id, i_epd_val, epi_val_ref, vm_s_ref, global_seed_ref, unique_salt_for_transition) \
                        OBF_MBA_XOR( (unsigned int)(state_id), _obf_icff_gen_key_epd(i_epd_val, epi_val_ref, vm_s_ref, global_seed_ref, unique_salt_for_transition) )

                    #define OBF_ICFF_DECODE_STATE_EPD(encoded_state_val, i_epd_val, epi_val_ref, vm_s_ref, global_seed_ref, unique_salt_for_transition) \
                        (_ObfICFF_BlockId_EPD)OBF_MBA_XOR( (unsigned int)(encoded_state_val), _obf_icff_gen_key_epd(i_epd_val, epi_val_ref, vm_s_ref, global_seed_ref, unique_salt_for_transition) )


                    K8_FORCEINLINE _ObfICFF_BlockId_EPD _obf_icff_map_selector_to_block_id_epd(unsigned int selector_val, volatile int& global_seed_ref) {
                        unsigned int s = OBF_MBA_XOR(selector_val, (unsigned int)global_seed_ref ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)__LINE__);
                        s = OBF_MBA_ADD(s, (unsigned int)__TIME__[(s % 8)+1]);
                        s %= 8;

                        switch (s) {
                            case 0: return _ObfICFF_BlockId_EPD::BLOCK_CASE_0;
                            case 1: return _ObfICFF_BlockId_EPD::BLOCK_CASE_1;
                            case 2: return _ObfICFF_BlockId_EPD::BLOCK_CASE_2;
                            case 3: return _ObfICFF_BlockId_EPD::BLOCK_CASE_3;
                            case 4: return _ObfICFF_BlockId_EPD::BLOCK_CASE_4;
                            case 5: return _ObfICFF_BlockId_EPD::BLOCK_CASE_5;
                            case 6: return _ObfICFF_BlockId_EPD::BLOCK_CASE_6;
                            case 7: return _ObfICFF_BlockId_EPD::BLOCK_CASE_7;
                            default:
                                K8_ASSUME(s >= 0 && s <= 7);
                                return _ObfICFF_BlockId_EPD::BLOCK_DEFAULT;
                        }
                    }
            }

            using namespace obf_icff_ns_epd;

        // --------------------------------------
        #pragma endregion OBF_ICFF_COMMON_DEFS

// --------------------------------------
#pragma endregion _CONTROL_FLOW_

#pragma region MAIN_FLATTENING
// --------------------------------------

    #define Runtime(vm_state_ref) \
        do { \
            unsigned int _rt_activation_key = OBF_MBA_XOR((unsigned int)std::time(nullptr), (unsigned int)_obf_global_opaque_seed ^ (unsigned int)__COUNTER__); \
            _rt_activation_key = OBF_MBA_ADD(_rt_activation_key, (vm_state_ref).r0 ^ (vm_state_ref).r1 ^ (vm_state_ref).pc); \
            \
            if (((_rt_activation_key >> ((OBF_CALL_ANY_LOCAL_JUNK() & 3) + 2)) & 0x7U) == ((unsigned int)__TIME__[(_rt_activation_key>>8)%8] & 0x7U) ) { \
                NOP(); \
                volatile int _rt_decision_val = OBF_MBA_XOR(_obf_global_opaque_seed, (int)__LINE__ ^ (int)std::time(nullptr) ^ (int)(vm_state_ref).dispatch_key); \
                _rt_decision_val = OBF_MBA_ADD(_rt_decision_val, OBF_CALL_ANY_LOCAL_JUNK()); \
                CALLER();\
                \
                if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                    CALLER();\
                } else { K8_ASSUME(0); CALLER(); } \
                \
                unsigned int _rt_crash_cond_part1 = OBF_MBA_MUL_CONST3(_rt_decision_val ^ (vm_state_ref).r2); \
                unsigned int _rt_crash_cond_part2 = OBF_MBA_NOT((unsigned int)_obf_global_opaque_seed + (vm_state_ref).pc); \
                \
                if ( (_rt_crash_cond_part1 & 0xFEFEFEFEU) == OBF_MBA_XOR(0x41414141U & 0xFEFEFEFEU, _rt_crash_cond_part2 & 0x01010101U) && \
                     OBF_OPAQUE_PREDICATE_TRUE_2(_rt_decision_val ^ (vm_state_ref).r0) ) \
                { \
                    OBF_CALL_ANY_LOCAL_JUNK(); \
                    if ((_rt_decision_val & 0x180) && (std::rand() & 1) && OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                        if (((unsigned int)_obf_global_opaque_seed ^ __LINE__) % 3 == 0) { \
                            obf_vm_engine::_seh_forced_exception_effect(vm_state_ref); \
                        } else { \
                            __debugbreak(); \
                        } \
                    } \
                    unsigned int _rt_err_seed = (unsigned int)_obf_global_opaque_seed ^ (unsigned int)__TIME__[0] ^ (unsigned int)__COUNTER__; \
                    auto llll = (_rt_err_seed >> 8) & 0xFF + _rt_err_seed & 0xFF ^ (vm_state_ref).r0 << 0xFFFF + OBF_CALL_ANY_LOCAL_JUNK() % 10;\
                    throw std::runtime_error(OBFUSCATE_STRING("pojkdkddkeifpojkdkddkeifpojkdkddkeifpojkdkddkeif Oh skibiddi oooh")); \
                    if (((unsigned int)_obf_global_opaque_seed ^ __COUNTER__ << llll) % 3 == 0) { \
                        CALLER(); \
                    } \
                } \
                CALLER(); \
                if (((unsigned int)_obf_global_opaque_seed ^ __COUNTER__) % 3 == 0) { \
                     CALLER(); \
                } \
            } \
            NOP(); \
        } while (0)

    #define HANDLER_TABLE_MUTATE(table, sz, vm_state_ref) \
        do { \
            if ((sz) == 0) break;\
            volatile unsigned int _htm_outer_loop_count = (sz) + (OBF_CALL_ANY_LOCAL_JUNK() & 3U);\
            \
            for (size_t _htm_i = 0; _htm_i < _htm_outer_loop_count; ++_htm_i) { \
                CALLER(); \
                NOP(); \
                \
                unsigned int _htm_base_val1 = OBF_MBA_XOR((unsigned int)_htm_i * 13U, (unsigned int)std::time(nullptr) + (unsigned int)_obf_global_opaque_seed); \
                _htm_base_val1 = OBF_MBA_ADD(_htm_base_val1, (vm_state_ref).r0 ^ (vm_state_ref).dispatch_key); \
                size_t _htm_idx1 = _htm_base_val1 % (sz); \
                \
                unsigned int _htm_base_val2 = OBF_MBA_SUB((unsigned int)_htm_i * 7U, (unsigned int)_obf_global_opaque_seed ^ (unsigned int)__LINE__); \
                _htm_base_val2 = OBF_MBA_XOR(_htm_base_val2, (vm_state_ref).r1 ^ (vm_state_ref).pc); \
                size_t _htm_idx2 = _htm_base_val2 % (sz); \
                \
                if (OBF_OPAQUE_PREDICATE_TRUE_1() && _htm_idx1 != _htm_idx2) { \
                    auto _htm_temp_ptr = (table)[_htm_idx1]; \
                    (table)[_htm_idx1] = (table)[_htm_idx2]; \
                    (table)[_htm_idx2] = _htm_temp_ptr; \
                    _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)(_htm_idx1 ^ _htm_idx2)); \
                } else if (OBF_OPAQUE_PREDICATE_TRUE_2(_htm_base_val1)) { \
                    unsigned int _htm_base_val3 = OBF_MBA_XOR((unsigned int)_obf_global_opaque_seed, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (vm_state_ref).r2); \
                    size_t _htm_idx3 = (_htm_base_val3 ^ _htm_idx1) % (sz); \
                    if (_htm_idx1 != _htm_idx3) { \
                        auto _htm_extra_temp_ptr = (table)[_htm_idx1]; \
                        (table)[_htm_idx1] = (table)[_htm_idx3]; \
                        (table)[_htm_idx3] = _htm_extra_temp_ptr; \
                         _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)(_htm_idx1 ^ _htm_idx3) + 1); \
                    } \
                } \
                \
                if (((unsigned int)_obf_global_opaque_seed ^ _htm_i) % 5 == 2) { \
                    OBF_BOGUS_FLOW_CASCADE(); \
                    if (_htm_i < _htm_outer_loop_count -1 ) _htm_i = OBF_MBA_ADD(_htm_i, 1U); else if (OBF_OPAQUE_PREDICATE_TRUE_1()) break; \
                } \
                if (OBF_OPAQUE_PREDICATE_FALSE_1()) { K8_ASSUME(0); break; }\
                \
                if (((_htm_idx1 + _htm_idx2) % 3) == 0 && OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                    (vm_state_ref).r0 = OBF_MBA_XOR((vm_state_ref).r0, _htm_base_val1); \
                    (vm_state_ref).dispatch_key = OBF_MBA_ADD((vm_state_ref).dispatch_key, _htm_base_val2 ^ (unsigned int)_obf_global_opaque_seed); \
                } \
            } \
            OBF_CALL_ANY_LOCAL_JUNK(); \
        } while (0)

    #define _main(main_body) \
        int main(int argc = 0, char** argv = nullptr) { \
            OBF_BOGUS_FLOW_CYCLONE();\
            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { OBF_BOGUS_FLOW_LABYRINTH(); }\
            OBF_BOGUS_FLOW_SCRAMBLE();\
            volatile unsigned int _d_seed = OBF_MBA_ADD((int)std::time(nullptr) ^ argc ^ (int)(__LINE__), _obf_global_opaque_seed ^ __COUNTER__); \
            _obf_global_opaque_seed = _d_seed; \
            OBF_FAKE_PROLOGUE_MANIP(); \
            OBF_STACK_AND_PROLOGUE_JUNK(_prologue_stack_junk_var1, 64 + (OBF_CALL_ANY_LOCAL_JUNK() & 63)); \
            OBF_STACK_AND_PROLOGUE_JUNK(_prologue_stack_junk_var2, 69 + (OBF_CALL_ANY_LOCAL_JUNK() & 68)); \
            OBF_STACK_AND_PROLOGUE_JUNK(_prologue_stack_junk_var3, 34 + (OBF_CALL_ANY_LOCAL_JUNK() & 44)); \
            OBF_STACK_AND_PROLOGUE_JUNK(_prologue_stack_junk_var4, 64 + (OBF_CALL_ANY_LOCAL_JUNK() & 32)); \
            OBF_STACK_AND_PROLOGUE_JUNK(_prologue_stack_junk_var5, 98 + (OBF_CALL_ANY_LOCAL_JUNK() & 99)); \
            obf_vm_engine::VMState vm_s(_obf_global_opaque_seed); \
            constexpr size_t VM_BYTECODE_LEN = 30; \
            std::array<unsigned int, VM_BYTECODE_LEN> _obf_vm_bytecode; \
            vm_s.r0 = (unsigned int)_obf_global_opaque_seed ^ (0xABCDEF01U + __LINE__); \
            vm_s.r1 = (unsigned int)(__TIME__[0] << 8) ^ __COUNTER__ ^ argc; \
            vm_s.r2 = (unsigned int)(argv ? (std::uintptr_t)argv[0] : __LINE__) ^ (0xBADF00DU + (unsigned int)__TIME__[2]); \
            vm_s.dispatch_key = (argc > 0 && argv != nullptr && argv[0] != nullptr) ? \
                                OBF_MBA_ADD((unsigned int)argv[0][0], (unsigned int)((std::string(argv[0]).length() > 1 ? argv[0][1] : (char)__COUNTER__) ^ __COUNTER__)) : \
                                (unsigned int)__COUNTER__; \
            vm_s.dispatch_key = (vm_s.dispatch_key == 0) ? (1u + (unsigned int)__TIME__[3]) : vm_s.dispatch_key; \
            vm_s.pc = ((unsigned int)__TIME__[4] ^ (unsigned int)_obf_global_opaque_seed) % VM_BYTECODE_LEN; \
            OBF_CHAINED_OBF_CALLS(vm_s, argc + 1); \
            volatile int _main_exit_choice = 0; \
            OBF_CONDITIONAL_EXIT(_main_exit_choice, 0, 1); \
            OBF_EXIT_CHOICE_DRIVES_CALL(vm_s, (int)(vm_s.pc % 10), _main_exit_choice, 0); \
            OBF_HEAVY_JUNK_OP(vm_s.r0, vm_s.r1 ^ (unsigned int)__LINE__); \
            obf_vm_engine::_seh_wrapped_vm_register_modification(vm_s, __LINE__ ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
            for(size_t i_bc=0; i_bc < VM_BYTECODE_LEN; ++i_bc) { \
                if ((i_bc % 5) == 0) { OBF_STACK_AND_ACCESS(32, i_bc % 32, (char)(i_bc ^ _obf_global_opaque_seed)); } \
                unsigned int bc_val = ( (i_bc * (17U + (unsigned int)__TIME__[5])) + __COUNTER__ + (unsigned int)_obf_global_opaque_seed ); \
                bc_val = OBF_MBA_XOR(bc_val, (unsigned int)__TIME__[i_bc % 8]); \
                unsigned int encryption_key = OBF_MBA_ADD(0xDEADBEEFU, (i_bc * 0x101U) ^ (unsigned int)__LINE__); \
                _obf_vm_bytecode[i_bc] = OBF_MBA_XOR(bc_val, encryption_key); \
            } \
            HANDLER_TABLE_MUTATE(obf_vm_engine::vm_handler_table, obf_vm_engine::VM_HANDLER_TABLE_SIZE, vm_s);\
            int prologue_loop_iterations = (int)VM_BYTECODE_LEN + (((unsigned int)_obf_global_opaque_seed ^ vm_s.dispatch_key) % 7) + 5; \
            for (int iter_vm = 0; iter_vm < prologue_loop_iterations; ++iter_vm) { \
                NOP(); \
                if ((iter_vm % 3) == 0) { OBF_FAKE_PROLOGUE_MANIP(); } \
                if ((iter_vm % 7) == 2) { \
                     obf_vm_engine::_seh_forced_exception_effect(vm_s); \
                } \
                CALLER();\
                unsigned int current_raw_bytecode = _obf_vm_bytecode[vm_s.pc % VM_BYTECODE_LEN]; \
                unsigned int decryption_key = OBF_MBA_ADD(0xDEADBEEFU, ((vm_s.pc % VM_BYTECODE_LEN) * 0x101U) ^ (unsigned int)__LINE__); \
                unsigned int handler_index = OBF_MBA_XOR(current_raw_bytecode, decryption_key) % obf_vm_engine::VM_HANDLER_TABLE_SIZE; \
                if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                    vm_s.dispatch_key = OBF_MBA_XOR(vm_s.dispatch_key, vm_s.r0 + vm_s.r1 + (unsigned int)iter_vm + (unsigned int)__TIME__[(iter_vm+1)%8]); \
                    vm_s.dispatch_key = OBF_MBA_ADD(vm_s.dispatch_key, (vm_s.dispatch_key << ((iter_vm%3)+1)) | (vm_s.dispatch_key >> (32-((iter_vm%3)+1)))); \
                } else { K8_ASSUME(0); \
                    vm_s.dispatch_key = OBF_MBA_SUB(vm_s.dispatch_key, 0xDEADDEADU); \
                } \
                vm_s.dispatch_key = (vm_s.dispatch_key == 0) ? ((unsigned int)iter_vm + 1u + (unsigned int)__COUNTER__): vm_s.dispatch_key; \
                obf_vm_engine::vm_handler_table[handler_index](vm_s, argc, argv); \
                unsigned int pc_increment = (vm_s.r0 & 0x3U) + 1U; \
                if (OBF_OPAQUE_PREDICATE_TRUE_2(vm_s.r1 ^ vm_s.dispatch_key)) { \
                    vm_s.pc = OBF_MBA_ADD(vm_s.pc, pc_increment); \
                } else { K8_ASSUME(0); \
                    vm_s.pc = OBF_MBA_SUB(vm_s.pc, (vm_s.r2 & 0x1U) + 1U); \
                } \
                vm_s.pc %= VM_BYTECODE_LEN; \
                NOP(); \
                if (iter_vm > 10 && OBF_OPAQUE_PREDICATE_FALSE_2(vm_s.r0 ^ vm_s.r1 ^ vm_s.r2)) { K8_ASSUME(0); break; } \
            } \
            \
            int dsptch_steps = 5 + (((unsigned int)_obf_global_opaque_seed ^ vm_s.pc) % 5);\
            vm_s.pc %= obf_vm_engine::HANDLER_COUNT; \
            obf_vm_engine::dsptch(vm_s, argc, argv, (unsigned int)dsptch_steps); \
            vm_s.pc %= VM_BYTECODE_LEN; \
            \
            volatile unsigned int _obf_direct_cff_seed = OBF_MBA_XOR(vm_s.r0, vm_s.dispatch_key ^ (unsigned int)__LINE__ ^ (unsigned int)__TIME__[6]); \
            int direct_cff_loops = (((_obf_direct_cff_seed + (unsigned int)argc) % 4) + 5); \
            for (int i_dcff = 0; i_dcff < direct_cff_loops; ++i_dcff) { \
                NOP(); \
                if ((i_dcff % 4) == 1) { \
                    obf_vm_engine::_seh_wrapped_vm_register_modification(vm_s, (_obf_direct_cff_seed >> (i_dcff % 24)) ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
                } \
                CALLER();\
                unsigned int dcff_selector_val = (_obf_direct_cff_seed ^ (unsigned int)(i_dcff * (0x1F1F1F1FU + __COUNTER__)) ^ ((unsigned int)_obf_global_opaque_seed << ((i_dcff%2)+2))) % 10; \
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)dcff_selector_val); \
                \
                volatile unsigned int _icff_current_block_salt_dcff = __COUNTER__; \
                volatile unsigned int _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF( \
                    _ObfICFF_BlockId_DCFF::BLOCK_INIT_SELECTOR, \
                    i_dcff, vm_s, _obf_global_opaque_seed, _icff_current_block_salt_dcff \
                ); \
                \
                volatile bool _icff_run_dispatcher_dcff = true; \
                unsigned int _icff_max_jumps_per_iter_dcff = 15 + (OBF_CALL_ANY_LOCAL_JUNK() & 0x0F); \
                unsigned int _icff_jump_counter_dcff = 0; \
                volatile unsigned int _icff_internal_dcff_selector = dcff_selector_val; \
                \
                while (_icff_run_dispatcher_dcff && _icff_jump_counter_dcff < _icff_max_jumps_per_iter_dcff) { \
                    _icff_jump_counter_dcff++; \
                    _ObfICFF_BlockId_DCFF _icff_decoded_block_dcff = OBF_ICFF_DECODE_STATE_DCFF( \
                        _icff_current_block_encoded_dcff, i_dcff, vm_s, _obf_global_opaque_seed, _icff_current_block_salt_dcff \
                    ); \
                    \
                    _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_icff_decoded_block_dcff ^ (int)i_dcff ^ (int)_icff_internal_dcff_selector ^ OBF_CALL_ANY_LOCAL_JUNK()); \
                    unsigned int _icff_next_salt_dcff_val; \
                    \
                    switch (_icff_decoded_block_dcff) { \
                        case _ObfICFF_BlockId_DCFF::BLOCK_INIT_SELECTOR: \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF( \
                                obf_icff_ns_dcff::_obf_icff_map_selector_to_block_id_dcff(_icff_internal_dcff_selector, _obf_global_opaque_seed), \
                                i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_0: \
                            vm_s.r0 = OBF_MBA_ADD(vm_s.r0, (unsigned int)(i_dcff ^ 0x1111U)); vm_s.r1 = OBF_MBA_XOR(vm_s.r1, vm_s.pc); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { K8_ASSUME(0); \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_CASE_3, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_1: \
                            vm_s.dispatch_key = OBF_MBA_MUL_CONST3(OBF_MBA_ADD(vm_s.dispatch_key, (unsigned int)(i_dcff | 3U))); \
                            OBF_CALL_ANY_LOCAL_JUNK(); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_2(vm_s.dispatch_key ^ (unsigned int)i_dcff)) { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_CASE_5, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_CASE_2, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_2: \
                            vm_s.r2 = OBF_MBA_SUB(((vm_s.r2 | (unsigned int)i_dcff) ^ (0xABCU + __LINE__)), 3U); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_FALSE_1()) { K8_ASSUME(0); \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_INIT_SELECTOR, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_3: \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) vm_s.r0 = OBF_MBA_XOR(vm_s.r0, _obf_direct_cff_seed); else { K8_ASSUME(0); vm_s.r0 = OBF_MBA_ADD(vm_s.r0, vm_s.r1); } \
                            _icff_internal_dcff_selector = OBF_MBA_ADD(_icff_internal_dcff_selector,1U) % 10; \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            if(OBF_OPAQUE_PREDICATE_TRUE_2(_icff_internal_dcff_selector)) { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_INIT_SELECTOR, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else {K8_ASSUME(0); \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_4: \
                            _obf_direct_cff_seed = OBF_MBA_ADD(_obf_direct_cff_seed, (vm_s.r0 ^ vm_s.r2)); vm_s.pc = (OBF_MBA_ADD(vm_s.pc, 2U) + 3U) % VM_BYTECODE_LEN; \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_5: \
                            vm_s.r1 = OBF_MBA_NOT(OBF_MBA_XOR(vm_s.r1, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK())); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            if (((unsigned int)_obf_global_opaque_seed ^ (unsigned int)i_dcff) % 3 == 0) { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_CASE_0, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_6: \
                            if (OBF_OPAQUE_PREDICATE_TRUE_2(vm_s.dispatch_key)) vm_s.r0 = OBF_MBA_MUL_CONST_ALT(vm_s.r0, 2); else { K8_ASSUME(0); vm_s.r0 = OBF_MBA_XOR(vm_s.r0, 7U); } \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_7: \
                            vm_s.r2 = (vm_s.r2 << 1) | (vm_s.r2 >> 31); _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)_obf_direct_cff_seed); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            if (!OBF_OPAQUE_PREDICATE_FALSE_2(vm_s.r2)) { \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_CASE_1, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { K8_ASSUME(0); \
                                _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_8: \
                            vm_s.dispatch_key = OBF_MBA_ADD(vm_s.dispatch_key, OBF_MBA_SUB(vm_s.r0, vm_s.r1)); _obf_direct_cff_seed = OBF_MBA_NOT(_obf_direct_cff_seed); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_CASE_9: \
                            vm_s.pc = OBF_MBA_XOR(vm_s.pc, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ _obf_direct_cff_seed) % VM_BYTECODE_LEN; \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_DEFAULT: \
                            NOP(); K8_ASSUME(0); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE: \
                            NOP(); \
                            _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)i_dcff ^ (int)vm_s.pc); \
                            _icff_next_salt_dcff_val = __COUNTER__; \
                            _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP: \
                            _icff_run_dispatcher_dcff = false; \
                            break; \
                        \
                        case _ObfICFF_BlockId_DCFF::BLOCK_DECOY_A: \
                            OBF_CALL_ANY_LOCAL_JUNK(); vm_s.r1 = OBF_MBA_ADD(vm_s.r1, OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)i_dcff); \
                             _icff_next_salt_dcff_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                               _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF( \
                                   (_ObfICFF_BlockId_DCFF)((OBF_CALL_ANY_LOCAL_JUNK() ^ _obf_global_opaque_seed ^ i_dcff) % (unsigned int)_ObfICFF_BlockId_DCFF::COUNT_DCFF), \
                                   i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { \
                               _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_EXIT_ICFF_LOOP, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break;\
                        case _ObfICFF_BlockId_DCFF::BLOCK_DECOY_B: \
                            vm_s.dispatch_key = OBF_MBA_NOT(vm_s.dispatch_key ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)i_dcff);\
                             _icff_next_salt_dcff_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_2(vm_s.r0)) { \
                               _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_CASE_4, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } else { \
                               _icff_current_block_encoded_dcff = OBF_ICFF_ENCODE_STATE_DCFF(_ObfICFF_BlockId_DCFF::BLOCK_COMMON_CONTINUE, i_dcff, vm_s, _obf_global_opaque_seed, _icff_next_salt_dcff_val); \
                            } \
                            _icff_current_block_salt_dcff = _icff_next_salt_dcff_val; \
                            break;\
                        \
                        default: \
                            NOP(); K8_ASSUME(0); \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) obf_vm_engine::_seh_forced_exception_effect(vm_s); \
                            else Runtime(vm_s); \
                            _icff_run_dispatcher_dcff = false; \
                            break; \
                    } \
                } \
                if (_icff_jump_counter_dcff >= _icff_max_jumps_per_iter_dcff && OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                     Runtime(vm_s); \
                } \
                \
                OBF_FAKE_PROLOGUE_MANIP(); \
                OBF_STACK_AND_PROLOGUE_JUNK(_direct_cff_stack_junk_var1_x, 999 + (OBF_CALL_ANY_LOCAL_JUNK() & 91)); \
                OBF_STACK_AND_PROLOGUE_JUNK(_direct_cff_stack_junk_var2_x, 89 + (OBF_CALL_ANY_LOCAL_JUNK() & 81)); \
                CALLER();\
                OBF_STACK_AND_PROLOGUE_JUNK(_direct_cff_stack_junk_var3_x, 34 + (OBF_CALL_ANY_LOCAL_JUNK() & 44)); \
                OBF_STACK_AND_PROLOGUE_JUNK(_direct_cff_stack_junk_var4_x, 55 + (OBF_CALL_ANY_LOCAL_JUNK() & 45)); \
                OBF_STACK_AND_PROLOGUE_JUNK(_direct_cff_stack_junk_var5_x, 100 + (OBF_CALL_ANY_LOCAL_JUNK() & 90)); \
                NOP(); \
            } \
            size_t g_bc; \
            for(g_bc=0; g_bc < VM_BYTECODE_LEN; ++g_bc){\
                    if ((g_bc % 5) == 0){ for(int ggg = 3; ggg <direct_cff_loops; ggg+=5){CALLER();CALLER();CALLER();} } else if(!((g_bc % 5) == 0)){ CALLER(); if(g_bc == 0){CALLER(); g_bc+=(unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK();} } else {CALLER(); g_bc = (OBF_CALL_ANY_LOCAL_JUNK() & 63) + (OBF_CALL_ANY_LOCAL_JUNK() & 68) - (OBF_CALL_ANY_LOCAL_JUNK() & 44) ^ (OBF_CALL_ANY_LOCAL_JUNK() & 32) << (OBF_CALL_ANY_LOCAL_JUNK() & 99);}\
                    CALLER();\
            }\
            OBF_BOGUS_FLOW_CASCADE();\
            Runtime(vm_s);\
            main_body\
            for(g_bc=0; g_bc < VM_BYTECODE_LEN; ++g_bc){ \
                    if ((g_bc % 5) == 0){ for(int ggg = 3; ggg <direct_cff_loops; ggg+=5){OBF_BOGUS_FLOW_GRID();CALLER();CALLER();CALLER();} } else if(!((g_bc % 5) == 0)){ CALLER(); if(g_bc == 0){CALLER(); g_bc+=(unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK();} } else {CALLER(); g_bc = (OBF_CALL_ANY_LOCAL_JUNK() & 63) + (OBF_CALL_ANY_LOCAL_JUNK() & 68) - (OBF_CALL_ANY_LOCAL_JUNK() & 44) ^ (OBF_CALL_ANY_LOCAL_JUNK() & 32) << (OBF_CALL_ANY_LOCAL_JUNK() & 99);}\
                    CALLER();\
            }\
            Runtime(vm_s);\
            OBF_BOGUS_FLOW_WEAVER();\
            volatile unsigned int epi_ = OBF_MBA_XOR(vm_s.r0, vm_s.r1 ^ (unsigned int)std::time(nullptr) ^ (unsigned int)__TIME__[7]); \
            epi_ = OBF_MBA_ADD(epi_, vm_s.r2 ^ vm_s.dispatch_key); \
            OBF_STACK_AND_PROLOGUE_JUNK(_epilogue_stack_junk, 32 + (epi_ & 31)); \
            OBF_HEAVY_JUNK_OP(epi_, (unsigned int)argc + 1u); \
            vm_s.r2 = epi_; \
            obf_vm_engine::_seh_wrapped_vm_register_modification(vm_s, vm_s.r2 ^ 0xBADF00D); \
            epi_ = vm_s.r0; \
            int epilogue_direct_loops = (((unsigned int)_obf_global_opaque_seed ^ (unsigned int)__LINE__) % 5) + 6; \
            for(int i_epd = 0; i_epd < epilogue_direct_loops; ++i_epd) { \
                HANDLER_TABLE_MUTATE(obf_vm_engine::vm_handler_table, obf_vm_engine::VM_HANDLER_TABLE_SIZE, vm_s); \
                NOP(); \
                if ((i_epd % 2) == 0) { OBF_CHAINED_OBF_CALLS(vm_s, i_epd + (OBF_CALL_ANY_LOCAL_JUNK() & 3)); } \
                unsigned int epd_selector_val = (epi_ ^ (unsigned int)_obf_global_opaque_seed ^ (unsigned int)__COUNTER__ ^ (unsigned int)(i_epd * 0x7654321U)) % 8; \
                _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)epd_selector_val ^ (int)epi_); \
                \
                volatile unsigned int _icff_current_block_salt_epd = __COUNTER__; \
                volatile unsigned int _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD( \
                    _ObfICFF_BlockId_EPD::BLOCK_INIT_SELECTOR, \
                    i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_current_block_salt_epd \
                ); \
                \
                volatile bool _icff_run_dispatcher_epd = true; \
                unsigned int _icff_max_jumps_per_iter_epd = 12 + (OBF_CALL_ANY_LOCAL_JUNK() & 0x07); \
                unsigned int _icff_jump_counter_epd = 0; \
                volatile unsigned int _icff_internal_epd_selector = epd_selector_val; \
                \
                while (_icff_run_dispatcher_epd && _icff_jump_counter_epd < _icff_max_jumps_per_iter_epd) { \
                    _icff_jump_counter_epd++; \
                    _ObfICFF_BlockId_EPD _icff_decoded_block_epd = OBF_ICFF_DECODE_STATE_EPD( \
                        _icff_current_block_encoded_epd, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_current_block_salt_epd \
                    ); \
                    \
                    _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)_icff_decoded_block_epd ^ (int)i_epd ^ (int)_icff_internal_epd_selector ^ (int)epi_ ^ OBF_CALL_ANY_LOCAL_JUNK()); \
                    unsigned int _icff_next_salt_epd_val; \
                    \
                    switch (_icff_decoded_block_epd) { \
                        case _ObfICFF_BlockId_EPD::BLOCK_INIT_SELECTOR: \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD( \
                                obf_icff_ns_epd::_obf_icff_map_selector_to_block_id_epd(_icff_internal_epd_selector, _obf_global_opaque_seed), \
                                i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_0: \
                            epi_ = OBF_MBA_ADD(epi_, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)i_epd); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_COMMON_CONTINUE, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { K8_ASSUME(0); \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_4, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_1: \
                            epi_ = OBF_MBA_SUB(epi_, vm_s.pc + (unsigned int)__LINE__); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            if (!OBF_OPAQUE_PREDICATE_TRUE_2(epi_)) { K8_ASSUME(0); \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_3, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_2, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_2: \
                            epi_ = OBF_MBA_XOR(epi_, vm_s.dispatch_key); \
                            if(OBF_OPAQUE_PREDICATE_TRUE_1()) vm_s.r0 = OBF_MBA_XOR(vm_s.r0, epi_); else { K8_ASSUME(0); vm_s.r0 = OBF_MBA_ADD(vm_s.r0, epi_); } \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_COMMON_CONTINUE, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_3: \
                            epi_ = OBF_MBA_NOT(epi_); vm_s.r1 = OBF_MBA_ADD(vm_s.r1, epi_); \
                            _icff_internal_epd_selector = OBF_MBA_ADD(_icff_internal_epd_selector, 2U) % 8; \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_INIT_SELECTOR, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { \
                                 _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_4, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_4: \
                            epi_ = (epi_ << ((i_epd%2)+1)) | (epi_ >> (32-((i_epd%2)+1))); OBF_CALL_ANY_LOCAL_JUNK(); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            if (((unsigned int)_obf_global_opaque_seed ^ (unsigned int)i_epd) % 4 == 0) { \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_0, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_EXIT_ICFF_LOOP, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_5: \
                            vm_s.r2 = OBF_MBA_XOR(vm_s.r2, epi_ + (unsigned int)argc); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_COMMON_CONTINUE, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_6: \
                            vm_s.dispatch_key = OBF_MBA_ADD(vm_s.dispatch_key, epi_ ^ vm_s.pc); _obf_global_opaque_seed = OBF_MBA_XOR(_obf_global_opaque_seed, (int)vm_s.r0); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_EXIT_ICFF_LOOP, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_CASE_7: \
                            epi_ = OBF_MBA_MUL_CONST3(epi_) ^ (unsigned int)OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_2(epi_)) { \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_1, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { K8_ASSUME(0); \
                                _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_COMMON_CONTINUE, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_DEFAULT: \
                            K8_ASSUME(0); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_EXIT_ICFF_LOOP, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_COMMON_CONTINUE: \
                            NOP(); \
                            epi_ = OBF_MBA_ADD(epi_, (unsigned int)i_epd ^ vm_s.dispatch_key); \
                            _icff_next_salt_epd_val = __COUNTER__; \
                            _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_EXIT_ICFF_LOOP, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_EXIT_ICFF_LOOP: \
                            _icff_run_dispatcher_epd = false; \
                            break; \
                        \
                        case _ObfICFF_BlockId_EPD::BLOCK_DECOY_A: \
                             OBF_CALL_ANY_LOCAL_JUNK(); epi_ = OBF_MBA_XOR(epi_, (unsigned int)i_epd + (unsigned int)OBF_CALL_ANY_LOCAL_JUNK()); \
                             _icff_next_salt_epd_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                               _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD( \
                                   (_ObfICFF_BlockId_EPD)((OBF_CALL_ANY_LOCAL_JUNK() ^ _obf_global_opaque_seed ^ i_epd ^ epi_) % (unsigned int)_ObfICFF_BlockId_EPD::COUNT_EPD), \
                                   i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { \
                               _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_EXIT_ICFF_LOOP, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break;\
                        case _ObfICFF_BlockId_EPD::BLOCK_DECOY_B: \
                             vm_s.r2 = OBF_MBA_XOR(vm_s.r2, (unsigned int)OBF_CALL_ANY_LOCAL_JUNK() ^ (unsigned int)i_epd ^ epi_); \
                             _icff_next_salt_epd_val = __COUNTER__; \
                            if (OBF_OPAQUE_PREDICATE_FALSE_1()) { \
                                K8_ASSUME(0); \
                               _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_CASE_0, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } else { \
                               _icff_current_block_encoded_epd = OBF_ICFF_ENCODE_STATE_EPD(_ObfICFF_BlockId_EPD::BLOCK_COMMON_CONTINUE, i_epd, epi_, vm_s, _obf_global_opaque_seed, _icff_next_salt_epd_val); \
                            } \
                            _icff_current_block_salt_epd = _icff_next_salt_epd_val; \
                            break;\
                        \
                        default: \
                            NOP(); K8_ASSUME(0); \
                            if (OBF_OPAQUE_PREDICATE_TRUE_2(epi_)) obf_vm_engine::_seh_forced_exception_effect(vm_s); \
                            else Runtime(vm_s); \
                            _icff_run_dispatcher_epd = false; \
                            break; \
                    } \
                } \
                if (_icff_jump_counter_epd >= _icff_max_jumps_per_iter_epd && OBF_OPAQUE_PREDICATE_TRUE_1()) { \
                     Runtime(vm_s); \
                } \
                CALLER();\
                _obf_global_opaque_seed = OBF_MBA_ADD(_obf_global_opaque_seed, (int)(epi_ ^ (unsigned int)i_epd ^ vm_s.dispatch_key)); \
            } \
            unsigned int ret_val_temp; \
            OBF_PREPARE_OBF_RETURN(OBF_MBA_XOR(vm_s.r0, vm_s.r1), ret_val_temp); \
            unsigned int ret = ret_val_temp; \
            ret = OBF_MBA_ADD(ret, vm_s.r2 ^ vm_s.dispatch_key); \
            ret = OBF_MBA_SUB(ret, vm_s.pc + (unsigned int)_obf_global_opaque_seed); \
            ret = OBF_MBA_XOR(ret, epi_ ^ (unsigned int)__COUNTER__); \
            if (((ret ^ (unsigned int)__LINE__) & 0xFFFFU) == ((0xBADC0DEU + (unsigned int)__TIME__[0]) & 0xFFFFU)) { \
                 OBF_FAKE_PROLOGUE_MANIP();\
                 CALLER(); \
            } \
            volatile int _d_ = OBF_MBA_XOR(_obf_global_opaque_seed, (int)__LINE__ ^ (int)std::time(nullptr)); \
            Runtime(vm_s); OBF_CALL_ANY_LOCAL_JUNK(); NOP(); \
            return (int)(ret & 0xFF) ^ (int)((_d_ & 0xDEADC0DE) ^ (unsigned int)__LINE__); \
        }

// --------------------------------------
#pragma endregion MAIN_FLATTENING
```

`Obfusk8/Resolve8.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstdio>
#include <windows.h>
#include <winnt.h>

#pragma region DEF
// --------------------------------------

    typedef struct _UNICODE_STRING 
    {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING;

    typedef struct _LDR_DATA_TABLE_ENTRY 
    {
        LIST_ENTRY InLoadOrderLinks;
        LIST_ENTRY InMemoryOrderLinks;
        LIST_ENTRY InInitializationOrderLinks;
        PVOID      DllBase;
        PVOID      EntryPoint;
        ULONG      SizeOfImage;
        UNICODE_STRING FullDllName;
        UNICODE_STRING BaseDllName;
    } LDR_DATA_TABLE_ENTRY;

    typedef struct _PEB_LDR_DATA 
    {
        ULONG Length;
        BOOLEAN Initialized;
        PVOID SsHandle;
        LIST_ENTRY InLoadOrderModuleList;
        LIST_ENTRY InMemoryOrderModuleList;
        LIST_ENTRY InInitializationOrderModuleList;
    } PEB_LDR_DATA;

    typedef struct _PEB 
    {
        BYTE Reserved1[2];
        BYTE BeingDebugged;
        BYTE Reserved2[1];
        PVOID Reserved3[2];
        PEB_LDR_DATA* Ldr;
    } PEB;

    #if defined(_WIN64)
        typedef struct _TEB_PARTIAL 
        {
            BYTE Reserved1[0x60];
            PEB* ProcessEnvironmentBlock;
        } TEB_PARTIAL;
    #else
        typedef struct _TEB_PARTIAL 
        {
            BYTE Reserved1[0x30];
            PEB* ProcessEnvironmentBlock;
        } TEB_PARTIAL;
    #endif


    inline uint32_t _CT_HASH(const char* s) 
    {
        uint32_t v = 0x811c9dc5;
        while (*s) v = (v ^ uint8_t(*s++)) * 0x01000193;
        return v;
    }

    #define CT_HASH(str) (_CT_HASH(str))

    inline PEB* g_PEP() {
        TEB_PARTIAL* pTeb;
    #if defined(_WIN64)

        pTeb = reinterpret_cast<TEB_PARTIAL*>(__readgsqword(0x30));
        if (!pTeb) return nullptr;
        return pTeb->ProcessEnvironmentBlock;
    #elif defined(_WIN32)
        pTeb = reinterpret_cast<TEB_PARTIAL*>(__readfsdword(0x18));
        if (!pTeb) return nullptr;
        return pTeb->ProcessEnvironmentBlock;
    #else
    #error "Unsupported architecture for g_PEP TEB trick"
        return nullptr;
    #endif
    }

// --------------------------------------
#pragma endregion DEF

inline HMODULE find_module_base(uint32_t modhash) {
    PEB* peb = g_PEP();
    if (!peb || !peb->Ldr) return nullptr;
    LIST_ENTRY* head = &peb->Ldr->InMemoryOrderModuleList;
    for (LIST_ENTRY* curr = head->Flink; curr != head; curr = curr->Flink) {
        LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(curr, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
        UNICODE_STRING* us = &entry->BaseDllName;
        char nameA[64]{};
        int i = 0;
        int num_wchars = (us->Length / sizeof(wchar_t));
        for (; i < num_wchars && i < (sizeof(nameA) - 1); ++i) {
            wchar_t c = us->Buffer[i];
            nameA[i] = (char)((c >= L'A' && c <= L'Z') ? (c | 0x20) : c);
        }
        nameA[i] = 0;
        if (CT_HASH(nameA) == modhash) return (HMODULE)entry->DllBase;
    }
    return nullptr;
}

inline void* find_export_byhash(HMODULE hmod, uint32_t funchash) {
    if (!hmod) return nullptr;
    uint8_t* base = (uint8_t*)hmod;
    IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)base;
    if(dos->e_magic != IMAGE_DOS_SIGNATURE) return nullptr;

    IMAGE_NT_HEADERS* nt = (IMAGE_NT_HEADERS*)(base + dos->e_lfanew);
    if(nt->Signature != IMAGE_NT_SIGNATURE) return nullptr;

    if (nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0) {
        return nullptr;
    }
    IMAGE_EXPORT_DIRECTORY* exp = (IMAGE_EXPORT_DIRECTORY*)(base +
        nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    DWORD* names = (DWORD*)(base + exp->AddressOfNames);
    WORD* ords = (WORD*)(base + exp->AddressOfNameOrdinals);
    DWORD* funcs = (DWORD*)(base + exp->AddressOfFunctions);

    for (DWORD i = 0; i < exp->NumberOfNames; i++) {
        if (names[i] == 0) continue;
        char* name = (char*)(base + names[i]);
        if (CT_HASH(name) == funchash) {
            if (ords[i] >= exp->NumberOfFunctions) continue;
            return (BYTE*)base + funcs[ords[i]];
        }
    }
    return nullptr;
}
```

`Obfusk8/k8_CryptographyAPIs/k8_CryptographyAPIs.hpp`:

```hpp
#pragma once

#include <windows.h>
#include <wincrypt.h>
#include "../Obfusk8Core.hpp"
#include <cstdio>

namespace k8_CryptographyAPIs 
{
    using LoadLibraryA_t            =       HMODULE(WINAPI*)(LPCSTR);
    using GetLastError_t            =       DWORD(WINAPI*)();
    using CryptAcquireContextA_t    =       BOOL(WINAPI*)(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD);
    using CryptReleaseContext_t     =       BOOL(WINAPI*)(HCRYPTPROV, DWORD);
    using CryptCreateHash_t         =       BOOL(WINAPI*)(HCRYPTPROV, ALG_ID, HCRYPTKEY, DWORD, HCRYPTHASH*);
    using CryptHashData_t           =       BOOL(WINAPI*)(HCRYPTHASH, const BYTE*, DWORD, DWORD);
    using CryptDeriveKey_t          =       BOOL(WINAPI*)(HCRYPTPROV, ALG_ID, HCRYPTHASH, DWORD, HCRYPTKEY*);
    using CryptEncrypt_t            =       BOOL(WINAPI*)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE*, DWORD*, DWORD);
    using CryptDecrypt_t            =       BOOL(WINAPI*)(HCRYPTKEY, HCRYPTHASH, BOOL, DWORD, BYTE*, DWORD*);
    using CryptDestroyHash_t        =       BOOL(WINAPI*)(HCRYPTHASH);
    using CryptDestroyKey_t         =       BOOL(WINAPI*)(HCRYPTKEY);
    using CryptGenRandom_t          =       BOOL(WINAPI*)(HCRYPTPROV, DWORD, BYTE*);
    using EncryptFileA_t            =       BOOL(WINAPI*)(LPCSTR lpFileName);
    using CryptSetKeyParam_t        =       BOOL(WINAPI*)(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags);
    using CryptGetHashParam_t       =       BOOL(WINAPI*)(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);
    using DecryptFileA_t            =       BOOL(WINAPI*)(LPCSTR lpFileName, DWORD dwReserved);
    using FlushEfsCache_t           =       VOID(WINAPI*)();
    using GetLogicalDrives_t        =       DWORD(WINAPI*)();
    using GetDriveTypeA_t           =       UINT(WINAPI*)(LPCSTR lpRootPathName);
    using CryptStringToBinaryA_t    =       BOOL(WINAPI*)(LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE *pbBinary, DWORD *pcbBinary, DWORD *pdwSkip, DWORD *pdwFlags);
    using CryptBinaryToStringA_t    =       BOOL(WINAPI*)(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString);
    using EnumSystemLocalesA_t      =       BOOL(WINAPI*)(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags);
    using CryptProtectData_t        =       BOOL(WINAPI*)(DATA_BLOB *pDataIn, LPCWSTR szDataDescr, DATA_BLOB *pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut);

    class CryptographyAPI 
    {
            public:
                LoadLibraryA_t pLoadLibraryA;
                GetLastError_t pGetLastError;
                CryptAcquireContextA_t pCryptAcquireContextA;
                CryptReleaseContext_t pCryptReleaseContext;
                CryptCreateHash_t pCryptCreateHash;
                CryptHashData_t pCryptHashData;
                CryptDeriveKey_t pCryptDeriveKey;
                CryptEncrypt_t pCryptEncrypt;
                CryptDecrypt_t pCryptDecrypt;
                CryptDestroyHash_t pCryptDestroyHash;
                CryptDestroyKey_t pCryptDestroyKey;
                CryptGenRandom_t pCryptGenRandom;
                EncryptFileA_t pEncryptFileA;
                CryptSetKeyParam_t pCryptSetKeyParam;
                CryptGetHashParam_t pCryptGetHashParam;
                DecryptFileA_t pDecryptFileA;
                FlushEfsCache_t pFlushEfsCache;
                GetLogicalDrives_t pGetLogicalDrives;
                GetDriveTypeA_t pGetDriveTypeA;
                CryptStringToBinaryA_t pCryptStringToBinaryA;
                CryptBinaryToStringA_t pCryptBinaryToStringA;
                EnumSystemLocalesA_t pEnumSystemLocalesA;
                CryptProtectData_t pCryptProtectData;

                bool m_initialized;

                CryptographyAPI() :
                    pLoadLibraryA(nullptr),
                    pGetLastError(nullptr),
                    pCryptAcquireContextA(nullptr),
                    pCryptReleaseContext(nullptr),
                    pCryptCreateHash(nullptr),
                    pCryptHashData(nullptr),
                    pCryptDeriveKey(nullptr),
                    pCryptEncrypt(nullptr),
                    pCryptDecrypt(nullptr),
                    pCryptDestroyHash(nullptr),
                    pCryptDestroyKey(nullptr),
                    pCryptGenRandom(nullptr),
                    pEncryptFileA(nullptr),
                    pCryptSetKeyParam(nullptr),
                    pCryptGetHashParam(nullptr),
                    pDecryptFileA(nullptr),
                    pFlushEfsCache(nullptr),
                    pGetLogicalDrives(nullptr),
                    pGetDriveTypeA(nullptr),
                    pCryptStringToBinaryA(nullptr),
                    pCryptBinaryToStringA(nullptr),
                    pEnumSystemLocalesA(nullptr),
                    pCryptProtectData(nullptr),
                    m_initialized(false)
                {
                    resolveAPIs();
                }

                bool IsInitialized() const {
                    return m_initialized;
                }

            private:
                void resolveAPIs() 
                {
                    this->pLoadLibraryA = reinterpret_cast<LoadLibraryA_t>(
                        STEALTH_API_OBFSTR("kernel32.dll", "LoadLibraryA")
                    );
                    
                    this->pGetLastError = reinterpret_cast<GetLastError_t>(
                        STEALTH_API_OBFSTR("kernel32.dll", "GetLastError")
                    );

                    if (!(this->pLoadLibraryA) || !(this->pGetLastError)) {
                        printf("CRITICAL: Failed to resolve LoadLibraryA or GetLastError. Cannot initialize CryptographyAPI.\n");
                        return;
                    }

                    HMODULE hAdvApi32 = this->pLoadLibraryA(OBFUSCATE_STRING("advapi32.dll").c_str());
                    if (!hAdvApi32) {
                        printf("CRITICAL: Failed to load advapi32.dll using resolved pLoadLibraryA. Many crypto functions will be unavailable.\n");

                    }
                    
                    HMODULE hCrypt32 = this->pLoadLibraryA(OBFUSCATE_STRING("crypt32.dll").c_str());
                    if (!hCrypt32) {
                         printf("WARNING: Failed to load crypt32.dll. CryptStringToBinary, CryptBinaryToString, CryptProtectData will be unavailable.\n");
                    }

                    pCryptAcquireContextA       =       reinterpret_cast<CryptAcquireContextA_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptAcquireContextA"));
                    pCryptReleaseContext        =       reinterpret_cast<CryptReleaseContext_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptReleaseContext"));
                    pCryptCreateHash            =       reinterpret_cast<CryptCreateHash_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptCreateHash"));
                    pCryptHashData              =       reinterpret_cast<CryptHashData_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptHashData"));
                    pCryptDeriveKey             =       reinterpret_cast<CryptDeriveKey_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptDeriveKey"));
                    pCryptEncrypt               =       reinterpret_cast<CryptEncrypt_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptEncrypt"));
                    pCryptDecrypt               =       reinterpret_cast<CryptDecrypt_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptDecrypt"));
                    pCryptDestroyHash           =       reinterpret_cast<CryptDestroyHash_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptDestroyHash"));
                    pCryptDestroyKey            =       reinterpret_cast<CryptDestroyKey_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptDestroyKey"));
                    pCryptGenRandom             =       reinterpret_cast<CryptGenRandom_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptGenRandom"));
                    pEncryptFileA               =       reinterpret_cast<EncryptFileA_t>(STEALTH_API_OBFSTR("advapi32.dll", "EncryptFileA"));
                    pCryptSetKeyParam           =       reinterpret_cast<CryptSetKeyParam_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptSetKeyParam"));
                    pCryptGetHashParam          =       reinterpret_cast<CryptGetHashParam_t>(STEALTH_API_OBFSTR("advapi32.dll", "CryptGetHashParam"));
                    pDecryptFileA               =       reinterpret_cast<DecryptFileA_t>(STEALTH_API_OBFSTR("advapi32.dll", "DecryptFileA"));
                    pFlushEfsCache              =       reinterpret_cast<FlushEfsCache_t>(STEALTH_API_OBFSTR("advapi32.dll", "FlushEfsCache"));
                    pGetLogicalDrives           =       reinterpret_cast<GetLogicalDrives_t>(STEALTH_API_OBFSTR("kernel32.dll", "GetLogicalDrives"));
                    pGetDriveTypeA              =       reinterpret_cast<GetDriveTypeA_t>(STEALTH_API_OBFSTR("kernel32.dll", "GetDriveTypeA"));
                    pEnumSystemLocalesA         =       reinterpret_cast<EnumSystemLocalesA_t>(STEALTH_API_OBFSTR("kernel32.dll", "EnumSystemLocalesA"));
                    pCryptStringToBinaryA       =       reinterpret_cast<CryptStringToBinaryA_t>(STEALTH_API_OBFSTR("crypt32.dll", "CryptStringToBinaryA"));
                    pCryptBinaryToStringA       =       reinterpret_cast<CryptBinaryToStringA_t>(STEALTH_API_OBFSTR("crypt32.dll", "CryptBinaryToStringA"));
                    pCryptProtectData           =       reinterpret_cast<CryptProtectData_t>(STEALTH_API_OBFSTR("crypt32.dll", "CryptProtectData"));

                    if (pCryptAcquireContextA && pCryptReleaseContext && pCryptCreateHash &&
                        pCryptHashData && pCryptDeriveKey && pCryptEncrypt && pCryptDecrypt &&
                        pCryptDestroyHash && pCryptDestroyKey && pCryptGenRandom &&
                        pEncryptFileA && pCryptSetKeyParam && pCryptGetHashParam &&
                        pDecryptFileA && pFlushEfsCache && pGetLogicalDrives &&
                        pGetDriveTypeA && pCryptStringToBinaryA && pCryptBinaryToStringA &&
                        pEnumSystemLocalesA && pCryptProtectData) {
                        m_initialized = true;
                        printf("CryptographyAPI initialized successfully (all functions resolved).\n");
                    }
                }
    };
}
```

`Obfusk8/k8_NetworkingAPIs/k8_NetworkingAPIs.hpp`:

```hpp
#pragma once

#include <windows.h>
#include <wininet.h>
#include "../Obfusk8Core.hpp"

namespace k8_NetworkingAPIs
{
    using LoadLibraryA_t                =       HMODULE(WINAPI*)(LPCSTR);
    using GetLastError_t                =       DWORD(WINAPI*)();
    using HttpQueryInfoA_t              =       BOOL(WINAPI*)(HINTERNET, DWORD, LPVOID, LPDWORD, LPDWORD);
    using HttpSendRequestExA_t          =       BOOL(WINAPI*)(HINTERNET, LPINTERNET_BUFFERSA, LPINTERNET_BUFFERSA, DWORD, DWORD_PTR);
    using HttpEndRequestA_t             =       BOOL(WINAPI*)(HINTERNET, LPINTERNET_BUFFERSA, DWORD, DWORD_PTR);
    using HttpOpenRequestA_t            =       HINTERNET(WINAPI*)(HINTERNET, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR*, DWORD, DWORD_PTR);
    using InternetOpenA_t               =       HINTERNET(WINAPI*)(LPCSTR, DWORD, LPCSTR, LPCSTR, DWORD);
    using InternetConnectA_t            =       HINTERNET(WINAPI*)(HINTERNET, LPCSTR, INTERNET_PORT, LPCSTR, LPCSTR, DWORD, DWORD, DWORD_PTR);
    using InternetGetConnectedState_t   =       BOOL(WINAPI*)(LPDWORD, DWORD);
    using InternetSetOptionA_t          =       BOOL(WINAPI*)(HINTERNET, DWORD, LPVOID, DWORD);
    using InternetWriteFile_t           =       BOOL(WINAPI*)(HINTERNET, LPCVOID, DWORD, LPDWORD);
    using InternetCrackUrlA_t           =       BOOL(WINAPI*)(LPCSTR, DWORD, DWORD, LPURL_COMPONENTSA);
    using InternetSetStatusCallbackA_t  =       INTERNET_STATUS_CALLBACK(WINAPI*)(HINTERNET, INTERNET_STATUS_CALLBACK);
    using InternetCloseHandle_t         =       BOOL(WINAPI*)(HINTERNET);
    using InternetOpenUrlA_t            =       HINTERNET(WINAPI*)(HINTERNET, LPCSTR, LPCSTR, DWORD, DWORD, DWORD_PTR);
    using InternetReadFile_t            =       BOOL(WINAPI*)(HINTERNET, LPVOID, DWORD, LPDWORD);
    using InternetReadFileExA_t         =       BOOL(WINAPI*)(HINTERNET, LPINTERNET_BUFFERSA, DWORD, DWORD_PTR);
    using InternetSetCookieA_t          =       BOOL(WINAPI*)(LPCSTR, LPCSTR, LPCSTR);
    using InternetGetCookieA_t          =       BOOL(WINAPI*)(LPCSTR, LPCSTR, LPSTR, LPDWORD);

    class NetworkingAPI
    {
        public:
            LoadLibraryA_t pLoadLibraryA;
            GetLastError_t pGetLastError;

            HttpQueryInfoA_t pHttpQueryInfoA;
            HttpSendRequestExA_t pHttpSendRequestExA;
            HttpEndRequestA_t pHttpEndRequestA;
            HttpOpenRequestA_t pHttpOpenRequestA;
            InternetOpenA_t pInternetOpenA;
            InternetConnectA_t pInternetConnectA;
            InternetGetConnectedState_t pInternetGetConnectedState;
            InternetSetOptionA_t pInternetSetOptionA;
            InternetWriteFile_t pInternetWriteFile;
            InternetCrackUrlA_t pInternetCrackUrlA;
            InternetSetStatusCallbackA_t pInternetSetStatusCallbackA;
            InternetCloseHandle_t pInternetCloseHandle;
            InternetOpenUrlA_t pInternetOpenUrlA;
            InternetReadFile_t pInternetReadFile;
            InternetReadFileExA_t pInternetReadFileExA;
            InternetSetCookieA_t pInternetSetCookieA;
            InternetGetCookieA_t pInternetGetCookieA;

            bool m_initialized;

            NetworkingAPI() :
                pLoadLibraryA(nullptr),
                pGetLastError(nullptr),
                pHttpQueryInfoA(nullptr),
                pHttpSendRequestExA(nullptr),
                pHttpEndRequestA(nullptr),
                pHttpOpenRequestA(nullptr),
                pInternetOpenA(nullptr),
                pInternetConnectA(nullptr),
                pInternetGetConnectedState(nullptr),
                pInternetSetOptionA(nullptr),
                pInternetWriteFile(nullptr),
                pInternetCrackUrlA(nullptr),
                pInternetSetStatusCallbackA(nullptr),
                pInternetCloseHandle(nullptr),
                pInternetOpenUrlA(nullptr),
                pInternetReadFile(nullptr),
                pInternetReadFileExA(nullptr),
                pInternetSetCookieA(nullptr),
                pInternetGetCookieA(nullptr),
                m_initialized(false)
            {
                resolveAPIs();
            }

            bool IsInitialized() const {
                return m_initialized;
            }

        private:
            void resolveAPIs()
            {
                pLoadLibraryA = reinterpret_cast<LoadLibraryA_t>(
                    STEALTH_API_OBFSTR("kernel32.dll", "LoadLibraryA")
                );

                if (!pLoadLibraryA) {
                    return;
                }

                pGetLastError = reinterpret_cast<GetLastError_t>(
                    STEALTH_API_OBFSTR("kernel32.dll", "GetLastError")
                );

                HMODULE hWinINet = pLoadLibraryA(OBFUSCATE_STRING("wininet.dll").c_str());
                if (!hWinINet) {
                    return;
                }

                pHttpQueryInfoA             =       reinterpret_cast<HttpQueryInfoA_t>(STEALTH_API_OBFSTR("wininet.dll", "HttpQueryInfoA"));
                pHttpSendRequestExA         =       reinterpret_cast<HttpSendRequestExA_t>(STEALTH_API_OBFSTR("wininet.dll", "HttpSendRequestExA"));
                pHttpEndRequestA            =       reinterpret_cast<HttpEndRequestA_t>(STEALTH_API_OBFSTR("wininet.dll", "HttpEndRequestA"));
                pHttpOpenRequestA           =       reinterpret_cast<HttpOpenRequestA_t>(STEALTH_API_OBFSTR("wininet.dll", "HttpOpenRequestA"));
                pInternetOpenA              =       reinterpret_cast<InternetOpenA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetOpenA"));
                pInternetConnectA           =       reinterpret_cast<InternetConnectA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetConnectA"));
                pInternetGetConnectedState  =       reinterpret_cast<InternetGetConnectedState_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetGetConnectedState"));
                pInternetSetOptionA         =       reinterpret_cast<InternetSetOptionA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetSetOptionA"));
                pInternetWriteFile          =       reinterpret_cast<InternetWriteFile_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetWriteFile"));
                pInternetCrackUrlA          =       reinterpret_cast<InternetCrackUrlA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetCrackUrlA"));
                pInternetSetStatusCallbackA =       reinterpret_cast<InternetSetStatusCallbackA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetSetStatusCallbackA"));
                pInternetCloseHandle        =       reinterpret_cast<InternetCloseHandle_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetCloseHandle"));
                pInternetOpenUrlA           =       reinterpret_cast<InternetOpenUrlA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetOpenUrlA"));
                pInternetReadFile           =       reinterpret_cast<InternetReadFile_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetReadFile"));
                pInternetReadFileExA        =       reinterpret_cast<InternetReadFileExA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetReadFileExA"));
                pInternetSetCookieA         =       reinterpret_cast<InternetSetCookieA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetSetCookieA"));
                pInternetGetCookieA         =       reinterpret_cast<InternetGetCookieA_t>(STEALTH_API_OBFSTR("wininet.dll", "InternetGetCookieA"));

                if (pHttpQueryInfoA && pHttpSendRequestExA && pHttpEndRequestA && pHttpOpenRequestA &&
                    pInternetOpenA && pInternetConnectA && pInternetGetConnectedState &&
                    pInternetSetOptionA && pInternetWriteFile && pInternetCrackUrlA &&
                    pInternetSetStatusCallbackA && pInternetCloseHandle &&
                    pInternetOpenUrlA && pInternetReadFile && pInternetReadFileExA &&
                    pInternetSetCookieA && pInternetGetCookieA)
                {
                    m_initialized = true;
                    printf("NetworkingAPIs initialized successfully (all functions resolved).\n");
                }
            }
    };
}
```

`Obfusk8/k8_ProcessManipulationAPIs/k8_ProcessManipulationAPIs.hpp`:

```hpp
/*
CreateFileMappingA
CreateProcessA
CreateRemoteThread
CreateRemoteThreadEx
GetModuleHandleA
GetProcAddress
GetThreadContext
HeapCreate
LoadLibraryA
LoadLibraryExA
LocalAlloc
MapViewOfFile
MapViewOfFile2
MapViewOfFile3
MapViewOfFileEx
OpenThread
Process32First
Process32Next
QueueUserAPC
ReadProcessMemory
ResumeThread
SetProcessDEPPolicy
SetThreadContext
SuspendThread
Thread32First
Thread32Next
Toolhelp32ReadProcessMemory
VirtualAlloc
VirtualAllocEx
VirtualProtect
VirtualProtectEx
WriteProcessMemory
VirtualAllocExNuma
VirtualAlloc2
VirtualAlloc2FromApp
VirtualAllocFromApp
VirtualProtectFromApp
CreateThread
WaitForSingleObject
OpenProcess
OpenFileMappingA
GetProcessHeap
GetProcessHeaps
HeapAlloc
HeapReAlloc
GlobalAlloc
AdjustTokenPrivileges
CreateProcessAsUserA
OpenProcessToken
CreateProcessWithTokenW
NtAdjustPrivilegesToken
NtAllocateVirtualMemory
NtContinue
NtCreateProcess
NtCreateProcessEx
NtCreateSection
NtCreateThread
NtCreateThreadEx
NtCreateUserProcess
NtDuplicateObject
NtMapViewOfSection
NtOpenProcess
NtOpenThread
NtProtectVirtualMemory
NtQueueApcThread
NtQueueApcThreadEx
NtQueueApcThreadEx2
NtReadVirtualMemory
NtResumeThread
NtUnmapViewOfSection
NtWaitForMultipleObjects
NtWaitForSingleObject
NtWriteVirtualMemory
RtlCreateHeap
LdrLoadDll
RtlMoveMemory
RtlCopyMemory
SetPropA
WaitForSingleObjectEx
WaitForMultipleObjects
WaitForMultipleObjectsEx
KeInsertQueueApc
Wow64SetThreadContext
NtSuspendProcess
NtResumeProcess
DuplicateToken
NtReadVirtualMemoryEx
CreateProcessInternal
EnumSystemLocalesA
UuidFromStringA
DebugActiveProcessStop
*/


#pragma once

#include <windows.h>
#include <tlhelp32.h>
#include <cstdio>
#include <string>

#include "../Obfusk8Core.hpp"

// i got this from : https://ntdoc.m417z.com/processinfoclass
typedef enum _PROCESSINFOCLASS
{
    ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters, // q: IO_COUNTERS
    ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes, // q: KERNEL_USER_TIMES
    ProcessBasePriority, // s: KPRIORITY
    ProcessRaisePriority, // s: ULONG
    ProcessDebugPort, // q: HANDLE
    ProcessExceptionPort, // s: PROCESS_EXCEPTION_PORT (requires SeTcbPrivilege)
    ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize, // s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode, // qs: ULONG
    ProcessIoPortHandlers, // s: PROCESS_IO_PORT_HANDLER_INFORMATION // (kernel-mode only)
    ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL, // qs: ULONG (requires SeTcbPrivilege)
    ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
    ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information, // qs: ULONG (requires SeTcbPrivilege) (VdmAllowed)
    ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask, // (q >WIN7)s: KAFFINITY, qs: GROUP_AFFINITY
    ProcessPriorityBoost, // qs: ULONG
    ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information, // q: ULONG_PTR
    ProcessImageFileName, // q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled, // q: ULONG
    ProcessBreakOnTermination, // qs: ULONG
    ProcessDebugObjectHandle, // q: HANDLE // 30
    ProcessDebugFlags, // qs: ULONG
    ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: PROCESS_HANDLE_TRACING_ENABLE[_EX] or void to disable
    ProcessIoPriority, // qs: IO_PRIORITY_HINT
    ProcessExecuteFlags, // qs: ULONG (MEM_EXECUTE_OPTION_*)
    ProcessTlsInformation, // PROCESS_TLS_INFORMATION // ProcessResourceManagement
    ProcessCookie, // q: ULONG
    ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority, // qs: PAGE_PRIORITY_INFORMATION
    ProcessInstrumentationCallback, // s: PVOID or PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION // 40
    ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]; s: void
    ProcessImageFileNameWin32, // q: UNICODE_STRING
    ProcessImageFileMapping, // q: HANDLE (input)
    ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation, // q: USHORT[]
    ProcessTokenVirtualizationEnabled, // s: ULONG
    ProcessConsoleHostProcess, // qs: ULONG_PTR // ProcessOwnerInformation
    ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation, // s: PROCESS_DYNAMIC_FUNCTION_TABLE_INFORMATION
    ProcessHandleCheckingMode, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
    ProcessHandleTable, // q: ULONG[] // since WINBLUE
    ProcessCheckStackExtentsMode, // qs: ULONG // KPROCESS->CheckStackExtents (CFG)
    ProcessCommandLineInformation, // q: UNICODE_STRING // 60
    ProcessProtectionInformation, // q: PS_PROTECTION
    ProcessMemoryExhaustion, // s: PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation, // s: PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation, // q: PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation, // qs: PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation, // qs: SYSTEM_CPU_SET_INFORMATION[5]
    ProcessAllowedCpuSetsInformation, // qs: SYSTEM_CPU_SET_INFORMATION[5]
    ProcessSubsystemProcess, // s: void // EPROCESS->SubsystemProcess
    ProcessJobMemoryInformation, // q: PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate, // q: BOOLEAN; s: void // ETW // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose, // qs: ULONG; s: 0 disables, otherwise enables
    ProcessIumChallengeResponse,
    ProcessChildProcessInformation, // q: PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation, // qs: BOOLEAN (requires SeTcbPrivilege)
    ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues, // q: PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessPowerThrottlingState, // qs: POWER_THROTTLING_PROCESS_STATE
    ProcessReserved3Information, // ProcessActivityThrottlePolicy // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation, // q: WIN32K_SYSCALL_FILTER
    ProcessDisableSystemAllowedCpuSets, // s: BOOLEAN // 80
    ProcessWakeInformation, // q: PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState, // qs: PROCESS_ENERGY_TRACKING_STATE
    ProcessManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
    ProcessCaptureTrustletLiveDump, // q: ULONG
    ProcessTelemetryCoverage, // q: TELEMETRY_COVERAGE_HEADER; s: TELEMETRY_COVERAGE_POINT
    ProcessEnclaveInformation,
    ProcessEnableReadWriteVmLogging, // qs: PROCESS_READWRITEVM_LOGGING_INFORMATION
    ProcessUptimeInformation, // q: PROCESS_UPTIME_INFORMATION
    ProcessImageSection, // q: HANDLE
    ProcessDebugAuthInformation, // s: CiTool.exe --device-id // PplDebugAuthorization // since RS4 // 90
    ProcessSystemResourceManagement, // s: PROCESS_SYSTEM_RESOURCE_MANAGEMENT
    ProcessSequenceNumber, // q: ULONGLONG
    ProcessLoaderDetour, // since RS5
    ProcessSecurityDomainInformation, // q: PROCESS_SECURITY_DOMAIN_INFORMATION
    ProcessCombineSecurityDomainsInformation, // s: PROCESS_COMBINE_SECURITY_DOMAINS_INFORMATION
    ProcessEnableLogging, // qs: PROCESS_LOGGING_INFORMATION
    ProcessLeapSecondInformation, // qs: PROCESS_LEAP_SECOND_INFORMATION
    ProcessFiberShadowStackAllocation, // s: PROCESS_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION // since 19H1
    ProcessFreeFiberShadowStackAllocation, // s: PROCESS_FREE_FIBER_SHADOW_STACK_ALLOCATION_INFORMATION
    ProcessAltSystemCallInformation, // s: PROCESS_SYSCALL_PROVIDER_INFORMATION // since 20H1 // 100
    ProcessDynamicEHContinuationTargets, // s: PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
    ProcessDynamicEnforcedCetCompatibleRanges, // s: PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE_INFORMATION // since 20H2
    ProcessCreateStateChange, // since WIN11
    ProcessApplyStateChange,
    ProcessEnableOptionalXStateFeatures, // s: ULONG64 // optional XState feature bitmask
    ProcessAltPrefetchParam, // qs: OVERRIDE_PREFETCH_PARAMETER // App Launch Prefetch (ALPF) // since 22H1
    ProcessAssignCpuPartitions, // HANDLE
    ProcessPriorityClassEx, // s: PROCESS_PRIORITY_CLASS_EX
    ProcessMembershipInformation, // q: PROCESS_MEMBERSHIP_INFORMATION
    ProcessEffectiveIoPriority, // q: IO_PRIORITY_HINT // 110
    ProcessEffectivePagePriority, // q: ULONG
    ProcessSchedulerSharedData, // SCHEDULER_SHARED_DATA_SLOT_INFORMATION // since 24H2
    ProcessSlistRollbackInformation,
    ProcessNetworkIoCounters, // q: PROCESS_NETWORK_COUNTERS
    ProcessFindFirstThreadByTebValue, // PROCESS_TEB_VALUE_INFORMATION
    ProcessEnclaveAddressSpaceRestriction, // since 25H2
    ProcessAvailableCpus, // PROCESS_AVAILABLE_CPUS_INFORMATION
    MaxProcessInfoClass
} PROCESSINFOCLASS;

namespace K8_ProcessManipulationAPIs
{
    using OpenProcess_t                 =   HANDLE(WINAPI*)(DWORD, BOOL, DWORD);
    using TerminateProcess_t            =       BOOL(WINAPI*)(HANDLE, UINT);
    using CreateRemoteThread_t          =       HANDLE(WINAPI*)(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
    using VirtualAllocEx_t              =       LPVOID(WINAPI*)(HANDLE, LPVOID, SIZE_T, DWORD, DWORD);
    using WriteProcessMemory_t          =       BOOL(WINAPI*)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
    using ReadProcessMemory_t           =       BOOL(WINAPI*)(HANDLE, LPCVOID, LPVOID, SIZE_T, SIZE_T*);
    using GetProcAddress_t              =       FARPROC(WINAPI*)(HMODULE, LPCSTR);
    using GetModuleHandleA_t            =       HMODULE(WINAPI*)(LPCSTR);
    using NtQueryInformationProcess_t   =       NTSTATUS(WINAPI*)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
    using SuspendThread_t               =       DWORD(WINAPI*)(HANDLE);
    using GetCurrentProcessId_t         =       DWORD(WINAPI*)();

    class ProcessAPI
    {
    public:
        OpenProcess_t pOpenProcess;
        TerminateProcess_t pTerminateProcess;
        CreateRemoteThread_t pCreateRemoteThread;
        VirtualAllocEx_t pVirtualAllocEx;
        WriteProcessMemory_t pWriteProcessMemory;
        ReadProcessMemory_t pReadProcessMemory;
        GetProcAddress_t pGetProcAddress;
        GetModuleHandleA_t pGetModuleHandleA;
        NtQueryInformationProcess_t pNtQueryInformationProcess;
        SuspendThread_t pSuspendThread;
        GetCurrentProcessId_t pGetCurrentProcessId;

        bool m_initialized;

        ProcessAPI() :
            pOpenProcess(nullptr),
            pTerminateProcess(nullptr),
            pCreateRemoteThread(nullptr),
            pVirtualAllocEx(nullptr),
            pWriteProcessMemory(nullptr),
            pReadProcessMemory(nullptr),
            pGetProcAddress(nullptr),
            pGetModuleHandleA(nullptr),
            pNtQueryInformationProcess(nullptr),
            pSuspendThread(nullptr),
            pGetCurrentProcessId(nullptr),
            m_initialized(false)
        {
            resolveAPIs();
        }

        bool IsInitialized() const {
            return m_initialized;
        }

    private:
        void resolveAPIs()
        {
            pOpenProcess                    =       reinterpret_cast<OpenProcess_t>(STEALTH_API_OBFSTR("kernel32.dll", "OpenProcess"));
            pTerminateProcess               =       reinterpret_cast<TerminateProcess_t>(STEALTH_API_OBFSTR("kernel32.dll", "TerminateProcess"));
            pCreateRemoteThread             =       reinterpret_cast<CreateRemoteThread_t>(STEALTH_API_OBFSTR("kernel32.dll", "CreateRemoteThread"));
            pVirtualAllocEx                 =       reinterpret_cast<VirtualAllocEx_t>(STEALTH_API_OBFSTR("kernel32.dll", "VirtualAllocEx"));
            pWriteProcessMemory             =       reinterpret_cast<WriteProcessMemory_t>(STEALTH_API_OBFSTR("kernel32.dll", "WriteProcessMemory"));
            pReadProcessMemory              =       reinterpret_cast<ReadProcessMemory_t>(STEALTH_API_OBFSTR("kernel32.dll", "ReadProcessMemory"));
            pGetProcAddress                 =       reinterpret_cast<GetProcAddress_t>(STEALTH_API_OBFSTR("kernel32.dll", "GetProcAddress"));
            pGetModuleHandleA               =       reinterpret_cast<GetModuleHandleA_t>(STEALTH_API_OBFSTR("kernel32.dll", "GetModuleHandleA"));
            pNtQueryInformationProcess      =       reinterpret_cast<NtQueryInformationProcess_t>(STEALTH_API_OBFSTR("ntdll.dll", "NtQueryInformationProcess"));
            pSuspendThread                  =       reinterpret_cast<SuspendThread_t>(STEALTH_API_OBFSTR("kernel32.dll", "SuspendThread"));
            pGetCurrentProcessId            =       reinterpret_cast<GetCurrentProcessId_t>(STEALTH_API_OBFSTR("kernel32.dll", "GetCurrentProcessId"));

            if (pOpenProcess && pTerminateProcess && pCreateRemoteThread && pVirtualAllocEx &&
                pWriteProcessMemory && pReadProcessMemory && pGetProcAddress &&
                pGetModuleHandleA && pNtQueryInformationProcess && pSuspendThread && pGetCurrentProcessId)
            {
                m_initialized = true;
                printf("ProcessManipulationAPIs Initialized successfully (all functions resolved)..\n");
            }
        }
    };
}

```

`Obfusk8/k8_RegistryAPIs/k8_RegistryAPIs.hpp`:

```hpp
 #pragma once

#include <windows.h>
#include <iostream>
#include "../Obfusk8Core.hpp"
#include <cstdio>

namespace RegistryAPIs 
{
	using LoadLibraryA_t 			= 		HMODULE(WINAPI*)(LPCSTR);
	using GetLastError_t 			= 		DWORD(WINAPI*)();
	using RegSetValueExA_t 			= 		LSTATUS(WINAPI*)(HKEY, LPCSTR, DWORD, DWORD, const BYTE*, DWORD);
	using RegCreateKeyExA_t 		= 		LSTATUS(WINAPI*)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, const LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
	using RegEnumKeyExA_t 			= 		LSTATUS(WINAPI*)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPSTR, LPDWORD, PFILETIME);
	using RegQueryValueExA_t 		= 		LSTATUS(WINAPI*)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
	using RegOpenKeyExA_t 			= 		LSTATUS(WINAPI*)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY);
	using RegCloseKey_t 			= 		LSTATUS(WINAPI*)(HKEY);
	using RegEnumValueA_t 			= 		LSTATUS(WINAPI*)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);

	class 
	RegistryAPI 
	{
		public:
		    LoadLibraryA_t pLoadLibraryA;
		    GetLastError_t pGetLastError;

		    RegSetValueExA_t pRegSetValueExA;
		    RegCreateKeyExA_t pRegCreateKeyExA;
		    RegEnumKeyExA_t pRegEnumKeyExA;
		    RegQueryValueExA_t pRegQueryValueExA;
		    RegOpenKeyExA_t pRegOpenKeyExA;
		    RegCloseKey_t pRegCloseKey;
		    RegEnumValueA_t pRegEnumValueA;

		    bool m_initialized;

		    RegistryAPI() :
		        pLoadLibraryA(nullptr),
		        pGetLastError(nullptr),
		        pRegSetValueExA(nullptr),
		        pRegCreateKeyExA(nullptr),
		        pRegEnumKeyExA(nullptr),
		        pRegQueryValueExA(nullptr),
		        pRegOpenKeyExA(nullptr),
		        pRegCloseKey(nullptr),
		        pRegEnumValueA(nullptr),
		        m_initialized(false)
		    {
		        resolveAPIs();
		    }

		    bool IsInitialized() const {
		        return m_initialized;
		    }

		private:
		    void 
		    resolveAPIs() 
		    {
		        pLoadLibraryA = reinterpret_cast<LoadLibraryA_t>(
		            STEALTH_API_OBFSTR("kernel32.dll", "LoadLibraryA")
		        );

		        pGetLastError = reinterpret_cast<GetLastError_t>(
		            STEALTH_API_OBFSTR("kernel32.dll", "GetLastError")
		        );

		        using namespace std;

		        if (!pLoadLibraryA || !pGetLastError) {
		           	cout << OBFUSCATE_STRING("CRITICAL: Failed to resolve LoadLibraryA or GetLastError. Cannot initialize RegistryAPI.\n");
		            return;
		        }

		        HMODULE hAdvApi32 = pLoadLibraryA(OBFUSCATE_STRING("advapi32.dll").c_str());
		        if (!hAdvApi32) {
		            cout << OBFUSCATE_STRING("CRITICAL: Failed to load advapi32.dll for RegistryAPI. Error: ").c_str() << pGetLastError();
		        }

		        // cout << OBFUSCATE_STRING"advapi32.dll loaded successfully for RegistryAPI, handle:").c_str() << hAdvApi32;

		        pRegSetValueExA 		= 		reinterpret_cast<RegSetValueExA_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegSetValueExA"));
		        pRegCreateKeyExA 		= 		reinterpret_cast<RegCreateKeyExA_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegCreateKeyExA"));
		        pRegEnumKeyExA 			= 		reinterpret_cast<RegEnumKeyExA_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegEnumKeyExA"));
		        pRegQueryValueExA 		= 		reinterpret_cast<RegQueryValueExA_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegQueryValueExA"));
		        pRegOpenKeyExA 			= 		reinterpret_cast<RegOpenKeyExA_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegOpenKeyExA"));
		        pRegCloseKey 			= 		reinterpret_cast<RegCloseKey_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegCloseKey"));
		        pRegEnumValueA 			= 		reinterpret_cast<RegEnumValueA_t>(STEALTH_API_OBFSTR("advapi32.dll", "RegEnumValueA"));

		        if (pRegSetValueExA && pRegCreateKeyExA && pRegEnumKeyExA &&
		            pRegQueryValueExA && pRegOpenKeyExA && pRegCloseKey && pRegEnumValueA) {
		            m_initialized = true;
		            cout << OBFUSCATE_STRING("RegistryAPI initialized successfully (all functions resolved).\n").c_str();
		        }
		    }
	};

}
```

`Obfusk8/main.cpp`:

```cpp
#define STEALTH_API_MAIN

#include "Obfusk8Core.hpp"
#include <cstdio>
#include <iostream>

using namespace std;

void
REG_CALLE(RegistryAPI* _RegistryAPI)
{
        HKEY            hKey;
        DWORD           dwDisposition;
        char            readBuffer[256];
        DWORD           bufferSize          = sizeof(readBuffer);
        DWORD           type = 0;

        LSTATUS status = _RegistryAPI->pRegCreateKeyExA(
            HKEY_CURRENT_USER,
            "Software\\Obfusk8",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition
        );

        const char* valueData = "_Obfusk8";
        status = _RegistryAPI->pRegSetValueExA(
            hKey,
            "Obfusk8",
            0,
            REG_SZ,
            reinterpret_cast<const BYTE*>(valueData),
            strlen(valueData) + 1
        );

        status = _RegistryAPI->pRegQueryValueExA(
            hKey,
            "Obfusk8",
            NULL,
            &type,
            reinterpret_cast<LPBYTE>(readBuffer),
            &bufferSize
        );

        _RegistryAPI->pRegCloseKey(hKey);
}


bool _check = false; 

HANDLE 
check(NetworkingAPI* _NetworkingAPI){
    HANDLE _handle = _NetworkingAPI->pInternetOpenA(
                                    OBFUSCATE_STRING("StealthClient/1.0").c_str(),
                                    INTERNET_OPEN_TYPE_DIRECT,
                                    NULL, NULL, 0
                                    );
    if (!_handle) {
         _check = false;
    }

    _check = true;
    return _handle;
}


void 
Net_CALLE(NetworkingAPI* _NetworkingAPI)
{
        HANDLE _handle = check(_NetworkingAPI);
        if((_check) && !(_handle)) {
            if((_NetworkingAPI->pInternetConnectA(
                                    _handle,
                                    OBFUSCATE_STRING("198.28.28.1").c_str(),
                                    INTERNET_DEFAULT_HTTP_PORT,
                                    NULL, NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0, 0
                                    ))){
            }
        }

}

void 
Cryp_CALLE(CryptographyAPI* _CryptographyAPI)
{
        HCRYPTPROV hProv = 0;
        HCRYPTHASH hHash = 0;
        HCRYPTKEY hKey = 0;

        if (!_CryptographyAPI->pCryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
            if (_CryptographyAPI->pGetLastError && _CryptographyAPI->pGetLastError() == NTE_BAD_KEYSET) {
                 cout << OBFUSCATE_STRING("NTE_BAD_KEYSET, trying to create a new keyset (for testing only).\n").c_str();
                 if (!_CryptographyAPI->pCryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_NEWKEYSET))
                 {

                 }
            } else {

            }
        }

        if (!_CryptographyAPI->pCryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash))
        {

        }

        const char* password = OBFUSCATE_STRING("Obfusk8!").c_str();
        if (!_CryptographyAPI->pCryptHashData(hHash, (const BYTE*)password, (DWORD)strlen(password), 0))
        {

        }

        if (!_CryptographyAPI->pCryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &hKey))
        {

        }

        char originalDataStr[] = "Obfusk8 C++17";
        std::vector<BYTE> dataBuffer(originalDataStr, originalDataStr + strlen(originalDataStr) + 1);
        DWORD dataLen = (DWORD)dataBuffer.size();
        DWORD bufferLen = dataLen;

        if (!_CryptographyAPI->pCryptEncrypt(hKey, 0, TRUE, 0, NULL, &bufferLen, 0)) 
        {
        }

        dataBuffer.resize(bufferLen);

        std::vector<BYTE> encryptedBuffer = dataBuffer;
        memcpy(encryptedBuffer.data(), originalDataStr, dataLen);
        DWORD encryptedDataLen = dataLen;

        if (!_CryptographyAPI->pCryptEncrypt(hKey, 0, TRUE, 0, encryptedBuffer.data(), &encryptedDataLen, (DWORD)encryptedBuffer.size()))
        {
        }

        std::vector<BYTE> decryptedBuffer = encryptedBuffer;
        DWORD decryptedDataLen = encryptedDataLen;

        if (!_CryptographyAPI->pCryptDecrypt(hKey, 0, TRUE, 0, decryptedBuffer.data(), &decryptedDataLen)) {

        }

        //cout << OBFUSCATE_STRING("CryptDecrypt: SUCCESS\n").c_str();

        decryptedBuffer.resize(decryptedDataLen);

        //cout << OBFUSCATE_STRING("Decrypted String: ").c_str() << (char*)decryptedBuffer.data() << endl;
}

void
ProcMan_CALLE(ProcessAPI* _ProcessManipulationAPIs)
{

    DWORD pid = _ProcessManipulationAPIs->pGetCurrentProcessId();
    cout << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - INFO] Current Process ID: ").c_str() << pid << endl;

    HANDLE hProcess = _ProcessManipulationAPIs->pOpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) {
        cerr << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - ERROR] OpenProcess failed with error: ").c_str() << GetLastError() << endl;
    }

    cout << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - INFO] Successfully opened current process.").c_str() << endl;

    const SIZE_T allocSize = 1024;
    LPVOID remoteMem = _ProcessManipulationAPIs->pVirtualAllocEx(hProcess, nullptr, allocSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!remoteMem) {
    }

    cout << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - INFO] Memory allocated at address: ").c_str() << remoteMem << std::endl;

    const char* message = OBFUSCATE_STRING("Obfusk8 C++17").c_str();
    SIZE_T bytesWritten = 0;
    if (!_ProcessManipulationAPIs->pWriteProcessMemory(hProcess, remoteMem, message, strlen(message) + 1, &bytesWritten)) {
        std::cerr << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - ERROR] WriteProcessMemory failed with error: ").c_str() << GetLastError() << std::endl;
    }

    cout << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - INFO] Wrote ").c_str() << bytesWritten << OBFUSCATE_STRING(" bytes to allocated memory.").c_str() << endl;

    char buffer[1024] = {0};
    SIZE_T bytesRead = 0;
    if (!_ProcessManipulationAPIs->pReadProcessMemory(hProcess, remoteMem, buffer, sizeof(buffer), &bytesRead)) {
        cerr << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - ERROR] ReadProcessMemory failed with error: ").c_str() << GetLastError() << endl;
    }

    cout << OBFUSCATE_STRING("-> [ProcessManipulationAPIs - INFO] Read ").c_str() << bytesRead << OBFUSCATE_STRING(" bytes from allocated memory: ").c_str() << buffer << endl;
}

void 
CALLEE()
{
        #pragma region USING
        // --------------------------------------

            // ProcessManipulationAPIs
            ProcessAPI* _ProcessManipulationAPIs = new ProcessAPI;
            if(!(_ProcessManipulationAPIs->IsInitialized() == TRUE)){
                std::cout << OBFUSCATE_STRING("something are wrong in ProcessManipulationAPIs!! isn't Initialized...\n").c_str();
                delete _ProcessManipulationAPIs;
            } else {
                ProcMan_CALLE(_ProcessManipulationAPIs);
                delete _ProcessManipulationAPIs;
            }

            // CryptographyAPIs
            CryptographyAPI* _CryptographyAPI =  new CryptographyAPI;
            if(!( _CryptographyAPI->IsInitialized() == TRUE)){
                std::cout << OBFUSCATE_STRING("something are wrong in CryptographyAPI!! isn't Initialized...\n").c_str();
                delete _CryptographyAPI;
            } else {
                Cryp_CALLE(_CryptographyAPI);
                delete _CryptographyAPI;
            }

            // NetworkingAPIs
            NetworkingAPI* _NetworkingAPI = new NetworkingAPI;
            if(!(_NetworkingAPI->IsInitialized() == TRUE)){
                std::cout << OBFUSCATE_STRING("something are wrong in NetworkingAPI!! isn't Initialized...\n").c_str();
                delete _NetworkingAPI;
            } else {
                Net_CALLE(_NetworkingAPI);
                delete _NetworkingAPI;
            }

            // RegistryAPIs
            RegistryAPI* _RegistryAPI = new RegistryAPI;
            if(!(_RegistryAPI->IsInitialized() == TRUE)){
                std::cout << OBFUSCATE_STRING("something are wrong in RegistryAPIs!! isn't Initialized...\n").c_str();
                delete _RegistryAPI;
            } else {
                REG_CALLE(_RegistryAPI);
                delete _RegistryAPI;
            }

        // --------------------------------------
        #pragma endregion USING
}

#ifdef STEALTH_API_MAIN
    _main({
        using LoadLibraryA_t = HMODULE(WINAPI*)(LPCSTR);
        using MsgBoxA_t = int(WINAPI*)(HWND, LPCSTR, LPCSTR, UINT);

        auto pLoadLibraryA = reinterpret_cast<LoadLibraryA_t>(
            STEALTH_API_OBFSTR("kernel32.dll", "LoadLibraryA")
        );

        HMODULE hUser32 = pLoadLibraryA ? pLoadLibraryA(OBFUSCATE_STRING("user32.dll").c_str()) : nullptr;
        auto pMsgBoxA = hUser32 ? reinterpret_cast<MsgBoxA_t>(
            STEALTH_API_OBFSTR("user32.dll", "MessageBoxA")
        ) : nullptr;

        if (pMsgBoxA) {
            pMsgBoxA(nullptr, OBFUSCATE_STRING("Obfusk8 Library Ready to use :3\n").c_str(), OBFUSCATE_STRING("Ready").c_str(), 0);
        }

        CALLEE();
        
        return 0;
    })
#endif


/*

to hide the main use :
    _main({})
        
to Obfuscte ur apis use :
    STEALTH_API_OBFSTR

to Obfuscate STRINGS use :
    OBFUSCATE_STRING
*/





```

`Obfusk8/xtea8.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <array>

#pragma region XTEAstuff
// ------------------------------------------------

    namespace xtea_en8de {
        constexpr void xtea_encipher(uint32_t* v, const uint32_t* key, int num_rounds = 32) {
            uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x9E3779B9;
            for (int i = 0; i < num_rounds; ++i) {
                v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
                sum += delta;
                v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
            }
            v[0] = v0; v[1] = v1;
        }
        constexpr void xtea_decipher(uint32_t* v, const uint32_t* key, int num_rounds = 32) {
            uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3779B9, sum = delta * num_rounds;
            for (int i = 0; i < num_rounds; ++i) {
                v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
                sum -= delta;
                v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
            }
            v[0] = v0; v[1] = v1;
        }
    } 

    using namespace xtea_en8de;

    #define XTEA_MIX(str, line) (uint32_t)(((sizeof(str) ^ ((line) * 0x314159)) ^ (__FILE__[0] * 0x271828)) | 1)
    #define XTEA_KEY0(str, line) (0xA3B1BAC6u ^ XTEA_MIX(str, line))
    #define XTEA_KEY1(str, line) (0x56AA3350u ^ XTEA_MIX(str, line))
    #define XTEA_KEY2(str, line) (0x677D9197u ^ XTEA_MIX(str, line))
    #define XTEA_KEY3(str, line) (0xB27022DCu ^ XTEA_MIX(str, line))

    template <size_t N, uint32_t K0, uint32_t K1, uint32_t K2, uint32_t K3>
    struct _XTEA8ObfStrs {
        static constexpr uint32_t key[4] = { K0, K1, K2, K3 };
        static constexpr std::array<uint32_t, ((N + 7) / 8 * 2)> encrypt(const char (&plain)[N]) {
            std::array<uint32_t, ((N + 7) / 8 * 2)> enc{};
            for (size_t i = 0; i < (N + 7) / 8; ++i) {
                uint32_t v[2] = {0, 0};
                for (size_t j = 0; j < 4 && (i * 8 + j) < N; ++j)
                    v[0] |= static_cast<uint8_t>(plain[i * 8 + j]) << (j * 8);
                for (size_t j = 0; j < 4 && (i * 8 + 4 + j) < N; ++j)
                    v[1] |= static_cast<uint8_t>(plain[i * 8 + 4 + j]) << (j * 8);
                xtea_encipher(v, key);
                enc[i * 2] = v[0];
                enc[i * 2 + 1] = v[1];
            }
            return enc;
        }
    };

    #define CONCAT2(a,b) a##b
    #define CONCAT(a,b) CONCAT2(a,b)

// ------------------------------------------------
#pragma endregion XTEAstuff

#pragma region Chunks
// ------------------------------------------------

    #pragma region MSVC_sections
    // ------------------------------------------------

        #define PACKER_SECTION_4 ".arch"
        #define PACKER_SECTION_6 ".xpdata"
        #define PACKER_SECTION_9 ".PECompac"
        #define PACKER_SECTION_3 ".xtls"
        #define PACKER_SECTION_0 ".themida"
        #define PACKER_SECTION_5 ".vmp0"
        #define PACKER_SECTION_1 ".vmp1"
        #define PACKER_SECTION_7 ".vmp2"
        #define PACKER_SECTION_23 ".vmp3"
        #define PACKER_SECTION_24 ".vmp4"
        #define PACKER_SECTION_25 ".vmp5"
        #define PACKER_SECTION_26 ".vmp6"
        #define PACKER_SECTION_27 ".vmp7"
        #define PACKER_SECTION_28 ".vmp8"
        #define PACKER_SECTION_8 ".enigma1"
        #define PACKER_SECTION_2 ".enigma2"
        #define PACKER_SECTION_10 ".dsstext"
        #define PACKER_SECTION_11 ".UPX0"
        #define PACKER_SECTION_12 ".UPX1"
        #define PACKER_SECTION_13 ".UPX2"
        #define PACKER_SECTION_14 ".aspack"
        #define PACKER_SECTION_15 ".nsp0"
        #define PACKER_SECTION_16 ".nsp1"
        #define PACKER_SECTION_17 ".FSG!"
        #define PACKER_SECTION_18 ".pec1"
        #define PACKER_SECTION_19 ".pec2"
        #define PACKER_SECTION_20 ".petite"
        #define PACKER_SECTION_21 ".mpress1"
        #define PACKER_SECTION_22 ".mpress2"

        //#define PACKER_SECTION_COUNT 29

        #define PICK_SECTION(idx) PACKER_SECTION_##idx

        #if defined(_MSC_VER)
            #pragma section(".arch", read, write)
            #pragma section(".xpdata", read, write)
            #pragma section(".PECompac", read, write)
            #pragma section(".xtls", read, write)
            #pragma section(".themida", read, write)
            #pragma section(".vmp0", read, write)
            #pragma section(".vmp1", read, write)
            #pragma section(".vmp2", read, write)
            #pragma section(".vmp3", read, write)
            #pragma section(".vmp4", read, write)
            #pragma section(".vmp5", read, write)
            #pragma section(".vmp6", read, write)
            #pragma section(".vmp7", read, write)
            #pragma section(".vmp8", read, write)
            #pragma section(".enigma1", read, write)
            #pragma section(".enigma2", read, write)
            #pragma section(".dsstext", read, write)
            #pragma section(".UPX0", read, write)
            #pragma section(".UPX1", read, write)
            #pragma section(".UPX2", read, write)
            #pragma section(".aspack", read, write)
            #pragma section(".nsp0", read, write)
            #pragma section(".nsp1", read, write)
            #pragma section(".FSG!", read, write)
            #pragma section(".pec1", read, write)
            #pragma section(".pec2", read, write)
            #pragma section(".petite", read, write)
            #pragma section(".mpress1", read, write)
            #pragma section(".mpress2", read, write)
        #endif

        #if defined(_MSC_VER)
            #define DECLARE_SECTION(secname) __pragma(section(secname, read, write))
            #define SECTION_ATTR_SEC(secname) __declspec(allocate(secname))
        #endif

        #pragma region g_sigs
        // ------------------------------------------------

            #define SIGNATURE_UPX     0x21585055  // "UPX!"
            #define SIGNATURE_VMP     0x504d565b  // "[VMP"
            #define SIGNATURE_ENIGMA  0x47494e45  // "ENIG"
            #define SIGNATURE_THEMIDA 0x4944454d  // "MEDI"
            #define SIGNATURE_FSG     0x21475346  // "FSG!"
            #define SIGNATURE_ASPACK  0x4b434150  // "PACK"
            #define SIGNATURE_NSPACK  0x4b43414e  // "NACK"
            #define SIGNATURE_MPRESS  0x53534552  // "RESS"

        // ------------------------------------------------
        #pragma endregion g_sigs

    // ------------------------------------------------
    #pragma endregion MSVC_sections


    #define OBFUSCATE_STRING(str) \
        ([]() -> std::string { \
            using _Obf = _XTEA8ObfStrs<sizeof(str), \
                XTEA_KEY0(str, __LINE__), XTEA_KEY1(str, __LINE__), XTEA_KEY2(str, __LINE__), XTEA_KEY3(str, __LINE__)>; \
            constexpr auto encrypted = _Obf::encrypt(str); \
            DECLARE_SECTION(PICK_SECTION(0)) \
            static SECTION_ATTR_SEC(PICK_SECTION(0)) uint32_t CONCAT(_obfstr_chunk0_, __LINE__)[3] = { SIGNATURE_UPX + 0xFFFF,      encrypted[0],  encrypted[1]  }; \
            DECLARE_SECTION(PICK_SECTION(1)) \
            static SECTION_ATTR_SEC(PICK_SECTION(1)) uint32_t CONCAT(_obfstr_chunk1_, __LINE__)[3] = { SIGNATURE_THEMIDA,  encrypted[2],  encrypted[3]  }; \
            DECLARE_SECTION(PICK_SECTION(2)) \
            static SECTION_ATTR_SEC(PICK_SECTION(2)) uint32_t CONCAT(_obfstr_chunk2_, __LINE__)[3] = { SIGNATURE_ENIGMA,   encrypted[4],  encrypted[5]  }; \
            DECLARE_SECTION(PICK_SECTION(3)) \
            static SECTION_ATTR_SEC(PICK_SECTION(3)) uint32_t CONCAT(_obfstr_chunk3_, __LINE__)[3] = { SIGNATURE_VMP,      encrypted[6],  encrypted[7]  }; \
            DECLARE_SECTION(PICK_SECTION(4)) \
            static SECTION_ATTR_SEC(PICK_SECTION(4)) uint32_t CONCAT(_obfstr_chunk4_, __LINE__)[3] = { SIGNATURE_FSG,      encrypted[8],  encrypted[9]  }; \
            DECLARE_SECTION(PICK_SECTION(5)) \
            static SECTION_ATTR_SEC(PICK_SECTION(5)) uint32_t CONCAT(_obfstr_chunk5_, __LINE__)[3] = { SIGNATURE_ASPACK,   encrypted[10], encrypted[11] }; \
            DECLARE_SECTION(PICK_SECTION(6)) \
            static SECTION_ATTR_SEC(PICK_SECTION(6)) uint32_t CONCAT(_obfstr_chunk6_, __LINE__)[3] = { SIGNATURE_NSPACK,   encrypted[12], encrypted[13] }; \
            DECLARE_SECTION(PICK_SECTION(7)) \
            static SECTION_ATTR_SEC(PICK_SECTION(7)) uint32_t CONCAT(_obfstr_chunk7_, __LINE__)[3] = { SIGNATURE_MPRESS,   encrypted[14], encrypted[15] }; \
            DECLARE_SECTION(PICK_SECTION(8)) \
            static SECTION_ATTR_SEC(PICK_SECTION(8)) uint32_t CONCAT(_obfstr_chunk8_, __LINE__)[3] = { SIGNATURE_UPX + 0xFFFF,      encrypted[16], encrypted[17] }; \
            DECLARE_SECTION(PICK_SECTION(9)) \
            static SECTION_ATTR_SEC(PICK_SECTION(9)) uint32_t CONCAT(_obfstr_chunk9_, __LINE__)[3] = { SIGNATURE_THEMIDA,  encrypted[18], encrypted[19] }; \
            DECLARE_SECTION(PICK_SECTION(10)) \
            static SECTION_ATTR_SEC(PICK_SECTION(10)) uint32_t CONCAT(_obfstr_chunk10_, __LINE__)[3] = { SIGNATURE_ENIGMA,  encrypted[20], encrypted[21] }; \
            DECLARE_SECTION(PICK_SECTION(11)) \
            static SECTION_ATTR_SEC(PICK_SECTION(11)) uint32_t CONCAT(_obfstr_chunk11_, __LINE__)[3] = { SIGNATURE_VMP,     encrypted[22], encrypted[23] }; \
            DECLARE_SECTION(PICK_SECTION(12)) \
            static SECTION_ATTR_SEC(PICK_SECTION(12)) uint32_t CONCAT(_obfstr_chunk12_, __LINE__)[3] = { SIGNATURE_FSG,     encrypted[24], encrypted[25] }; \
            DECLARE_SECTION(PICK_SECTION(13)) \
            static SECTION_ATTR_SEC(PICK_SECTION(13)) uint32_t CONCAT(_obfstr_chunk13_, __LINE__)[3] = { SIGNATURE_ASPACK,  encrypted[26], encrypted[27] }; \
            DECLARE_SECTION(PICK_SECTION(14)) \
            static SECTION_ATTR_SEC(PICK_SECTION(14)) uint32_t CONCAT(_obfstr_chunk14_, __LINE__)[3] = { SIGNATURE_NSPACK,  encrypted[28], encrypted[29] }; \
            DECLARE_SECTION(PICK_SECTION(15)) \
            static SECTION_ATTR_SEC(PICK_SECTION(15)) uint32_t CONCAT(_obfstr_chunk15_, __LINE__)[3] = { SIGNATURE_MPRESS,  encrypted[30], encrypted[31] }; \
            DECLARE_SECTION(PICK_SECTION(16)) \
            static SECTION_ATTR_SEC(PICK_SECTION(16)) uint32_t CONCAT(_obfstr_chunk16_, __LINE__)[3] = { SIGNATURE_UPX + 0xFFFF,     encrypted[32], encrypted[33] }; \
            DECLARE_SECTION(PICK_SECTION(17)) \
            static SECTION_ATTR_SEC(PICK_SECTION(17)) uint32_t CONCAT(_obfstr_chunk17_, __LINE__)[3] = { SIGNATURE_THEMIDA, encrypted[34], encrypted[35] }; \
            DECLARE_SECTION(PICK_SECTION(18)) \
            static SECTION_ATTR_SEC(PICK_SECTION(18)) uint32_t CONCAT(_obfstr_chunk18_, __LINE__)[3] = { SIGNATURE_ENIGMA,  encrypted[36], encrypted[37] }; \
            DECLARE_SECTION(PICK_SECTION(19)) \
            static SECTION_ATTR_SEC(PICK_SECTION(19)) uint32_t CONCAT(_obfstr_chunk19_, __LINE__)[3] = { SIGNATURE_VMP,     encrypted[38], encrypted[39] }; \
            DECLARE_SECTION(PICK_SECTION(20)) \
            static SECTION_ATTR_SEC(PICK_SECTION(20)) uint32_t CONCAT(_obfstr_chunk20_, __LINE__)[3] = { SIGNATURE_FSG,     encrypted[40], encrypted[41] }; \
            DECLARE_SECTION(PICK_SECTION(21)) \
            static SECTION_ATTR_SEC(PICK_SECTION(21)) uint32_t CONCAT(_obfstr_chunk21_, __LINE__)[3] = { SIGNATURE_ASPACK,  encrypted[42], encrypted[43] }; \
            DECLARE_SECTION(PICK_SECTION(22)) \
            static SECTION_ATTR_SEC(PICK_SECTION(22)) uint32_t CONCAT(_obfstr_chunk22_, __LINE__)[3] = { SIGNATURE_NSPACK,  encrypted[44], encrypted[45] }; \
            DECLARE_SECTION(PICK_SECTION(23)) \
            static SECTION_ATTR_SEC(PICK_SECTION(23)) uint32_t CONCAT(_obfstr_chunk23_, __LINE__)[3] = { SIGNATURE_MPRESS,  encrypted[46], encrypted[47] }; \
            DECLARE_SECTION(PICK_SECTION(24)) \
            static SECTION_ATTR_SEC(PICK_SECTION(24)) uint32_t CONCAT(_obfstr_chunk24_, __LINE__)[3] = { SIGNATURE_UPX + 0xFFFF,     encrypted[48], encrypted[49] }; \
            DECLARE_SECTION(PICK_SECTION(25)) \
            static SECTION_ATTR_SEC(PICK_SECTION(25)) uint32_t CONCAT(_obfstr_chunk25_, __LINE__)[3] = { SIGNATURE_THEMIDA, encrypted[50], encrypted[51] }; \
            DECLARE_SECTION(PICK_SECTION(26)) \
            static SECTION_ATTR_SEC(PICK_SECTION(26)) uint32_t CONCAT(_obfstr_chunk26_, __LINE__)[3] = { SIGNATURE_ENIGMA,  encrypted[52], encrypted[53] }; \
            DECLARE_SECTION(PICK_SECTION(27)) \
            static SECTION_ATTR_SEC(PICK_SECTION(27)) uint32_t CONCAT(_obfstr_chunk27_, __LINE__)[3] = { SIGNATURE_VMP,     encrypted[54], encrypted[55] }; \
            char out[sizeof(str)]; \
            for (int chunk = 0; chunk < 28; ++chunk) { \
                uint32_t* chunk_ptr; \
                switch(chunk) { \
                    case 0: chunk_ptr = CONCAT(_obfstr_chunk0_, __LINE__); break; \
                    case 1: chunk_ptr = CONCAT(_obfstr_chunk1_, __LINE__); break; \
                    case 2: chunk_ptr = CONCAT(_obfstr_chunk2_, __LINE__); break; \
                    case 3: chunk_ptr = CONCAT(_obfstr_chunk3_, __LINE__); break; \
                    case 4: chunk_ptr = CONCAT(_obfstr_chunk4_, __LINE__); break; \
                    case 5: chunk_ptr = CONCAT(_obfstr_chunk5_, __LINE__); break; \
                    case 6: chunk_ptr = CONCAT(_obfstr_chunk6_, __LINE__); break; \
                    case 7: chunk_ptr = CONCAT(_obfstr_chunk7_, __LINE__); break; \
                    case 8: chunk_ptr = CONCAT(_obfstr_chunk8_, __LINE__); break; \
                    case 9: chunk_ptr = CONCAT(_obfstr_chunk9_, __LINE__); break; \
                    case 10: chunk_ptr = CONCAT(_obfstr_chunk10_, __LINE__); break; \
                    case 11: chunk_ptr = CONCAT(_obfstr_chunk11_, __LINE__); break; \
                    case 12: chunk_ptr = CONCAT(_obfstr_chunk12_, __LINE__); break; \
                    case 13: chunk_ptr = CONCAT(_obfstr_chunk13_, __LINE__); break; \
                    case 14: chunk_ptr = CONCAT(_obfstr_chunk14_, __LINE__); break; \
                    case 15: chunk_ptr = CONCAT(_obfstr_chunk15_, __LINE__); break; \
                    case 16: chunk_ptr = CONCAT(_obfstr_chunk16_, __LINE__); break; \
                    case 17: chunk_ptr = CONCAT(_obfstr_chunk17_, __LINE__); break; \
                    case 18: chunk_ptr = CONCAT(_obfstr_chunk18_, __LINE__); break; \
                    case 19: chunk_ptr = CONCAT(_obfstr_chunk19_, __LINE__); break; \
                    case 20: chunk_ptr = CONCAT(_obfstr_chunk20_, __LINE__); break; \
                    case 21: chunk_ptr = CONCAT(_obfstr_chunk21_, __LINE__); break; \
                    case 22: chunk_ptr = CONCAT(_obfstr_chunk22_, __LINE__); break; \
                    case 23: chunk_ptr = CONCAT(_obfstr_chunk23_, __LINE__); break; \
                    case 24: chunk_ptr = CONCAT(_obfstr_chunk24_, __LINE__); break; \
                    case 25: chunk_ptr = CONCAT(_obfstr_chunk25_, __LINE__); break; \
                    case 26: chunk_ptr = CONCAT(_obfstr_chunk26_, __LINE__); break; \
                    case 27: chunk_ptr = CONCAT(_obfstr_chunk27_, __LINE__); break; \
                    default: chunk_ptr = nullptr; \
                } \
                if (!chunk_ptr) break; \
                uint32_t v[2] = { chunk_ptr[1], chunk_ptr[2] }; \
                xtea_decipher(v, _Obf::key); \
                for (size_t j = 0; j < 4 && (chunk * 8 + j) < sizeof(str); ++j) \
                    out[chunk * 8 + j] = static_cast<char>((v[0] >> (j * 8)) & 0xFF); \
                for (size_t j = 0; j < 4 && (chunk * 8 + 4 + j) < sizeof(str); ++j) \
                    out[chunk * 8 + 4 + j] = static_cast<char>((v[1] >> (j * 8)) & 0xFF); \
            } \
            out[sizeof(str) - 1] = 0; \
            std::string s(out, sizeof(str) - 1); \
            return s; \
        })()

// ------------------------------------------------
#pragma endregion Chunks
```

`README.md`:

```md
# Obfusk8: C++17-Based Obfuscation Library

Obfusk8 is a lightweight, header-only C++17 library designed to significantly enhance the obfuscation of your applications, making reverse engineering a substantially more challenging endeavor. It achieves this through a diverse set of compile-time and runtime techniques aimed at protecting your code's logic and data.

   ![banner](https://github.com/user-attachments/assets/09a3c47f-fa56-42f5-b50a-b25d29922de5)


**Core Obfuscation Strategies**

### 1. `main` Function Wrapping (`_main` Macro)
The entry point of your application (`main`) is transformed into a complex, multi-layered obfuscation engine:
*   **Virtual Machine (VM) Execution (Conceptual)**: Before your actual `main_body` code is executed, a mini-VM (simulated CPU) runs a sequence of "encrypted" instructions. This conceals the true entry point and initial operations. The VM's state (registers, program counter, dispatch key) is initialized with runtime-randomized values.
*   **Indirect Control Flow Flattening (ICFF)**: Critical loops within the `_main` macro (both in the prologue and epilogue) are transformed into intricate state machines. Control flow is not direct but determined by heavily "encrypted" state variables. The encoding/decoding keys for these state variables are dynamic, derived from VM state, loop counters, compile-time randomness (like `__COUNTER__`, `__LINE__`, `__TIME__`), and a global opaque seed. This makes static analysis of the control flow exceptionally difficult.
    *   Two distinct ICFF engines (`obf_icff_ns_dcff` and `obf_icff_ns_epd`) are used with different state transition logic and key generation, further complicating analysis.
*   **Bogus Control Flow (`OBF_BOGUS_FLOW_*` macros)**: Numerous misleading jump patterns and convoluted conditional structures are injected throughout `_main`. These use `goto` statements combined with opaque predicates (conditions that always evaluate to true or false but are computationally expensive or hard to determine statically). This creates a labyrinth of false paths for disassemblers and decompilers.
    *   Includes `OBF_BOGUS_FLOW_LABYRINTH`, `OBF_BOGUS_FLOW_GRID`, `OBF_BOGUS_FLOW_SCRAMBLE`, `OBF_BOGUS_FLOW_WEAVER`, `OBF_BOGUS_FLOW_CASCADE`, and `OBF_BOGUS_FLOW_CYCLONE` to generate diverse and complex bogus flows.
*   **Anti-Analysis & Anti-Debug Tricks (`Runtime` macro, SEH)**:
    *   **Forced Exceptions & SEH**: Structured Exception Handling (SEH) is used to create paths that involve forced exceptions. The `__except` blocks can alter program state, making it hard to follow if the debugger skips exceptions.
    *   **Debugger Checks (Conceptual)**: The `Runtime` macro contains conditions that, if met (due to specific VM states or timing), could trigger `__debugbreak()` or throw exceptions, designed to disrupt debugging sessions.

### 2. Virtual ISA Engine (`obf_vm_engine`)
A core component of the `_main` macro's obfuscation:
*   **Custom Mini-CPU Simulation**: Simulates a CPU with volatile registers (`r0`, `r1`, `r2`), a program counter (`pc`), and a `dispatch_key`. It executes custom "instructions" (handlers).
*   **Obfuscated Instructions**: VM instruction handlers perform operations that are heavily disguised using Mixed Boolean-Arithmetic (MBA) and bitwise manipulations. Handlers include arithmetic, bitwise logic, key mangling, junk sequences, conditional updates, memory simulation, and PC mangling.
*   **Dynamic Dispatch**: The selection of the next VM instruction handler is randomized through multiple dispatch mechanisms:
    *   Register-based dispatch (`reg_dispatch_idx`).
    *   Memory-table based dispatch (scrambled function pointer table `get_mem_dispatch_table`).
    *   Mixed dispatch (`mixed_dispatch_idx`).
    The `dispatch_key` is constantly mutated, making the sequence of executed handlers highly unpredictable.
*   **Handler Table Mutation**: The table of VM instruction handlers (`vm_handler_table`) is itself mutated at runtime within the `_main` prologue and epilogue, further obscuring the VM's behavior.

### 3. Compile-Time String Encryption (`OBFUSCATE_STRING` from `xtea8.hpp`)
*   **Hidden Strings**: Encrypts all string literals at compile-time using a modified XTEA cipher.
*   **Dynamic Keys**: Encryption keys are unique per string instance, derived from string content, file location (`__FILE__`, `__LINE__`), and build time (`__DATE__`, `__TIME__`).
*   **Just-In-Time Decryption**: Strings are decrypted on the stack only when accessed at runtime, minimizing their plaintext lifetime in memory.
*   **(Optional) Decoy PE Sections**: Can store encrypted strings in custom PE sections designed to mimic common packer signatures, potentially misleading analysts (MSVC-specific feature from `xtea8.hpp`).

### 4. Stealthy Windows API Calling (`STEALTH_API_OBFSTR` / `STEALTH_API_OBF` from `Resolve8.hpp`)
*   **IAT Obscurity**: Avoids leaving direct, easily identifiable entries for Windows APIs in the Import Address Table (IAT).
*   **PEB-Based Resolution**: Dynamically finds base addresses of loaded DLLs and the addresses of API functions by directly parsing Process Environment Block (PEB) data structures at runtime. This bypasses standard `GetModuleHandle` and `GetProcAddress` for initial resolution if those themselves are not yet resolved by this mechanism.
*   **Hashed Names**: Uses compile-time hashing (custom algorithm `CT_HASH`) of DLL and API names for lookups. This prevents plaintext DLL and API names from appearing in the binary's import-related data or string tables when using these macros.

### 5. API Abstraction Classes with Built-in Stealth
Obfusk8 provides helper classes that encapsulate common sets of Windows APIs. These classes automatically use the stealthy API resolution mechanism (`STEALTH_API_OBFSTR`) during their construction, ensuring that the underlying Windows functions are resolved without leaving obvious static import traces.

   - **`K8_ProcessManipulationAPIs::ProcessAPI` (`k8_ProcessManipulationAPIs.hpp`)**:
     *   Provides convenient access to Windows APIs for process manipulation, such as `OpenProcess`, `TerminateProcess`, `CreateRemoteThread`, `VirtualAllocEx`, `WriteProcessMemory`, `ReadProcessMemory`, `GetProcAddress`, `GetModuleHandleA`, `NtQueryInformationProcess`, `SuspendThread`, and `GetCurrentProcessId`.
     *   **Automatic Stealth Resolution**: Resolves necessary functions from `kernel32.dll` and `ntdll.dll` stealthily.
     *   Simplifies performing process-related operations with a reduced static analysis footprint. Includes the `PROCESSINFOCLASS` enum for use with `NtQueryInformationProcess`.

   - **`k8_CryptographyAPIs::CryptographyAPI` (`k8_CryptographyAPIs.hpp`)**:
     *   Offers wrappers for common Windows Cryptography API (CAPI/CNG) functions. (Functionality depends on the actual implementation of this file - the provided snippet was a duplicate. Assuming typical CAPI functions like `CryptAcquireContextA`, `CryptCreateHash`, etc.)
     *   **Automatic Stealth Resolution**: Resolves necessary functions primarily from `advapi32.dll` (and `kernel32.dll` for core functions) stealthily.
     *   Facilitates cryptographic operations while minimizing the exposure of crypto API usage.

   - **`k8_NetworkingAPIs::NetworkingAPI` (`k8_NetworkingAPIs.hpp`)**:
     *   Provides easy access to a wide range of networking functions from `wininet.dll` (e.g., `InternetOpenA`, `HttpOpenRequestA`, `FtpPutFileA`), `urlmon.dll` (e.g., `URLDownloadToFileA`), `ws2_32.dll` (e.g., `socket`, `connect`, `WSAStartup`), `shell32.dll` (e.g., `ShellExecuteA`), `dnsapi.dll` (e.g., `DnsQuery_A`), and `mpr.dll` (e.g., `WNetOpenEnumA`).
     *   **Automatic Stealth Resolution**: In its constructor, it uses `STEALTH_API_OBFSTR` and `OBFUSCATE_STRING` to resolve all required functions from their respective DLLs (and `kernel32.dll` for `LoadLibraryA`/`GetLastError`) without leaving obvious import traces.
     *   Simplifies making obfuscated network requests and performing other network-related tasks.

   - **`RegistryAPIs::RegistryAPI` (`k8_RegistryAPIs.hpp`)**:
     *   Wraps commonly used Windows Registry functions such as `RegSetValueExA`, `RegCreateKeyExA`, `RegOpenKeyExA`, `RegQueryValueExA`, `RegCloseKey`, etc.
     *   **Automatic Stealth Resolution**: Resolves functions from `advapi32.dll` (and `kernel32.dll`) stealthily during construction.
     *   Aids in performing registry operations with less traceable API calls.

### 6. Core Obfuscation Primitives (Macros in `Obfusk8Core.hpp`)
These are the building blocks used extensively throughout the library, especially in the `_main` macro and VM engine:
*   **Mixed Boolean-Arithmetic (MBA)**: Transforms simple mathematical and logical operations (ADD, SUB, XOR, NOT, MUL) into complex, but equivalent, sequences of bitwise and arithmetic formulas (e.g., `OBF_MBA_ADD`, `OBF_MBA_XOR`). These are designed to be very difficult for decompilers to simplify back to their original forms.
*   **Opaque Predicates**: Inserts conditional branches where the condition always evaluates to true (e.g., `OBF_OPAQUE_PREDICATE_TRUE_1`) or always false (e.g., `OBF_OPAQUE_PREDICATE_FALSE_1`). These conditions are constructed from complex, hard-to-statically-evaluate expressions involving `__COUNTER__`, `__LINE__`, `__TIME__`, and the `_obf_global_opaque_seed`. They create misleading code paths and can be used to guard dead code or force specific execution flows.
*   **Junk Code Injection**:
    *   `OBF_CALL_ANY_LOCAL_JUNK`: Calls one of many small, randomized junk functions defined in `obf_junk_ns`. These functions perform trivial, volatile operations and are selected randomly at compile time. Their purpose is to increase code entropy, break up simple code patterns, and potentially mislead signature-based detection or analysis tools.
    *   `NOP()`: A macro that inserts volatile operations designed to prevent easy removal by optimizers and to subtly modify a global seed.
*   **Anti-Disassembly & Anti-Analysis Tricks**:
    *   **Obfuscated Jumps (`OBF_JUMP_*` macros)**: Creates `goto` statements whose conditions or targets are obfuscated, often relying on opaque predicates or MBA.
    *   **Obfuscated State Transitions (`OBF_SET_NEXT_STATE_*` macros)**: Used in ICFF, these macros set the next state variable for the flattened control flow dispatcher using similar obfuscation techniques as the obfuscated jumps.
    *   **Stack Manipulation (`OBF_STACK_ALLOC_MANIP`, `OBF_FAKE_PROLOGUE_MANIP`)**: Allocates variable-sized chunks on the stack and performs bogus manipulations on them. Fake prologues attempt to confuse stack analysis.
    *   **Obfuscated Function Calls (`OBF_CALL_VIA_OBF_PTR`)**: Function pointers are XORed with a dynamic key before and after being used, obscuring the true call target.
    *   `K8_ASSUME(0)`: Used in dead code paths to hint to the MSVC compiler that these paths are unreachable, potentially allowing for different optimizations or code generation that might further confuse analysis if the assumption is violated by a patch.

**Dependencies**
The Obfusk8 library is modular. Core functionality relies on:
- `Obfusk8Core.hpp`: (This file) The central header that orchestrates and provides the main obfuscation macros and primitives.
- `xtea8.hpp`: Provides XTEA-based compile-time string encryption and optional PE section manipulation features.
- `Resolve8.hpp`: Implements the PEB-based stealthy Windows API resolution.

Optional helper API classes are provided in separate headers, typically located in subdirectories:
- `k8_ProcessManipulationAPIs/k8_ProcessManipulationAPIs.hpp`: For stealthy process manipulation APIs.
- `k8_CryptographyAPIs/k8_CryptographyAPIs.hpp`: For stealthy cryptography APIs.
- `k8_NetworkingAPIs/k8_NetworkingAPIs.hpp`: For stealthy networking APIs.
- `k8_RegistryAPIs/k8_RegistryAPIs.hpp`: For stealthy registry APIs.

  *   **ida graph**:
      ![image](https://github.com/user-attachments/assets/680f542e-88c0-472e-8149-4ee6c80e82a2)
     
  *   **some chunks from ida pro**:
      ![image](https://github.com/user-attachments/assets/2bdc6270-96d9-4448-9557-54f9ef4035e3)
      ![image](https://github.com/user-attachments/assets/952584b4-f046-4ff4-a3a4-c485fa370aa8)
      ![image](https://github.com/user-attachments/assets/54128487-445c-42c9-86df-202f77a2eb73)
    
  *   **detect it easy signatures results**:
      ![image](https://github.com/user-attachments/assets/460889f8-49a7-4d6d-a226-442d4cece4db)
    
  *   **memory map (from die)**:
    
    `
                  Offset	Address	Size	Name
                  0000000000000000	0000000140000000	0000000000000800	PE Header
                  0000000000000800	0000000140001000	000000000029b600	Section(0)['.text']
                  000000000029be00	000000014029d000	000000000004a400	Section(1)['.rdata']
                  00000000002e6200	00000001402e8000	0000000000001400	Section(2)['.data']
                  00000000002e7600	00000001402ef000	0000000000004200	Section(3)['.pdata']
                  00000000002eb800	00000001402f4000	0000000000000c00	Section(4)['.themida']
                  00000000002ec400	00000001402f5000	0000000000000c00	Section(5)['.vmp1']
                  00000000002ed000	00000001402f6000	0000000000000c00	Section(6)['.enigma2']
                  00000000002edc00	00000001402f7000	0000000000000c00	Section(7)['.xtls']
                  00000000002ee800	00000001402f8000	0000000000000c00	Section(8)['.arch']
                  00000000002ef400	00000001402f9000	0000000000000c00	Section(9)['.vmp0']
                  00000000002f0000	00000001402fa000	0000000000000c00	Section(10)['.xpdata']
                  00000000002f0c00	00000001402fb000	0000000000000c00	Section(11)['.vmp2']
                  00000000002f1800	00000001402fc000	0000000000000c00	Section(12)['.enigma1']
                  00000000002f2400	00000001402fd000	0000000000000c00	Section(13)['.PECompa']
                  00000000002f3000	00000001402fe000	0000000000000c00	Section(14)['.dsstext']
                  00000000002f3c00	00000001402ff000	0000000000000c00	Section(15)['.UPX0']
                  00000000002f4800	0000000140300000	0000000000000c00	Section(16)['.UPX1']
                  00000000002f5400	0000000140301000	0000000000000c00	Section(17)['.UPX2']
                  00000000002f6000	0000000140302000	0000000000000c00	Section(18)['.aspack']
                  00000000002f6c00	0000000140303000	0000000000000c00	Section(19)['.nsp0']
                  00000000002f7800	0000000140304000	0000000000000c00	Section(20)['.nsp1']
                  00000000002f8400	0000000140305000	0000000000000c00	Section(21)['.FSG!']
                  00000000002f9000	0000000140306000	0000000000000c00	Section(22)['.pec1']
                  00000000002f9c00	0000000140307000	0000000000000c00	Section(23)['.pec2']
                  00000000002fa800	0000000140308000	0000000000000c00	Section(24)['.petite']
                  00000000002fb400	0000000140309000	0000000000000c00	Section(25)['.mpress1']
                  00000000002fc000	000000014030a000	0000000000000c00	Section(26)['.mpress2']
                  00000000002fcc00	000000014030b000	0000000000000c00	Section(27)['.vmp3']
                  00000000002fd800	000000014030c000	0000000000000c00	Section(28)['.vmp4']
                  00000000002fe400	000000014030d000	0000000000000c00	Section(29)['.vmp5']
                  00000000002ff000	000000014030e000	0000000000000c00	Section(30)['.vmp6']
                  00000000002ffc00	000000014030f000	0000000000000c00	Section(31)['.vmp7']
                  0000000000300800	0000000140310000	0000000000000200	Section(32)['.fptable']
                  0000000000300a00	0000000140311000	0000000000000c00	Section(33)['.reloc']
`

### Demo:
   [[Obfusk8: C++17-Based Obfuscation Library - IDA pro Graph View] ~Video Demo](https://youtu.be/B9g4KSg3tHQ)

**Usage**

1.  Include `Obfusk8Core.hpp` in your main project file (e.g., `main.cpp`).
    ```cpp
    #include "Obfusk8Core.hpp" // Adjust path as needed
    ```
2.  Wrap your `main` function's body with the `_main`:
    ```cpp
    _main({
        // Your application's original main code here
        // Example:
        // OBFUSCATE_STRING("Hello, Obfuscated World!").c_str();
        
        // Using an API wrapper class
        k8_NetworkingAPIs::NetworkingAPI* netAPI = new k8_NetworkingAPIs::NetworkingAPI;
        if (netAPI->IsInitialized() && netAPI->pInternetOpenA) {
            HINTERNET hInternet = netAPI->pInternetOpenA(OBFUSCATE_STRING("MyAgent").c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
            if (hInternet) {
                // ... use hInternet ...
                netAPI->pInternetCloseHandle(hInternet);
            }
        }

        delete netAPI;
        
        return 0;
    })
    ```
3.  Use `OBFUSCATE_STRING("your string")` for all important string literals. Access the decrypted string via its `.c_str()` method if needed for API calls, or use its other methods like `.print_to_console()` if provided by `xtea8.hpp`.
4.  Use `STEALTH_API_OBFSTR("dll_name.dll", "FunctionNameA")` for direct stealthy API calls, or preferably use the API wrapper classes (e.g., `K8_ProcessManipulationAPIs::ProcessAPI`, `k8_NetworkingAPIs::NetworkingAPI`) for convenience and built-in stealth.
5.  Sprinkle `OBF_BOGUS_FLOW_*`, `OBF_CALL_ANY_LOCAL_JUNK`, `NOP()`, and other primitives in performance-insensitive critical sections of your code for added obfuscation layers.

* see the main.cpp file.

**Building**

*   **Compiler Requirement**: This library is designed for C++17. The Microsoft C++ Compiler (`cl.exe`) is primarily targeted, especially for PE section features and SEH usage.
*   **Getting `cl.exe` (MSVC Compiler) on Windows**:
    1.  **Install Visual Studio**: The easiest way to get `cl.exe` is by installing Visual Studio. You can download the Visual Studio Community edition for free from the [Visual Studio website](https://visualstudio.microsoft.com/downloads/).
    2.  **Select Workload**: During installation, make sure to select the "Desktop development with C++" workload. This will install the C++ compiler, Windows SDK, and other necessary tools.
    3.  **Use Developer Command Prompt**: After installation, search for "Developer Command Prompt for VS" (e.g., "x64 Native Tools Command Prompt for VS 2022") in your Start Menu and run it. This command prompt automatically sets up the environment variables (PATH, INCLUDE, LIB) needed to use `cl.exe`.
*   **Include Paths**:
    *   Ensure the directory containing `Obfusk8Core.hpp` is in your compiler's include path.
    *   If `xtea8.hpp`, `Resolve8.hpp`, and the API wrapper directories (e.g., `k8_NetworkingAPIs/`) are not in the same directory as `Obfusk8Core.hpp`, ensure their paths are also correctly configured. `Obfusk8Core.hpp` uses relative paths like `../Obfusk8Core.hpp` for some of its internal includes of the API wrappers, so the directory structure matters. If `Obfusk8Core.hpp` is at the root of your include directory for this library, then API wrappers should be in subdirectories like `k8_NetworkingAPIs/` relative to where `Obfusk8Core.hpp` expects them or adjust the include paths within `Obfusk8Core.hpp` itself.
*   **Compilation Example (using Developer Command Prompt)**:
    Assuming your `main.cpp` and the Obfusk8 headers are structured correctly, you can compile using a command similar to:
    ```bash
    cl /std:c++17 /EHsc main.cpp
    ```
    *   after opening `x64 Native Tools Command Prompt for VS 2022`:
        ![x64 Native Tools Command Prompt for VS 2022](https://github.com/user-attachments/assets/f5da8da0-b466-4836-a525-0e37acf4b8cb)

        
    *   `/std:c++17`: Specifies C++17 standard.
    *   `/EHsc`: Specifies the C++ exception handling model.
    *   `main.cpp`: Your main source file.
    *   `/I"path/to/your/obfusk8_includes"`: (Optional, if headers are not in default paths) Add the directory where `Obfusk8Core.hpp` and its dependencies are located. If they are in subdirectories, ensure the relative paths within `Obfusk8Core.hpp` match your layout.
    *   **Note on Libraries**: While the stealth API resolution aims to avoid static linking for the obfuscated functions, the Windows SDK headers themselves might require certain `.lib` files to be available to the linker for resolving any non-obfuscated SDK usage or internal types (e.g., `Ws2_32.lib`, `Wininet.lib`, `Advapi32.lib`, etc.). For a simple project like `cl /std:c++17 /EHsc main.cpp`, the linker often resolves these automatically if they are standard Windows libraries.

*   **Considerations on Binary Size & Future Enhancements**:
    *   **Size Impact**: Be aware that extensive use of header-only obfuscation, especially with techniques like inlining junk code, MBA expansions, and flattened control flow, can lead to a significant increase in the final binary size. A small program might grow from kilobytes to potentially 2MB or more, depending on the intensity of obfuscation applied.
    *   **Customization & Packing (Future Direction)**:
        *   Currently, Obfusk8 focuses on in-code obfuscation. Users might need to fine-tune the usage of various macros (e.g., reducing the density of `OBF_CALL_ANY_LOCAL_JUNK` or the complexity of `_main`'s loops) if binary size is a critical constraint.
        *   For substantial size reduction post-obfuscation, integrating or using an external PE packer (like UPX, MPRESS, or custom solutions) would be a separate step.
        *   Future development of Obfusk8 could explore options for more granular control over obfuscation intensity or even integrate lightweight packing/compression stubs directly within the library, though this would significantly increase its complexity.

**mindmap & Feedback**

This project, Obfusk8, is an ongoing exploration into advanced C++ obfuscation techniques. The current version lays a strong foundation with a multitude of interwoven strategies.

*   **Future Vision (Obfusk8 v2)**: I envision a "Version 2" that will delve into even more sophisticated areas. A key feature I'm aiming for is **self-packing/unpacking capabilities integrated directly into the obfuscation layer**. This would involve the `_main` macro or a similar mechanism not only obfuscating the code but also embedding the primary application logic in an encrypted/compressed form, which is then decrypted and executed in memory at runtime. This would further enhance resistance to static analysis and reduce the initial on-disk footprint if the compression is effective. Other potential v2 enhancements could include deeper integration of metamorphic code generation, and perhaps even user-configurable obfuscation profiles.

*   **Your Feedback is Invaluable**: As the developer of Obfusk8, I am keenly interested in your perspective, insights, and any feedback you might have. Whether it's suggestions for new features, improvements to existing techniques, reports of successful (or unsuccessful) reverse engineering attempts against code protected by Obfusk8, or general thoughts on the library's usability and effectiveness – all contributions are welcome and highly appreciated. This project thrives on community input and real-world testing to push its boundaries and become an even more formidable tool for code protection. Please feel free to share your thoughts, raise issues, or contribute to its evolution!

**Disclaimer**
Obfuscation is a layer of defense, not a foolproof solution. Determined attackers with sufficient skill and time can often reverse engineer obfuscated code. Obfusk8 aims to significantly raise the bar for such efforts. Use in conjunction with other security measures.

```