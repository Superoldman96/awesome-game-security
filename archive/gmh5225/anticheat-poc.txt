Project Path: arc_gmh5225_anticheat-poc_0_32z5qb

Source Tree:

```txt
arc_gmh5225_anticheat-poc_0_32z5qb
├── README.md
├── anticheat_poc.filters
├── anticheat_poc.sln
├── anticheat_poc.user
├── anticheat_poc.vcxproj
├── anticheat_poc.vcxproj.user
├── defines.h
├── hooks.h
├── main.cpp
├── minhook
└── syscall
    ├── instrumentationcallbackproxy.asm
    ├── syscalls.c
    ├── syscalls.h
    └── syscallsstubs.asm

```

`README.md`:

```md
# anticheat-poc
In pursuit of a deeper understanding of low-level programming and reverse engineering, I took to the development of a program that functions as a basic form of an anti-cheat or anti-virus that could be used in the context of not only ensured gameplay integrity but also general security and protection against malicious code for a specific process. Initially, this project began as a test bed to evaluate the detection vectors triggered by methods used in my own memory-hacking program. Through independent research, I studied techniques used by well-known industry-level anti-cheats and incorporated similar procedures into my application. Some aspects of my code drew inspiration from the reversed, decompiled IDA output of the aforementioned software binaries.
# DLL component
There is also a [dynamic link library (DLL) component](https://github.com/thetuh/anticheat-dll-example) created specifically for this program to showcase how certain hooks are triggered and how they can also be circumvented using various techniques.
# Features
* DLL inject detection (LoadLibrary)
* Return address integrity checks on various Windows API / Native API function exports via detour hooks
* Kernel-level return address integrity checks on all syscalls via instrumentation callbacks
# Planned
* Compute and cache all valid module base and end addresses on startup by walking the PEB
* Scan all opened handles to our process
* Restructure/reorganize project
* Clean/Optimize code
# Resources
https://github.com/TsudaKageyu/minhook

```

`anticheat_poc.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hde\hde32.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hde\hde64.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="syscall\syscalls.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="minhook\src\hde\hde32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\hde64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\pstdint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\table32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\table64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\MinHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="syscall\syscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="defines.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="syscall\syscallsstubs.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`anticheat_poc.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.2.32526.322
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ac_emulator", "anticheat_poc.vcxproj", "{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "example_dll", "..\example_dll\example_dll.vcxproj", "{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x64.ActiveCfg = Debug|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x64.Build.0 = Debug|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x86.ActiveCfg = Debug|Win32
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Debug|x86.Build.0 = Debug|Win32
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x64.ActiveCfg = Release|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x64.Build.0 = Release|x64
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x86.ActiveCfg = Release|Win32
		{3C8CE0DD-3BEC-4BD4-8127-6201CA699E74}.Release|x86.Build.0 = Release|Win32
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Debug|x64.ActiveCfg = Debug|x64
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Debug|x64.Build.0 = Debug|x64
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Debug|x86.ActiveCfg = Debug|Win32
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Debug|x86.Build.0 = Debug|Win32
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Release|x64.ActiveCfg = Release|x64
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Release|x64.Build.0 = Release|x64
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Release|x86.ActiveCfg = Release|Win32
		{055B4B1D-A4C8-4750-B306-9DF7F8B1516A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E14AC698-8E6B-422D-B86E-797F487EBF64}
	EndGlobalSection
EndGlobal

```

`anticheat_poc.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`anticheat_poc.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3c8ce0dd-3bec-4bd4-8127-6201ca699e74}</ProjectGuid>
    <RootNamespace>winapihooks</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ac_emulator</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)build\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(Configuration)\intermediates\executable\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)build\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(Configuration)\intermediates\executable\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)build\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(Configuration)\intermediates\executable\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)build\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(Configuration)\intermediates\executable\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>Default</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>Default</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="minhook\src\buffer.c" />
    <ClCompile Include="minhook\src\hde\hde32.c" />
    <ClCompile Include="minhook\src\hde\hde64.c" />
    <ClCompile Include="minhook\src\hook.c" />
    <ClCompile Include="minhook\src\trampoline.c" />
    <ClCompile Include="syscall\syscalls.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defines.h" />
    <ClInclude Include="hooks.h" />
    <ClInclude Include="minhook\MinHook.h" />
    <ClInclude Include="minhook\src\buffer.h" />
    <ClInclude Include="minhook\src\hde\hde32.h" />
    <ClInclude Include="minhook\src\hde\hde64.h" />
    <ClInclude Include="minhook\src\hde\pstdint.h" />
    <ClInclude Include="minhook\src\hde\table32.h" />
    <ClInclude Include="minhook\src\hde\table64.h" />
    <ClInclude Include="minhook\src\trampoline.h" />
    <ClInclude Include="syscall\syscalls.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="syscall\instrumentationcallbackproxy.asm" />
    <MASM Include="syscall\syscallsstubs.asm">
      <FileType>Document</FileType>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`anticheat_poc.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`defines.h`:

```h
#pragma once

#ifndef NT_ERROR
#define NT_ERROR(Status) ((((ULONG)(Status)) >> 30) == 3)
#endif

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)    // ntsubauth
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)
#define STATUS_NOT_SUPPORTED             ((NTSTATUS)0xC00000BBL)

#define ProcessInstrumentationCallback (PROCESSINFOCLASS)0x28
#define IP_SANITY_CHECK(ip,BaseAddress,ModuleSize) (ip > BaseAddress) && (ip < (BaseAddress + ModuleSize))
#define CEPTOR_VALID_HANDLE( h )	( ( ( ( std::uint64_t )h >> 20 ) & 0xFFF ) == 0xF0F )

namespace gate
{
	static bool loadlibrarya{ false };
	static bool loadlibraryw{ false };
	static bool loadlibraryexa{ false };
	static bool loadlibraryexw{ false };
}

static DWORD_PTR g_NtdllBase;
static DWORD_PTR g_W32UBase;

static DWORD g_NtdllSize;
static DWORD g_W32USize;

using OpenProcess_t = HANDLE( WINAPI* )( DWORD, BOOL, DWORD );
OpenProcess_t openprocess_original{ nullptr };

using CloseHandle_t = BOOL( WINAPI* )( HANDLE );
CloseHandle_t closehandle_original{ nullptr };

using LoadLibraryA_t = HMODULE( WINAPI* )( LPCSTR );
LoadLibraryA_t loadlibrarya_original{ nullptr };

using LoadLibraryW_t = HMODULE( WINAPI* )( LPCWSTR );
LoadLibraryW_t loadlibraryw_original{ nullptr };

using GetCurrentProcess_t = HANDLE( WINAPI* )( );
GetCurrentProcess_t getcurrentprocess_original{ nullptr };

using VirtualAllocEx_t = LPVOID( WINAPI* )( HANDLE, LPVOID, SIZE_T, DWORD, DWORD );
VirtualAllocEx_t virtualallocex_original{ nullptr };

using VirtualQueryEx_t = SIZE_T( WINAPI* )( HANDLE, LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T );
static VirtualQueryEx_t virtualqueryex_original{ nullptr };

using MessageBoxW_t = int( WINAPI* )( HWND, LPCWSTR, LPCWSTR, UINT );
static MessageBoxW_t messagebox_original{ nullptr };

using SetCursorPos_t = BOOL( WINAPI* )( int, int );
static SetCursorPos_t setcursor_original{ nullptr };

using NtAllocateVirtualMemory_t = NTSTATUS( NTAPI* )( HANDLE, PVOID*, ULONG, PSIZE_T, ULONG, ULONG );
static NtAllocateVirtualMemory_t ntallocatevirtualmemory_original{ nullptr };

typedef void( *CallbackFn )( );

typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
{
	ULONG Version;
	ULONG Reserved;
	CallbackFn Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

VOID GetBaseAddresses( )
{
	PIMAGE_DOS_HEADER piDH;
	PIMAGE_NT_HEADERS piNH;

	g_NtdllBase = ( DWORD_PTR ) GetModuleHandle( TEXT( "ntdll.dll" ) );
	piDH = ( PIMAGE_DOS_HEADER ) g_NtdllBase;
	piNH = ( PIMAGE_NT_HEADERS ) ( g_NtdllBase + piDH->e_lfanew );

	g_NtdllSize = piNH->OptionalHeader.SizeOfImage;

	g_W32UBase = ( DWORD_PTR ) GetModuleHandle( TEXT( "win32u.dll" ) );
	if ( g_W32UBase ) {
		piDH = ( PIMAGE_DOS_HEADER ) g_W32UBase;
		piNH = ( PIMAGE_NT_HEADERS ) ( g_W32UBase + piDH->e_lfanew );
		g_W32USize = piNH->OptionalHeader.SizeOfImage;
	}
}

// https://stackoverflow.com/questions/8032080/how-to-convert-char-to-wchar-t
const wchar_t* GetWC( const char* c )
{
	const size_t cSize = strlen( c ) + 1;
	wchar_t* wc = new wchar_t[ cSize ];
	mbstowcs( wc, c, cSize );

	return wc;
}

//https://gist.github.com/syu5-gh/eaa0018ed70836b7279b
void DebugOut( const wchar_t* fmt, ... )
{
	va_list argp;
	va_start( argp, fmt );
	wchar_t dbg_out[ 4096 ];
	vswprintf_s( dbg_out, fmt, argp );
	printf( "%ls", dbg_out );
	va_end( argp );
	OutputDebugString( dbg_out );
}

// could be massively improved

bool validate_call( uintptr_t address )
{
	HMODULE hMods[ 1024 ];
	DWORD cbNeeded;

	if ( EnumProcessModules( GetCurrentProcess( ), hMods, sizeof( hMods ), &cbNeeded ) )
	{
		for ( unsigned int i = 0; i < ( cbNeeded / sizeof( HMODULE ) ); i++ )
		{
			TCHAR szModName[ MAX_PATH ];

			if ( GetModuleFileNameEx( GetCurrentProcess( ), hMods[ i ], szModName,
				sizeof( szModName ) / sizeof( TCHAR ) ) )
			{
				const HMODULE handle{ GetModuleHandle( szModName ) };
				if ( !handle )
					continue;

				MODULEINFO mod_info{ };
				if ( !GetModuleInformation( GetCurrentProcess( ), handle, &mod_info, sizeof( MODULEINFO ) ) )
					continue;

				if ( address > ( DWORD ) mod_info.lpBaseOfDll && address <= ( DWORD ) mod_info.lpBaseOfDll + mod_info.SizeOfImage )
					return true;
			}
		}
	}

	return false;
}

void syscall_msgbox( const wchar_t* body, const wchar_t* caption )
{
	UNICODE_STRING msgBody;
	UNICODE_STRING msgCaption;

	ULONG ErrorResponse;

	msgBody.Length = ( wcslen( body ) + 1 ) * sizeof( wchar_t );
	msgBody.MaximumLength = msgBody.Length;
	msgBody.Buffer = ( PWSTR ) body;

	msgCaption.Length = ( wcslen( caption ) + 1 ) * sizeof( wchar_t );
	msgCaption.MaximumLength = msgCaption.Length;
	msgCaption.Buffer = ( PWSTR ) caption;

	const ULONG_PTR msgParams[ ] = {
	( ULONG_PTR ) &msgBody,
	( ULONG_PTR ) &msgCaption,
	( ULONG_PTR ) ( MB_OK )
	};

	NtRaiseHardError( 0x50000018L, 0x00000003L, 3, ( PULONG_PTR ) msgParams, NULL, &ErrorResponse );
}
```

`hooks.h`:

```h
#pragma once

/*
* @note:
* 
*	as a poc, there is a very primitive return address integrity check implemented, could be much improved
* 
*	from a practical design standpoint, it'd much more efficient to compute all the valid module base/end addresses (maybe only .text/.code section?)
*		on startup, store them, and cache them each call ( see 'GetBaseAddreses' ) for use in practice
* 
*	furthermore, this doesn't account for the fact that the dependencies are dynamically loaded so this will flag calls that are legit
*		if we make a call to a module that has not yet been loaded
* 
*/

static HANDLE WINAPI HookedOpenProcess( DWORD access, BOOL inherithandle, DWORD pid )
{
	printf( "[inline hook]: OpenProcess called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return openprocess_original( access, inherithandle, pid);
}

static BOOL WINAPI HookedCloseHandle( HANDLE handle )
{
	printf( "[inline hook]: CloseHandle called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return closehandle_original( handle );
}

static BOOL HookedSetCursorPos( int x, int y )
{
	printf( "[inline hook]: SetCursorPos called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return setcursor_original( x, y );
}

static HANDLE WINAPI HookedGetCurrentProcess( )
{
	printf( "[inline hook]: GetCurrentProcess called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return getcurrentprocess_original( );
}

static HMODULE WINAPI HookedLoadLibraryA( LPCSTR filename )
{
	printf( "[inline hook]: LoadLibraryA was called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	if ( gate::loadlibrarya )
		return loadlibrarya_original( filename );
	else
		printf( "[inline hook]: call was not authenticated, rejecting\n" );

	return nullptr;
}

static HMODULE WINAPI HookedLoadLibraryW( LPCWSTR filename )
{
	printf( "[inline hook]: LoadLibraryW was called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	if ( gate::loadlibraryw )
		return loadlibraryw_original( filename );
	else
		printf( "[inline hook]: call was not authenticated, rejecting\n" );

	return nullptr;
}

static LPVOID WINAPI HookedVirtualAllocEx(
	_In_ HANDLE hProcess,
	_In_opt_ LPVOID lpAddress,
	_In_ SIZE_T dwSize,
	_In_ DWORD flAllocationType,
	_In_ DWORD flProtect
) {
	printf( "[inline hook]: VirtualAllocEx called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return virtualallocex_original( hProcess, lpAddress, dwSize, flAllocationType, flProtect );
}

static SIZE_T WINAPI HookedVirtualQueryEx(
	HANDLE hProcess,
	LPCVOID lpAddress,
	PMEMORY_BASIC_INFORMATION lpBuffer,
	SIZE_T dwLength
) {
	printf( "[inline hook]: VirtualQueryEx called\n" );

	if ( !validate_call( ( uintptr_t ) _ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return virtualqueryex_original( hProcess, lpAddress, lpBuffer, dwLength );
}

static int WINAPI HookedMessageBoxW(
	HWND hWnd,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType
) {
	printf( "[inline hook]: MessageBoxW called with text '%ls' and caption '%ls'\n", lpText, lpCaption );

	if ( !validate_call( ( uintptr_t )_ReturnAddress( ) ) )
		printf( "[inline hook]: failed retaddr check\n" );

	return messagebox_original( hWnd, lpText, lpCaption, uType );
}

NTSTATUS NTAPI HookedNtAllocateVirtualMemory(
	HANDLE processhandle,
	PVOID* baseaddress,
	ULONG zerobits,
	PSIZE_T regionsize,
	ULONG allocationtype,
	ULONG protect
) {
	validate_call( ( uintptr_t ) _ReturnAddress( ) );

	return ntallocatevirtualmemory_original( processhandle, baseaddress, zerobits, regionsize, allocationtype, protect );
}
```

`main.cpp`:

```cpp

#include <Windows.h>
#include <DbgHelp.h>
#include <iostream>
#include <bcrypt.h>
#include <thread>
#include <intrin.h>
#include <psapi.h>
#include <future>

#pragma comment (lib, "dbghelp.lib")
#pragma comment (lib, "ntdll.lib")

#include "syscall/syscalls.h"
#include "minhook/MinHook.h"

#include "defines.h"
#include "hooks.h"

extern "C" NTSTATUS NTAPI ZwRaiseHardError( LONG ErrorStatus, ULONG NumberOfParameters, ULONG UnicodeStringParameterMask,
	PULONG_PTR Parameters, ULONG ValidResponseOptions, PULONG Response );

extern "C" void InstrumentationCallbackProxy( VOID );
extern "C" void instrumentation_callback( uintptr_t ReturnAddress, uintptr_t ReturnVal )
{
	BOOLEAN sanityCheckNt;
	BOOLEAN sanityCheckWu;
	DWORD_PTR NtdllBase;
	DWORD_PTR W32UBase;
	DWORD NtdllSize;
	DWORD W32USize;
	int cbDisableOffset;
	int instPrevSpOffset;
	int instPrevPcOffset;
#ifdef _DEBUG
	BOOLEAN SymbolLookupResult = FALSE;
	DWORD64 Displacement;
	PSYMBOL_INFO SymbolInfo;
	BYTE SymbolBuffer[ sizeof( SYMBOL_INFO ) + MAX_SYM_NAME ] = { 0 };
#endif

	uintptr_t pTEB = ( uintptr_t ) NtCurrentTeb( );

#ifdef _WIN64
	cbDisableOffset = 0x02EC;	// TEB64->InstrumentationCallbackDisabled offset
	instPrevPcOffset = 0x02D8;	// TEB64->InstrumentationCallbackPreviousPc offset
	instPrevSpOffset = 0x02E0;  // TEB64->InstrumentationCallbackPreviousSp offset
	ctx->Rip = *( ( uintptr_t* ) ( pTEB + instPrevPcOffset ) );
	ctx->Rsp = *( ( uintptr_t* ) ( pTEB + instPrevSpOffset ) );
	ctx->Rcx = ctx->R10;
	ctx->R10 = ctx->Rip;
#else
	//PTEB32 pTEB = (PTEB32)NtCurrentTeb();
	cbDisableOffset = 0x01B8;   // TEB32->InstrumentationCallbackDisabled offset
	instPrevPcOffset = 0x01B0;  // TEB32->InstrumentationCallbackPreviousPc offset
	instPrevSpOffset = 0x01B4;  // TEB32->InstrumentationCallbackPreviousSp offset
#endif

	//
	// Check TEB->InstrumentaionCallbackDisabled flag to prevent recursion.
	//
	if ( !*( ( uintptr_t* ) ( pTEB + cbDisableOffset ) ) ) {
		//
		// Disabling to prevent recursion. Do not call any 
		// Win32 APIs outside of this loop and before
		// setting the TEB->InstrumentationCallbackDisabled flag
		// 
		*( ( uintptr_t* ) ( pTEB + cbDisableOffset ) ) = 1;

#ifdef _DEBUG
		// Lookup and display the Symbol Name if found
		SymbolInfo = ( PSYMBOL_INFO ) SymbolBuffer;
		SymbolInfo->SizeOfStruct = sizeof( SYMBOL_INFO );
		SymbolInfo->MaxNameLen = MAX_SYM_NAME;

		SymbolLookupResult = SymFromAddr( ( HANDLE ) -1, ReturnAddress, &Displacement, SymbolInfo );

		if ( SymbolLookupResult )
			DebugOut( L"[+] Symbol name: %s\n", GetWC( SymbolInfo->Name ) );

#ifdef DEBUG_VERBOSE
#ifdef _WIN64
		DebugOut( L"[d] CTX->Rip: 0x%016Ix\n", ctx->Rip );
#endif
		DebugOut( L"[d] ReturnAddress: 0x%016Ix\n", ReturnAddress );
		DebugOut( L"[d] ReturnVal: 0x%016Ix\n", ReturnVal );
#endif
#endif

		// Get pointers to DLL base addresss & sizes
		NtdllBase = ( DWORD_PTR ) InterlockedCompareExchangePointer(
			( PVOID* ) &g_NtdllBase,
			NULL,
			NULL
		);

		W32UBase = ( DWORD_PTR ) InterlockedCompareExchangePointer(
			( PVOID* ) &g_W32UBase,
			NULL,
			NULL
		);

		NtdllSize = InterlockedCompareExchange(
			( DWORD* ) &g_NtdllSize,
			NULL,
			NULL
		);

		W32USize = InterlockedCompareExchange(
			( DWORD* ) &g_W32USize,
			NULL,
			NULL
		);

		// Check to see if the syscall came from within the DLLs
#ifdef _WIN64
		sanityCheckNt = IP_SANITY_CHECK( ctx->Rip, NtdllBase, NtdllSize );
		sanityCheckWu = IP_SANITY_CHECK( ctx->Rip, W32UBase, W32USize );
#else
		sanityCheckNt = IP_SANITY_CHECK( ReturnAddress, NtdllBase, NtdllSize );
		sanityCheckWu = IP_SANITY_CHECK( ReturnAddress, W32UBase, W32USize );
#endif

		// If the syscall did not come from the a know DLL, print a message and break.
		if ( !( sanityCheckNt || sanityCheckWu ) ) {
			DebugOut( L"[instrumentation callback]: kernel returns to unverified module\n" );
#ifdef _WIN64
			DebugOut( L"[I] CTX->Rip: 0x%016Ix\n", ctx->Rip );
#else
			DebugOut( L"[instrumentation callback]: return address: 0x%016Ix\n", ReturnAddress );
			DebugOut( L"[instrumentation callback]: return value: 0x%016Ix\n", ReturnVal );
#endif

#ifdef _DEBUG
			if ( SymbolLookupResult )
				DebugOut( L"[!] Unverified function: %s\n", GetWC( SymbolInfo->Name ) );

			// Un-commnet if you want to manually debug
			// DebugBreak();
#endif
			//// Terminate the process
			//DebugOut( L"[!] Preventing further execution!\n" );
			//ExitProcess( ERROR_INVALID_ACCESS );
		}

		// Unset TEB->InstrumentationCallbackDisabled to re-enable
		// instrumention.
		*( ( uintptr_t* ) ( pTEB + cbDisableOffset ) ) = 0;
	}
#ifdef _WIN64
	RtlRestoreContext( ctx, NULL );
#endif
}

// Code from ScyllaHide
NTSTATUS SetInstrumentationCallbackHook( HANDLE ProcessHandle, BOOL Enable )
{
	CallbackFn Callback = Enable ? InstrumentationCallbackProxy : NULL;

	// Windows 10
	PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION CallbackInfo;
#ifdef _WIN64
	Info.Version = 0;
#else
	// Native x86 instrumentation callbacks don't work correctly
	BOOL Wow64Process = FALSE;
	if ( !IsWow64Process( ProcessHandle, &Wow64Process ) || !Wow64Process )
	{
		//Info.Version = 1; // Value to use if they did
		return STATUS_NOT_SUPPORTED;
	}

	// WOW64: set the callback pointer in the version field
	CallbackInfo.Version = ( ULONG ) Callback;
#endif
	CallbackInfo.Reserved = 0;
	CallbackInfo.Callback = Callback;

	return NtSetInformationProcess( ProcessHandle, ProcessInstrumentationCallback,
		&CallbackInfo, sizeof( CallbackInfo ) );
}

void install_hooks( )
{
	/* set the inline hooks */

	MH_Initialize( );

	/* works fine just spams console because it's called several times */
	//MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "GetCurrentProcess" ), &HookedGetCurrentProcess, reinterpret_cast< LPVOID* >( &getcurrentprocess_original ) );

	MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "OpenProcess" ), &HookedOpenProcess, reinterpret_cast< LPVOID* >( &openprocess_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "CloseHandle" ), &HookedCloseHandle, reinterpret_cast< LPVOID* >( &closehandle_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "LoadLibraryA" ), &HookedLoadLibraryA, reinterpret_cast< LPVOID* >( &loadlibrarya_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "LoadLibraryW" ), &HookedLoadLibraryW, reinterpret_cast< LPVOID* >( &loadlibraryw_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "VirtualAllocEx" ), &HookedVirtualAllocEx, reinterpret_cast< LPVOID* >( &virtualallocex_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"Kernel32.dll" ), "VirtualQueryEx" ), &HookedVirtualQueryEx, reinterpret_cast< LPVOID* >( &virtualqueryex_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"User32.dll" ), "MessageBoxW" ), &HookedMessageBoxW, reinterpret_cast< LPVOID* >( &messagebox_original ) );
	MH_CreateHook( GetProcAddress( GetModuleHandle( L"User32.dll" ), "SetCursorPos" ), &HookedSetCursorPos, reinterpret_cast< LPVOID* >( &setcursor_original ) );

	/* this isn't stable for some reason */
	//MH_CreateHook( PVOID ( GetProcAddress( GetModuleHandle( L"ntdll.dll" ), "NtAllocateVirtualMemory" ) ), &HookedNtAllocateVirtualMemory, reinterpret_cast< LPVOID* >( &ntallocatevirtualmemory_original ) );

	MH_EnableHook( MH_ALL_HOOKS );

	/* set the instrumentation callbacks */

	SymSetOptions( SYMOPT_UNDNAME );
	SymInitialize( (HANDLE)-1, NULL, TRUE );

	if ( !NT_SUCCESS( SetInstrumentationCallbackHook( (HANDLE)-1, TRUE ) ) )
		printf( "failed to initialize syscall hooks\n" );
}

void uninstall_hooks( )
{
	/* uninstall inline hooks */
	MH_DisableHook( MH_ALL_HOOKS );
	MH_Uninitialize( );

	/* @todo: instrumentation callbacks */
}

extern "C" void* internal_cleancall_wow64_gate{ nullptr };

#pragma section(".text")
__declspec( allocate( ".text" ) ) const unsigned char jmp_rbx_0[ ] = { 0x1B, 0xFF, 0x23, 0xF8 };

int main( )
{
	/* allocate bytes for our test dll rop gadget */
	jmp_rbx_0;

	/* compute base and end addresses for ntdll/win32u to cache them for integrity checks */
	GetBaseAddresses();

	/* initialize WoW64 transition (Heavens Gate) */
	internal_cleancall_wow64_gate = ( void* ) __readfsdword( 0xC0 );

	/* initialize all function call hooks */
    install_hooks( );
	
	/* program loop */

	char input[ 255 ];

	do
	{

		printf( "--------------------------------------------------------------------------------------\n" );
		printf( "you can inject your preferred dll or select from the options below\n" );
		printf( "[1] verified loadlibrary\n" );
		printf( "[2] foreign loadlibrary\n" );
		printf( "[3] winapi iat - allocate memory\n" );
		printf( "[4] winapi eat - message box\n" );
		printf( "[5] winapi eat - allocate memory\n" );
		printf( "[6] winapi eat- message box\n" );
		printf( "[7] native iat - allocate memory\n" );
		printf( "[8] native iat - message box\n" );
		printf( "[9] native eat - allocate memory\n" );
		printf( "[10] native eat - message box\n" );
		printf( "[11] direct syscall - allocate memory\n" );
		printf( "[12] direct syscall - message box\n" );
		printf( "[13] exit program\n" );
		std::cin >> input;

		switch ( atoi( input ) )
		{
		case 1: // verified loadlibrary
		{
			/* tell our hook to allow calls to go through i.e. open the gate */
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "enabling loadlibrary calls...\n" );
			gate::loadlibrarya = true;

			/* our call is now authenticated */
			printf( "calling loadlibrary...\n" );
			auto dll_module = std::async( LoadLibraryA, "example_dll.dll" );
			FreeLibrary( dll_module.get( ) );

			/* tell our hook to prevent other calls from going through i.e. close the gate */
			printf( "disabling loadlibrary calls...\n" );
			gate::loadlibrarya = false;

			break;
		}
		case 2: // foreign loadlibrary
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "calling loadlibrary...\n" );
			auto dll_module = std::async( LoadLibraryA, "example_dll.dll" );
			FreeLibrary( dll_module.get( ) );

			break;
		}
		case 3: // winapi allocate
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "allocating memory...\n" );
			void* address{ VirtualAllocEx( GetCurrentProcess(), nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) };
			printf( "freeing memory...\n" );
			VirtualFreeEx( GetCurrentProcess( ), address, 0, MEM_RELEASE );

			break;
		}
		case 4: // winapi msgbox
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "calling messagebox...\n" );
			MessageBoxW( NULL, L"winapi call", L"title", MB_OK );

			break;
		}
		case 5: // winapi export allocate
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "allocating memory...\n" );

			break;
		}
		case 6: // winapi export msgbox
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "calling messagebox...\n" );
			const MessageBoxW_t messagebox_export{ reinterpret_cast< MessageBoxW_t >( GetProcAddress( GetModuleHandle( L"User32.dll" ), "MessageBoxW" ) ) };
			messagebox_export( NULL, L"export address call", L"title", MB_OK );

			break;
		}
		case 7: // native allocate
		{


			break;
		}
		case 8: // native msgbox
		{
			const wchar_t* body = L"native api";
			const wchar_t* caption = L"title";

			UNICODE_STRING msgBody;
			UNICODE_STRING msgCaption;

			ULONG ErrorResponse;

			msgBody.Length = ( wcslen( body ) + 1 ) * sizeof( wchar_t );
			msgBody.MaximumLength = msgBody.Length;
			msgBody.Buffer = ( PWSTR ) body;

			msgCaption.Length = ( wcslen( caption ) + 1 ) * sizeof( wchar_t );
			msgCaption.MaximumLength = msgCaption.Length;
			msgCaption.Buffer = ( PWSTR ) caption;

			const ULONG_PTR msgParams[ ] = {
			( ULONG_PTR ) &msgBody,
			( ULONG_PTR ) &msgCaption,
			( ULONG_PTR ) ( MB_OK )
			};

			ZwRaiseHardError( 0x50000018L, 0x00000003L, 3, ( PULONG_PTR ) msgParams, NULL, &ErrorResponse );

			break;
		}
		case 9: // native export allocate
		{


			break;
		}
		case 10: // native export msgbox
		{


			break;
		}
		case 11: // syscall allocate
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "calling NtAllocateVirtualMemory...\n" );

			void* address{ };
			SIZE_T region_size{ 0x1000 };
			if ( NT_ERROR( NtAllocateVirtualMemory( GetCurrentProcess( ), &address, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) ) )
			{
				printf( "could not allocate virtual memory\n" );
				break;
			}
			
			*reinterpret_cast< int* >( address ) = rand( );
			printf( "allocated memory at 0x%p\n", &address );
			printf( "value at address: %d\n", *reinterpret_cast< int* >( address ) );
			printf( "freeing memory...\n" );

			NtFreeVirtualMemory( address, &address, &region_size, MEM_RELEASE );

			break;
		}
		case 12: // syscall msgbox
		{
			printf( "--------------------------------------------------------------------------------------\n" );
			printf( "calling messagebox...\n" );
			syscall_msgbox( L"direct syscall", L"title" );

			break;
		}
		default:
			break;
		}

	} while ( atoi( input ) != 13 );

	/* remove the hooks */
	uninstall_hooks( );
}
```

`syscall/instrumentationcallbackproxy.asm`:

```asm
include ksamd64.inc
include CallConv.inc
.686

.model flat
public _InstrumentationCallbackProxy

assume fs:nothing
extern _instrumentation_callback:PROC

.code
_InstrumentationCallbackProxy PROC

    push    esp                         ; back-up ESP, ECX, and EAX to restore them
    push    ecx
    push    eax
    mov     eax, 1                      ; set EAX to 1 for comparison
    cmp     fs:1b8h, eax                ; see if the recurion flag has been set
    je      resume                      ; jump and restore the registers if it has and resume
    pop     eax
    pop     ecx
    pop     esp
    mov     fs:1b0h, ecx                ; InstrumentationCallbackPreviousPc
    mov     fs:1b4h, esp                ; InstrumentationCallbackPreviousSp
    
    pushad                              ; push registers to stack
    pushfd                              ; push flags to the stack
    cld                                 ; clear direction flag
    
    push    eax                         ; return value
    push    ecx                         ; return address
    call    _instrumentation_callback
    add     esp, 08h                    ; correct stack postion

    popfd                               ; restore stored flags
    popad                               ; restore stored registers

    mov     esp, fs:1b4h                ; restore ESP
    mov     ecx, fs:1b0h                ; restore ECX
    jmp     ecx                         ; resume execution
resume:
    pop     eax
    pop     ecx
     pop     esp
    jmp     ecx

_InstrumentationCallbackProxy ENDP

assume fs:error
end
```

`syscall/syscalls.c`:

```c

#include "syscalls.h"

// Code below is adapted from @modexpblog. Read linked article for more details.
// https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams

SW2_SYSCALL_LIST SW2_SyscallList;

DWORD SW2_HashSyscall(PCSTR FunctionName)
{
    DWORD i = 0;
    DWORD Hash = SW2_SEED;

    while (FunctionName[i])
    {
        WORD PartialName = *(WORD*)((ULONG64)FunctionName + i++);
        Hash ^= PartialName + SW2_ROR8(Hash);
    }

    return Hash;
}

BOOL SW2_PopulateSyscallList()
{
    // Return early if the list is already populated.
    if (SW2_SyscallList.Count) return TRUE;

    PSW2_PEB Peb = (PSW2_PEB)__readfsdword(0x30);
    PSW2_PEB_LDR_DATA Ldr = Peb->Ldr;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    PVOID DllBase = NULL;

    // Get the DllBase address of NTDLL.dll. NTDLL is not guaranteed to be the second
    // in the list, so it's safer to loop through the full list and find it.
    PSW2_LDR_DATA_TABLE_ENTRY LdrEntry;
    for (LdrEntry = (PSW2_LDR_DATA_TABLE_ENTRY)Ldr->Reserved2[1]; LdrEntry->DllBase != NULL; LdrEntry = (PSW2_LDR_DATA_TABLE_ENTRY)LdrEntry->Reserved1[0])
    {
        DllBase = LdrEntry->DllBase;
        PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)DllBase;
        PIMAGE_NT_HEADERS NtHeaders = SW2_RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader->e_lfanew);
        PIMAGE_DATA_DIRECTORY DataDirectory = (PIMAGE_DATA_DIRECTORY)NtHeaders->OptionalHeader.DataDirectory;
        DWORD VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
        if (VirtualAddress == 0) continue;

        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)SW2_RVA2VA(ULONG_PTR, DllBase, VirtualAddress);

        // If this is NTDLL.dll, exit loop.
        PCHAR DllName = SW2_RVA2VA(PCHAR, DllBase, ExportDirectory->Name);

        if ((*(ULONG*)DllName | 0x20202020) != 'ldtn') continue;
        if ((*(ULONG*)(DllName + 4) | 0x20202020) == 'ld.l') break;
    }

    if (!ExportDirectory) return FALSE;

    DWORD NumberOfNames = ExportDirectory->NumberOfNames;
    PDWORD Functions = SW2_RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfFunctions);
    PDWORD Names = SW2_RVA2VA(PDWORD, DllBase, ExportDirectory->AddressOfNames);
    PWORD Ordinals = SW2_RVA2VA(PWORD, DllBase, ExportDirectory->AddressOfNameOrdinals);

    // Populate SW2_SyscallList with unsorted Zw* entries.
    DWORD i = 0;
    PSW2_SYSCALL_ENTRY Entries = SW2_SyscallList.Entries;
    do
    {
        PCHAR FunctionName = SW2_RVA2VA(PCHAR, DllBase, Names[NumberOfNames - 1]);

        // Is this a system call?
        if (*(USHORT*)FunctionName == 'wZ')
        {
            Entries[i].Hash = SW2_HashSyscall(FunctionName);
            Entries[i].Address = Functions[Ordinals[NumberOfNames - 1]];

            i++;
            if (i == SW2_MAX_ENTRIES) break;
        }
    } while (--NumberOfNames);

    // Save total number of system calls found.
    SW2_SyscallList.Count = i;

    // Sort the list by address in ascending order.
    for (DWORD i = 0; i < SW2_SyscallList.Count - 1; i++)
    {
        for (DWORD j = 0; j < SW2_SyscallList.Count - i - 1; j++)
        {
            if (Entries[j].Address > Entries[j + 1].Address)
            {
                // Swap entries.
                SW2_SYSCALL_ENTRY TempEntry;

                TempEntry.Hash = Entries[j].Hash;
                TempEntry.Address = Entries[j].Address;

                Entries[j].Hash = Entries[j + 1].Hash;
                Entries[j].Address = Entries[j + 1].Address;

                Entries[j + 1].Hash = TempEntry.Hash;
                Entries[j + 1].Address = TempEntry.Address;
            }
        }
    }

    return TRUE;
}

EXTERN_C DWORD SW2_GetSyscallNumber(DWORD FunctionHash)
{
    // Ensure SW2_SyscallList is populated.
    if (!SW2_PopulateSyscallList()) return -1;

    for (DWORD i = 0; i < SW2_SyscallList.Count; i++)
    {
        if (FunctionHash == SW2_SyscallList.Entries[i].Hash)
        {
            return i;
        }
    }

    return -1;
}
```

`syscall/syscalls.h`:

```h
#pragma once

// Code below is adapted from @modexpblog. Read linked article for more details.
// https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams

#ifndef SW2_HEADER_H_
#define SW2_HEADER_H_

#include <Windows.h>

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

#define SW2_SEED 0x874DD416
#define SW2_ROL8(v) (v << 8 | v >> 24)
#define SW2_ROR8(v) (v >> 8 | v << 24)
#define SW2_ROX8(v) ((SW2_SEED % 2) ? SW2_ROL8(v) : SW2_ROR8(v))
#define SW2_MAX_ENTRIES 500
#define SW2_RVA2VA(Type, DllBase, Rva) (Type)((ULONG_PTR) DllBase + Rva)

// Typedefs are prefixed to avoid pollution.

typedef struct _SW2_SYSCALL_ENTRY
{
	DWORD Hash;
	DWORD Address;
} SW2_SYSCALL_ENTRY, * PSW2_SYSCALL_ENTRY;

typedef struct _SW2_SYSCALL_LIST
{
	DWORD Count;
	SW2_SYSCALL_ENTRY Entries[SW2_MAX_ENTRIES];
} SW2_SYSCALL_LIST, * PSW2_SYSCALL_LIST;

typedef struct _SW2_PEB_LDR_DATA {
	BYTE Reserved1[8];
	PVOID Reserved2[3];
	LIST_ENTRY InMemoryOrderModuleList;
} SW2_PEB_LDR_DATA, * PSW2_PEB_LDR_DATA;

typedef struct _SW2_LDR_DATA_TABLE_ENTRY {
	PVOID Reserved1[2];
	LIST_ENTRY InMemoryOrderLinks;
	PVOID Reserved2[2];
	PVOID DllBase;
} SW2_LDR_DATA_TABLE_ENTRY, * PSW2_LDR_DATA_TABLE_ENTRY;

typedef struct _SW2_PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PSW2_PEB_LDR_DATA Ldr;
} SW2_PEB, * PSW2_PEB;

DWORD SW2_HashSyscall(PCSTR FunctionName);
BOOL SW2_PopulateSyscallList();
EXTERN_C DWORD SW2_GetSyscallNumber(DWORD FunctionHash);

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _SYSTEM_HANDLE
{
	ULONG ProcessId;
	BYTE ObjectTypeNumber;
	BYTE Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
	PVOID pValue;
	ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, * PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
	ULONG64        Version;
	UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, * PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _WNF_TYPE_ID
{
	GUID TypeId;
} WNF_TYPE_ID, * PWNF_TYPE_ID;

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS Status;
		VOID* Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef enum _KCONTINUE_TYPE
{
	KCONTINUE_UNWIND,
	KCONTINUE_RESUME,
	KCONTINUE_LONGJUMP,
	KCONTINUE_SET,
	KCONTINUE_LAST
} KCONTINUE_TYPE;

typedef enum _PS_CREATE_STATE
{
	PsCreateInitialState,
	PsCreateFailOnFileOpen,
	PsCreateFailOnSectionCreate,
	PsCreateFailExeFormat,
	PsCreateFailMachineMismatch,
	PsCreateFailExeName,
	PsCreateSuccess,
	PsCreateMaximumStates
} PS_CREATE_STATE, * PPS_CREATE_STATE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef enum _PLUGPLAY_EVENT_CATEGORY
{
	HardwareProfileChangeEvent,
	TargetDeviceChangeEvent,
	DeviceClassChangeEvent,
	CustomDeviceEvent,
	DeviceInstallEvent,
	DeviceArrivalEvent,
	PowerEvent,
	VetoEvent,
	BlockedDriverEvent,
	InvalidIDEvent,
	MaxPlugEventCategory
} PLUGPLAY_EVENT_CATEGORY, * PPLUGPLAY_EVENT_CATEGORY;

typedef enum _PNP_VETO_TYPE
{
	PNP_VetoTypeUnknown, // unspecified
	PNP_VetoLegacyDevice, // instance path
	PNP_VetoPendingClose, // instance path
	PNP_VetoWindowsApp, // module
	PNP_VetoWindowsService, // service
	PNP_VetoOutstandingOpen, // instance path
	PNP_VetoDevice, // instance path
	PNP_VetoDriver, // driver service name
	PNP_VetoIllegalDeviceRequest, // instance path
	PNP_VetoInsufficientPower, // unspecified
	PNP_VetoNonDisableable, // instance path
	PNP_VetoLegacyDriver, // service
	PNP_VetoInsufficientRights  // unspecified
} PNP_VETO_TYPE, * PPNP_VETO_TYPE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
	UNICODE_STRING Name;
	USHORT         ValueType;
	USHORT         Reserved;
	ULONG          Flags;
	ULONG          ValueCount;
	union
	{
		PLONG64                                      pInt64;
		PULONG64                                     pUint64;
		PUNICODE_STRING                              pString;
		PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE         pFqbn;
		PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
	} Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, * PTOKEN_SECURITY_ATTRIBUTE_V1;

typedef VOID(KNORMAL_ROUTINE) (
	IN PVOID NormalContext,
	IN PVOID SystemArgument1,
	IN PVOID SystemArgument2);

typedef struct _PS_ATTRIBUTE
{
	ULONG  Attribute;
	SIZE_T Size;
	union
	{
		ULONG Value;
		PVOID ValuePtr;
	} u1;
	PSIZE_T ReturnLength;
} PS_ATTRIBUTE, * PPS_ATTRIBUTE;

typedef struct _WNF_STATE_NAME
{
	ULONG Data[2];
} WNF_STATE_NAME, * PWNF_STATE_NAME;

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) { \
	(p)->Length = sizeof( OBJECT_ATTRIBUTES );        \
	(p)->RootDirectory = r;                           \
	(p)->Attributes = a;                              \
	(p)->ObjectName = n;                              \
	(p)->SecurityDescriptor = s;                      \
	(p)->SecurityQualityOfService = NULL;             \
}
#endif

typedef struct _KEY_VALUE_ENTRY
{
	PUNICODE_STRING ValueName;
	ULONG           DataLength;
	ULONG           DataOffset;
	ULONG           Type;
} KEY_VALUE_ENTRY, * PKEY_VALUE_ENTRY;

typedef enum _KEY_SET_INFORMATION_CLASS
{
	KeyWriteTimeInformation,
	KeyWow64FlagsInformation,
	KeyControlFlagsInformation,
	KeySetVirtualizationInformation,
	KeySetDebugInformation,
	KeySetHandleTagsInformation,
	MaxKeySetInfoClass  // MaxKeySetInfoClass should always be the last enum.
} KEY_SET_INFORMATION_CLASS, * PKEY_SET_INFORMATION_CLASS;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemProcessInformation = 5,
	SystemProcessorPerformanceInformation = 8,
	SystemHandleInformation = 16,
	SystemInterruptInformation = 23,
	SystemExceptionInformation = 33,
	SystemRegistryQuotaInformation = 37,
	SystemLookasideInformation = 45,
	SystemCodeIntegrityInformation = 103,
	SystemPolicyInformation = 134,
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation = 0,
	ProcessDebugPort = 7,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessBreakOnTermination = 29
} PROCESSINFOCLASS, * PPROCESSINFOCLASS;

typedef struct _MEMORY_RANGE_ENTRY
{
	PVOID  VirtualAddress;
	SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, * PMEMORY_RANGE_ENTRY;

typedef struct _T2_SET_PARAMETERS_V0
{
	ULONG    Version;
	ULONG    Reserved;
	LONGLONG NoWakeTolerance;
} T2_SET_PARAMETERS, * PT2_SET_PARAMETERS;

typedef struct _FILE_PATH
{
	ULONG Version;
	ULONG Length;
	ULONG Type;
	CHAR  FilePath[1];
} FILE_PATH, * PFILE_PATH;

typedef struct _FILE_USER_QUOTA_INFORMATION
{
	ULONG         NextEntryOffset;
	ULONG         SidLength;
	LARGE_INTEGER ChangeTime;
	LARGE_INTEGER QuotaUsed;
	LARGE_INTEGER QuotaThreshold;
	LARGE_INTEGER QuotaLimit;
	SID           Sid[1];
} FILE_USER_QUOTA_INFORMATION, * PFILE_USER_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_LIST_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG SidLength;
	SID   Sid[1];
} FILE_QUOTA_LIST_INFORMATION, * PFILE_QUOTA_LIST_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG         FileAttributes;
	ULONG         Unknown;
} FILE_NETWORK_OPEN_INFORMATION, * PFILE_NETWORK_OPEN_INFORMATION;

typedef enum _FILTER_BOOT_OPTION_OPERATION
{
	FilterBootOptionOperationOpenSystemStore,
	FilterBootOptionOperationSetElement,
	FilterBootOptionOperationDeleteElement,
	FilterBootOptionOperationMax
} FILTER_BOOT_OPTION_OPERATION, * PFILTER_BOOT_OPTION_OPERATION;

typedef enum _EVENT_TYPE
{
	NotificationEvent = 0,
	SynchronizationEvent = 1,
} EVENT_TYPE, * PEVENT_TYPE;

typedef struct _FILE_FULL_EA_INFORMATION
{
	ULONG  NextEntryOffset;
	UCHAR  Flags;
	UCHAR  EaNameLength;
	USHORT EaValueLength;
	CHAR   EaName[1];
} FILE_FULL_EA_INFORMATION, * PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION
{
	ULONG NextEntryOffset;
	BYTE  EaNameLength;
	CHAR  EaName[1];
} FILE_GET_EA_INFORMATION, * PFILE_GET_EA_INFORMATION;

typedef struct _BOOT_OPTIONS
{
	ULONG Version;
	ULONG Length;
	ULONG Timeout;
	ULONG CurrentBootEntryId;
	ULONG NextBootEntryId;
	WCHAR HeadlessRedirection[1];
} BOOT_OPTIONS, * PBOOT_OPTIONS;

typedef ULONG WNF_CHANGE_STAMP, * PWNF_CHANGE_STAMP;

typedef enum _WNF_DATA_SCOPE
{
	WnfDataScopeSystem = 0,
	WnfDataScopeSession = 1,
	WnfDataScopeUser = 2,
	WnfDataScopeProcess = 3,
	WnfDataScopeMachine = 4
} WNF_DATA_SCOPE, * PWNF_DATA_SCOPE;

typedef enum _WNF_STATE_NAME_LIFETIME
{
	WnfWellKnownStateName = 0,
	WnfPermanentStateName = 1,
	WnfPersistentStateName = 2,
	WnfTemporaryStateName = 3
} WNF_STATE_NAME_LIFETIME, * PWNF_STATE_NAME_LIFETIME;

typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS
{
	VmPrefetchInformation,
	VmPagePriorityInformation,
	VmCfgCallTargetInformation
} VIRTUAL_MEMORY_INFORMATION_CLASS, * PVIRTUAL_MEMORY_INFORMATION_CLASS;

typedef enum _IO_SESSION_EVENT
{
	IoSessionEventIgnore,
	IoSessionEventCreated,
	IoSessionEventTerminated,
	IoSessionEventConnected,
	IoSessionEventDisconnected,
	IoSessionEventLogon,
	IoSessionEventLogoff,
	IoSessionEventMax
} IO_SESSION_EVENT, * PIO_SESSION_EVENT;

typedef enum _PORT_INFORMATION_CLASS
{
	PortBasicInformation,
#if DEVL
	PortDumpInformation
#endif
} PORT_INFORMATION_CLASS, * PPORT_INFORMATION_CLASS;

typedef enum _PLUGPLAY_CONTROL_CLASS
{
	PlugPlayControlEnumerateDevice,
	PlugPlayControlRegisterNewDevice,
	PlugPlayControlDeregisterDevice,
	PlugPlayControlInitializeDevice,
	PlugPlayControlStartDevice,
	PlugPlayControlUnlockDevice,
	PlugPlayControlQueryAndRemoveDevice,
	PlugPlayControlUserResponse,
	PlugPlayControlGenerateLegacyDevice,
	PlugPlayControlGetInterfaceDeviceList,
	PlugPlayControlProperty,
	PlugPlayControlDeviceClassAssociation,
	PlugPlayControlGetRelatedDevice,
	PlugPlayControlGetInterfaceDeviceAlias,
	PlugPlayControlDeviceStatus,
	PlugPlayControlGetDeviceDepth,
	PlugPlayControlQueryDeviceRelations,
	PlugPlayControlTargetDeviceRelation,
	PlugPlayControlQueryConflictList,
	PlugPlayControlRetrieveDock,
	PlugPlayControlResetDevice,
	PlugPlayControlHaltDevice,
	PlugPlayControlGetBlockedDriverList,
	MaxPlugPlayControl
} PLUGPLAY_CONTROL_CLASS, * PPLUGPLAY_CONTROL_CLASS;

typedef enum _IO_COMPLETION_INFORMATION_CLASS
{
	IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS, * PIO_COMPLETION_INFORMATION_CLASS;

typedef enum _SECTION_INHERIT
{
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT, * PSECTION_INHERIT;

typedef enum _DEBUGOBJECTINFOCLASS
{
	DebugObjectFlags = 1,
	MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, * PDEBUGOBJECTINFOCLASS;

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
	SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS, * PSEMAPHORE_INFORMATION_CLASS;

typedef struct _PS_ATTRIBUTE_LIST
{
	SIZE_T       TotalLength;
	PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, * PPS_ATTRIBUTE_LIST;

typedef enum _VDMSERVICECLASS
{
	VdmStartExecution,
	VdmQueueInterrupt,
	VdmDelayInterrupt,
	VdmInitialize,
	VdmFeatures,
	VdmSetInt21Handler,
	VdmQueryDir,
	VdmPrinterDirectIoOpen,
	VdmPrinterDirectIoClose,
	VdmPrinterInitialize,
	VdmSetLdtEntries,
	VdmSetProcessLdtInfo,
	VdmAdlibEmulation,
	VdmPMCliControl,
	VdmQueryVdmProcess
} VDMSERVICECLASS, * PVDMSERVICECLASS;

typedef struct _PS_CREATE_INFO
{
	SIZE_T Size;
	PS_CREATE_STATE State;
	union
	{
		// PsCreateInitialState
		struct {
			union {
				ULONG InitFlags;
				struct {
					UCHAR  WriteOutputOnExit : 1;
					UCHAR  DetectManifest : 1;
					UCHAR  IFEOSkipDebugger : 1;
					UCHAR  IFEODoNotPropagateKeyState : 1;
					UCHAR  SpareBits1 : 4;
					UCHAR  SpareBits2 : 8;
					USHORT ProhibitedImageCharacteristics : 16;
				};
			};
			ACCESS_MASK AdditionalFileAccess;
		} InitState;
		// PsCreateFailOnSectionCreate
		struct {
			HANDLE FileHandle;
		} FailSection;
		// PsCreateFailExeFormat
		struct {
			USHORT DllCharacteristics;
		} ExeFormat;
		// PsCreateFailExeName
		struct {
			HANDLE IFEOKey;
		} ExeName;
		// PsCreateSuccess
		struct {
			union {
				ULONG OutputFlags;
				struct {
					UCHAR  ProtectedProcess : 1;
					UCHAR  AddressSpaceOverride : 1;
					UCHAR  DevOverrideEnabled : 1; // from Image File Execution Options
					UCHAR  ManifestDetected : 1;
					UCHAR  ProtectedProcessLight : 1;
					UCHAR  SpareBits1 : 3;
					UCHAR  SpareBits2 : 8;
					USHORT SpareBits3 : 16;
				};
			};
			HANDLE    FileHandle;
			HANDLE    SectionHandle;
			ULONGLONG UserProcessParametersNative;
			ULONG     UserProcessParametersWow64;
			ULONG     CurrentParameterFlags;
			ULONGLONG PebAddressNative;
			ULONG     PebAddressWow64;
			ULONGLONG ManifestAddress;
			ULONG     ManifestSize;
		} SuccessState;
	};
} PS_CREATE_INFO, * PPS_CREATE_INFO;

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation,
	MemorySharedCommitInformation,
	MemoryImageInformation,
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation,
	MemoryEnclaveImageInformation,
	MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS, * PMEMORY_INFORMATION_CLASS;

typedef enum _MEMORY_RESERVE_TYPE
{
	MemoryReserveUserApc,
	MemoryReserveIoCompletion,
	MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE, * PMEMORY_RESERVE_TYPE;

typedef enum _ALPC_PORT_INFORMATION_CLASS
{
	AlpcBasicInformation,
	AlpcPortInformation,
	AlpcAssociateCompletionPortInformation,
	AlpcConnectedSIDInformation,
	AlpcServerInformation,
	AlpcMessageZoneInformation,
	AlpcRegisterCompletionListInformation,
	AlpcUnregisterCompletionListInformation,
	AlpcAdjustCompletionListConcurrencyCountInformation,
	AlpcRegisterCallbackInformation,
	AlpcCompletionListRundownInformation
} ALPC_PORT_INFORMATION_CLASS, * PALPC_PORT_INFORMATION_CLASS;

typedef struct _ALPC_CONTEXT_ATTR
{
	PVOID PortContext;
	PVOID MessageContext;
	ULONG SequenceNumber;
	ULONG MessageID;
	ULONG CallbackID;
} ALPC_CONTEXT_ATTR, * PALPC_CONTEXT_ATTR;

typedef struct _ALPC_DATA_VIEW_ATTR
{
	ULONG  Flags;
	HANDLE SectionHandle;
	PVOID  ViewBase;
	SIZE_T ViewSize;
} ALPC_DATA_VIEW_ATTR, * PALPC_DATA_VIEW_ATTR;

typedef struct _ALPC_SECURITY_ATTR
{
	ULONG                        Flags;
	PSECURITY_QUALITY_OF_SERVICE SecurityQos;
	HANDLE                       ContextHandle;
	ULONG                        Reserved1;
	ULONG                        Reserved2;
} ALPC_SECURITY_ATTR, * PALPC_SECURITY_ATTR;

typedef PVOID* PPVOID;

typedef enum _KPROFILE_SOURCE
{
	ProfileTime = 0,
	ProfileAlignmentFixup = 1,
	ProfileTotalIssues = 2,
	ProfilePipelineDry = 3,
	ProfileLoadInstructions = 4,
	ProfilePipelineFrozen = 5,
	ProfileBranchInstructions = 6,
	ProfileTotalNonissues = 7,
	ProfileDcacheMisses = 8,
	ProfileIcacheMisses = 9,
	ProfileCacheMisses = 10,
	ProfileBranchMispredictions = 11,
	ProfileStoreInstructions = 12,
	ProfileFpInstructions = 13,
	ProfileIntegerInstructions = 14,
	Profile2Issue = 15,
	Profile3Issue = 16,
	Profile4Issue = 17,
	ProfileSpecialInstructions = 18,
	ProfileTotalCycles = 19,
	ProfileIcacheIssues = 20,
	ProfileDcacheAccesses = 21,
	ProfileMemoryBarrierCycles = 22,
	ProfileLoadLinkedIssues = 23,
	ProfileMaximum = 24,
} KPROFILE_SOURCE, * PKPROFILE_SOURCE;

typedef enum _ALPC_MESSAGE_INFORMATION_CLASS
{
	AlpcMessageSidInformation,
	AlpcMessageTokenModifiedIdInformation
} ALPC_MESSAGE_INFORMATION_CLASS, * PALPC_MESSAGE_INFORMATION_CLASS;

typedef enum _WORKERFACTORYINFOCLASS
{
	WorkerFactoryTimeout,
	WorkerFactoryRetryTimeout,
	WorkerFactoryIdleTimeout,
	WorkerFactoryBindingCount,
	WorkerFactoryThreadMinimum,
	WorkerFactoryThreadMaximum,
	WorkerFactoryPaused,
	WorkerFactoryBasicInformation,
	WorkerFactoryAdjustThreadGoal,
	WorkerFactoryCallbackType,
	WorkerFactoryStackInformation,
	MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, * PWORKERFACTORYINFOCLASS;

typedef enum _MEMORY_PARTITION_INFORMATION_CLASS
{
	SystemMemoryPartitionInformation,
	SystemMemoryPartitionMoveMemory,
	SystemMemoryPartitionAddPagefile,
	SystemMemoryPartitionCombineMemory,
	SystemMemoryPartitionInitialAddMemory,
	SystemMemoryPartitionGetMemoryEvents,
	SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS, * PMEMORY_PARTITION_INFORMATION_CLASS;

typedef enum _MUTANT_INFORMATION_CLASS
{
	MutantBasicInformation,
	MutantOwnerInformation
} MUTANT_INFORMATION_CLASS, * PMUTANT_INFORMATION_CLASS;

typedef enum _ATOM_INFORMATION_CLASS
{
	AtomBasicInformation,
	AtomTableInformation
} ATOM_INFORMATION_CLASS, * PATOM_INFORMATION_CLASS;

typedef enum _SHUTDOWN_ACTION {
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION;

typedef VOID(CALLBACK* PTIMER_APC_ROUTINE)(
	IN PVOID TimerContext,
	IN ULONG TimerLowValue,
	IN LONG TimerHighValue);

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation = 0,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef LANGID* PLANGID;

typedef struct _PLUGPLAY_EVENT_BLOCK
{
	GUID EventGuid;
	PLUGPLAY_EVENT_CATEGORY EventCategory;
	PULONG Result;
	ULONG Flags;
	ULONG TotalSize;
	PVOID DeviceObject;

	union
	{
		struct
		{
			GUID ClassGuid;
			WCHAR SymbolicLinkName[1];
		} DeviceClass;
		struct
		{
			WCHAR DeviceIds[1];
		} TargetDevice;
		struct
		{
			WCHAR DeviceId[1];
		} InstallDevice;
		struct
		{
			PVOID NotificationStructure;
			WCHAR DeviceIds[1];
		} CustomNotification;
		struct
		{
			PVOID Notification;
		} ProfileNotification;
		struct
		{
			ULONG NotificationCode;
			ULONG NotificationData;
		} PowerNotification;
		struct
		{
			PNP_VETO_TYPE VetoType;
			WCHAR DeviceIdVetoNameBuffer[1]; // DeviceId<null>VetoName<null><null>
		} VetoNotification;
		struct
		{
			GUID BlockedDriverGuid;
		} BlockedDriverNotification;
		struct
		{
			WCHAR ParentId[1];
		} InvalidIDNotification;
	} u;
} PLUGPLAY_EVENT_BLOCK, * PPLUGPLAY_EVENT_BLOCK;

typedef VOID(NTAPI* PIO_APC_ROUTINE) (
	IN PVOID            ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG            Reserved);

typedef KNORMAL_ROUTINE* PKNORMAL_ROUTINE;

typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS
{
	DirectoryNotifyInformation = 1,
	DirectoryNotifyExtendedInformation = 2,
} DIRECTORY_NOTIFY_INFORMATION_CLASS, * PDIRECTORY_NOTIFY_INFORMATION_CLASS;

typedef enum _EVENT_INFORMATION_CLASS
{
	EventBasicInformation
} EVENT_INFORMATION_CLASS, * PEVENT_INFORMATION_CLASS;

typedef struct _ALPC_MESSAGE_ATTRIBUTES
{
	unsigned long AllocatedAttributes;
	unsigned long ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES, * PALPC_MESSAGE_ATTRIBUTES;

typedef struct _ALPC_PORT_ATTRIBUTES
{
	ULONG                       Flags;
	SECURITY_QUALITY_OF_SERVICE SecurityQos;
	SIZE_T                      MaxMessageLength;
	SIZE_T                      MemoryBandwidth;
	SIZE_T                      MaxPoolUsage;
	SIZE_T                      MaxSectionSize;
	SIZE_T                      MaxViewSize;
	SIZE_T                      MaxTotalSectionSize;
	ULONG                       DupObjectTypes;
#ifdef _WIN64
	ULONG                       Reserved;
#endif
} ALPC_PORT_ATTRIBUTES, * PALPC_PORT_ATTRIBUTES;

typedef enum _IO_SESSION_STATE
{
	IoSessionStateCreated = 1,
	IoSessionStateInitialized = 2,
	IoSessionStateConnected = 3,
	IoSessionStateDisconnected = 4,
	IoSessionStateDisconnectedLoggedOn = 5,
	IoSessionStateLoggedOn = 6,
	IoSessionStateLoggedOff = 7,
	IoSessionStateTerminated = 8,
	IoSessionStateMax = 9,
} IO_SESSION_STATE, * PIO_SESSION_STATE;

typedef const WNF_STATE_NAME* PCWNF_STATE_NAME;

typedef const WNF_TYPE_ID* PCWNF_TYPE_ID;

typedef struct _WNF_DELIVERY_DESCRIPTOR
{
	unsigned __int64 SubscriptionId;
	WNF_STATE_NAME   StateName;
	unsigned long    ChangeStamp;
	unsigned long    StateDataSize;
	unsigned long    EventMask;
	WNF_TYPE_ID      TypeId;
	unsigned long    StateDataOffset;
} WNF_DELIVERY_DESCRIPTOR, * PWNF_DELIVERY_DESCRIPTOR;

typedef enum _DEBUG_CONTROL_CODE
{
	SysDbgQueryModuleInformation = 0,
	SysDbgQueryTraceInformation = 1,
	SysDbgSetTracePoint = 2,
	SysDbgSetSpecialCall = 3,
	SysDbgClearSpecialCalls = 4,
	SysDbgQuerySpecialCalls = 5,
	SysDbgBreakPoint = 6,
	SysDbgQueryVersion = 7,
	SysDbgReadVirtual = 8,
	SysDbgWriteVirtual = 9,
	SysDbgReadPhysical = 10,
	SysDbgWritePhysical = 11,
	SysDbgReadControlSpace = 12,
	SysDbgWriteControlSpace = 13,
	SysDbgReadIoSpace = 14,
	SysDbgWriteIoSpace = 15,
	SysDbgReadMsr = 16,
	SysDbgWriteMsr = 17,
	SysDbgReadBusData = 18,
	SysDbgWriteBusData = 19,
	SysDbgCheckLowMemory = 20,
	SysDbgEnableKernelDebugger = 21,
	SysDbgDisableKernelDebugger = 22,
	SysDbgGetAutoKdEnable = 23,
	SysDbgSetAutoKdEnable = 24,
	SysDbgGetPrintBufferSize = 25,
	SysDbgSetPrintBufferSize = 26,
	SysDbgGetKdUmExceptionEnable = 27,
	SysDbgSetKdUmExceptionEnable = 28,
	SysDbgGetTriageDump = 29,
	SysDbgGetKdBlockEnable = 30,
	SysDbgSetKdBlockEnable = 31
} DEBUG_CONTROL_CODE, * PDEBUG_CONTROL_CODE;

typedef struct _PORT_MESSAGE
{
	union
	{
		union
		{
			struct
			{
				short DataLength;
				short TotalLength;
			} s1;
			unsigned long Length;
		};
	} u1;
	union
	{
		union
		{
			struct
			{
				short Type;
				short DataInfoOffset;
			} s2;
			unsigned long ZeroInit;
		};
	} u2;
	union
	{
		CLIENT_ID ClientId;
		double    DoNotUseThisField;
	};
	unsigned long MessageId;
	union
	{
		unsigned __int64 ClientViewSize;
		struct
		{
			unsigned long CallbackId;
			long          __PADDING__[1];
		};
	};
} PORT_MESSAGE, * PPORT_MESSAGE;

typedef struct FILE_BASIC_INFORMATION
{
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	ULONG         FileAttributes;
} FILE_BASIC_INFORMATION, * PFILE_BASIC_INFORMATION;

typedef struct _PORT_SECTION_READ
{
	ULONG Length;
	ULONG ViewSize;
	ULONG ViewBase;
} PORT_SECTION_READ, * PPORT_SECTION_READ;

typedef struct _PORT_SECTION_WRITE
{
	ULONG  Length;
	HANDLE SectionHandle;
	ULONG  SectionOffset;
	ULONG  ViewSize;
	PVOID  ViewBase;
	PVOID  TargetViewBase;
} PORT_SECTION_WRITE, * PPORT_SECTION_WRITE;

typedef enum _TIMER_TYPE
{
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE, * PTIMER_TYPE;

typedef struct _BOOT_ENTRY
{
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG Attributes;
	ULONG FriendlyNameOffset;
	ULONG BootFilePathOffset;
	ULONG OsOptionsLength;
	UCHAR OsOptions[ANYSIZE_ARRAY];
} BOOT_ENTRY, * PBOOT_ENTRY;

typedef struct _EFI_DRIVER_ENTRY
{
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG Attributes;
	ULONG FriendlyNameOffset;
	ULONG DriverFilePathOffset;
} EFI_DRIVER_ENTRY, * PEFI_DRIVER_ENTRY;

typedef USHORT RTL_ATOM, * PRTL_ATOM;

typedef enum _TIMER_SET_INFORMATION_CLASS
{
	TimerSetCoalescableTimer,
	MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS, * PTIMER_SET_INFORMATION_CLASS;

typedef enum _FSINFOCLASS
{
	FileFsVolumeInformation = 1,
	FileFsLabelInformation = 2,
	FileFsSizeInformation = 3,
	FileFsDeviceInformation = 4,
	FileFsAttributeInformation = 5,
	FileFsControlInformation = 6,
	FileFsFullSizeInformation = 7,
	FileFsObjectIdInformation = 8,
	FileFsDriverPathInformation = 9,
	FileFsVolumeFlagsInformation = 10,
	FileFsSectorSizeInformation = 11,
	FileFsDataCopyInformation = 12,
	FileFsMetadataSizeInformation = 13,
	FileFsFullSizeInformationEx = 14,
	FileFsMaximumInformation = 15,
} FSINFOCLASS, * PFSINFOCLASS;

typedef enum _WAIT_TYPE
{
	WaitAll = 0,
	WaitAny = 1
} WAIT_TYPE, * PWAIT_TYPE;

typedef struct _USER_STACK
{
	PVOID FixedStackBase;
	PVOID FixedStackLimit;
	PVOID ExpandableStackBase;
	PVOID ExpandableStackLimit;
	PVOID ExpandableStackBottom;
} USER_STACK, * PUSER_STACK;

typedef enum _SECTION_INFORMATION_CLASS
{
	SectionBasicInformation,
	SectionImageInformation,
} SECTION_INFORMATION_CLASS, * PSECTION_INFORMATION_CLASS;

typedef enum _APPHELPCACHESERVICECLASS
{
	ApphelpCacheServiceLookup = 0,
	ApphelpCacheServiceRemove = 1,
	ApphelpCacheServiceUpdate = 2,
	ApphelpCacheServiceFlush = 3,
	ApphelpCacheServiceDump = 4,
	ApphelpDBGReadRegistry = 0x100,
	ApphelpDBGWriteRegistry = 0x101,
} APPHELPCACHESERVICECLASS, * PAPPHELPCACHESERVICECLASS;

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
	USHORT Version;
	USHORT Reserved;
	ULONG  AttributeCount;
	union
	{
		PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
	} Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, * PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

typedef struct _FILE_IO_COMPLETION_INFORMATION
{
	PVOID           KeyContext;
	PVOID           ApcContext;
	IO_STATUS_BLOCK IoStatusBlock;
} FILE_IO_COMPLETION_INFORMATION, * PFILE_IO_COMPLETION_INFORMATION;

typedef PVOID PT2_CANCEL_PARAMETERS;

typedef enum _THREADINFOCLASS
{
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair_Reusable,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger,
	ThreadBreakOnTermination,
	MaxThreadInfoClass
} THREADINFOCLASS, * PTHREADINFOCLASS;

typedef enum _OBJECT_INFORMATION_CLASS
{
	ObjectBasicInformation,
	ObjectNameInformation,
	ObjectTypeInformation,
	ObjectAllTypesInformation,
	ObjectHandleInformation
} OBJECT_INFORMATION_CLASS, * POBJECT_INFORMATION_CLASS;

typedef enum _FILE_INFORMATION_CLASS
{
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation = 2,
	FileBothDirectoryInformation = 3,
	FileBasicInformation = 4,
	FileStandardInformation = 5,
	FileInternalInformation = 6,
	FileEaInformation = 7,
	FileAccessInformation = 8,
	FileNameInformation = 9,
	FileRenameInformation = 10,
	FileLinkInformation = 11,
	FileNamesInformation = 12,
	FileDispositionInformation = 13,
	FilePositionInformation = 14,
	FileFullEaInformation = 15,
	FileModeInformation = 16,
	FileAlignmentInformation = 17,
	FileAllInformation = 18,
	FileAllocationInformation = 19,
	FileEndOfFileInformation = 20,
	FileAlternateNameInformation = 21,
	FileStreamInformation = 22,
	FilePipeInformation = 23,
	FilePipeLocalInformation = 24,
	FilePipeRemoteInformation = 25,
	FileMailslotQueryInformation = 26,
	FileMailslotSetInformation = 27,
	FileCompressionInformation = 28,
	FileObjectIdInformation = 29,
	FileCompletionInformation = 30,
	FileMoveClusterInformation = 31,
	FileQuotaInformation = 32,
	FileReparsePointInformation = 33,
	FileNetworkOpenInformation = 34,
	FileAttributeTagInformation = 35,
	FileTrackingInformation = 36,
	FileIdBothDirectoryInformation = 37,
	FileIdFullDirectoryInformation = 38,
	FileValidDataLengthInformation = 39,
	FileShortNameInformation = 40,
	FileIoCompletionNotificationInformation = 41,
	FileIoStatusBlockRangeInformation = 42,
	FileIoPriorityHintInformation = 43,
	FileSfioReserveInformation = 44,
	FileSfioVolumeInformation = 45,
	FileHardLinkInformation = 46,
	FileProcessIdsUsingFileInformation = 47,
	FileNormalizedNameInformation = 48,
	FileNetworkPhysicalNameInformation = 49,
	FileIdGlobalTxDirectoryInformation = 50,
	FileIsRemoteDeviceInformation = 51,
	FileUnusedInformation = 52,
	FileNumaNodeInformation = 53,
	FileStandardLinkInformation = 54,
	FileRemoteProtocolInformation = 55,
	FileRenameInformationBypassAccessCheck = 56,
	FileLinkInformationBypassAccessCheck = 57,
	FileVolumeNameInformation = 58,
	FileIdInformation = 59,
	FileIdExtdDirectoryInformation = 60,
	FileReplaceCompletionInformation = 61,
	FileHardLinkFullIdInformation = 62,
	FileIdExtdBothDirectoryInformation = 63,
	FileDispositionInformationEx = 64,
	FileRenameInformationEx = 65,
	FileRenameInformationExBypassAccessCheck = 66,
	FileMaximumInformation = 67,
} FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;

typedef enum _KEY_INFORMATION_CLASS
{
	KeyBasicInformation = 0,
	KeyNodeInformation = 1,
	KeyFullInformation = 2,
	KeyNameInformation = 3,
	KeyCachedInformation = 4,
	KeyFlagsInformation = 5,
	KeyVirtualizationInformation = 6,
	KeyHandleTagsInformation = 7,
	MaxKeyInfoClass = 8
} KEY_INFORMATION_CLASS, * PKEY_INFORMATION_CLASS;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG           Length;
	HANDLE          RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG           Attributes;
	PVOID           SecurityDescriptor;
	PVOID           SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef enum _TIMER_INFORMATION_CLASS
{
	TimerBasicInformation
} TIMER_INFORMATION_CLASS, * PTIMER_INFORMATION_CLASS;

typedef struct _KCONTINUE_ARGUMENT
{
	KCONTINUE_TYPE ContinueType;
	ULONG          ContinueFlags;
	ULONGLONG      Reserved[2];
} KCONTINUE_ARGUMENT, * PKCONTINUE_ARGUMENT;

EXTERN_C NTSTATUS NtAccessCheck(
	IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
	IN HANDLE ClientToken,
	IN ACCESS_MASK DesiaredAccess,
	IN PGENERIC_MAPPING GenericMapping,
	OUT PPRIVILEGE_SET PrivilegeSet OPTIONAL,
	IN OUT PULONG PrivilegeSetLength,
	OUT PACCESS_MASK GrantedAccess,
	OUT PBOOLEAN AccessStatus);

EXTERN_C NTSTATUS NtWorkerFactoryWorkerReady(
	IN HANDLE WorkerFactoryHandle);

EXTERN_C NTSTATUS NtAcceptConnectPort(
	OUT PHANDLE ServerPortHandle,
	IN ULONG AlternativeReceivePortHandle OPTIONAL,
	IN PPORT_MESSAGE ConnectionReply,
	IN BOOLEAN AcceptConnection,
	IN OUT PPORT_SECTION_WRITE ServerSharedMemory OPTIONAL,
	OUT PPORT_SECTION_READ ClientSharedMemory OPTIONAL);

EXTERN_C NTSTATUS NtMapUserPhysicalPagesScatter(
	IN PVOID VirtualAddresses,
	IN PULONG NumberOfPages,
	IN PULONG UserPfnArray OPTIONAL);

EXTERN_C NTSTATUS NtWaitForSingleObject(
	IN HANDLE ObjectHandle,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER TimeOut OPTIONAL);

EXTERN_C NTSTATUS NtCallbackReturn(
	IN PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputLength,
	IN NTSTATUS Status);

EXTERN_C NTSTATUS NtReadFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	OUT PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset OPTIONAL,
	IN PULONG Key OPTIONAL);

EXTERN_C NTSTATUS NtDeviceIoControlFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG IoControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength);

EXTERN_C NTSTATUS NtWriteFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset OPTIONAL,
	IN PULONG Key OPTIONAL);

EXTERN_C NTSTATUS NtRemoveIoCompletion(
	IN HANDLE IoCompletionHandle,
	OUT PULONG KeyContext,
	OUT PULONG ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtReleaseSemaphore(
	IN HANDLE SemaphoreHandle,
	IN LONG ReleaseCount,
	OUT PLONG PreviousCount OPTIONAL);

EXTERN_C NTSTATUS NtReplyWaitReceivePort(
	IN HANDLE PortHandle,
	OUT PVOID PortContext OPTIONAL,
	IN PPORT_MESSAGE ReplyMessage OPTIONAL,
	OUT PPORT_MESSAGE ReceiveMessage);

EXTERN_C NTSTATUS NtReplyPort(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE ReplyMessage);

EXTERN_C NTSTATUS NtSetInformationThread(
	IN HANDLE ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	IN PVOID ThreadInformation,
	IN ULONG ThreadInformationLength);

EXTERN_C NTSTATUS NtSetEvent(
	IN HANDLE EventHandle,
	OUT PULONG PreviousState OPTIONAL);

EXTERN_C NTSTATUS NtClose(
	IN HANDLE Handle);

EXTERN_C NTSTATUS NtQueryObject(
	IN HANDLE Handle,
	IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
	OUT PVOID ObjectInformation OPTIONAL,
	IN ULONG ObjectInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass);

EXTERN_C NTSTATUS NtOpenKey(
	OUT PHANDLE KeyHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtEnumerateValueKey(
	IN HANDLE KeyHandle,
	IN ULONG Index,
	IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	OUT PVOID KeyValueInformation OPTIONAL,
	IN ULONG Length,
	OUT PULONG ResultLength);

EXTERN_C NTSTATUS NtFindAtom(
	IN PWSTR AtomName OPTIONAL,
	IN ULONG Length,
	OUT PUSHORT Atom OPTIONAL);

EXTERN_C NTSTATUS NtQueryDefaultLocale(
	IN BOOLEAN UserProfile,
	OUT PLCID DefaultLocaleId);

EXTERN_C NTSTATUS NtQueryKey(
	IN HANDLE KeyHandle,
	IN KEY_INFORMATION_CLASS KeyInformationClass,
	OUT PVOID KeyInformation OPTIONAL,
	IN ULONG Length,
	OUT PULONG ResultLength);

EXTERN_C NTSTATUS NtQueryValueKey(
	IN HANDLE KeyHandle,
	IN PUNICODE_STRING ValueName,
	IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	OUT PVOID KeyValueInformation OPTIONAL,
	IN ULONG Length,
	OUT PULONG ResultLength);

EXTERN_C NTSTATUS NtAllocateVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN ULONG ZeroBits,
	IN OUT PSIZE_T RegionSize,
	IN ULONG AllocationType,
	IN ULONG Protect);

EXTERN_C NTSTATUS NtQueryInformationProcess(
	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT PVOID ProcessInformation,
	IN ULONG ProcessInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtWaitForMultipleObjects32(
	IN ULONG ObjectCount,
	IN PHANDLE Handles,
	IN WAIT_TYPE WaitType,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtWriteFileGather(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PFILE_SEGMENT_ELEMENT SegmentArray,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset,
	IN PULONG Key OPTIONAL);

EXTERN_C NTSTATUS NtCreateKey(
	OUT PHANDLE KeyHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG TitleIndex,
	IN PUNICODE_STRING Class OPTIONAL,
	IN ULONG CreateOptions,
	OUT PULONG Disposition OPTIONAL);

EXTERN_C NTSTATUS NtFreeVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN OUT PSIZE_T RegionSize,
	IN ULONG FreeType);

EXTERN_C NTSTATUS NtImpersonateClientOfPort(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE Message);

EXTERN_C NTSTATUS NtReleaseMutant(
	IN HANDLE MutantHandle,
	OUT PULONG PreviousCount OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationToken(
	IN HANDLE TokenHandle,
	IN TOKEN_INFORMATION_CLASS TokenInformationClass,
	OUT PVOID TokenInformation,
	IN ULONG TokenInformationLength,
	OUT PULONG ReturnLength);

EXTERN_C NTSTATUS NtRequestWaitReplyPort(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE RequestMessage,
	OUT PPORT_MESSAGE ReplyMessage);

EXTERN_C NTSTATUS NtQueryVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
	OUT PVOID MemoryInformation,
	IN SIZE_T MemoryInformationLength,
	OUT PSIZE_T ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtOpenThreadToken(
	IN HANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN BOOLEAN OpenAsSelf,
	OUT PHANDLE TokenHandle);

EXTERN_C NTSTATUS NtQueryInformationThread(
	IN HANDLE ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	OUT PVOID ThreadInformation,
	IN ULONG ThreadInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtOpenProcess(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId OPTIONAL);

EXTERN_C NTSTATUS NtSetInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass);

EXTERN_C NTSTATUS NtMapViewOfSection(
	IN HANDLE SectionHandle,
	IN HANDLE ProcessHandle,
	IN OUT PVOID BaseAddress,
	IN ULONG ZeroBits,
	IN SIZE_T CommitSize,
	IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
	IN OUT PSIZE_T ViewSize,
	IN SECTION_INHERIT InheritDisposition,
	IN ULONG AllocationType,
	IN ULONG Win32Protect);

EXTERN_C NTSTATUS NtAccessCheckAndAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN PUNICODE_STRING ObjectTypeName,
	IN PUNICODE_STRING ObjectName,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN ACCESS_MASK DesiredAccess,
	IN PGENERIC_MAPPING GenericMapping,
	IN BOOLEAN ObjectCreation,
	OUT PACCESS_MASK GrantedAccess,
	OUT PBOOLEAN AccessStatus,
	OUT PBOOLEAN GenerateOnClose);

EXTERN_C NTSTATUS NtUnmapViewOfSection(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress);

EXTERN_C NTSTATUS NtReplyWaitReceivePortEx(
	IN HANDLE PortHandle,
	OUT PULONG PortContext OPTIONAL,
	IN PPORT_MESSAGE ReplyMessage OPTIONAL,
	OUT PPORT_MESSAGE ReceiveMessage,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtTerminateProcess(
	IN HANDLE ProcessHandle OPTIONAL,
	IN NTSTATUS ExitStatus);

EXTERN_C NTSTATUS NtSetEventBoostPriority(
	IN HANDLE EventHandle);

EXTERN_C NTSTATUS NtReadFileScatter(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PFILE_SEGMENT_ELEMENT SegmentArray,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset OPTIONAL,
	IN PULONG Key OPTIONAL);

EXTERN_C NTSTATUS NtOpenThreadTokenEx(
	IN HANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN BOOLEAN OpenAsSelf,
	IN ULONG HandleAttributes,
	OUT PHANDLE TokenHandle);

EXTERN_C NTSTATUS NtOpenProcessTokenEx(
	IN HANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	OUT PHANDLE TokenHandle);

EXTERN_C NTSTATUS NtQueryPerformanceCounter(
	OUT PLARGE_INTEGER PerformanceCounter,
	OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL);

EXTERN_C NTSTATUS NtEnumerateKey(
	IN HANDLE KeyHandle,
	IN ULONG Index,
	IN KEY_INFORMATION_CLASS KeyInformationClass,
	OUT PVOID KeyInformation OPTIONAL,
	IN ULONG Length,
	OUT PULONG ResultLength);

EXTERN_C NTSTATUS NtOpenFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG ShareAccess,
	IN ULONG OpenOptions);

EXTERN_C NTSTATUS NtDelayExecution(
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER DelayInterval);

EXTERN_C NTSTATUS NtQueryDirectoryFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN BOOLEAN ReturnSingleEntry,
	IN PUNICODE_STRING FileName OPTIONAL,
	IN BOOLEAN RestartScan);

EXTERN_C NTSTATUS NtQuerySystemInformation(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	IN OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtOpenSection(
	OUT PHANDLE SectionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtQueryTimer(
	IN HANDLE TimerHandle,
	IN TIMER_INFORMATION_CLASS TimerInformationClass,
	OUT PVOID TimerInformation,
	IN ULONG TimerInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtFsControlFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG FsControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength);

EXTERN_C NTSTATUS NtWriteVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN PVOID Buffer,
	IN SIZE_T NumberOfBytesToWrite,
	OUT PSIZE_T NumberOfBytesWritten OPTIONAL);

EXTERN_C NTSTATUS NtCloseObjectAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN BOOLEAN GenerateOnClose);

EXTERN_C NTSTATUS NtDuplicateObject(
	IN HANDLE SourceProcessHandle,
	IN HANDLE SourceHandle,
	IN HANDLE TargetProcessHandle OPTIONAL,
	OUT PHANDLE TargetHandle OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Options);

EXTERN_C NTSTATUS NtQueryAttributesFile(
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PFILE_BASIC_INFORMATION FileInformation);

EXTERN_C NTSTATUS NtClearEvent(
	IN HANDLE EventHandle);

EXTERN_C NTSTATUS NtReadVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress OPTIONAL,
	OUT PVOID Buffer,
	IN SIZE_T BufferSize,
	OUT PSIZE_T NumberOfBytesRead OPTIONAL);

EXTERN_C NTSTATUS NtOpenEvent(
	OUT PHANDLE EventHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtAdjustPrivilegesToken(
	IN HANDLE TokenHandle,
	IN BOOLEAN DisableAllPrivileges,
	IN PTOKEN_PRIVILEGES NewState OPTIONAL,
	IN ULONG BufferLength,
	OUT PTOKEN_PRIVILEGES PreviousState OPTIONAL,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtDuplicateToken(
	IN HANDLE ExistingTokenHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN BOOLEAN EffectiveOnly,
	IN TOKEN_TYPE TokenType,
	OUT PHANDLE NewTokenHandle);

EXTERN_C NTSTATUS NtContinue(
	IN PCONTEXT ContextRecord,
	IN BOOLEAN TestAlert);

EXTERN_C NTSTATUS NtQueryDefaultUILanguage(
	OUT PLANGID DefaultUILanguageId);

EXTERN_C NTSTATUS NtQueueApcThread(
	IN HANDLE ThreadHandle,
	IN PKNORMAL_ROUTINE ApcRoutine,
	IN PVOID ApcArgument1 OPTIONAL,
	IN PVOID ApcArgument2 OPTIONAL,
	IN PVOID ApcArgument3 OPTIONAL);

EXTERN_C NTSTATUS NtYieldExecution();

EXTERN_C NTSTATUS NtAddAtom(
	IN PWSTR AtomName OPTIONAL,
	IN ULONG Length,
	OUT PUSHORT Atom OPTIONAL);

EXTERN_C NTSTATUS NtCreateEvent(
	OUT PHANDLE EventHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN EVENT_TYPE EventType,
	IN BOOLEAN InitialState);

EXTERN_C NTSTATUS NtQueryVolumeInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FsInformation,
	IN ULONG Length,
	IN FSINFOCLASS FsInformationClass);

EXTERN_C NTSTATUS NtCreateSection(
	OUT PHANDLE SectionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PLARGE_INTEGER MaximumSize OPTIONAL,
	IN ULONG SectionPageProtection,
	IN ULONG AllocationAttributes,
	IN HANDLE FileHandle OPTIONAL);

EXTERN_C NTSTATUS NtFlushBuffersFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock);

EXTERN_C NTSTATUS NtApphelpCacheControl(
	IN APPHELPCACHESERVICECLASS Service,
	IN PVOID ServiceData);

EXTERN_C NTSTATUS NtCreateProcessEx(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE ParentProcess,
	IN ULONG Flags,
	IN HANDLE SectionHandle OPTIONAL,
	IN HANDLE DebugPort OPTIONAL,
	IN HANDLE ExceptionPort OPTIONAL,
	IN ULONG JobMemberLevel);

EXTERN_C NTSTATUS NtCreateThread(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE ProcessHandle,
	OUT PCLIENT_ID ClientId,
	IN PCONTEXT ThreadContext,
	IN PUSER_STACK InitialTeb,
	IN BOOLEAN CreateSuspended);

EXTERN_C NTSTATUS NtIsProcessInJob(
	IN HANDLE ProcessHandle,
	IN HANDLE JobHandle OPTIONAL);

EXTERN_C NTSTATUS NtProtectVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN OUT PSIZE_T RegionSize,
	IN ULONG NewProtect,
	OUT PULONG OldProtect);

EXTERN_C NTSTATUS NtQuerySection(
	IN HANDLE SectionHandle,
	IN SECTION_INFORMATION_CLASS SectionInformationClass,
	OUT PVOID SectionInformation,
	IN ULONG SectionInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtResumeThread(
	IN HANDLE ThreadHandle,
	IN OUT PULONG PreviousSuspendCount OPTIONAL);

EXTERN_C NTSTATUS NtTerminateThread(
	IN HANDLE ThreadHandle,
	IN NTSTATUS ExitStatus);

EXTERN_C NTSTATUS NtReadRequestData(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE Message,
	IN ULONG DataEntryIndex,
	OUT PVOID Buffer,
	IN ULONG BufferSize,
	OUT PULONG NumberOfBytesRead OPTIONAL);

EXTERN_C NTSTATUS NtCreateFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER AllocationSize OPTIONAL,
	IN ULONG FileAttributes,
	IN ULONG ShareAccess,
	IN ULONG CreateDisposition,
	IN ULONG CreateOptions,
	IN PVOID EaBuffer OPTIONAL,
	IN ULONG EaLength);

EXTERN_C NTSTATUS NtQueryEvent(
	IN HANDLE EventHandle,
	IN EVENT_INFORMATION_CLASS EventInformationClass,
	OUT PVOID EventInformation,
	IN ULONG EventInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtWriteRequestData(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE Request,
	IN ULONG DataIndex,
	IN PVOID Buffer,
	IN ULONG Length,
	OUT PULONG ResultLength OPTIONAL);

EXTERN_C NTSTATUS NtOpenDirectoryObject(
	OUT PHANDLE DirectoryHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtAccessCheckByTypeAndAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN PUNICODE_STRING ObjectTypeName,
	IN PUNICODE_STRING ObjectName,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN PSID PrincipalSelfSid OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN AUDIT_EVENT_TYPE AuditType,
	IN ULONG Flags,
	IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
	IN ULONG ObjectTypeListLength,
	IN PGENERIC_MAPPING GenericMapping,
	IN BOOLEAN ObjectCreation,
	OUT PACCESS_MASK GrantedAccess,
	OUT PULONG AccessStatus,
	OUT PBOOLEAN GenerateOnClose);

EXTERN_C NTSTATUS NtWaitForMultipleObjects(
	IN ULONG Count,
	IN PHANDLE Handles,
	IN WAIT_TYPE WaitType,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtSetInformationObject(
	IN HANDLE Handle,
	IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
	IN PVOID ObjectInformation,
	IN ULONG ObjectInformationLength);

EXTERN_C NTSTATUS NtCancelIoFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock);

EXTERN_C NTSTATUS NtTraceEvent(
	IN HANDLE TraceHandle,
	IN ULONG Flags,
	IN ULONG FieldSize,
	IN PVOID Fields);

EXTERN_C NTSTATUS NtPowerInformation(
	IN POWER_INFORMATION_LEVEL InformationLevel,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength);

EXTERN_C NTSTATUS NtSetValueKey(
	IN HANDLE KeyHandle,
	IN PUNICODE_STRING ValueName,
	IN ULONG TitleIndex OPTIONAL,
	IN ULONG Type,
	IN PVOID SystemData,
	IN ULONG DataSize);

EXTERN_C NTSTATUS NtCancelTimer(
	IN HANDLE TimerHandle,
	OUT PBOOLEAN CurrentState OPTIONAL);

EXTERN_C NTSTATUS NtSetTimer(
	IN HANDLE TimerHandle,
	IN PLARGE_INTEGER DueTime,
	IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
	IN PVOID TimerContext OPTIONAL,
	IN BOOLEAN ResumeTimer,
	IN LONG Period OPTIONAL,
	OUT PBOOLEAN PreviousState OPTIONAL);

EXTERN_C NTSTATUS NtAccessCheckByType(
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN PSID PrincipalSelfSid OPTIONAL,
	IN HANDLE ClientToken,
	IN ULONG DesiredAccess,
	IN POBJECT_TYPE_LIST ObjectTypeList,
	IN ULONG ObjectTypeListLength,
	IN PGENERIC_MAPPING GenericMapping,
	OUT PPRIVILEGE_SET PrivilegeSet,
	IN OUT PULONG PrivilegeSetLength,
	OUT PACCESS_MASK GrantedAccess,
	OUT PULONG AccessStatus);

EXTERN_C NTSTATUS NtAccessCheckByTypeResultList(
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN PSID PrincipalSelfSid OPTIONAL,
	IN HANDLE ClientToken,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_TYPE_LIST ObjectTypeList,
	IN ULONG ObjectTypeListLength,
	IN PGENERIC_MAPPING GenericMapping,
	OUT PPRIVILEGE_SET PrivilegeSet,
	IN OUT PULONG PrivilegeSetLength,
	OUT PACCESS_MASK GrantedAccess,
	OUT PULONG AccessStatus);

EXTERN_C NTSTATUS NtAccessCheckByTypeResultListAndAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN PUNICODE_STRING ObjectTypeName,
	IN PUNICODE_STRING ObjectName,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN PSID PrincipalSelfSid OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN AUDIT_EVENT_TYPE AuditType,
	IN ULONG Flags,
	IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
	IN ULONG ObjectTypeListLength,
	IN PGENERIC_MAPPING GenericMapping,
	IN BOOLEAN ObjectCreation,
	OUT PACCESS_MASK GrantedAccess,
	OUT PULONG AccessStatus,
	OUT PULONG GenerateOnClose);

EXTERN_C NTSTATUS NtAccessCheckByTypeResultListAndAuditAlarmByHandle(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN HANDLE ClientToken,
	IN PUNICODE_STRING ObjectTypeName,
	IN PUNICODE_STRING ObjectName,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN PSID PrincipalSelfSid OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN AUDIT_EVENT_TYPE AuditType,
	IN ULONG Flags,
	IN POBJECT_TYPE_LIST ObjectTypeList OPTIONAL,
	IN ULONG ObjectTypeListLength,
	IN PGENERIC_MAPPING GenericMapping,
	IN BOOLEAN ObjectCreation,
	OUT PACCESS_MASK GrantedAccess,
	OUT PULONG AccessStatus,
	OUT PULONG GenerateOnClose);

EXTERN_C NTSTATUS NtAcquireProcessActivityReference();

EXTERN_C NTSTATUS NtAddAtomEx(
	IN PWSTR AtomName,
	IN ULONG Length,
	IN PRTL_ATOM Atom,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtAddBootEntry(
	IN PBOOT_ENTRY BootEntry,
	OUT PULONG Id OPTIONAL);

EXTERN_C NTSTATUS NtAddDriverEntry(
	IN PEFI_DRIVER_ENTRY DriverEntry,
	OUT PULONG Id OPTIONAL);

EXTERN_C NTSTATUS NtAdjustGroupsToken(
	IN HANDLE TokenHandle,
	IN BOOLEAN ResetToDefault,
	IN PTOKEN_GROUPS NewState OPTIONAL,
	IN ULONG BufferLength OPTIONAL,
	OUT PTOKEN_GROUPS PreviousState OPTIONAL,
	OUT PULONG ReturnLength);

EXTERN_C NTSTATUS NtAdjustTokenClaimsAndDeviceGroups(
	IN HANDLE TokenHandle,
	IN BOOLEAN UserResetToDefault,
	IN BOOLEAN DeviceResetToDefault,
	IN BOOLEAN DeviceGroupsResetToDefault,
	IN PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewUserState OPTIONAL,
	IN PTOKEN_SECURITY_ATTRIBUTES_INFORMATION NewDeviceState OPTIONAL,
	IN PTOKEN_GROUPS NewDeviceGroupsState OPTIONAL,
	IN ULONG UserBufferLength,
	OUT PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousUserState OPTIONAL,
	IN ULONG DeviceBufferLength,
	OUT PTOKEN_SECURITY_ATTRIBUTES_INFORMATION PreviousDeviceState OPTIONAL,
	IN ULONG DeviceGroupsBufferLength,
	OUT PTOKEN_GROUPS PreviousDeviceGroups OPTIONAL,
	OUT PULONG UserReturnLength OPTIONAL,
	OUT PULONG DeviceReturnLength OPTIONAL,
	OUT PULONG DeviceGroupsReturnBufferLength OPTIONAL);

EXTERN_C NTSTATUS NtAlertResumeThread(
	IN HANDLE ThreadHandle,
	OUT PULONG PreviousSuspendCount OPTIONAL);

EXTERN_C NTSTATUS NtAlertThread(
	IN HANDLE ThreadHandle);

EXTERN_C NTSTATUS NtAlertThreadByThreadId(
	IN ULONG ThreadId);

EXTERN_C NTSTATUS NtAllocateLocallyUniqueId(
	OUT PLUID Luid);

EXTERN_C NTSTATUS NtAllocateReserveObject(
	OUT PHANDLE MemoryReserveHandle,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN MEMORY_RESERVE_TYPE Type);

EXTERN_C NTSTATUS NtAllocateUserPhysicalPages(
	IN HANDLE ProcessHandle,
	IN OUT PULONG NumberOfPages,
	OUT PULONG UserPfnArray);

EXTERN_C NTSTATUS NtAllocateUuids(
	OUT PLARGE_INTEGER Time,
	OUT PULONG Range,
	OUT PULONG Sequence,
	OUT PUCHAR Seed);

EXTERN_C NTSTATUS NtAllocateVirtualMemoryEx(
	IN HANDLE ProcessHandle,
	IN OUT PPVOID lpAddress,
	IN ULONG_PTR ZeroBits,
	IN OUT PSIZE_T pSize,
	IN ULONG flAllocationType,
	IN OUT PVOID DataBuffer OPTIONAL,
	IN ULONG DataCount);

EXTERN_C NTSTATUS NtAlpcAcceptConnectPort(
	OUT PHANDLE PortHandle,
	IN HANDLE ConnectionPortHandle,
	IN ULONG Flags,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PALPC_PORT_ATTRIBUTES PortAttributes OPTIONAL,
	IN PVOID PortContext OPTIONAL,
	IN PPORT_MESSAGE ConnectionRequest,
	IN OUT PALPC_MESSAGE_ATTRIBUTES ConnectionMessageAttributes OPTIONAL,
	IN BOOLEAN AcceptConnection);

EXTERN_C NTSTATUS NtAlpcCancelMessage(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN PALPC_CONTEXT_ATTR MessageContext);

EXTERN_C NTSTATUS NtAlpcConnectPort(
	OUT PHANDLE PortHandle,
	IN PUNICODE_STRING PortName,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PALPC_PORT_ATTRIBUTES PortAttributes OPTIONAL,
	IN ULONG Flags,
	IN PSID RequiredServerSid OPTIONAL,
	IN OUT PPORT_MESSAGE ConnectionMessage OPTIONAL,
	IN OUT PULONG BufferLength OPTIONAL,
	IN OUT PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes OPTIONAL,
	IN OUT PALPC_MESSAGE_ATTRIBUTES InMessageAttributes OPTIONAL,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtAlpcConnectPortEx(
	OUT PHANDLE PortHandle,
	IN POBJECT_ATTRIBUTES ConnectionPortObjectAttributes,
	IN POBJECT_ATTRIBUTES ClientPortObjectAttributes OPTIONAL,
	IN PALPC_PORT_ATTRIBUTES PortAttributes OPTIONAL,
	IN ULONG Flags,
	IN PSECURITY_DESCRIPTOR ServerSecurityRequirements OPTIONAL,
	IN OUT PPORT_MESSAGE ConnectionMessage OPTIONAL,
	IN OUT PSIZE_T BufferLength OPTIONAL,
	IN OUT PALPC_MESSAGE_ATTRIBUTES OutMessageAttributes OPTIONAL,
	IN OUT PALPC_MESSAGE_ATTRIBUTES InMessageAttributes OPTIONAL,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtAlpcCreatePort(
	OUT PHANDLE PortHandle,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PALPC_PORT_ATTRIBUTES PortAttributes OPTIONAL);

EXTERN_C NTSTATUS NtAlpcCreatePortSection(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN HANDLE SectionHandle OPTIONAL,
	IN SIZE_T SectionSize,
	OUT PHANDLE AlpcSectionHandle,
	OUT PSIZE_T ActualSectionSize);

EXTERN_C NTSTATUS NtAlpcCreateResourceReserve(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN SIZE_T MessageSize,
	OUT PHANDLE ResourceId);

EXTERN_C NTSTATUS NtAlpcCreateSectionView(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN OUT PALPC_DATA_VIEW_ATTR ViewAttributes);

EXTERN_C NTSTATUS NtAlpcCreateSecurityContext(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN OUT PALPC_SECURITY_ATTR SecurityAttribute);

EXTERN_C NTSTATUS NtAlpcDeletePortSection(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN HANDLE SectionHandle);

EXTERN_C NTSTATUS NtAlpcDeleteResourceReserve(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN HANDLE ResourceId);

EXTERN_C NTSTATUS NtAlpcDeleteSectionView(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN PVOID ViewBase);

EXTERN_C NTSTATUS NtAlpcDeleteSecurityContext(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN HANDLE ContextHandle);

EXTERN_C NTSTATUS NtAlpcDisconnectPort(
	IN HANDLE PortHandle,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtAlpcImpersonateClientContainerOfPort(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE Message,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtAlpcImpersonateClientOfPort(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE Message,
	IN PVOID Flags);

EXTERN_C NTSTATUS NtAlpcOpenSenderProcess(
	OUT PHANDLE ProcessHandle,
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE PortMessage,
	IN ULONG Flags,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtAlpcOpenSenderThread(
	OUT PHANDLE ThreadHandle,
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE PortMessage,
	IN ULONG Flags,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtAlpcQueryInformation(
	IN HANDLE PortHandle OPTIONAL,
	IN ALPC_PORT_INFORMATION_CLASS PortInformationClass,
	IN OUT PVOID PortInformation,
	IN ULONG Length,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtAlpcQueryInformationMessage(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE PortMessage,
	IN ALPC_MESSAGE_INFORMATION_CLASS MessageInformationClass,
	OUT PVOID MessageInformation OPTIONAL,
	IN ULONG Length,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtAlpcRevokeSecurityContext(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN HANDLE ContextHandle);

EXTERN_C NTSTATUS NtAlpcSendWaitReceivePort(
	IN HANDLE PortHandle,
	IN ULONG Flags,
	IN PPORT_MESSAGE SendMessage OPTIONAL,
	IN OUT PALPC_MESSAGE_ATTRIBUTES SendMessageAttributes OPTIONAL,
	OUT PPORT_MESSAGE ReceiveMessage OPTIONAL,
	IN OUT PSIZE_T BufferLength OPTIONAL,
	IN OUT PALPC_MESSAGE_ATTRIBUTES ReceiveMessageAttributes OPTIONAL,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtAlpcSetInformation(
	IN HANDLE PortHandle,
	IN ALPC_PORT_INFORMATION_CLASS PortInformationClass,
	IN PVOID PortInformation OPTIONAL,
	IN ULONG Length);

EXTERN_C NTSTATUS NtAreMappedFilesTheSame(
	IN PVOID File1MappedAsAnImage,
	IN PVOID File2MappedAsFile);

EXTERN_C NTSTATUS NtAssignProcessToJobObject(
	IN HANDLE JobHandle,
	IN HANDLE ProcessHandle);

EXTERN_C NTSTATUS NtAssociateWaitCompletionPacket(
	IN HANDLE WaitCompletionPacketHandle,
	IN HANDLE IoCompletionHandle,
	IN HANDLE TargetObjectHandle,
	IN PVOID KeyContext OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	IN NTSTATUS IoStatus,
	IN ULONG_PTR IoStatusInformation,
	OUT PBOOLEAN AlreadySignaled OPTIONAL);

EXTERN_C NTSTATUS NtCallEnclave(
	IN PENCLAVE_ROUTINE Routine,
	IN PVOID Parameter,
	IN BOOLEAN WaitForThread,
	IN OUT PVOID ReturnValue OPTIONAL);

EXTERN_C NTSTATUS NtCancelIoFileEx(
	IN HANDLE FileHandle,
	IN PIO_STATUS_BLOCK IoRequestToCancel OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock);

EXTERN_C NTSTATUS NtCancelSynchronousIoFile(
	IN HANDLE ThreadHandle,
	IN PIO_STATUS_BLOCK IoRequestToCancel OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock);

EXTERN_C NTSTATUS NtCancelTimer2(
	IN HANDLE TimerHandle,
	IN PT2_CANCEL_PARAMETERS Parameters);

EXTERN_C NTSTATUS NtCancelWaitCompletionPacket(
	IN HANDLE WaitCompletionPacketHandle,
	IN BOOLEAN RemoveSignaledPacket);

EXTERN_C NTSTATUS NtCommitComplete(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtCommitEnlistment(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtCommitRegistryTransaction(
	IN HANDLE RegistryHandle,
	IN BOOL Wait);

EXTERN_C NTSTATUS NtCommitTransaction(
	IN HANDLE TransactionHandle,
	IN BOOLEAN Wait);

EXTERN_C NTSTATUS NtCompactKeys(
	IN ULONG Count,
	IN HANDLE KeyArray);

EXTERN_C NTSTATUS NtCompareObjects(
	IN HANDLE FirstObjectHandle,
	IN HANDLE SecondObjectHandle);

EXTERN_C NTSTATUS NtCompareSigningLevels(
	IN ULONG UnknownParameter1,
	IN ULONG UnknownParameter2);

EXTERN_C NTSTATUS NtCompareTokens(
	IN HANDLE FirstTokenHandle,
	IN HANDLE SecondTokenHandle,
	OUT PBOOLEAN Equal);

EXTERN_C NTSTATUS NtCompleteConnectPort(
	IN HANDLE PortHandle);

EXTERN_C NTSTATUS NtCompressKey(
	IN HANDLE Key);

EXTERN_C NTSTATUS NtConnectPort(
	OUT PHANDLE PortHandle,
	IN PUNICODE_STRING PortName,
	IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
	IN OUT PPORT_SECTION_WRITE ClientView OPTIONAL,
	IN OUT PPORT_SECTION_READ ServerView OPTIONAL,
	OUT PULONG MaxMessageLength OPTIONAL,
	IN OUT PVOID ConnectionInformation OPTIONAL,
	IN OUT PULONG ConnectionInformationLength OPTIONAL);

EXTERN_C NTSTATUS NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(
	IN ULONG UnknownParameter1,
	IN ULONG UnknownParameter2,
	IN ULONG UnknownParameter3,
	IN ULONG UnknownParameter4);

EXTERN_C NTSTATUS NtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtCreateDirectoryObject(
	OUT PHANDLE DirectoryHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtCreateDirectoryObjectEx(
	OUT PHANDLE DirectoryHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN HANDLE ShadowDirectoryHandle,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtCreateEnclave(
	IN HANDLE ProcessHandle,
	IN OUT PVOID BaseAddress,
	IN ULONG_PTR ZeroBits,
	IN SIZE_T Size,
	IN SIZE_T InitialCommitment,
	IN ULONG EnclaveType,
	IN PVOID EnclaveInformation,
	IN ULONG EnclaveInformationLength,
	OUT PULONG EnclaveError OPTIONAL);

EXTERN_C NTSTATUS NtCreateEnlistment(
	OUT PHANDLE EnlistmentHandle,
	IN ACCESS_MASK DesiredAccess,
	IN HANDLE ResourceManagerHandle,
	IN HANDLE TransactionHandle,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG CreateOptions OPTIONAL,
	IN NOTIFICATION_MASK NotificationMask,
	IN PVOID EnlistmentKey OPTIONAL);

EXTERN_C NTSTATUS NtCreateEventPair(
	OUT PHANDLE EventPairHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

EXTERN_C NTSTATUS NtCreateIRTimer(
	OUT PHANDLE TimerHandle,
	IN ACCESS_MASK DesiredAccess);

EXTERN_C NTSTATUS NtCreateIoCompletion(
	OUT PHANDLE IoCompletionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG Count OPTIONAL);

EXTERN_C NTSTATUS NtCreateJobObject(
	OUT PHANDLE JobHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

EXTERN_C NTSTATUS NtCreateJobSet(
	IN ULONG NumJob,
	IN PJOB_SET_ARRAY UserJobSet,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtCreateKeyTransacted(
	OUT PHANDLE KeyHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG TitleIndex,
	IN PUNICODE_STRING Class OPTIONAL,
	IN ULONG CreateOptions,
	IN HANDLE TransactionHandle,
	OUT PULONG Disposition OPTIONAL);

EXTERN_C NTSTATUS NtCreateKeyedEvent(
	OUT PHANDLE KeyedEventHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtCreateLowBoxToken(
	OUT PHANDLE TokenHandle,
	IN HANDLE ExistingTokenHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PSID PackageSid,
	IN ULONG CapabilityCount,
	IN PSID_AND_ATTRIBUTES Capabilities OPTIONAL,
	IN ULONG HandleCount,
	IN HANDLE Handles OPTIONAL);

EXTERN_C NTSTATUS NtCreateMailslotFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG CreateOptions,
	IN ULONG MailslotQuota,
	IN ULONG MaximumMessageSize,
	IN PLARGE_INTEGER ReadTimeout);

EXTERN_C NTSTATUS NtCreateMutant(
	OUT PHANDLE MutantHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN BOOLEAN InitialOwner);

EXTERN_C NTSTATUS NtCreateNamedPipeFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG ShareAccess,
	IN ULONG CreateDisposition,
	IN ULONG CreateOptions,
	IN BOOLEAN NamedPipeType,
	IN BOOLEAN ReadMode,
	IN BOOLEAN CompletionMode,
	IN ULONG MaximumInstances,
	IN ULONG InboundQuota,
	IN ULONG OutboundQuota,
	IN PLARGE_INTEGER DefaultTimeout OPTIONAL);

EXTERN_C NTSTATUS NtCreatePagingFile(
	IN PUNICODE_STRING PageFileName,
	IN PULARGE_INTEGER MinimumSize,
	IN PULARGE_INTEGER MaximumSize,
	IN ULONG Priority);

EXTERN_C NTSTATUS NtCreatePartition(
	OUT PHANDLE PartitionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG PreferredNode);

EXTERN_C NTSTATUS NtCreatePort(
	OUT PHANDLE PortHandle,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG MaxConnectionInfoLength,
	IN ULONG MaxMessageLength,
	IN ULONG MaxPoolUsage OPTIONAL);

EXTERN_C NTSTATUS NtCreatePrivateNamespace(
	OUT PHANDLE NamespaceHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PVOID BoundaryDescriptor);

EXTERN_C NTSTATUS NtCreateProcess(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE ParentProcess,
	IN BOOLEAN InheritObjectTable,
	IN HANDLE SectionHandle OPTIONAL,
	IN HANDLE DebugPort OPTIONAL,
	IN HANDLE ExceptionPort OPTIONAL);

EXTERN_C NTSTATUS NtCreateProfile(
	OUT PHANDLE ProfileHandle,
	IN HANDLE Process OPTIONAL,
	IN PVOID ProfileBase,
	IN ULONG ProfileSize,
	IN ULONG BucketSize,
	IN PULONG Buffer,
	IN ULONG BufferSize,
	IN KPROFILE_SOURCE ProfileSource,
	IN ULONG Affinity);

EXTERN_C NTSTATUS NtCreateProfileEx(
	OUT PHANDLE ProfileHandle,
	IN HANDLE Process OPTIONAL,
	IN PVOID ProfileBase,
	IN SIZE_T ProfileSize,
	IN ULONG BucketSize,
	IN PULONG Buffer,
	IN ULONG BufferSize,
	IN KPROFILE_SOURCE ProfileSource,
	IN USHORT GroupCount,
	IN PGROUP_AFFINITY GroupAffinity);

EXTERN_C NTSTATUS NtCreateRegistryTransaction(
	OUT PHANDLE Handle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN DWORD Flags);

EXTERN_C NTSTATUS NtCreateResourceManager(
	OUT PHANDLE ResourceManagerHandle,
	IN ACCESS_MASK DesiredAccess,
	IN HANDLE TmHandle,
	IN LPGUID RmGuid,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG CreateOptions OPTIONAL,
	IN PUNICODE_STRING Description OPTIONAL);

EXTERN_C NTSTATUS NtCreateSemaphore(
	OUT PHANDLE SemaphoreHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN LONG InitialCount,
	IN LONG MaximumCount);

EXTERN_C NTSTATUS NtCreateSymbolicLinkObject(
	OUT PHANDLE LinkHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PUNICODE_STRING LinkTarget);

EXTERN_C NTSTATUS NtCreateThreadEx(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE ProcessHandle,
	IN PVOID StartRoutine,
	IN PVOID Argument OPTIONAL,
	IN ULONG CreateFlags,
	IN SIZE_T ZeroBits,
	IN SIZE_T StackSize,
	IN SIZE_T MaximumStackSize,
	IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);

EXTERN_C NTSTATUS NtCreateTimer(
	OUT PHANDLE TimerHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN TIMER_TYPE TimerType);

EXTERN_C NTSTATUS NtCreateTimer2(
	OUT PHANDLE TimerHandle,
	IN PVOID Reserved1 OPTIONAL,
	IN PVOID Reserved2 OPTIONAL,
	IN ULONG Attributes,
	IN ACCESS_MASK DesiredAccess);

EXTERN_C NTSTATUS NtCreateToken(
	OUT PHANDLE TokenHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN TOKEN_TYPE TokenType,
	IN PLUID AuthenticationId,
	IN PLARGE_INTEGER ExpirationTime,
	IN PTOKEN_USER User,
	IN PTOKEN_GROUPS Groups,
	IN PTOKEN_PRIVILEGES Privileges,
	IN PTOKEN_OWNER Owner OPTIONAL,
	IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
	IN PTOKEN_DEFAULT_DACL DefaultDacl OPTIONAL,
	IN PTOKEN_SOURCE TokenSource);

EXTERN_C NTSTATUS NtCreateTokenEx(
	OUT PHANDLE TokenHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN TOKEN_TYPE TokenType,
	IN PLUID AuthenticationId,
	IN PLARGE_INTEGER ExpirationTime,
	IN PTOKEN_USER User,
	IN PTOKEN_GROUPS Groups,
	IN PTOKEN_PRIVILEGES Privileges,
	IN PTOKEN_SECURITY_ATTRIBUTES_INFORMATION UserAttributes OPTIONAL,
	IN PTOKEN_SECURITY_ATTRIBUTES_INFORMATION DeviceAttributes OPTIONAL,
	IN PTOKEN_GROUPS DeviceGroups OPTIONAL,
	IN PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy OPTIONAL,
	IN PTOKEN_OWNER Owner OPTIONAL,
	IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
	IN PTOKEN_DEFAULT_DACL DefaultDacl OPTIONAL,
	IN PTOKEN_SOURCE TokenSource);

EXTERN_C NTSTATUS NtCreateTransaction(
	OUT PHANDLE TransactionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN LPGUID Uow OPTIONAL,
	IN HANDLE TmHandle OPTIONAL,
	IN ULONG CreateOptions OPTIONAL,
	IN ULONG IsolationLevel OPTIONAL,
	IN ULONG IsolationFlags OPTIONAL,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	IN PUNICODE_STRING Description OPTIONAL);

EXTERN_C NTSTATUS NtCreateTransactionManager(
	OUT PHANDLE TmHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PUNICODE_STRING LogFileName OPTIONAL,
	IN ULONG CreateOptions OPTIONAL,
	IN ULONG CommitStrength OPTIONAL);

EXTERN_C NTSTATUS NtCreateUserProcess(
	OUT PHANDLE ProcessHandle,
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK ProcessDesiredAccess,
	IN ACCESS_MASK ThreadDesiredAccess,
	IN POBJECT_ATTRIBUTES ProcessObjectAttributes OPTIONAL,
	IN POBJECT_ATTRIBUTES ThreadObjectAttributes OPTIONAL,
	IN ULONG ProcessFlags,
	IN ULONG ThreadFlags,
	IN PVOID ProcessParameters OPTIONAL,
	IN OUT PPS_CREATE_INFO CreateInfo,
	IN PPS_ATTRIBUTE_LIST AttributeList OPTIONAL);

EXTERN_C NTSTATUS NtCreateWaitCompletionPacket(
	OUT PHANDLE WaitCompletionPacketHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

EXTERN_C NTSTATUS NtCreateWaitablePort(
	OUT PHANDLE PortHandle,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN ULONG MaxConnectionInfoLength,
	IN ULONG MaxMessageLength,
	IN ULONG MaxPoolUsage OPTIONAL);

EXTERN_C NTSTATUS NtCreateWnfStateName(
	OUT PCWNF_STATE_NAME StateName,
	IN WNF_STATE_NAME_LIFETIME NameLifetime,
	IN WNF_DATA_SCOPE DataScope,
	IN BOOLEAN PersistData,
	IN PCWNF_TYPE_ID TypeId OPTIONAL,
	IN ULONG MaximumStateSize,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor);

EXTERN_C NTSTATUS NtCreateWorkerFactory(
	OUT PHANDLE WorkerFactoryHandleReturn,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN HANDLE CompletionPortHandle,
	IN HANDLE WorkerProcessHandle,
	IN PVOID StartRoutine,
	IN PVOID StartParameter OPTIONAL,
	IN ULONG MaxThreadCount OPTIONAL,
	IN SIZE_T StackReserve OPTIONAL,
	IN SIZE_T StackCommit OPTIONAL);

EXTERN_C NTSTATUS NtDebugActiveProcess(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle);

EXTERN_C NTSTATUS NtDebugContinue(
	IN HANDLE DebugObjectHandle,
	IN PCLIENT_ID ClientId,
	IN NTSTATUS ContinueStatus);

EXTERN_C NTSTATUS NtDeleteAtom(
	IN USHORT Atom);

EXTERN_C NTSTATUS NtDeleteBootEntry(
	IN ULONG Id);

EXTERN_C NTSTATUS NtDeleteDriverEntry(
	IN ULONG Id);

EXTERN_C NTSTATUS NtDeleteFile(
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtDeleteKey(
	IN HANDLE KeyHandle);

EXTERN_C NTSTATUS NtDeleteObjectAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN BOOLEAN GenerateOnClose);

EXTERN_C NTSTATUS NtDeletePrivateNamespace(
	IN HANDLE NamespaceHandle);

EXTERN_C NTSTATUS NtDeleteValueKey(
	IN HANDLE KeyHandle,
	IN PUNICODE_STRING ValueName);

EXTERN_C NTSTATUS NtDeleteWnfStateData(
	IN PCWNF_STATE_NAME StateName,
	IN PVOID ExplicitScope OPTIONAL);

EXTERN_C NTSTATUS NtDeleteWnfStateName(
	IN PCWNF_STATE_NAME StateName);

EXTERN_C NTSTATUS NtDisableLastKnownGood();

EXTERN_C NTSTATUS NtDisplayString(
	IN PUNICODE_STRING String);

EXTERN_C NTSTATUS NtDrawText(
	IN PUNICODE_STRING String);

EXTERN_C NTSTATUS NtEnableLastKnownGood();

EXTERN_C NTSTATUS NtEnumerateBootEntries(
	OUT PVOID Buffer OPTIONAL,
	IN OUT PULONG BufferLength);

EXTERN_C NTSTATUS NtEnumerateDriverEntries(
	OUT PVOID Buffer OPTIONAL,
	IN OUT PULONG BufferLength);

EXTERN_C NTSTATUS NtEnumerateSystemEnvironmentValuesEx(
	IN ULONG InformationClass,
	OUT PVOID Buffer,
	IN OUT PULONG BufferLength);

EXTERN_C NTSTATUS NtEnumerateTransactionObject(
	IN HANDLE RootObjectHandle OPTIONAL,
	IN KTMOBJECT_TYPE QueryType,
	IN OUT PKTMOBJECT_CURSOR ObjectCursor,
	IN ULONG ObjectCursorLength,
	OUT PULONG ReturnLength);

EXTERN_C NTSTATUS NtExtendSection(
	IN HANDLE SectionHandle,
	IN OUT PLARGE_INTEGER NewSectionSize);

EXTERN_C NTSTATUS NtFilterBootOption(
	IN FILTER_BOOT_OPTION_OPERATION FilterOperation,
	IN ULONG ObjectType,
	IN ULONG ElementType,
	IN PVOID SystemData OPTIONAL,
	IN ULONG DataSize);

EXTERN_C NTSTATUS NtFilterToken(
	IN HANDLE ExistingTokenHandle,
	IN ULONG Flags,
	IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
	IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
	IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
	OUT PHANDLE NewTokenHandle);

EXTERN_C NTSTATUS NtFilterTokenEx(
	IN HANDLE TokenHandle,
	IN ULONG Flags,
	IN PTOKEN_GROUPS SidsToDisable OPTIONAL,
	IN PTOKEN_PRIVILEGES PrivilegesToDelete OPTIONAL,
	IN PTOKEN_GROUPS RestrictedSids OPTIONAL,
	IN ULONG DisableUserClaimsCount,
	IN PUNICODE_STRING UserClaimsToDisable OPTIONAL,
	IN ULONG DisableDeviceClaimsCount,
	IN PUNICODE_STRING DeviceClaimsToDisable OPTIONAL,
	IN PTOKEN_GROUPS DeviceGroupsToDisable OPTIONAL,
	IN PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedUserAttributes OPTIONAL,
	IN PTOKEN_SECURITY_ATTRIBUTES_INFORMATION RestrictedDeviceAttributes OPTIONAL,
	IN PTOKEN_GROUPS RestrictedDeviceGroups OPTIONAL,
	OUT PHANDLE NewTokenHandle);

EXTERN_C NTSTATUS NtFlushBuffersFileEx(
	IN HANDLE FileHandle,
	IN ULONG Flags,
	IN PVOID Parameters,
	IN ULONG ParametersSize,
	OUT PIO_STATUS_BLOCK IoStatusBlock);

EXTERN_C NTSTATUS NtFlushInstallUILanguage(
	IN LANGID InstallUILanguage,
	IN ULONG SetComittedFlag);

EXTERN_C NTSTATUS NtFlushInstructionCache(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress OPTIONAL,
	IN ULONG Length);

EXTERN_C NTSTATUS NtFlushKey(
	IN HANDLE KeyHandle);

EXTERN_C NTSTATUS NtFlushProcessWriteBuffers();

EXTERN_C NTSTATUS NtFlushVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID BaseAddress,
	IN OUT PULONG RegionSize,
	OUT PIO_STATUS_BLOCK IoStatusBlock);

EXTERN_C NTSTATUS NtFlushWriteBuffer();

EXTERN_C NTSTATUS NtFreeUserPhysicalPages(
	IN HANDLE ProcessHandle,
	IN OUT PULONG NumberOfPages,
	IN PULONG UserPfnArray);

EXTERN_C NTSTATUS NtFreezeRegistry(
	IN ULONG TimeOutInSeconds);

EXTERN_C NTSTATUS NtFreezeTransactions(
	IN PLARGE_INTEGER FreezeTimeout,
	IN PLARGE_INTEGER ThawTimeout);

EXTERN_C NTSTATUS NtGetCachedSigningLevel(
	IN HANDLE File,
	OUT PULONG Flags,
	OUT PSE_SIGNING_LEVEL SigningLevel,
	OUT PUCHAR Thumbprint OPTIONAL,
	IN OUT PULONG ThumbprintSize OPTIONAL,
	OUT PULONG ThumbprintAlgorithm OPTIONAL);

EXTERN_C NTSTATUS NtGetCompleteWnfStateSubscription(
	IN PCWNF_STATE_NAME OldDescriptorStateName OPTIONAL,
	IN PLARGE_INTEGER OldSubscriptionId OPTIONAL,
	IN ULONG OldDescriptorEventMask OPTIONAL,
	IN ULONG OldDescriptorStatus OPTIONAL,
	OUT PWNF_DELIVERY_DESCRIPTOR NewDeliveryDescriptor,
	IN ULONG DescriptorSize);

EXTERN_C NTSTATUS NtGetContextThread(
	IN HANDLE ThreadHandle,
	IN OUT PCONTEXT ThreadContext);

EXTERN_C NTSTATUS NtGetCurrentProcessorNumber();

EXTERN_C NTSTATUS NtGetCurrentProcessorNumberEx(
	OUT PULONG ProcNumber OPTIONAL);

EXTERN_C NTSTATUS NtGetDevicePowerState(
	IN HANDLE Device,
	OUT PDEVICE_POWER_STATE State);

EXTERN_C NTSTATUS NtGetMUIRegistryInfo(
	IN ULONG Flags,
	IN OUT PULONG DataSize,
	OUT PVOID SystemData);

EXTERN_C NTSTATUS NtGetNextProcess(
	IN HANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Flags,
	OUT PHANDLE NewProcessHandle);

EXTERN_C NTSTATUS NtGetNextThread(
	IN HANDLE ProcessHandle,
	IN HANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Flags,
	OUT PHANDLE NewThreadHandle);

EXTERN_C NTSTATUS NtGetNlsSectionPtr(
	IN ULONG SectionType,
	IN ULONG SectionData,
	IN PVOID ContextData,
	OUT PVOID SectionPointer,
	OUT PULONG SectionSize);

EXTERN_C NTSTATUS NtGetNotificationResourceManager(
	IN HANDLE ResourceManagerHandle,
	OUT PTRANSACTION_NOTIFICATION TransactionNotification,
	IN ULONG NotificationLength,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	OUT PULONG ReturnLength OPTIONAL,
	IN ULONG Asynchronous,
	IN ULONG AsynchronousContext OPTIONAL);

EXTERN_C NTSTATUS NtGetWriteWatch(
	IN HANDLE ProcessHandle,
	IN ULONG Flags,
	IN PVOID BaseAddress,
	IN ULONG RegionSize,
	OUT PULONG UserAddressArray,
	IN OUT PULONG EntriesInUserAddressArray,
	OUT PULONG Granularity);

EXTERN_C NTSTATUS NtImpersonateAnonymousToken(
	IN HANDLE ThreadHandle);

EXTERN_C NTSTATUS NtImpersonateThread(
	IN HANDLE ServerThreadHandle,
	IN HANDLE ClientThreadHandle,
	IN PSECURITY_QUALITY_OF_SERVICE SecurityQos);

EXTERN_C NTSTATUS NtInitializeEnclave(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN PVOID EnclaveInformation,
	IN ULONG EnclaveInformationLength,
	OUT PULONG EnclaveError OPTIONAL);

EXTERN_C NTSTATUS NtInitializeNlsFiles(
	OUT PVOID BaseAddress,
	OUT PLCID DefaultLocaleId,
	OUT PLARGE_INTEGER DefaultCasingTableSize);

EXTERN_C NTSTATUS NtInitializeRegistry(
	IN USHORT BootCondition);

EXTERN_C NTSTATUS NtInitiatePowerAction(
	IN POWER_ACTION SystemAction,
	IN SYSTEM_POWER_STATE LightestSystemState,
	IN ULONG Flags,
	IN BOOLEAN Asynchronous);

EXTERN_C NTSTATUS NtIsSystemResumeAutomatic();

EXTERN_C NTSTATUS NtIsUILanguageComitted();

EXTERN_C NTSTATUS NtListenPort(
	IN HANDLE PortHandle,
	OUT PPORT_MESSAGE ConnectionRequest);

EXTERN_C NTSTATUS NtLoadDriver(
	IN PUNICODE_STRING DriverServiceName);

EXTERN_C NTSTATUS NtLoadEnclaveData(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN PVOID Buffer,
	IN SIZE_T BufferSize,
	IN ULONG Protect,
	IN PVOID PageInformation,
	IN ULONG PageInformationLength,
	OUT PSIZE_T NumberOfBytesWritten OPTIONAL,
	OUT PULONG EnclaveError OPTIONAL);

EXTERN_C NTSTATUS NtLoadHotPatch(
	IN PUNICODE_STRING HotPatchName,
	IN ULONG LoadFlag);

EXTERN_C NTSTATUS NtLoadKey(
	IN POBJECT_ATTRIBUTES TargetKey,
	IN POBJECT_ATTRIBUTES SourceFile);

EXTERN_C NTSTATUS NtLoadKey2(
	IN POBJECT_ATTRIBUTES TargetKey,
	IN POBJECT_ATTRIBUTES SourceFile,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtLoadKeyEx(
	IN POBJECT_ATTRIBUTES TargetKey,
	IN POBJECT_ATTRIBUTES SourceFile,
	IN ULONG Flags,
	IN HANDLE TrustClassKey OPTIONAL,
	IN HANDLE Event OPTIONAL,
	IN ACCESS_MASK DesiredAccess OPTIONAL,
	OUT PHANDLE RootHandle OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatus OPTIONAL);

EXTERN_C NTSTATUS NtLockFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PULARGE_INTEGER ByteOffset,
	IN PULARGE_INTEGER Length,
	IN ULONG Key,
	IN BOOLEAN FailImmediately,
	IN BOOLEAN ExclusiveLock);

EXTERN_C NTSTATUS NtLockProductActivationKeys(
	IN OUT PULONG pPrivateVer OPTIONAL,
	OUT PULONG pSafeMode OPTIONAL);

EXTERN_C NTSTATUS NtLockRegistryKey(
	IN HANDLE KeyHandle);

EXTERN_C NTSTATUS NtLockVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN PULONG RegionSize,
	IN ULONG MapType);

EXTERN_C NTSTATUS NtMakePermanentObject(
	IN HANDLE Handle);

EXTERN_C NTSTATUS NtMakeTemporaryObject(
	IN HANDLE Handle);

EXTERN_C NTSTATUS NtManagePartition(
	IN HANDLE TargetHandle,
	IN HANDLE SourceHandle,
	IN MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
	IN OUT PVOID PartitionInformation,
	IN ULONG PartitionInformationLength);

EXTERN_C NTSTATUS NtMapCMFModule(
	IN ULONG What,
	IN ULONG Index,
	OUT PULONG CacheIndexOut OPTIONAL,
	OUT PULONG CacheFlagsOut OPTIONAL,
	OUT PULONG ViewSizeOut OPTIONAL,
	OUT PVOID BaseAddress OPTIONAL);

EXTERN_C NTSTATUS NtMapUserPhysicalPages(
	IN PVOID VirtualAddress,
	IN PULONG NumberOfPages,
	IN PULONG UserPfnArray OPTIONAL);

EXTERN_C NTSTATUS NtMapViewOfSectionEx(
	IN HANDLE SectionHandle,
	IN HANDLE ProcessHandle,
	IN OUT PLARGE_INTEGER SectionOffset,
	IN OUT PPVOID BaseAddress,
	IN OUT PSIZE_T ViewSize,
	IN ULONG AllocationType,
	IN ULONG Protect,
	IN OUT PVOID DataBuffer OPTIONAL,
	IN ULONG DataCount);

EXTERN_C NTSTATUS NtModifyBootEntry(
	IN PBOOT_ENTRY BootEntry);

EXTERN_C NTSTATUS NtModifyDriverEntry(
	IN PEFI_DRIVER_ENTRY DriverEntry);

EXTERN_C NTSTATUS NtNotifyChangeDirectoryFile(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PFILE_NOTIFY_INFORMATION Buffer,
	IN ULONG Length,
	IN ULONG CompletionFilter,
	IN BOOLEAN WatchTree);

EXTERN_C NTSTATUS NtNotifyChangeDirectoryFileEx(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID Buffer,
	IN ULONG Length,
	IN ULONG CompletionFilter,
	IN BOOLEAN WatchTree,
	IN DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass OPTIONAL);

EXTERN_C NTSTATUS NtNotifyChangeKey(
	IN HANDLE KeyHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG CompletionFilter,
	IN BOOLEAN WatchTree,
	OUT PVOID Buffer OPTIONAL,
	IN ULONG BufferSize,
	IN BOOLEAN Asynchronous);

EXTERN_C NTSTATUS NtNotifyChangeMultipleKeys(
	IN HANDLE MasterKeyHandle,
	IN ULONG Count OPTIONAL,
	IN POBJECT_ATTRIBUTES SubordinateObjects OPTIONAL,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG CompletionFilter,
	IN BOOLEAN WatchTree,
	OUT PVOID Buffer OPTIONAL,
	IN ULONG BufferSize,
	IN BOOLEAN Asynchronous);

EXTERN_C NTSTATUS NtNotifyChangeSession(
	IN HANDLE SessionHandle,
	IN ULONG ChangeSequenceNumber,
	IN PLARGE_INTEGER ChangeTimeStamp,
	IN IO_SESSION_EVENT Event,
	IN IO_SESSION_STATE NewState,
	IN IO_SESSION_STATE PreviousState,
	IN PVOID Payload OPTIONAL,
	IN ULONG PayloadSize);

EXTERN_C NTSTATUS NtOpenEnlistment(
	OUT PHANDLE EnlistmentHandle,
	IN ACCESS_MASK DesiredAccess,
	IN HANDLE ResourceManagerHandle,
	IN LPGUID EnlistmentGuid,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

EXTERN_C NTSTATUS NtOpenEventPair(
	OUT PHANDLE EventPairHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenIoCompletion(
	OUT PHANDLE IoCompletionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenJobObject(
	OUT PHANDLE JobHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenKeyEx(
	OUT PHANDLE KeyHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG OpenOptions);

EXTERN_C NTSTATUS NtOpenKeyTransacted(
	OUT PHANDLE KeyHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN HANDLE TransactionHandle);

EXTERN_C NTSTATUS NtOpenKeyTransactedEx(
	OUT PHANDLE KeyHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG OpenOptions,
	IN HANDLE TransactionHandle);

EXTERN_C NTSTATUS NtOpenKeyedEvent(
	OUT PHANDLE KeyedEventHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenMutant(
	OUT PHANDLE MutantHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenObjectAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN PUNICODE_STRING ObjectTypeName,
	IN PUNICODE_STRING ObjectName,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
	IN HANDLE ClientToken,
	IN ACCESS_MASK DesiredAccess,
	IN ACCESS_MASK GrantedAccess,
	IN PPRIVILEGE_SET Privileges OPTIONAL,
	IN BOOLEAN ObjectCreation,
	IN BOOLEAN AccessGranted,
	OUT PBOOLEAN GenerateOnClose);

EXTERN_C NTSTATUS NtOpenPartition(
	OUT PHANDLE PartitionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenPrivateNamespace(
	OUT PHANDLE NamespaceHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PVOID BoundaryDescriptor);

EXTERN_C NTSTATUS NtOpenProcessToken(
	IN HANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	OUT PHANDLE TokenHandle);

EXTERN_C NTSTATUS NtOpenRegistryTransaction(
	OUT PHANDLE RegistryHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenResourceManager(
	OUT PHANDLE ResourceManagerHandle,
	IN ACCESS_MASK DesiredAccess,
	IN HANDLE TmHandle,
	IN LPGUID ResourceManagerGuid OPTIONAL,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL);

EXTERN_C NTSTATUS NtOpenSemaphore(
	OUT PHANDLE SemaphoreHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenSession(
	OUT PHANDLE SessionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenSymbolicLinkObject(
	OUT PHANDLE LinkHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenThread(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId OPTIONAL);

EXTERN_C NTSTATUS NtOpenTimer(
	OUT PHANDLE TimerHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes);

EXTERN_C NTSTATUS NtOpenTransaction(
	OUT PHANDLE TransactionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN LPGUID Uow,
	IN HANDLE TmHandle OPTIONAL);

EXTERN_C NTSTATUS NtOpenTransactionManager(
	OUT PHANDLE TmHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PUNICODE_STRING LogFileName OPTIONAL,
	IN LPGUID TmIdentity OPTIONAL,
	IN ULONG OpenOptions OPTIONAL);

EXTERN_C NTSTATUS NtPlugPlayControl(
	IN PLUGPLAY_CONTROL_CLASS PnPControlClass,
	IN OUT PVOID PnPControlData,
	IN ULONG PnPControlDataLength);

EXTERN_C NTSTATUS NtPrePrepareComplete(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtPrePrepareEnlistment(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtPrepareComplete(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtPrepareEnlistment(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtPrivilegeCheck(
	IN HANDLE ClientToken,
	IN OUT PPRIVILEGE_SET RequiredPrivileges,
	OUT PBOOLEAN Result);

EXTERN_C NTSTATUS NtPrivilegeObjectAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PVOID HandleId OPTIONAL,
	IN HANDLE ClientToken,
	IN ACCESS_MASK DesiredAccess,
	IN PPRIVILEGE_SET Privileges,
	IN BOOLEAN AccessGranted);

EXTERN_C NTSTATUS NtPrivilegedServiceAuditAlarm(
	IN PUNICODE_STRING SubsystemName,
	IN PUNICODE_STRING ServiceName,
	IN HANDLE ClientToken,
	IN PPRIVILEGE_SET Privileges,
	IN BOOLEAN AccessGranted);

EXTERN_C NTSTATUS NtPropagationComplete(
	IN HANDLE ResourceManagerHandle,
	IN ULONG RequestCookie,
	IN ULONG BufferLength,
	IN PVOID Buffer);

EXTERN_C NTSTATUS NtPropagationFailed(
	IN HANDLE ResourceManagerHandle,
	IN ULONG RequestCookie,
	IN NTSTATUS PropStatus);

EXTERN_C NTSTATUS NtPulseEvent(
	IN HANDLE EventHandle,
	OUT PULONG PreviousState OPTIONAL);

EXTERN_C NTSTATUS NtQueryAuxiliaryCounterFrequency(
	OUT PULONGLONG lpAuxiliaryCounterFrequency);

EXTERN_C NTSTATUS NtQueryBootEntryOrder(
	OUT PULONG Ids OPTIONAL,
	IN OUT PULONG Count);

EXTERN_C NTSTATUS NtQueryBootOptions(
	OUT PBOOT_OPTIONS BootOptions OPTIONAL,
	IN OUT PULONG BootOptionsLength);

EXTERN_C NTSTATUS NtQueryDebugFilterState(
	IN ULONG ComponentId,
	IN ULONG Level);

EXTERN_C NTSTATUS NtQueryDirectoryFileEx(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN ULONG QueryFlags,
	IN PUNICODE_STRING FileName OPTIONAL);

EXTERN_C NTSTATUS NtQueryDirectoryObject(
	IN HANDLE DirectoryHandle,
	OUT PVOID Buffer OPTIONAL,
	IN ULONG Length,
	IN BOOLEAN ReturnSingleEntry,
	IN BOOLEAN RestartScan,
	IN OUT PULONG Context,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryDriverEntryOrder(
	IN PULONG Ids OPTIONAL,
	IN OUT PULONG Count);

EXTERN_C NTSTATUS NtQueryEaFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PFILE_FULL_EA_INFORMATION Buffer,
	IN ULONG Length,
	IN BOOLEAN ReturnSingleEntry,
	IN PFILE_GET_EA_INFORMATION EaList OPTIONAL,
	IN ULONG EaListLength,
	IN PULONG EaIndex OPTIONAL,
	IN BOOLEAN RestartScan);

EXTERN_C NTSTATUS NtQueryFullAttributesFile(
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation);

EXTERN_C NTSTATUS NtQueryInformationAtom(
	IN USHORT Atom,
	IN ATOM_INFORMATION_CLASS AtomInformationClass,
	OUT PVOID AtomInformation,
	IN ULONG AtomInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationByName(
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass);

EXTERN_C NTSTATUS NtQueryInformationEnlistment(
	IN HANDLE EnlistmentHandle,
	IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
	OUT PVOID EnlistmentInformation,
	IN ULONG EnlistmentInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationJobObject(
	IN HANDLE JobHandle,
	IN JOBOBJECTINFOCLASS JobObjectInformationClass,
	OUT PVOID JobObjectInformation,
	IN ULONG JobObjectInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationPort(
	IN HANDLE PortHandle,
	IN PORT_INFORMATION_CLASS PortInformationClass,
	OUT PVOID PortInformation,
	IN ULONG Length,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationResourceManager(
	IN HANDLE ResourceManagerHandle,
	IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
	OUT PVOID ResourceManagerInformation,
	IN ULONG ResourceManagerInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationTransaction(
	IN HANDLE TransactionHandle,
	IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
	OUT PVOID TransactionInformation,
	IN ULONG TransactionInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationTransactionManager(
	IN HANDLE TransactionManagerHandle,
	IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
	OUT PVOID TransactionManagerInformation,
	IN ULONG TransactionManagerInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInformationWorkerFactory(
	IN HANDLE WorkerFactoryHandle,
	IN WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
	OUT PVOID WorkerFactoryInformation,
	IN ULONG WorkerFactoryInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryInstallUILanguage(
	OUT PLANGID InstallUILanguageId);

EXTERN_C NTSTATUS NtQueryIntervalProfile(
	IN KPROFILE_SOURCE ProfileSource,
	OUT PULONG Interval);

EXTERN_C NTSTATUS NtQueryIoCompletion(
	IN HANDLE IoCompletionHandle,
	IN IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
	OUT PVOID IoCompletionInformation,
	IN ULONG IoCompletionInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryLicenseValue(
	IN PUNICODE_STRING ValueName,
	OUT PULONG Type OPTIONAL,
	OUT PVOID SystemData OPTIONAL,
	IN ULONG DataSize,
	OUT PULONG ResultDataSize);

EXTERN_C NTSTATUS NtQueryMultipleValueKey(
	IN HANDLE KeyHandle,
	IN OUT PKEY_VALUE_ENTRY ValueEntries,
	IN ULONG EntryCount,
	OUT PVOID ValueBuffer,
	IN PULONG BufferLength,
	OUT PULONG RequiredBufferLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryMutant(
	IN HANDLE MutantHandle,
	IN MUTANT_INFORMATION_CLASS MutantInformationClass,
	OUT PVOID MutantInformation,
	IN ULONG MutantInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryOpenSubKeys(
	IN POBJECT_ATTRIBUTES TargetKey,
	OUT PULONG HandleCount);

EXTERN_C NTSTATUS NtQueryOpenSubKeysEx(
	IN POBJECT_ATTRIBUTES TargetKey,
	IN ULONG BufferLength,
	OUT PVOID Buffer,
	OUT PULONG RequiredSize);

EXTERN_C NTSTATUS NtQueryPortInformationProcess();

EXTERN_C NTSTATUS NtQueryQuotaInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PFILE_USER_QUOTA_INFORMATION Buffer,
	IN ULONG Length,
	IN BOOLEAN ReturnSingleEntry,
	IN PFILE_QUOTA_LIST_INFORMATION SidList OPTIONAL,
	IN ULONG SidListLength,
	IN PSID StartSid OPTIONAL,
	IN BOOLEAN RestartScan);

EXTERN_C NTSTATUS NtQuerySecurityAttributesToken(
	IN HANDLE TokenHandle,
	IN PUNICODE_STRING Attributes OPTIONAL,
	IN ULONG NumberOfAttributes,
	OUT PVOID Buffer,
	IN ULONG Length,
	OUT PULONG ReturnLength);

EXTERN_C NTSTATUS NtQuerySecurityObject(
	IN HANDLE Handle,
	IN SECURITY_INFORMATION SecurityInformation,
	OUT PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
	IN ULONG Length,
	OUT PULONG LengthNeeded);

EXTERN_C NTSTATUS NtQuerySecurityPolicy(
	IN ULONG_PTR UnknownParameter1,
	IN ULONG_PTR UnknownParameter2,
	IN ULONG_PTR UnknownParameter3,
	IN ULONG_PTR UnknownParameter4,
	IN ULONG_PTR UnknownParameter5,
	IN ULONG_PTR UnknownParameter6);

EXTERN_C NTSTATUS NtQuerySemaphore(
	IN HANDLE SemaphoreHandle,
	IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
	OUT PVOID SemaphoreInformation,
	IN ULONG SemaphoreInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQuerySymbolicLinkObject(
	IN HANDLE LinkHandle,
	IN OUT PUNICODE_STRING LinkTarget,
	OUT PULONG ReturnedLength OPTIONAL);

EXTERN_C NTSTATUS NtQuerySystemEnvironmentValue(
	IN PUNICODE_STRING VariableName,
	OUT PVOID VariableValue,
	IN ULONG ValueLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQuerySystemEnvironmentValueEx(
	IN PUNICODE_STRING VariableName,
	IN LPGUID VendorGuid,
	OUT PVOID Value OPTIONAL,
	IN OUT PULONG ValueLength,
	OUT PULONG Attributes OPTIONAL);

EXTERN_C NTSTATUS NtQuerySystemInformationEx(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	IN PVOID InputBuffer,
	IN ULONG InputBufferLength,
	OUT PVOID SystemInformation OPTIONAL,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtQueryTimerResolution(
	OUT PULONG MaximumTime,
	OUT PULONG MinimumTime,
	OUT PULONG CurrentTime);

EXTERN_C NTSTATUS NtQueryWnfStateData(
	IN PCWNF_STATE_NAME StateName,
	IN PCWNF_TYPE_ID TypeId OPTIONAL,
	IN PVOID ExplicitScope OPTIONAL,
	OUT PWNF_CHANGE_STAMP ChangeStamp,
	OUT PVOID Buffer OPTIONAL,
	IN OUT PULONG BufferSize);

EXTERN_C NTSTATUS NtQueryWnfStateNameInformation(
	IN PCWNF_STATE_NAME StateName,
	IN PCWNF_TYPE_ID NameInfoClass,
	IN PVOID ExplicitScope OPTIONAL,
	OUT PVOID InfoBuffer,
	IN ULONG InfoBufferSize);

EXTERN_C NTSTATUS NtQueueApcThreadEx(
	IN HANDLE ThreadHandle,
	IN HANDLE UserApcReserveHandle OPTIONAL,
	IN PKNORMAL_ROUTINE ApcRoutine,
	IN PVOID ApcArgument1 OPTIONAL,
	IN PVOID ApcArgument2 OPTIONAL,
	IN PVOID ApcArgument3 OPTIONAL);

EXTERN_C NTSTATUS NtRaiseException(
	IN PEXCEPTION_RECORD ExceptionRecord,
	IN PCONTEXT ContextRecord,
	IN BOOLEAN FirstChance);

EXTERN_C NTSTATUS NtRaiseHardError(
	IN NTSTATUS ErrorStatus,
	IN ULONG NumberOfParameters,
	IN ULONG UnicodeStringParameterMask,
	IN PULONG_PTR Parameters,
	IN ULONG ValidResponseOptions,
	OUT PULONG Response);

EXTERN_C NTSTATUS NtReadOnlyEnlistment(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtRecoverEnlistment(
	IN HANDLE EnlistmentHandle,
	IN PVOID EnlistmentKey OPTIONAL);

EXTERN_C NTSTATUS NtRecoverResourceManager(
	IN HANDLE ResourceManagerHandle);

EXTERN_C NTSTATUS NtRecoverTransactionManager(
	IN HANDLE TransactionManagerHandle);

EXTERN_C NTSTATUS NtRegisterProtocolAddressInformation(
	IN HANDLE ResourceManager,
	IN LPGUID ProtocolId,
	IN ULONG ProtocolInformationSize,
	IN PVOID ProtocolInformation,
	IN ULONG CreateOptions OPTIONAL);

EXTERN_C NTSTATUS NtRegisterThreadTerminatePort(
	IN HANDLE PortHandle);

EXTERN_C NTSTATUS NtReleaseKeyedEvent(
	IN HANDLE KeyedEventHandle,
	IN PVOID KeyValue,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtReleaseWorkerFactoryWorker(
	IN HANDLE WorkerFactoryHandle);

EXTERN_C NTSTATUS NtRemoveIoCompletionEx(
	IN HANDLE IoCompletionHandle,
	OUT PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
	IN ULONG Count,
	OUT PULONG NumEntriesRemoved,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	IN BOOLEAN Alertable);

EXTERN_C NTSTATUS NtRemoveProcessDebug(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle);

EXTERN_C NTSTATUS NtRenameKey(
	IN HANDLE KeyHandle,
	IN PUNICODE_STRING NewName);

EXTERN_C NTSTATUS NtRenameTransactionManager(
	IN PUNICODE_STRING LogFileName,
	IN LPGUID ExistingTransactionManagerGuid);

EXTERN_C NTSTATUS NtReplaceKey(
	IN POBJECT_ATTRIBUTES NewFile,
	IN HANDLE TargetHandle,
	IN POBJECT_ATTRIBUTES OldFile);

EXTERN_C NTSTATUS NtReplacePartitionUnit(
	IN PUNICODE_STRING TargetInstancePath,
	IN PUNICODE_STRING SpareInstancePath,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtReplyWaitReplyPort(
	IN HANDLE PortHandle,
	IN OUT PPORT_MESSAGE ReplyMessage);

EXTERN_C NTSTATUS NtRequestPort(
	IN HANDLE PortHandle,
	IN PPORT_MESSAGE RequestMessage);

EXTERN_C NTSTATUS NtResetEvent(
	IN HANDLE EventHandle,
	OUT PULONG PreviousState OPTIONAL);

EXTERN_C NTSTATUS NtResetWriteWatch(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN ULONG RegionSize);

EXTERN_C NTSTATUS NtRestoreKey(
	IN HANDLE KeyHandle,
	IN HANDLE FileHandle,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtResumeProcess(
	IN HANDLE ProcessHandle);

EXTERN_C NTSTATUS NtRevertContainerImpersonation();

EXTERN_C NTSTATUS NtRollbackComplete(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtRollbackEnlistment(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtRollbackRegistryTransaction(
	IN HANDLE RegistryHandle,
	IN BOOL Wait);

EXTERN_C NTSTATUS NtRollbackTransaction(
	IN HANDLE TransactionHandle,
	IN BOOLEAN Wait);

EXTERN_C NTSTATUS NtRollforwardTransactionManager(
	IN HANDLE TransactionManagerHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtSaveKey(
	IN HANDLE KeyHandle,
	IN HANDLE FileHandle);

EXTERN_C NTSTATUS NtSaveKeyEx(
	IN HANDLE KeyHandle,
	IN HANDLE FileHandle,
	IN ULONG Format);

EXTERN_C NTSTATUS NtSaveMergedKeys(
	IN HANDLE HighPrecedenceKeyHandle,
	IN HANDLE LowPrecedenceKeyHandle,
	IN HANDLE FileHandle);

EXTERN_C NTSTATUS NtSecureConnectPort(
	OUT PHANDLE PortHandle,
	IN PUNICODE_STRING PortName,
	IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
	IN OUT PPORT_SECTION_WRITE ClientView OPTIONAL,
	IN PSID RequiredServerSid OPTIONAL,
	IN OUT PPORT_SECTION_READ ServerView OPTIONAL,
	OUT PULONG MaxMessageLength OPTIONAL,
	IN OUT PVOID ConnectionInformation OPTIONAL,
	IN OUT PULONG ConnectionInformationLength OPTIONAL);

EXTERN_C NTSTATUS NtSerializeBoot();

EXTERN_C NTSTATUS NtSetBootEntryOrder(
	IN PULONG Ids,
	IN ULONG Count);

EXTERN_C NTSTATUS NtSetBootOptions(
	IN PBOOT_OPTIONS BootOptions,
	IN ULONG FieldsToChange);

EXTERN_C NTSTATUS NtSetCachedSigningLevel(
	IN ULONG Flags,
	IN SE_SIGNING_LEVEL InputSigningLevel,
	IN PHANDLE SourceFiles,
	IN ULONG SourceFileCount,
	IN HANDLE TargetFile OPTIONAL);

EXTERN_C NTSTATUS NtSetCachedSigningLevel2(
	IN ULONG Flags,
	IN ULONG InputSigningLevel,
	IN PHANDLE SourceFiles,
	IN ULONG SourceFileCount,
	IN HANDLE TargetFile OPTIONAL,
	IN PVOID LevelInformation OPTIONAL);

EXTERN_C NTSTATUS NtSetContextThread(
	IN HANDLE ThreadHandle,
	IN PCONTEXT Context);

EXTERN_C NTSTATUS NtSetDebugFilterState(
	IN ULONG ComponentId,
	IN ULONG Level,
	IN BOOLEAN State);

EXTERN_C NTSTATUS NtSetDefaultHardErrorPort(
	IN HANDLE PortHandle);

EXTERN_C NTSTATUS NtSetDefaultLocale(
	IN BOOLEAN UserProfile,
	IN LCID DefaultLocaleId);

EXTERN_C NTSTATUS NtSetDefaultUILanguage(
	IN LANGID DefaultUILanguageId);

EXTERN_C NTSTATUS NtSetDriverEntryOrder(
	IN PULONG Ids,
	IN PULONG Count);

EXTERN_C NTSTATUS NtSetEaFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PFILE_FULL_EA_INFORMATION EaBuffer,
	IN ULONG EaBufferSize);

EXTERN_C NTSTATUS NtSetHighEventPair(
	IN HANDLE EventPairHandle);

EXTERN_C NTSTATUS NtSetHighWaitLowEventPair(
	IN HANDLE EventPairHandle);

EXTERN_C NTSTATUS NtSetIRTimer(
	IN HANDLE TimerHandle,
	IN PLARGE_INTEGER DueTime OPTIONAL);

EXTERN_C NTSTATUS NtSetInformationDebugObject(
	IN HANDLE DebugObject,
	IN DEBUGOBJECTINFOCLASS InformationClass,
	IN PVOID Information,
	IN ULONG InformationLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtSetInformationEnlistment(
	IN HANDLE EnlistmentHandle,
	IN ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
	IN PVOID EnlistmentInformation,
	IN ULONG EnlistmentInformationLength);

EXTERN_C NTSTATUS NtSetInformationJobObject(
	IN HANDLE JobHandle,
	IN JOBOBJECTINFOCLASS JobObjectInformationClass,
	IN PVOID JobObjectInformation,
	IN ULONG JobObjectInformationLength);

EXTERN_C NTSTATUS NtSetInformationKey(
	IN HANDLE KeyHandle,
	IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
	IN PVOID KeySetInformation,
	IN ULONG KeySetInformationLength);

EXTERN_C NTSTATUS NtSetInformationResourceManager(
	IN HANDLE ResourceManagerHandle,
	IN RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
	IN PVOID ResourceManagerInformation,
	IN ULONG ResourceManagerInformationLength);

EXTERN_C NTSTATUS NtSetInformationSymbolicLink(
	IN HANDLE Handle,
	IN ULONG Class,
	IN PVOID Buffer,
	IN ULONG BufferLength);

EXTERN_C NTSTATUS NtSetInformationToken(
	IN HANDLE TokenHandle,
	IN TOKEN_INFORMATION_CLASS TokenInformationClass,
	IN PVOID TokenInformation,
	IN ULONG TokenInformationLength);

EXTERN_C NTSTATUS NtSetInformationTransaction(
	IN HANDLE TransactionHandle,
	IN TRANSACTIONMANAGER_INFORMATION_CLASS TransactionInformationClass,
	IN PVOID TransactionInformation,
	IN ULONG TransactionInformationLength);

EXTERN_C NTSTATUS NtSetInformationTransactionManager(
	IN HANDLE TransactionHandle,
	IN TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
	IN PVOID TransactionInformation,
	IN ULONG TransactionInformationLength);

EXTERN_C NTSTATUS NtSetInformationVirtualMemory(
	IN HANDLE ProcessHandle,
	IN VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
	IN ULONG_PTR NumberOfEntries,
	IN PMEMORY_RANGE_ENTRY VirtualAddresses,
	IN PVOID VmInformation,
	IN ULONG VmInformationLength);

EXTERN_C NTSTATUS NtSetInformationWorkerFactory(
	IN HANDLE WorkerFactoryHandle,
	IN WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
	IN PVOID WorkerFactoryInformation,
	IN ULONG WorkerFactoryInformationLength);

EXTERN_C NTSTATUS NtSetIntervalProfile(
	IN ULONG Interval,
	IN KPROFILE_SOURCE Source);

EXTERN_C NTSTATUS NtSetIoCompletion(
	IN HANDLE IoCompletionHandle,
	IN ULONG CompletionKey,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN NTSTATUS CompletionStatus,
	IN ULONG NumberOfBytesTransfered);

EXTERN_C NTSTATUS NtSetIoCompletionEx(
	IN HANDLE IoCompletionHandle,
	IN HANDLE IoCompletionPacketHandle,
	IN PVOID KeyContext OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	IN NTSTATUS IoStatus,
	IN ULONG_PTR IoStatusInformation);

EXTERN_C NTSTATUS NtSetLdtEntries(
	IN ULONG Selector0,
	IN ULONG Entry0Low,
	IN ULONG Entry0Hi,
	IN ULONG Selector1,
	IN ULONG Entry1Low,
	IN ULONG Entry1Hi);

EXTERN_C NTSTATUS NtSetLowEventPair(
	IN HANDLE EventPairHandle);

EXTERN_C NTSTATUS NtSetLowWaitHighEventPair(
	IN HANDLE EventPairHandle);

EXTERN_C NTSTATUS NtSetQuotaInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PFILE_USER_QUOTA_INFORMATION Buffer,
	IN ULONG Length);

EXTERN_C NTSTATUS NtSetSecurityObject(
	IN HANDLE ObjectHandle,
	IN SECURITY_INFORMATION SecurityInformationClass,
	IN PSECURITY_DESCRIPTOR DescriptorBuffer);

EXTERN_C NTSTATUS NtSetSystemEnvironmentValue(
	IN PUNICODE_STRING VariableName,
	IN PUNICODE_STRING Value);

EXTERN_C NTSTATUS NtSetSystemEnvironmentValueEx(
	IN PUNICODE_STRING VariableName,
	IN LPGUID VendorGuid,
	IN PVOID Value OPTIONAL,
	IN ULONG ValueLength,
	IN ULONG Attributes);

EXTERN_C NTSTATUS NtSetSystemInformation(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	IN PVOID SystemInformation,
	IN ULONG SystemInformationLength);

EXTERN_C NTSTATUS NtSetSystemPowerState(
	IN POWER_ACTION SystemAction,
	IN SYSTEM_POWER_STATE MinSystemState,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtSetSystemTime(
	IN PLARGE_INTEGER SystemTime,
	OUT PLARGE_INTEGER PreviousTime OPTIONAL);

EXTERN_C NTSTATUS NtSetThreadExecutionState(
	IN EXECUTION_STATE ExecutionState,
	OUT PEXECUTION_STATE PreviousExecutionState);

EXTERN_C NTSTATUS NtSetTimer2(
	IN HANDLE TimerHandle,
	IN PLARGE_INTEGER DueTime,
	IN PLARGE_INTEGER Period OPTIONAL,
	IN PT2_SET_PARAMETERS Parameters);

EXTERN_C NTSTATUS NtSetTimerEx(
	IN HANDLE TimerHandle,
	IN TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
	IN OUT PVOID TimerSetInformation OPTIONAL,
	IN ULONG TimerSetInformationLength);

EXTERN_C NTSTATUS NtSetTimerResolution(
	IN ULONG DesiredResolution,
	IN BOOLEAN SetResolution,
	OUT PULONG CurrentResolution);

EXTERN_C NTSTATUS NtSetUuidSeed(
	IN PUCHAR Seed);

EXTERN_C NTSTATUS NtSetVolumeInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileSystemInformation,
	IN ULONG Length,
	IN FSINFOCLASS FileSystemInformationClass);

EXTERN_C NTSTATUS NtSetWnfProcessNotificationEvent(
	IN HANDLE NotificationEvent);

EXTERN_C NTSTATUS NtShutdownSystem(
	IN SHUTDOWN_ACTION Action);

EXTERN_C NTSTATUS NtShutdownWorkerFactory(
	IN HANDLE WorkerFactoryHandle,
	IN OUT PLONG PendingWorkerCount);

EXTERN_C NTSTATUS NtSignalAndWaitForSingleObject(
	IN HANDLE hObjectToSignal,
	IN HANDLE hObjectToWaitOn,
	IN BOOLEAN bAlertable,
	IN PLARGE_INTEGER dwMilliseconds OPTIONAL);

EXTERN_C NTSTATUS NtSinglePhaseReject(
	IN HANDLE EnlistmentHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtStartProfile(
	IN HANDLE ProfileHandle);

EXTERN_C NTSTATUS NtStopProfile(
	IN HANDLE ProfileHandle);

EXTERN_C NTSTATUS NtSubscribeWnfStateChange(
	IN PCWNF_STATE_NAME StateName,
	IN WNF_CHANGE_STAMP ChangeStamp OPTIONAL,
	IN ULONG EventMask,
	OUT PLARGE_INTEGER SubscriptionId OPTIONAL);

EXTERN_C NTSTATUS NtSuspendProcess(
	IN HANDLE ProcessHandle);

EXTERN_C NTSTATUS NtSuspendThread(
	IN HANDLE ThreadHandle,
	OUT PULONG PreviousSuspendCount);

EXTERN_C NTSTATUS NtSystemDebugControl(
	IN DEBUG_CONTROL_CODE Command,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength,
	OUT PULONG ReturnLength OPTIONAL);

EXTERN_C NTSTATUS NtTerminateEnclave(
	IN PVOID BaseAddress,
	IN BOOLEAN WaitForThread);

EXTERN_C NTSTATUS NtTerminateJobObject(
	IN HANDLE JobHandle,
	IN NTSTATUS ExitStatus);

EXTERN_C NTSTATUS NtTestAlert();

EXTERN_C NTSTATUS NtThawRegistry();

EXTERN_C NTSTATUS NtThawTransactions();

EXTERN_C NTSTATUS NtTraceControl(
	IN ULONG FunctionCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength,
	OUT PULONG ReturnLength);

EXTERN_C NTSTATUS NtTranslateFilePath(
	IN PFILE_PATH InputFilePath,
	IN ULONG OutputType,
	OUT PFILE_PATH OutputFilePath OPTIONAL,
	IN OUT PULONG OutputFilePathLength OPTIONAL);

EXTERN_C NTSTATUS NtUmsThreadYield(
	IN PVOID SchedulerParam);

EXTERN_C NTSTATUS NtUnloadDriver(
	IN PUNICODE_STRING DriverServiceName);

EXTERN_C NTSTATUS NtUnloadKey(
	IN POBJECT_ATTRIBUTES DestinationKeyName);

EXTERN_C NTSTATUS NtUnloadKey2(
	IN POBJECT_ATTRIBUTES TargetKey,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtUnloadKeyEx(
	IN POBJECT_ATTRIBUTES TargetKey,
	IN HANDLE Event OPTIONAL);

EXTERN_C NTSTATUS NtUnlockFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PULARGE_INTEGER ByteOffset,
	IN PULARGE_INTEGER Length,
	IN ULONG Key);

EXTERN_C NTSTATUS NtUnlockVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID* BaseAddress,
	IN PSIZE_T NumberOfBytesToUnlock,
	IN ULONG LockType);

EXTERN_C NTSTATUS NtUnmapViewOfSectionEx(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress OPTIONAL,
	IN ULONG Flags);

EXTERN_C NTSTATUS NtUnsubscribeWnfStateChange(
	IN PCWNF_STATE_NAME StateName);

EXTERN_C NTSTATUS NtUpdateWnfStateData(
	IN PCWNF_STATE_NAME StateName,
	IN PVOID Buffer OPTIONAL,
	IN ULONG Length OPTIONAL,
	IN PCWNF_TYPE_ID TypeId OPTIONAL,
	IN PVOID ExplicitScope OPTIONAL,
	IN WNF_CHANGE_STAMP MatchingChangeStamp,
	IN ULONG CheckStamp);

EXTERN_C NTSTATUS NtVdmControl(
	IN VDMSERVICECLASS Service,
	IN OUT PVOID ServiceData);

EXTERN_C NTSTATUS NtWaitForAlertByThreadId(
	IN HANDLE Handle,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtWaitForDebugEvent(
	IN HANDLE DebugObjectHandle,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	OUT PVOID WaitStateChange);

EXTERN_C NTSTATUS NtWaitForKeyedEvent(
	IN HANDLE KeyedEventHandle,
	IN PVOID Key,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL);

EXTERN_C NTSTATUS NtWaitForWorkViaWorkerFactory(
	IN HANDLE WorkerFactoryHandle,
	OUT PVOID MiniPacket);

EXTERN_C NTSTATUS NtWaitHighEventPair(
	IN HANDLE EventHandle);

EXTERN_C NTSTATUS NtWaitLowEventPair(
	IN HANDLE EventHandle);

EXTERN_C NTSTATUS NtAcquireCMFViewOwnership(
	OUT BOOLEAN TimeStamp,
	OUT BOOLEAN TokenTaken,
	IN BOOLEAN ReplaceExisting);

EXTERN_C NTSTATUS NtCancelDeviceWakeupRequest(
	IN HANDLE DeviceHandle);

EXTERN_C NTSTATUS NtClearAllSavepointsTransaction(
	IN HANDLE TransactionHandle);

EXTERN_C NTSTATUS NtClearSavepointTransaction(
	IN HANDLE TransactionHandle,
	IN ULONG SavePointId);

EXTERN_C NTSTATUS NtRollbackSavepointTransaction(
	IN HANDLE TransactionHandle,
	IN ULONG SavePointId);

EXTERN_C NTSTATUS NtSavepointTransaction(
	IN HANDLE TransactionHandle,
	IN BOOLEAN Flag,
	OUT ULONG SavePointId);

EXTERN_C NTSTATUS NtSavepointComplete(
	IN HANDLE TransactionHandle,
	IN PLARGE_INTEGER TmVirtualClock OPTIONAL);

EXTERN_C NTSTATUS NtCreateSectionEx(
	OUT PHANDLE SectionHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN PLARGE_INTEGER MaximumSize OPTIONAL,
	IN ULONG SectionPageProtection,
	IN ULONG AllocationAttributes,
	IN HANDLE FileHandle OPTIONAL,
	IN PMEM_EXTENDED_PARAMETER ExtendedParameters,
	IN ULONG ExtendedParametersCount);

EXTERN_C NTSTATUS NtCreateCrossVmEvent();

EXTERN_C NTSTATUS NtGetPlugPlayEvent(
	IN HANDLE EventHandle,
	IN PVOID Context OPTIONAL,
	OUT PPLUGPLAY_EVENT_BLOCK EventBlock,
	IN ULONG EventBufferSize);

EXTERN_C NTSTATUS NtListTransactions();

EXTERN_C NTSTATUS NtMarshallTransaction();

EXTERN_C NTSTATUS NtPullTransaction();

EXTERN_C NTSTATUS NtReleaseCMFViewOwnership();

EXTERN_C NTSTATUS NtWaitForWnfNotifications();

EXTERN_C NTSTATUS NtStartTm();

EXTERN_C NTSTATUS NtSetInformationProcess(
	IN HANDLE DeviceHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	IN PVOID ProcessInformation,
	IN ULONG Length);

EXTERN_C NTSTATUS NtRequestDeviceWakeup(
	IN HANDLE DeviceHandle);

EXTERN_C NTSTATUS NtRequestWakeupLatency(
	IN ULONG LatencyTime);

EXTERN_C NTSTATUS NtQuerySystemTime(
	OUT PLARGE_INTEGER SystemTime);

EXTERN_C NTSTATUS NtManageHotPatch(
	IN ULONG UnknownParameter1,
	IN ULONG UnknownParameter2,
	IN ULONG UnknownParameter3,
	IN ULONG UnknownParameter4);

EXTERN_C NTSTATUS NtContinueEx(
	IN PCONTEXT ContextRecord,
	IN PKCONTINUE_ARGUMENT ContinueArgument);

#endif
```

`syscall/syscallsstubs.asm`:

```asm
.686 
.XMM 
.MODEL flat, c 
ASSUME fs:_DATA 
.CODE

; x64 for x86

EXTERN SW2_GetSyscallNumber: PROC

EXTERN internal_cleancall_wow64_gate: PROC

NtAccessCheck PROC
	push ebp
	mov ebp, esp
	push 0C45B3507h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheck ENDP

NtWorkerFactoryWorkerReady PROC
	push ebp
	mov ebp, esp
	push 08DAEE74Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWorkerFactoryWorkerReady ENDP

NtAcceptConnectPort PROC
	push ebp
	mov ebp, esp
	push 018AF0340h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAcceptConnectPort ENDP

NtMapUserPhysicalPagesScatter PROC
	push ebp
	mov ebp, esp
	push 0A36D8931h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMapUserPhysicalPagesScatter ENDP

NtWaitForSingleObject PROC
	push ebp
	mov ebp, esp
	push 064DED283h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForSingleObject ENDP

NtCallbackReturn PROC
	push ebp
	mov ebp, esp
	push 0FA60878Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCallbackReturn ENDP

NtReadFile PROC
	push ebp
	mov ebp, esp
	push 0B5139A5Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReadFile ENDP

NtDeviceIoControlFile PROC
	push ebp
	mov ebp, esp
	push 0D876A360h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeviceIoControlFile ENDP

NtWriteFile PROC
	push ebp
	mov ebp, esp
	push 002981C2Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWriteFile ENDP

NtRemoveIoCompletion PROC
	push ebp
	mov ebp, esp
	push 0930C939Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRemoveIoCompletion ENDP

NtReleaseSemaphore PROC
	push ebp
	mov ebp, esp
	push 018084D38h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReleaseSemaphore ENDP

NtReplyWaitReceivePort PROC
	push ebp
	mov ebp, esp
	push 062F27B76h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReplyWaitReceivePort ENDP

NtReplyPort PROC
	push ebp
	mov ebp, esp
	push 01AB11324h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReplyPort ENDP

NtSetInformationThread PROC
	push ebp
	mov ebp, esp
	push 0554A61D5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationThread ENDP

NtSetEvent PROC
	push ebp
	mov ebp, esp
	push 0298B301Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetEvent ENDP

NtClose PROC
	push ebp
	mov ebp, esp
	push 0049F2513h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtClose ENDP

NtQueryObject PROC
	push ebp
	mov ebp, esp
	push 0F8C80384h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryObject ENDP

NtQueryInformationFile PROC
	push ebp
	mov ebp, esp
	push 078DC7476h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationFile ENDP

NtOpenKey PROC
	push ebp
	mov ebp, esp
	push 064D19FB2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenKey ENDP

NtEnumerateValueKey PROC
	push ebp
	mov ebp, esp
	push 0964FE5B4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnumerateValueKey ENDP

NtFindAtom PROC
	push ebp
	mov ebp, esp
	push 0DB5FEA9Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFindAtom ENDP

NtQueryDefaultLocale PROC
	push ebp
	mov ebp, esp
	push 0663754A3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDefaultLocale ENDP

NtQueryKey PROC
	push ebp
	mov ebp, esp
	push 003C6EE5Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryKey ENDP

NtQueryValueKey PROC
	push ebp
	mov ebp, esp
	push 02EFF5D05h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryValueKey ENDP

NtAllocateVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 00D9F1913h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAllocateVirtualMemory ENDP

NtQueryInformationProcess PROC
	push ebp
	mov ebp, esp
	push 0822EA9B3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationProcess ENDP

NtWaitForMultipleObjects32 PROC
	push ebp
	mov ebp, esp
	push 08F42C8D7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForMultipleObjects32 ENDP

NtWriteFileGather PROC
	push ebp
	mov ebp, esp
	push 0DBC4349Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWriteFileGather ENDP

NtCreateKey PROC
	push ebp
	mov ebp, esp
	push 0099D4C4Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateKey ENDP

NtFreeVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 0039E1B01h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFreeVirtualMemory ENDP

NtImpersonateClientOfPort PROC
	push ebp
	mov ebp, esp
	push 010B2392Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtImpersonateClientOfPort ENDP

NtReleaseMutant PROC
	push ebp
	mov ebp, esp
	push 080BED298h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReleaseMutant ENDP

NtQueryInformationToken PROC
	push ebp
	mov ebp, esp
	push 00B990506h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationToken ENDP

NtRequestWaitReplyPort PROC
	push ebp
	mov ebp, esp
	push 0A0F166BBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRequestWaitReplyPort ENDP

NtQueryVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 0C985E520h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryVirtualMemory ENDP

NtOpenThreadToken PROC
	push ebp
	mov ebp, esp
	push 02B9F1114h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenThreadToken ENDP

NtQueryInformationThread PROC
	push ebp
	mov ebp, esp
	push 08EA243F4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationThread ENDP

NtOpenProcess PROC
	push ebp
	mov ebp, esp
	push 04DD34C5Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenProcess ENDP

NtSetInformationFile PROC
	push ebp
	mov ebp, esp
	push 0E5B6CB63h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationFile ENDP

NtMapViewOfSection PROC
	push ebp
	mov ebp, esp
	push 0C348C3DAh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMapViewOfSection ENDP

NtAccessCheckAndAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 0A8A8A93Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheckAndAuditAlarm ENDP

NtUnmapViewOfSection PROC
	push ebp
	mov ebp, esp
	push 008C02E49h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnmapViewOfSection ENDP

NtReplyWaitReceivePortEx PROC
	push ebp
	mov ebp, esp
	push 00785DBD1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReplyWaitReceivePortEx ENDP

NtTerminateProcess PROC
	push ebp
	mov ebp, esp
	push 043DF545Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTerminateProcess ENDP

NtSetEventBoostPriority PROC
	push ebp
	mov ebp, esp
	push 02E8C321Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetEventBoostPriority ENDP

NtReadFileScatter PROC
	push ebp
	mov ebp, esp
	push 003A00D3Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReadFileScatter ENDP

NtOpenThreadTokenEx PROC
	push ebp
	mov ebp, esp
	push 00A8D7876h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenThreadTokenEx ENDP

NtOpenProcessTokenEx PROC
	push ebp
	mov ebp, esp
	push 0900392B8h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenProcessTokenEx ENDP

NtQueryPerformanceCounter PROC
	push ebp
	mov ebp, esp
	push 071DA5F7Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryPerformanceCounter ENDP

NtEnumerateKey PROC
	push ebp
	mov ebp, esp
	push 0AEBEBF24h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnumerateKey ENDP

NtOpenFile PROC
	push ebp
	mov ebp, esp
	push 0DD7AFB39h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenFile ENDP

NtDelayExecution PROC
	push ebp
	mov ebp, esp
	push 0D7B017C2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDelayExecution ENDP

NtQueryDirectoryFile PROC
	push ebp
	mov ebp, esp
	push 032B8BA9Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDirectoryFile ENDP

NtQuerySystemInformation PROC
	push ebp
	mov ebp, esp
	push 04E9E684Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySystemInformation ENDP

NtOpenSection PROC
	push ebp
	mov ebp, esp
	push 056105A8Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenSection ENDP

NtQueryTimer PROC
	push ebp
	mov ebp, esp
	push 0EBA776ABh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryTimer ENDP

NtFsControlFile PROC
	push ebp
	mov ebp, esp
	push 01CBA4F8Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFsControlFile ENDP

NtWriteVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 0B018A6B4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWriteVirtualMemory ENDP

NtCloseObjectAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 00A942A42h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCloseObjectAuditAlarm ENDP

NtDuplicateObject PROC
	push ebp
	mov ebp, esp
	push 00A379A1Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDuplicateObject ENDP

NtQueryAttributesFile PROC
	push ebp
	mov ebp, esp
	push 02BB9C0ECh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryAttributesFile ENDP

NtClearEvent PROC
	push ebp
	mov ebp, esp
	push 0D289D502h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtClearEvent ENDP

NtReadVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 047D37B57h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReadVirtualMemory ENDP

NtOpenEvent PROC
	push ebp
	mov ebp, esp
	push 0014B06C0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenEvent ENDP

NtAdjustPrivilegesToken PROC
	push ebp
	mov ebp, esp
	push 0059B7696h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAdjustPrivilegesToken ENDP

NtDuplicateToken PROC
	push ebp
	mov ebp, esp
	push 0A580F3A4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDuplicateToken ENDP

NtContinue PROC
	push ebp
	mov ebp, esp
	push 042C6816Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtContinue ENDP

NtQueryDefaultUILanguage PROC
	push ebp
	mov ebp, esp
	push 03B9C0A06h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDefaultUILanguage ENDP

NtQueueApcThread PROC
	push ebp
	mov ebp, esp
	push 0389B76B1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueueApcThread ENDP

NtYieldExecution PROC
	push ebp
	mov ebp, esp
	push 0CB1FE84Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtYieldExecution ENDP

NtAddAtom PROC
	push ebp
	mov ebp, esp
	push 094C1936Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAddAtom ENDP

NtCreateEvent PROC
	push ebp
	mov ebp, esp
	push 076A44700h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateEvent ENDP

NtQueryVolumeInformationFile PROC
	push ebp
	mov ebp, esp
	push 06C3CBC8Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryVolumeInformationFile ENDP

NtCreateSection PROC
	push ebp
	mov ebp, esp
	push 00EAC1001h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateSection ENDP

NtFlushBuffersFile PROC
	push ebp
	mov ebp, esp
	push 0BF772D41h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushBuffersFile ENDP

NtApphelpCacheControl PROC
	push ebp
	mov ebp, esp
	push 04F9965DFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtApphelpCacheControl ENDP

NtCreateProcessEx PROC
	push ebp
	mov ebp, esp
	push 0838DD751h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateProcessEx ENDP

NtCreateThread PROC
	push ebp
	mov ebp, esp
	push 07D25AD99h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateThread ENDP

NtIsProcessInJob PROC
	push ebp
	mov ebp, esp
	push 0652EB71Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtIsProcessInJob ENDP

NtProtectVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 001911B13h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtProtectVirtualMemory ENDP

NtQuerySection PROC
	push ebp
	mov ebp, esp
	push 006DC0841h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySection ENDP

NtResumeThread PROC
	push ebp
	mov ebp, esp
	push 00D2D038Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtResumeThread ENDP

NtTerminateThread PROC
	push ebp
	mov ebp, esp
	push 04EEE5467h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTerminateThread ENDP

NtReadRequestData PROC
	push ebp
	mov ebp, esp
	push 062FC724Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReadRequestData ENDP

NtCreateFile PROC
	push ebp
	mov ebp, esp
	push 0AA9825B3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateFile ENDP

NtQueryEvent PROC
	push ebp
	mov ebp, esp
	push 0C88E448Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryEvent ENDP

NtWriteRequestData PROC
	push ebp
	mov ebp, esp
	push 02084CC8Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWriteRequestData ENDP

NtOpenDirectoryObject PROC
	push ebp
	mov ebp, esp
	push 0829C9002h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenDirectoryObject ENDP

NtAccessCheckByTypeAndAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 034AB2E06h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 16h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheckByTypeAndAuditAlarm ENDP

NtWaitForMultipleObjects PROC
	push ebp
	mov ebp, esp
	push 031A1FEE3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForMultipleObjects ENDP

NtSetInformationObject PROC
	push ebp
	mov ebp, esp
	push 067584C07h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationObject ENDP

NtCancelIoFile PROC
	push ebp
	mov ebp, esp
	push 0349DC0D6h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelIoFile ENDP

NtTraceEvent PROC
	push ebp
	mov ebp, esp
	push 038BF1F2Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTraceEvent ENDP

NtPowerInformation PROC
	push ebp
	mov ebp, esp
	push 082099CB9h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPowerInformation ENDP

NtSetValueKey PROC
	push ebp
	mov ebp, esp
	push 039E4DC86h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetValueKey ENDP

NtCancelTimer PROC
	push ebp
	mov ebp, esp
	push 005BA93BEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelTimer ENDP

NtSetTimer PROC
	push ebp
	mov ebp, esp
	push 02096B195h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetTimer ENDP

NtAccessCheckByType PROC
	push ebp
	mov ebp, esp
	push 05EF96A36h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheckByType ENDP

NtAccessCheckByTypeResultList PROC
	push ebp
	mov ebp, esp
	push 025B92B23h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheckByTypeResultList ENDP

NtAccessCheckByTypeResultListAndAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 0165116CEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 16h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheckByTypeResultListAndAuditAlarm ENDP

NtAccessCheckByTypeResultListAndAuditAlarmByHandle PROC
	push ebp
	mov ebp, esp
	push 03B942F24h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 17h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAccessCheckByTypeResultListAndAuditAlarmByHandle ENDP

NtAcquireProcessActivityReference PROC
	push ebp
	mov ebp, esp
	push 0D89B3687h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAcquireProcessActivityReference ENDP

NtAddAtomEx PROC
	push ebp
	mov ebp, esp
	push 089ABB72Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAddAtomEx ENDP

NtAddBootEntry PROC
	push ebp
	mov ebp, esp
	push 0099CE2FEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAddBootEntry ENDP

NtAddDriverEntry PROC
	push ebp
	mov ebp, esp
	push 00995190Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAddDriverEntry ENDP

NtAdjustGroupsToken PROC
	push ebp
	mov ebp, esp
	push 01CA80A21h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAdjustGroupsToken ENDP

NtAdjustTokenClaimsAndDeviceGroups PROC
	push ebp
	mov ebp, esp
	push 009910D07h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 16h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAdjustTokenClaimsAndDeviceGroups ENDP

NtAlertResumeThread PROC
	push ebp
	mov ebp, esp
	push 07ADA206Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlertResumeThread ENDP

NtAlertThread PROC
	push ebp
	mov ebp, esp
	push 03C073691h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlertThread ENDP

NtAlertThreadByThreadId PROC
	push ebp
	mov ebp, esp
	push 06FB00378h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlertThreadByThreadId ENDP

NtAllocateLocallyUniqueId PROC
	push ebp
	mov ebp, esp
	push 045B13D2Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAllocateLocallyUniqueId ENDP

NtAllocateReserveObject PROC
	push ebp
	mov ebp, esp
	push 0249E0DC3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAllocateReserveObject ENDP

NtAllocateUserPhysicalPages PROC
	push ebp
	mov ebp, esp
	push 0059C0400h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAllocateUserPhysicalPages ENDP

NtAllocateUuids PROC
	push ebp
	mov ebp, esp
	push 02A91E2CEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAllocateUuids ENDP

NtAllocateVirtualMemoryEx PROC
	push ebp
	mov ebp, esp
	push 0868FC051h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAllocateVirtualMemoryEx ENDP

NtAlpcAcceptConnectPort PROC
	push ebp
	mov ebp, esp
	push 065B71C39h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcAcceptConnectPort ENDP

NtAlpcCancelMessage PROC
	push ebp
	mov ebp, esp
	push 0A396860Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcCancelMessage ENDP

NtAlpcConnectPort PROC
	push ebp
	mov ebp, esp
	push 05E80BFDEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcConnectPort ENDP

NtAlpcConnectPortEx PROC
	push ebp
	mov ebp, esp
	push 0615EDD9Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcConnectPortEx ENDP

NtAlpcCreatePort PROC
	push ebp
	mov ebp, esp
	push 0198C3EDFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcCreatePort ENDP

NtAlpcCreatePortSection PROC
	push ebp
	mov ebp, esp
	push 010CB361Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcCreatePortSection ENDP

NtAlpcCreateResourceReserve PROC
	push ebp
	mov ebp, esp
	push 0DD58DDF4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcCreateResourceReserve ENDP

NtAlpcCreateSectionView PROC
	push ebp
	mov ebp, esp
	push 00D28F143h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcCreateSectionView ENDP

NtAlpcCreateSecurityContext PROC
	push ebp
	mov ebp, esp
	push 036AA2922h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcCreateSecurityContext ENDP

NtAlpcDeletePortSection PROC
	push ebp
	mov ebp, esp
	push 03AA910F1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcDeletePortSection ENDP

NtAlpcDeleteResourceReserve PROC
	push ebp
	mov ebp, esp
	push 0448F2A4Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcDeleteResourceReserve ENDP

NtAlpcDeleteSectionView PROC
	push ebp
	mov ebp, esp
	push 004D07937h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcDeleteSectionView ENDP

NtAlpcDeleteSecurityContext PROC
	push ebp
	mov ebp, esp
	push 07EE2796Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcDeleteSecurityContext ENDP

NtAlpcDisconnectPort PROC
	push ebp
	mov ebp, esp
	push 065307C9Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcDisconnectPort ENDP

NtAlpcImpersonateClientContainerOfPort PROC
	push ebp
	mov ebp, esp
	push 0D172F2DDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcImpersonateClientContainerOfPort ENDP

NtAlpcImpersonateClientOfPort PROC
	push ebp
	mov ebp, esp
	push 024752FEBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcImpersonateClientOfPort ENDP

NtAlpcOpenSenderProcess PROC
	push ebp
	mov ebp, esp
	push 07DA3440Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcOpenSenderProcess ENDP

NtAlpcOpenSenderThread PROC
	push ebp
	mov ebp, esp
	push 069496FEBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcOpenSenderThread ENDP

NtAlpcQueryInformation PROC
	push ebp
	mov ebp, esp
	push 0D54CD5DEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcQueryInformation ENDP

NtAlpcQueryInformationMessage PROC
	push ebp
	mov ebp, esp
	push 03D1E2E8Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcQueryInformationMessage ENDP

NtAlpcRevokeSecurityContext PROC
	push ebp
	mov ebp, esp
	push 0922C6144h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcRevokeSecurityContext ENDP

NtAlpcSendWaitReceivePort PROC
	push ebp
	mov ebp, esp
	push 0FD76E6F9h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcSendWaitReceivePort ENDP

NtAlpcSetInformation PROC
	push ebp
	mov ebp, esp
	push 0E076E2DBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAlpcSetInformation ENDP

NtAreMappedFilesTheSame PROC
	push ebp
	mov ebp, esp
	push 0F2340C6Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAreMappedFilesTheSame ENDP

NtAssignProcessToJobObject PROC
	push ebp
	mov ebp, esp
	push 0755F4DF3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAssignProcessToJobObject ENDP

NtAssociateWaitCompletionPacket PROC
	push ebp
	mov ebp, esp
	push 00FA93506h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAssociateWaitCompletionPacket ENDP

NtCallEnclave PROC
	push ebp
	mov ebp, esp
	push 09B3FF9B5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCallEnclave ENDP

NtCancelIoFileEx PROC
	push ebp
	mov ebp, esp
	push 0504BA231h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelIoFileEx ENDP

NtCancelSynchronousIoFile PROC
	push ebp
	mov ebp, esp
	push 002BB8AACh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelSynchronousIoFile ENDP

NtCancelTimer2 PROC
	push ebp
	mov ebp, esp
	push 0BBBF56A1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelTimer2 ENDP

NtCancelWaitCompletionPacket PROC
	push ebp
	mov ebp, esp
	push 099BCBB22h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelWaitCompletionPacket ENDP

NtCommitComplete PROC
	push ebp
	mov ebp, esp
	push 006A3000Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCommitComplete ENDP

NtCommitEnlistment PROC
	push ebp
	mov ebp, esp
	push 05FC97E7Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCommitEnlistment ENDP

NtCommitRegistryTransaction PROC
	push ebp
	mov ebp, esp
	push 0144FF61Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCommitRegistryTransaction ENDP

NtCommitTransaction PROC
	push ebp
	mov ebp, esp
	push 0408A4217h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCommitTransaction ENDP

NtCompactKeys PROC
	push ebp
	mov ebp, esp
	push 0B315A882h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCompactKeys ENDP

NtCompareObjects PROC
	push ebp
	mov ebp, esp
	push 0041B70C3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCompareObjects ENDP

NtCompareSigningLevels PROC
	push ebp
	mov ebp, esp
	push 0248A241Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCompareSigningLevels ENDP

NtCompareTokens PROC
	push ebp
	mov ebp, esp
	push 017BB0CD3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCompareTokens ENDP

NtCompleteConnectPort PROC
	push ebp
	mov ebp, esp
	push 02E71DDFEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCompleteConnectPort ENDP

NtCompressKey PROC
	push ebp
	mov ebp, esp
	push 09700ACBCh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCompressKey ENDP

NtConnectPort PROC
	push ebp
	mov ebp, esp
	push 0EA8DC112h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtConnectPort ENDP

NtConvertBetweenAuxiliaryCounterAndPerformanceCounter PROC
	push ebp
	mov ebp, esp
	push 07FF6091Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtConvertBetweenAuxiliaryCounterAndPerformanceCounter ENDP

NtCreateDebugObject PROC
	push ebp
	mov ebp, esp
	push 0BCB7DC63h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateDebugObject ENDP

NtCreateDirectoryObject PROC
	push ebp
	mov ebp, esp
	push 0EC58C48Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateDirectoryObject ENDP

NtCreateDirectoryObjectEx PROC
	push ebp
	mov ebp, esp
	push 024D4E78Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateDirectoryObjectEx ENDP

NtCreateEnclave PROC
	push ebp
	mov ebp, esp
	push 0CE2EA924h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateEnclave ENDP

NtCreateEnlistment PROC
	push ebp
	mov ebp, esp
	push 00A410BD7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateEnlistment ENDP

NtCreateEventPair PROC
	push ebp
	mov ebp, esp
	push 004B04C65h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateEventPair ENDP

NtCreateIRTimer PROC
	push ebp
	mov ebp, esp
	push 033A00518h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateIRTimer ENDP

NtCreateIoCompletion PROC
	push ebp
	mov ebp, esp
	push 03AA41A2Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateIoCompletion ENDP

NtCreateJobObject PROC
	push ebp
	mov ebp, esp
	push 008A7183Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateJobObject ENDP

NtCreateJobSet PROC
	push ebp
	mov ebp, esp
	push 0BD398F86h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateJobSet ENDP

NtCreateKeyTransacted PROC
	push ebp
	mov ebp, esp
	push 07CDFA562h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateKeyTransacted ENDP

NtCreateKeyedEvent PROC
	push ebp
	mov ebp, esp
	push 09E045956h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateKeyedEvent ENDP

NtCreateLowBoxToken PROC
	push ebp
	mov ebp, esp
	push 09E54025Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateLowBoxToken ENDP

NtCreateMailslotFile PROC
	push ebp
	mov ebp, esp
	push 07FC4B571h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateMailslotFile ENDP

NtCreateMutant PROC
	push ebp
	mov ebp, esp
	push 0872186B5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateMutant ENDP

NtCreateNamedPipeFile PROC
	push ebp
	mov ebp, esp
	push 0E8482C12h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 14h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateNamedPipeFile ENDP

NtCreatePagingFile PROC
	push ebp
	mov ebp, esp
	push 016B9C982h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreatePagingFile ENDP

NtCreatePartition PROC
	push ebp
	mov ebp, esp
	push 08AD38843h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreatePartition ENDP

NtCreatePort PROC
	push ebp
	mov ebp, esp
	push 0A6F258F1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreatePort ENDP

NtCreatePrivateNamespace PROC
	push ebp
	mov ebp, esp
	push 019B5D21Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreatePrivateNamespace ENDP

NtCreateProcess PROC
	push ebp
	mov ebp, esp
	push 0319E3010h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateProcess ENDP

NtCreateProfile PROC
	push ebp
	mov ebp, esp
	push 036A14072h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateProfile ENDP

NtCreateProfileEx PROC
	push ebp
	mov ebp, esp
	push 07CD28AACh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateProfileEx ENDP

NtCreateRegistryTransaction PROC
	push ebp
	mov ebp, esp
	push 0991EC1D0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateRegistryTransaction ENDP

NtCreateResourceManager PROC
	push ebp
	mov ebp, esp
	push 0029EC5D4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateResourceManager ENDP

NtCreateSemaphore PROC
	push ebp
	mov ebp, esp
	push 0CB4BF5C5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateSemaphore ENDP

NtCreateSymbolicLinkObject PROC
	push ebp
	mov ebp, esp
	push 0163860C5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateSymbolicLinkObject ENDP

NtCreateThreadEx PROC
	push ebp
	mov ebp, esp
	push 046BC3042h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateThreadEx ENDP

NtCreateTimer PROC
	push ebp
	mov ebp, esp
	push 074575104h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateTimer ENDP

NtCreateTimer2 PROC
	push ebp
	mov ebp, esp
	push 07022D1BDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateTimer2 ENDP

NtCreateToken PROC
	push ebp
	mov ebp, esp
	push 00C312A9Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 13h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateToken ENDP

NtCreateTokenEx PROC
	push ebp
	mov ebp, esp
	push 0B8ABF810h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 17h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateTokenEx ENDP

NtCreateTransaction PROC
	push ebp
	mov ebp, esp
	push 05CC5725Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateTransaction ENDP

NtCreateTransactionManager PROC
	push ebp
	mov ebp, esp
	push 00E2E72C4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateTransactionManager ENDP

NtCreateUserProcess PROC
	push ebp
	mov ebp, esp
	push 00BA7063Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 11h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateUserProcess ENDP

NtCreateWaitCompletionPacket PROC
	push ebp
	mov ebp, esp
	push 0079A21C0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateWaitCompletionPacket ENDP

NtCreateWaitablePort PROC
	push ebp
	mov ebp, esp
	push 025403CC4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateWaitablePort ENDP

NtCreateWnfStateName PROC
	push ebp
	mov ebp, esp
	push 0853A597Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateWnfStateName ENDP

NtCreateWorkerFactory PROC
	push ebp
	mov ebp, esp
	push 0088C7A74h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateWorkerFactory ENDP

NtDebugActiveProcess PROC
	push ebp
	mov ebp, esp
	push 0B0335121h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDebugActiveProcess ENDP

NtDebugContinue PROC
	push ebp
	mov ebp, esp
	push 01E94F9D8h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDebugContinue ENDP

NtDeleteAtom PROC
	push ebp
	mov ebp, esp
	push 036A3AB92h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteAtom ENDP

NtDeleteBootEntry PROC
	push ebp
	mov ebp, esp
	push 0099D0111h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteBootEntry ENDP

NtDeleteDriverEntry PROC
	push ebp
	mov ebp, esp
	push 00B960104h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteDriverEntry ENDP

NtDeleteFile PROC
	push ebp
	mov ebp, esp
	push 047C55079h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteFile ENDP

NtDeleteKey PROC
	push ebp
	mov ebp, esp
	push 0E723055Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteKey ENDP

NtDeleteObjectAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 0C12F3BB9h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteObjectAuditAlarm ENDP

NtDeletePrivateNamespace PROC
	push ebp
	mov ebp, esp
	push 096B95390h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeletePrivateNamespace ENDP

NtDeleteValueKey PROC
	push ebp
	mov ebp, esp
	push 07DE46C7Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteValueKey ENDP

NtDeleteWnfStateData PROC
	push ebp
	mov ebp, esp
	push 0840E96BEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteWnfStateData ENDP

NtDeleteWnfStateName PROC
	push ebp
	mov ebp, esp
	push 0921C9FBDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDeleteWnfStateName ENDP

NtDisableLastKnownGood PROC
	push ebp
	mov ebp, esp
	push 0F86AEEDBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDisableLastKnownGood ENDP

NtDisplayString PROC
	push ebp
	mov ebp, esp
	push 00EA14480h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDisplayString ENDP

NtDrawText PROC
	push ebp
	mov ebp, esp
	push 0F94CECCDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtDrawText ENDP

NtEnableLastKnownGood PROC
	push ebp
	mov ebp, esp
	push 0A4325A23h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnableLastKnownGood ENDP

NtEnumerateBootEntries PROC
	push ebp
	mov ebp, esp
	push 02490514Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnumerateBootEntries ENDP

NtEnumerateDriverEntries PROC
	push ebp
	mov ebp, esp
	push 060C4FAEBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnumerateDriverEntries ENDP

NtEnumerateSystemEnvironmentValuesEx PROC
	push ebp
	mov ebp, esp
	push 07E5F08A1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnumerateSystemEnvironmentValuesEx ENDP

NtEnumerateTransactionObject PROC
	push ebp
	mov ebp, esp
	push 0E4B8EC24h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtEnumerateTransactionObject ENDP

NtExtendSection PROC
	push ebp
	mov ebp, esp
	push 034AD1679h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtExtendSection ENDP

NtFilterBootOption PROC
	push ebp
	mov ebp, esp
	push 01A347CE4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFilterBootOption ENDP

NtFilterToken PROC
	push ebp
	mov ebp, esp
	push 0C759CDC2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFilterToken ENDP

NtFilterTokenEx PROC
	push ebp
	mov ebp, esp
	push 08A9B46DEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 14h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFilterTokenEx ENDP

NtFlushBuffersFileEx PROC
	push ebp
	mov ebp, esp
	push 0043650EBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushBuffersFileEx ENDP

NtFlushInstallUILanguage PROC
	push ebp
	mov ebp, esp
	push 083D47089h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushInstallUILanguage ENDP

NtFlushInstructionCache PROC
	push ebp
	mov ebp, esp
	push 01FA1491Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushInstructionCache ENDP

NtFlushKey PROC
	push ebp
	mov ebp, esp
	push 040E45579h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushKey ENDP

NtFlushProcessWriteBuffers PROC
	push ebp
	mov ebp, esp
	push 00929CD7Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushProcessWriteBuffers ENDP

NtFlushVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 0831C899Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushVirtualMemory ENDP

NtFlushWriteBuffer PROC
	push ebp
	mov ebp, esp
	push 097A4B5F4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFlushWriteBuffer ENDP

NtFreeUserPhysicalPages PROC
	push ebp
	mov ebp, esp
	push 095CFA867h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFreeUserPhysicalPages ENDP

NtFreezeRegistry PROC
	push ebp
	mov ebp, esp
	push 0CC90FC2Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFreezeRegistry ENDP

NtFreezeTransactions PROC
	push ebp
	mov ebp, esp
	push 05DC95543h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtFreezeTransactions ENDP

NtGetCachedSigningLevel PROC
	push ebp
	mov ebp, esp
	push 0A0AAC638h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetCachedSigningLevel ENDP

NtGetCompleteWnfStateSubscription PROC
	push ebp
	mov ebp, esp
	push 0FFB4FD27h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetCompleteWnfStateSubscription ENDP

NtGetContextThread PROC
	push ebp
	mov ebp, esp
	push 00228450Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetContextThread ENDP

NtGetCurrentProcessorNumber PROC
	push ebp
	mov ebp, esp
	push 082A56FFFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetCurrentProcessorNumber ENDP

NtGetCurrentProcessorNumberEx PROC
	push ebp
	mov ebp, esp
	push 0F75B0B2Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetCurrentProcessorNumberEx ENDP

NtGetDevicePowerState PROC
	push ebp
	mov ebp, esp
	push 0CE55AEDEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetDevicePowerState ENDP

NtGetMUIRegistryInfo PROC
	push ebp
	mov ebp, esp
	push 01EBC5467h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetMUIRegistryInfo ENDP

NtGetNextProcess PROC
	push ebp
	mov ebp, esp
	push 07DA81C3Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetNextProcess ENDP

NtGetNextThread PROC
	push ebp
	mov ebp, esp
	push 0F45039F1h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetNextThread ENDP

NtGetNlsSectionPtr PROC
	push ebp
	mov ebp, esp
	push 039EC2066h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetNlsSectionPtr ENDP

NtGetNotificationResourceManager PROC
	push ebp
	mov ebp, esp
	push 0BA67C8ABh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetNotificationResourceManager ENDP

NtGetWriteWatch PROC
	push ebp
	mov ebp, esp
	push 01CC6286Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetWriteWatch ENDP

NtImpersonateAnonymousToken PROC
	push ebp
	mov ebp, esp
	push 0F15024EBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtImpersonateAnonymousToken ENDP

NtImpersonateThread PROC
	push ebp
	mov ebp, esp
	push 01EAA5B8Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtImpersonateThread ENDP

NtInitializeEnclave PROC
	push ebp
	mov ebp, esp
	push 0A6BE8E3Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtInitializeEnclave ENDP

NtInitializeNlsFiles PROC
	push ebp
	mov ebp, esp
	push 00D47DB04h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtInitializeNlsFiles ENDP

NtInitializeRegistry PROC
	push ebp
	mov ebp, esp
	push 040DD7651h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtInitializeRegistry ENDP

NtInitiatePowerAction PROC
	push ebp
	mov ebp, esp
	push 09C8AF25Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtInitiatePowerAction ENDP

NtIsSystemResumeAutomatic PROC
	push ebp
	mov ebp, esp
	push 0FCFEE649h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtIsSystemResumeAutomatic ENDP

NtIsUILanguageComitted PROC
	push ebp
	mov ebp, esp
	push 09BA3D91Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtIsUILanguageComitted ENDP

NtListenPort PROC
	push ebp
	mov ebp, esp
	push 0523E57ACh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtListenPort ENDP

NtLoadDriver PROC
	push ebp
	mov ebp, esp
	push 0917ECA53h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLoadDriver ENDP

NtLoadEnclaveData PROC
	push ebp
	mov ebp, esp
	push 0B6CF43A2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLoadEnclaveData ENDP

NtLoadHotPatch PROC
	push ebp
	mov ebp, esp
	push 03EE52A56h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLoadHotPatch ENDP

NtLoadKey PROC
	push ebp
	mov ebp, esp
	push 0069BF5E0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLoadKey ENDP

NtLoadKey2 PROC
	push ebp
	mov ebp, esp
	push 0E69DA08Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLoadKey2 ENDP

NtLoadKeyEx PROC
	push ebp
	mov ebp, esp
	push 0557A8126h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLoadKeyEx ENDP

NtLockFile PROC
	push ebp
	mov ebp, esp
	push 02F78CE3Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLockFile ENDP

NtLockProductActivationKeys PROC
	push ebp
	mov ebp, esp
	push 02DB72826h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLockProductActivationKeys ENDP

NtLockRegistryKey PROC
	push ebp
	mov ebp, esp
	push 04A6F358Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLockRegistryKey ENDP

NtLockVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 01D952B1Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtLockVirtualMemory ENDP

NtMakePermanentObject PROC
	push ebp
	mov ebp, esp
	push 0BE925D8Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMakePermanentObject ENDP

NtMakeTemporaryObject PROC
	push ebp
	mov ebp, esp
	push 01ABA220Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMakeTemporaryObject ENDP

NtManagePartition PROC
	push ebp
	mov ebp, esp
	push 04C98084Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtManagePartition ENDP

NtMapCMFModule PROC
	push ebp
	mov ebp, esp
	push 036BC2C38h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMapCMFModule ENDP

NtMapUserPhysicalPages PROC
	push ebp
	mov ebp, esp
	push 085BC602Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMapUserPhysicalPages ENDP

NtMapViewOfSectionEx PROC
	push ebp
	mov ebp, esp
	push 04093742Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMapViewOfSectionEx ENDP

NtModifyBootEntry PROC
	push ebp
	mov ebp, esp
	push 005AB0B3Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtModifyBootEntry ENDP

NtModifyDriverEntry PROC
	push ebp
	mov ebp, esp
	push 00F872514h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtModifyDriverEntry ENDP

NtNotifyChangeDirectoryFile PROC
	push ebp
	mov ebp, esp
	push 048EA5A42h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtNotifyChangeDirectoryFile ENDP

NtNotifyChangeDirectoryFileEx PROC
	push ebp
	mov ebp, esp
	push 02AA9DCD7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtNotifyChangeDirectoryFileEx ENDP

NtNotifyChangeKey PROC
	push ebp
	mov ebp, esp
	push 09A8EB9D4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtNotifyChangeKey ENDP

NtNotifyChangeMultipleKeys PROC
	push ebp
	mov ebp, esp
	push 00F553C92h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 12h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtNotifyChangeMultipleKeys ENDP

NtNotifyChangeSession PROC
	push ebp
	mov ebp, esp
	push 0278C7940h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 8h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtNotifyChangeSession ENDP

NtOpenEnlistment PROC
	push ebp
	mov ebp, esp
	push 079E51BF3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenEnlistment ENDP

NtOpenEventPair PROC
	push ebp
	mov ebp, esp
	push 01631DA63h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenEventPair ENDP

NtOpenIoCompletion PROC
	push ebp
	mov ebp, esp
	push 0C88E885Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenIoCompletion ENDP

NtOpenJobObject PROC
	push ebp
	mov ebp, esp
	push 00A26F94Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenJobObject ENDP

NtOpenKeyEx PROC
	push ebp
	mov ebp, esp
	push 06D623BBDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenKeyEx ENDP

NtOpenKeyTransacted PROC
	push ebp
	mov ebp, esp
	push 056DF5460h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenKeyTransacted ENDP

NtOpenKeyTransactedEx PROC
	push ebp
	mov ebp, esp
	push 062BD3666h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenKeyTransactedEx ENDP

NtOpenKeyedEvent PROC
	push ebp
	mov ebp, esp
	push 0C803D790h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenKeyedEvent ENDP

NtOpenMutant PROC
	push ebp
	mov ebp, esp
	push 05688591Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenMutant ENDP

NtOpenObjectAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 016898EA6h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 12h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenObjectAuditAlarm ENDP

NtOpenPartition PROC
	push ebp
	mov ebp, esp
	push 036A01633h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenPartition ENDP

NtOpenPrivateNamespace PROC
	push ebp
	mov ebp, esp
	push 0173FD413h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenPrivateNamespace ENDP

NtOpenProcessToken PROC
	push ebp
	mov ebp, esp
	push 093A37BA6h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenProcessToken ENDP

NtOpenRegistryTransaction PROC
	push ebp
	mov ebp, esp
	push 0FE57FEC5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenRegistryTransaction ENDP

NtOpenResourceManager PROC
	push ebp
	mov ebp, esp
	push 00AB2DE90h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenResourceManager ENDP

NtOpenSemaphore PROC
	push ebp
	mov ebp, esp
	push 040AFA42Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenSemaphore ENDP

NtOpenSession PROC
	push ebp
	mov ebp, esp
	push 09F317D64h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenSession ENDP

NtOpenSymbolicLinkObject PROC
	push ebp
	mov ebp, esp
	push 0BC26445Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenSymbolicLinkObject ENDP

NtOpenThread PROC
	push ebp
	mov ebp, esp
	push 0A4783057h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenThread ENDP

NtOpenTimer PROC
	push ebp
	mov ebp, esp
	push 0DDB02BD4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenTimer ENDP

NtOpenTransaction PROC
	push ebp
	mov ebp, esp
	push 00CA22233h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenTransaction ENDP

NtOpenTransactionManager PROC
	push ebp
	mov ebp, esp
	push 035A70126h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtOpenTransactionManager ENDP

NtPlugPlayControl PROC
	push ebp
	mov ebp, esp
	push 0041AE08Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPlugPlayControl ENDP

NtPrePrepareComplete PROC
	push ebp
	mov ebp, esp
	push 00890003Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrePrepareComplete ENDP

NtPrePrepareEnlistment PROC
	push ebp
	mov ebp, esp
	push 05FC11E13h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrePrepareEnlistment ENDP

NtPrepareComplete PROC
	push ebp
	mov ebp, esp
	push 04929BB70h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrepareComplete ENDP

NtPrepareEnlistment PROC
	push ebp
	mov ebp, esp
	push 076A81142h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrepareEnlistment ENDP

NtPrivilegeCheck PROC
	push ebp
	mov ebp, esp
	push 0F855C1F7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrivilegeCheck ENDP

NtPrivilegeObjectAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 03C52C61Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrivilegeObjectAuditAlarm ENDP

NtPrivilegedServiceAuditAlarm PROC
	push ebp
	mov ebp, esp
	push 0B638BCA0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPrivilegedServiceAuditAlarm ENDP

NtPropagationComplete PROC
	push ebp
	mov ebp, esp
	push 01E610EEEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPropagationComplete ENDP

NtPropagationFailed PROC
	push ebp
	mov ebp, esp
	push 04E9E74C0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPropagationFailed ENDP

NtPulseEvent PROC
	push ebp
	mov ebp, esp
	push 040836718h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPulseEvent ENDP

NtQueryAuxiliaryCounterFrequency PROC
	push ebp
	mov ebp, esp
	push 006AB2134h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryAuxiliaryCounterFrequency ENDP

NtQueryBootEntryOrder PROC
	push ebp
	mov ebp, esp
	push 0039F9B95h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryBootEntryOrder ENDP

NtQueryBootOptions PROC
	push ebp
	mov ebp, esp
	push 0C7572ACFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryBootOptions ENDP

NtQueryDebugFilterState PROC
	push ebp
	mov ebp, esp
	push 0F1480645h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDebugFilterState ENDP

NtQueryDirectoryFileEx PROC
	push ebp
	mov ebp, esp
	push 014275CF0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 10h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDirectoryFileEx ENDP

NtQueryDirectoryObject PROC
	push ebp
	mov ebp, esp
	push 02C1F1453h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDirectoryObject ENDP

NtQueryDriverEntryOrder PROC
	push ebp
	mov ebp, esp
	push 01BB8695Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryDriverEntryOrder ENDP

NtQueryEaFile PROC
	push ebp
	mov ebp, esp
	push 0BC2B8EBCh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryEaFile ENDP

NtQueryFullAttributesFile PROC
	push ebp
	mov ebp, esp
	push 0DBD9D771h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryFullAttributesFile ENDP

NtQueryInformationAtom PROC
	push ebp
	mov ebp, esp
	push 04CD6B17Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationAtom ENDP

NtQueryInformationByName PROC
	push ebp
	mov ebp, esp
	push 0ED33FA82h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationByName ENDP

NtQueryInformationEnlistment PROC
	push ebp
	mov ebp, esp
	push 09844E58Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationEnlistment ENDP

NtQueryInformationJobObject PROC
	push ebp
	mov ebp, esp
	push 0A4BFDDB2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationJobObject ENDP

NtQueryInformationPort PROC
	push ebp
	mov ebp, esp
	push 064F6795Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationPort ENDP

NtQueryInformationResourceManager PROC
	push ebp
	mov ebp, esp
	push 027B50F2Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationResourceManager ENDP

NtQueryInformationTransaction PROC
	push ebp
	mov ebp, esp
	push 00C845229h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationTransaction ENDP

NtQueryInformationTransactionManager PROC
	push ebp
	mov ebp, esp
	push 03F29D430h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationTransactionManager ENDP

NtQueryInformationWorkerFactory PROC
	push ebp
	mov ebp, esp
	push 0055D25F4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInformationWorkerFactory ENDP

NtQueryInstallUILanguage PROC
	push ebp
	mov ebp, esp
	push 073EF4472h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryInstallUILanguage ENDP

NtQueryIntervalProfile PROC
	push ebp
	mov ebp, esp
	push 00F5D8C44h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryIntervalProfile ENDP

NtQueryIoCompletion PROC
	push ebp
	mov ebp, esp
	push 0950EB59Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryIoCompletion ENDP

NtQueryLicenseValue PROC
	push ebp
	mov ebp, esp
	push 021203C98h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryLicenseValue ENDP

NtQueryMultipleValueKey PROC
	push ebp
	mov ebp, esp
	push 0E95DC8EAh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryMultipleValueKey ENDP

NtQueryMutant PROC
	push ebp
	mov ebp, esp
	push 04F6A0EBEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryMutant ENDP

NtQueryOpenSubKeys PROC
	push ebp
	mov ebp, esp
	push 022D830B9h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryOpenSubKeys ENDP

NtQueryOpenSubKeysEx PROC
	push ebp
	mov ebp, esp
	push 09860DE9Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryOpenSubKeysEx ENDP

NtQueryPortInformationProcess PROC
	push ebp
	mov ebp, esp
	push 0B9A39E38h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryPortInformationProcess ENDP

NtQueryQuotaInformationFile PROC
	push ebp
	mov ebp, esp
	push 0229A520Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryQuotaInformationFile ENDP

NtQuerySecurityAttributesToken PROC
	push ebp
	mov ebp, esp
	push 001D01F70h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySecurityAttributesToken ENDP

NtQuerySecurityObject PROC
	push ebp
	mov ebp, esp
	push 08858D295h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySecurityObject ENDP

NtQuerySecurityPolicy PROC
	push ebp
	mov ebp, esp
	push 08651BBE5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySecurityPolicy ENDP

NtQuerySemaphore PROC
	push ebp
	mov ebp, esp
	push 08555760Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySemaphore ENDP

NtQuerySymbolicLinkObject PROC
	push ebp
	mov ebp, esp
	push 0009E21C3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySymbolicLinkObject ENDP

NtQuerySystemEnvironmentValue PROC
	push ebp
	mov ebp, esp
	push 0988B0EBFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySystemEnvironmentValue ENDP

NtQuerySystemEnvironmentValueEx PROC
	push ebp
	mov ebp, esp
	push 01035528Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySystemEnvironmentValueEx ENDP

NtQuerySystemInformationEx PROC
	push ebp
	mov ebp, esp
	push 036D4F4AEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySystemInformationEx ENDP

NtQueryTimerResolution PROC
	push ebp
	mov ebp, esp
	push 0148A1419h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryTimerResolution ENDP

NtQueryWnfStateData PROC
	push ebp
	mov ebp, esp
	push 0AEC6509Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryWnfStateData ENDP

NtQueryWnfStateNameInformation PROC
	push ebp
	mov ebp, esp
	push 0228BE4DFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueryWnfStateNameInformation ENDP

NtQueueApcThreadEx PROC
	push ebp
	mov ebp, esp
	push 0382B0C96h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQueueApcThreadEx ENDP

NtRaiseException PROC
	push ebp
	mov ebp, esp
	push 0990F9595h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRaiseException ENDP

NtRaiseHardError PROC
	push ebp
	mov ebp, esp
	push 0FD6CFDFBh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRaiseHardError ENDP

NtReadOnlyEnlistment PROC
	push ebp
	mov ebp, esp
	push 00E26CB74h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReadOnlyEnlistment ENDP

NtRecoverEnlistment PROC
	push ebp
	mov ebp, esp
	push 0BB26A1B0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRecoverEnlistment ENDP

NtRecoverResourceManager PROC
	push ebp
	mov ebp, esp
	push 01F06860Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRecoverResourceManager ENDP

NtRecoverTransactionManager PROC
	push ebp
	mov ebp, esp
	push 00A3606ACh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRecoverTransactionManager ENDP

NtRegisterProtocolAddressInformation PROC
	push ebp
	mov ebp, esp
	push 015831310h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRegisterProtocolAddressInformation ENDP

NtRegisterThreadTerminatePort PROC
	push ebp
	mov ebp, esp
	push 0DAB3C13Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRegisterThreadTerminatePort ENDP

NtReleaseKeyedEvent PROC
	push ebp
	mov ebp, esp
	push 00F4AF53Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReleaseKeyedEvent ENDP

NtReleaseWorkerFactoryWorker PROC
	push ebp
	mov ebp, esp
	push 08B77A822h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReleaseWorkerFactoryWorker ENDP

NtRemoveIoCompletionEx PROC
	push ebp
	mov ebp, esp
	push 08092D44Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRemoveIoCompletionEx ENDP

NtRemoveProcessDebug PROC
	push ebp
	mov ebp, esp
	push 08423B668h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRemoveProcessDebug ENDP

NtRenameKey PROC
	push ebp
	mov ebp, esp
	push 003925840h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRenameKey ENDP

NtRenameTransactionManager PROC
	push ebp
	mov ebp, esp
	push 08E329AAFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRenameTransactionManager ENDP

NtReplaceKey PROC
	push ebp
	mov ebp, esp
	push 09EDDB571h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReplaceKey ENDP

NtReplacePartitionUnit PROC
	push ebp
	mov ebp, esp
	push 03838CA3Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReplacePartitionUnit ENDP

NtReplyWaitReplyPort PROC
	push ebp
	mov ebp, esp
	push 020BD272Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReplyWaitReplyPort ENDP

NtRequestPort PROC
	push ebp
	mov ebp, esp
	push 02ACD0152h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRequestPort ENDP

NtResetEvent PROC
	push ebp
	mov ebp, esp
	push 07EBE4518h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtResetEvent ENDP

NtResetWriteWatch PROC
	push ebp
	mov ebp, esp
	push 074B94E2Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtResetWriteWatch ENDP

NtRestoreKey PROC
	push ebp
	mov ebp, esp
	push 0DF5AFCF0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRestoreKey ENDP

NtResumeProcess PROC
	push ebp
	mov ebp, esp
	push 0DE3CD7A3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtResumeProcess ENDP

NtRevertContainerImpersonation PROC
	push ebp
	mov ebp, esp
	push 004AE043Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRevertContainerImpersonation ENDP

NtRollbackComplete PROC
	push ebp
	mov ebp, esp
	push 069304180h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRollbackComplete ENDP

NtRollbackEnlistment PROC
	push ebp
	mov ebp, esp
	push 0F196D64Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRollbackEnlistment ENDP

NtRollbackRegistryTransaction PROC
	push ebp
	mov ebp, esp
	push 094D64F9Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRollbackRegistryTransaction ENDP

NtRollbackTransaction PROC
	push ebp
	mov ebp, esp
	push 00E992005h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRollbackTransaction ENDP

NtRollforwardTransactionManager PROC
	push ebp
	mov ebp, esp
	push 08B375614h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRollforwardTransactionManager ENDP

NtSaveKey PROC
	push ebp
	mov ebp, esp
	push 009DAF7ACh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSaveKey ENDP

NtSaveKeyEx PROC
	push ebp
	mov ebp, esp
	push 07E75B003h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSaveKeyEx ENDP

NtSaveMergedKeys PROC
	push ebp
	mov ebp, esp
	push 021B8DDD2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSaveMergedKeys ENDP

NtSecureConnectPort PROC
	push ebp
	mov ebp, esp
	push 026E94576h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSecureConnectPort ENDP

NtSerializeBoot PROC
	push ebp
	mov ebp, esp
	push 070A0367Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSerializeBoot ENDP

NtSetBootEntryOrder PROC
	push ebp
	mov ebp, esp
	push 01F3269D7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetBootEntryOrder ENDP

NtSetBootOptions PROC
	push ebp
	mov ebp, esp
	push 0D98B3D1Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetBootOptions ENDP

NtSetCachedSigningLevel PROC
	push ebp
	mov ebp, esp
	push 0209B2424h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetCachedSigningLevel ENDP

NtSetCachedSigningLevel2 PROC
	push ebp
	mov ebp, esp
	push 004BB8D6Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetCachedSigningLevel2 ENDP

NtSetContextThread PROC
	push ebp
	mov ebp, esp
	push 0284FAD6Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetContextThread ENDP

NtSetDebugFilterState PROC
	push ebp
	mov ebp, esp
	push 030B16E0Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetDebugFilterState ENDP

NtSetDefaultHardErrorPort PROC
	push ebp
	mov ebp, esp
	push 0DD71D8DFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetDefaultHardErrorPort ENDP

NtSetDefaultLocale PROC
	push ebp
	mov ebp, esp
	push 0C7A7FD62h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetDefaultLocale ENDP

NtSetDefaultUILanguage PROC
	push ebp
	mov ebp, esp
	push 0B58B39A3h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetDefaultUILanguage ENDP

NtSetDriverEntryOrder PROC
	push ebp
	mov ebp, esp
	push 01F8C8C91h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetDriverEntryOrder ENDP

NtSetEaFile PROC
	push ebp
	mov ebp, esp
	push 0AEEDFED2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetEaFile ENDP

NtSetHighEventPair PROC
	push ebp
	mov ebp, esp
	push 010B43821h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetHighEventPair ENDP

NtSetHighWaitLowEventPair PROC
	push ebp
	mov ebp, esp
	push 03CB3D02Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetHighWaitLowEventPair ENDP

NtSetIRTimer PROC
	push ebp
	mov ebp, esp
	push 093AAE962h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetIRTimer ENDP

NtSetInformationDebugObject PROC
	push ebp
	mov ebp, esp
	push 040986A45h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationDebugObject ENDP

NtSetInformationEnlistment PROC
	push ebp
	mov ebp, esp
	push 07BD27C40h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationEnlistment ENDP

NtSetInformationJobObject PROC
	push ebp
	mov ebp, esp
	push 0F8D4C27Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationJobObject ENDP

NtSetInformationKey PROC
	push ebp
	mov ebp, esp
	push 0D389FC39h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationKey ENDP

NtSetInformationResourceManager PROC
	push ebp
	mov ebp, esp
	push 07F1F8F7Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationResourceManager ENDP

NtSetInformationSymbolicLink PROC
	push ebp
	mov ebp, esp
	push 0AE38242Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationSymbolicLink ENDP

NtSetInformationToken PROC
	push ebp
	mov ebp, esp
	push 03398F932h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationToken ENDP

NtSetInformationTransaction PROC
	push ebp
	mov ebp, esp
	push 00EE62E75h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationTransaction ENDP

NtSetInformationTransactionManager PROC
	push ebp
	mov ebp, esp
	push 0AB14E5C8h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationTransactionManager ENDP

NtSetInformationVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 00D963B39h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationVirtualMemory ENDP

NtSetInformationWorkerFactory PROC
	push ebp
	mov ebp, esp
	push 07EEE544Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationWorkerFactory ENDP

NtSetIntervalProfile PROC
	push ebp
	mov ebp, esp
	push 05C847200h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetIntervalProfile ENDP

NtSetIoCompletion PROC
	push ebp
	mov ebp, esp
	push 03553158Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetIoCompletion ENDP

NtSetIoCompletionEx PROC
	push ebp
	mov ebp, esp
	push 018DE423Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetIoCompletionEx ENDP

NtSetLdtEntries PROC
	push ebp
	mov ebp, esp
	push 02612D21Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetLdtEntries ENDP

NtSetLowEventPair PROC
	push ebp
	mov ebp, esp
	push 004B42C01h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetLowEventPair ENDP

NtSetLowWaitHighEventPair PROC
	push ebp
	mov ebp, esp
	push 014B0342Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetLowWaitHighEventPair ENDP

NtSetQuotaInformationFile PROC
	push ebp
	mov ebp, esp
	push 0ED4A266Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetQuotaInformationFile ENDP

NtSetSecurityObject PROC
	push ebp
	mov ebp, esp
	push 01CB8241Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetSecurityObject ENDP

NtSetSystemEnvironmentValue PROC
	push ebp
	mov ebp, esp
	push 01483CC3Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetSystemEnvironmentValue ENDP

NtSetSystemEnvironmentValueEx PROC
	push ebp
	mov ebp, esp
	push 06CBE5E05h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetSystemEnvironmentValueEx ENDP

NtSetSystemInformation PROC
	push ebp
	mov ebp, esp
	push 03EA23835h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetSystemInformation ENDP

NtSetSystemPowerState PROC
	push ebp
	mov ebp, esp
	push 07290585Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetSystemPowerState ENDP

NtSetSystemTime PROC
	push ebp
	mov ebp, esp
	push 0A4A9B412h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetSystemTime ENDP

NtSetThreadExecutionState PROC
	push ebp
	mov ebp, esp
	push 05C9257F2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetThreadExecutionState ENDP

NtSetTimer2 PROC
	push ebp
	mov ebp, esp
	push 0B5B61520h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetTimer2 ENDP

NtSetTimerEx PROC
	push ebp
	mov ebp, esp
	push 0130259FFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetTimerEx ENDP

NtSetTimerResolution PROC
	push ebp
	mov ebp, esp
	push 0C14E205Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetTimerResolution ENDP

NtSetUuidSeed PROC
	push ebp
	mov ebp, esp
	push 007ACCF00h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetUuidSeed ENDP

NtSetVolumeInformationFile PROC
	push ebp
	mov ebp, esp
	push 0CBDA3ACCh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetVolumeInformationFile ENDP

NtSetWnfProcessNotificationEvent PROC
	push ebp
	mov ebp, esp
	push 03EAD3B3Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetWnfProcessNotificationEvent ENDP

NtShutdownSystem PROC
	push ebp
	mov ebp, esp
	push 0C050C9C4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtShutdownSystem ENDP

NtShutdownWorkerFactory PROC
	push ebp
	mov ebp, esp
	push 00494706Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtShutdownWorkerFactory ENDP

NtSignalAndWaitForSingleObject PROC
	push ebp
	mov ebp, esp
	push 09AB569CAh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSignalAndWaitForSingleObject ENDP

NtSinglePhaseReject PROC
	push ebp
	mov ebp, esp
	push 0B816D28Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSinglePhaseReject ENDP

NtStartProfile PROC
	push ebp
	mov ebp, esp
	push 004B2DC80h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtStartProfile ENDP

NtStopProfile PROC
	push ebp
	mov ebp, esp
	push 0F7A6F01Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtStopProfile ENDP

NtSubscribeWnfStateChange PROC
	push ebp
	mov ebp, esp
	push 01E236FFEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSubscribeWnfStateChange ENDP

NtSuspendProcess PROC
	push ebp
	mov ebp, esp
	push 05D863A94h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSuspendProcess ENDP

NtSuspendThread PROC
	push ebp
	mov ebp, esp
	push 0F8E372CDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSuspendThread ENDP

NtSystemDebugControl PROC
	push ebp
	mov ebp, esp
	push 0078F011Dh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSystemDebugControl ENDP

NtTerminateEnclave PROC
	push ebp
	mov ebp, esp
	push 0EEB062A2h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTerminateEnclave ENDP

NtTerminateJobObject PROC
	push ebp
	mov ebp, esp
	push 0269A2407h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTerminateJobObject ENDP

NtTestAlert PROC
	push ebp
	mov ebp, esp
	push 086D5B57Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTestAlert ENDP

NtThawRegistry PROC
	push ebp
	mov ebp, esp
	push 040AF3E4Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtThawRegistry ENDP

NtThawTransactions PROC
	push ebp
	mov ebp, esp
	push 0019A1971h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtThawTransactions ENDP

NtTraceControl PROC
	push ebp
	mov ebp, esp
	push 00991F3D7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 6h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTraceControl ENDP

NtTranslateFilePath PROC
	push ebp
	mov ebp, esp
	push 0CE10E9DEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtTranslateFilePath ENDP

NtUmsThreadYield PROC
	push ebp
	mov ebp, esp
	push 0A73A9CADh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUmsThreadYield ENDP

NtUnloadDriver PROC
	push ebp
	mov ebp, esp
	push 012BF4E12h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnloadDriver ENDP

NtUnloadKey PROC
	push ebp
	mov ebp, esp
	push 0C81F2B67h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnloadKey ENDP

NtUnloadKey2 PROC
	push ebp
	mov ebp, esp
	push 0AFD77AF0h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnloadKey2 ENDP

NtUnloadKeyEx PROC
	push ebp
	mov ebp, esp
	push 0537819C5h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnloadKeyEx ENDP

NtUnlockFile PROC
	push ebp
	mov ebp, esp
	push 06C3E64A8h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 5h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnlockFile ENDP

NtUnlockVirtualMemory PROC
	push ebp
	mov ebp, esp
	push 003932D05h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnlockVirtualMemory ENDP

NtUnmapViewOfSectionEx PROC
	push ebp
	mov ebp, esp
	push 032890634h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnmapViewOfSectionEx ENDP

NtUnsubscribeWnfStateChange PROC
	push ebp
	mov ebp, esp
	push 04F5F1B6Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUnsubscribeWnfStateChange ENDP

NtUpdateWnfStateData PROC
	push ebp
	mov ebp, esp
	push 0A23CD4B4h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 7h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtUpdateWnfStateData ENDP

NtVdmControl PROC
	push ebp
	mov ebp, esp
	push 04794470Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtVdmControl ENDP

NtWaitForAlertByThreadId PROC
	push ebp
	mov ebp, esp
	push 05CBE6E69h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForAlertByThreadId ENDP

NtWaitForDebugEvent PROC
	push ebp
	mov ebp, esp
	push 0008B0B0Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForDebugEvent ENDP

NtWaitForKeyedEvent PROC
	push ebp
	mov ebp, esp
	push 0D08A3618h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForKeyedEvent ENDP

NtWaitForWorkViaWorkerFactory PROC
	push ebp
	mov ebp, esp
	push 058F0725Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForWorkViaWorkerFactory ENDP

NtWaitHighEventPair PROC
	push ebp
	mov ebp, esp
	push 027921D3Eh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitHighEventPair ENDP

NtWaitLowEventPair PROC
	push ebp
	mov ebp, esp
	push 0C09DC00Bh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitLowEventPair ENDP

NtAcquireCMFViewOwnership PROC
	push ebp
	mov ebp, esp
	push 00A912008h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtAcquireCMFViewOwnership ENDP

NtCancelDeviceWakeupRequest PROC
	push ebp
	mov ebp, esp
	push 017AAEFA6h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCancelDeviceWakeupRequest ENDP

NtClearAllSavepointsTransaction PROC
	push ebp
	mov ebp, esp
	push 0000846DDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtClearAllSavepointsTransaction ENDP

NtClearSavepointTransaction PROC
	push ebp
	mov ebp, esp
	push 012151E8Fh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtClearSavepointTransaction ENDP

NtRollbackSavepointTransaction PROC
	push ebp
	mov ebp, esp
	push 076E950BDh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRollbackSavepointTransaction ENDP

NtSavepointTransaction PROC
	push ebp
	mov ebp, esp
	push 00D920904h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 3h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSavepointTransaction ENDP

NtSavepointComplete PROC
	push ebp
	mov ebp, esp
	push 0BD32253Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSavepointComplete ENDP

NtCreateSectionEx PROC
	push ebp
	mov ebp, esp
	push 0FEAD2DF7h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 9h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateSectionEx ENDP

NtCreateCrossVmEvent PROC
	push ebp
	mov ebp, esp
	push 09CBBA109h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtCreateCrossVmEvent ENDP

NtGetPlugPlayEvent PROC
	push ebp
	mov ebp, esp
	push 040CB3F38h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtGetPlugPlayEvent ENDP

NtListTransactions PROC
	push ebp
	mov ebp, esp
	push 001953933h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtListTransactions ENDP

NtMarshallTransaction PROC
	push ebp
	mov ebp, esp
	push 030AB12FFh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtMarshallTransaction ENDP

NtPullTransaction PROC
	push ebp
	mov ebp, esp
	push 0178C151Ch        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtPullTransaction ENDP

NtReleaseCMFViewOwnership PROC
	push ebp
	mov ebp, esp
	push 058E781AEh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtReleaseCMFViewOwnership ENDP

NtWaitForWnfNotifications PROC
	push ebp
	mov ebp, esp
	push 00D973101h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtWaitForWnfNotifications ENDP

NtStartTm PROC
	push ebp
	mov ebp, esp
	push 0438F257Ah        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 0h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtStartTm ENDP

NtSetInformationProcess PROC
	push ebp
	mov ebp, esp
	push 07E337FACh        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtSetInformationProcess ENDP

NtRequestDeviceWakeup PROC
	push ebp
	mov ebp, esp
	push 01547D013h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRequestDeviceWakeup ENDP

NtRequestWakeupLatency PROC
	push ebp
	mov ebp, esp
	push 0BC18A7B8h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtRequestWakeupLatency ENDP

NtQuerySystemTime PROC
	push ebp
	mov ebp, esp
	push 08E97AF13h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 1h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtQuerySystemTime ENDP

NtManageHotPatch PROC
	push ebp
	mov ebp, esp
	push 0E4D93065h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 4h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtManageHotPatch ENDP

NtContinueEx PROC
	push ebp
	mov ebp, esp
	push 053AD7510h        ; Load function hash into ECX.
	call SW2_GetSyscallNumber
	lea esp, [esp+4]
	mov ecx, 2h
push_argument:
	dec ecx
	push [ebp + 08h + ecx * 4]
	jnz push_argument
	push ret_address_epilog ;ret address
	call dword ptr internal_cleancall_wow64_gate ; call KiFastSystemCall
	lea esp, [esp+4]
ret_address_epilog:
	mov esp, ebp
	pop ebp
	ret
NtContinueEx ENDP



END
```