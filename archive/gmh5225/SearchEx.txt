Project Path: arc_gmh5225_SearchEx_4e0cfe6m

Source Tree:

```txt
arc_gmh5225_SearchEx_4e0cfe6m
├── SRC
│   ├── SearchEx.cpp
│   ├── SearchEx.rc
│   ├── code32.asm
│   ├── code64.asm
│   ├── file.cpp
│   ├── file.h
│   ├── lineheap.cpp
│   ├── lineheap.h
│   ├── mask.cpp
│   ├── mask.h
│   ├── name component.cpp
│   ├── name component.h
│   ├── resource.h
│   ├── search.ico
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── task.cpp
│   └── task.h
├── readme.txt
├── s1.png
├── s2.png
├── s3.png
├── s4.png
├── s5.png
├── s6.png
├── x64
│   └── SearchEx.exe
└── x86
    └── SearchEx.exe

```

`SRC/SearchEx.cpp`:

```cpp
// SearchEx.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

_NT_BEGIN

#include "resource.h"
#include "../inc/initterm.h"
#include "../inc/rundown.h"
#include "../asio/io.h"
#include "../asio/tp.h"
#include "../winZ/window.h"
#include "../winZ/ctrl.h"
#include "task.h"

HFONT CreateCaptionFont()
{
	ULONG m;
	RtlGetNtVersionNumbers(&m, 0, 0);

	NONCLIENTMETRICS ncm = { m < 6 ? sizeof(NONCLIENTMETRICS) - 4 : sizeof(NONCLIENTMETRICS) };
	if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
	{
		ncm.lfCaptionFont.lfWeight = FW_NORMAL;
		ncm.lfCaptionFont.lfQuality = CLEARTYPE_QUALITY;
		ncm.lfCaptionFont.lfPitchAndFamily = FIXED_PITCH|FF_MODERN;
		wcscpy(ncm.lfCaptionFont.lfFaceName, L"Courier New");

		return CreateFontIndirect(&ncm.lfCaptionFont);
	}

	return 0;
}

class SearchDlg : public ZDlg, CIcons
{
	Task m_task;
	HFONT m_hFont;
	int m_Encoding, m_SearchEncoding;
	ULONG m_cbStr;
	BOOL m_bInSearch;

	enum {
		i_ANSI, i_OEM, i_UTF8, i_UTF16, i_HEX, i_DWORD
	};

	void OnInitDialog(HWND hwndDlg);

	void OnTask(HWND hwndDlg, BOOL begin);

	void OnOk(HWND hwndDlg);

	void ShowLog(HWND hwndDlg);

	void PrintResults(HWND hwndDlg);

	void ShowStatus(HWND hwndDlg, ULONG ticks, BOOL bFinal);

	void OnCaseSensetive(HWND hwndEdit, HWND hwndChk);

	void OnEncodingChanged(HWND hwndEdit, HWND hwndCombo, HWND hwndCheck);

	static PWSTR ReadData(HANDLE hFile, PLARGE_INTEGER ByteOffset, PBYTE pb, ULONG& cb, PWSTR pszText, ULONG& cchTextMax);

	void SetInfoTip(PWSTR pszText, ULONG cchTextMax, SEARCH_RESULT *psr);

	virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

void SearchDlg::OnInitDialog(HWND hwndDlg)
{
	SetIcons(hwndDlg, (HINSTANCE)&__ImageBase, MAKEINTRESOURCE(1));
	m_bInSearch = FALSE;

	m_hFont = CreateCaptionFont();

	if (0 > m_task.Create(hwndDlg, 0x1000000, 0x1000000))
	{
		EndDialog(hwndDlg, -1);
		return ;
	}

	CheckDlgButton(hwndDlg, IDC_CHECK2, BST_CHECKED);
	SetDlgItemInt(hwndDlg, IDC_EDIT4, 32, FALSE);
	SetDlgItemInt(hwndDlg, IDC_EDIT5, 0, FALSE);

	HWND hwnd = GetDlgItem(hwndDlg, IDC_COMBO1);

	ComboBox_AddString(hwnd, L"ANSI");
	ComboBox_AddString(hwnd, L"OEM");
	ComboBox_AddString(hwnd, L"UTF-8");
	ComboBox_AddString(hwnd, L"UTF-16");
	ComboBox_AddString(hwnd, L"HEX");
	ComboBox_AddString(hwnd, L"DWORD");
	ComboBox_SetCurSel(hwnd, i_ANSI);
	m_Encoding = i_ANSI;

	HWND hwndLV = GetDlgItem(hwndDlg, IDC_LIST1);

	SetWindowTheme(hwndLV, L"Explorer", 0);

	RECT rc;
	GetWindowRect(hwndLV, &rc);

	ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_BORDERSELECT|LVS_EX_INFOTIP|LVS_EX_FULLROWSELECT|LVS_EX_DOUBLEBUFFER);

	SIZE size = { 8, 16 };
	if (HDC hdc = GetDC(hwndLV))
	{
		HGDIOBJ o = SelectObject(hdc, (HGDIOBJ)SendMessage(hwndLV, WM_GETFONT, 0, 0));
		GetTextExtentPoint32(hdc, L"W", 1, &size);
		SelectObject(hdc, o);
		ReleaseDC(hwndLV, hdc);
	}

	LVCOLUMN lvc = { LVCF_FMT|LVCF_WIDTH|LVCF_TEXT|LVCF_SUBITEM, LVCFMT_LEFT };

	static PCWSTR headers[] = { L" Offset ", L" Name "};
	DWORD lens[] = { 16, 80};

	do 
	{
		lvc.pszText = (PWSTR)headers[lvc.iSubItem], lvc.cx = lens[lvc.iSubItem] * size.cx;
		ListView_InsertColumn(hwndLV, lvc.iSubItem, &lvc);
	} while (++lvc.iSubItem < RTL_NUMBER_OF(headers));

	SendMessage(ListView_GetToolTips(hwndLV), TTM_SETDELAYTIME, TTDT_AUTOPOP, MAKELONG(MAXSHORT, 0));
}

void SearchDlg::OnTask(HWND hwndDlg, BOOL begin)
{
	m_bInSearch = begin;
	EnableWindow(GetDlgItem(hwndDlg, IDOK), !begin);
	EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), begin);

	if (begin)
	{
		EnableWindow(GetDlgItem(hwndDlg, IDC_BUTTON1), FALSE);
		ListView_SetItemCountEx(GetDlgItem(hwndDlg, IDC_LIST1), 0, 0);
		SetWindowTextW(hwndDlg, L"Search");
		SetTimer(hwndDlg, 0, 1000, 0);
	}
	else
	{
		KillTimer(hwndDlg, 0);
	}
}

void SearchDlg::OnOk(HWND hwndDlg)
{
	BOOL Translated;
	UINT maxIoCount = GetDlgItemInt(hwndDlg, IDC_EDIT4, &Translated, FALSE);

	if (maxIoCount - 1 > 98 || !Translated)
	{
		SetFocus(GetDlgItem(hwndDlg, IDC_EDIT4));
		MessageBoxW(hwndDlg, L"Maximum simultaneous I/O requests\r\ncount must be in range [1, 100)", 0, MB_ICONWARNING|MB_OK);
		return;
	}

	UINT maxLevel = GetDlgItemInt(hwndDlg, IDC_EDIT5, &Translated, FALSE);

	if (!Translated)
	{
		SetFocus(GetDlgItem(hwndDlg, IDC_EDIT5));
		MessageBoxW(hwndDlg, L"0: infinite\r\n1: current folder only\r\nN: and so on", L"You need set deep search level", MB_ICONWARNING|MB_OK);
		return;
	}

	if (!maxLevel)
	{
		maxLevel = MAXDWORD;
	}

	HWND hwnd;
	ULONG len;
	PWSTR mask = 0;

	if (len = GetWindowTextLength(hwnd = GetDlgItem(hwndDlg, IDC_EDIT2)))
	{
		mask = (PWSTR)alloca((len+2)*sizeof(WCHAR));
		GetWindowText(hwnd, mask, len + 1);
		if (len == 1 && *mask == '*')
		{
			mask = 0;
		}
		else
		{
			mask[len] = ':', mask[len + 1] = 0;

			PWSTR c = mask;

			while (c = wcschr(c, '*'))
			{
				if (*++c == '*')
				{
					SetFocus(hwnd);
					MessageBoxW(hwndDlg, L"no sense have ** in mask", 0, MB_ICONWARNING|MB_OK);
					return;
				}
			}
		}
	}

	PVOID pvStr = 0;
	ULONG cbStr = 0;
	UINT CodePage = 0;

	if (len = GetWindowTextLength(hwnd = GetDlgItem(hwndDlg, IDC_EDIT3)))
	{
		if (len > 256)
		{
			SetFocus(hwnd);
			MessageBoxW(hwndDlg, L"string too long (> 256) !", 0, MB_ICONWARNING|MB_OK);
			return ;
		}
		PWSTR str = (PWSTR)alloca((len + 1)* sizeof(WCHAR));
		GetWindowText(hwnd, str, len + 1);

		BOOL UsedDefaultChar = FALSE, *lpUsedDefaultChar = &UsedDefaultChar;

		switch (m_Encoding)
		{
		case i_ANSI:
			CodePage = CP_ACP;
			break;

		case i_OEM:
			CodePage = CP_OEMCP;
			break;

		case i_UTF8:
			CodePage = CP_UTF8;
			lpUsedDefaultChar = 0;
			break;

		case i_UTF16:
			pvStr = str, cbStr = len * sizeof(WCHAR);
			goto __ok;

		case i_HEX:
			while (CryptStringToBinaryW(str, len, CRYPT_STRING_HEX, (PBYTE)pvStr, &cbStr, 0, 0))
			{
				if (pvStr)
				{
					goto __ok;
				}

				pvStr = alloca(cbStr);
			}
			SetFocus(hwnd);
			MessageBoxW(hwndDlg, L"Invalid Hex string", 0, MB_ICONWARNING|MB_OK);
			return;

		case i_DWORD:
			if (len <= 8)
			{
				if (ULONG n =  wcstoul(str, &str, 16))
				{
					if (!*str)
					{
						cbStr = sizeof(n);
						pvStr = &n;
						goto __ok;
					}
				}
			}
			SetFocus(hwnd);
			MessageBoxW(hwndDlg, L"Invalid DWORD", 0, MB_ICONWARNING|MB_OK);
			return;
		default:
			return;
		}

		while ((cbStr = WideCharToMultiByte(CodePage, 0, str, len, (PSTR)pvStr, cbStr, 0, lpUsedDefaultChar)) && !UsedDefaultChar)
		{
			if (pvStr)
			{
				goto __ok;
			}

			pvStr = alloca(cbStr);
		}

		SetFocus(hwnd);
		MessageBoxW(hwndDlg, L"string can not be converted !", 0, MB_ICONWARNING|MB_OK);
		return ;
	}

__ok:
	if (!(len = GetWindowTextLength(hwnd = GetDlgItem(hwndDlg, IDC_EDIT1))))
	{
		SetFocus(hwnd);
		MessageBoxW(hwndDlg, L"Root Folder or File Path can not be empty", 0, MB_ICONWARNING|MB_OK);
		return;
	}

	PWSTR Name = (PWSTR)alloca((len + 1) * sizeof(WCHAR));
	GetWindowText(hwnd, Name, len + 1);

	m_cbStr = cbStr, m_SearchEncoding = m_Encoding;

	NTSTATUS status = m_task.Start(Name, mask, pvStr, cbStr, maxIoCount, maxLevel,
		IsDlgButtonChecked(hwndDlg, IDC_CHECK1) == BST_CHECKED, m_Encoding == i_UTF16,
		m_Encoding >= i_HEX || IsDlgButtonChecked(hwndDlg, IDC_CHECK2) == BST_CHECKED, CodePage);

	if (0 <= status)
	{
		SetDlgItemText(hwndDlg, IDC_STATIC1, L"");
		OnTask(hwndDlg, TRUE);
	}
}

void SearchDlg::ShowLog(HWND hwndDlg)
{
	if (SIZE_T size = m_task.m_log.getSize())
	{
		PWSTR sz = (PWSTR)m_task.m_log.getBase();
		*(PWSTR)RtlOffsetToPointer(sz, size - sizeof(WCHAR))=0;
		if (HWND hwnd = CreateWindowExW(0, WC_EDIT, L"Fail files", 
			WS_OVERLAPPEDWINDOW|WS_VSCROLL|WS_HSCROLL|ES_MULTILINE|ES_AUTOHSCROLL|ES_AUTOVSCROLL, 
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwndDlg, 0, 0, 0))
		{
			if (m_hFont)
			{
				SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hFont, 0);
			}

			SetWindowTextW(hwnd, sz);
			ShowWindow(hwnd, SW_SHOW);
		}
	}
}

void SearchDlg::PrintResults(HWND hwndDlg)
{
	if (ULONG n = m_task.m_nResults)
	{
		SEARCH_RESULT* psr = (SEARCH_RESULT*)m_task.m_srh.getBase(), *_psr = psr;

		BOOL bOffset = m_task.m_cbStr;
		ULONG cbex = bOffset ? 19 : 2;
		ULONG i = n, len = 1;

		do 
		{
			len += cbex + _psr++->name->get_Length();
		} while (--i);

		if (PWSTR buf = new WCHAR[len])
		{
			PWSTR sz = buf;
			do 
			{
				if (bOffset)
				{
					sz += swprintf(sz, L"%16I64x ", psr->offset);
				}

				len -= cbex;

				sz = psr++->name->Print(sz, len);

				*sz++ = '\r', *sz++ = '\n';

			} while (--n);

			*sz = 0;

			if (HWND hwnd = CreateWindowExW(0, WC_EDIT, L"Results", 
				WS_OVERLAPPEDWINDOW|WS_VSCROLL|WS_HSCROLL|ES_MULTILINE|ES_AUTOHSCROLL|ES_AUTOVSCROLL, 
				CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwndDlg, 0, 0, 0))
			{
				if (m_hFont)
				{
					SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hFont, 0);
				}

				SetWindowTextW(hwnd, buf);
				ShowWindow(hwnd, SW_SHOW);
			}

			delete [] buf;
		}
	}
}

void SearchDlg::ShowStatus(HWND hwndDlg, ULONG ticks, BOOL bFinal)
{
	WCHAR sz[128];
	swprintf(sz, L"%u: %u/%u %I64u (%u)(%u)\n", ticks, m_task.m_nFolders, m_task.m_nFiles, 
		m_task.m_TotalSize, m_task.m_MaxTasks, m_task.m_PeakIoCount);
	SetDlgItemText(hwndDlg, IDC_STATIC1, sz);
	SEARCH_RESULT *psr;
	ULONG n = m_task.getResults(&psr);
	swprintf(sz, L"Search - %u found%s", n, m_task.Quit() ? L" [canceled]" : L"");
	SetWindowTextW(hwndDlg, sz);

	if (bFinal && n)
	{
		EnableWindow(GetDlgItem(hwndDlg, IDC_BUTTON1), TRUE);

		qsort(psr, n, sizeof(SEARCH_RESULT), QSORTFN(SEARCH_RESULT::compare));
	}

	if (n)
	{
		ListView_SetItemCountEx(GetDlgItem(hwndDlg, IDC_LIST1), n, bFinal ? 0 : LVSICF_NOINVALIDATEALL);
	}
}

void SearchDlg::OnCaseSensetive(HWND hwndEdit, HWND hwndChk)
{
	ULONG NewStyle, Style = GetWindowLongW(hwndEdit, GWL_STYLE);

	switch (SendMessage(hwndChk, BM_GETCHECK, 0, 0))
	{
	case BST_CHECKED:
		NewStyle = Style & ~ES_UPPERCASE;
		break;
	case BST_UNCHECKED:
		NewStyle = Style | ES_UPPERCASE;
		break;
	default: return ;
	}

	if (NewStyle != Style)
	{
		SetWindowLongW(hwndEdit, GWL_STYLE, NewStyle);

		if (NewStyle & ES_UPPERCASE)
		{
			if (ULONG len = GetWindowTextLength(hwndEdit))
			{
				PWSTR sz = (PWSTR)alloca( (len + 1) * sizeof(WCHAR));
				GetWindowTextW(hwndEdit, sz, len + 1);
				SetWindowTextW(hwndEdit, sz);
			}
		}
	}
}

void SearchDlg::OnEncodingChanged(HWND hwndEdit, HWND hwndCombo, HWND hwndCheck)
{
	int Encoding = ComboBox_GetCurSel(hwndCombo), _Encoding = m_Encoding;

	if (_Encoding == Encoding)
	{
		return ;
	}

	m_Encoding = Encoding;

	if (Encoding == i_UTF8)
	{
		// for utf-8 only case sensetive search
		SendMessage(hwndCheck, BM_SETCHECK, BST_CHECKED, 0);
		EnableWindow(hwndCheck, FALSE);
		ULONG Style = GetWindowLongW(hwndEdit, GWL_STYLE);
		if (Style & ES_UPPERCASE)
		{
			SetWindowLongW(hwndEdit, GWL_STYLE, Style & ~ES_UPPERCASE);
		}
	}
	else
	{
		EnableWindow(hwndCheck, TRUE);
	}

	// for hex/dword search case no sense
	ShowWindow(hwndCheck, Encoding >= i_HEX ? SW_HIDE : SW_SHOW);

	ULONG len = GetWindowTextLengthW(hwndEdit);

	if (!len)
	{
		return ;
	}

	PWSTR sz = (PWSTR)alloca((len + 1)* sizeof(WCHAR)), wz = 0;
	GetWindowTextW(hwndEdit, sz, len + 1);

	PVOID pv = 0;
	ULONG cb = 0;
	UINT CodePage = 0;
	BOOL UsedDefaultChar = FALSE, *lpUsedDefaultChar = &UsedDefaultChar;

	if ((_Encoding == i_DWORD && Encoding != i_HEX) || 
		(Encoding == i_DWORD && _Encoding != i_HEX))
	{
		goto __set;
	}

	if (Encoding == i_HEX)
	{
		switch (_Encoding)
		{
		case i_ANSI:
			CodePage = CP_ACP;
			break;
		case i_OEM:
			CodePage = CP_OEMCP;
			break;
		case i_UTF8:
			CodePage = CP_UTF8;
			lpUsedDefaultChar = 0;
			break;
		case i_UTF16:
			pv = sz, cb = len * sizeof(WCHAR);
			goto __0;
		case i_DWORD:
			if (ULONG n = wcstoul(sz, &sz, 16))
			{
				if (!*sz)
				{
					pv = &n, cb = sizeof(n);
					goto __0;
				}
			}
			[[fallthrough]];
		default:
			return;
		}

		while ((cb = WideCharToMultiByte(CodePage, 0, sz, len, (PSTR)pv, cb, 0, lpUsedDefaultChar)) && !UsedDefaultChar)
		{
			if (pv)
			{
__0:
				sz = 0, len = 0;
				while (CryptBinaryToStringW((PBYTE)pv, cb, CRYPT_STRING_HEX|CRYPT_STRING_NOCRLF, sz, &len))
				{
					if (sz)
					{
						wz = sz;
						goto __set;
					}

					sz = (PWSTR)alloca(len* sizeof(WCHAR));
				}
			}

			pv = alloca(cb);
		}
	}
	else if (_Encoding == i_HEX)
	{
		while (CryptStringToBinaryW(sz, len, CRYPT_STRING_HEX, (PBYTE)pv, &cb, 0, 0))
		{
			if (pv)
			{
				sz = 0;

				switch (Encoding)
				{
				case i_ANSI:
					CodePage = CP_ACP;
					break;
				case i_OEM:
					CodePage = CP_OEMCP;
					break;
				case i_UTF8:
					CodePage = CP_UTF8;
					break;
				case i_UTF16:
					if (!(cb & (sizeof(WCHAR) - 1)))
					{
						len = cb / sizeof(WCHAR);
						sz = (PWSTR)pv;
						goto __1;
					}
					goto __set;
				case i_DWORD:
					if (cb == sizeof(ULONG))
					{
						wz = (PWSTR)alloca(9 * sizeof(WCHAR));
						_itow(*(ULONG*)pv, wz, 16);
					}
					goto __set;
				default: return;
				}

				while (len = MultiByteToWideChar(CodePage, MB_ERR_INVALID_CHARS, (PSTR)pv, cb, sz, len))
				{
					if (sz)
					{
__1:
						sz[len] = 0;
						wz = sz;
						goto __set;
					}

					sz = (PWSTR)alloca((len + 1) * sizeof(WCHAR));
				}

				break;
			}

			pv = alloca(cb + sizeof(WCHAR));
		}
	}
	else
	{
		return;
	}
__set:
	SetWindowTextW(hwndEdit, wz);
}

PWSTR SearchDlg::ReadData(HANDLE hFile, PLARGE_INTEGER ByteOffset, PBYTE pb, ULONG& cb, PWSTR pszText, ULONG& cchTextMax)
{
	IO_STATUS_BLOCK iosb;
	if (0 <= NtReadFile(hFile, 0, 0, 0, &iosb, pb, cb, ByteOffset, 0))
	{
		if (cb = (ULONG)iosb.Information)
		{
			ULONG cch = cchTextMax;
			if (CryptBinaryToStringW(pb, cb, CRYPT_STRING_HEX|CRYPT_STRING_NOCRLF, pszText, &cch))
			{
				cchTextMax -= cch;
				pszText += cch;
			}
			else
			{
				*pszText = 0;
			}
		}
	}

	return pszText;
}

void SearchDlg::SetInfoTip(PWSTR pszText, ULONG cchTextMax, SEARCH_RESULT *psr)
{
	LARGE_INTEGER ByteOffset;
	ByteOffset.QuadPart = psr->offset;

	NAME_COMPONENT* name = psr->name;

	if (ByteOffset.QuadPart < 0)
	{
		// this is folder
		_snwprintf(pszText, cchTextMax, L"%wZ", name->getCUS());
		return ;
	}

	ULONG cch = name->get_Length();
	PWSTR FilePath = (PWSTR)alloca((cch + 1) * sizeof(WCHAR));
	*name->Print(FilePath, cch) = 0;

	UNICODE_STRING ObjectName;

	if (RtlDosPathNameToNtPathName_U(FilePath, &ObjectName, 0, 0))
	{
		OBJECT_ATTRIBUTES oa = { sizeof(oa), 0, &ObjectName };
		HANDLE hFile;
		IO_STATUS_BLOCK iosb;

		NTSTATUS status = NtOpenFile(&hFile, FILE_READ_DATA|SYNCHRONIZE, &oa, &iosb,
			FILE_SHARE_VALID_FLAGS, FILE_SYNCHRONOUS_IO_ALERT|FILE_OPEN_FOR_BACKUP_INTENT);

		RtlFreeUnicodeString(&ObjectName);

		if (0 <= status)
		{
			BYTE buf1[8], buf2[8];
			ULONG cb1 = sizeof(buf1), cb2 = 0;
			if (ByteOffset.QuadPart < sizeof(buf1))
			{
				cb1 = ByteOffset.LowPart;
				ByteOffset.LowPart = 0;
			}
			else
			{
				ByteOffset.QuadPart -= sizeof(buf1);
			}

			if (cb1)
			{
				pszText = ReadData(hFile, &ByteOffset, buf1, cb1, pszText, cchTextMax);
			}

			if (3 < cchTextMax)
			{
				cb2 = sizeof(buf2);

				*pszText++ = ' ', *pszText++ = '*', *pszText++ = ' ', cchTextMax -= 3;

				ByteOffset.QuadPart = psr->offset + m_cbStr;

				pszText = ReadData(hFile, &ByteOffset, buf2, cb2, pszText, cchTextMax);
			}

			NtClose(hFile);

			if (RTL_NUMBER_OF(buf1) + RTL_NUMBER_OF(buf2) + 8 < cchTextMax)
			{
				*pszText++ = ' ', *pszText++ = '|', *pszText++ = ' ', cchTextMax -= 3;

				PWSTR psz = pszText;
				ULONG len = 0;
				ULONG cp = 0;

				switch (m_SearchEncoding)
				{
				case i_HEX:
					pszText[-3] = 0;
					return;

				case i_UTF16:
					memcpy(pszText, buf1, cb1);
					pszText += cb1 / sizeof(WCHAR);
					*pszText++ = ' ', *pszText++ = '*', *pszText++ = ' ';
					memcpy(pszText, buf2, cb2);
					len = cb1 / sizeof(WCHAR) + 3 + cb2 / sizeof(WCHAR);
					break;

				case i_ANSI:
					cp = CP_ACP;
					break;
				case i_UTF8:
					cp = CP_UTF8;
					break;
				case i_OEM:
					cp = CP_OEMCP;
					break;
				}

				if (!len)//m_SearchEncoding != i_UTF16
				{
					cch = MultiByteToWideChar(cp, 0, (PCCH)buf1, cb1, pszText, cchTextMax);
					pszText += cch, len += cch;

					if ((cchTextMax -= cch) > 3)
					{
						*pszText++ = ' ', *pszText++ = '*', *pszText++ = ' ', cchTextMax -= 3, len += 3;
						cch = MultiByteToWideChar(cp, 0, (PCCH)buf2, cb2, pszText, cchTextMax);
						pszText += cch, len += cch;
						cchTextMax -= cch;
					}
				}

				psz[len] = 0;

				if (len)
				{
					do 
					{
						if (*psz < ' ')
						{
							*psz = '.';
						}
					} while (psz++, --len);
				}
			}

		}
	}
}

INT_PTR SearchDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_USER+WM_QUIT:
		OnTask(hwndDlg, FALSE);
		ShowStatus(hwndDlg, (ULONG)wParam, TRUE);
		ShowLog(hwndDlg);
		break;

	case WM_DESTROY:
		if (m_hFont) DeleteObject(m_hFont);
		break;

	case WM_TIMER:
		if (m_bInSearch)
		{
			ShowStatus(hwndDlg, GetTickCount() - m_task.m_time, FALSE);
		}
		break;

	case WM_INITDIALOG:
		OnInitDialog(hwndDlg);
		break;

	case WM_COMMAND:
		switch (wParam)
		{
		case IDCANCEL:
			if (m_bInSearch)
			{
				m_task.Stop();
			}
			break;

		case IDOK:
			OnOk(hwndDlg);
			break;

		case MAKEWPARAM(IDC_BUTTON1, BN_CLICKED):
			PrintResults(hwndDlg);
			break;

		case MAKEWPARAM(IDC_COMBO1, CBN_SELCHANGE):
			OnEncodingChanged(GetDlgItem(hwndDlg, IDC_EDIT3), (HWND)lParam, GetDlgItem(hwndDlg, IDC_CHECK2));
			break;

		case MAKEWPARAM(IDC_CHECK2, BN_CLICKED):
			OnCaseSensetive(GetDlgItem(hwndDlg, IDC_EDIT3), (HWND)lParam);
			break;
		}
		break;

	case WM_CLOSE:
		if (m_bInSearch)
		{
			m_task.Stop();
		}
		else
		{
			EndDialog(hwndDlg, 1);
		}
		return TRUE;

	case WM_NOTIFY:

		if (((LPNMHDR)lParam)->idFrom == IDC_LIST1)
		{
			PWSTR pszText;
			SEARCH_RESULT *psr;
			ULONG cchTextMax, iItem, nItems = m_task.getResults(&psr);

			switch (((LPNMHDR)lParam)->code)
			{
			case LVN_GETINFOTIP:
				if (
					(cchTextMax = ((LPNMLVGETINFOTIP)lParam)->cchTextMax)
					&&
					(pszText = ((LPNMLVGETINFOTIP)lParam)->pszText)
					&&
					(iItem = ((LPNMLVGETINFOTIP)lParam)->iItem) < nItems
					)
				{
					SetInfoTip(pszText, cchTextMax, psr + iItem);
				}
				break;

			case LVN_GETDISPINFO:

				if (
					(((NMLVDISPINFO*)lParam)->item.mask & LVIF_TEXT) 
					&&
					(cchTextMax = ((NMLVDISPINFO*)lParam)->item.cchTextMax)
					&&
					(iItem = ((NMLVDISPINFO*)lParam)->item.iItem) < nItems
					)
				{			
					pszText = ((NMLVDISPINFO*)lParam)->item.pszText;

					pszText[0] = 0;

					psr += iItem;

					switch (((NMLVDISPINFO*)lParam)->item.iSubItem)
					{
					case 0:
						if (0 <= psr->offset)
						{
							_snwprintf(pszText, cchTextMax, L"%I64x", psr->offset);
						}
						break;
					case 1:
						*(pszText = psr->name->Print(pszText, --cchTextMax)) = 0;
						break;
					}
				}
			}
		}
		break;
	}
	return ZDlg::DialogProc(hwndDlg, uMsg, wParam, lParam);
}

void IoPostInit();

extern "C"
{
	extern PVOID __imp_CryptBinaryToStringW;

	BOOL ( WINAPI * orig_CryptBinaryToStringW)(
		__in       const BYTE* pbBinary,
		__in       DWORD cbBinary,
		__in       DWORD dwFlags,
		__out_opt  PWSTR pszString,
		__inout    DWORD* pcchString
		);
}

BOOL WINAPI XpCryptBinaryToStringW(
								__in       const BYTE* pbBinary,
								__in       DWORD cbBinary,
								__in       DWORD dwFlags,
								__out_opt  PWSTR pszString,
								__inout    DWORD* pcchString
								)
{
	if (dwFlags != (CRYPT_STRING_HEX|CRYPT_STRING_NOCRLF))
	{
		return orig_CryptBinaryToStringW(pbBinary, cbBinary, dwFlags, pszString, pcchString);
	}

	DWORD cchString = cbBinary ? cbBinary * 3 : 1;


	if (!pszString)
	{
		*pcchString = cchString;
		return TRUE;
	}

	if (*pcchString < cchString)
	{
		*pcchString = cchString;
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	if (cbBinary)
	{
		do 
		{
			pszString += swprintf(pszString, L"%02x", *pbBinary++);
			*pszString++ = ' ';
		} while (--cbBinary);
		--pszString;
	}

	*pszString = 0;
	*pcchString = cchString - 1;

	return TRUE;
}

#ifdef _X86_
#pragma comment(linker, "/alternatename:___imp_CryptBinaryToStringW=__imp__CryptBinaryToStringW@20")
#endif

void RedirectCryptBinaryToString()
{
	ULONG op;
	if (VirtualProtect(&__imp_CryptBinaryToStringW, sizeof(__imp_CryptBinaryToStringW), PAGE_READWRITE, &op))
	{
		*(void**)&orig_CryptBinaryToStringW = __imp_CryptBinaryToStringW;

		__imp_CryptBinaryToStringW = XpCryptBinaryToStringW;

		if (op != PAGE_READWRITE)
		{
			VirtualProtect(&__imp_CryptBinaryToStringW, sizeof(__imp_CryptBinaryToStringW), op, &op);
		}
	}
}

BOOL MyIsNameInExpression(PCWSTR Expression, PUNICODE_STRING Name);

void IO_RUNDOWN::RundownCompleted()
{
	CThreadPool::Stop();
	destroyterm();
	ExitProcess(0);
}

namespace CThreadPool {
	extern HANDLE m_hiocp;
};

void WINAPI ep(void*)
{
	ULONG M;
	RtlGetNtVersionNumbers(&M, 0, 0);
	if (M < 6)
	{
		RedirectCryptBinaryToString();
	}

	initterm();
	IoPostInit();
	CThreadPool::Start();

	BOOLEAN b;
	if (0 > RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &b))
	{
		MessageBoxW(0, L"Without this some files can be not opened.", L"Process have not Backup Privilege", MB_ICONWARNING|MB_OK);
	}

	if (SearchDlg* p = new SearchDlg)
	{
		p->DoModal((HINSTANCE)&__ImageBase, MAKEINTRESOURCE(IDD_DIALOG3), HWND_DESKTOP, 0);
		p->Release();
	}

	IO_RUNDOWN::g_IoRundown.BeginRundown();
}

_NT_END



```

`SRC/SearchEx.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"
#include "../inc/idcres.h"
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG3 DIALOGEX 0, 0, 482, 285
STYLE DS_SETFONT | DS_MODALFRAME | DS_3DLOOK | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Search File"
FONT 10, "Courier New", 400, 0, 0xCC
BEGIN
    EDITTEXT        IDC_EDIT1,45,7,166,14,ES_AUTOHSCROLL
    EDITTEXT        IDC_EDIT2,235,7,82,14,ES_UPPERCASE | ES_AUTOHSCROLL
    EDITTEXT        IDC_EDIT4,365,7,11,14,ES_NUMBER
    EDITTEXT        IDC_EDIT5,453,7,22,14,ES_NUMBER
    EDITTEXT        IDC_EDIT3,45,24,272,14,ES_AUTOHSCROLL
    CONTROL         "Cached I/O",IDC_CHECK1,"Button",BS_AUTOCHECKBOX | WS_GROUP | WS_TABSTOP,424,26,51,10
    PUSHBUTTON      "Stop",IDCANCEL,424,264,24,14,WS_DISABLED
    DEFPUSHBUTTON   "OK",IDOK,451,264,24,14
    LTEXT           "File Name",IDC_STATIC,7,9,32,8
    LTEXT           "Mask",IDC_STATIC,215,9,17,8
    LTEXT           "Search",IDC_STATIC,7,27,26,8
    LTEXT           "Max Files ",IDC_STATIC,322,10,38,8
    LTEXT           "Deep Level",IDC_STATIC,408,10,41,8
    LTEXT           "",IDC_STATIC1,7,267,182,8
    CONTROL         "",IDC_LIST1,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | LVS_OWNERDATA | WS_BORDER | WS_TABSTOP,7,42,468,217
    PUSHBUTTON      "Dump",IDC_BUTTON1,396,264,24,14,WS_DISABLED
    COMBOBOX        IDC_COMBO1,319,25,48,30,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    CONTROL         "Case-Sens",IDC_CHECK2,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,371,26,48,10
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO 
BEGIN
    IDD_DIALOG3, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 475
        TOPMARGIN, 7
        BOTTOMMARGIN, 278
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include ".rc2"
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`SRC/code32.asm`:

```asm
.686

_TEXT segment


@strnstr@16 proc
	jecxz @@3
	cmp ecx,[esp + 4]
	jb @@3
	push edi
	push esi
	push ebx
	push ebp
	mov ebx,[esp + 20]
	mov ebp,[esp + 24]
	mov edi,edx
	mov al,[ebp]
	inc ebp
	dec ebx
	sub ecx,ebx
@@1:
	repne scasb
	jne @@2
	mov esi,ebp
	mov edx,edi
	push ecx
	mov ecx,ebx
	test ecx,ecx
	repe cmpsb
	pop ecx
	je @@2
	mov edi,edx
	jmp @@1
@@2:
	sete al
	movzx eax,al
	neg eax
	and eax,edi
	pop ebp
	pop ebx
	pop esi
	pop edi
	ret 8
@@3:
	xor eax,eax
	ret 8
@strnstr@16 endp

@wtrnstr@16 proc
	jecxz @@3
	cmp ecx,[esp + 4]
	jb @@3
	push edi
	push esi
	push ebx
	push ebp
	mov ebx,[esp + 20]
	mov ebp,[esp + 24]
	mov edi,edx
	mov ax,[ebp]
	inc ebp
	inc ebp
	dec ebx
	sub ecx,ebx
@@1:
	repne scasw
	jne @@2
	mov esi,ebp
	mov edx,edi
	push ecx
	mov ecx,ebx
	test ecx,ecx
	repe cmpsw
	pop ecx
	je @@2
	mov edi,edx
	jmp @@1
@@2:
	sete al
	movzx eax,al
	neg eax
	and eax,edi
	pop ebp
	pop ebx
	pop esi
	pop edi
	ret 8
@@3:
	xor eax,eax
	ret 8
@wtrnstr@16 endp

_TEXT ends
end
```

`SRC/code64.asm`:

```asm
_TEXT segment 'CODE'

strnstr proc
	jrcxz @@3
	cmp rcx,r8
	jb @@3
	push rdi
	push rsi
	mov rdi,rdx
	mov al,[r9]
	inc r9
	dec r8
	sub rcx,r8
@@1:
	repne scasb
	jne @@2
	mov rsi,r9
	mov rdx,rdi
	mov r10,rcx
	mov rcx,r8
	test ecx,ecx
	repe cmpsb
	je @@2
	mov rcx,r10
	mov rdi,rdx
	jmp @@1
@@2:
	sete al
	movzx rax,al
	neg rax
	and rax,rdi
	pop rsi
	pop rdi
	ret
@@3:
	xor rax,rax
	ret
strnstr endp

wtrnstr proc
	jrcxz @@3
	cmp rcx,r8
	jb @@3
	push rdi
	push rsi
	mov rdi,rdx
	mov ax,[r9]
	inc r9
	inc r9
	dec r8
	sub rcx,r8
@@1:
	repne scasw
	jne @@2
	mov rsi,r9
	mov rdx,rdi
	mov r10,rcx
	mov rcx,r8
	test ecx,ecx
	repe cmpsw
	je @@2
	mov rcx,r10
	mov rdi,rdx
	jmp @@1
@@2:
	sete al
	movzx rax,al
	neg rax
	and rax,rdi
	pop rsi
	pop rdi
	ret
@@3:
	xor rax,rax
	ret
wtrnstr endp

_TEXT ENDS
END
```

`SRC/file.cpp`:

```cpp
#include "stdafx.h"

_NT_BEGIN

#include "task.h"
#include "file.h"
#include "../winZ/str.h"

void Upcase(UINT cp, PSTR buf, int cch, PWSTR wz)
{
	if (cch == MultiByteToWideChar(cp, 0, buf, cch, wz, cch))
	{
		LCMapStringW(LOCALE_NEUTRAL, LCMAP_UPPERCASE, wz, cch, wz, cch);

		WideCharToMultiByte(cp, 0, wz, cch, buf, cch, 0, 0);
	}
}

void LogError(Task* pTask, PCWSTR format, NAME_COMPONENT* name, NTSTATUS status)
{
	UNICODE_STRING us;
	ULONG len = name->get_Length();
	name->Print(us.Buffer = (PWSTR)alloca(us.MaximumLength = us.Length = (USHORT)len*sizeof(WCHAR)), len);
	len = 1 + _scwprintf(format, status, &us);
	if (PWSTR sz = (PWSTR)pTask->m_log.Allocate(len*sizeof(WCHAR), __alignof(WCHAR)))
	{
		swprintf(sz, format, status, &us);
		sz[len-1]='\n';
	}
}
//////////////////////////////////////////////////////////////////////////
// FileOfFolder

FileOfFolder::FileOfFolder(Task* pTask) : m_pTask(pTask)
{
	pTask->BeginTask();
	m_Name = 0;
}

FileOfFolder::~FileOfFolder()
{
	if (m_Name)
	{
		m_Name->Release();
	}
	m_pTask->EndTask();
}

NTSTATUS FileOfFolder::Open(POBJECT_ATTRIBUTES poa, NAME_COMPONENT* parent)
{
	if (m_pTask->Quit())
	{
		return STATUS_CANCELLED;
	}

	if (!(m_Name = new NAME_COMPONENT(parent)))
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	PUNICODE_STRING ObjectName = poa->ObjectName;

	if (!parent)
	{
		UNICODE_STRING us;
		RtlInitUnicodeString(ObjectName = &us, m_pTask->m_DosPath);
		if (*(PWSTR)RtlOffsetToPointer(us.Buffer, us.Length - sizeof(WCHAR)) == OBJ_NAME_PATH_SEPARATOR)
		{
			us.Length -= sizeof(WCHAR);
		}
	}

	NTSTATUS status = m_Name->Init(ObjectName);

	if (0 > status)
	{
		return status;
	}

	HANDLE hFile;
	IO_STATUS_BLOCK iosb;

	if (0 <= (status = NtOpenFile(&hFile, FILE_GENERIC_READ, poa, &iosb, 
		FILE_SHARE_VALID_FLAGS, m_pTask->get_OpenOptions())))
	{
		Assign(hFile);

		if (!(m_pTask->get_OpenOptions() & (FILE_SYNCHRONOUS_IO_NONALERT|FILE_SYNCHRONOUS_IO_ALERT)))
		{
			status = NT_IRP::RtlBindIoCompletion(hFile);			
		}
	}

	return status;
}

//////////////////////////////////////////////////////////////////////////
// File

File::File(Task* pTask) : FileOfFolder(pTask)
{
	m_ByteOffset.QuadPart = 0;
	pTask->NewFile();
}

File* File::CreateObject(Task* pTask, ULONGLONG FileSize)
{
	ULONG SectorSize = pTask->m_SectorSize;// this is really (byte_per_sector - 1)
	ULONG cbBuffer = FileSize > ChunkSize ? ChunkSize : (ULONG)FileSize;
	cbBuffer = (cbBuffer + SectorSize) & ~SectorSize;

	ULONG cbForUpcase = pTask->m_CaseSensetive || pTask->m_UnicodeSearch ? 0 : cbBuffer * sizeof(WCHAR);

	ULONG cbStr = pTask->m_cbStr - (pTask->m_UnicodeSearch ? sizeof(WCHAR) : sizeof(CHAR));
	ULONG_PTR AlignmentRequirement = pTask->m_AlignmentRequirement;

	if (File* p = new(cbStr + AlignmentRequirement + cbBuffer + cbForUpcase) File(pTask))
	{
		PBYTE pb = p->m_buf + cbStr;
		p->m_pbReadBuffer = (PBYTE)(((ULONG_PTR)pb + AlignmentRequirement) & ~AlignmentRequirement);
		p->m_cbChunk = cbBuffer;
		return p;
	}

	return 0;
}

void File::Read()
{
	if (m_pTask->Quit()) return ;

	if (NT_IRP* irp = new NT_IRP(this, 0, 0))
	{
		m_pTask->BeginIO();

		// not use LockHandle()/UnlockHandle() here because call Close() only from destructor - so m_hFile valid here
		irp->CheckNtStatus(NtReadFile(getHandleNoLock(), NULL, NULL, irp, 
			irp, m_pbReadBuffer, m_cbChunk, &m_ByteOffset, 0));
	}
}

void File::IOCompletionRoutine(CDataPacket* /*packet*/, DWORD /*Code*/, NTSTATUS status, ULONG_PTR dwNumberOfBytesTransfered, PVOID /*Pointer*/)
{
	Task* pTask = m_pTask;

	pTask->EndIO();

	if (0 > status)
	{
		if (status != STATUS_END_OF_FILE)
		{
			LogError(pTask, L"%x: ReadFile(%wZ)\r", getName(), status);
		}
	}
	else
	{
		OnRead(dwNumberOfBytesTransfered);
	}

	while (pTask->CheckSuspendedTasks()) ;
}

void File::OnRead(ULONG_PTR dwNumberOfBytesTransfered)
{
	Task* pTask = m_pTask;

	pTask->AddSize(dwNumberOfBytesTransfered);

	if (pTask->Quit()) return ;

	BOOLEAN UnicodeSearch = pTask->m_UnicodeSearch, CaseSensetive = pTask->m_CaseSensetive;

	ULONG cbStr = pTask->m_cbStr, cbStr_1 = cbStr - (UnicodeSearch ? sizeof(WCHAR) : sizeof(CHAR));
	const void* pbStr = pTask->m_pbStr;

	PBYTE pbReadBuffer = m_pbReadBuffer, pb = pbReadBuffer, pbEnd = pb + dwNumberOfBytesTransfered;

	NAME_COMPONENT* name = m_Name;
	LONGLONG ByteOffset = m_ByteOffset.QuadPart;

	if (ByteOffset)
	{
		pb -= cbStr_1;
	}

	if (UnicodeSearch)
	{
		if (!CaseSensetive)
		{
			LCMapStringW(LOCALE_NEUTRAL, LCMAP_UPPERCASE, 
				(PWSTR)pbReadBuffer, (ULONG)dwNumberOfBytesTransfered / sizeof(WCHAR),
				(PWSTR)pbReadBuffer, (ULONG)dwNumberOfBytesTransfered / sizeof(WCHAR));
		}

		while (pb = (PBYTE)wtrnstr((pbEnd - pb) / sizeof(WCHAR), pb, cbStr / sizeof(WCHAR), pbStr))
		{
			pTask->AddSearchResult(name, ByteOffset + (pb - pbReadBuffer) - cbStr);

			if (pTask->Quit()) return ;
		}
	}
	else
	{
		if (!CaseSensetive)
		{
			Upcase(pTask->m_CodePage, (PSTR)pbReadBuffer, (ULONG)dwNumberOfBytesTransfered, 
				(PWSTR)RtlOffsetToPointer(pbReadBuffer, dwNumberOfBytesTransfered));
		}

		while (pb = (PBYTE)strnstr(pbEnd - pb, pb, cbStr, pbStr))
		{
			pTask->AddSearchResult(name, ByteOffset + (pb - pbReadBuffer) - cbStr);

			if (pTask->Quit()) return ;
		}
	}

	if (dwNumberOfBytesTransfered < m_cbChunk)
	{
		// end of file
		return ;
	}

	if (cbStr_1) memcpy(pbReadBuffer - cbStr_1, pbEnd - cbStr_1, cbStr_1);

	m_ByteOffset.QuadPart += m_cbChunk;

	Read();
}

//////////////////////////////////////////////////////////////////////////
// Folder
BLOCK_HEAP Folder::s_bh;

void IoPostInit()
{
	NT_IRP::_init(128);
	Folder::_init(128);
}

void Folder::Query()
{
	if (m_pTask->Quit()) return;

	if (NT_IRP* irp = new NT_IRP(this, 0, 0))
	{
		m_pTask->BeginIO();

		// not use LockHandle()/UnlockHandle() here because call Close() only from destructor - so m_hFile valid here
		irp->CheckNtStatus(NtQueryDirectoryFile(getHandleNoLock(), NULL, NULL, irp, irp, 
			m_buf, sizeof(m_buf), FileDirectoryInformation, FALSE, NULL, FALSE));
	}
}

void Folder::ProcessFile(Task* pTask, POBJECT_ATTRIBUTES poa, NAME_COMPONENT* parent, ULONGLONG FileSize)
{
	ULONG cbStr = pTask->get_cb_Str();

	if (FileSize >= cbStr && pTask->IsFileInMask(poa->ObjectName))
	{
		if (cbStr)
		{
			if (File* pFile = File::CreateObject(pTask, FileSize))
			{
				NTSTATUS status = pFile->Open(poa, parent);
				if (0 <= status)
				{
					pFile->Read();
				}
				else
				{
					LogError(pTask, L"%x: Open(%wZ)\r", pFile->getName(), status);
				}
				pFile->Release();
			}
		}
		else
		{
			// we search file by mask only. no scan it content

			if (NAME_COMPONENT* Name = new NAME_COMPONENT(parent))
			{
				if (0 <= Name->Init(poa->ObjectName))
				{
					pTask->AddSearchResult(Name);
					Name->Release();
				}
			}
		}
	}
}

void Folder::ProcessFolder(Task* pTask, POBJECT_ATTRIBUTES poa, NAME_COMPONENT* Name, int nLevel)
{
	if (!pTask->IsLevelOk(nLevel))
	{
		return ;
	}

	pTask->NewFolder();

	NTSTATUS status;

	if (Folder* pFolder = new Folder(pTask, nLevel))
	{
		if (0 <= (status = pFolder->Open(poa, Name)))
		{
			pFolder->Query();
		}
		else
		{
			LogError(pTask, L"%x: Open(%wZ)\r", pFolder->getName(), status);
		}
		pFolder->Release();
	}
}

void Folder::IOCompletionRoutine(CDataPacket* /*packet*/, DWORD /*Code*/, NTSTATUS status, ULONG_PTR /*dwNumberOfBytesTransfered*/, PVOID /*Pointer*/)
{
	Task* pTask = m_pTask;
	
	pTask->EndIO();

	if (0 > status)
	{
		switch (status)
		{
		case STATUS_NO_SUCH_FILE:
		case STATUS_NO_MORE_FILES:
			break;
		default:
			LogError(pTask, L"%x: QueryDirectory(%wZ)\r", getName(), status);
		}
	}
	else
	{
		m_pfdi = &m_fdi;

		Process();
	}

	while (pTask->CheckSuspendedTasks()) ;
}

void Folder::Process()
{
	Task* pTask = m_pTask;

	union {
		PBYTE pb;
		PFILE_DIRECTORY_INFORMATION DirInfo;
	};

	if (DirInfo = m_pfdi)
	{
		ULONG NextEntryOffset = 0;

		UNICODE_STRING ObjectName;
		OBJECT_ATTRIBUTES oa = { sizeof(oa), getHandleNoLock(), &ObjectName };

		int level = m_nLevel + 1;

		do 
		{
			if (pTask->Quit()) return;

			pb += NextEntryOffset;

			m_pfdi = DirInfo;

			if (pTask->PauseFolder(this))
			{
				return ;
			}

			ObjectName.Buffer = DirInfo->FileName;

			switch (ObjectName.Length = (USHORT)DirInfo->FileNameLength)
			{
			case 2*sizeof(WCHAR):
				if (ObjectName.Buffer[1] != '.') break;
			case sizeof(WCHAR):
				if (ObjectName.Buffer[0] == '.') continue;
			}

			ObjectName.MaximumLength = ObjectName.Length;

			if (DirInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				ProcessFolder(pTask, &oa, m_Name, level);
			}
			else
			{
				ProcessFile(pTask, &oa, m_Name, DirInfo->EndOfFile.QuadPart);
			}

		} while (NextEntryOffset = DirInfo->NextEntryOffset);

		m_pfdi = 0;
	}

	if (!pTask->PauseFolder(this))
	{
		Query();
	}
}

_NT_END
```

`SRC/file.h`:

```h
#pragma once

#include "../asio/io.h"

class Task;
class NAME_COMPONENT;

class __declspec(novtable) FileOfFolder : public IO_OBJECT
{
protected:

	Task* m_pTask;
	NAME_COMPONENT* m_Name;

	FileOfFolder(Task* pTask);

	virtual ~FileOfFolder();

public:

	NTSTATUS Open(POBJECT_ATTRIBUTES poa, NAME_COMPONENT* parent);

	NAME_COMPONENT* getName()
	{
		return m_Name;
	}
};

class File : public FileOfFolder
{
	enum { ChunkSize = 0x10000 };//64kb

	LARGE_INTEGER m_ByteOffset;
	PBYTE m_pbReadBuffer;
	ULONG m_cbChunk;
	UCHAR m_buf[];

	File(Task* pTask);

	void* operator new(size_t cb, size_t cbBuf)
	{
		return IO_OBJECT::operator new(cb + cbBuf);
	}

	void OnRead(ULONG_PTR dwNumberOfBytesTransfered);
public:

	static File* CreateObject(Task* pTask, ULONGLONG FileSize);

	void Read();

	virtual void IOCompletionRoutine(CDataPacket* /*packet*/, DWORD /*Code*/, NTSTATUS status, ULONG_PTR dwNumberOfBytesTransfered, PVOID /*Pointer*/);
};

class Folder : public FileOfFolder, SLIST_ENTRY
{
	friend class Task;

	static BLOCK_HEAP s_bh;

	FILE_DIRECTORY_INFORMATION* m_pfdi;
	ULONG m_nLevel;
	union {
		FILE_DIRECTORY_INFORMATION m_fdi;
		UCHAR m_buf[0x10000];// must be aligned as FILE_DIRECTORY_INFORMATION
	};

	virtual void IOCompletionRoutine(CDataPacket* packet, DWORD Code, NTSTATUS status, ULONG_PTR dwNumberOfBytesTransfered, PVOID Pointer);

	void Process();

	void Query();

public:
	void operator delete(PVOID p)
	{
		s_bh.IsBlock(p) ? s_bh.free(p) : ::operator delete(p);
	}

	Folder(Task* pTask, ULONG nLevel) : FileOfFolder(pTask), m_nLevel(nLevel)
	{
	}

	void* operator new(size_t size)
	{
		PVOID p = size == sizeof(Folder) ? s_bh.alloc() : 0;
		return p ? p : p = ::operator new(size);
	}

	static BOOL _init(DWORD count)
	{
		return s_bh.Create(sizeof(Folder), count);
	}

	static void ProcessFolder(Task* pTask, POBJECT_ATTRIBUTES poa, NAME_COMPONENT* Name, int nLevel);
	static void ProcessFile(Task* pTask, POBJECT_ATTRIBUTES poa, NAME_COMPONENT* Name, ULONGLONG FileSize);
};
```

`SRC/lineheap.cpp`:

```cpp
#include "StdAfx.h"

_NT_BEGIN

#include "lineheap.h"

void LineHeap::Reset()
{
	if (m_commit > chunkSize)
	{
		PVOID BaseAddress = (PBYTE)_BaseAddress + chunkSize;
		SIZE_T RegionSize = m_commit - chunkSize;
		if (0 > NtFreeVirtualMemory(NtCurrentProcess(), &BaseAddress, &RegionSize, MEM_DECOMMIT))
		{
			__debugbreak();
		}
		m_commit = chunkSize;
	}
	m_allocated = 0;
}

PVOID LineHeap::Allocate(SIZE_T cb, SIZE_T align)
{
	if (align & (align - 1))
	{
		return 0;
	}

	--align;

	SIZE_T allocated = m_allocated, new_allocated, newValue, ofs, commit;

	for (;;)
	{
		ofs = (allocated + align) & ~align;

		new_allocated = ofs + cb;

		if (new_allocated  > m_reserved)
		{
			return 0;
		}

		newValue = (SIZE_T)InterlockedCompareExchangePointer((void**)&m_allocated, (void*)new_allocated, (void*)allocated);

		if (newValue == allocated)
		{
			break;
		}

		allocated = newValue;
	}

	if (new_allocated > (commit = m_commit))
	{
		PVOID BaseAddress = (PBYTE)_BaseAddress + commit;

		new_allocated = (new_allocated + (chunkSize-1)) & ~(chunkSize-1);

		newValue = new_allocated - commit;

		if (0 > NtAllocateVirtualMemory(NtCurrentProcess(), &BaseAddress, 0, &newValue, MEM_COMMIT, PAGE_EXECUTE_READWRITE))
		{
			return 0;
		}

		do 
		{
			newValue = (SIZE_T)InterlockedCompareExchangePointer((void**)&m_commit, (void*)new_allocated, (void*)commit);

		} while (newValue != commit && new_allocated > (commit = newValue));
	}

	return (PBYTE)_BaseAddress + ofs;
}

_NT_END
```

`SRC/lineheap.h`:

```h
#pragma once

class LineHeap 
{
	PVOID _BaseAddress;
	SIZE_T m_reserved, m_commit, m_allocated;

	enum { chunkSize = 0x10000 /*64kb*/};
public:

	PVOID getBase()
	{
		return _BaseAddress;
	}

	SIZE_T getSize()
	{
		return m_allocated;
	}

	void Reset();

	LineHeap()
	{
		_BaseAddress = 0, m_commit = 0, m_allocated = 0;
	}

	~LineHeap()
	{
		if (_BaseAddress)
		{
			SIZE_T RegionSize = 0;
			NtFreeVirtualMemory(NtCurrentProcess(), &_BaseAddress, &RegionSize, MEM_RELEASE);
		}
	}

	NTSTATUS Create(SIZE_T reserved)
	{
		return NtAllocateVirtualMemory(NtCurrentProcess(), &_BaseAddress, 0, 
			&(m_reserved = (reserved + (chunkSize-1)) & ~(chunkSize-1)), MEM_RESERVE, PAGE_READWRITE);
	}

	PVOID Allocate(SIZE_T cb, SIZE_T align = __alignof(PVOID));
};

```

`SRC/mask.cpp`:

```cpp
#include "StdAfx.h"

_NT_BEGIN

#include "mask.h"

BOOL IsNameInExpression(PCWSTR Expression, PCWSTR Name, SIZE_T len)
{
__begin:

	switch (WCHAR c = *Expression++)
	{
	default:
		if (!len-- || c != *Name++)
		{
			return FALSE;
		}
		goto __begin;

	case '?':
		if (!len--)
		{
			return FALSE;
		}
		Name++;
		goto __begin;

	case 0:
		return !len;

	case '*':
__loop:
		switch (c = *Expression++)
		{
		case '?':
			if (!len--)
			{
				return FALSE;
			}
			Name++;
		case '*':
			goto __loop;
		case 0:
			return TRUE;
		}

		// c ## Expression where c not in { '*', '?' }

		// c must be in Name
		if (!len)
		{
			return FALSE;
		}

		ULONG k = 0;

		PCWSTR pc = Expression;

		BOOLEAN bExistQuestion = FALSE;

		for (;;)
		{
			switch (++k, *pc++)
			{
			case '?':
				bExistQuestion = TRUE;
				continue;

			case '*':
				// Name = * ## c ## Expression
				do 
				{
					if (c != (--len, *Name++))
					{
						continue;
					}

					if (IsNameInExpression(Expression, Name, len)) return TRUE;

				} while (len);

				return FALSE;

			case 0:
				// no more '*' in Expression
				if (len < k)
				{
					return FALSE;
				}

				Name += len - k, len = k;

				if (*Name++ != c)
				{
					return FALSE;
				}

				if (!--len)
				{
					return TRUE;
				}

				if (!bExistQuestion)
				{
					return !memcmp(Expression, Name, len * sizeof(WCHAR));
				}
				goto __begin;
			}
		}

		break;
	}
}

BOOL MyIsNameInExpression(PCWSTR Expression, PUNICODE_STRING Name)
{
	RtlUpcaseUnicodeString(Name, Name, FALSE);
	return IsNameInExpression(Expression, Name->Buffer, Name->Length / sizeof(WCHAR) );
}

BOOLEAN FILE_MASK::IsNameInExpression(PUNICODE_STRING Name)
{
	RtlUpcaseUnicodeString(Name, Name, FALSE);
	return MyIsNameInExpression(_Expression, Name) ? TRUE : _next ? _next->IsNameInExpression(Name) : FALSE;
}

void FILE_MASK::free(FILE_MASK* next)
{
	if (next)
	{
		free(next->_next);
		delete next;
	}
}

NTSTATUS FILE_MASK::Create(PWSTR psz, FILE_MASK** first)
{
	*first = 0;

	if (!psz)
	{
		return STATUS_SUCCESS;
	}

	FILE_MASK* next = 0;

	// psz = mask:[mask:]
	while (PWSTR c = wcschr(psz, ':'))
	{
		*c = 0;
		if (FILE_MASK* p = new FILE_MASK(psz, next))
		{
			next = p;
			psz = c + 1;
		}
		else
		{
			if (next)
			{
				delete next;
			}
			return STATUS_INSUFFICIENT_RESOURCES;
		}
	}

	*first = next;
	return STATUS_SUCCESS;
}

_NT_END
```

`SRC/mask.h`:

```h
#pragma once

class FILE_MASK
{
	FILE_MASK* _next;
	PCWSTR _Expression;

	FILE_MASK(PWSTR Expression, FILE_MASK* next)
	{
		_Expression = Expression, _next = next;
	}

	~FILE_MASK()
	{
	}

public:

	BOOLEAN IsNameInExpression(PUNICODE_STRING Name);

	static NTSTATUS Create(PWSTR psz, FILE_MASK** first);

	static void free(FILE_MASK* next);
};

```

`SRC/name component.cpp`:

```cpp
#include "StdAfx.h"

_NT_BEGIN

#include "name component.h"

NAME_COMPONENT::NAME_COMPONENT(NAME_COMPONENT* parent) : _parent(parent)
{
	RtlZeroMemory(static_cast<PUNICODE_STRING>(this), sizeof(UNICODE_STRING));
	_dwRef = 1;
	_Level = 0;
	if (parent)
	{
		parent->AddRef();
		_Level = parent->_Level + 1;
	}
}

NAME_COMPONENT::~NAME_COMPONENT()
{
	RtlFreeUnicodeString(this);
	if (_parent)
	{
		_parent->Release();
	}
}

PWSTR NAME_COMPONENT::Print(PWSTR buf, ULONG& cb)
{
	if (_parent)
	{
		buf = _parent->Print(buf, cb);

		if (cb)
		{
			*buf++ = '\\', cb--;
		}
	}

	ULONG cch = Length / sizeof(WCHAR);

	if (cb >= cch)
	{
		memcpy(buf, Buffer, Length), buf += cch, cb -= cch;
	}
	else
	{
		cb = 0;
	}

	return buf;
}

ULONG NAME_COMPONENT::get_Length()
{
	ULONG cb = Length / sizeof(WCHAR);

	if (_parent)
	{
		cb += 1 + _parent->get_Length();
	}

	return cb;
}

int NAME_COMPONENT::compare(NAME_COMPONENT* p, NAME_COMPONENT* q)
{
	if (p == q)
	{
		return 0;
	}

	int i = q->_Level - p->_Level;

	if (i < 0)
	{
		do 
		{
			p = p->_parent;
		} while (++i);
	}
	else if (i > 0)
	{
		do 
		{
			q = q->_parent;
		} while (--i);
	}

	while (p->_parent != q->_parent)
	{
		p = p->_parent, q = q->_parent;
	}

	if (int j = RtlCompareUnicodeString(p, q, TRUE))
	{
		return j;
	}

	return i;
}

int __cdecl SEARCH_RESULT::compare(SEARCH_RESULT* p, SEARCH_RESULT* q)
{
	if (int i = NAME_COMPONENT::compare(p->name, q->name))
	{
		return i;
	}

	if (p->offset < q->offset) return -1;
	if (p->offset > q->offset) return +1;
	return 0;
}

_NT_END
```

`SRC/name component.h`:

```h
#pragma once

class NAME_COMPONENT : UNICODE_STRING 
{
	NAME_COMPONENT* _parent;
	LONG _dwRef;
	ULONG _Level;

	~NAME_COMPONENT();

public:

	NAME_COMPONENT(NAME_COMPONENT* parent);

	NTSTATUS Init(PCUNICODE_STRING Str)
	{
		return RtlDuplicateUnicodeString(0, Str, this);
	}

	void Release()
	{
		if (!InterlockedDecrement(&_dwRef))
		{
			delete this;
		}
	}

	void AddRef()
	{
		InterlockedIncrement(&_dwRef);
	}

	PWSTR Print(PWSTR buf, ULONG& cb);

	ULONG get_Length();

	PCUNICODE_STRING getCUS()
	{
		return this;
	}

	static int compare(NAME_COMPONENT* p, NAME_COMPONENT* q);
};

struct SEARCH_RESULT 
{
	LONGLONG offset;//-1 if we search files by mask only
	NAME_COMPONENT* name;

	static int __cdecl compare(SEARCH_RESULT* p, SEARCH_RESULT* q);
};

```

`SRC/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SearchEx.rc
//
#define IDD_DIALOG3                     140
#define IDC_LIST1                       10201
#define IDC_STATIC1                     10301
#define IDC_CHECK1                      10501
#define IDC_CHECK2                      10502
#define IDC_COMBO1                      10601
#define IDC_EDIT1                       10701
#define IDC_EDIT2                       10702
#define IDC_EDIT3                       10703
#define IDC_EDIT4                       10704
#define IDC_EDIT5                       10705
#define IDC_BUTTON1                     10801

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`SRC/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// SearchEx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
```

`SRC/stdafx.h`:

```h
#include "../inc/StdAfx.h"

#include <intrin.h>
#include <WINDOWSX.H>
#include <commctrl.h>
#include <uxtheme.h>

```

`SRC/task.cpp`:

```cpp
#include "StdAfx.h"

_NT_BEGIN

#include "task.h"
#include "file.h"

extern volatile UCHAR guz;

void Task::FreeResults()
{
	if (QueryDepthSList(&m_head) || m_IoCount)
	{
		__debugbreak();
	}

	if (ULONG n = m_nResults)
	{
		SEARCH_RESULT* psr = (SEARCH_RESULT*)m_srh.getBase();
		do 
		{
			psr++->name->Release();
		} while (--n);

		m_nResults = 0;
	}

	if (m_pbStr)
	{
		delete [] m_pbStr;
		m_pbStr = 0;
	}

	FILE_MASK::free(m_fm), m_fm = 0;

	RtlFreeUnicodeString(&m_mask);

}

void Task::Reset()
{
	FreeResults();

	m_srh.Reset(), m_log.Reset();

	m_bStop = FALSE;
	m_nFiles = 0, m_nFolders = 0;
	m_TotalSize = 0;
	m_MaxTasks = 0, m_PeakIoCount = 0;
	m_AlignmentRequirement = 0, m_SectorSize = 0;
}

NTSTATUS Task::Create(HWND hwnd, SIZE_T SearchSize, SIZE_T LogSize)
{
	m_hwnd = hwnd;

	NTSTATUS status;

	0 <= (status = m_srh.Create(SearchSize)) && 0 <= (status = m_log.Create(LogSize));

	return status;
}

void Task::AddSearchResult(NAME_COMPONENT* name, LONGLONG offset)
{
	if (SEARCH_RESULT* psr = (SEARCH_RESULT*)m_srh.Allocate(sizeof(SEARCH_RESULT), __alignof(SEARCH_RESULT)))
	{
		psr->name = name;
		psr->offset = offset;
		name->AddRef();
		InterlockedIncrement(&m_nResults);
	}
}

BOOL Task::PauseFolder(Folder* p)
{
	if (m_IoCount >= m_MaxIoCount)
	{
		p->AddRef();
		InterlockedPushEntrySList(&m_head, p);

		return TRUE;
	}

	return FALSE;
}

BOOL Task::ResumeFolder()
{
	if (Folder* p = static_cast<Folder*>(InterlockedPopEntrySList(&m_head)))
	{
		p->Process();
		p->Release();
		return TRUE;
	}
	return FALSE;
}

NTSTATUS Task::Start(PCWSTR DosPath, PWSTR mask, const void* pbStr, ULONG cbStr, 
					 ULONG MaxIoCount, ULONG maxLevel, BOOLEAN CachedIO, 
					 BOOLEAN UnicodeSearch, BOOLEAN CaseSensetive, ULONG CodePage)
{
	if ( ((cbStr != 0) ^ (pbStr != 0)) || (UnicodeSearch && (!cbStr || (cbStr & (sizeof(WCHAR) - 1)))) )
	{
		return STATUS_INVALID_PARAMETER_MIX;
	}

	if (InterlockedCompareExchange(&m_nTasks, 1, 0) == 0)
	{
		Reset();

		m_UnicodeSearch = UnicodeSearch, m_CaseSensetive = CaseSensetive, m_CodePage = CodePage;
		m_MaxIoCount = MaxIoCount, m_maxLevel = maxLevel;

		NTSTATUS status = _Start(DosPath, mask, pbStr, cbStr, CachedIO);

		if (0 > status)
		{
			FreeResults();
		}

		EndTask();

		return status;
	}

	return STATUS_INVALID_DEVICE_STATE;
}

NTSTATUS Task::_Start(PCWSTR DosPath, PWSTR mask, const void* pbStr, ULONG cbStr, BOOLEAN CachedIO)
{
	NTSTATUS status;

	if (mask)
	{
		if (!RtlCreateUnicodeString(&m_mask, mask))
		{
			return STATUS_NAME_TOO_LONG;
		}

		RtlUpcaseUnicodeString(&m_mask, &m_mask, FALSE);
		
		if (0 > (status = FILE_MASK::Create(m_mask.Buffer, &m_fm)))
		{
			return status;
		}
	}

	if (pbStr)
	{
		if (m_pbStr = new char[cbStr])
		{
			memcpy(m_pbStr, pbStr, cbStr);
			m_cbStr = cbStr;
		}
		else
		{
			return STATUS_INSUFFICIENT_RESOURCES;
		}
	}
	else
	{
		m_cbStr = 0, m_pbStr = 0;
	}

	UNICODE_STRING ObjectName;
	OBJECT_ATTRIBUTES oa = { sizeof(oa), 0, &ObjectName };

	if (!RtlDosPathNameToNtPathName_U(DosPath, &ObjectName, 0, 0))
	{
		return STATUS_INVALID_PARAMETER_1;
	}

	m_DosPath = DosPath;

	m_time = GetTickCount();

	HANDLE hFile;
	IO_STATUS_BLOCK iosb;

	status = NtOpenFile(&hFile, FILE_GENERIC_READ, &oa, &iosb, FILE_SHARE_VALID_FLAGS, 
		FILE_OPEN_FOR_BACKUP_INTENT|FILE_SEQUENTIAL_ONLY|FILE_OPEN_REPARSE_POINT);

	if (0 <= status)
	{
		union {
			FILE_ALIGNMENT_INFORMATION fai;
			FILE_ATTRIBUTE_TAG_INFORMATION fati;
			FILE_FS_SIZE_INFORMATION ffsi;
		};

		if (!CachedIO)
		{
			if (0 > NtQueryVolumeInformationFile(hFile, &iosb, &ffsi, sizeof(ffsi), FileFsSizeInformation) ||
				(((ffsi.BytesPerSector - 1) & ffsi.BytesPerSector)) ||
				ffsi.BytesPerSector > 0x10000)
			{
				CachedIO = TRUE;
			}
			else
			{
				m_SectorSize = ffsi.BytesPerSector - 1;

				if (0 > NtQueryInformationFile(hFile, &iosb, &fai, sizeof(fai), FileAlignmentInformation) ||
					(fai.AlignmentRequirement & (fai.AlignmentRequirement + 1)) ||
					fai.AlignmentRequirement > FILE_512_BYTE_ALIGNMENT)
				{
					m_SectorSize = 0;
					CachedIO = TRUE;
				}
				else
				{
					m_AlignmentRequirement = fai.AlignmentRequirement;
				}
			}
		}

		status = NtQueryInformationFile(hFile, &iosb, &fati, sizeof(fati), FileAttributeTagInformation);

		NtClose(hFile);

		if (0 <= status)
		{
			status = STATUS_PENDING;

			m_OpenOptions = CachedIO 
				? FILE_OPEN_FOR_BACKUP_INTENT|FILE_SEQUENTIAL_ONLY|FILE_OPEN_REPARSE_POINT
				: FILE_OPEN_FOR_BACKUP_INTENT|FILE_SEQUENTIAL_ONLY|FILE_OPEN_REPARSE_POINT|FILE_NO_INTERMEDIATE_BUFFERING;

			if (fati.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				Folder::ProcessFolder(this, &oa, 0, 0);
			}
			else
			{
				Folder::ProcessFile(this, &oa, 0, 0x10000);
			}
		}
	}

	RtlFreeUnicodeString(&ObjectName);

	return status;
}

_NT_END
```

`SRC/task.h`:

```h
#pragma once

#include "name component.h"
#include "mask.h"
#include "lineheap.h"

class Folder;

class Task
{
public:
	SLIST_HEADER m_head;
	LineHeap m_srh, m_log;
	UNICODE_STRING m_mask;
	LONGLONG m_TotalSize;
	
	PCWSTR m_DosPath;//temp!
	HWND m_hwnd;

	FILE_MASK* m_fm;
	void* m_pbStr;
	ULONG m_cbStr;

	ULONG m_AlignmentRequirement;
	ULONG m_SectorSize;
	ULONG m_maxLevel;
	LONG m_nFolders, m_nFiles;
	ULONG m_OpenOptions;
	ULONG m_time;
	LONG m_nTasks, m_MaxTasks;
	LONG m_MaxIoCount, m_IoCount, m_PeakIoCount;
	LONG m_nResults;
	ULONG m_CodePage;
	BOOLEAN m_bStop, m_UnicodeSearch, m_CaseSensetive;

	NTSTATUS _Start(PCWSTR DosPath, PWSTR mask, const void* pbStr, ULONG cbStr, BOOLEAN CachedIO);

	void BeginIO()
	{
		ULONG IoCount = InterlockedIncrement(&m_IoCount), PeakIoCount = m_PeakIoCount;
		if (PeakIoCount < IoCount)
		{
			InterlockedCompareExchange(&m_PeakIoCount, IoCount, PeakIoCount);
		}
	}

	void EndIO()
	{
		InterlockedDecrement(&m_IoCount);
	}

	BOOL CheckSuspendedTasks()
	{
		if (m_IoCount < m_MaxIoCount)
		{
			return ResumeFolder();
		}
		return FALSE;
	}

	void FreeResults();

	void Reset();

	BOOL PauseFolder(Folder* p);

	BOOL ResumeFolder();

	void BeginTask()
	{
		ULONG Tasks = InterlockedIncrement(&m_nTasks), MaxTasks = m_MaxTasks;

		if (MaxTasks < Tasks)
		{
			InterlockedCompareExchange(&m_MaxTasks, Tasks, MaxTasks);
		}
	}

	void EndTask()
	{
		if (!InterlockedDecrement(&m_nTasks))
		{
			PostMessage(m_hwnd, WM_USER+WM_QUIT, GetTickCount() - m_time, 0);
		}
	}

	void NewFolder()
	{
		InterlockedIncrement(&m_nFolders);
	}

	void NewFile()
	{
		InterlockedIncrement(&m_nFiles);
	}

	void AddSize(ULONGLONG Size)
	{
		InterlockedExchangeAdd64(&m_TotalSize, Size);
	}

	void AddSearchResult(NAME_COMPONENT* name, LONGLONG offset = -1);

	~Task()
	{
		FreeResults();
	}

	Task()
	{
		m_nTasks = 0, m_nResults = 0, m_fm = 0, m_pbStr = 0, m_mask = {}, m_IoCount = 0;
		InitializeSListHead(&m_head);
		Reset();
	}

	BOOL IsLevelOk(ULONG maxLevel)
	{
		return maxLevel < m_maxLevel;
	}

	NTSTATUS Create(HWND hwnd, SIZE_T SearchSize, SIZE_T LogSize);

	BOOLEAN Quit()
	{
		return m_bStop;
	}

	ULONG get_OpenOptions()
	{
		return m_OpenOptions;
	}

	ULONG get_cb_Str()
	{
		return m_cbStr;
	}

	LPCVOID get_Str()
	{
		return m_pbStr;
	}

	ULONG getResults(SEARCH_RESULT** ppsr)
	{
		*ppsr = (SEARCH_RESULT*)m_srh.getBase();
		return m_nResults;
	}

	NTSTATUS Start(PCWSTR DosPath, PWSTR mask, const void* pbStr, ULONG cbStr, 
		ULONG MaxIoCount, ULONG maxLevel, BOOLEAN CachedIO, BOOLEAN UnicodeSearch, BOOLEAN CaseSensetive, ULONG CodePage);

	void Stop()
	{
		m_bStop = TRUE;
	}

	BOOLEAN IsFileInMask(PUNICODE_STRING Name)
	{
		return m_fm ? m_fm->IsNameInExpression(Name) : TRUE;
	}
};

```

`readme.txt`:

```txt
1. file or folder from which begin search
2. N file search masks (* and ? wild cards) (separated with `:` symbol) - empty or `*` for search in all files
3. deep search level - 0 for infinite deep (all levels), 1 - we search only in current folder, 2 - folder and direct child subfolders. and so on
4. i not follow symlinks/reparse point during search
5. user can select use cached or non-cached io
6. search string - up to 256 symbols (or 85 raw hex bytes)
7. string can be in ansi, oem, utf-8, utf-16 encoding or raw hex bytes
8. for ansi, oem, and utf-16 we can search case sensetive or insesetive (more slow and more memory used)
9. for utf-16 i assume that string have 2*n offset from file begin (which is true for pe and plain text files)
10. for utf-8 only case sensetive search (try upcase from every position in file will be too slow)
11. for raw bytes hex search case of course have no sense
12. user can select maximum concurrent io requests count (by default 32).

i use only asynchronous io - for both enumerate folders via NtQueryDirectoryFile which support asynchronous io unlike pitiful FindFirstFileEx shell. and for Read file. so after begin io operation - i never wait in place when it finished, but continue execution (in case folder continue walk through FILE_DIRECTORY_INFORMATION entries). so instead creating several threads for synchronous enumerate folders/scan files synchronously (sure you wait this) - i implement much more power asynchronous solution. and we select here not thread count but simultaneous io requests count. during process folder (enumerate child FILE_DIRECTORY_INFORMATION entries i check current io count and if it exceeds limit - i stop enumeration and push Folder object to queue (Task::PauseFolder). later, when some io finished and simultaneous io count down - i check this queue and resume enumaration for folder Task::CheckSuspendedTasks -> Task::ResumeFolder - called from file and folder completion end.

i test only on NVMe disks where i got the best result with ~16-32 simultaneous io requests count. of course on old, not ssd disks maybe the best will be have only 1 request in time, i not check - but GUI let select you any value in range [1, 100) and test result

13. i log all errors during scan and show log window (if exist errors) after scan end
14. user ca cancel/stop scan at any time
15. GUI updated every 1 second during scan and when scan finished
16. file lists with offset within the file where the string started (we can have empty search string - in this case i will be search for files/folders only based on it name (if mask exist) but not scan it content - in this case offset of course not displayed)
17. prefix/suffix (i use up to 8 characters) i show via tooltip. for format string (hex bytes + ascii) i use CryptBinaryToString with CRYPT_STRING_HEXASCII|CRYPT_STRING_NOCRLF. for support xp (primary for demo only, which not implement CRYPT_STRING_NOCRLF flag - i hook this api call (from own exe) on xp)

18. for implement asynchronous io i bind IOCP to file/folder handles. despite BindIoCompletionCallback enough here, for best perfomance i use own fixed count thread pool (thread count == cpu count in group) and IOCP

in solution i use my generic IO class library (look in asio: io.h, io.cpp, tp.cpp) where implemented logic for objects, used asynchronous io
concrete scan logic implemented task.[h/cpp] and file.[h/cpp] with auxiliary files: "name component".h/cpp, mask.h/cpp, lineheap.h/cpp
for apply mask, despite is possible use RtlIsNameInExpression (win7+) i implemet own IsNameInExpression (in mask.cpp)
for GUI i use own generic library winz. however here very simply gui :)
for search substring i use most primitive algoritm, but maximum optimized in asm (x86/x64) code (look in code32.asm, code64.asm - strnstr, wtrnstr)

files readed chunk by chunk (64kb). first search in [buf, buf + cbChunk), then (if file have more data) last (CbStr-1) bytes copied before read buffer and next searches in [buf - cbStr + 1, buf + cbChunk) - look implementation in File::OnRead in file.cpp

asio - https://github.com/rbmm/LIB/tree/master/ASIO

```