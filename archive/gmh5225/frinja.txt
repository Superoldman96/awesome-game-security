Project Path: arc_gmh5225_frinja_3mr7pxye

Source Tree:

```txt
arc_gmh5225_frinja_3mr7pxye
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ actions.py
‚îú‚îÄ‚îÄ console.py
‚îú‚îÄ‚îÄ frida_launcher.py
‚îú‚îÄ‚îÄ helper.py
‚îú‚îÄ‚îÄ icons
‚îÇ   ‚îú‚îÄ‚îÄ code-branch-solid.svg
‚îÇ   ‚îú‚îÄ‚îÄ floppy-disk-solid.svg
‚îÇ   ‚îú‚îÄ‚îÄ play-solid.svg
‚îÇ   ‚îî‚îÄ‚îÄ stop-solid.svg
‚îú‚îÄ‚îÄ log.py
‚îú‚îÄ‚îÄ plugin.json
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ settings.py
‚îú‚îÄ‚îÄ snippets.py
‚îî‚îÄ‚îÄ templates
    ‚îú‚îÄ‚îÄ _macros.js.j2
    ‚îú‚îÄ‚îÄ devi.js.j2
    ‚îú‚îÄ‚îÄ function_dumper.js.j2
    ‚îú‚îÄ‚îÄ function_dumper_report.md.j2
    ‚îú‚îÄ‚îÄ function_inspector.js.j2
    ‚îú‚îÄ‚îÄ hooker.js.j2
    ‚îú‚îÄ‚îÄ log_sniffer.js.j2
    ‚îî‚îÄ‚îÄ repl.js

```

`LICENSE`:

```
Copyright 2019 Andrea Ferraris
Copyright 2024 <dzervas@dzervas.gr> Dimitris Zervas

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# Frinja

Author: **Dimitris Zervas**

Frida plugin for binary ninja.

A set of jinja-enabled frida scripts using the context of binary ninja's static analysis.

This is a continuation of the [BinRida](https://github.com/c3r34lk1ll3r/BinRida) plugin by @[c3r34lk1ll3r](https://github.com/c3r34lk1ll3r).

## Usage

First of all you'll need to go to `Plugins > Frinja > Settings` to set up the frida
connection and the application to be instrumented.

Afterwards you can use any available commands - the `Hook Function` and `Run Hooker`
commands are explained [below](#hooker)

### Dump Function Context

It hooks and gathers all calls and returns of the focused function and generates
a markdown report with the following information:

- Callee address
- Thread ID
- Arguments (tries to dereference pointers, read strings and numbers)
- Return value
- Register values

### Inspect Function Paths

A code coverage tracer for the focused function that highlights the executed basic blocks

## Hooker

The main show of this plugin is the `Run Hooker` command. It allows you to trace
and tamper with the execution of the application.

After a function is marked with the `Hook Function` command (or any function with
the `Frinja Hooked` tag) all its calls and returns will get logged in the log pane.

There's also the ability to add pre and post hooks to the function as well as altering
the return value.

To do so a function comment should be added in the following format:

```text
@prehook: <prehook js code>
@posthook: <posthook js code>
@ret: <return value>
@replace: <replace whole function with js code>
```

The return value can be any kind of valid javascript expression

## License

This plugin is released under a MIT license.

```

`__init__.py`:

```py
"""
binrida.py - Stalk,dump and instrumentation with Frida

Copyright (c) 2019 Andrea Ferraris

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""
import binaryninja as bn
import binaryninjaui as ui
from .actions import *
from .console import CONSOLE
from .settings import SETTINGS

bn.PluginCommand.register("Frinja\\Settings", "Set up Frinja to your liking", SETTINGS.show)
bn.PluginCommand.register("Frinja\\Help", "Show the project readme", show_help)
bn.PluginCommand.register_for_function("Frinja\\Hook Function", "Mark function for hooking during run", mark_hooked)
bn.PluginCommand.register("Frinja\\Run Hooker", "Start frida with the given settings and the hooker script", frida_start)
bn.PluginCommand.register_for_function("Frinja\\Inspect Function Paths", "Highlight the code paths that the functions takes", function_inspector)
bn.PluginCommand.register_for_function("Frinja\\Dump Function Context", "Create a report of all the function calls and returns", function_dumper)
bn.PluginCommand.register("Frinja\\Log Sniffer", "Try to identify logging functions that are called", log_sniffer)

try:
	import murx_devi_binja
	bn.PluginCommand.register_for_function("Frinja\\Devirtualize Virtual calls (devi plugin)", "Generate a devi virtual calls report and call the plugin", devi)
	info("devi plugin found, enabling devi support")
except ImportError:
	warn("devi plugin not found, disabling devi support")
	pass

try:
	import Vector35_snippets
	from .snippets import *
	info("snippets plugin found, enabling snippets support")
except ImportError:
	info("snippets plugin not found, disabling snippets support")

ui.GlobalArea.addWidget(lambda _: CONSOLE)

```

`actions.py`:

```py
from html import escape
from typing import Any, Optional
import binaryninja as bn
import frida

from .frida_launcher import FridaLauncher, jinja, FRIDA_RELOADER
from .log import *
from .console import CONSOLE
from .settings import HOOK_TAG_TYPE, HOOK_TAG_TYPE_ICON
from .helper import get_functions_by_tag, needs_settings, message_handler, PLUGIN_PATH

@alert_on_error
def show_help(bv: bn.BinaryView):
	bv.show_markdown_report("Frinja Help", open(PLUGIN_PATH / "README.md").read())

def mark_hooked(bv: bn.BinaryView, func: bn.Function):
	global FRIDA_RELOADER

	# NOTE: Maybe rely on id instead of name?
	if not bv.get_tag_type(HOOK_TAG_TYPE):
		state = bv.begin_undo_actions()
		bv.create_tag_type(HOOK_TAG_TYPE, HOOK_TAG_TYPE_ICON)
		bv.commit_undo_actions(state)

	if not func.get_function_tags(False, HOOK_TAG_TYPE):
		func.add_tag(HOOK_TAG_TYPE, "Hook function calls", None)
	else:
		func.remove_user_function_tags_of_type(HOOK_TAG_TYPE)

	try:
		FRIDA_RELOADER()
	except frida.InvalidOperationError:
		FRIDA_RELOADER = lambda: None

# Frida Start
@needs_settings
def frida_start(bv: bn.BinaryView):
	global FRIDA_RELOADER

	info("Launching hooker script")
	# int is immutable so we have to use dict/list
	state = { "depth": 0 }
	targets = get_functions_by_tag(bv, HOOK_TAG_TYPE)

	frida_launcher = FridaLauncher.from_template(bv, "hooker.js.j2", targets=targets)
	frida_launcher.on_message_send = [on_frida_start(state)]
	frida_launcher.start()

	FRIDA_RELOADER = lambda: frida_launcher.replace_script_from_template("hooker.js.j2", targets=get_functions_by_tag(bv, HOOK_TAG_TYPE))

@message_handler
def on_frida_start(msg: Any, data: Optional[bytes], state: dict):
	if not isinstance(msg, dict) or "event" not in msg.keys() or msg["event"] not in ("call", "return"):
		CONSOLE.handle_message(msg)
		return

	for k, v in msg.items():
		if isinstance(v, str):
			msg[k] = escape(v)

	link = f'<a href="function:{hex(msg["address"])}">{msg["function"]}</a>'
	indent = "‚ïë " * state["depth"]
	# TODO: Per-thread color
	if msg["event"] == "call":
		args = ", ".join([f"{k}={v}" for k, v in msg["args"].items()])
		CONSOLE.output.appendHtml(f"{indent}‚ïî {link}({args})")
		state["depth"] += 1
	elif msg["event"] == "return":
		state["depth"] -= 1
		indent = indent[:-2]
		retval = msg["retval"]

		if "new_retval" in msg.keys():
			retval = f'<span style="text-decoration: line-through">{retval}</span> ~> <b>{msg["new_retval"]}</b>'

		CONSOLE.output.appendHtml(f"{indent}‚ïö {link}(...) ¬´ {retval}")

	if state["depth"] <= 0:
		state["depth"] = 0

# Function Inspector
@alert_on_error
@needs_settings
def function_inspector(bv: bn.BinaryView, func: bn.Function):
	info(f"Launching function inspector for {func.name}@{hex(func.start)}")
	frida_launcher = FridaLauncher.from_template(bv, "function_inspector.js.j2", func=func)
	frida_launcher.on_message_send = [on_function_inspector(bv, func)]
	frida_launcher.start()

@message_handler
def on_function_inspector(msg: str, data: Optional[bytes], bv: bn.BinaryView, func: bn.Function):
	addr = bv.start + int(msg, 16)
	debug(f"Highlighting block @ {hex(addr)}")

	# The block in HLIL can't get highlighted - upstream bug https://github.com/Vector35/binaryninja-api/issues/2584
	# block = func.get_basic_block_at(addr)
	# block.set_auto_highlight(bn.HighlightStandardColor.CyanHighlightColor)
	func.set_auto_instr_highlight(addr, bn.HighlightStandardColor.CyanHighlightColor)

# Function Dumper
@alert_on_error
@needs_settings
def function_dumper(bv: bn.BinaryView, func: bn.Function):
	dump_data = []
	info(f"Launching function dumper for {func.name}@{hex(func.start)}")

	def reporter():
		info("Dumping complete - generating report")
		template = jinja.get_template("function_dumper_report.md.j2")
		report = template.render(bv=bv, func=func, data=dump_data)
		bv.show_markdown_report(f"{func.name} Dump", report)

	frida_launcher = FridaLauncher.from_template(bv, "function_dumper.js.j2", func=func)
	frida_launcher.on_message_send = [on_function_dumper(bv, func, dump_data)]
	frida_launcher.on_end.append(reporter)
	frida_launcher.start()


@message_handler
def on_function_dumper(msg: dict, data: Optional[bytes], bv: bn.BinaryView, func: bn.Function, dump_data: list):
	if "return" in msg.keys():
		msg["return"] = int(msg["return"], 16)
	dump_data.append(msg)

# Devi
@alert_on_error
@needs_settings
def devi(bv: bn.BinaryView, func: bn.Function):
	dump_data = {
		"callList": [],
		"modules": None,
	}
	info(f"Launching devi analysis for {func.name}@{hex(func.start)}")

	frida_launcher = FridaLauncher.from_template(bv, "devi.js.j2", func=func)
	frida_launcher.on_message_send = [on_devi(bv, func, dump_data)]
	frida_launcher.start()

@message_handler
def on_devi(msg: dict, data: Optional[bytes], bv: bn.BinaryView, func: bn.Function, dump_data: dict):
	print(msg)
	if "callList" in msg.keys():
		dump_data["callList"].extend(msg["callList"])
	elif "moduleMap" in msg.keys():
		dump_data["modules"] = msg["moduleMap"]
	elif "deviFinished" in msg.keys():
		info("Analysis complete - calling devi plugin")

		import murx_devi_binja

		# Disable the load_virtual_calls function that shows the load dialog
		class DeviMuted(murx_devi_binja.binja_devi):
			def load_virtual_calls(self):
				pass

		devi = DeviMuted(bv)
		devi.devirtualize_calls(dump_data["callList"], dump_data["modules"])

# Log Sniffer
@needs_settings
def log_sniffer(bv: bn.BinaryView):
	info("Launching log sniffer")
	frida_launcher = FridaLauncher.from_template(bv, "log_sniffer.js.j2")
	frida_launcher.start()

```

`console.py`:

```py
from threading import Thread
import binaryninjaui as ui
import json
import frida
import time
import asyncio

from .log import *
from .settings import SETTINGS
from .helper import PLUGIN_PATH
from html import escape
from typing import Any, Callable, Mapping, Optional, Tuple, Union
from PySide6.QtWidgets import QVBoxLayout, QTextBrowser, QLineEdit, QLabel, QHBoxLayout, QPushButton, QWidget
from PySide6.QtGui import QTextCursor, QIcon, QAction, QContextMenuEvent
from PySide6.QtCore import Qt, QUrl

ICONS_PATH = PLUGIN_PATH / "icons"

CSS = f"""
a {{ text-decoration: none; }}
a[href^="function"] {{ color: {ui.getThemeColor(bn.ThemeColor.CodeSymbolColor).name()}; }}
a[href^="address"] {{ color: {ui.getThemeColor(bn.ThemeColor.AddressColor).name()}; }}
"""

def on_anchor_click(url: QUrl):
	bv: bn.BinaryView = ui.UIContext.activeContext().getCurrentView().getData()

	target = url.path().strip()
	try:
		target = int(target, 16)
	except ValueError:
		try:
			target = int(target)
		except ValueError:
			pass

	if url.scheme() == "function":
		func = bv.get_function_at(target)
		if func:
			bv.navigate(bv.view, func.start)
		else:
			alert(f"Function not found at: {url.path()}")
	elif url.scheme() == "address":
		bv.navigate(bv.view, target)

# Got from https://github.com/frida/frida-tools/blob/main/frida_tools/repl.py#L1188
def hexdump(src, length: int = 16) -> str:
	FILTER = "".join([(len(repr(chr(x))) == 3) and chr(x) or "." for x in range(256)])
	lines = []
	for c in range(0, len(src), length):
		chars = src[c : c + length]
		hex = " ".join(["%02x" % x for x in iter(chars)])
		printable = "".join(["%s" % ((x <= 127 and FILTER[x]) or ".") for x in iter(chars)])
		lines.append("%04x  %-*s  %s\n" % (c, length * 3, hex, printable))
	return "".join(lines).rstrip("\n")


class HistoryLineEdit(QLineEdit):
	def __init__(self, parent=None):
		super().__init__(parent)
		self.history = []
		self.history_pos = -1

	def keyPressEvent(self, event):
		if event.key() == Qt.Key.Key_Up:
			if self.history_pos < len(self.history) - 1:
				self.history_pos += 1
				self.setText(self.history[self.history_pos])
		elif event.key() == Qt.Key.Key_Down:
			if self.history_pos > 0:
				self.history_pos -= 1
				self.setText(self.history[self.history_pos])
			else:
				self.history_pos = -1
				self.clear()
		else:
			super().keyPressEvent(event)

	def loadHistory(self):
		self.history = SETTINGS.console_history
		self.history_pos = -1

	def addToHistory(self, command):
		try:
			self.history.remove(command)
		except ValueError:
			pass

		self.history_pos = -1
		self.history.insert(0, command)

		if len(self.history) > 4096:
			self.history = self.history[:4096]

		SETTINGS.console_history = self.history


class ConsoleTextBrowser(QTextBrowser):
	_last_update: float
	_queue: asyncio.Queue
	_throttled_update: Optional[asyncio.Task]

	def __init__(self, parent: QWidget | None = ...) -> None:
		super().__init__(parent)

		self._last_update = 0
		self._queue = asyncio.Queue()
		self._throttled_update = None

	def contextMenuEvent(self, event: QContextMenuEvent):
		self.setUndoRedoEnabled(False)
		self.setReadOnly(True)
		menu = self.createStandardContextMenu()
		menu.addSeparator()

		# Add custom action to clear the text
		clearAction = QAction("Clear Console", self)
		clearAction.triggered.connect(self.clear_text)
		menu.addAction(clearAction)

		# Display the context menu
		menu.exec(event.globalPos())

	def appendHtml(self, html: str, sync: bool = False):
		if not isinstance(html, str):
			alert(f"appendHtml called with non-string argument: {str(html)}")
			return

		if not sync and self._throttled_update is not None and not self._throttled_update.done():
			self._queue.put_nowait(html)
		elif not sync and time.time() - self._last_update < 0.35:
			self._queue.put_nowait(html)

			if not self._throttled_update:
				self._throttled_update = asyncio.create_task(self._appendHtml_throttler())
		else:
			self.insertHtml(f"<style>{CSS}</style><br/>{html}")

			self._last_update = time.time()

	async def _appendHtml_throttler(self):
		html = ""
		await asyncio.sleep(0.3)
		while True:
			try:
				html += self._queue.get_nowait() + "<br/>"
			except asyncio.QueueEmpty:
				break

		html = html[:-len("<br/>")]
		self._throttled_update = None

		def callback():
			self._throttled_update = None
			self.appendHtml(html, sync=True)

		bn.execute_on_main_thread(callback)

	def clear_text(self):
		self.clear()


class FridaConsoleWidget(ui.GlobalAreaWidget):
	_evaluate_cb: Optional[Callable[[str], Union[bytes, Mapping[Any, Any], Tuple[str, bytes]]]] = None
	_stop_cb: Optional[Callable[[], None]] = None

	input: HistoryLineEdit
	output: QTextBrowser
	play_stop: QPushButton
	hook: QPushButton
	save: QPushButton

	def __init__(self):
		super().__init__("Frida Console")

		layout = QVBoxLayout()

		self.output = ConsoleTextBrowser(self)
		self.output.setOpenLinks(False)
		self.output.setOpenExternalLinks(False)
		self.output.anchorClicked.connect(on_anchor_click)
		layout.addWidget(self.output)

		hbox = QHBoxLayout()
		hbox.addWidget(QLabel(">"))

		self.input = HistoryLineEdit(self)
		self.input.returnPressed.connect(self.on_input_handler)
		hbox.addWidget(self.input)

		self.play_stop = QPushButton(parent=self)
		self.play_stop.clicked.connect(self.on_play_stop)
		hbox.addWidget(self.play_stop)

		self.save = QPushButton(parent=self)
		self.save.setIcon(QIcon(str(ICONS_PATH / "floppy-disk-solid.svg")))
		self.save.setToolTip("Save script and console output to file")
		# self.save.clicked.connect(self.on_save)
		hbox.addWidget(self.save)

		self.hook = QPushButton(parent=self)
		self.hook.setIcon(QIcon(str(ICONS_PATH / "code-branch-solid.svg")))
		self.hook.setToolTip("Mark the current function to be hooked")
		self.hook.clicked.connect(self.on_hook)
		hbox.addWidget(self.hook)

		layout.addLayout(hbox)
		self.setLayout(layout)

		self.session_end(showFinished=False)

	@alert_on_error
	def on_input_handler(self):
		if not self._evaluate_cb:
			self.output.appendHtml("Internal Error: No evaluate function set")
			return

		text = self.input.text()
		self.input.addToHistory(text)
		self.input.clear()
		self.output.appendHtml(f"> {text}")

		# result = self._evaluate_cb(text)
		# self.handle_result(result)
		@alert_on_error
		def eval_bg():
			result = self._evaluate_cb(text)
			bn.execute_on_main_thread_and_wait(lambda: self.handle_result(result))

		Thread(target=eval_bg).start()

	def on_play_stop(self):
		if self._evaluate_cb:
			self._stop_cb()
			self.session_end()
		else:
			bv = ui.UIContext.activeContext().getCurrentView().getData()
			ctx = bn.PluginCommandContext(bv)
			bn.PluginCommand.get_valid_list(ctx)["Frinja\\Run Hooker"].execute(ctx)

	def on_hook(self):
		bv = ui.UIContext.activeContext().getCurrentView().getData()
		func = ui.UIContext.activeContext().getCurrentView().getCurrentFunction()
		ctx = bn.PluginCommandContext(bv)
		ctx.function = func
		bn.PluginCommand.get_valid_list(ctx)["Frinja\\Hook Function"].execute(ctx)

	def session_start(self, evaluate: Callable[[str], Union[bytes, Mapping[Any, Any], Tuple[str, bytes]]], stop: Callable[[], None]):
		if not evaluate:
			alert("Frinja: No evaluate function set for console on session start")
			return

		self._evaluate_cb = evaluate
		self._stop_cb = stop

		self.input.clear()
		self.input.loadHistory()
		self.input.setReadOnly(False)
		self.input.setFocus()

		self.output.insertHtml("Frida Client v" + str(frida.__version__))
		try:
			self.output.appendHtml("Frida Client v" + evaluate("Frida.version")[1])
		except frida.InvalidOperationError:
			pass

		self.play_stop.setIcon(QIcon(str(ICONS_PATH / "stop-solid.svg")))
		self.play_stop.setToolTip("Stop frida session")
		# self.save.show()

	def session_end(self, showFinished: bool = True):
		self.input.setReadOnly(True)
		self.input.setText("Please use the `Start Hooker` command to start a session")
		self._evaluate_cb = None
		self.input.history = []

		self.play_stop.setIcon(QIcon(str(ICONS_PATH / "play-solid.svg")))
		self.play_stop.setToolTip("Start frida session")
		self.save.hide()

		if showFinished:
			self.output.appendHtml("<br/>=== Script finished ===<br/>")

	def handle_result(self, result: Union[bytes, Mapping[Any, Any], Tuple[str, bytes]]):
		if result[0] == "error":
			error = result[1]
			line = f'<span style="color: red;"><b>{escape(error["name"])}</b></span>: {escape(error["message"])}'

			if "stack" in error.keys():
				message_len = len(error["message"].split("\n"))
				# trim_amount = 6 if self._runtime == "v8" else 7
				trimmed_stack = error["stack"].split("\n")[message_len:-6]
				if len(trimmed_stack) > 0:
					output += "<br/>" + "<br/>".join(trimmed_stack)

			self.output.appendHtml(line)
			return

		if isinstance(result, bytes):
			self.output.appendHtml(escape(hexdump(result)))
		elif isinstance(result, dict):
			warn(f"dict instance {str(result)}")
		elif result[0] in ("function", "undefined", "null"):
			self.output.appendHtml(escape(result[0]))
		else:
			self.output.appendHtml(escape(json.dumps(result[1], sort_keys=True, indent=4, separators=(",", ": "))))

	def handle_log(self, level: str, text: str):
		line = escape(text).replace("\n", "<br/>")

		if level == "debug":
			line = f'<span style="color: gray;"><b>[d]</b></span> <i>{line}</i>'
		elif level == "info":
			line = f'<span style="color: blue;"><b>[+]</b></span> {line}'
		elif level == "warning":
			line = f'<span style="color: yellow;"><b>[!]</b></span> {line}'
		elif level == "error":
			line = f'<span style="color: red;"><b>[x]</b> {line}</span>'

		self.output.appendHtml(line)

	def handle_message(self, msg: Any):
		self.output.appendHtml(escape("< " + str(msg)))

	def handle_error(self, msg: frida.core.ScriptErrorMessage):
		for k in msg.keys():
			try:
				msg[k] = escape(msg[k])
			except Exception:
				pass

		self.output.appendHtml(f"<span style='color: red;'><b>{msg['description']}</b></span>")
		if "stack" in msg.keys():
			self.output.appendHtml("<span style='color: red;>" + "<br/>".join(msg["stack"].split("\\n")) + "</span>")


CONSOLE = FridaConsoleWidget()

```

`frida_launcher.py`:

```py
from threading import Thread
import time
from typing import List, Optional
import frida
import binaryninja as bn

from .console import CONSOLE
from .settings import ExecutionAction, SETTINGS
from .log import *
from .helper import PLUGIN_PATH
from jinja2 import Environment, FileSystemLoader, select_autoescape

TEMPLATES_PATH = PLUGIN_PATH / "templates"
FRIDA_RELOADER: Callable[[], None] = lambda: None

jinja = Environment(
	loader=FileSystemLoader(TEMPLATES_PATH),
	autoescape=select_autoescape()
)


class FridaLauncher(bn.BackgroundTaskThread):
	bv: bn.BinaryView
	script_source: str

	on_log: List[Callable[[str, str], None]]
	on_destroyed: List[Callable[[], None]]
	on_detached: List[Callable[[str], None]]
	on_start: List[Callable[[Callable[[str], str]], None]]
	on_end: List[Callable[[], None]]
	on_message: List[Callable[[frida.core.ScriptMessage, Optional[bytes]], None]]
	on_message_send: List[Callable[[frida.core.ScriptPayloadMessage, Optional[bytes]], None]]
	on_message_error: List[Callable[[frida.core.ScriptErrorMessage], None]]

	session: Optional[frida.core.Session]
	script: Optional[frida.core.Script]
	evaluate: Optional[Callable[[str], str]]
	pid: int

	def __init__(self, bv: bn.BinaryView, script: str):
		global FRIDA_RELOADER
		super().__init__("Frinja initializing", True)

		FRIDA_RELOADER = lambda: None
		self.script_source = script
		self.bv = bv
		self.script = None
		self.session = None
		self.pid = 0
		self.evaluate = None
		SETTINGS.restore(bv)

		self.on_log = [CONSOLE.handle_log]
		self.on_destroyed = []
		self.on_detached = []
		self.on_start = [CONSOLE.session_start]
		self.on_end = [CONSOLE.session_end]
		self.on_message = []
		self.on_message_send = [lambda msg, _: CONSOLE.handle_message(msg)]
		self.on_message_error = [CONSOLE.handle_error]

	@staticmethod
	def from_template(bv: bn.BinaryView, template_name: str, **kwargs):
		template = jinja.get_template(template_name)
		script = template.render(settings=SETTINGS, bv=bv, **kwargs)
		return FridaLauncher(bv, script)

	def replace_script_from_template(self, template_name: str, **kwargs):
		template = jinja.get_template(template_name)
		script = template.render(settings=SETTINGS, bv=self.bv, **kwargs)
		return self.replace_script(script)

	def replace_script(self, script: str) -> bool:
		if self.session is None:
			return False

		if self.script is None:
			info("Loading script")
			self.progress = "Loading script"
		else:
			info("Reloading script")
			self.progress = "Reloading script"
			self.script.unload()

			bn.execute_on_main_thread(lambda: CONSOLE.output.appendHtml("=== Script reloaded ==="))

		# Print the script (very useful for debugging)
		debug("\n".join([f"{n + 1}: {l}" for n, l in enumerate(script.split("\n"))]))

		# Create the script with the repl code injected
		repl_script = open(TEMPLATES_PATH / "repl.js").read()
		self.script = self.session.create_script(repl_script + "\n\n" + script)

		# Intialize the callback handlers
		def on_destroyed():
			self.script = None
			for f in self.on_destroyed:
				bn.execute_on_main_thread(f)

		def on_message(msg: frida.core.ScriptMessage, data: Optional[bytes]):
			for f in self.on_message:
				bn.execute_on_main_thread(lambda: f(msg, data))

			if msg["type"] == "error":
				for f in self.on_message_error:
					bn.execute_on_main_thread(lambda: f(msg))
			elif msg["type"] == "send":
				for f in self.on_message_send:
					bn.execute_on_main_thread(lambda: f(msg, data))

		def on_log(level: str, text: str):
			for f in self.on_log:
				bn.execute_on_main_thread(lambda: f(level, text))

		self.script.set_log_handler(on_log)
		self.script.on("destroyed", on_destroyed)
		self.script.on("message", on_message)
		self.script.load()
		self.evaluate = self.script.exports_sync.evaluate # RPC export defined in repl.js

		self.progress = "Frinja running..."

	def run(self):
		if SETTINGS.device is None:
			alert("Please select a device from the settings")

		# Prepare the callback handlers
		def on_detached(reason):
			info("Detached from process")
			for f in self.on_detached:
				bn.execute_on_main_thread(lambda: f(reason))

			self.cancel()

		# Find (or create) the process
		if SETTINGS.exec_action == ExecutionAction.SPAWN:
			# TODO: Allow tinkering with the env, stdio and cwd
			self.pid = SETTINGS.device.spawn(SETTINGS.file_target, SETTINGS.cmdline.split(" "))
			info(f"Spawned {SETTINGS.file_target} with arguments `{SETTINGS.cmdline}` that got PID {self.pid}")
		elif SETTINGS.exec_action == ExecutionAction.ATTACH_NAME:
			self.pid = SETTINGS.attach_name
		elif SETTINGS.exec_action == ExecutionAction.ATTACH_PID:
			self.pid = SETTINGS.attach_pid
		else:
			alert("Frinja: Unknown execution action")
		info(f"Attaching to {self.pid}")

		# Initialize the frida session
		self.session = SETTINGS.device.attach(self.pid)
		self.session.on("detached", on_detached)

		# Load the script
		self.replace_script(self.script_source)

		# Resume the process and connect to the REPL
		if SETTINGS.exec_action == ExecutionAction.SPAWN:
			SETTINGS.device.resume(self.pid)

		for f in self.on_start:
			bn.execute_on_main_thread(lambda: f(self.evaluate, self.cancel))

		while True:
			if self.cancelled or self.finished:
				break
			time.sleep(1)

		self.session.detach()

	def _finalizer(self):
		if self.finished:
			return

		# global FRIDA_RELOADER
		self.progress = "Frinja cleaning up"

		if SETTINGS.exec_action != ExecutionAction.SPAWN:
			if self.session is not None and not self.session.is_detached:
				# Frida internally does frida_session_detach_sync which is a blocking call
				# so if we stop in the middle of a hooked function we have to wait till it returns
				self.session.detach()
				return
		else:
			try:
				SETTINGS.device.kill(self.pid)
				info("Process killed")
			except frida.ProcessNotFoundError:
				info("Process already finished")

		# FRIDA_RELOADER = lambda: None
		for f in self.on_end:
			bn.execute_on_main_thread(f)

		# SETTINGS.store(self.bv)

	def finish(self):
		self._finalizer()
		super().finish()

	def cancel(self):
		return super().cancel()

```

`helper.py`:

```py
from pathlib import Path
from typing import Callable, Optional
import binaryninja as bn
import frida

from .log import *
from .settings import HOOK_TAG_TYPE, HOOK_TAG_TYPE_ICON, SETTINGS

PLUGIN_PATH = Path(bn.user_plugin_path()) / "frinja"

mgr = bn.RepositoryManager()
for repo in mgr.repositories:
	if any([x.path == "dzervas_frinja" and x.installed for x in repo.plugins]):
		PLUGIN_PATH = Path(repo.full_path) / "dzervas_frinja"
		break

def get_functions_by_tag(bv: bn.BinaryView, tag: str):
	if not bv.get_tag_type(HOOK_TAG_TYPE):
		bv.create_tag_type(HOOK_TAG_TYPE, HOOK_TAG_TYPE_ICON)

	return [f for f in bv.functions if f.get_function_tags(False, tag)]

def needs_settings(func: Callable):
	def wrapper(bv: bn.BinaryView, *args, **kwargs):
		SETTINGS.restore(bv)
		func(bv, *args, **kwargs)
	return wrapper

def message_handler(func: Callable):
	def wrapper(*args, **kwargs):
		def inner(msg: frida.core.ScriptMessage, data: Optional[bytes]):
			# TODO: What to do with the data?
			if msg["type"] == "error":
				if msg["stack"]:
					error(msg["stack"])

				error("\n".join(msg["description"].split("\\n")))
				return

			func(msg["payload"], data, *args, **kwargs)
		return inner
	return wrapper

```

`icons/code-branch-solid.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M80 104a24 24 0 1 0 0-48 24 24 0 1 0 0 48zm80-24c0 32.8-19.7 61-48 73.3v87.8c18.8-10.9 40.7-17.1 64-17.1h96c35.3 0 64-28.7 64-64v-6.7C307.7 141 288 112.8 288 80c0-44.2 35.8-80 80-80s80 35.8 80 80c0 32.8-19.7 61-48 73.3V160c0 70.7-57.3 128-128 128H176c-35.3 0-64 28.7-64 64v6.7c28.3 12.3 48 40.5 48 73.3c0 44.2-35.8 80-80 80s-80-35.8-80-80c0-32.8 19.7-61 48-73.3V352 153.3C19.7 141 0 112.8 0 80C0 35.8 35.8 0 80 0s80 35.8 80 80zm232 0a24 24 0 1 0 -48 0 24 24 0 1 0 48 0zM80 456a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"/></svg>
```

`icons/floppy-disk-solid.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M64 32C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V173.3c0-17-6.7-33.3-18.7-45.3L352 50.7C340 38.7 323.7 32 306.7 32H64zm0 96c0-17.7 14.3-32 32-32H288c17.7 0 32 14.3 32 32v64c0 17.7-14.3 32-32 32H96c-17.7 0-32-14.3-32-32V128zM224 288a64 64 0 1 1 0 128 64 64 0 1 1 0-128z"/></svg>
```

`icons/play-solid.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" height="16" width="12" viewBox="0 0 384 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg>
```

`icons/stop-solid.svg`:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M0 128C0 92.7 28.7 64 64 64H320c35.3 0 64 28.7 64 64V384c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V128z"/></svg>
```

`log.py`:

```py
from typing import Callable, Optional
import binaryninja as bn

LOGGER = bn.log.Logger(0, "Frinja")

log = LOGGER.log
debug = LOGGER.log_debug
info = LOGGER.log_info
warn = LOGGER.log_warn
error = LOGGER.log_error
alert = LOGGER.log_alert

def alert_on_error_cb(exception: Optional[Callable] = None, finalizer: Optional[Callable] = None):
	def wrapper(func: Callable):
		def inner(*args, **kwargs):
			try:
				return func(*args, **kwargs)
			except Exception as e:
				error(e)
				alert(f"Frinja: {e}")

				if exception:
					exception(e)
			finally:
				if finalizer:
					finalizer()

		return inner
	return wrapper

def alert_on_error(func: Callable):
	return alert_on_error_cb()(func)

```

`plugin.json`:

```json
{
  "pluginmetadataversion": 2,
  "name": "Frinja",
  "author": "Dimitris Zervas",
  "type": [
    "helper"
  ],
  "api": [
    "python3"
  ],
  "description": "Frida plugin for Binary Ninja - continuation of BinRida by @c3r34lk1ll3r",
  "longdescription": "# Frinja\n\nAuthor: **Dimitris Zervas**\n\nFrida plugin for binary ninja.\n\nA set of jinja-enabled frida scripts using the context of binary ninja's static analysis.\n\nThis is a continuation of the [BinRida](https://github.com/c3r34lk1ll3r/BinRida) plugin by @[c3r34lk1ll3r](https://github.com/c3r34lk1ll3r).\n\n## Usage\n\nFirst of all you'll need to go to `Plugins > Frinja > Settings` to set up the frida\nconnection and the application to be instrumented.\n\nAfterwards you can use any available commands - the `Hook Function` and `Run Hooker`\ncommands are explained [below](#hooker)\n\n### Dump Function Context\n\nIt hooks and gathers all calls and returns of the focused function and generates\na markdown report with the following information:\n\n- Callee address\n- Thread ID\n- Arguments (tries to dereference pointers, read strings and numbers)\n- Return value\n- Register values\n\n### Inspect Function Paths\n\nA code coverage tracer for the focused function that highlights the executed basic blocks\n\n## Hooker\n\nThe main show of this plugin is the `Run Hooker` command. It allows you to trace\nand tamper with the execution of the application.\n\nAfter a function is marked with the `Hook Function` command (or any function with\nthe `Frinja Hooked` tag) all its calls and returns will get logged in the log pane.\n\nThere's also the ability to add pre and post hooks to the function as well as altering\nthe return value.\n\nTo do so a function comment should be added in the following format:\n\n```text\n@prehook: <prehook js code>\n@posthook: <posthook js code>\n@ret: <return value>\n@replace: <replace whole function with js code>\n```\n\nThe return value can be any kind of valid javascript expression\n\n## License\n\nThis plugin is released under a MIT license.",
  "license": {
    "name": "MIT",
    "text": "Copyright 2019 Andrea Ferraris\nCopyright 2024 <dzervas@dzervas.gr> Dimitris Zervas\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "platforms": [
    "Darwin",
    "Windows",
    "Linux"
  ],
  "dependencies": {
    "pip": [
      "frida",
      "Jinja2"
    ]
  },
  "version": "1.2.2",
  "minimumbinaryninjaversion": 3164
}

```

`requirements.txt`:

```txt
frida
Jinja2

```

`settings.py`:

```py
from enum import Enum
from typing import Optional
from binaryninja import BinaryView
from frida.core import Device
import binaryninja as bn
import frida
from .log import *

HOOK_TAG_TYPE = "Frinja Hooked"
HOOK_TAG_TYPE_ICON = "ü™ù"


class ExecutionAction(Enum):
	SPAWN = 0
	ATTACH_NAME = 1
	ATTACH_PID = 2


class Settings():
	device: Optional[Device] = None
	exec_action: ExecutionAction = ExecutionAction.SPAWN
	attach_name: str = ""
	attach_pid: Optional[int] = None
	file_target: str = ""
	cmdline: str = ""
	console_history: list[str] = []

	# TODO: P2P functionality
	# TODO: Certificate support
	# TODO: Stun server support
	# TODO: Relay server support

	def __init__(self):
		pass

	def show(self, bv: BinaryView):
		self.restore(bv)

		devices = frida.enumerate_devices()

		device_ui = bn.ChoiceField("Device", [d.name for d in devices], [d.id for d in devices].index(self.device.id) if self.device is not None else None)
		exec_action_ui = bn.ChoiceField("Execution mode", ["Spawn a new process", "Attach to process name", "Attach to PID"], self.exec_action.value)

		name_ui = bn.TextLineField("Process Name", self.attach_name)
		pid_ui = bn.ChoiceField("PID", [])
		file_target_ui = bn.TextLineField("File target", self.file_target if self.file_target != "" else bv.file.original_filename)
		cmdline_ui = bn.TextLineField("Command line arguments", self.cmdline)

		form = [
			device_ui,
			exec_action_ui,
			bn.SeparatorField(),

			bn.LabelField("Process Name Attaching Settings"),
			name_ui,
			bn.SeparatorField(),

			bn.LabelField("PID Attaching Settings"),
			pid_ui,
			bn.SeparatorField(),

			bn.LabelField("Spawning Settings"),
			file_target_ui,
			cmdline_ui,
		]

		device = self.device if self.device is not None else devices[0]

		try:
			for processes in device.enumerate_processes():
				pid_ui.choices.append(f"{processes.name} ({processes.pid})")
				if self.attach_pid == processes.pid:
					pid_ui._default = len(pid_ui.choices) - 1
		except frida.ServerNotRunningError:
			info("Unable to enumerate PIDs of the device - is the server running?")
			pid_ui.prompt += " (Unable to enumerate PIDs)"

		result = bn.interaction.get_form_input(form, "Frinja Settings")

		if not result:
			return

		self.device = devices[device_ui.result]
		self.exec_action = ExecutionAction(exec_action_ui.result)
		self.attach_name = name_ui.result.strip()
		self.attach_pid = int(pid_ui.choices[pid_ui.result].split("(")[1][:-1]) if pid_ui.result is not None and pid_ui.choices else 0
		self.file_target = file_target_ui.result
		self.cmdline = cmdline_ui.result

		self.store(bv)

	def store(self, bv: BinaryView):
		bv.store_metadata("frinja_device", self.device.id)
		bv.store_metadata("frinja_exec_action", self.exec_action.value)
		bv.store_metadata("frinja_attach_name", self.attach_name)
		bv.store_metadata("frinja_attach_pid", self.attach_pid)
		bv.store_metadata("frinja_cmdline", self.cmdline)
		bv.store_metadata("frinja_file_target", self.file_target)
		bv.store_metadata("frinja_console_history", self.console_history)

	def restore(self, bv: BinaryView):
		try:
			self.device = frida.get_device(bv.query_metadata("frinja_device"))
			self.exec_action = ExecutionAction(bv.query_metadata("frinja_exec_action"))
			self.cmdline = bv.query_metadata("frinja_cmdline")
			self.attach_name = bv.query_metadata("frinja_attach_name")
			self.attach_pid = bv.query_metadata("frinja_attach_pid")
			self.file_target = bv.query_metadata("frinja_file_target")
			self.console_history = bv.query_metadata("frinja_console_history")
		except KeyError:
			pass

SETTINGS = Settings()

```

`snippets.py`:

```py
import binaryninja as bn
import binaryninjaui as ui
import Vector35_snippets as snippets
from PySide6.QtWidgets import QDialog
from PySide6.QtCore import QFileInfo
from PySide6.QtGui import QKeySequence
import os

from .log import *

def newFileDialog(cls):
	name_ui = bn.TextLineField("Snippet Name:")
	type_ui = bn.ChoiceField("Snippet Type:", ["Python", "Frinja"])
	form = [
		name_ui,
		type_ui,
	]

	ok = bn.get_form_input(form, "New Snippet")
	snippetName = name_ui.result.strip()

	if type_ui.result == 0 and not snippetName.endswith(".py"):
		snippetName += ".py"
	elif type_ui.result == 1 and not snippetName.endswith(".js.j2"):
		snippetName += ".js.j2"

	if ok and snippetName:
		index = cls.tree.selectionModel().currentIndex()
		selection = cls.files.filePath(index)
		if QFileInfo(selection).isDir():
			path = os.path.join(selection, snippetName)
		else:
			path = os.path.join(snippets.snippetPath, snippetName)
			cls.readOnly(False)
		open(path, "w").close()
		cls.tree.setCurrentIndex(cls.files.index(path))
		debug("Snippets: Snippet %s created." % snippetName)

_includeWalk = snippets.includeWalk
def includeWalk(dir, includeExt):
	result = []
	result.extend(_includeWalk(dir, includeExt))
	result.extend(_includeWalk(dir, ".js.j2"))
	result.extend(_includeWalk(dir, ".js"))
	return result

def loadSnippetFromFile(snippetPath):
	try:
		with snippets.codecs.open(snippetPath, 'r', 'utf-8') as snippetFile:
			snippetText = snippetFile.readlines()
	except:
		return ("", "", "")

	if (len(snippetText) < 3):
		return ("", "", "")

	description = snippetText[0].strip()
	keySequence = snippetText[1].strip()

	comment = "#"
	if snippetPath.endswith(".js.j2"):
		comment = "{#"
	elif snippetPath.endswith(".js"):
		comment = "//"

	if not description.startswith(comment) or not keySequence.startswith(comment):
		return ("", "", "")

	description = description[len(comment):].strip()
	keySequence = keySequence[len(comment):].strip()

	if snippetPath.endswith(".js.j2"):
		# Remove the closing `#}`
		description = description[:-2].strip()
		keySequence = keySequence[:-2].strip()

	qKeySequence = QKeySequence(keySequence)
	if qKeySequence.isEmpty():
		qKeySequence = None
	return (description,
			qKeySequence,
			''.join(snippetText[2:])
	)

_actionFromSnippet = snippets.actionFromSnippet
def actionFromSnippet(snippetPath, description):
	if not snippetPath.endswith(".js.j2") and not snippetPath.endswith(".js"):
		return _actionFromSnippet(snippetPath, description)

	if description:
		return _actionFromSnippet(snippetPath, "[Frinja] " + description)

	return _actionFromSnippet(snippetPath, "[Frinja] " + os.path.basename(snippetPath).rstrip(".js.j2").rstrip(".js"))

_executeSnippet = snippets.executeSnippet
def executeSnippet(code, description):
	if not description.startswith("Snippets\\[Frinja] "):
		return _executeSnippet(code, description)

	class SnippetTask():
		def __init__(self, code, snippetGlobals, context, snippetName="Executing frinja snippet"):
			self.code = code
			self.snippetGlobals = snippetGlobals
			self.context = context
			self.snippetName = snippetName

		def start(self):
			from .frida_launcher import FridaLauncher, jinja
			script = jinja.from_string(self.code).render(self.snippetGlobals)

			info(f"Executing frinja snippet {self.snippetName}")
			debug(script)

			launcher = FridaLauncher(self.snippetGlobals["bv"], script)
			return launcher.start()

	_SnippetTask = snippets.SnippetTask
	snippets.SnippetTask = SnippetTask
	_executeSnippet(code[6:], description)
	snippets.SnippetTask = _SnippetTask

def show(cls: snippets.Snippets):
	QDialog.show(cls)

	# Allow frinja snippets to be edited/selected
	nameFilters = cls.files.nameFilters()
	nameFilters.append("*.js.j2")
	cls.files.setNameFilters(nameFilters)

	# Add correct syntax highlighting
	def loadSnippet():
		if cls.edit.highlighter is None:
			return snippets.Snippets.loadSnippet(cls)

		from pygments.lexers import get_lexer_by_name
		if cls.currentFile.endswith(".js.j2"):
			cls.edit.highlighter.lexer = get_lexer_by_name("javascript+jinja")
			cls.edit.setPlaceholderText("jinja2 javascript code")
		elif cls.currentFile.endswith(".js"):
			cls.edit.highlighter.lexer = get_lexer_by_name("javascript")
			cls.edit.setPlaceholderText("javascript code")
		elif cls.currentFile.endswith(".py"):
			cls.edit.highlighter.lexer = get_lexer_by_name("python")
			cls.edit.setPlaceholderText("python code")

		snippets.Snippets.loadSnippet(cls)
	cls.loadSnippet = loadSnippet

	# Save scripts correctly - with proper comments
	def save():
		if not cls.snippetName.text().endswith(".js.j2") and not cls.snippetName.text().endswith(".js"):
			return snippets.Snippets.save(cls)

		if os.path.basename(cls.currentFile) != cls.snippetName:
			os.unlink(cls.currentFile)
			cls.currentFile = os.path.join(os.path.dirname(cls.currentFile), cls.snippetName.text())

		debug(f"Snippets: Saving frinja script {cls.currentFile}")

		comment = "// {0}\n"
		if cls.currentFile.endswith(".js.j2"):
			comment = "{{# {0} #}}\n"

		outputSnippet = snippets.codecs.open(cls.currentFile, "w", "utf-8")
		outputSnippet.write(comment.format(cls.snippetDescription.text()))
		outputSnippet.write(comment.format(cls.keySequenceEdit.keySequence().toString()))
		outputSnippet.write(cls.edit.toPlainText())
		outputSnippet.close()
	cls.save = save

snippets.Snippets.show = show
# Allows the creation of frinja snippets
snippets.Snippets.newFileDialog = newFileDialog
# Allows frinja scripts to be registered, loaded, etc.
snippets.includeWalk = includeWalk
# Parse scripts correctly
snippets.loadSnippetFromFile = loadSnippetFromFile
# Give a distinct name to frinja snippets
snippets.actionFromSnippet = actionFromSnippet
# Execute frinja snippets
snippets.executeSnippet = executeSnippet

snippets.Snippets.registerAllSnippets()

```

`templates/_macros.js.j2`:

```j2
{% macro function_header(bv, func) %}
// {{ "%#x" % func.start }}: {{ func.type.return_value.__str__() }} {{ func.name }}({{ func.type.parameters | join(", ") }})
const func_{{ func.start }}_module = Process.getModuleByName("{{ bv.file.original_filename.split("/") | last }}").base;
const func_{{ func.start }}_ptr = ptr(func_{{ func.start }}_module.add({{ "%#x" % (func.start - bv.start) }}));
{% endmacro %}

{% macro argparse(param, var) -%}
	{%- set type = param.type | string -%}

	{%- for _ in range(1, type.count("**")) if "**" in type -%}
		{%- set var = var + ".readPointer()" -%}
		{%- set type = type[:-1] -%}
	{%- endfor -%}

	{%- if type == "char*" -%}
		{{ var }}.readCString()
	{%- elif type == "wchar_t*" -%}
		{{ var }}.readUtf16String()
	{%- elif type == "int" -%}
		{{ var }}.readInt()
	{%- elif type == "uint" -%}
		{{ var }}.readUInt()
	{%- elif type == "float" -%}
		{{ var }}.readFloat()
	{%- elif type == "double" -%}
		{{ var }}.readDouble()
	{%- elif type == "bool" -%}
		{{ var }}.readU8()
	{%- elif type == "char" -%}
		{{ var }}.readU8()
	{%- elif type == "wchar_t" -%}
		{{ var }}.readU16()
	{%- elif type == "int8_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "uint8_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "int16_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "uint16_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "int32_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "uint32_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "int64_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "uint64_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "size_t" -%}
		{{ var }}.toInt32()
	{%- elif type == "int*" -%}
		{{ var }}.readInt()
	{%- elif type == "uint*" -%}
		{{ var }}.readUInt()
	{%- elif type == "float*" -%}
		{{ var }}.readFloat()
	{%- elif type == "double*" -%}
		{{ var }}.readDouble()
	{%- elif type == "bool*" -%}
		{{ var }}.readU8()
	{%- elif type == "char*" -%}
		{{ var }}.readU8()
	{%- elif type == "wchar_t*" -%}
		{{ var }}.readU16()
	{%- elif type == "int8_t*" -%}
		{{ var }}.readS8()
	{%- elif type == "uint8_t*" -%}
		{{ var }}.readU8()
	{%- elif type == "int16_t*" -%}
		{{ var }}.readS16()
	{%- elif type == "uint16_t*" -%}
		{{ var }}.readU16()
	{%- elif type == "int32_t*" -%}
		{{ var }}.readS32()
	{%- elif type == "uint32_t*" -%}
		{{ var }}.readU32()
	{%- elif type == "int64_t*" -%}
		{{ var }}.readS64()
	{%- elif type == "uint64_t*" -%}
		{{ var }}.readU64()
	{%- elif type == "size_t*" -%}
		{{ var }}.readU64()
	{%- elif type.endswith("*") -%}
		{{ var }}.readPointer()
	{%- else -%}
		{{ var }}
	{%- endif -%}
{%- endmacro %}

{% macro type_translate(bn_type) -%}
	{%- set bn_type = bn_type | string %}
	{%- set type_mapping = {
		"int8_t": "int8",
		"uint8_t": "uint8",
		"int16_t": "int16",
		"uint16_t": "uint16",
		"int32_t": "int32",
		"uint32_t": "uint32",
		"int64_t": "int64",
		"uint64_t": "uint64",
		"char": "char",
		"wchar_t": "uint16",
		"void": "void",
		"float": "float",
		"double": "double",
		"size_t": "size_t"
	} -%}

	{%- set frida_type = type_mapping[bn_type] if bn_type in type_mapping else "pointer" -%}

	{%- if bn_type.endswith('*') -%}
		"pointer"
	{%- else -%}
		"{{ frida_type }}"
	{%- endif -%}
{%- endmacro %}

```

`templates/devi.js.j2`:

```j2
'use strict';

// Got from https://github.com/murx-/devi/blob/master/devi_frida_tracer.js
// Version 0.2

{%- from "_macros.js.j2" import function_header -%}
{{ function_header(bv, func) }}
const myModule = Process.getModuleByName("{{ bv.file.original_filename.split("/") | last }}");
const symbolAddress = func_{{ func.start }}_ptr;
const debug = "True";

if (symbolAddress === undefined) {
	console.log("[!] Unable to finde symbol " + symbolInput)
	send({ "deviError": "No symbol found named: " + symbolInput })
}


if (myModule !== null) {
	myModule.end = myModule.base.add(myModule.size);
	attachInterceptor();
} else {
	send({ "deviError": "No module found named: {{ module_name }}" });
	// exit javascript here?
	console.log("[!] No module found named: {{ module_name }}")
}

/**
 *
 * @param {*} str
 *
 * Debug print
 *
 */
function log_d(str) {
	if (debug === "True")
		console.log("[+] " + str);
}

/**
 *
 * @param {*} moduleName
 * @param {*} symbolName
 *
 * return the symbol in the module
 *
 */
function getSymbolAddress(moduleName, symbolName) {
	var symbols = Module.enumerateSymbols(moduleName);
	for (var i = 0; i < symbols.length; i++) {
		if (symbols[i].name == symbolName)
			return symbols[i].address
	}
}

/**
 *
 * @param {*} codePointer
 * check if the instruction at codePointer is an indrect call.
 */
function isIndirectCall(codePointer) {
	return !Instruction.parse(codePointer).toString().startsWith('call 0x')
}

function printDebugCallEvent(callEvent) {
	log_d((callEvent[1] - myModule.base).toString(16) + ' -> ' + (callEvent[2] - myModule.base).toString(16));
	log_d(Instruction.parse(callEvent[1]) + " -> " + Instruction.parse(callEvent[2]));
	log_d("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
}

/**
 * stalk the current thread.
 */
function traceCalls() {
	Stalker.follow({
		events: {
			call: true
		},

		onReceive: function (events) {
			var callList = [];

			var call_events = Stalker.parse(events);
			call_events.forEach(function (event) {
				//todo change ifs
				if ((myModule.base <= event[1]) && (event[1] <= myModule.end)) {
					if (isIndirectCall(ptr(event[1]))) {

						//debug!
						printDebugCallEvent(event);

						var src = (event[1]);
						var payload = {};
						payload[src] = (event[2]).toString(10);
						callList.push(payload);
					}
				}
			});

			send({ "callList": callList })
		},

		onLeave: function (retval) {
			//console.log("onLeave Called");
			Stalker.unfollow(Process.getCurrentThreadId());
			Stalker.flush();
			Stalker.garbageCollect();
			send({ "finished": true });
		}

	});
}


/**
 * attach interceptor to main, and start stalker
 */
function attachInterceptor() {
	Interceptor.attach(symbolAddress, {
		onEnter: function (args) {
			log_d('[-] Start Tracing');
			log_d("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")

			// Send ModuleMap to devi
			send({ "moduleMap": Process.enumerateModulesSync() })

			traceCalls();
		},
		onLeave: function () {
			Stalker.flush();
			Stalker.unfollow(Process.getCurrentThreadId());
			Stalker.garbageCollect();
			log_d('[-] Done Tracing')
			// send here that we are done and user should detach
			send({"deviFinished":"Execution finished detach with ctrl + d"})
		}
	});
}

```

`templates/function_dumper.js.j2`:

```j2
{%- from "_macros.js.j2" import argparse, function_header -%}
{{ function_header(bv, func) }}
let index = 0;

Interceptor.attach(func_{{ func.start }}_ptr, {
	onEnter(args) {
		if (index > 50) {
			Interceptor.detachAll();
			throw new Error(`{{ func.name }}: Maximum call depth exceeded (${index - 1}), detaching all intercepts`);
		}

		this.index = index;
		send({
			"context": this.context,
			"return": this.returnAddress.sub(func_{{ func.start }}_module),
			"depth": this.depth,
			"thread_id": this.threadId,
			"index": index++,
			"args": {
				{% for param in func.parameter_vars -%}
					{%- set index = loop.index0 | string -%}
					"{{ param.name }}": {{- argparse(param, "args[" + index + "]") -}},
				{% endfor %}
			}
		})
	},
	onLeave(retval) {
		send({
			"context": this.context ? this.context : {},
			"retval": retval ? retval : "",
			"index": this.index,
		})
	}
});

```

`templates/function_dumper_report.md.j2`:

```j2
# Function Dump report for {{ func.name }}

{% for frame in data -%}
{%- if "args" in frame.keys() -%}
## Function Call {{ frame["index"] }}

- Depth: {{ data.depth }}
- Callee: {{ "%#x" % (bv.start + frame["return"]) }}
- Thread ID: {{ frame["thread_id"] }}
- Arguments:
{%- for key, value in frame["args"].items() %}
  - {{ key }}: {{ value }}
{%- endfor %}
{%- else -%}
## Function Return {{ frame["index"] }}

- Return Value: {{ frame["retval"] }}
{%- endif %}


### Context

| Register | Value |
|----------|-------|
{%- for key, value in frame["context"].items() %}
| `{{ key }}` | **{{ value }}** |
{%- endfor %}
---
{% endfor %}

```

`templates/function_inspector.js.j2`:

```j2
{%- from "_macros.js.j2" import function_header -%}
{{ function_header(bv, func) }}
const basic_blocks = [
	{% for bb in func.basic_blocks -%}
		{%- if loop.index != 1 -%}
		func_{{ func.start }}_module.add({{ "%#x" % (bb.start - bv.start) }}),
		{%- endif %}
	{% endfor %}
];

let hooked_blocks = {}

Interceptor.attach(func_{{ func.start }}_ptr, {
	onEnter: function(args) {
		for (const block of basic_blocks) {
			const instr = Instruction.parse(block)
			const page = Memory.alloc(Process.pageSize);
			const return_ptr = block.add(1)

			hooked_blocks[block] = page;

			// Move the code to the new memory page
			Memory.patchCode(page, 64, code => {
				const writer = new X86Writer(code, { pc: code });
				const relocator = new X86Relocator(block, writer);

				relocator.readOne();
				relocator.writeOne();

				writer.putJmpAddress(return_ptr);
				writer.flush();
			});

			// Add a breakpoint to the original code
			Memory.patchCode(block, 64, function(code) {
				const writer = new X86Writer(code, {pc: code})
				writer.putBreakpoint();
				writer.putNopPadding(instr.size - 1);
			});
		}
	}
});

Process.setExceptionHandler(args => {
	if(args.type === "breakpoint"){
		// Send the basic block offset to the python script as we don't know the module base address
		send(args.address.sub(func_{{ func.start }}_module));

		args.context["pc"] = hooked_blocks[args.address];
		return true;
	}

	console.log(args.type)
	return false
});

```

`templates/hooker.js.j2`:

```j2
{%- from "_macros.js.j2" import argparse, function_header, type_translate -%}

{%- for func in targets -%}
{{ function_header(bv, func) }}
{% if "@replace" in func.comment -%}
function func_{{ func.start }}_replace({{ func.parameter_vars | map(attribute="name") | join(", ") }}) {
	{{ func.comment.split("@replace:")[1].split("\n")[0].strip() }}
}
Interceptor.replace(func_{{ func.start }}_ptr, new NativeCallback(func_{{ func.start }}_replace, {{ type_translate(func.return_type) }}, [{% for p in func.parameter_vars %}{{ type_translate(p.type) }}, {% endfor %}]))
{% elif "@attach" in func.comment -%}
{% else -%}
Interceptor.attach(func_{{ func.start }}_ptr, {
	onEnter: function(args) {
		send({
			"event": "call",
			"function": "{{ func.name }}",
			"address": {{ "%#x" % func.start }},
			"args": {
				{%- for param in func.parameter_vars -%}
					{%- set index = loop.index0 | string -%}
					{{ param.name }}: {{- argparse(param, "args[" + index + "]") -}},
				{%- endfor -%}
			}
		});

		{%- if "@prehook" in func.comment %}
		{% for param in func.parameter_vars %}
			{%- set index = loop.index0 | string -%}
			const {{ param.name }} = {{- argparse(param, "args[" + index + "]") -}};
		{% endfor %}
		{{ func.comment.split("@prehook:")[1].split("\n")[0].strip() }};
		{%- endif %}
	},
	onLeave: function(retval) {
		{%- if "@ret" in func.comment -%}
		{%- set new_retval = func.comment.split("@ret:")[1].split("\n")[0].strip() -%}
		{%- endif %}
		send({
			"event": "return",
			"function": "{{ func.name }}",
			"address": {{ "%#x" % func.start }},
			"retval": retval,
			{% if "@ret" in func.comment %}
			"new_retval": {{ new_retval }},
			{% endif %}
		});

		{%- if "@posthook" in func.comment %}
		{{ func.comment.split("@posthook:")[1].split("\n")[0].strip() }}
		{% endif -%}
		{%- if "@ret" in func.comment %}
		retval.replace({{ new_retval }})
		{%- endif %}
	}
});
{% endif -%}
{% endfor %}

```

`templates/log_sniffer.js.j2`:

```j2
const mainThread = Process.enumerateThreads()[0];

Stalker.follow(mainThread.id, {
	events: {
		call: true,
	},

	onCallSummary(summary) {
		send(summary);
	},
});

```

`templates/repl.js`:

```js
// From https://github.com/frida/frida-tools/blob/main/frida_tools/repl.py
rpc.exports = {
	evaluate(expression) {
		try {
			const result = eval(expression);
			if (result instanceof ArrayBuffer) {
				return result;
			} else {
				const type = (result === null) ? 'null' : typeof result;
				return [type, result];
			}
		} catch (e) {
			return ['error', {
				name: e.name,
				message: e.message,
				stack: e.stack
			}];
		}
	},
}

// Object.defineProperty(rpc, 'exports', {
// 	get() {
// 		return rpcExports;
// 	},
// 	set(value) {
// 		for (const [k, v] of Object.entries(value)) {
// 			rpcExports[k] = v;
// 		}
// 	}
// });

```