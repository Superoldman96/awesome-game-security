Project Path: arc_gmh5225_battlefield-2042-internal-sdk_vojrlnur

Source Tree:

```txt
arc_gmh5225_battlefield-2042-internal-sdk_vojrlnur
├── Classes.hpp
├── Enums.hpp
├── Functions.hpp
├── Offsets.hpp
├── README.md
├── Vector.cpp
└── Vector.hpp

```

`Classes.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>
#include <vector>
#include <cstdint>
#include <d3dx10math.h>

#include "Vector.hpp"
#include "Offsets.hpp"
#include "Enums.hpp"
#include "Functions.hpp"

using namespace SDK;

std::pair<float, float> ScreenMetrics;
std::uintptr_t GameModule;

#define AFIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

inline auto IsValidPtr(void* const pointer) -> bool { 
	return (pointer && pointer > (void*)0xFFFFFF && pointer < (void*)0x7FFFFFFFFFFF);
}

namespace SDK
{
#define MAX_PLAYER_COUNT 128
#define MAX_ENTITY_COUNT 1024

	void InitSDK()
	{
		ScreenMetrics = std::make_pair(GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
		GameModule = reinterpret_cast<std::uintptr_t>(GetModuleHandleA(nullptr));
	}

	template <typename TElement>
	class cArray
	{
	public:
		inline auto get_count() -> size_t
		{
			return this->_size;
		}

		inline auto get_max_size() -> size_t
		{
			return this->_maxsize;
		}

		inline auto get_buffer() -> TElement 
		{
			return _buffer;
		}

		inline auto get_by_idx(int _index) -> TElement
		{
			return _buffer[_index];
		}

	private:
		char pad_0x01[0x10];
		size_t _size;
		size_t _maxsize;
		TElement _buffer[];
	};

	class cString
	{
	public:
		inline auto ptr() -> bool
		{
			return IsValidPtr((void*)_pbuffer);
		}

		inline auto c_str() -> const char*
		{
			if (this->ptr())
				return this->_pbuffer;

			return this->_buffer;
		}

		inline auto to_str() -> std::string
		{
			if (this->ptr())
				return std::string(this->_pbuffer);

			return std::string(this->_buffer);
		}

	private:
		union {
			char* _pbuffer;
			char _buffer[16];
		};
	};

	class cGameRenderer
	{
	public:
		auto GetRenderView() -> uintptr_t
		{
			return *reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(this) + offsets::RenderView);
		}

		static auto GetInstance(uintptr_t Base = GameModule) -> cGameRenderer*
		{
			return *reinterpret_cast<cGameRenderer**>(Base + offsets::GameRenderer);
		}
	};

	class cHealthComponent
	{
	public:
		auto GetHealth() -> float
		{
			return *reinterpret_cast<float*>(reinterpret_cast<uintptr_t>(this) + offsets::Health);
		}

		auto GetMaxHealth() -> float
		{
			return *reinterpret_cast<float*>(reinterpret_cast<uintptr_t>(this) + offsets::MaxHealth);
		}
	};

	class cWeapon
	{
	public:
		auto GetName() -> cString
		{
			return *reinterpret_cast<cString*>(reinterpret_cast<uintptr_t>(this) + offsets::WeaponName);
		}
	};

	class cActiveWeapon
	{
	public:
		auto GetWeapon() -> cWeapon*
		{
			return *reinterpret_cast<cWeapon**>(reinterpret_cast<uintptr_t>(this) + offsets::Weapon);
		}

		auto GetActiveSlot() -> int
		{
			return *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + offsets::ActiveSlot);
		}
	};

	class cWeaponComponent
	{
	public:
		auto GetWeapons() -> cArray<cWeapon*>*
		{
			return *reinterpret_cast<cArray<cWeapon*>**>(reinterpret_cast<uintptr_t>(this) + offsets::WeaponArray);
		}

		auto GetActiveWeapon() -> cActiveWeapon*
		{
			return *reinterpret_cast<cActiveWeapon**>(reinterpret_cast<uintptr_t>(this) + offsets::ActiveWeapon);
		}
	};

	class cClEntity
	{
	public:
		auto GetTransformInternal(D3DMATRIX* Transform)
		{
			return functions::VirtualCall<offsets::GetTransform, void>(this, Transform);
		}

		auto GetTransformAABBInternal(D3DMATRIX* Transform)
		{
			return functions::VirtualCall<offsets::GetTransformAABB, void>(this, Transform);
		}
	};

	class cSoldierEntity : public cClEntity
	{
	public:
		auto GetPosition() -> utils::maths::vec3_t
		{
			return *reinterpret_cast<utils::maths::vec3_t*>(reinterpret_cast<uintptr_t>(this) + offsets::RootPosition);
		}

		auto GetHealthComponent() -> cHealthComponent*
		{
			return *reinterpret_cast<cHealthComponent**>(reinterpret_cast<uintptr_t>(this) + offsets::HealthComponent);
		}

		auto GetWeaponComponent() -> cWeaponComponent*
		{
			return *reinterpret_cast<cWeaponComponent**>(reinterpret_cast<uintptr_t>(this) + offsets::WeaponComponent);
		}

		auto GetActiveWeaponName() -> const char*
		{
			const auto WeaponComponent = this->GetWeaponComponent();

			if (!IsValidPtr((void*)WeaponComponent))
				return nullptr;

			const auto ActiveWeapon = WeaponComponent->GetActiveWeapon();

			if (!IsValidPtr((void*)ActiveWeapon))
				return nullptr;

			const auto Weapon = ActiveWeapon->GetWeapon();

			if (!IsValidPtr((void*)Weapon))
				return nullptr;

			const auto WeaponName = Weapon->GetName().c_str();

			if (!IsValidPtr((void*)WeaponName))
				return nullptr;
	
			return WeaponName;
		}

		auto IsVisible() -> bool
		{
			return !*reinterpret_cast<bool*>(reinterpret_cast<uintptr_t>(this) + offsets::IsHidden);
		}

		auto GetYawAngle() -> float
		{
			return *reinterpret_cast<float*>(reinterpret_cast<uintptr_t>(this) + offsets::YawAngle);
		}
	};

	class cClientEntity
	{
	public:

	};

	class cClientPlayer : public cClientEntity
	{
	public:
		auto GetName() -> cString
		{
			return *reinterpret_cast<cString*>(reinterpret_cast<uintptr_t>(this) + offsets::PlayerName);
		}

		auto GetTeamId() -> int
		{
			return *reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(this) + offsets::PlayerTeamId);
		}

		auto GetSoldierEntity() -> cSoldierEntity*
		{
			return *reinterpret_cast<cSoldierEntity**>(reinterpret_cast<uintptr_t>(this) + offsets::PlayerSoldierEntity);
		}
	};

	class cVehicleData
	{
	public:
		auto GetNameSid() -> cString
		{
			return *reinterpret_cast<cString*>(reinterpret_cast<uintptr_t>(this) + offsets::VehicleNameSid);
		}
	};

	class cVehicleEntity : public cClEntity
	{
	public:
		auto GetPosition(utils::maths::vec3_t* Position, bool Internal = true) -> bool
		{
			D3DMATRIX Transform{};

			if (!Internal)
			{
				auto pCollection =
					*reinterpret_cast<uintptr_t*>(reinterpret_cast<uintptr_t>(this) + offsets::TransformCollection);

				if (!IsValidPtr((void*)pCollection))
					return false;

				int8_t _9 = *reinterpret_cast<int8_t*>(pCollection + 9);
				int8_t _10 = *reinterpret_cast<int8_t*>(pCollection + 10);

				uintptr_t ComponentCollectionOffset = 0x20 * (_9 + (2 * _10));

				Transform = *reinterpret_cast<D3DMATRIX*>(pCollection + ComponentCollectionOffset + 0x10);
			}
			else
			{
				this->GetTransformAABBInternal(&Transform);
			}

			*Position = functions::ExtractPos(Transform);

			return true;
		}

		auto GetVehicleData() -> cVehicleData*
		{
			return *reinterpret_cast<cVehicleData**>(reinterpret_cast<uintptr_t>(this) + offsets::VehicleData);
		}
	};

	class cClientVehicle : public cClientEntity
	{
	public:
		auto GetVehicleEntity() -> cVehicleEntity*
		{
			return *reinterpret_cast<cVehicleEntity**>(reinterpret_cast<uintptr_t>(this) + offsets::VehicleEntity);
		}
	};

	class cLocalPlayer : public cClientPlayer
	{
	public:

	};

	class cClientPlayerMgr
	{
	public:
		auto GetLocalPlayerArray() -> uintptr_t*
		{
			return *reinterpret_cast<uintptr_t**>(reinterpret_cast<uintptr_t>(this) + offsets::LocalPlayerArray);
		}

		auto GetClientPlayersArray() -> cArray<cClientEntity*>*
		{
			return *reinterpret_cast<cArray<cClientEntity*>**>(reinterpret_cast<uintptr_t>(this) + offsets::ClientPlayerArray);
		}

		auto GetLocalPlayer() -> cLocalPlayer*
		{
			auto lpArray = this->GetLocalPlayerArray();

			if (!IsValidPtr((void*)lpArray))
				return nullptr;

			return (cLocalPlayer*)lpArray[0];
		}

		auto GetAllClientPlayers(cArray<cClientEntity*>* const clpArray, cLocalPlayer* const lPlayer) -> std::vector<cClientEntity*>
		{
			std::vector<cClientEntity*> clBuffer;

			for (int i = 0; i < MAX_PLAYER_COUNT; i++)
			{
				const auto ClientPlayer = clpArray->get_by_idx(i);

				if (!IsValidPtr((void*)ClientPlayer))
					continue;

				if ((uintptr_t)ClientPlayer == (uintptr_t)lPlayer)
					continue;

				clBuffer.push_back(ClientPlayer);
			}

			return clBuffer;
		}
	};

	class cGameContext
	{
	public:
		auto GetClientPlayerMgr() -> cClientPlayerMgr*
		{
			return *reinterpret_cast<cClientPlayerMgr**>(reinterpret_cast<uintptr_t>(this) + offsets::ClientPlayerManager);
		}

		static auto GetInstance(uintptr_t Base = GameModule) -> cGameContext*
		{
			return *reinterpret_cast<cGameContext**>(Base + offsets::GameContext);
		}
	};
}
```

`Enums.hpp`:

```hpp
#pragma once

#include "Classes.hpp"

namespace SDK
{
	namespace enums
	{
		enum PoseType : uint8_t
		{
			Stand = 26,
			Crounched = 0,
			Lying = 102
		};

		enum BoneIdx : uint8_t
		{
			Reference = 0,
			AITrajectory = 1,
			Hips = 2,
			Spine = 3,
			Spine1 = 4,
			Spine2 = 5,
			Neck = 6,
			Neck1 = 7,
			Head = 8,
			HeadEnd = 9,
			FACIAL_C_FacialRoot = 10,
			FACIAL_LOD1_C_Forehead = 11,
			FACIAL_LOD1_L_ForeheadIn = 12,
			FACIAL_LOD1_R_ForeheadIn = 13,
			FACIAL_LOD1_L_ForeheadMid = 14,
			FACIAL_LOD1_R_ForeheadMid = 15,
			FACIAL_LOD1_L_ForeheadOut = 16,
			FACIAL_LOD1_R_ForeheadOut = 17,
			FACIAL_LOD1_L_EyesackUpper = 18,
			FACIAL_LOD1_R_EyesackUpper = 19,
			FACIAL_LOD1_L_EyelidUpperFurrow = 20,
			FACIAL_LOD1_R_EyelidUpperFurrow = 21,
			FACIAL_LOD1_L_EyelidUpper = 22,
			FACIAL_LOD1_R_EyelidUpper = 23,
			FACIAL_LOD1_L_Eyeball = 24,
			FACIAL_LOD1_L_Pupil = 25,
			FACIAL_LOD1_R_Eyeball = 26,
			FACIAL_LOD1_R_Pupil = 27,
			FACIAL_LOD1_L_EyelidLower = 28,
			FACIAL_LOD1_R_EyelidLower = 29,
			FACIAL_LOD1_L_EyesackLower = 30,
			FACIAL_LOD1_R_EyesackLower = 31,
			FACIAL_LOD1_L_CheekInner = 32,
			FACIAL_LOD1_R_CheekInner = 33,
			FACIAL_LOD1_L_CheekOuter = 34,
			FACIAL_LOD1_R_CheekOuter = 35,
			FACIAL_LOD1_C_NoseBridge = 36,
			FACIAL_LOD1_L_NasolabialBulge = 37,
			FACIAL_LOD1_R_NasolabialBulge = 38,
			FACIAL_LOD1_L_NasolabialFurrow = 39,
			FACIAL_LOD1_R_NasolabialFurrow = 40,
			FACIAL_LOD1_L_CheekLower = 41,
			FACIAL_LOD1_R_CheekLower = 42,
			FACIAL_LOD1_L_Ear = 43,
			FACIAL_LOD1_R_Ear = 44,
			FACIAL_LOD1_C_Nose = 45,
			FACIAL_LOD1_C_NoseLower = 46,
			FACIAL_LOD1_L_Nostril = 47,
			FACIAL_LOD1_R_Nostril = 48,
			FACIAL_LOD1_C_Mouth = 49,
			FACIAL_LOD1_C_LipUpper = 50,
			FACIAL_LOD1_C_LipUpperInner = 51,
			FACIAL_LOD1_L_LipUpper = 52,
			FACIAL_LOD1_L_LipUpperInner = 53,
			FACIAL_LOD1_R_LipUpper = 54,
			FACIAL_LOD1_R_LipUpperInner = 55,
			FACIAL_LOD1_L_LipUpperOuter = 56,
			FACIAL_LOD1_L_LipUpperOuterInner = 57,
			FACIAL_LOD1_R_LipUpperOuter = 58,
			FACIAL_LOD1_R_LipUpperOuterInner = 59,
			FACIAL_LOD1_L_LipCorner = 60,
			FACIAL_LOD1_L_LipCornerInner = 61,
			FACIAL_LOD1_R_LipCorner = 62,
			FACIAL_LOD1_R_LipCornerInner = 63,
			FACIAL_LOD1_C_LipLower = 64,
			FACIAL_LOD1_C_LipLowerInner = 65,
			FACIAL_LOD1_L_LipLower = 66,
			FACIAL_LOD1_L_LipLowerInner = 67,
			FACIAL_LOD1_R_LipLower = 68,
			FACIAL_LOD1_R_LipLowerInner = 69,
			FACIAL_LOD1_L_LipLowerOuter = 70,
			FACIAL_LOD1_L_LipLowerOuterInner = 71,
			FACIAL_LOD1_R_LipLowerOuter = 72,
			FACIAL_LOD1_R_LipLowerOuterInner = 73,
			FACIAL_LOD1_C_Jaw = 74,
			FACIAL_LOD1_C_Chin = 75,
			FACIAL_LOD1_L_ChinSide = 76,
			FACIAL_LOD1_R_ChinSide = 77,
			FACIAL_LOD1_C_Tongue1 = 78,
			FACIAL_LOD1_C_Tongue2 = 79,
			FACIAL_LOD1_C_Tongue3 = 80,
			FACIAL_LOD1_C_Tongue4 = 81,
			FACIAL_LOD1_L_Masseter = 82,
			FACIAL_LOD1_R_Masseter = 83,
			FACIAL_LOD1_C_UnderChin = 84,
			FACIAL_LOD1_L_UnderChin = 85,
			FACIAL_LOD1_R_UnderChin = 86,
			Head_Prop = 87,
			Head_Phys = 88,
			FACIAL_C_Neck2Root = 89,
			FACIAL_LOD1_C_AdamsApple = 90,
			HeadRoll = 91,
			Neck_Phys = 92,
			SpineX = 93,
			Wep_Aim = 94,
			SpineXRight = 95,
			RightShoulder = 96,
			RightArm = 97,
			RightForeArm = 98,
			RightHand = 99,
			RightHandAttach = 100,
			RightHandIndex0 = 101,
			RightHandIndex1 = 102,
			RightHandIndex2 = 103,
			RightHandIndex3 = 104,
			RightHandIndex4 = 105,
			RightHandMiddle0 = 106,
			RightHandMiddle1 = 107,
			RightHandMiddle2 = 108,
			RightHandMiddle3 = 109,
			RightHandMiddle4 = 110,
			RightHandThumb0 = 111,
			RightHandThumb1 = 112,
			RightHandThumb2 = 113,
			RightHandThumb3 = 114,
			RightHandThumb4 = 115,
			RightHandPinky0 = 116,
			RightHandPinky1 = 117,
			RightHandPinky2 = 118,
			RightHandPinky3 = 119,
			RightHandPinky4 = 120,
			RightHandRing0 = 121,
			RightHandRing1 = 122,
			RightHandRing2 = 123,
			RightHandRing3 = 124,
			RightHandRing4 = 125,
			RightForeArmRoll = 126,
			RightForeArmRoll1 = 127,
			RightForeArmRoll2 = 128,
			RightForeArm_Upper = 129,
			RightForeArm_Lower = 130,
			RightElbowRoll = 131,
			RightArmRoll = 132,
			RightArmRoll1 = 133,
			RightArmBend = 134,
			RightShoulder_Phys = 135,
			SpineXLeft = 136,
			LeftShoulder = 137,
			LeftArm = 138,
			LeftForeArm = 139,
			LeftHand = 140,
			LeftHandAttach = 141,
			LeftHandIndex0 = 142,
			LeftHandIndex1 = 143,
			LeftHandIndex2 = 144,
			LeftHandIndex3 = 145,
			LeftHandIndex4 = 146,
			LeftHandMiddle0 = 147,
			LeftHandMiddle1 = 148,
			LeftHandMiddle2 = 149,
			LeftHandMiddle3 = 150,
			LeftHandMiddle4 = 151,
			LeftHandThumb0 = 152,
			LeftHandThumb1 = 153,
			LeftHandThumb2 = 154,
			LeftHandThumb3 = 155,
			LeftHandThumb4 = 156,
			LeftHandPinky0 = 157,
			LeftHandPinky1 = 158,
			LeftHandPinky2 = 159,
			LeftHandPinky3 = 160,
			LeftHandPinky4 = 161,
			LeftHandRing0 = 162,
			LeftHandRing1 = 163,
			LeftHandRing2 = 164,
			LeftHandRing3 = 165,
			LeftHandRing4 = 166,
			LeftForeArmRoll = 167,
			LeftForeArmRoll1 = 168,
			LeftForeArmRoll2 = 169,
			LeftForeArm_Upper = 170,
			LeftForeArm_Lower = 171,
			LeftElbowRoll = 172,
			LeftArmRoll = 173,
			LeftArmRoll1 = 174,
			LeftArmBend = 175,
			LeftShoulder_Phys = 176,
			Wep_SpineX = 177,
			Wep_Root = 178,
			Wep_Align = 179,
			Wep_Trigger = 180,
			Wep_Slide = 181,
			Wep_Grenade1 = 182,
			Wep_Grenade2 = 183,
			IK_Joint_LeftHand = 184,
			IK_Joint_RightHand = 185,
			Wep_Physic1 = 186,
			Wep_Physic2 = 187,
			Wep_Physic3 = 188,
			Wep_Physic4 = 189,
			Wep_Physic5 = 190,
			Wep_Extra1 = 191,
			Wep_Extra2 = 192,
			Wep_Extra3 = 193,
			Wep_Extra4 = 194,
			Wep_Extra5 = 195,
			Wep_FX = 196,
			Wep_ButtStock = 197,
			IK_Dyn_LeftHand = 198,
			IK_Dyn_RightHand = 199,
			Wep_Belt1 = 200,
			Wep_Belt2 = 201,
			Wep_Belt3 = 202,
			Wep_Belt4 = 203,
			Wep_Belt5 = 204,
			Wep_Belt6 = 205,
			Wep_Belt7 = 206,
			Wep_Belt8 = 207,
			Wep_Belt9 = 208,
			Wep_Belt10 = 209,
			Wep_Mag = 210,
			Wep_Mag_Ammo = 211,
			Wep_Mag_Extra1 = 212,
			Wep_Scope1 = 213,
			Wep_Scope2 = 214,
			Wep_Bipod1 = 215,
			Wep_Bipod2 = 216,
			Wep_Bipod3 = 217,
			Wep_Belt_Out1 = 218,
			Wep_Belt_Out2 = 219,
			Wep_Belt_Out3 = 220,
			Wep_Belt_Out4 = 221,
			Wep_Belt_Out5 = 222,
			Wep_Belt_Out6 = 223,
			Wep_Belt_Out7 = 224,
			Wep_Belt_Out8 = 225,
			Wep_Belt_Out9 = 226,
			Wep_Belt_Out10 = 227,
			Wep_Charm1 = 228,
			Spine2_Phys = 229,
			RightArmpit = 230,
			RightDeltoidBulge = 231,
			LeftArmpit = 232,
			LeftDeltoidBulge = 233,
			BackPackAnchor = 234,
			BackPackRoot = 235,
			BackPackPhys = 236,
			Spine1_Phys = 237,
			Spine_Phys = 238,
			LeftUpLeg = 239,
			LeftKneeUp = 240,
			LeftUpLegRoll = 241,
			LeftUpLegRoll_Phys = 242,
			LeftKneeRoll = 243,
			LeftKneeUp_Phys = 244,
			LeftLeg = 245,
			LeftKneeLow = 246,
			LeftKneeLow_Phys = 247,
			LeftFoot = 248,
			LeftToeBase = 249,
			LeftToe = 250,
			LeftFootAttach = 251,
			LeftAnkle = 252,
			LeftHipsRoll = 253,
			RightUpLeg = 254,
			RightKneeUp = 255,
			RightUpLegRoll = 256,
			RightUpLegRoll_Phys = 257,
			RightKneeRoll = 258,
			RightKneeUp_Phys = 259,
			RightLeg = 260,
			RightKneeLow = 261,
			RightKneeLow_Phys = 262,
			RightFoot = 263,
			RightToeBase = 264,
			RightToe = 265,
			RightFootAttach = 266,
			RightAnkle = 267,
			RightHipsRoll = 268,
			Hips_Phys = 269,
			Trajectory = 270,
			TrajectoryEnd = 271,
			CameraBase = 272,
			CameraJoint = 273,
			WepRootOffset = 274,
			Connect = 275,
			ConnectEnd = 276,
			LeftFootPhaseEnd = 277,
			RightFootPhaseEnd = 278,
			RightAnkleEffectorAux = 279,
			LeftAnkleEffectorAux = 280,
			Wep_ProxyRoot = 281,
			Wep_Proxy1 = 282,
			Wep_Proxy2 = 283,
			Wep_ProxyExtra1 = 284,
			Wep_ProxyExtra2 = 285,
			SpineX_Driver = 286,
			FacePosesAnimation = 287
		};
	}
}
```

`Functions.hpp`:

```hpp
#pragma once
#include "Classes.hpp"

namespace SDK
{
	namespace functions
	{
		template< size_t index, typename type, typename ...argument_list >
		type VirtualCall(void* instance, argument_list ...list) {
			using fn_t = type(__thiscall*)(void*, decltype(list) ...);
			auto fn = (*reinterpret_cast<fn_t**>(instance))[index];
			return fn(instance, list ...);
		}

		inline auto ExtractPos(D3DMATRIX Transform) -> utils::maths::vec3_t {
			return utils::maths::vec3_t(Transform._41, Transform._42, Transform._43);
		};

		bool WorldToScreen(uintptr_t pRenderView, utils::maths::vec3_t WorldPos, utils::maths::vec3_t* ScreenPos, float Width = ScreenMetrics.first, float Height = ScreenMetrics.second)
		{
			D3DXMATRIX ViewProjection = *reinterpret_cast<D3DXMATRIX*>(pRenderView + offsets::ViewProjection);

			float mX = Width * 0.5f;
			float mY = Height * 0.5f;

			float w = ViewProjection.m[0][3] * WorldPos.x + ViewProjection.m[1][3] * WorldPos.y + ViewProjection.m[2][3] * WorldPos.z + ViewProjection.m[3][3];

			if (w < 0.01)
				return false;

			ScreenPos->x = ViewProjection.m[0][0] * WorldPos.x + ViewProjection.m[1][0] * WorldPos.y + ViewProjection.m[2][0] * WorldPos.z + ViewProjection.m[3][0];
			ScreenPos->y = ViewProjection.m[0][1] * WorldPos.x + ViewProjection.m[1][1] * WorldPos.y + ViewProjection.m[2][1] * WorldPos.z + ViewProjection.m[3][1];

			float invw = 1.0f / w;

			ScreenPos->x *= invw;
			ScreenPos->y *= invw;

			float x = (float)Width / 2;
			float y = (float)Height / 2;

			x += 0.5 * ScreenPos->x * (float)Width + 0.5;
			y -= 0.5 * ScreenPos->y * (float)Height + 0.5;

			ScreenPos->x = x;
			ScreenPos->y = y;

			if (ScreenPos->x > Width || ScreenPos->y > Height || ScreenPos->x < 0 || ScreenPos->y < 0)
				return false;

			return true;
		}
	}
}

```

`Offsets.hpp`:

```hpp
#pragma once

#include "Classes.hpp"

namespace SDK
{
	namespace offsets
	{
		// Renderer
		static constexpr auto GameRenderer = 0x62CF960;
		static constexpr auto RenderView = 0x60;
		static constexpr auto ViewProjection = 0x480;

		// Game
		static constexpr auto GameContext = 0x621BE48;
		static constexpr auto ClientPlayerManager = 0xA8;
		static constexpr auto ClientPlayerArray = 0x570;
		static constexpr auto LocalPlayerArray = 0x560;

		// Entity
		static constexpr auto PlayerSoldierEntity = 0xC8;
		static constexpr auto VehicleEntity = 0xB8;

		// Player
		static constexpr auto PlayerName = 0x20;
		static constexpr auto PlayerTeamId = 0x60;

		// Entity
		static constexpr auto GetTransform = 27; /* VTable Index */
		static constexpr auto GetTransformAABB = 26; /* VTable Index */

		// SoldierEntity
		static constexpr auto WeaponComponent = 0x1590;
		static constexpr auto HealthComponent = 0x1C60;
		static constexpr auto RootPosition = 0x20E0;
		static constexpr auto IsHidden = 0x2A0;
		static constexpr auto YawAngle = 0x1318;

		// VehicleEntity
		static constexpr auto TransformCollection = 0x60;
		static constexpr auto VehicleData = 0x38;
		static constexpr auto VehicleNameSid = 0x280;

		// HealthComponent
		static constexpr auto Health = 0x40;
		static constexpr auto MaxHealth = 0x44;

		// WeaponComponent
		static constexpr auto WeaponArray = 0x4A70;
		static constexpr auto ActiveWeapon = 0x4AB8;

		// ActiveWeapon
		static constexpr auto Weapon = 0x38;
		static constexpr auto ActiveSlot = 0x40;

		// Weapon
		static constexpr auto WeaponName = 0x1D0;
	}
}
```

`README.md`:

```md
# battlefield-2042-internal-sdk
Internal Software Development Kit for Battlefield 2042

SDK Includes the following:

- Entity Classes
- Player Classes
- Vehicle Classes
- Weapon Classes
- GameContext Class
- GameRenderer Class
- ClientPlayerManager Class
- WorldToScreen Utility
- Other Useful Utilities

Note: SDK may have issues as it is not fully complete yet, I am still working on it. Entity list iteration is kind of broken as I cannot find the array count to properly iterate it

Usage:

```cpp
        /* Initialize Module Address and Resolution */
        SDK::Init();
	
	const auto GameRenderer = cGameRenderer::GetInstance();

	if (!IsValidPtr((void*)GameRenderer))
		return;

	const auto RenderView = GameRenderer->GetRenderView();

	if (!IsValidPtr((void*)RenderView))
		return;

	const auto GameContext = cGameContext::GetInstance();

	if (!IsValidPtr((void*)GameContext))
		return;

	const auto ClientPlayerManager = GameContext->GetClientPlayerMgr();

	if (!IsValidPtr((void*)ClientPlayerManager))
		return;

	const auto LocalPlayer = ClientPlayerManager->GetLocalPlayer();

	if (!IsValidPtr((void*)LocalPlayer))
		return;

	const auto lpTeamId = LocalPlayer->GetTeamId();

	const auto lpSoldierEntity = LocalPlayer->GetSoldierEntity();

	if (!IsValidPtr((void*)lpSoldierEntity))
		return;

	const auto lpPosition = lpSoldierEntity->GetPosition();

	if (lpPosition.empty())
		return;

	const auto ClientPlayerArray = ClientPlayerManager->GetClientPlayersArray();

	if (!IsValidPtr((void*)ClientPlayerArray))
		return;

	auto IsSoldier = [](cClientEntity* const clPlayer) -> bool {
		return IsValidPtr((void*)static_cast<cClientPlayer*>(clPlayer)->GetSoldierEntity());
	};

	auto IsInVehicle = [](cClientEntity* const clPlayer) -> bool {
		return IsValidPtr((void*)static_cast<cClientVehicle*>(clPlayer)->GetVehicleEntity());
	};

	for (const auto ClientPlayer : 
		ClientPlayerManager->GetAllClientPlayers(ClientPlayerArray, LocalPlayer))
	{
		if (IsSoldier(ClientPlayer))
		{
			const auto SoldierEntity = static_cast<cClientPlayer*>(ClientPlayer)->GetSoldierEntity();

			if (!IsValidPtr((void*)SoldierEntity))
				continue;

			const auto TeamId = static_cast<cClientPlayer*>(ClientPlayer)->GetTeamId();

			if (TeamId == lpTeamId)
				continue;

			const auto HealthComponent = SoldierEntity->GetHealthComponent();

			if (!IsValidPtr((void*)HealthComponent))
				continue;

			auto Health = HealthComponent->GetHealth();
			auto MaxHealth = HealthComponent->GetMaxHealth();

			if (Health <= 0.f || MaxHealth <= 0.f)
				continue;

			auto PlayerName = static_cast<cClientPlayer*>(ClientPlayer)->GetName().c_str();

			const auto CurrentPosition = SoldierEntity->GetPosition();

			if (CurrentPosition.empty())
				continue;

			auto Distance = lpPosition.distance(CurrentPosition);

			utils::maths::vec3_t ScreenPosition;
			if (!functions::WorldToScreen(RenderView, CurrentPosition, &ScreenPosition))
				continue;

			if (ConfigSys.esp_player)
			{
				rendering::Renderer::GetInstance()->DrawNameTag(PlayerName,
					{ ScreenPosition.x, ScreenPosition.y + 5.f },
					{ 139.f, 69.f, 19.f, 255.f },
					Distance,
					ConfigSys.font_size,
					true,
					Health,
					MaxHealth);
			}
		}

		if (IsInVehicle(ClientPlayer))
		{
			const auto VehicleEnity = static_cast<cClientVehicle*>(ClientPlayer)->GetVehicleEntity();

			if (!IsValidPtr((void*)VehicleEnity))
				continue;

			utils::maths::vec3_t CurrentPosition;
			if (!VehicleEnity->GetPosition(&CurrentPosition))
				continue;

			if (CurrentPosition.empty())
				continue;

			utils::maths::vec3_t ScreenPosition;
			if (!functions::WorldToScreen(RenderView, CurrentPosition, &ScreenPosition))
				continue;
        
			auto Distance = lpPosition.distance(CurrentPosition);

			if (ConfigSys.esp_player)
			{
				rendering::Renderer::GetInstance()->DrawNameTag("Vehicle",
					{ ScreenPosition.x, ScreenPosition.y + 5.f },
					{ 119.f, 80.f, 19.f, 255.f },
					Distance,
					ConfigSys.font_size,
					false);
			}
		}
	}  
  ```


```

`Vector.cpp`:

```cpp
#include "Vector.hpp"

using namespace SDK::utils::maths;

vector4::vector4( )
{
}

vector4::vector4( float x, float y, float z, float w )
	: x( x ), y( y ), z( z ), w( w )
{
}

vector4& vector4::operator+=( const vector4& vector )
{
	x += vector.x;
	y += vector.y;
	z += vector.z;
	w += vector.w;

	return *this;
}

vector4& vector4::operator-=( const vector4& vector )
{
	x -= vector.x;
	y -= vector.y;
	z -= vector.z;
	w -= vector.w;

	return *this;
}

vector4& vector4::operator*=( float number )
{
	x *= number;
	y *= number;
	z *= number;
	w *= number;

	return *this;
}

vector4& vector4::operator/=( float number )
{
	x /= number;
	y /= number;
	z /= number;
	w /= number;

	return *this;
}
```

`Vector.hpp`:

```hpp
#pragma once
#include <algorithm>
#include <cmath>

namespace SDK
{
	namespace utils
	{
		namespace maths
		{
			class vector2
			{
			public:
				vector2( )
				{
					x = y = 0.f;
				}

				vector2( float fx, float fy )
				{
					x = fx;
					y = fy;
				}

				float x, y;

				vector2 operator+( const vector2& input ) const
				{
					return vector2{ x + input.x, y + input.y };
				}

				vector2 operator-( const vector2& input ) const
				{
					return vector2{ x - input.x, y - input.y };
				}

				vector2 operator/( float input ) const
				{
					return vector2{ x / input, y / input };
				}

				vector2 operator*( float input ) const
				{
					return vector2{ x * input, y * input };
				}

				vector2& operator-=( const vector2& v )
				{
					x -= v.x;
					y -= v.y;
					return *this;
				}

				vector2& operator/=( float input )
				{
					x /= input;
					y /= input;
					return *this;
				}

				vector2& operator*=( float input )
				{
					x *= input;
					y *= input;
					return *this;
				}

				float length( ) const
				{
					return std::sqrt( ( x * x ) + ( y * y ) );
				}

				vector2 normalized( ) const
				{
					return { x / length( ), y / length( ) };
				}

				vector2 normalize( ) const
				{
					return { x * length( ), y * length( ) };
				}

				float dot_product( vector2 input ) const
				{
					return ( x * input.x ) + ( y * input.y );
				}

				float distance( vector2 input ) const
				{
					return ( *this - input ).length( );
				}

				bool empty( ) const
				{
					return x == 0.f && y == 0.f;
				}
			};

			class vector3
			{
			public:
				vector3( )
				{
					x = y = z = 0.f;
				}

				vector3( float fx, float fy, float fz )
				{
					x = fx;
					y = fy;
					z = fz;
				}

				float x, y, z;

				vector3 operator+( const vector3& input ) const
				{
					return vector3{ x + input.x, y + input.y, z + input.z };
				}

				vector3 operator+=(vector3 input)
				{
					return { x += input.x, y += input.y, z += input.z };
				}

				vector3 operator-( const vector3& input ) const
				{
					return vector3{ x - input.x, y - input.y, z - input.z };
				}

				vector3 operator/( float input ) const
				{
					return vector3{ x / input, y / input, z / input };
				}

				vector3 operator*( float input ) const
				{
					return vector3{ x * input, y * input, z * input };
				}

				vector3& operator-=( const vector3& v )
				{
					x -= v.x;
					y -= v.y;
					z -= v.z;

					return *this;
				}

				vector3& operator/=( float input )
				{
					x /= input;
					y /= input;
					z /= input;
					return *this;
				}

				vector3& operator*=( float input )
				{
					x *= input;
					y *= input;
					z *= input;
					return *this;
				}

				bool operator==( const vector3& input ) const
				{
					return x == input.x && y == input.y && z == input.z;
				}

				void make_absolute( )
				{
					x = std::abs( x );
					y = std::abs( y );
					z = std::abs( z );
				}

				float length_sqr( ) const
				{
					return ( x * x ) + ( y * y ) + ( z * z );
				}

				float length( ) const
				{
					return std::sqrt( length_sqr( ) );
				}

				float length_2d( ) const
				{
					return std::sqrt( ( x * x ) + ( y * y ) );
				}

				vector3 normalized( ) const
				{
					return { x / length( ), y / length( ), z / length( ) };
				}

				void normalize_angle()
				{
					while (x > 89.0f)
						x -= 180.f;

					while (x < -89.0f)
						x += 180.f;

					//while (y > 180.f)
					//	y -= 360.f;

					//while (y < -180.f)
					//	y += 360.f;
				}

				float dot_product( vector3 input ) const
				{
					return ( x * input.x ) + ( y * input.y ) + ( z * input.z );
				}

				float distance( vector3 input ) const
				{
					return ( *this - input ).length( );
				}

				float distance_2d( vector3 input ) const
				{
					return ( *this - input ).length_2d( );
				}

				void clamp( )
				{
					//std::clamp( x, -89.f, 89.f );
					//std::clamp( y, -180.f, 180.f );

					z = 0.f;
				}

				bool empty( ) const
				{
					return x == 0.f && y == 0.f && z == 0.f;
				}
			};

			class vector4
			{
			public:
				float x;
				float y;
				float z;
				float w;

				vector4( );
				vector4( float x, float y, float z, float w );

				vector4 operator+( const vector4& vector ) const;
				vector4 operator-( const vector4& vector ) const;
				vector4 operator-( ) const;
				vector4 operator*( float number ) const;
				vector4 operator/( float number ) const;

				vector4& operator+=( const vector4& vector );
				vector4& operator-=( const vector4& vector );
				vector4& operator*=( float number );
				vector4& operator/=( float number );

				bool operator==( const vector4& vector ) const;
				bool operator!=( const vector4& vector ) const;

				inline float Dot( const vector4& vector )
				{
					return x * vector.x + y * vector.y + z * vector.z + w * vector.w;
				}

				inline float Distance( const vector4& vector )
				{
					return sqrt(
						( x - vector.x ) * ( x - vector.x ) +
						( y - vector.y ) * ( y - vector.y ) +
						( z - vector.z ) * ( z - vector.z ) +
						( w - vector.w ) * ( w - vector.w ) );
				}
			};

			inline bool vector4::operator==( const vector4& vector ) const
			{
				return x == vector.x && y == vector.y && z == vector.z && w == vector.w;
			}

			inline bool vector4::operator!=( const vector4& vector ) const
			{
				return x != vector.x || y != vector.y || z != vector.z || w != vector.w;
			}

			inline vector4 vector4::operator+( const vector4& vector ) const
			{
				return vector4( x + vector.x, y + vector.y, z + vector.z, w + vector.w );
			}

			inline vector4 vector4::operator-( const vector4& vector ) const
			{
				return vector4( x - vector.x, y - vector.y, z - vector.z, w - vector.w );
			}

			inline vector4 vector4::operator-( ) const
			{
				return vector4( -x, -y, -z, -w );
			}

			inline vector4 vector4::operator*( float number ) const
			{
				return vector4( x * number, y * number, z * number, w * number );
			}

			inline vector4 vector4::operator/( float number ) const
			{
				return vector4( x / number, y / number, z / number, w / number );
			}

			class matrix
			{
			public:
				inline float* operator[]( int i )
				{
					return m [ i ];
				}

				inline const float* operator[]( int i ) const
				{
					return m [ i ];
				}

				inline float* Base( )
				{
					return &m [ 0 ][ 0 ];
				}

				inline const float* Base( ) const
				{
					return &m [ 0 ][ 0 ];
				}
			public:

				inline matrix( )
				{
				}

				inline matrix(
					float m00, float m01, float m02, float m03,
					float m10, float m11, float m12, float m13,
					float m20, float m21, float m22, float m23,
					float m30, float m31, float m32, float m33 )
				{
					Init(
						m00, m01, m02, m03,
						m10, m11, m12, m13,
						m20, m21, m22, m23,
						m30, m31, m32, m33
					);
				}

				inline void Init(
					float m00, float m01, float m02, float m03,
					float m10, float m11, float m12, float m13,
					float m20, float m21, float m22, float m23,
					float m30, float m31, float m32, float m33
				)
				{
					m [ 0 ][ 0 ] = m00;
					m [ 0 ][ 1 ] = m01;
					m [ 0 ][ 2 ] = m02;
					m [ 0 ][ 3 ] = m03;

					m [ 1 ][ 0 ] = m10;
					m [ 1 ][ 1 ] = m11;
					m [ 1 ][ 2 ] = m12;
					m [ 1 ][ 3 ] = m13;

					m [ 2 ][ 0 ] = m20;
					m [ 2 ][ 1 ] = m21;
					m [ 2 ][ 2 ] = m22;
					m [ 2 ][ 3 ] = m23;

					m [ 3 ][ 0 ] = m30;
					m [ 3 ][ 1 ] = m31;
					m [ 3 ][ 2 ] = m32;
					m [ 3 ][ 3 ] = m33;
				}

				matrix transpose( ) const
				{
					return matrix(
						m [ 0 ][ 0 ], m [ 1 ][ 0 ], m [ 2 ][ 0 ], m [ 3 ][ 0 ],
						m [ 0 ][ 1 ], m [ 1 ][ 1 ], m [ 2 ][ 1 ], m [ 3 ][ 1 ],
						m [ 0 ][ 2 ], m [ 1 ][ 2 ], m [ 2 ][ 2 ], m [ 3 ][ 2 ],
						m [ 0 ][ 3 ], m [ 1 ][ 3 ], m [ 2 ][ 3 ], m [ 3 ][ 3 ] );
				}

				float m [ 4 ][ 4 ];
			};

			using vec2_t = vector2;
			using vec3_t = vector3;
			using vec4_t = vector4;
			using mat4x4_t = matrix;

			struct Matrix34
			{
				vector4 vec0;
				vector4 vec1;
				vector4 vec2;
			};
		}
	}
}

```