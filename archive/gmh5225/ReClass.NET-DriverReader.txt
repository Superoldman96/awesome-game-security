Project Path: arc_gmh5225_ReClass.NET-DriverReader_itrharwg

Source Tree:

```txt
arc_gmh5225_ReClass.NET-DriverReader_itrharwg
├── LICENSE
├── Makefile
├── Native
│   ├── DriverReader.cpp
│   ├── DriverReader.h
│   ├── Makefile
│   ├── SamplePlugin.vcxproj
│   ├── SamplePlugin.vcxproj.filters
│   ├── SamplePluginNative.rc
│   ├── dllmain.cpp
│   ├── exports.def
│   └── resource.h
├── README.md
└── ReClass.NET DriverReader.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2016 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
all: debug release

clean: clean_debug clean_release

debug:
	cd Managed && make debug
	cd Native && make debug

clean_debug:
	cd Managed && make clean_debug
	cd Native && make clean_debug

release:
	cd Managed && make release
	cd Native && make release

clean_release:
	cd Managed && make clean_release
	cd Native && make clean_release

```

`Native/DriverReader.cpp`:

```cpp
#include "DriverReader.h"


HANDLE DriverReader::hDeviceDrv = NULL;
char DriverReader::targetProc[];
char DriverReader::previousTargetProc[];
uintptr_t DriverReader::DTBTargetProcess = 0;
uintptr_t DriverReader::virtualSizeTargetProcess = 0;
uintptr_t DriverReader::pBaseAddressTargetProcess = 0;
uintptr_t DriverReader::pVadRootTargetProcess = 0;
uintptr_t DriverReader::pPEBTargetProcess = 0;
std::vector<EnumerateRemoteSectionData> DriverReader::sections;
std::vector<EnumerateRemoteModuleData> DriverReader::modules;

int DriverReader::getDeviceHandle(LPTSTR name)
{
	DriverReader::hDeviceDrv = CreateFile(name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (DriverReader::hDeviceDrv == INVALID_HANDLE_VALUE)
	{
		std::cout << "[-] Handle failed: " << std::dec << GetLastError() << std::endl;
		return 1;
	}
	std::cout << "[+] HANDLE obtained" << std::endl;
	return 0;
}



ULONG64 fn_mapPhysical(ULONG64 physicaladdress, DWORD size)
{
	READ_REQUEST inbuffer = { 0, 0, physicaladdress, 0, size };
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverReader::hDeviceDrv,
		IOCTL_GIO_MAPPHYSICAL,
		&inbuffer,
		sizeof(inbuffer),
		&outbuffer,
		sizeof(outbuffer),
		&bytes_returned,
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

ULONG64 fn_unmapPhysical(ULONG64 address)
{
	ULONG64 inbuffer = address;
	ULONG64 outbuffer[2] = { 0 };
	DWORD bytes_returned = 0;
	DeviceIoControl(DriverReader::hDeviceDrv,
		IOCTL_GIO_UNMAPPHYSICAL,
		(LPVOID)&inbuffer,
		sizeof(inbuffer),
		(LPVOID)outbuffer,
		sizeof(outbuffer),
		&bytes_returned,
		(LPOVERLAPPED)NULL);

	return outbuffer[0];
}

BOOL GIO_memcpy(ULONG64 dest, ULONG64 src, DWORD size)
{
	MEMCPY_REQUEST mystructIn = { dest, src, size };
	BYTE outbuffer[0x30] = { 0 };
	DWORD returned = 0;

	DeviceIoControl(DriverReader::hDeviceDrv, IOCTL_GIO_MEMCPY, (LPVOID)&mystructIn, sizeof(mystructIn), (LPVOID)outbuffer, sizeof(outbuffer), &returned, NULL);
	if (returned) {
		return TRUE;
	}
	return FALSE;
}


// Read a Physical memory
bool ReadPhyMemory(uintptr_t physicalAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead)
{
	// Read physical memory
	uint64_t memory = fn_mapPhysical(physicalAddress, nSize);

	if (!memory)
		return false;

	// Copy the buffer so we can free the mapped memory
	memcpy((void*)lpBuffer, (const void*)memory, nSize);

	// Free mapped memory
	fn_unmapPhysical(memory);

	return true;

}

uint64_t VAtoPhylAddress(uintptr_t directoryTableBase, LPVOID virtualAddress)
{
	uintptr_t va = (uint64_t)virtualAddress;

	// PMl4 - Page Map level 4
	// PDPT - Page Directory Pointer Table
	// PD - Page Directory
	// PT - Page Table 
	unsigned short PML4 = (USHORT)((va >> (12 + 9 + 9 + 9)) & 0x1FF);
	unsigned short PDPT = (USHORT)((va >> (12 + 9 + 9)) & 0x1FF);
	unsigned short PD = (USHORT)((va >> (12 + 9)) & 0x1FF);
	unsigned short PT = (USHORT)((va >> 12) & 0x1FF);
	////std::cout << "- virtualAddress " << virtualAddress << std::endl;
	////std::cout << "- directoryTableBase" << directoryTableBase << std::endl;
	////std::cout << "- PML4 " << PML4 << std::endl;
	////std::cout << "- PDPT " << PDPT << std::endl;
	////std::cout << "- PD " << PD << std::endl;
	////std::cout << "- PT " << PT << std::endl;

	// Obtain the PML4 Entry (PML4E)
	uintptr_t PML4E = 0;
	ReadPhyMemory(directoryTableBase + PML4 * sizeof(ULONGLONG), &PML4E, sizeof(uint64_t), NULL);
	//std::cout << "- PML4E " << PML4E << std::endl;
	if (PML4E == 0)
		return 0;

	// Obtain the PDPT Entry. It is the base address of the next table
	uintptr_t PDPTE = 0;
	ReadPhyMemory((PML4E & 0xFFFFFFFFFF000) + PDPT * sizeof(ULONGLONG), &PDPTE, sizeof(uint64_t), NULL);
	////std::cout << "- PDPTE " << PDPTE << std::endl;
	if (PDPTE == 0)
		return 0;

	// Checking this bit will allow us to determinate if PDPTE maps a 1GB page or not.
	// In that case we need to calculate the final base address extracting bits 51-30 (0xFFFFFC0000000) 
	// from PDPTE nad bits 29-0 from the VA (0x3FFFFFFF).
	if ((PDPTE & (1 << 7)) != 0)
		return (PDPTE & 0xFFFFFC0000000) + (va & 0x3FFFFFFF);

	// If PS bit was zero we need to obtain the base address of the next table on the chain.
	uint64_t PDE = 0;
	ReadPhyMemory((PDPTE & 0xFFFFFFFFFF000) + PD * sizeof(ULONGLONG), &PDE, sizeof(uint64_t), NULL);
	////std::cout << "- PDE " << PDE << std::endl;
	if (PDE == 0)
		return 0;

	// Again we need to check the PS flag for PDE, in this case it will be a 2MB page if 1.
	// In that case we need to calculate the final base address extracting bits 51-21 (0xFFFFFFFE00000)
	// from PDE and 20-0 from the VA (0x1FFFFF)
	if ((PDE & (1 << 7)) != 0)
		return (PDE & 0xFFFFFFFE00000) + (va & 0x1FFFFF);

	// Let's obtain the PT entry if PS was 0.
	uintptr_t PTE = 0;
	ReadPhyMemory((PDE & 0xFFFFFFFFFF000) + PT * sizeof(ULONGLONG), &PTE, sizeof(uint64_t), NULL);
	////std::cout << "- PTE " << PTE << std::endl;

	if (PTE == 0)
		return 0;

	// Each PTE corresponds to a 4KB page. Final physical address is obtaining extracting the bits 51-12 from the PTE (0xFFFFFFFFFF000)
	// and the 11-0 from the VA (0xFFF).
	return (PTE & 0xFFFFFFFFFF000) + (va & 0xFFF);
}


// Write a VirtualMemory (Kernel or Usermode)
bool DriverReader::WriteVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{

	// Translate Virtual to physical
	uint64_t physicalAddress = VAtoPhylAddress(directoryTableBase,  (LPVOID) virtualAddress);

	// Control if physicalAddress is valid
	if (!physicalAddress)
		return false;

	// Read physical memory
	uint64_t memory = fn_mapPhysical(physicalAddress, nSize);

	if (!memory)
		return false;

	// Copy the new value to the already mapped physical memory
	memcpy((void*)memory, (const void*)lpBuffer , nSize);

	// Free mapped memory so we can persist the changes
	fn_unmapPhysical(memory);

	return true;
}

bool DriverReader::ReadVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead)
{
	//std::cout << virtualAddress << std::endl;
	// Translate Virtual to physical
	uint64_t physicalAddress = VAtoPhylAddress(directoryTableBase, (LPVOID)virtualAddress);

	// std::cout << physicalAddress << std::endl;
	// Control if physicalAddress is valid
	if (!physicalAddress)
		return false;

	// Read physical memory
	uint64_t memory = fn_mapPhysical(physicalAddress, nSize);

	if (!memory)
		return false;

	// Copy the buffer so we can free the mapped memory
	memcpy((void*)lpBuffer, (const void*)memory, nSize);

	// Free mapped memory
	fn_unmapPhysical(memory);

	return true;
}

// From here we are implementing the V2 of DriverHelper. Focus will be set on implementing functions that allows us to exploit a driver and perform actions like: dump the target process and RWMemory from kernel.
// We can leak a kernel pointer to an EPROCESS structure. We can use this to traverse over the double linked list to enumerate every process.
bool DriverReader::LeakKernelPointers(std::vector<uintptr_t> &pKernelPointers)
{

	SYSTEM_HANDLE_INFORMATION_EX* pHandleInfo = NULL;

	// Initial size of the buffer, we are going to make it bigger if it is necesary later
	DWORD lBuffer = 0x10000;

	// This option will allow us to get the list of kernel pointers
	const unsigned long SystemExtendedHandleInformation = 0x40;

	DWORD retSize = 0;
	NTSTATUS status;

	do {
		if (pHandleInfo != NULL) {
			// Cleaning the buffer if this is not the first execution of the DO
			HeapFree(GetProcessHeap(), 0, pHandleInfo);
			pHandleInfo = NULL;
		}

		// Expanding the buffer *2
		lBuffer *= 2;

		// Dinamically allocate memory on the Heap for the buffer. I tried to use VirtualAlloc but it didn't work.
		pHandleInfo = (SYSTEM_HANDLE_INFORMATION_EX*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lBuffer);

		if (pHandleInfo == NULL)
		{
			std::cout << "[-] LeakKernelPointer pHandleInfo NULL" << std::endl;
			return false;
		}
	} while ((status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemExtendedHandleInformation), pHandleInfo, lBuffer, &retSize)) == STATUS_INFO_LENGTH_MISMATCH);

	/*
	The returned structure will have the following definition
	typedef struct SYSTEM_HANDLE_INFORMATION_EX
	{
		ULONG_PTR NumberOfHandles;
		ULONG_PTR Reserved;
		SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
	};
	*/

	std::cout << "[+] LeakKernelPointer NUmberOfHandles: " << pHandleInfo->NumberOfHandles << std::endl;
	// NumberOfHandles will tell us how many times we need to iterate the array.
	for (unsigned int i = 0; i < pHandleInfo->NumberOfHandles; i++)
	{
		// Lets get all the handles from the process with PID 4 (system)
		ULONG SystemPID = 4;
		// Atribbute value for Process HANDLEs
		ULONG ProcessHandleAttribute = 0x102A;

		// Is this the best option? Maybe there is a better one
		if (pHandleInfo->Handles[i].UniqueProcessId == SystemPID && pHandleInfo->Handles[i].HandleAttributes == ProcessHandleAttribute)
		{
			pKernelPointers.push_back(reinterpret_cast<uintptr_t>(pHandleInfo->Handles[i].Object));
		}

	}
	return true;
}


// Thanks to https://twitter.com/SpecialHoang for this function
// https://github.com/hoangprod/DanSpecial/blob/master/DanSpecial/memory.cpp
uintptr_t DriverReader::FindDirectoryBase()
{
	printf("[+] Attempting to find Dirbase.\n");

	for (int i = 0; i < 10; i++)
	{
		uintptr_t lpBuffer = fn_mapPhysical(i * 0x10000, 0x10000);

		for (int uOffset = 0; uOffset < 0x10000; uOffset += 0x1000)
		{

			if (0x00000001000600E9 ^ (0xffffffffffff00ff & *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset)))
				continue;
			if (0xfffff80000000000 ^ (0xfffff80000000000 & *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset + 0x70)))
				continue;
			if (0xffffff0000000fff & *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset + 0xa0))
				continue;

			return *reinterpret_cast<uintptr_t*>(lpBuffer + uOffset + 0xa0);
		}

		fn_unmapPhysical((lpBuffer));
	}

	return NULL;
}


/*

0: kd> dd  0xffffbe8c2141d040
ffffbe8c`2141d040  00b60003 00000000 2141d048 ffffbe8c		<==== 00b60003 if KPROCESS
ffffbe8c`2141d050  2141d048 ffffbe8c 2141d058 ffffbe8c
ffffbe8c`2141d060  2141d058 ffffbe8c 001ab000 00000000
ffffbe8c`2141d070  214aa338 ffffbe8c 25089338 ffffbe8c
ffffbe8c`2141d080  00000000 00000000 00000000 00000000
ffffbe8c`2141d090  00140001 00000000 00000003 00000000
ffffbe8c`2141d0a0  00000000 00000000 00000000 00000000
ffffbe8c`2141d0b0  00000000 00000000 00000000 00000000


0: kd> dt nt!_KPROCESS 0xffffbe8c2141d040
   +0x000 Header           : _DISPATCHER_HEADER
   +0x018 ProfileListHead  : _LIST_ENTRY [ 0xffffbe8c`2141d058 - 0xffffbe8c`2141d058 ]
   +0x028 DirectoryTableBase : 0x1ab000
   +0x030 ThreadListHead   : _LIST_ENTRY [ 0xffffbe8c`214aa338 - 0xffffbe8c`25089338 ]
   +0x040 ProcessLock      : 0

*/
// This is necessary to check if the pointer we have its a KPROCESS pointer :)
uintptr_t DriverReader::ObtainKProcessPointer(uint64_t directoryTableBase, std::vector<uintptr_t> pKernelPointers)
{
	//The header of a KPROCESS has the value 00b60003
	unsigned int KProcessHeader = 0x00b60003;

	unsigned int bHeader = 0;

	for (uintptr_t pointer : pKernelPointers)
	{
		// read header
		DriverReader::ReadVirtualMemory(directoryTableBase, pointer, &bHeader, sizeof(unsigned int), NULL);


		// Compare Header with value
		if (bHeader == KProcessHeader)
		{
			std::cout << "[+] ObtainKProcessPointer found." << std::endl;
			return pointer;
		}

		std::cout << "[-] ObtainKProcessPointer not found." << std::endl;
	}

	return 0;

}

uintptr_t DriverReader::GetKProcess(uintptr_t &directoryTableBase)
{
	// Define the vector of pointers to return
	std::vector<uintptr_t> pKernelPointers;

	// We need the DirectoryBaseTable of the process to translate Virtual to Phyisical Addresses
	directoryTableBase = DriverReader::FindDirectoryBase();

	std::cout << "[+] GetKprocess - directoryTableBase 0x" << std::hex << directoryTableBase << std::endl;

	// Lets use NtQuerySystemInformation with SystemExtendedHandleInformation to get the list of kernel pointers
	if (!(DriverReader::LeakKernelPointers(pKernelPointers)))
		return 0;

	// Validate KProcess Header to identify all the handles to KPROCESS structures.
	auto pKprocess = DriverReader::ObtainKProcessPointer(directoryTableBase, pKernelPointers);

	if (pKprocess == 0)
	{
		std::cout << "[-] ObtainKProcessPointer not found." << std::endl;
		return 0;
	}

	return pKprocess;
}



//0: kd > dt nt!_EPROCESS 0xFFFFDA8ADA8E2800
//+ 0x000 Pcb              : _KPROCESS
//+ 0x2d8 ProcessLock : _EX_PUSH_LOCK
//+ 0x2e0 RundownProtect : _EX_RUNDOWN_REF
//+ 0x2e8 UniqueProcessId : 0x00000000`00000638 Void
//+ 0x2f0 ActiveProcessLinks : _LIST_ENTRY[0xffffda8a`da9634f0 - 0xffffda8a`da86daf0]
//+ 0x450 ImageFileName    : [15]  "spoolsv.exe"
//+ 0x45f PriorityClass : 0x2 ''
//+ 0x460 SecurityPort : (null)
//  +0x3b0 Job              : 0xffffda8a`de7ca860 _EJOB
//   +0x3b8 SectionObject    : 0xffffc98f`cdb93180 Void
//   +0x3c0 SectionBaseAddress : 0x00007ff6`18b50000 Void

uintptr_t DriverReader::SearchKProcess(LPCVOID processName, uintptr_t &directoryTableBase, uintptr_t pKProcess)
{

	uintptr_t initialProcessId = 0;
	DriverReader::ReadVirtualMemory(directoryTableBase, pKProcess + OFFSET_UNIQUEPROCESSID, &initialProcessId, sizeof(initialProcessId), NULL);
	uintptr_t currentProcessId = 0;
	uintptr_t currentKProcess = 0;


	PLIST_ENTRY   initialEntry = (PLIST_ENTRY)(pKProcess + OFFSET_ACTIVEPROCESSLINKS);
	PLIST_ENTRY currentEntry = initialEntry;
	uintptr_t imagefilename_offset = OFFSET_IMAGEFILENAME - OFFSET_ACTIVEPROCESSLINKS;

	do
	{
		char currentKProcessName[15] = { 0 };

		// Obtain KProcessName
		DriverReader::ReadVirtualMemory(directoryTableBase, reinterpret_cast<uintptr_t>(currentEntry) + imagefilename_offset, &currentKProcessName, sizeof(currentKProcessName), NULL);

		if (strcmp(static_cast<const char *>(processName), currentKProcessName) == 0)
		{
			std::cout << "[+] KProcess Target Found: 0x" << std::hex << (uintptr_t)(currentEntry) - OFFSET_ACTIVEPROCESSLINKS << std::endl;
			return (uintptr_t)(currentEntry)-OFFSET_ACTIVEPROCESSLINKS;
		}

		// Set next entry on the list
		DriverReader::ReadVirtualMemory(directoryTableBase, reinterpret_cast<uintptr_t>(currentEntry) + sizeof(uintptr_t), &currentEntry, sizeof(currentEntry), NULL);

	} while (currentEntry != initialEntry);


	return 0;

}


// This function retrieves information from the EProcess/KProcess structure of the target process in kernel.
// All this will be stored on global variables so we can use them anywhere.
bool DriverReader::ObtainKProcessInfo(uintptr_t &directoryTableBase, uintptr_t pKProcessAddress)
{
	std::cout << "\t[+] Grabing info from target process" << std::endl;
	if (!DriverReader::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_SECTIONBASEADDRESS,
		&(DriverReader::pBaseAddressTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the BaseAddress." << std::endl;
		return false;
	}
	std::cout << "\t[+] BaseAddress: 0x" << std::hex << DriverReader::pBaseAddressTargetProcess << std::endl;


	if (!DriverReader::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_DIRECTORYTABLEBASE,
		&(DriverReader::DTBTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the DirectoryTableBase." << std::endl;
		return false;
	}
	std::cout << "\t[+] DirectoryTableBase: 0x" << std::hex << DriverReader::DTBTargetProcess << std::endl;

	if (!DriverReader::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_VIRTUALSIZE,
		&(DriverReader::virtualSizeTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the VirtualSize." << std::endl;
		return false;
	}
	std::cout << "\t[+] VirtualSize: 0x" << std::hex << DriverReader::virtualSizeTargetProcess << std::endl;

if (!DriverReader::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_VADROOT,
		&(DriverReader::pVadRootTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the VadRoot." << std::endl;
		return false;
	}
	std::cout << "\t[+] VadRoot: 0x" << std::hex << DriverReader::pVadRootTargetProcess << std::endl;


	if (!DriverReader::ReadVirtualMemory(directoryTableBase, pKProcessAddress + OFFSET_EPROCESS_PEB,
		&(DriverReader::pPEBTargetProcess), sizeof(uintptr_t), NULL))
	{
		std::cout << "[-] Failed trying to obtain the PEB." << std::endl;
		return false;
	}
	std::cout << "\t[+] PEB: 0x" << std::hex << DriverReader::pPEBTargetProcess << std::endl;


	return true;
}


// Functions that will help us to dump the VadRoot AVL Tree, which has all the memory information about a particular process.

EnumerateRemoteSectionData GetVadNodeInfo(uintptr_t directoryTableBase, uintptr_t node)
{
/*
#define OFFSET_STARTINGVPN 0x018
#define OFFSET_ENDINGVPN 0x01c
#define OFFSET_STARTINGVPNHIGH 0x020
#define OFFSET_ENDINGVPNHIGH 0x021
*/
	uint64_t startingVPNLow = 0;
	uint64_t endingVPNLow = 0;
	uint64_t startingVPNHigh = 0;
	uint64_t endingVPNHigh = 0;
	unsigned long u = 0;

	// Reading the starting and ending VPN.
	DriverReader::ReadVirtualMemory(directoryTableBase, node + OFFSET_STARTINGVPN, &startingVPNLow, sizeof(uint32_t), NULL);
	DriverReader::ReadVirtualMemory(directoryTableBase, node + OFFSET_ENDINGVPN, &endingVPNLow, sizeof(uint32_t), NULL);
	DriverReader::ReadVirtualMemory(directoryTableBase, node + OFFSET_STARTINGVPNHIGH, &startingVPNHigh, sizeof(uint8_t), NULL);
	DriverReader::ReadVirtualMemory(directoryTableBase, node + OFFSET_ENDINGVPNHIGH, &endingVPNHigh, sizeof(uint8_t), NULL);
	
	// Reading the unsigned long u from MMVAD_SHORT
	DriverReader::ReadVirtualMemory(directoryTableBase, node + OFFSET_MMVAD_SHORT_U, &u, sizeof(unsigned long), NULL);

	// We need to put together this two parts, some lshr will doo all the work.
	uint64_t startingVPN = (startingVPNLow << 12) | (startingVPNHigh << 44);
	uint64_t endingVPN = ( (endingVPNLow + 1) << 12 | (endingVPNHigh << 44));

	// Let's create the object for our section.
	EnumerateRemoteSectionData section = {};
	section.BaseAddress = (void *)startingVPN;
	section.Size = endingVPN - startingVPN;

	section.Protection = SectionProtection::NoAccess;
	// To get the Protection Flag we need first to obtain the index of the protection from the _MMVAD_FLAGS->Protection
	//		[+0x000 ( 2: 0)] VadType          : 0x2 [Type: unsigned long]
    //		[+0x000 ( 7: 3)] Protection       : 0x7 [Type: unsigned long]
    //		[+0x000 (13: 8)] PreferredNode    : 0x0 [Type: unsigned long]
    //		[+0x000 (14:14)] NoChange         : 0x0 [Type: unsigned long]
    //		[+0x000 (15:15)] PrivateMemory    : 0x0 [Type: unsigned long]
	//    0xF8 == 11111000  <----- Mask to extract bits 7:3
	DWORD protection = ( u >> 3) & 0x1F;
	protection = ProtectionFlags[protection];

	if ((protection & PAGE_EXECUTE) == PAGE_EXECUTE) section.Protection |= SectionProtection::Execute;
	if ((protection & PAGE_EXECUTE_READ) == PAGE_EXECUTE_READ) section.Protection |= SectionProtection::Execute | SectionProtection::Read;
	if ((protection & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE) section.Protection |= SectionProtection::Execute | SectionProtection::Read | SectionProtection::Write;
	if ((protection & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY) section.Protection |= SectionProtection::Execute | SectionProtection::Read | SectionProtection::CopyOnWrite;
	if ((protection & PAGE_READONLY) == PAGE_READONLY) section.Protection |= SectionProtection::Read;
	if ((protection & PAGE_READWRITE) == PAGE_READWRITE) section.Protection |= SectionProtection::Read | SectionProtection::Write;
	if ((protection & PAGE_WRITECOPY) == PAGE_WRITECOPY) section.Protection |= SectionProtection::Read | SectionProtection::CopyOnWrite;
	if ((protection & PAGE_GUARD) == PAGE_GUARD) section.Protection |= SectionProtection::Guard;

	//  [+0x000 (15:15)] PrivateMemory    : 0x0 [Type: unsigned long]
    //  [+0x000 (16:16)] PrivateFixup     : 0x0 [Type: unsigned long]
    //  [+0x000 (17:17)] ManySubsections  : 0x0 [Type: unsigned long]
    //  [+0x000 (18:18)] Enclave          : 0x0 [Type: unsigned long]
	//  We need the memory type, we can check with the bit 15 if its private memory
	//  TODO: not mandatory, this is why we see an unknown on the GUI when displaying all the sections.

	return section;
}


// Since we can't open a handle to the process and call VirtualQueryEx
void DriverReader::WalkVadAVLTree(uintptr_t directoryTableBase, uintptr_t start)
{

	if (start == NULL)
		return;
	
	// Since we need to traverse a balanced tree, 
	// we first read all the left branches and then we read the right one while we go up again.
	uintptr_t left = 0;
	DriverReader::ReadVirtualMemory(directoryTableBase, start, &left, sizeof(uintptr_t), NULL);

	// Yep, recursion ;)
	WalkVadAVLTree(directoryTableBase, left);

	// Now the right nodes.
	uintptr_t right = 0;
	DriverReader::ReadVirtualMemory(directoryTableBase, start + sizeof(uintptr_t), &right, sizeof(uintptr_t), NULL);

	// We need to obtain information from each node: starting and ending address, protection, etc.
	EnumerateRemoteSectionData section = GetVadNodeInfo(directoryTableBase, start);

	// We push that information so we can later notify ReClass.
	DriverReader::sections.push_back(section);

	// And again recursion
	WalkVadAVLTree(directoryTableBase, right);
}
	
	
void DriverReader::EnumRing3ProcessModules(uintptr_t directoryTableBase)
{
 
	// Variables used to store lpr pointer and data.
	PEB_LDR_DATA ldr;
	uintptr_t pLDR = 0;

	// We need to dereference the pointer and obtain retrieve the whole LDR structure.
	DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, DriverReader::pPEBTargetProcess + OFFSET_PEB_LDR , &pLDR, sizeof(uintptr_t), NULL);
	DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, pLDR , &ldr,sizeof(PEB_LDR_DATA), NULL);

	// InMemoryOrderModuleList will have the head of a linked list.
	// We can traverse the whole list to obtain all the currently loaded modules.
	LIST_ENTRY* head = ldr.InMemoryOrderModuleList.Flink;
	LIST_ENTRY* next = head;

    PLDR_MODULE pLdrModule = nullptr;
	LDR_MODULE LdrModule;
	do
	{
            LDR_DATA_TABLE_ENTRY LdrEntry;
            LDR_DATA_TABLE_ENTRY* Base = CONTAINING_RECORD(head, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

            if (DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, (uintptr_t)Base, &LdrEntry, sizeof(LdrEntry), NULL))
            {
                char* pLdrModuleOffset = reinterpret_cast<char*>(head) - sizeof(LIST_ENTRY);
				
				// Obtaining module pointer
				DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, (uintptr_t)pLdrModuleOffset, &pLdrModule, sizeof(pLdrModule), NULL);
                // Retrieven module information
				DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, (uintptr_t)pLdrModule, &LdrModule, sizeof(LdrModule), NULL);

                if (LdrEntry.DllBase)
                {
					//std::wstring fullname = LdrModule.FullDllName;

					// Retrieve the FullDllName
					WCHAR strFullDllName[MAX_PATH] = { 0 };
					if (DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, 
						reinterpret_cast<uintptr_t>(LdrModule.FullDllName.Buffer),
						&strFullDllName,
						LdrModule.FullDllName.Length, NULL))
					{
						// We create the EnumerateRemoteModuleData so we can return it to ReClass
						EnumerateRemoteModuleData module = {};
						
						// Debuging code :P
						// wprintf(L"Full Dll Name: %s\n", strFullDllName);
						// std::cout<< "BaseAddress:     " << LdrModule.BaseAddress<<std::endl;
						
						module.BaseAddress = LdrModule.BaseAddress;
						std::copy(strFullDllName, strFullDllName + MAX_PATH, module.Path);
						module.Size = LdrModule.SizeOfImage;
						
						// We push the current module into the vecto we later use to notify ReClass
						DriverReader::modules.push_back(module);
					}
                }

                head = LdrEntry.InMemoryOrderLinks.Flink;
            }
        }
        while (head != next);

	return;
}
```

`Native/DriverReader.h`:

```h
#pragma once
#include <stdio.h>
#include <iostream>
#include <vector>
#include <Windows.h>
#include <winternl.h>

#include <ReClassNET_Plugin.hpp>
#pragma comment( lib, "ntdll.lib" )

// IMPORTANT!!! You need to set up this constant to the windows version
// you are going to compile it for.
#define WINVERSION 1607


#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

// GIO Driver
#define IOCTL_GIO_MAPPHYSICAL	0xC3502004
#define IOCTL_GIO_UNMAPPHYSICAL 0xC3502008
#define IOCTL_GIO_MEMCPY 0xC3502808


// Kernel offsets (used for Read Write kernel memory)
#define OFFSET_DIRECTORYTABLEBASE 0x028
#define OFFSET_VIRTUALSIZE 0x338
#define OFFSET_SECTIONBASEADDRESS 0x3c0
#define OFFSET_OBJECTTABLE 0x418
#define OFFSET_IMAGEFILENAME 0x450
#define OFFSET_PRIORITYCLASS 0x45f

// Kernel offsets (used for enumerate modules and sections of a process using kernel memory) w10 1607
#define OFFSET_EPROCESS_PEB 0x3f8
#define OFFSET_PEB_LDR 0x018
#define OFFSET_LDR_InMemoryOrderModuleList 0x20

#if (WINVERSION == 1607)
#define OFFSET_ACTIVEPROCESSLINKS 0x2f0
#define OFFSET_UNIQUEPROCESSID 0x2e8
#define OFFSET_VADROOT 0x620
#endif


#if (WINVERSION == 1703 || WINVERSION == 1709)
#define OFFSET_ACTIVEPROCESSLINKS 0x2e8
#define OFFSET_UNIQUEPROCESSID 0x2e0
#define OFFSET_VADROOT 0x628
#endif


/*
(*((ntkrnlmp!_MMVAD_SHORT *)0xffffb803e0fa73a0))                 [Type: _MMVAD_SHORT]
    [+0x000] VadNode          [Type: _RTL_BALANCED_NODE]
    [+0x000] NextVad          : 0xffffb803dfc39240 [Type: _MMVAD_SHORT *]
    [+0x018] StartingVpn      : 0x96ee040 [Type: unsigned long]
    [+0x01c] EndingVpn        : 0x96ee13f [Type: unsigned long]
	[+0x020] StartingVpnHigh  : 0x0 [Type: unsigned char]
    [+0x021] EndingVpnHigh    : 0x0 [Type: unsigned char]

*/
#define OFFSET_STARTINGVPN 0x018
#define OFFSET_ENDINGVPN 0x01c
#define OFFSET_STARTINGVPNHIGH 0x020
#define OFFSET_ENDINGVPNHIGH 0x021
#define OFFSET_MMVAD_SHORT_U 0x030


const ULONG ProtectionFlags[] = {
	PAGE_NOACCESS,
	PAGE_READONLY,
	PAGE_EXECUTE,
	PAGE_EXECUTE_READ,
	PAGE_READWRITE,
	PAGE_WRITECOPY,
	PAGE_EXECUTE_READWRITE,
	PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_NOCACHE | PAGE_READONLY,
	PAGE_NOCACHE | PAGE_EXECUTE,
	PAGE_NOCACHE | PAGE_EXECUTE_READ,
	PAGE_NOCACHE | PAGE_READWRITE,
	PAGE_NOCACHE | PAGE_WRITECOPY,
	PAGE_NOCACHE | PAGE_EXECUTE_READWRITE,
	PAGE_NOCACHE | PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_GUARD | PAGE_READONLY,
	PAGE_GUARD | PAGE_EXECUTE,
	PAGE_GUARD | PAGE_EXECUTE_READ,
	PAGE_GUARD | PAGE_READWRITE,
	PAGE_GUARD | PAGE_WRITECOPY,
	PAGE_GUARD | PAGE_EXECUTE_READWRITE,
	PAGE_GUARD | PAGE_EXECUTE_WRITECOPY,
	PAGE_NOACCESS,
	PAGE_WRITECOMBINE | PAGE_READONLY,
	PAGE_WRITECOMBINE | PAGE_EXECUTE,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_READ,
	PAGE_WRITECOMBINE | PAGE_READWRITE,
	PAGE_WRITECOMBINE | PAGE_WRITECOPY,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_READWRITE,
	PAGE_WRITECOMBINE | PAGE_EXECUTE_WRITECOPY,
};


// Structure of MAP
typedef struct _READ_REQUEST {
	DWORD InterfaceType;
	DWORD Bus;
	ULONG64 PhysicalAddress;
	DWORD IOSpace;
	DWORD size;
} READ_REQUEST;

typedef struct _WRITE_REQUEST {
	DWORDLONG address;
	DWORD length;
	DWORDLONG buffer;
} WRITE_REQUEST;

typedef struct _MEMCPY_REQUEST {
	ULONG64 dest;
	ULONG64 src;
	DWORD size;
} MEMCPY_REQUEST;

struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX			// Size => 28
{
	PVOID Object;									// Size => 4 Offset =>0
	ULONG UniqueProcessId;							// Size => 4 Offset =>4
	ULONG HandleValue;								// Size => 4 Offset =>8
	ULONG GrantedAccess;							// Size => 4 Offset =>12
	USHORT CreatorBackTraceIndex;					// Size => 2 Offset =>16
	USHORT ObjectTypeIndex;							// Size => 2 Offset =>18
	ULONG HandleAttributes;							// Size => 4 Offset =>20
	ULONG Reserved;									// Size => 4 Offset =>24
};

struct SYSTEM_HANDLE_INFORMATION_EX					// Size => 36
{
	ULONG NumberOfHandles;							// Size => 4 Offset => 0
	ULONG Reserved;									// Size => 4 Offset => 4
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];	// Size => 36 Offset => 8
};


typedef struct _LDR_MODULE
{
	LIST_ENTRY      InLoadOrderModuleList;
	LIST_ENTRY      InMemoryOrderModuleList;
	LIST_ENTRY      InInitializationOrderModuleList;
	PVOID           BaseAddress;
	PVOID           EntryPoint;
	ULONG           SizeOfImage;
	UNICODE_STRING  FullDllName;
	UNICODE_STRING  BaseDllName;
	ULONG           Flags;
	SHORT           LoadCount;
	SHORT           TlsIndex;
	LIST_ENTRY      HashTableEntry;
	ULONG           TimeDateStamp;
} LDR_MODULE, *PLDR_MODULE;


class DriverReader
{
public:
	static int getDeviceHandle(LPTSTR name);
	static bool ReadPhyMemory(uintptr_t physicalAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead);
	static bool WriteVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPVOID  lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
	static bool ReadVirtualMemory(uint64_t directoryTableBase, uintptr_t virtualAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesRead);
	static uintptr_t ObtainKProcessPointer(uint64_t directoryTableBase, std::vector<uintptr_t> pKernelPointers);
	static uintptr_t GetKProcess(uintptr_t &directoryTableBase);
	static uintptr_t SearchKProcess(LPCVOID processName, uintptr_t &directoryTableBase, uintptr_t pKProcess);
	static bool ObtainKProcessInfo(uintptr_t &directoryTableBase, uintptr_t pKProcessAddress);
	//static bool VirtualQueryEx(uintptr_t &directoryTableBase, uintptr_t &infoStructure);
	static bool LeakKernelPointers(std::vector<uintptr_t> &pKernelPointers);
	static uintptr_t FindDirectoryBase();
	static void WalkVadAVLTree(uintptr_t directoryTableBase, uintptr_t start);
	static void EnumRing3ProcessModules(uintptr_t directoryTableBase);


	// Variables
	static HANDLE hDeviceDrv;
	static char targetProc[256];
	static char previousTargetProc[256];
	static uintptr_t DTBTargetProcess;
	static uintptr_t virtualSizeTargetProcess;
	static uintptr_t pBaseAddressTargetProcess;
	static uintptr_t pVadRootTargetProcess;
	static uintptr_t pPEBTargetProcess;
	static std::vector<EnumerateRemoteSectionData> sections;
	static std::vector<EnumerateRemoteModuleData> modules;

};


```

`Native/Makefile`:

```
WORKDIR = `pwd`

CC = gcc
CXX = g++
AR = ar
LD = g++
WINDRES = windres

INC = -I../../ReClass.NET/NativeCore/
CFLAGS = -Wall -fpermissive -fPIC -std=c++14
RESINC =
LIBDIR =
LIB =
LDFLAGS = -shared

INC_DEBUG = $(INC)
CFLAGS_DEBUG = $(CFLAGS) -g
RESINC_DEBUG = $(RESINC)
RCFLAGS_DEBUG = $(RCFLAGS)
LIBDIR_DEBUG = $(LIBDIR)
LIB_DEBUG = $(LIB)
LDFLAGS_DEBUG = $(LDFLAGS)
OBJDIR_DEBUG = obj/debug
DEP_DEBUG =
OUT_DEBUG = build/debug/native_plugin.so

INC_RELEASE = $(INC)
CFLAGS_RELEASE = $(CFLAGS) -O2
RESINC_RELEASE = $(RESINC)
RCFLAGS_RELEASE = $(RCFLAGS)
LIBDIR_RELEASE = $(LIBDIR)
LIB_RELEASE = $(LIB)
LDFLAGS_RELEASE = $(LDFLAGS) -s
OBJDIR_RELEASE = obj/release
DEP_RELEASE =
OUT_RELEASE = build/release/native_plugin.so

OBJ_DEBUG = $(OBJDIR_DEBUG)/dllmain.o

OBJ_RELEASE = $(OBJDIR_RELEASE)/dllmain.o

all: debug release

clean: clean_debug clean_release

before_debug:
	test -d build/debug || mkdir -p build/debug
	test -d $(OBJDIR_DEBUG) || mkdir -p $(OBJDIR_DEBUG)

after_debug:

debug: before_debug out_debug after_debug

out_debug: before_debug $(OBJ_DEBUG) $(DEP_DEBUG)
	$(CXX) $(LIBDIR_DEBUG) -o $(OUT_DEBUG) $(OBJ_DEBUG)  $(LDFLAGS_DEBUG) $(LIB_DEBUG)

$(OBJDIR_DEBUG)/dllmain.o: dllmain.cpp
	$(CXX) $(CFLAGS_DEBUG) $(INC_DEBUG) -c dllmain.cpp -o $(OBJDIR_DEBUG)/dllmain.o

clean_debug:
	rm -f $(OBJ_DEBUG) $(OUT_DEBUG)
	rm -rf build/debug
	rm -rf $(OBJDIR_DEBUG)

before_release:
	test -d build/release || mkdir -p build/release
	test -d $(OBJDIR_RELEASE) || mkdir -p $(OBJDIR_RELEASE)

after_release:

release: before_release out_release after_release

out_release: before_release $(OBJ_RELEASE) $(DEP_RELEASE)
	$(LD) $(LIBDIR_RELEASE) -o $(OUT_RELEASE) $(OBJ_RELEASE)  $(LDFLAGS_RELEASE) $(LIB_RELEASE)

$(OBJDIR_RELEASE)/dllmain.o: dllmain.cpp
	$(CXX) $(CFLAGS_RELEASE) $(INC_RELEASE) -c dllmain.cpp -o $(OBJDIR_RELEASE)/dllmain.o

clean_release:
	rm -f $(OBJ_RELEASE) $(OUT_RELEASE)
	rm -rf build/release
	rm -rf $(OBJDIR_RELEASE)

.PHONY: before_debug after_debug clean_debug before_release after_release clean_release

```

`Native/SamplePlugin.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PluginDriverReader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
    <ProjectName>PluginDriverReader</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IncludePath>..\..\ReClass.NET\NativeCore;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\x64\</OutDir>
    <IncludePath>..\..\ReClass.NET\NativeCore;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IncludePath>..\..\ReClass.NET\NativeCore;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(SolutionDir)bin\$(Configuration)\x64\</OutDir>
    <IncludePath>..\..\ReClass.NET\NativeCore;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;RECLASSNET64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="DriverReader.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverReader.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="SamplePluginNative.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Native/SamplePlugin.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="DriverReader.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Resources">
      <UniqueIdentifier>{593315aa-3e5c-44a1-9ee4-e358209e9a8c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Resources</Filter>
    </ClInclude>
    <ClInclude Include="DriverReader.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="SamplePluginNative.rc">
      <Filter>Resources</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def">
      <Filter>Resources</Filter>
    </None>
  </ItemGroup>
</Project>
```

`Native/SamplePluginNative.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Deutsch (Deutschland) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_DEU)
LANGUAGE LANG_GERMAN, SUBLANG_GERMAN

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040704b0"
        BEGIN
            VALUE "CompanyName", "KN4CK3R"
            VALUE "Comments", "A sample plugin for developers that demonstrates how to use the plugin system."
            VALUE "FileVersion", "1.0.0.0"
            VALUE "FileDescription", "SamplePluginNative"
            VALUE "ProductName", "ReClass.NET Native Plugin"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x407, 1200
    END
END

#endif    // Deutsch (Deutschland) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Native/dllmain.cpp`:

```cpp
#include <cstdint>

// Remove annoying error
#if (_MSC_VER >= 1915)
#define no_init_all deprecated
#endif


#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <algorithm>

#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <ReClassNET_Plugin.hpp>
#include <experimental/filesystem>
#include "DriverReader.h"
namespace fs = std::experimental::filesystem;

// Variables required for the Kernel Driver Exploit ;)
uintptr_t directoryTableBase = 0;
uintptr_t pKProcess = 0;
uintptr_t pBaseAddress = 0;


enum class Platform
{
	Unknown,
	X86,
	X64
};

Platform GetProcessPlatform(HANDLE process)
{
	static USHORT processorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
	if (processorArchitecture == PROCESSOR_ARCHITECTURE_UNKNOWN)
	{
		SYSTEM_INFO info = {};
		GetNativeSystemInfo(&info);

		processorArchitecture = info.wProcessorArchitecture;
	}

	switch (processorArchitecture)
	{
	case PROCESSOR_ARCHITECTURE_INTEL:
		return Platform::X86;
	case PROCESSOR_ARCHITECTURE_AMD64:
		auto isWow64 = FALSE;
		if (IsWow64Process(process, &isWow64))
		{
			return isWow64 ? Platform::X86 : Platform::X64;
		}

#ifdef RECLASSNET64
		return Platform::X64;
#else
		return Platform::X86;
#endif
	}
	return Platform::Unknown;
}

std::string getFileName(const std::string& s)
{
	char sep = '/';

#ifdef _WIN32
	sep = '\\';
#endif

	size_t i = s.rfind(sep, s.length());
	if (i != std::string::npos) {
		return(s.substr(i + 1, s.length() - i));
	}
	return("");
}

/// <summary>Opens the remote process.</summary>
/// <param name="id">The identifier of the process returned by EnumerateProcesses.</param>
/// <param name="desiredAccess">The desired access.</param>
/// <returns>A handle to the remote process or nullptr if an error occured.</returns>
extern "C" RC_Pointer RC_CallConv OpenRemoteProcess(RC_Pointer id, ProcessAccess desiredAccess)
{
	// BEFORE: Open the remote process with the desired access rights and return the handle to use with the other functions.
	// NOW: We are just returning the ID to the process instead. Now each methods takes care of resolving this ID (PID) to the respective process.
	// We need to do this to stop using privileged HANDLEs to the process
	return id;
}

/// <summary>Queries if the process is valid.</summary>
/// <param name="id">The process handle (now PID) obtained by OpenRemoteProcess.</param>
/// <returns>True if the process is valid, false if not.</returns>
extern "C" bool RC_CallConv IsProcessValid(RC_Pointer id)
{
	/*
	if (handle == nullptr)
	{
		return false;
	}

	const auto retn = WaitForSingleObject(handle, 0);
	if (retn == WAIT_FAILED)
	{
		return false;
	}

	return retn == WAIT_TIMEOUT;
	*/

	// BEFORE: Check if the handle is valid.
	// NOW: If is not null it is enough, we are using the PID now instead of a HANDLE
	if (id == nullptr)
	{
		return false;
	}

	return true;
}

/// <summary>Closes the handle to the remote process.</summary>
/// <param name="handle">The process handle obtained by OpenRemoteProcess.</param>
extern "C" void RC_CallConv CloseRemoteProcess(RC_Pointer handle)
{
	// BEFORE: Close the handle to the remote process.
	// NOW: We don't have a HANDLE so it is just a fake function
	return;
	
	/*
	if (handle == nullptr)
	{
		return;
	}

	CloseHandle(handle);
	*/
}


/// <summary>Enumerate all processes on the system.</summary>
/// <param name="callbackProcess">The callback for a process.</param>
extern "C" void RC_CallConv EnumerateProcesses(EnumerateProcessCallback callbackProcess)
{
	// With this trick we'll be able to print content to the console.
	// I let this here, because if you are using this you will probably need to debug, trust me.
	AllocConsole();
	SetConsoleTitle("Debug");
	freopen("CONOUT$", "w", stdout);
	freopen("CONOUT$", "w", stderr);
	freopen("CONIN$", "r", stdin);
	
	// Enumerate all processes with the current plattform (x86/x64) and call the callback.
	if (callbackProcess == nullptr)
	{
		return;
	}

	const auto handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (handle != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32W pe32 = {};
		pe32.dwSize = sizeof(PROCESSENTRY32W);
		if (Process32FirstW(handle, &pe32))
		{
			do
			{
				// TODO: Remove this so we don't need to open a HANDLE to the game, in this case it is just a HANDLE with very limited privileges. Most AC seem to allow this kind of HANDLE.
				// There should be a better way to figure out the platform of the process (x86/x64)
				const auto handle_limited = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION , FALSE, static_cast<DWORD>(pe32.th32ProcessID));

				if (handle_limited == nullptr || handle == INVALID_HANDLE_VALUE)
				{
					continue;
				}

				// if 0 or SYSTEM process, just skip it.
				if (pe32.th32ProcessID == 0 || pe32.th32ProcessID == 4)
					continue;

				if (pe32.th32ProcessID)
				{
					const auto platform = GetProcessPlatform(handle_limited);
					CloseRemoteProcess(handle_limited);
#ifdef RECLASSNET64
					if (platform == Platform::X64)
#else
					if (platform == Platform::X86)
#endif
					{
						EnumerateProcessData data = { };
						data.Id = pe32.th32ProcessID;

						const auto name = fs::path(pe32.szExeFile).filename().u16string();
						const auto path = fs::path(pe32.szExeFile).u16string();
						str16cpy(data.Name, name.c_str(), std::min<size_t>(name.length(), PATH_MAXIMUM_LENGTH - 1));
						str16cpy(data.Path, path.c_str(), std::min<size_t>(path.length(), PATH_MAXIMUM_LENGTH - 1));

						callbackProcess(&data);
					}

				}

				

			} while (Process32NextW(handle, &pe32));
		}

		CloseHandle(handle);
	}

}

// Confirm of prepare if we have all what we need to read a ring3 process memory.
bool CheckKernelStatus(RC_Pointer id)
{
if (id)
	{
		// I'm using a limited HANDLE to get the name of the executable, is this necessary? ;(
		// It is not so uncommon to do this, and AC allow it.
		const auto handle_limited = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION , FALSE, reinterpret_cast<DWORD>(id));

		if (handle_limited == nullptr)
		{
			std::cout << "[-] Unable to get executable name." << std::endl;
			return false;
		}

		// I was to lazy to find another way of getting this.
		if (GetProcessImageFileNameA(handle_limited, DriverReader::targetProc, sizeof(DriverReader::targetProc)))
		{
			strcpy(DriverReader::targetProc,getFileName(DriverReader::targetProc).c_str());
		}
		else
		{
			std::cout << "\t[.] targetProc failed: 0x" << std::hex << GetLastError() << std::endl;
		}
		CloseHandle(handle_limited);
	}

	// Have we selected a new process on ReClass?
	// In that case we have to retrieve all the process information we need.
	if (strcmp(DriverReader::targetProc, DriverReader::previousTargetProc) != 0)
	{
		std::cout << "[.] Process context changed." << std::endl;
		if (DriverReader::getDeviceHandle("\\\\.\\GIO"))
		{
			std::cout << "[-] Driver not loaded" << std::endl;
			return false;
		}

		// Let's store this process as the last one we used for the next time we run this method.
		strcpy(DriverReader::previousTargetProc, DriverReader::targetProc);
	
		// Obtaining a valid pointer to a KProcess.
		// We need this to traverse the linked list of processes and find our target.
		pKProcess = DriverReader::GetKProcess(directoryTableBase);

		// With this pKProcess we traverse it until we find what we want. Our target process.
		pBaseAddress = DriverReader::SearchKProcess(DriverReader::targetProc, directoryTableBase, pKProcess);

		// And now we get all the kernel information we need to work ;)
		if (!DriverReader::ObtainKProcessInfo(directoryTableBase, pBaseAddress))
		{
			std::cout << "[-] ObtainKProcessInfo failed" << std::endl;
			return false;
		}

	}
	return true;
}


/// <summary>Enumerate all sections and modules of the remote process.</summary>
/// <param name="process">The process handle obtained by OpenRemoteProcess.</param>
/// <param name="callbackSection">The callback for a section.</param>
/// <param name="callbackModule">The callback for a module.</param>
void RC_CallConv EnumerateRemoteSectionsAndModules(RC_Pointer id, EnumerateRemoteSectionsCallback callbackSection, EnumerateRemoteModulesCallback callbackModule)
{
	// Enumerate all sections and modules of the remote process and call the callback for them.
	if (callbackSection == nullptr && callbackModule == nullptr && !DriverReader::DTBTargetProcess)
	{
		std::cout << "[-] EnumerateRemoteSectionsAndModules failed" << std::endl;
		return;
	}

	// We need to be sure that everything is setup for this function to run properly. 
	// If not we set it up here
	if (!CheckKernelStatus(id))
	{
		std::cout << "[-] CheckKernelStatus failed" << std::endl;
		return;
	}

	// Reset variables from the last run, and init new ones.
	std::vector<EnumerateRemoteSectionData> sections;
	DriverReader::sections = {};
	DriverReader::modules = {};

	// WalkVadADLTree will do the magic and retrieve all the section information we need.
	DriverReader::WalkVadADLTree(directoryTableBase,DriverReader::pVadRootTargetProcess);

	// I wanted to reuse my previous code so I just reassigned to a local variable
	// You thought you were lazy?
	sections = DriverReader::sections;

	// We already god all the sections, now we nede the modules
	// Here we go.
	DriverReader::EnumRing3ProcessModules(directoryTableBase);


		if (callbackModule != nullptr)
		{
			for (auto&& module: DriverReader::modules)
			{
				// Let's notify to Reclass we got a new module.
				callbackModule(&module);


				// Now we can add additional information to the sections we already have on our vector sections.
				// This can be done parsing the headers from the PE as you can see below.
				if (callbackSection != nullptr)
				{
					auto it = std::lower_bound(std::begin(sections), std::end(sections), static_cast<LPVOID>(module.BaseAddress), [&sections](const auto& lhs, const LPVOID& rhs)
					{
						return lhs.BaseAddress < rhs;
					});

					IMAGE_DOS_HEADER DosHdr = {};
					IMAGE_NT_HEADERS NtHdr = {};

					// Reading the headers.
					DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, (uintptr_t)module.BaseAddress, &DosHdr, sizeof(IMAGE_DOS_HEADER), NULL);
					DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess,  (uintptr_t)(module.BaseAddress) + DosHdr.e_lfanew, &NtHdr, sizeof(IMAGE_NT_HEADERS), NULL);
					
					std::vector<IMAGE_SECTION_HEADER> sectionHeaders(NtHdr.FileHeader.NumberOfSections);
					
					DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, (uintptr_t)(module.BaseAddress) + DosHdr.e_lfanew + sizeof(IMAGE_NT_HEADERS), sectionHeaders.data(), NtHdr.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER), NULL);
					std::cout << NtHdr.FileHeader.NumberOfSections << std::endl;
					for (auto i = 0; i < NtHdr.FileHeader.NumberOfSections; ++i)
					{
						auto&& sectionHeader = sectionHeaders[i];
						const auto sectionAddress = reinterpret_cast<size_t>(module.BaseAddress) + sectionHeader.VirtualAddress;

						for (auto j = it; j != std::end(sections); ++j)
						{
							// We add the path to the executable.
							std::memcpy(j->ModulePath, module.Path, PATH_MAXIMUM_LENGTH * sizeof(RC_UnicodeChar));
							break;
						}

					}
				}
			}
		}

		// Finally, let's notify ReClass about the sections.
		if (callbackSection != nullptr)
		{
			for (auto&& section : sections)
			{
				callbackSection(&section);
			}
		}
}



/// <summary>Reads memory of the remote process.</summary>
/// <param name="handle">The process handle obtained by OpenRemoteProcess.</param>
/// <param name="address">The address to read from.</param>
/// <param name="buffer">The buffer to read into.</param>
/// <param name="offset">The offset into the buffer.</param>
/// <param name="size">The number of bytes to read.</param>
/// <returns>True if it succeeds, false if it fails.</returns>
extern "C" bool RC_CallConv ReadRemoteMemory(RC_Pointer id, RC_Pointer address, RC_Pointer buffer, int offset, int size)
{
	// Read the memory of the remote process into the buffer.	
	if (!CheckKernelStatus(id))
		return false;
	//std::cout << "[+] Reading ########################################" << std::endl;
	//std::cout << "[+] directoryTableBase" << directoryTableBase << std::endl;
	//std::cout << "[+] pKProcess" << pKProcess << std::endl;
	//std::cout << "[+] pBaseAddress" << pBaseAddress << std::endl;
	//std::cout << "[+] address" << address << std::endl;
	//std::cout << "[+] size" << size << std::endl;
	
	buffer = reinterpret_cast<RC_Pointer>(reinterpret_cast<uintptr_t>(buffer) + offset);
	//std::cout << "[+] buffer" << buffer << std::endl;
	//std::cout << "[+] DriverReader::DTBTargetProcess " << DriverReader::DTBTargetProcess << std::endl;

	SIZE_T numberOfBytesRead;
	if (DriverReader::ReadVirtualMemory(DriverReader::DTBTargetProcess, reinterpret_cast<uintptr_t>(address), buffer, size, &numberOfBytesRead))
	{
		return true;
	}
	std::cout << "[-] RVM failed" << std::endl;

	return false;
}

/// <summary>Writes memory to the remote process.</summary>
/// <param name="process">The process handle obtained by OpenRemoteProcess.</param>
/// <param name="address">The address to write to.</param>
/// <param name="buffer">The buffer to write.</param>
/// <param name="offset">The offset into the buffer.</param>
/// <param name="size">The number of bytes to write.</param>
/// <returns>True if it succeeds, false if it fails.</returns>
extern "C" bool RC_CallConv WriteRemoteMemory(RC_Pointer id, RC_Pointer address, RC_Pointer buffer, int offset, int size)
{
	if (!CheckKernelStatus(id))
		return false;

	// Write the buffer into the memory of the remote process.
    buffer = reinterpret_cast<RC_Pointer>(reinterpret_cast<uintptr_t>(buffer) + offset);

	SIZE_T numberOfBytesWritten;
	if (DriverReader::WriteVirtualMemory(DriverReader::DTBTargetProcess, reinterpret_cast<uintptr_t>(address), buffer, size, &numberOfBytesWritten))
	{
		return true;
	}

	return false;
}

/// <summary>Control the remote process (Pause, Resume, Terminate).</summary>
/// <param name="handle">The process handle obtained by OpenRemoteProcess.</param>
/// <param name="action">The action to perform.</param>
extern "C" void RC_CallConv ControlRemoteProcess(RC_Pointer handle, ControlRemoteProcessAction action)
{
	// Perform the desired action on the remote process.
}

/// <summary>Attach a debugger to the process.</summary>
/// <param name="id">The identifier of the process returned by EnumerateProcesses.</param>
/// <returns>True if it succeeds, false if it fails.</returns>
extern "C" bool RC_CallConv AttachDebuggerToProcess(RC_Pointer id)
{
	// Attach a debugger to the remote process.

	return false;
}

/// <summary>Detach a debugger from the remote process.</summary>
/// <param name="id">The identifier of the process returned by EnumerateProcesses.</param>
extern "C" void RC_CallConv DetachDebuggerFromProcess(RC_Pointer id)
{
	// Detach the debugger.
}

/// <summary>Wait for a debug event within the given timeout.</summary>
/// <param name="evt">[out] The occured debug event.</param>
/// <param name="timeoutInMilliseconds">The timeout in milliseconds.</param>
/// <returns>True if an event occured within the given timeout, false if not.</returns>
extern "C" bool RC_CallConv AwaitDebugEvent(DebugEvent* evt, int timeoutInMilliseconds)
{
	// Wait for a debug event.

	return false;
}

/// <summary>Handles the debug event described by evt.</summary>
/// <param name="evt">[in] The (modified) event returned by AwaitDebugEvent.</param>
extern "C" void RC_CallConv HandleDebugEvent(DebugEvent* evt)
{
	// Handle the debug event.
}

/// <summary>Sets a hardware breakpoint.</summary>
/// <param name="processId">The identifier of the process returned by EnumerateProcesses.</param>
/// <param name="address">The address of the breakpoint.</param>
/// <param name="reg">The register to use.</param>
/// <param name="type">The type of the breakpoint.</param>
/// <param name="size">The size of the breakpoint.</param>
/// <param name="set">True to set the breakpoint, false to remove it.</param>
/// <returns>True if it succeeds, false if it fails.</returns>
extern "C" bool RC_CallConv SetHardwareBreakpoint(RC_Pointer id, RC_Pointer address, HardwareBreakpointRegister reg, HardwareBreakpointTrigger type, HardwareBreakpointSize size, bool set)
{
	// Set a hardware breakpoint with the given parameters.

	return false;
}

```

`Native/exports.def`:

```def
LIBRARY
EXPORTS
	IsProcessValid
	OpenRemoteProcess
	CloseRemoteProcess
	ReadRemoteMemory
	WriteRemoteMemory
	EnumerateProcesses
	EnumerateRemoteSectionsAndModules
	ControlRemoteProcess
	AttachDebuggerToProcess
	DetachDebuggerFromProcess
	AwaitDebugEvent
	HandleDebugEvent
	SetHardwareBreakpoint
```

`Native/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SamplePluginNative.rc

```

`README.md`:

```md
# ReClass.NET-DriverReader
Plugin for ReClass.NET (https://github.com/KN4CK3R/ReClass.NET).

This plugin can be used to bypass multiple AC by reading directly the game process from kernel.

All this code is the result of a research done for BlackHat Europe 2019 (London). 

Twitter: [@Niemand_sec](https://twitter.com/niemand_sec)

More info: [Personal Blog](https://niemand.com.ar/)

> Note, the driver used for this program may be already blacklisted, choose your own driver if you don't want to get banned. This driver still works for all of them but you may get banned after a while, they are controlling if this particular driver is loaded while the game is running.

> Only x64 games are supported. The plugin compiles for x86 but some modification are required in order to work properly.

## Compiling
If you want to compile the ReClass.NET Sample Plugins just fork the repository and create the following folder structure. If you don't use this structure you need to fix the project references.

```
..\ReClass.NET\
..\ReClass.NET\ReClass.NET\ReClass.NET.csproj
..\ReClass.NET-SamplePlugin
..\ReClass.NET-SamplePlugin\ReClass.NET SamplePlugin.sln
```

For obvious reasons,the Gigabyte driver is not provided on this repository. But if you are compiling this plugin, I'm pretty sure you will be able to get that driver.

## Configuration

> Remember to configure the constant `WINVERSION` beforing compiling. Versions (x64) 1607, 1703 and 1709 are supported for now.

- 1803+ version are not currently supported due to new security patches added by Windows that restrict the memory access level. Becareful with the security patches there are some KB that backport this fix to older versions, make sure you disable Windows Updates.

- DEBUG Console comes enabled by default, can be disabled on the code. 

## Additional information

This plugin makes use of the module [DriverHelper](https://github.com/niemand-sec/AntiCheat-Testing-Framework/tree/master/DriverHelper) from [AntiCheat-Testing-Framework](https://github.com/niemand-sec/AntiCheat-Testing-Framework). 

DriverHelper has been renamed to DriverReader on this project, and it has been enhaced in order to provide additional features.

Some usefull functions that can be found on this module:

- **EnumRing3ProcessModules**: This function help us to extract from PEB_LDR_DATA all the module information we need.
- **WalkVadAVLTree**: Traverse the VadRoot AVL Tree. The pointer to the head of VadRoot can be found inside EPROCESS structure. By walking the tree it is possible to enumerate all the sections/modules mapped into the Ring3 process. 
- **GetVadNodeInfo**: Extract the required information from each node of the VadRoot AVL Tree (starting/endingVPN, size, protections, etc).



## About this Project

All this code is a result of the Researching presented at BlackHat Europe 2019 (London) "Unveiling the underground world of Anti-Cheats".

Links:
- https://www.blackhat.com/eu-19/briefings/schedule/index.html#unveiling-the-underground-world-of-anti-cheats-17359

```

`ReClass.NET DriverReader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27004.2002
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ReClass.NET", "..\ReClass.NET\ReClass.NET\ReClass.NET.csproj", "{BFB8917D-E9B4-463F-A6E8-612C35728C78}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PluginDriverReader", "Native\SamplePlugin.vcxproj", "{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{E62BB7E9-C977-471E-BDFD-8EAEAAB9C720}"
	ProjectSection(SolutionItems) = preProject
		README.md = README.md
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x64.ActiveCfg = Debug|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x64.Build.0 = Debug|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x86.ActiveCfg = Debug|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Debug|x86.Build.0 = Debug|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x64.ActiveCfg = Release|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x64.Build.0 = Release|x64
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x86.ActiveCfg = Release|x86
		{BFB8917D-E9B4-463F-A6E8-612C35728C78}.Release|x86.Build.0 = Release|x86
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x64.ActiveCfg = Debug|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x64.Build.0 = Debug|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x86.ActiveCfg = Debug|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Debug|x86.Build.0 = Debug|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x64.ActiveCfg = Release|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x64.Build.0 = Release|x64
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x86.ActiveCfg = Release|Win32
		{22CA6FDB-7622-4F94-8FC2-2E7AB481C86F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A4D6E479-778F-44E1-A8AA-43098CD09FC3}
	EndGlobalSection
EndGlobal

```