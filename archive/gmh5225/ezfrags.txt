Project Path: arc_gmh5225_ezfrags_trno7y8h

Source Tree:

```txt
arc_gmh5225_ezfrags_trno7y8h
├── Ezfrags
│   ├── AimAssist.cpp
│   ├── AimAssist.h
│   ├── Aimlock.cpp
│   ├── Aimlock.h
│   ├── BunnyHop.cpp
│   ├── BunnyHop.h
│   ├── Ezfrags.cpp
│   ├── Ezfrags.h
│   ├── Ezfrags.vcxproj
│   ├── Ezfrags.vcxproj.filters
│   ├── Ezfrags.vcxproj.user
│   ├── Get.cpp
│   ├── Get.h
│   ├── GlowESP.cpp
│   ├── GlowESP.h
│   ├── KillMessage.cpp
│   ├── KillMessage.h
│   ├── MemManager.cpp
│   ├── MemManager.h
│   ├── NoFlash.cpp
│   ├── NoFlash.h
│   ├── Radar.cpp
│   ├── Radar.h
│   ├── Settings.hpp
│   ├── ShowFeatures.cpp
│   ├── ShowFeatures.h
│   ├── Signatures.cpp
│   ├── Signatures.h
│   ├── Triggerbot.cpp
│   ├── Triggerbot.h
│   ├── WaitForKeys.cpp
│   ├── WaitForKeys.h
│   └── netvars.h
├── Ezfrags.sln
├── README.md
├── Reversing
│   └── ezfrags.exe.idb
├── Tools
│   ├── convert_pattern.py
│   └── decrypt_string.cpp
└── how to use.txt

```

`Ezfrags.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31729.503
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ezfrags", "Ezfrags\Ezfrags.vcxproj", "{A5502949-41D2-47BC-9AD3-0BDF34E83300}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Debug|x64.ActiveCfg = Debug|x64
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Debug|x64.Build.0 = Debug|x64
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Debug|x86.ActiveCfg = Debug|Win32
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Debug|x86.Build.0 = Debug|Win32
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Release|x64.ActiveCfg = Release|x64
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Release|x64.Build.0 = Release|x64
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Release|x86.ActiveCfg = Release|Win32
		{A5502949-41D2-47BC-9AD3-0BDF34E83300}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {182C1B8B-3A39-4D63-A976-D0317374C0BF}
	EndGlobalSection
EndGlobal

```

`Ezfrags/AimAssist.cpp`:

```cpp
#include "Settings.hpp"
#include "AimAssist.h"

void aim_assist_thread() {
	cheat_thread_state::aim_assist_thread_status = 1;
}
```

`Ezfrags/AimAssist.h`:

```h
#pragma once

void aim_assist_thread();
```

`Ezfrags/Aimlock.cpp`:

```cpp
#include "Settings.hpp"
#include "Aimlock.h"

void aimlock_thread() {
	cheat_thread_state::aimlock_thread_status = 1;
}
```

`Ezfrags/Aimlock.h`:

```h
#pragma once

void aimlock_thread();
```

`Ezfrags/BunnyHop.cpp`:

```cpp
#include "Settings.hpp"
#include "MemManager.h"
#include "Signatures.h"
#include "BunnyHop.h"
#include "Signatures.h"

#include <iostream>
#include <Windows.h>

//This function is about 90% decompiled
void bunnyhop_thread() {
	cheat_thread_state::bunnyhop_thread_status = 1;
	while (1) {
		while (!settings::bunnyhop_bool || !Mem::csgo_found || !Mem::client_dll_found) {
			Sleep(5u);
		}

		//Mem::RPM<int>(Mem::client + get_sigs::dwLocalPlayer)
		bool player_alive = true;
		if (player_alive && GetAsyncKeyState(32) < 0)// If we're alive and we're pressing space
		{
			Mem::WPM<int>(Mem::client + Signatures::dwForceJump, 5);// force jump
			Sleep(10u);
			Mem::WPM<int>(Mem::client + Signatures::dwForceJump, 4);// unjump
		}
		Sleep(1u);

		/*
		while ( !bunnyhop_bool || !csgo_module || !client_module_found || !byte_4FBF0C || LocalPlayer_notsure == 1 )
		  Sleep(5u);
		if ( ReadProcessMemory_2(player, v2, v3, v4, v5) && GetAsyncKeyState(32) < 0 )// If we're alive and we're pressing space
		{
		  write_memory((LPVOID)(client + dwForceJump), 5);// force jump
		  Sleep(10u);
		  write_memory((LPVOID)(client + dwForceJump), 4);// unjump
		}
		Sleep(1u);
		*/
	}
}
```

`Ezfrags/BunnyHop.h`:

```h
#pragma once

void bunnyhop_thread();
```

`Ezfrags/Ezfrags.cpp`:

```cpp
#include <iostream>
#include <Windows.h>

#include "MemManager.cpp"
#include "Signatures.cpp"
#include "ShowFeatures.cpp"
#include "WaitForKeys.cpp"

#include "AimAssist.cpp"
#include "Aimlock.cpp"
#include "BunnyHop.cpp"
#include "GlowESP.cpp"
#include "KillMessage.cpp"
#include "NoFlash.cpp"
#include "Radar.cpp"
#include "Triggerbot.cpp"

#include "Settings.hpp"
#include "Ezfrags.h"

#include "StringObfuscation.hpp"

time_t TimeUpdate;
time_t current_time; // eax

int main()
{
	start_obfuscation();
	current_time = time(0);                     // current time in seconds
	srand((unsigned int)current_time);			// sets the seed for random numbers to the current time
                                                // randomness will be used later for the kill message

	std::cout << console_title << std::endl;
	SetConsoleTitleA("EZfrags CS:GO multihack v9.65 public [www.EZfrags.co.uk]"); //Ezfrag premium ++ spinbout edition
	std::cout << "EZfrags CS:GO multihack v9.65 public [www.EZfrags.co.uk]" << "\n";

	time(&TimeUpdate);
	if (TimeUpdate - 1591304279 > 864000)             // If our version is older than 10 days
	{
		std::cout << '\n' << "!!! WARNING !!!: This version is more than 10 days old.";
		std::cout << '\n' << "You should go and download a new build from www.EZfrags.co.uk" << std::endl;
	}

	std::cout << '\n' << "The hack will start loading once CS:GO is started." << std::endl;

	std::cout << "\n" << "Loading csgo.exe";
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mem::get_csgo, 0, 0, 0);

	//All this instant thing is just from me, that doesn't figure in the original code
	//So yeah that's to change ig
	bool instant_csgo = true;
	while (!Mem::csgo_found)
	{
		Sleep(250);

		if (Mem::csgo_found)
		{
			break;
		}

		std::cout << ".";

		instant_csgo = false;
	}

	if (instant_csgo) {
		std::cout << "....";
	}

	std::cout << std::endl;

	std::cout << "Loading client.dll";
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mem::get_client_base_address, 0, 0, 0);

	bool instant_client = true;
	while (!Mem::client_dll_found)
	{
		Sleep(250);

		if (Mem::client_dll_found)
		{
			break;
		}

		std::cout << ".";

		instant_client = false;
	}

	if (instant_client) {
		std::cout << "....";
	}

	std::cout << std::endl;


	std::cout << "Loading engine.dll";
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mem::get_engine_base_address, 0, 0, 0);

	bool instant_engine = true;
	while (!Mem::engine_dll_found)
	{

		Sleep(250);

		if (Mem::engine_dll_found)
		{
			break;
		}
		std::cout << ".";

		instant_engine = false;
	}

	if (instant_engine) {
		std::cout << "....";
	}

	std::cout << std::endl;

	std::cout << "\n" << "Scanning for offsets...";

	get_sigs::start();

	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)radar_thread, 0, 0, 0);// Stuck
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)aim_assist_thread, 0, 0, 0);//
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)no_flash_thread, 0, 0, 0);// Done !
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)bunnyhop_thread, 0, 0, 0);// Done !
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)aimlock_thread, 0, 0, 0);//
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)glow_esp_thread, 0, 0, 0);//
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)kill_message_thread, 0, 0, 0);//
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)trigger_thread, 0, 0, 0);//
	while (!cheat_thread_state::aim_assist_thread_status
		|| !cheat_thread_state::aimlock_thread_status
		|| !cheat_thread_state::no_flash_thread_status
		|| !cheat_thread_state::glow_esp_thread_status
		|| !cheat_thread_state::radar_thread_status
		|| !cheat_thread_state::bunnyhop_thread_status
		|| !cheat_thread_state::trigger_thread_status
		|| !cheat_thread_state::kill_message_thread_status)
		Sleep(100u);

	settings::glow_esp_bool = 1;
	settings::trigger_mode_switch_1 = 0;
	settings::aimlock_bool = 1;
	settings::radar_bool = 1;
	settings::aim_assist_bool = 1;
	settings::trigger_mode_switch_2 = 0;
	settings::bunnyhop_bool = 1;
	settings::kill_message_bool = 1;
	settings::no_flash_bool = 1;
	update();

	while (WaitForSingleObject(Mem::process_handle, 0)) {
		wait_for_keys();
	}
	CloseHandle(Mem::process_handle);
	exit(0);
}


```

`Ezfrags/Ezfrags.h`:

```h
#pragma once

int main();
```

`Ezfrags/Ezfrags.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a5502949-41d2-47bc-9ad3-0bdf34e83300}</ProjectGuid>
    <RootNamespace>Ezfrags</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>Default</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Ezfrags.cpp" />
    <ClCompile Include="Get.cpp" />
    <ClCompile Include="netvars.h" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AimAssist.cpp" />
    <ClInclude Include="AimAssist.h" />
    <ClInclude Include="Aimlock.h" />
    <ClInclude Include="Aimlock.cpp" />
    <ClInclude Include="BunnyHop.cpp" />
    <ClInclude Include="BunnyHop.h" />
    <ClInclude Include="Ezfrags.h" />
    <ClInclude Include="Get.h" />
    <ClInclude Include="GlowESP.cpp" />
    <ClInclude Include="GlowESP.h" />
    <ClInclude Include="KillMessage.h" />
    <ClInclude Include="KillMessage.cpp" />
    <ClInclude Include="MemManager.h" />
    <ClInclude Include="MemManager.cpp" />
    <ClInclude Include="NoFlash.cpp" />
    <ClInclude Include="NoFlash.h" />
    <ClInclude Include="Radar.cpp" />
    <ClInclude Include="Radar.h" />
    <ClInclude Include="Settings.hpp" />
    <ClInclude Include="ShowFeatures.cpp" />
    <ClInclude Include="ShowFeatures.h" />
    <ClInclude Include="Signatures.h" />
    <ClInclude Include="Signatures.cpp" />
    <ClInclude Include="Triggerbot.cpp" />
    <ClInclude Include="Triggerbot.h" />
    <ClInclude Include="WaitForKeys.h" />
    <ClInclude Include="WaitForKeys.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Ezfrags/Ezfrags.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Fichiers sources">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Fichiers d%27en-tête">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Fichiers de ressources">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Memory">
      <UniqueIdentifier>{22c8e2bf-5511-4a73-baf5-ff24109b3af1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Hacks">
      <UniqueIdentifier>{252e8f23-1acb-462d-b403-e33b980580de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Console">
      <UniqueIdentifier>{93ecdca2-1ebf-408b-b23c-89a0bdb5cbc1}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Ezfrags.cpp">
      <Filter>Fichiers sources</Filter>
    </ClCompile>
    <ClCompile Include="netvars.h">
      <Filter>Memory</Filter>
    </ClCompile>
    <ClCompile Include="Get.cpp">
      <Filter>Memory</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="MemManager.cpp">
      <Filter>Memory</Filter>
    </ClInclude>
    <ClInclude Include="Signatures.cpp">
      <Filter>Memory</Filter>
    </ClInclude>
    <ClInclude Include="ShowFeatures.cpp">
      <Filter>Console</Filter>
    </ClInclude>
    <ClInclude Include="Settings.hpp">
      <Filter>Fichiers sources</Filter>
    </ClInclude>
    <ClInclude Include="WaitForKeys.cpp">
      <Filter>Console</Filter>
    </ClInclude>
    <ClInclude Include="Radar.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="AimAssist.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="NoFlash.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="BunnyHop.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Aimlock.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="GlowESP.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="KillMessage.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Triggerbot.cpp">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="ShowFeatures.h">
      <Filter>Console</Filter>
    </ClInclude>
    <ClInclude Include="WaitForKeys.h">
      <Filter>Console</Filter>
    </ClInclude>
    <ClInclude Include="MemManager.h">
      <Filter>Memory</Filter>
    </ClInclude>
    <ClInclude Include="Signatures.h">
      <Filter>Memory</Filter>
    </ClInclude>
    <ClInclude Include="AimAssist.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Aimlock.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="BunnyHop.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="GlowESP.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="KillMessage.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="NoFlash.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Radar.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Triggerbot.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Ezfrags.h">
      <Filter>Fichiers sources</Filter>
    </ClInclude>
    <ClInclude Include="Get.h">
      <Filter>Memory</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Ezfrags/Ezfrags.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Ezfrags/Get.cpp`:

```cpp
#include "MemManager.h"
#include "Signatures.h"
#include "Get.h"

namespace Get {
	INT32 LocalPlayer() {
		return Mem::RPM<INT32>(Mem::client + Signatures::dwLocalPlayer);
	}
}

```

`Ezfrags/Get.h`:

```h
#pragma once
#include <Windows.h>

namespace Get {
	INT32 LocalPlayer();
}
```

`Ezfrags/GlowESP.cpp`:

```cpp
#include "Settings.hpp"
#include "GlowESP.h"

void glow_esp_thread() {
	cheat_thread_state::glow_esp_thread_status = 1;
}
```

`Ezfrags/GlowESP.h`:

```h
#pragma once

void glow_esp_thread();
```

`Ezfrags/KillMessage.cpp`:

```cpp
#include "Settings.hpp"
#include "KillMessage.h"

void kill_message_thread() {
	cheat_thread_state::kill_message_thread_status = 1;
}
```

`Ezfrags/KillMessage.h`:

```h
#pragma once

void kill_message_thread();
```

`Ezfrags/MemManager.cpp`:

```cpp
#include <iostream>
#include <thread>
#include <Windows.h>
#include <TlHelp32.h>
#include "MemManager.h"

namespace Mem {
    inline MODULEENTRY32 get_module(const char* modName, DWORD proc_id) {
        HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, proc_id);
        if (hSnap != INVALID_HANDLE_VALUE) {
            MODULEENTRY32 modEntry;
            modEntry.dwSize = sizeof(modEntry);
            if (Module32First(hSnap, &modEntry)) {
                do {
                    if (!strcmp(modEntry.szModule, modName)) {
                        CloseHandle(hSnap);
                        return modEntry;
                    }
                } while (Module32Next(hSnap, &modEntry));
            }
        }
        MODULEENTRY32 module = { (DWORD)-1 };
        return module;
    }

    inline void get_csgo() {
        while (1) {
            //Get a window handle to csgo
            HWND hw_csgo = FindWindowA(NULL, "Counter-Strike: Global Offensive - Direct3D 9");

            if (hw_csgo) {
                csgo_found = true;
                //Get csgo's process ID using the handle (No need to make some big function for procid like every other paster does)
                GetWindowThreadProcessId(hw_csgo, &dw_process_id);
                Mem::process_handle = OpenProcess(PROCESS_VM_READ | PROCESS_VM_OPERATION | PROCESS_VM_WRITE, false, dw_process_id);
                break;
            }
        }
        
    }

    inline void get_client_base_address() {
        while (1) {
            Mem::dw_client_address = get_module("client.dll", dw_process_id);
            Mem::client_bytes = new uint8_t[Mem::dw_client_address.modBaseSize]; //making a variable size of the module
            
            Mem::client = (uintptr_t)dw_client_address.modBaseAddr;

            if (Mem::client_bytes) {
                client_dll_found = true;
                break;
            }

            DWORD bytes_read;
            ReadProcessMemory(process_handle, Mem::dw_client_address.modBaseAddr, Mem::client_bytes, Mem::dw_client_address.modBaseSize, &bytes_read); //reading the module and storing as bytes_read
            if (bytes_read != Mem::dw_client_address.modBaseSize) throw; //checking that the size of bytes read is = to size of bytes in the module
            delete[] Mem::client_bytes;
        }
    }

    inline void get_engine_base_address() {
        while (1) {
            MODULEENTRY32 dw_engine_address = get_module("engine.dll", dw_process_id);
            engine_bytes = new uint8_t[dw_engine_address.modBaseSize]; //making a variable size of the module

            Mem::engine = (uintptr_t)dw_engine_address.modBaseAddr;

            if (engine_bytes) {
                engine_dll_found = true;
                break;
            }

            DWORD bytes_read;
            ReadProcessMemory(process_handle, dw_engine_address.modBaseAddr, engine_bytes, dw_engine_address.modBaseSize, &bytes_read); //reading the module and storing as bytes_read
            if (bytes_read != dw_engine_address.modBaseSize) throw; //checking that the size of bytes read is = to size of bytes in the module
            delete[] Mem::engine_bytes;
        }
    }

    //https://github.com/Made0x0000000a/nyfox/blob/main/csgoCheat/patternscan.cpp
    DWORD FindAddress(const wchar_t* moduleName, const char* pattern, const char* mask, const int offset=0, const int extra=0) {
        const MODULEENTRY32 moduleEntry = Mem::dw_client_address;
        const HANDLE hProcess = Mem::process_handle;

        // No Module Entry found
        if (!moduleEntry.th32ModuleID) {
            return NULL;
        }  

        // Module base address = scan starting point
        uintptr_t base = (uintptr_t)moduleEntry.modBaseAddr;
        // Size of Module = scan end point
        uintptr_t size = base + moduleEntry.modBaseSize;

        uintptr_t curChunk = base;
        SIZE_T bytesRead;
        DWORD res;
        int res_plus_offset = 0;

        while (curChunk < size) {
            // Area to scan
            char buffer[4096];

            // Change read protection, raed memory and change read protection back to the original
            DWORD oProtect;
            VirtualProtectEx(hProcess, (LPVOID)curChunk, sizeof(buffer), PAGE_EXECUTE_READWRITE, &oProtect);
            ReadProcessMemory(hProcess, (LPVOID)curChunk, &buffer, sizeof(buffer), &bytesRead);
            VirtualProtectEx(hProcess, (LPVOID)curChunk, sizeof(buffer), oProtect, &oProtect);

            // No bytes read
            if (bytesRead == 0) {
                return NULL;
            }

            DWORD internalAddr = Mem::FindPattern((char*)&buffer, bytesRead, pattern, mask);

            if (internalAddr != NULL) {
                // Calculate real address
                uintptr_t offsetFromBuffer = (uintptr_t)internalAddr - (uintptr_t)&buffer;
                res = (DWORD)(curChunk + offsetFromBuffer);
                res_plus_offset = Mem::RPM<int>(res + offset); //Adding the offset
                return res_plus_offset - (DWORD)Mem::dw_client_address.modBaseAddr + extra; //adding the extra
            }
            else {
                // Next chunk
                curChunk += bytesRead;
            }
        }
        return NULL;
    }

    // Find matching pattern
    DWORD FindPattern(char* base, size_t size, const char* pattern, const char* mask) {
        size_t patternLen = strlen(mask);

        for (DWORD i = 0; i < size - patternLen; i++) {
            bool found = true;

            for (DWORD j = 0; j < patternLen; j++) {

                if (mask[j] != '?' && pattern[j] != *(base + i + j)) {
                    found = false;
                    break;
                }
            }

            if (found) {
                return (DWORD)(base + i);
            }
        }

        return NULL;
    }

    template<typename T> T RPM(SIZE_T address) {
        T buffer;
        ReadProcessMemory(process_handle, (LPCVOID)address, &buffer, sizeof(T), NULL);
        return buffer;
    }

    template<typename T> void WPM(SIZE_T address, T buffer) {
        WriteProcessMemory(process_handle, (LPVOID)address, &buffer, sizeof(buffer), NULL);
    }
}
```

`Ezfrags/MemManager.h`:

```h
#pragma once
#include <iostream>
#include <thread>
#include <Windows.h>
#include <TlHelp32.h>

namespace Mem {
    static bool csgo_found = false;
    static bool client_dll_found = false;
    static bool engine_dll_found = false;
    static uintptr_t client;
    static uintptr_t engine;
    static DWORD dw_process_id;
    static MODULEENTRY32 dw_client_address;
    static MODULEENTRY32 dw_engine_address;
    static HANDLE process_handle;
    static uint8_t* client_bytes;
    static uint8_t* engine_bytes;

	inline MODULEENTRY32 get_module(const char* modName, DWORD proc_id);
    inline void get_csgo();
    inline void get_client_base_address();
    inline void get_engine_base_address();
    DWORD FindAddress(const wchar_t* moduleName, const char* pattern, const char* mask, const int offset, const int extra);
    DWORD FindPattern(char* base, size_t size, const char* pattern, const char* mask);

    template<typename T> T RPM(SIZE_T address);
    template<typename T> void WPM(SIZE_T address, T buffer);
}

```

`Ezfrags/NoFlash.cpp`:

```cpp
#include "Settings.hpp"
#include "MemManager.h"
#include "Signatures.h"
#include "Get.h"
#include "NoFlash.h"

//This function has been 100% decompiled !
//Not actually, still remains :
/*
 while ( !csgo_module || !client_module_found || !byte_4FBF0C )
      Sleep(5u);
*/
//But i simplified it here
//No idea what byte_4FBF0C is, seems used in the GetEngine function of Ezfrags, it's yet to be decompiled

void no_flash_thread() {
	cheat_thread_state::no_flash_thread_status = 1;

    while (1)
    {
        while (!Mem::csgo_found || !Mem::client_dll_found)
            Sleep(5u);

        if (settings::no_flash_bool)
        {
            /*
            if (ReadProcessMemory_0((char*)player + m_flFlashMaxAlpha) > 0.0)// If flash value is > 0
                WriteProcessMemory_0((char*)player + m_flFlashMaxAlpha, (float)0.0);// We put anti flash
            */
            if (Mem::RPM<float>(Get::LocalPlayer() + Netvars::m_flFlashMaxAlpha) > 0.0f)
                Mem::WPM<float>(Get::LocalPlayer() + Netvars::m_flFlashMaxAlpha, 0.0f);
        }

        /*
        else if (0.0 == ReadProcessMemory_0((char*)player + m_flFlashMaxAlpha))// We need to reset the flash value to 255
        {
            WriteProcessMemory_0((char*)player + m_flFlashMaxAlpha, (float)255.0);// Yop
        }
        */

        else if (Mem::RPM<float>(Get::LocalPlayer() + Netvars::m_flFlashMaxAlpha) == 0.0f) {
            Mem::WPM<float>(Get::LocalPlayer() + Netvars::m_flFlashMaxAlpha, 255.0f);
        }

        //std::cout << Mem::RPM<float>(Signatures::dwLocalPlayer + Netvars::m_flFlashMaxAlpha) << std::endl;
        //Sleep(300);
        Sleep(1u);
    }
}
```

`Ezfrags/NoFlash.h`:

```h
#pragma once

void no_flash_thread();
```

`Ezfrags/Radar.cpp`:

```cpp
#include "Settings.hpp"
#include "MemManager.h"
#include "netvars.h"
#include "Radar.h"

#define BYTE1(Entities)       (*((char *)(&Entities) + 1))

/*
Still a prototype of what it would look like
I don't know where they actually get the Entities_unk variable
Also i don't know anything about byte_4FBF0C, doesn't seem that important
*/

void radar_thread() {
    int Entities[157];

	cheat_thread_state::radar_thread_status = 1;

    return; //don't wanna cause errors
    while (1)
    {
        while (!Mem::csgo_found || !settings::radar_bool || !Mem::client_dll_found) //|| !byte_4FBF0C) Don't know about this byte
            Sleep(5u);

        for (int i = 0; i <= 63 && Mem::csgo_found == 1 && Mem::client_dll_found == 1; i++)//For every player in the map.        //&& byte_4FBF0C == 1; ++i) Same byte as before
        {
            //memcpy(Entities, (char*)&Entities_unk + 628 * i, sizeof(Entities));
            if (BYTE1(Entities[146])
                && LOBYTE(Entities[141])
                && LOBYTE(Entities[78])
                && BYTE1(Entities[118]) != 1
                && BYTE1(Entities[99]) != 1
                //&& Entities[4] != dword_4FBEF0
                && (Mem::RPM<unsigned __int8>(Entities[120] + Netvars::m_bSpotted) != 1)) // If ennemy is not spotted
                //&& (unsigned __int8)RPM((LPCVOID)(Entities[120] + m_bSpotted)) != 1)
            {
                //Mem::WPM_test((LPVOID)(Entities[120] + Netvars::m_bSpotted), 1);
                //WPM((LPVOID)(Entities[120] + m_bSpotted), 1);// Set entity is spotted
            }
        }
        Sleep(1u);
    }

}
```

`Ezfrags/Radar.h`:

```h
#pragma once

void radar_thread();
```

`Ezfrags/Settings.hpp`:

```hpp
#pragma once

namespace settings {
	bool glow_esp_bool;
	int trigger_mode_switch_1;
	int trigger_mode_switch_2;
	int trigger_delay = 30;
	bool aimlock_bool;
	int aimlock_bone = 6; //8 : chest,   6 : head
	bool radar_bool;
	bool aim_assist_bool;
	int aim_assist_bone = 6; //8 : chest,   6 : head
	float aim_fov = 25.0;
	bool bunnyhop_bool;
	bool kill_message_bool;
	bool no_flash_bool;
};

namespace cheat_thread_state {
	bool aim_assist_thread_status = 0;
	bool aimlock_thread_status = 0;
	bool no_flash_thread_status = 0;
	bool glow_esp_thread_status = 0;
	bool radar_thread_status = 0;
	bool bunnyhop_thread_status = 0;
	bool trigger_thread_status = 0;
	bool kill_message_thread_status = 0;
}
```

`Ezfrags/ShowFeatures.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include "ShowFeatures.h"
#include "Settings.hpp"

time_t Time;

void update() {
	system("cls");

	std::cout << "EZfrags CS:GO multihack v9.65 public [www.EZfrags.co.uk]" << "\n";

	time(&Time);
	if (Time - 1591304279 > 864000)             // If our version is older than 10 days
	{
		std::cout << '\n' << "!!! WARNING !!!: This version is more than 10 days old.";
		std::cout << '\n' << "You should go and download a new build from www.EZfrags.co.uk" << std::endl;
	}

	std::cout << '\n' << "The hack has been loaded. Have fun!" << std::endl;

	std::cout << "\n" << "TRIGGERBOT ";
	if (settings::trigger_mode_switch_2 && settings::trigger_mode_switch_1 != 1)
	{
		std::cout << "AUTO";
	}
	else if (settings::trigger_mode_switch_2 != 1 && settings::trigger_mode_switch_1)
	{
		std::cout << "HOLD";
	}
	else if (settings::trigger_mode_switch_2 != 1 && settings::trigger_mode_switch_1 != 1)
	{
		std::cout << "OFF";
	}

	std::cout << " @ " << settings::trigger_delay << " MS";

	std::cout << std::endl;

	std::cout << "AIM ASSIST " << settings::aim_assist_bool << " @ ";
	if (settings::aim_assist_bone == 8) {
		std::cout << "CHEST" << std::endl;
	}
	else {
		std::cout << "HEAD" << std::endl;
	}

	std::cout << "AIMLOCK " << settings::aimlock_bool << " @ ";
	if (settings::aimlock_bone == 8) {
		std::cout << "CHEST" << std::endl;
	}
	else {
		std::cout << "HEAD" << std::endl;
	}

	std::cout << "GLOW ESP " << settings::glow_esp_bool << std::endl;

	std::cout << "RADAR HACK " << settings::radar_bool << std::endl;

	std::cout << "NO FLASH HACK " << settings::no_flash_bool << std::endl;

	std::cout << "BUNNY HOP " << settings::bunnyhop_bool << std::endl;

	std::cout << "KILL MESSAGE " << settings::kill_message_bool;
}
```

`Ezfrags/ShowFeatures.h`:

```h
#pragma once

void update();
```

`Ezfrags/Signatures.cpp`:

```cpp
#include "MemManager.h"
#include "netvars.h"
#include "Signatures.h"
#include <stdio.h>
#include <iostream>

namespace get_sigs {
	//https://github.com/HeathHowren/Pattern-Scanning/blob/master/patternscanexternal/Source.cpp

	void start() {
		//Netvars
		DWORD dwGetAllClasses = Mem::FindAddress(L"client.dll", "\xA1\x00\x00\x00\x00\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xA1\x00\x00\x00\x00\xB9","x????xxxxxxxxxxxx????x", 1, 0) + (uintptr_t)Mem::dw_client_address.modBaseAddr;
		DWORD dwGetAllClasses_deref = Mem::RPM<DWORD>(dwGetAllClasses);
		DWORD dwGetAllClasses_offset = dwGetAllClasses_deref - (uintptr_t)Mem::dw_client_address.modBaseAddr;

		std::unique_ptr<NetvarsClass> NetvarManager(new NetvarsClass((uintptr_t)Mem::dw_client_address.modBaseAddr + dwGetAllClasses_offset));
		Netvars::m_fFlags = NetvarManager->NETVAR("DT_CSPlayer", "m_fFlags");
		Netvars::m_flFlashMaxAlpha = NetvarManager->NETVAR("DT_CSPlayer", "m_flFlashMaxAlpha");
		Netvars::m_bSpotted = NetvarManager->NETVAR("DT_BaseEntity", "m_bSpotted");
		
		//Signatures
		Signatures::dwLocalPlayer = Mem::FindAddress(L"client.dll", "\x8D\x34\x85\x00\x00\x00\x00\x89\x15\x00\x00\x00\x00\x8B\x41\x08\x8B\x48\x04\x83\xF9\xFF", "xxx????xx????xxxxxxxxx", 3, 4);
		Signatures::dwForceJump = Mem::FindAddress(L"client.dll", "\x8B\x0D\x00\x00\x00\x00\x8B\xD6\x8B\xC1\x83\xCA\x02", "xx????xxxxxxx", 2, 0);
	}
}

```

`Ezfrags/Signatures.h`:

```h
#pragma once
#include <stdio.h>

namespace get_sigs {
	void start();
}

namespace Signatures {
	static DWORD dwForceJump;
	static DWORD dwLocalPlayer;
}

namespace Netvars {
	static int m_fFlags;
	static int m_flFlashMaxAlpha;
	static int m_bSpotted;
}
```

`Ezfrags/Triggerbot.cpp`:

```cpp
#include "Settings.hpp"
#include "Triggerbot.h"

void trigger_thread() {
	cheat_thread_state::trigger_thread_status = 1;
}
```

`Ezfrags/Triggerbot.h`:

```h
#pragma once

void trigger_thread();
```

`Ezfrags/WaitForKeys.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include "WaitForKeys.h"
#include "ShowFeatures.h"
#include "Settings.hpp"

void wait_for_keys()
{
    if (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(117) < 0)// 
                                                  // F6 - cycle through triggerbot modes (autofire, hold key, disabled - default)
                                                  // SHIFT+F6 - cycle through triggerbot delays (10, 30 - default, 50, 80, 110, 140)
    {
        while (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(117) < 0)
            Sleep(75u);
        if (settings::trigger_mode_switch_2 && settings::trigger_mode_switch_1 != 1)// mode switching (f6)
        {
            settings::trigger_mode_switch_2 = 0;
            settings::trigger_mode_switch_1 = 1;
        }
        else if (settings::trigger_mode_switch_2 != 1 && settings::trigger_mode_switch_1)
        {
            settings::trigger_mode_switch_2 = 0;
            settings::trigger_mode_switch_1 = 0;
        }
        else if (settings::trigger_mode_switch_2 != 1 && settings::trigger_mode_switch_1 != 1)
        {
            settings::trigger_mode_switch_2 = 1;
            settings::trigger_mode_switch_1 = 0;
        }
        update();
    }
    if (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(117) < 0)
    {
        while (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(117) < 0)
            Sleep(75u);
        if (settings::trigger_delay == 140)                 // Delay switching (shift + f6)
        {
            settings::trigger_delay = 10;
        }
        else if (settings::trigger_delay == 10 || settings::trigger_delay == 30)
        {
            settings::trigger_delay += 20;
        }
        else
        {
            settings::trigger_delay += 30;
        }
        update();
    }
    if (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(118) < 0)// 
                                                  // F7 - toggle aim assist
                                                  // SHIFT+F7 - toggle aim assist mode (rage/legit)
    {
        while (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(118) < 0)
            Sleep(75u);
        settings::aim_assist_bool = settings::aim_assist_bool == 0;
        update();
    }
    if (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(118) < 0)
    {
        while (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(118) < 0)
            Sleep(75u);
        if (settings::aim_assist_bone == 8)                 // mode switching (shift + f7)
        {
            settings::aim_assist_bone = 6;                      // switching between bones, head and chest
            settings::aim_fov = 25.0;                           // switching between 25.0 and 100.0 fov
        }
        else
        {
            settings::aim_assist_bone = 8;
            settings::aim_fov = 100.0;
        }
        update();
    }
    if (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(119) < 0)// 
                                                  // F8 - toggle aimlock 119
                                                  // SHIFT+F8 - toggle aimlock target (head/chest)
    {
        while (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(119) < 0)
            Sleep(75u);
        settings::aimlock_bool = settings::aimlock_bool == 0;
        update();
    }
    if (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(119) < 0)
    {
        while (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(119) < 0)
            Sleep(75u);
        if (settings::aimlock_bone == 8)                    // switching between bones, head and chest
            settings::aimlock_bone = 6;
        else
            settings::aimlock_bone = 8;
        update();
    }
    if (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(120) < 0)// 
                                                  // F9 - toggle GlowESP 120
                                                  // SHIFT+F9 - toggle radar hack
    {
        while (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(120) < 0)
            Sleep(75u);
        settings::glow_esp_bool = settings::glow_esp_bool == 0;
        update();
    }
    if (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(120) < 0)
    {
        while (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(120) < 0)
            Sleep(75u);
        settings::radar_bool = settings::radar_bool == 0;
        update();
    }
    if (GetAsyncKeyState(121) < 0)              // 
                                                  // F10 - toggle no flash hack
    {
        while (GetAsyncKeyState(121) < 0)
            Sleep(75u);
        settings::no_flash_bool = settings::no_flash_bool == 0;
        update();
    }
    if (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(122) < 0)// 
                                                  // F11 - toggle bunny hop 122
                                                  // SHIFT+F11 - toggle kill message
    {
        while (GetAsyncKeyState(16) >= 0 && GetAsyncKeyState(122) < 0)
            Sleep(75u);
        settings::bunnyhop_bool = settings::bunnyhop_bool == 0;
        update();
    }
    if (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(122) < 0)
    {
        while (GetAsyncKeyState(16) < 0 && GetAsyncKeyState(122) < 0)
            Sleep(75u);
        settings::kill_message_bool = settings::kill_message_bool == 0;
        update();
    }
    Sleep(25u);
}
```

`Ezfrags/WaitForKeys.h`:

```h
#pragma once

void wait_for_keys();
```

`Ezfrags/netvars.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>

#include "MemManager.h"

class NetvarsClass {
private:
	class RecvTable {
	public:
		std::string GetTableName() {
			DWORD offset = Mem::RPM<DWORD>((DWORD)this + 0xC);
			char tableName[128];
			ReadProcessMemory(Mem::process_handle, (LPCVOID)offset, &tableName, sizeof(tableName), 0);
			return std::string(tableName);
		}
		void* GetProperty(int i) { // RecvProp*
			return (void*)(Mem::RPM<DWORD>((DWORD)this) + 0x3C * i);
		}
		int GetMaxProp() {
			return Mem::RPM<int>((DWORD)this + 0x4);
		}
	};
	class ClientClass {
	public:
		void* GetTable() { // RecvTable*
			return Mem::RPM<void*>((DWORD)this + 0xC);
		}
		void* GetNextClass() { // ClientClass*
			return Mem::RPM<void*>((DWORD)this + 0x10);
		}
	};
	class RecvProp {
	public:
		std::string GetVarName() {
			DWORD offset = Mem::RPM<DWORD>((DWORD)this);
			char vName[128];
			ReadProcessMemory(Mem::process_handle, (LPCVOID)offset, &vName, sizeof(vName), 0);
			return std::string(vName);
		}
		int GetOffset() {
			return Mem::RPM<int>((DWORD)this + 0x2C);
		}
		void* GetDataTable() { // RecvTable*
			return Mem::RPM<void*>((DWORD)this + 0x28);
		}
	};
	DWORD CheckProps(RecvTable* DataTable, std::string NetVarName) {
		for (int i = 0; i < DataTable->GetMaxProp(); i++) {
			auto pRecvProp = reinterpret_cast<RecvProp*>(DataTable->GetProperty(i));
			auto VarName = pRecvProp->GetVarName();
			if (isdigit(VarName[0])) continue;
			if (NetVarName.compare(VarName) == 0) return pRecvProp->GetOffset();
			if (auto DataTable2 = reinterpret_cast<RecvTable*>(pRecvProp->GetDataTable()))
				if (auto Offset = CheckProps(DataTable2, NetVarName)) return Offset;
		}
		return NULL;
	}
	DWORD dwGetAllClasses;
	
public:
	NetvarsClass(DWORD Base) : dwGetAllClasses(Base) {}
	 DWORD NETVAR(std::string ClassName, std::string NetVarName) {
		if (auto pClass = reinterpret_cast<ClientClass*>(dwGetAllClasses))
			for (; pClass != NULL; pClass = reinterpret_cast<ClientClass*>(pClass->GetNextClass()))
				if (auto Table = reinterpret_cast<RecvTable*>(pClass->GetTable()))
					if (Table->GetTableName().compare(ClassName) == 0)
						if (auto Offset = CheckProps(Table, NetVarName)) return Offset;
		return NULL;
	}
};
```

`README.md`:

```md
# Ezfrags
Ezfrags was the first cheat of a lot of people, and probably their last. This cheat is so popular that it became a meme in the CS:GO community.

# Why ?
I wanted to start this project because a lot of people are not sure if Ezfrags is a virus, if it's detected etc.. Also because the updates are slow to arrive. And obviously because i couldn't resist to make the code of this masterpiece public.
The point is that we can update the cheat, make it undetected, paste it, or just play with a clean version. It's also a training for me who'se learning reverse engineering.

# How ?
I'm currently using IDA 7.5 to decompile this cheat, [the database is avalaible in the repo](https://github.com/ALittlePatate/ezfrags/blob/master/Reversing/ezfrags.exe.idb).
Then you just have to read the code, try to understand and with some time you'll get there.
The version of Ezfrags i'm using here is the v9.65, from 05/06/2020. We don't need to use newer version as they just patch the signatures/structs.
I'm trying to replicate the function as close as they were written but a lot of them are very hard to understand (especially for a begginer like me).
Also the strings are obfuscated but idk how, i know where, but not how.
All the memory related things aren't decompiled yet so i'm using some pasted stuff for the Netvars/Signatures dump.

# Decompilation state :
* ### UI : 100%
* ## Cheats
  * ### [Triggerbot](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/Triggerbot.cpp) : 0%
  * ### [AimAssist](https://gith](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/Aimlock.cpp)ub.com/ALittlePatate/ezfrags/blob/master/Ezfrags/AimAssist.cpp) : 0%
  * ### [Aimlock](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/Aimlock.cpp) : 0%
  * ### [GlowESP](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/GlowESP.cpp) : ~10-20% (see the IDA database)
  * ### [Radar](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/Radar.cpp) : ~60% (see the IDA database)
  * ### [Noflash](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/NoFlash.cpp) : 99% (missing 1 single variable)
  * ### [Bhop](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/BunnyHop.cpp) : 99% (missing 1 single variable)
  * ### [KillMessage](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/KillMessage.cpp) : 0%
* ### [Memory Management](https://github.com/ALittlePatate/ezfrags/blob/master/Ezfrags/MemManager.cpp) : 2%

# The tools
I provided in the [Tools/ folder](https://github.com/ALittlePatate/ezfrags/tree/master/Tools) all the tools i'm using for this project.

## Contact

You can add me on discord at patate#1252

## Contributing

Note: before contrubuting please make sure that your code is as close as the IDA database as you can, also try to stick to the general structure of the project.
Open an [issue](https://github.com/ALittlePatate/ezfrags/issues/new) or make a [pull request](https://github.com/ALittlePatate/ezfrags/pulls), i'll be glad to improve my project with you !

```

`Tools/convert_pattern.py`:

```py
import sys

"""
Basically converting a given pattern in this form :
8D 34 85 ? ? ? ? 89 15 ? ? ? ? 8B 41 08 8B 48 04 83 F9 FF
to this :
\x8D\x34\x85\x00\x00\x00\x00\x89\x15\x00\x00\x00\x00\x8B\x41\x08\x8B\x48\x04\x83\xF9\xFF
xxx????xx????xxxxxxxxx

It also generates the mask for the signature.
The code isn't optimized because idc
"""

sig = sys.argv[1]
sig = "\\x" + sig
temp = sig.replace(" ","\\x")
res = temp.replace("?","00")
print(res)

res_list = sig.split(" ")
res_mask = ""
for charac in res_list :
    if charac == "?" :
        res_mask += "?"
    else :
        res_mask += "x"

print(res_mask)
```

`Tools/decrypt_string.cpp`:

```cpp
#include <iostream>
#include <defs.h>

void Decrypt(int a1, int size)
{
    unsigned int i; // [esp+10h] [ebp-4h]

    for (i = 0; i <= (size - 2); ++i)
        *(char*)(a1 + i) ^= (char)i + 3;
    *(char*)(a1 + (size - 1)) = 0;
}


int main()
{
    char string[] = "Pgdhiagm+jb|/";

    Decrypt((int)string, sizeof(string));

    std::cout << string << std::endl;

    return 0;
}
```

`how to use.txt`:

```txt
The hack will start loading once CS:GO is started.
If the hack doesn't work, try clicking the 'Unblock' button in the .exe's properties.
Running the hack with administrator rights might sort it out, too.

Keys:
- Left ALT - hold LALT to lock onto an enemy
- SPACE - hold SPACE to use bunny hop
- MOUSE5 and Middle Mouse Button - triggerbot hold keys

- F6 - cycle through triggerbot modes (autofire, hold key, disabled - default)
- SHIFT+F6 - cycle through triggerbot delays (10, 30 - default, 50, 80, 110, 140)
- F7 - toggle aim assist
- SHIFT+F7 - toggle aim assist mode (rage/legit)
- F8 - toggle aimlock
- SHIFT+F8 - toggle aimlock target (head/chest)
- F9 - toggle GlowESP
- SHIFT+F9 - toggle radar hack
- F10 - toggle no flash hack
- F11 - toggle bunny hop
- SHIFT+F11 - toggle kill message
```