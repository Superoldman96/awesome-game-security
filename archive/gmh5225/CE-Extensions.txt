Project Path: arc_gmh5225_CE-Extensions_vmuw51y1

Source Tree:

```txt
arc_gmh5225_CE-Extensions_vmuw51y1
├── AutosaveMenu.lua
├── Conversion Calculator.lua
├── DisassemblerHighlight.lua
├── DuplicateScan.zip
├── HexViewCopyNBytes.lua
├── LuaEngineTransparency.lua
├── SaveDissectCode.lua
├── SoundOnBP.lua
├── TableFileIterator.lua
├── addElementsTostructure.lua
├── attachToMostMemoryProcess.lua
├── autosave.lua
├── convertStructDisplay.lua
├── copyOffsets.lua
├── createBanner.lua
├── disableMono.lua
├── docs_gvim.lua
├── duplicatePointer.lua
├── genFromStruct.lua
├── get returnaddresses.lua
├── git-simple.bat
├── github link.url
├── gotoOnBreak.lua
├── loader.lua
├── lockMouse.lua
├── lua engine output monospace.lua
├── playRandomMovie.lua
├── popout_addressList.lua
├── randomizeSelected.lua
└── remove hotkeys.lua

```

`AutosaveMenu.lua`:

```lua
--##### Remove Hotkeys Lua Script for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a menu option to remove all hotkeys from memory records
  note: this does not remove/destroy any hotkeys created by lua code only the gui
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'Autosaves'
local extItemCaption = 'Open autosaves'
local requiredVersion = 7.2 -- DB added autosave in 7.2
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end
if not autosave then print("Uh... looks like autosave data has changed. Sorry but I can't do my job :(") end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = 'Open Autosaves'
extMenuItem.OnClick = function()
  shellExecute(autosave.getPath() .. 'Cheat Engine AutoSave')
end
extMenu.add(extMenuItem)

extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = 'Save state'
extMenu.add(extMenuItem)
extMenuItem.OnClick = function()
  autosave.saveState()
end

extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = 'Load state'
extMenu.add(extMenuItem)
extMenuItem.OnClick = function()
  autosave.loadState()
end

extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = 'Open Settings'
extMenu.add(extMenuItem)
extMenuItem.OnClick = function()
  local settings = getSettingsForm()
  local tabs = settings.pcSetting
  tabs.ActivePage = autosave.settingsTab
  settings.show()
end

extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = 'Toggle Autosaving'
if autosave.Timer and autosave.Timer.Enabled then
  extMenuItem.Caption = 'Toggle Autosaving (ON)'
end
extMenu.add(extMenuItem)
extMenuItem.OnClick = function()
  if not autosave.Timer then
    autosave.applySettings() -- enable timer based on settings
    if autosave.Timer then
      extMenuItem.Caption = 'Toggle Autosaving (ON)'
    end
  else
    extMenuItem.Caption = 'Toggle Autosaving (OFF)'
    autosave.Timer.Enabled = not autosave.Timer.Enabled
  end
end


```

`Conversion Calculator.lua`:

```lua
--##### Conversion Calculator POC Lua Script for Cheat Engine
--##### Author: FreeER (based on https://github.com/cheat-engine/cheat-engine/issues/243 by rcg4u)
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  example of a conversion calculator for CE like x64dbg
  inspired by https://github.com/cheat-engine/cheat-engine/issues/243
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Conversion Calculator'
local requiredVersion = 6.4 -- requirement for inputQuery
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

local function saveDissectCode(dc)
  local fd = createSaveDialog(nil)
  fd.Filter = 'DisectCode|*.DC|All Files|*.*'
  local picked = fd.Execute()
  if not picked then return false end
  dc.saveToFile(fd.FileName)
  fd.destroy()
end

local function loadDissectCode(dc)
  local fd = createOpenDialog(nil)
  fd.Filter = 'DisectCode|*.DC|All Files|*.*'
  local picked = fd.Execute()
  if not picked then return false end
  dc.loadFromFile(fd.FileName)
  fd.destroy()
end

local conversionForm = createForm(false)
conversionForm.onClose = function(sender)
  -- not sure if sender is form or the x button...
  conversionForm.hide()
end

local mainLabel = createLabel(conversionForm)
mainLabel.Caption = 'Value'
local mainEdit = createEdit(conversionForm)
mainEdit.Top = mainLabel.Top + mainLabel.Height + 5

local hex=1
local signed=2
local unsigned=3
local octal=4
local binary=5
local ascii=6
local unicode=7
local num = unicode

local editBoxes = {}
local peb = mainEdit
for i=1,num do
  local eb = createEdit(conversionForm)
  eb.Top = peb.Top + peb.Height + 5
  eb.Width = conversionForm.Width
  editBoxes[i] = eb
  peb = eb
end
conversionForm.Height = peb.Top + peb.Height

local function toBits(num,bits)
    -- returns a table of bits, most significant first.
    bits = bits or math.max(1, select(2, math.frexp(num)))
    local t = {} -- will contain the bits        
    for b = bits, 1, -1 do
        t[b] = math.fmod(num, 2)
        num = math.floor((num - t[b]) / 2)
    end
    return t
end

mainEdit.OnChange = function()
  local num = tonumber(mainEdit.Text)

  local memstream = createMemoryStream()
  memstream.write(dwordToByteTable(num))
  local mem = memstream.Memory

  editBoxes[hex].Text = num and ('%X'):format(num) or 'invalid'
  editBoxes[signed].Text = tostring(readIntegerLocal(mem, true))
  editBoxes[unsigned].Text = tostring(readIntegerLocal(mem, not true))
  editBoxes[octal].Text = ('%o'):format(num) or 'invalid' -- might only be lowercase o
  local bits = toBits(num, 32)
  bits = table.concat(bits) -- keep forgetting concat doesn't take a separator in lua...
  editBoxes[binary].Text = bits:gsub('(%d%d%d%d)', '%1 ')

  editBoxes[ascii].Text = readStringLocal(mem, 10)
  editBoxes[unicode].Text = readStringLocal(mem, 10, true)
  memstream.destroy()
end

extMenuItem.OnClick = function()
  conversionForm.show()
end

```

`DisassemblerHighlight.lua`:

```lua
--##### RegisterHighlight Script
--##### Author: FreeER (based on code from STN)
--##### Website: http://forum.cheatengine.org/viewtopic.php?t=604314
--##### Github: https://github.com/FreeER
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  http://forum.cheatengine.org/viewtopic.php?p=5731529
  provides a way to highlight things in the disassembler, click the new menu option
  and type in what you want highlighted eg. eax
  note: highlights are global, they affect all disassemblers not just the one it was done from
  note2: uncomment the 'local staticColor' line below to have a static color rather than random flashes
]]

-- BGR
--local staticColor = 0xAE33AE
local menuCaption = 'Disassembler Highlight'
if getCEVersion() < 6.4 then
  error(menuCaption .. " requires CE >= 6.4, update CE!")
end

local function addColorCodes(ps,reg)
  --local ps = "{R}edx(N),{S}Tutorial-1386.exe+201004{N}"
  local lowerps = ps:lower()
  local found=1, last
  local format = "{C%0.6x}%s{N}"
  -- if all letters (ignoring whitespace) then prepend with } so ax only matches ax not eax
  -- else assume the user knows what they wanted and use their input
  -- hopefully there's not an exploit by passing crafted data to find
  local nospaces = reg:gsub('%s',''):lower()
  local lowerreg = nospaces:find('%W') ~= 1 and '}' .. nospaces or reg
  local newcolor = staticColor and staticColor or math.floor(math.random()*0xffffff)
  while true do
    found, last = lowerps:find(lowerreg, last)
    if not found then break end
    local match = ps:sub(lowerps:find(nospaces,found),last)
    local new = format:format(newcolor, match)
    ps = ps:sub(1,found-1) .. new .. ps:sub(last+1)
    last = found + #new
  end
  return ps
end

local function enableHighlight()
  local reg = inputQuery(menuCaption, "What do you want to highlight?", targetIs64Bit() and "RAX" or "EAX")
  local visDis = getVisibleDisassembler()
  if not reg or reg:gsub("%s","") == "" then visDis.OnPostDisassemble=nil return end

  function f(sender, address, LastDisassembleData, result, description) 
    if not sender.syntaxHighlighting then return end
    LastDisassembleData.parameters = addColorCodes(LastDisassembleData.parameters, reg)
    return result,description 
  end 

  visDis.OnPostDisassemble = f
end

local function createMenu(f)
  local items = f.menu.Items
  for j=0,items.Count-1 do
    if items[j].Caption == menuCaption then return end
  end
  local themenu = createMenuItem(f.Menu)
  themenu.Caption = menuCaption
  themenu.OnClick = enableHighlight
  items.add(themenu)
end

-- add menu to main memory view form
createMenu(getMemoryViewForm())

-- remember when the user pastes a memory record to workaround a bug
local ctrlv_time = os.clock()

-- keyboard shortcut
local ctrlv = createHotkey(function(hk) ctrlv_time = os.clock() end, VK_CONTROL, VK_V)

-- menu
local pasteMenuItem = nil
-- find the menu item for paste
local it = MainForm.PopupMenu2.Items
for i=0,it.Count-1 do
  if it[i].Caption == 'Paste' then
    pasteMenuItem = it[i]
    break
  end
end
if not pasteMenuItem then error('failed to find paste menu item') end

-- add an onclick function
local pasteMenuItem_onclick = pasteMenuItem.OnClick
pasteMenuItem.OnClick = function(...)
  ctrlv_time = os.clock()
  if pasteMenuItem_onclick and type(pasteMenuItem_onclick) == 'function' then
    pasteMenuItem_onclick(...)
  end
end

-- setup event to add menu to new forms
-- seems to get an invalid form on paste that causes an error, no idea why
registerFormAddNotification(function(form)
  -- captions/names don't seem to be set yet so start a timer to check later
  local t = createTimer()
  t.OnTimer = function(t)
    -- stop checking (only checks once after a delay)
    t.destroy()
    -- if the user just copy/pasted a memory record then don't check (bug workaround)
    if os.clock() - ctrlv_time < 0.5 then return end
    -- check if it's a memory viwer form
    if form.Name:find("MemoryBrowser") then createMenu(form) end
  end
  t.Interval = 300
end)

```

`HexViewCopyNBytes.lua`:

```lua
--this script adds "Copy N Bytes to Clipboard option" 
-- based on http://forum.cheatengine.org/viewtopic.php?p=5735612#5735612

local mv=getMemoryViewForm() 

local oldmemorypopuponpopup 
if miCopyNBytes~=nil then 
  miCopyNBytes.destroy() 
  miCopyNBytes=nil 
  mv.memorypopup.OnPopup=oldmemorypopuponpopup 
  oldmemorypopuponpopup=nil 
end 

miCopyNBytes=createMenuItem(mv.memorypopup) 
miCopyNBytes.Name="miCopyNBytes" 
miCopyNBytes.Caption="Copy N Bytes to clipboard" 
miCopyNBytes.ShortCut=textToShortCut("Ctrl+Shift+B")
miCopyNBytes.OnClick=function() 
  local hv=mv.HexadecimalView 
  -- start at current selection
  local start = inputQuery('Start', 'Starting address', ('%X'):format(mv.HexadecimalView.SelectionStart))
  if not start then return end

  -- start with current selection or 32
  local numbytes = mv.HexadecimalView.SelectionStop-mv.HexadecimalView.SelectionStart
  if not numbytes or numbytes == 0 then numbytes = 32 end
  numbytes = inputQuery('Number of Bytes', 'Number of Bytes', numbytes)
  if not numbytes then return end
  numbytes = tonumber(numbytes)
  if not numbytes then return end -- if it failed to convert

  local format = '%02X '
  local bytes = readBytes(start, numbytes, true)
  if not bytes then print('failed to read bytes') return end
  writeToClipboard(format:rep(#bytes):format(unpack(bytes)))
end 

mv.memorypopup.Items.insert(mv.Cut1.MenuIndex-1, miCopyNBytes) 

oldmemorypopuponpopup=mv.memorypopup.OnPopup 
mv.memorypopup.OnPopup=function(s) 
  miCopyNBytes.Visible=true
  return oldmemorypopuponpopup(s) 
end 

```

`LuaEngineTransparency.lua`:

```lua
--##### Lua Engine Transparency Script for Cheat Engine
--##### Author: FreeER (based on DB code snippet)
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  http://forum.cheatengine.org/viewtopic.php?t=606479
  add a menu option to make the lua engine always on top and transparent (based on given alpha value 0-255)
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Lua Engine Transparency'
local requiredVersion = 6.4 -- requirement for inputQuery
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

local stateTransparent = false
local previousValue = 127

local function enableTransparency()
  local alpha = inputQuery('Alpha/Opacity/Transparency value','Alpha/Opacity/Transparency value: ',  previousValue)
  if not alpha then return end -- if they hit cancel

  local f=getLuaEngine() 
  f.AlphaBlend=true 
  f.AlphaBlendValue = alpha
  previousValue = alpha
  stateTransparent = true
  
  f.FormStyle="fsSystemStayOnTop" 
end

local function disableTransparency()
  local f=getLuaEngine() 
  f.AlphaBlend=false
  stateTransparent = false

  f.FormStyle="fsNormal" 
end


extMenuItem.OnClick = function()
  if stateTransparent then
    disableTransparency()
  else
    enableTransparency()
  end
end

```

`SaveDissectCode.lua`:

```lua
--##### Save Dissect Code Lua Script for Cheat Engine
--##### Author: FreeER (based on DB code snippet)
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  http://www.cheatengine.org/forum/viewtopic.php?t=580166&sid=2f5184fda985975d19a859a4de193cc7
  adds a menu option to save dissected code data
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Save Dissect Code'
local requiredVersion = 6.4 -- requirement for inputQuery
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

local function saveDissectCode(dc)
  local fd = createSaveDialog(nil)
  fd.Filter = 'DisectCode|*.DC|All Files|*.*'
  local picked = fd.Execute()
  if not picked then return false end
  dc.saveToFile(fd.FileName)
  fd.destroy()
end

local function loadDissectCode(dc)
  local fd = createOpenDialog(nil)
  fd.Filter = 'DisectCode|*.DC|All Files|*.*'
  local picked = fd.Execute()
  if not picked then return false end
  dc.loadFromFile(fd.FileName)
  fd.destroy()
end

extMenuItem.OnClick = function()
  local dc = getDissectCode()
  if dc.getReferencedFunctions() == nil and dc.getReferencedStrings() == nil then
    loadDissectCode(dc)
  else
    res = inputQuery('Save, load, or clear?', 'save, load, or clear: ', 'save')
    if not res then return end -- quit if canceled
    res = res:lower()
    if res == 'save' then
      saveDissectCode(dc)
    elseif res == 'load' then
      loadDissectCode(dc)
    elseif res == 'clear' then
      dc.Clear()
    else
      showMessage(res .. ' is not save, load, or clear!')
    end
  end
end

```

`SoundOnBP.lua`:

```lua
--##### Play Sound on BreakPoint
--##### Author: FreeER
--##### Website: http://forum.cheatengine.org/viewtopic.php?t=604314
--##### Github: https://github.com/FreeER
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[ Beeps on added breakpoints ]]

local menuCaption = 'SoundOnBP'
if getCEVersion() < 6.4 then
  error(menuCaption .. " requires CE >= 6.4, update CE!")
end

FreeER = FreeER or {}
FreeER.SoundOnBP = {}
FreeER.SoundOnBP.BPS = {}
FreeER.SoundOnBP.Sound = findTableFile('Activate') -- comes with CE

local bps = FreeER.SoundOnBP.BPS

local function hasBP(addr)
  addr = GetAddressSafe(addr)
  local list = debug_getBreakpointList()
  for _,ad in ipairs(list) do
    if ad == addr then return true end
  end
end

local oldDebugger_onBreakpoint=nil
if debugger_onBreakpoint then oldDebugger_onBreakpoint = debugger_onBreakpoint end
debugger_onBreakpoint = function(...)
  if not bps[EIP] then
    if oldDebugger_onBreakpoint then return oldDebugger_onBreakpoint(...) end
    return 0 -- not registered for sound and no other handler so just break and update
  end

  playSound(FreeER.SoundOnBP.Sound)
  if bps[EIP] == co_run then
    if oldDebugger_onBreakpoint then oldDebugger_onBreakpoint(...) end
    debug_continueFromBreakpoint(co_run)
    return not 0
  else
    if oldDebugger_onBreakpoint then return oldDebugger_onBreakpoint(...) end
    return 0 -- break and update interface
  end
end

local function createMenu(f)
  local items = f.menu.Items
  for j=0,items.Count-1 do
    if items[j].Caption == menuCaption then return end
  end
  local themenu = createMenuItem(f.Menu)
  themenu.Caption = menuCaption
  themenu.OnClick = function()
    local dis = f.DisassemblerView
    local addr = GetAddressSafe(dis.SelectedAddress)
    if not bps[addr] and not hasBP(addr) then
      debug_setBreakpoint(addr)
      bps[addr] = co_run
    else
      if bps[addr] == co_run then debug_removeBreakpoint(addr) end
      if debug_isBroken() and EIP == addr then debug_continueFromBreakpoint(co_run) end
      bps[addr] = false
    end
  end
  items.add(themenu)
end

-- add menu to main memory view form
createMenu(getMemoryViewForm())

-- remember when the user pastes a memory record to workaround a bug
local ctrlv_time = os.clock()

-- keyboard shortcut
local ctrlv = createHotkey(function(hk) ctrlv_time = os.clock() end, VK_CONTROL, VK_V)

-- menu
local pasteMenuItem = nil
-- find the menu item for paste
local it = MainForm.PopupMenu2.Items
for i=0,it.Count-1 do
  if it[i].Caption == 'Paste' then
    pasteMenuItem = it[i]
    break
  end
end
if not pasteMenuItem then error('failed to find paste menu item') end

-- add an onclick function
local pasteMenuItem_onclick = pasteMenuItem.OnClick
pasteMenuItem.OnClick = function(...)
  ctrlv_time = os.clock()
  if pasteMenuItem_onclick and type(pasteMenuItem_onclick) == 'function' then
    pasteMenuItem_onclick(...)
  end
end

-- setup event to add menu to new forms
-- seems to get an invalid form on paste that causes an error, no idea why
registerFormAddNotification(function(form)
  -- captions/names don't seem to be set yet so start a timer to check later
  local t = createTimer()
  t.OnTimer = function(t)
    -- stop checking (only checks once after a delay)
    t.destroy()
    -- if the user just copy/pasted a memory record then don't check (bug workaround)
    if os.clock() - ctrlv_time < 0.5 then return end
    -- check if it's a memory viwer form
    if form.Name:find("MemoryBrowser") then createMenu(form) end
  end
  t.Interval = 300
end)

```

`TableFileIterator.lua`:

```lua
--##### TableFileIterator script for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  note you should probably just use Tim's code https://forum.cheatengine.org/viewtopic.php?p=5734555&sid=cb7c5b0af732c46cb766f12d627975dd
  But if you really want to continue using this, I updated it for 7.4


  provides two functions tableFileIterator and tableFileIteratorReverse which
  return iterators for CE's table files, only works for versions with offsets
  listed in table below because it works by reading memory directly.
  Probably best not to store the iterators since the table files could change before use...

  If getCheatEngineFileVersion function does not exist, it also provides that

  inspired by http://forum.cheatengine.org/viewtopic.php?p=5734637#5734637
]]

-- https://youtu.be/s87WtAw636M updating offsets for different versions
-- (first 5 minutes, rest is a quick attempt to show why it works)
--
-- text explanation
-- to find offsets start 2 instances of CE, in the first add some tablefiles in the second scan for the number of table files there are
-- find what accesses the address, you'll find an instruction with either 0x10 (x64) or 0x8, take the register value (probably in *bx)
-- and scan for it, you should only have a few results, check each to see which is accessed when you click the Tables menu
-- once you've found the one that's actually used, that's the offset from the MainForm
-- the key in the table below is the integer (first) result of getCheatEngineFileVersion()
local knownTableFileOffsets = {
  [1688879925040206] = {0x0900}, -- CE 6.7 x86, 0x0910 for rcg4u's CE with same file version...
  [1688879925040207] = {0x1058}, -- CE 6.7 x64, 0x1078 for rcg4u's CE with same file version...
  [1688875630072592] = {0x08F0}, -- CE 6.6 x86
  [1688875630072593] = {0x1030}, -- CE 6.6 x64
  [1688884220007827] = {0x0938}, -- CE 6.8 x86
  [1688884220007828] = {0x10C8}, -- CE 6.8 x64
  [1688884220073440] = {0x10C8, 0x0938}, -- CE 6.8.1 x64, x86, same file version!
  [1688884220139078] = {0x10E0, 0x0948}, -- CE 6.8.2
  [1688884220204715] = {0x10E0, 0x0948}, -- CE 6.8.3 pre-postfix
  [1688884220204718] = {0x10E0, 0x0948}, -- CE 6.8.3 postfix
  [1970324836980594] = {0x11A8, 0x09B0},  -- CE 7.0
  [1970324836980599] = {0x11B0, 0x09B4},  -- CE 7.0 rerelease
  [1970329131948227] = {0x11C8, 0x09BC},  -- CE 7.1 release
  [1970329131948229] = {0x11C8, 0x09BC},  -- CE 7.1 rerelease
  [1970333426915724] = {0x11E0, 0x09C8},  -- CE 7.2
  [1970342016851077] = {0x1140, 0x09DC},  -- CE 7.4, x64, x86
}

if not getCheatEngineFileVersion then
  -- getCheatEngineFileVersion does not exist in CE 6.6
  function getCheatEngineFileVersion()
    local cepid = executeCodeLocal('GetProcessId',-1) -- getCheatEngineProcessID also does not exist in 6.6
    local cename = getProcesslist()[cepid]
    return getFileVersion(getCheatEngineDir() .. cename)
  end
end

local function getTableFileOffset()
  local offsets = knownTableFileOffsets[getCheatEngineFileVersion()]
  if not offsets then return nil end
  --when both the x86 and x64 exes have the same file version
  return offsets[CheatEngineIs64Bit() and 1 or 2]
end

if not getTableFileOffset() then
  local msg = "unkown CE version %d, update offset for TableFile\nRun shellExecute(getCheatEngineDir() .. 'autorun') to open autorun directory and fix the table file"
  print(msg:format(getCheatEngineFileVersion()))
  return
end

local TFPGListOfTLuaFilesOffset = getTableFileOffset()
local pointerSize = cheatEngineIs64Bit() and 8 or 4
local TFPGListOfTLuaFiles = readPointerLocal(userDataToInteger(getMainForm())+TFPGListOfTLuaFilesOffset)

-- warning it's probably not safe to delete files directly from the iterator
-- create a table using it or try the reverse table iterator which _may_ be safer
function tableFileIterator()
  -- https://www.lua.org/pil/7.1.html
  local i = 0
  local itemsBase = readPointerLocal(TFPGListOfTLuaFiles + pointerSize)
  return function()
    local count = readIntegerLocal(TFPGListOfTLuaFiles + pointerSize*2)
    if i < count then
      local file = integerToUserData(readPointerLocal(itemsBase+pointerSize*i))
      i = i + 1
      return file
    end
  end
end

function tableFileIteratorReverse()
  -- https://www.lua.org/pil/7.1.html
  local i = readIntegerLocal(TFPGListOfTLuaFiles + pointerSize*2)-1
  local itemsBase = readPointerLocal(TFPGListOfTLuaFiles + pointerSize)
  return function()
    local count = readIntegerLocal(TFPGListOfTLuaFiles + pointerSize*2)
    if i < count and i >= 0 then
      local file = integerToUserData(readPointerLocal(itemsBase+pointerSize*i))
      i = i - 1
      return file
    end
  end
end

--[[
for file in tableFileIterator() do
  print(file.name)
end
]]

```

`addElementsTostructure.lua`:

```lua
--##### Add Elements To Structure Lua Function for Cheat Engine
--##### Author: FreeER (based on https://github.com/cheat-engine/cheat-engine/issues/243 by rcg4u)
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw

FreeER = FreeER or {}

--[[
  adds addElementsToStructure function to let you add multiple elements to a struction, eg. 30 byte elements
  see function comment for more info
]]
local function getStructureIDByName(name)
  local lname = name:lower()
  local casematch = nil
  local count = getStructureCount()-1
  for i=0, count do
    local struct = getStructure(i)
    -- if there are two structs with the exact same name, not my problem if you get the wrong one!
    if struct.Name == name then return i
    elseif struct.Name:lower() == lname then
      if casematch == nil then casematch = i
        -- potentially misses case where exact match exists after two caseinsensitive matches
        -- ... can fix easily enough with two loops but... people probably should have that many
        -- structures with the same name right? right? I'll find out I guess lol
      else return nil, "more than one structure matches when ignoring case" end
    end
  end
  if casematch then return casematch else return nil, ("No structure with the name '%s' exists"):format(name) end
end

local function getStructureByName(name)
  local id, errmsg = getStructureIDByName(name)
  if not id then return nil, errmsg
  else return getStructure(id) end
end

function getStructureByIdent(ident)
  if type(ident) == 'number' then return getStructure(ident)
  elseif type(ident) == 'string' then return getStructureByName(ident)
  else return nil end
end

-- if vtType is basic returns appropriate size else size arg
local function vtTypeSize(vtType, size)
      if vtType == vtByte then return 1
  elseif vtType == vtWord then return 2
  elseif vtType == vtDword then return 4
  elseif vtType == vtQword then return 8
  elseif vtType == vtSingle then return 4
  elseif vtType == vtDouble then return 8
  elseif vtType == vtString then return size
  elseif vtType == vtUnicodeString then return size
  elseif vtType == vtByteArray then return size
  elseif vtType == vtBinary then return size
  elseif vtType == vtAutoAssembler then return nil
  elseif vtType == vtPointer then return targetIs64Bit() and 8 or 4
  elseif vtType == vtCustom then return size
  elseif vtType == vtGrouped then return size
  else return error("Unknown varType", 2) end
end

--[[
ident is structure or index/name of structure
starting offset to begin adding elements at
info table of Vartype and optionally ChildStruct, ChildStructStart, ByteSize, displayMethod
  ChildStruct may be either an ident or the struct itself
  displayMethod may be either 'dtHexadecimal', 'dtSignedInteger' or 'dtUnSignedInteger'
numElems is number of elements to add
if endOffset is provided that's used instead of numElems
]]
function addElementsToStructure(ident,startOffset,info,numElems,endOffset)
  local struct
  if type(ident) == 'userdata' then
    if ident.ClassName ~= 'TDissectedStruct' then error(ident.ClassName .. ' is not a valid structure!')
    else struct = ident end
  else struct = getStructureByIdent(ident) end
  if not struct then error("no valid structure given!", 2) end

  local elementSize = vtTypeSize(info.Vartype, info.ByteSize)

  local cs = info.ChildStruct
  if cs and (type(cs) == 'number' or type(cs) == 'string') then cs = getStructureByIdent(cs)
  elseif cs and type(cs) == 'userdata' then
    if cs.ClassName ~= 'TDissectedStruct' then cs = '' end
  elseif cs then cs = '' end

  endOffset = endOffset or startOffset+(numElems-1)*elementSize

  for offset=startOffset, endOffset, elementSize do
    local se = struct.addElement()
    se.Offset = offset
    -- hm... maybe use a loop to add anything in the table?
    se.Vartype = info.Vartype
    se.ChildStruct = cs
    se.ChildStructStart = info.ChildStructStart
    se.ByteSize = info.ByteSize
    se.displayMethod = info.displayMethod
  end
end

FreeER.addElementsToStructure = addElementsToStructure

```

`attachToMostMemoryProcess.lua`:

```lua
--##### Attach To Most Memory Process for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a menu option to try and attach to the process with the most memory (based on exe name)
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'attachToMostMemoryProcess'
local requiredVersion = 6.4 -- requirement for inputQuery
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

local function getMemory(procname)
  local cmd = ('tasklist /FI "IMAGENAME eq %s" /NH'):format(procname)
  local h = io.popen(cmd)
  local res = h:read('*a')
  h:close()
  --print(res:gsub('\n','\r\n'))
  if res:find('No tasks are running') then error(('No tasks named %s found'):format(procname), 2) end

  local list = {}
  local factorTable = {M=1024*1024,K=1024,G=1024*1024*1024,B=1}
  for info in res:gmatch('[^\n]+') do
    local pid, mem = info:match('.+%s+(%d+)%s+.+%s+%d+%s+(.+%s%a)')
    local pid = tonumber(pid)
    local mfactor = factorTable[mem:sub(-1)] or 1
    local num = mem:sub(1,-2):gsub(',', '')
    --print(mem)
    --print(num, mfactor)
    local nmem = tonumber(num) * mfactor / 1024
    list[pid] = nmem
  end
  return list
end

local function findmax(list)
  local maxPID, maxMem = 0, 0
  for pid, mem in pairs(list) do
    if mem > maxMem then
      maxMem = mem
      maxPID = pid
    end
  end
  return maxPID, maxMem
end

extMenuItem.OnClick = function()
  local name = InputQuery('Process Name + .exe', "What's the process name?", 'chrome.exe')
  openProcess(findmax(getMemory(name)))
end

```

`autosave.lua`:

```lua
--##### Auto Backup Script for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
------------- based on work by akumakuja28 and Dark Byte -------------
------ see http://forum.cheatengine.org/viewtopic.php?t=602701 -------
-- and http://forum.cheatengine.org/viewtopic.php?p=5468951#5468951 --
---------------------------------------------------------------------- 
]]


----------------------------------------------------------------------
--------------------------- START OF CONFIGURATION -------------------
----------------------------------------------------------------------
local numSaves = 5
local tableSaveTime = 5 -- every n seconds
local luaEngineDelay = 5 -- seconds since typing to save
local saveInFormDesigner = true -- seems to reset selected items and properties/events scrollbar
-- ^ alternative is to open lua engine and type FreeER.autosave.tableSaves.timer.enabled = false
-- that does however completely disable the table saves, not just when the FormDesigner is open
-- so do not forget to reenable them :)
-- you can also access the lua script timer with FreeER.autosave.luaSaves.timer
----------------------------------------------------------------------
---------------------------  END OF CONFIGURATION --------------------
----------------------------------------------------------------------
local mScript = getLuaEngine().Component[11]
local CE_D = getCheatEngineDir()
local FileToCheck = CE_D..[[Bak\Dir_Check.txt]]
local FileToOpen = io.open (FileToCheck)
local CE_Open_Time = (os.date ("%c"))
local Time = CE_Open_Time:gsub("/", "."):gsub(":", ".")
local luaSaves = {}
  luaSaves.current = 1
  for i=0,numSaves do
    luaSaves[i] = ('%s\\Bak\\%s-lua-%i.lua'):format(CE_D, Time, i)
  end
  luaSaves.next = function()
    local Bak = luaSaves[luaSaves.current]
    luaSaves.current = (luaSaves.current % #luaSaves) + 1
    return Bak
  end
  luaSaves.timer = createTimer(getMainForm(),false)
  luaSaves.timer.Interval = 50
  luaSaves.typedTime = 0
  
local tableSaves = {}
  tableSaves.current = 1
  for i=0,numSaves do
    tableSaves[i] = ('%s\\Bak\\%s-table-%i.ct'):format(CE_D, Time, i)
  end
  tableSaves.prev = function()
    local id = tableSaves.current - 1
    if id < 1 then id = numSaves end
    return tableSaves[id]
  end
  tableSaves.peek = function()
    local Bak = tableSaves[tableSaves.current]
    return Bak
  end
  tableSaves.next = function()
    local Bak = tableSaves[tableSaves.current]
    tableSaves.current = (tableSaves.current % #tableSaves) + 1
    return Bak
  end
  tableSaves.timer=createTimer(getMainForm())
  tableSaves.timer.Interval = tableSaveTime*1000

if FileToOpen == nil then
  -- print('No File Exist')
  local Chr = [[chdir XXX && mkdir Bak]]
  local DirMake = string.gsub(Chr,"XXX",getCheatEngineDir())
  os.execute(DirMake)
  local f = io.open(FileToCheck,"w")
  f:write("This file is to check if directory exists.")
  f:close()
end

---------------------------------------------------------------------
------------------------------ SAVING FUNCTIONS ---------------------
---------------------------------------------------------------------

local function Write_Lua_Bak()
  local Bak = luaSaves.next()
  local f = io.open(Bak,'w')
  --print('saving lua to', Bak)

  for l=0, mScript.Lines.Count do
    f:write(mScript.Lines[l].."\n")
  end

  f:close()
end

local function Update_Lua_Bak_Timer(t)
  local now = os.clock()
  --print(now - luaSaves.typedTime)
  if now - luaSaves.typedTime > luaEngineDelay then
    Write_Lua_Bak()
    t.Enabled = false
  end
end

local function getFormDesigner()
  for i=0,getFormCount()-1 do
    local f = getForm(i)
    if(f.name == 'FormDesigner') then return f end
  end
end

--[[
local function addMultiSelectedItems(t, items)
  for i=0,items.Count-1 do
    local it = items[i]
    if it.MultiSelected then t[#t+1] = it end
    if it.HasChildren and it.items then addMultiSelectedItems(t, it.items) end
  end
end
]]
  --[[ saveTable resets FormDesigner selection... save and restore it
  local Selected = nil
  local MultiSelected = {}
  if FormDesigner then
    local insp = FormDesigner.ObjectInspectorDlg
    local tree = insp.ComponentTree
    Selected = tree.getSelected()
    addMultiSelectedItems(MultiSelected, tree.Items)
  end]]

  --[[ restore selection
  if FormDesigner then
    local insp = FormDesigner.ObjectInspectorDlg
    local tree = insp.ComponentTree
    local first = tree.Items[0]
    first.Selected = false
    first.MultiSelected = false
    tree.Selected = Selected
    for _,item in ipairs(MultiSelected) do item.MultiSelected = true end
  end
  ]]

local function Write_Table_Bak()
  local Bak = tableSaves.peek()
  --print('saving table to', Bak)

  local FormDesigner = getFormDesigner()
  if FormDesigner and not saveInFormDesigner then return end

  saveTable(Bak)

  local prv = tableSaves.prev()
  -- if they are the same then next time just overwrite the same one
  local file = io.open(prv)
  local overwriteNextTime
  if file then
    overwriteNextTime = md5file(prv) ~= md5file(Bak)
    file:close()
  else
    overwriteNextTime = true
  end
  if overwriteNextTime then
    --print('moving to next')
    tableSaves.next()
  end
end

---------------------------------------------------------------------
------------------------------ SETUP EVENT HANDLERS -----------------
---------------------------------------------------------------------
--print('creating event handlers')
luaSaves.timer.OnTimer = Update_Lua_Bak_Timer
mScript.OnChange = function()
  luaSaves.typedTime = os.clock()
  luaSaves.timer.Enabled = true
  --print(luaSaves.timer.Enabled and 'enabled timer' or 'failed')
end

tableSaves.timer.OnTimer = Write_Table_Bak
FreeER = FreeER or {}
FreeER.autosave = {}
FreeER.autosave.luaSaves = luaSaves
FreeER.autosave.tableSaves = tableSaves

```

`convertStructDisplay.lua`:

```lua
--##### Convert Struct Display (type) Lua Function for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  provides a function called convertStructDisplay that takes the name of a
  struct, the display type to change, and the new displa type
  all elements of the first given type will be changed to the second given type
    valid display types = 'dtHexadecimal', 'dtUnSignedInteger', and 'dtSignedInteger'
]]

FreeER = FreeER or {}
local function getStructureIDByName(name)
  local lname = name:lower()
  local casematch = nil
  local count = getStructureCount()-1
  for i=0, count do
    local struct = getStructure(i)
    -- if there are two structs with the exact same name, not my problem if you get the wrong one!
    if struct.Name == name then return i
    elseif struct.Name:lower() == lname then
      if casematch == nil then casematch = i
        -- potentially misses case where exact match exists after two caseinsensitive matches
        -- ... can fix easily enough with two loops but... people probably should have that many
        -- structures with the same name right? right? I'll find out I guess lol
      else return nil, "more than one structure matches when ignoring case"
      end
    end
  end
  if casematch then return casematch else return nil, ("No structure with the name '%s' exists"):format(name) end
end

local function getStructureByName(name)
  local id, errmsg = getStructureIDByName(name)
  if not id then
    return nil, errmsg
  else
    return getStructure(id)
  end
end

-- valid display types = 'dtHexadecimal', 'dtUnSignedInteger', and 'dtSignedInteger'
function convertStructDisplay(structName, displayToChange, newDisplay)
  local s = getStructureByName(structName)
  for i=0, s.Count-1 do
    local e = s.Element[i]
    if e.DisplayMethod == displayToChange then e.DisplayMethod = newDisplay end
  end
end
FreeER.convertStructDisplay = convertStructDisplay

```

`copyOffsets.lua`:

```lua
--##### Copy Pointer Offsets for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  http://cheatthegame.net/?view=thread&id=37&part=1#postid-48
  adds a context menu option to print offsets for pointers
]]

local function findMenu(mi)
  while not mi.Menu do mi = mi.Parent end
  return mi.Menu
end
local del_mi = MainForm.Deletethisrecord1
local del_menu = findMenu(del_mi)

local mi = createMenuItem(del_menu)
mi.Caption = 'Print Offsets'

local function printOffsets(memrec)
  print(memrec.Description)
  local base,offsets=memrec.getAddress()
  print(base)
  if not offsets then return end
  local combined = ('['):rep(#offsets) .. base
  for i=#offsets, 1, -1 do
    local hex = ('%02X'):format(offsets[i])
    print(hex)
    combined = ('%s]+%s'):format(combined,hex)
  end
  print(combined)
  print('')
end

mi.OnClick = function()
  local al = getAddressList()
  local records = al.getSelectedRecords()
  for k,v in pairs(records) do
    if v.Type ~= vtAutoAssembler and not v.isGroupHeader then
      printOffsets(v)
    end
  end
end
del_menu.Items.insert(del_mi.MenuIndex, mi)


```

`createBanner.lua`:

```lua
--##### Create BannerLua Function for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  provides a function called createBanner that tries to do this:

------------------------------------------------------------------------------------
------------------------- Cheat Engine Auto Backup Script --------------------------
-- based on http://forum.cheatengine.org/viewtopic.php?t=602701 and DB's autosave --
------------------------------------------------------------------------------------ 

or with something more complex: print(createBanner(lines, '_-~=~-'))
_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-
__-~=~-_-~=~-_-~=~-_-~=~- Cheat Engine Auto Backup Script _-~=~-_-~=~-_-~=~-_-~=~--~
_- based on http://forum.cheatengine.org/viewtopic.php?t=602701 and DB's autosave ~=
_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~-_-~=~- 

created as a test of the time delay for my autosave script
]]

FreeER = FreeER or {}

function createBanner(lines, fillStr)
  if type(lines) == 'string' then
    local it = lines:gmatch('[^\r\n]+')
    lines = {}
    for line in it do
      lines[#lines+1] = line
    end
  end
  local Infinity = 1e309
  local maxlength = -Infinity
  for _,line in ipairs(lines) do
    if #line > maxlength then maxlength = #line end
  end
  maxlength = maxlength + 4
  for k,line in ipairs(lines) do
    local needed = math.floor((maxlength - #line) / #fillStr / 2)
    local filler = fillStr:rep(needed)
    local needExtra = maxlength - (needed*2*#fillStr + #line)
    local extra = needExtra and fillStr:rep(math.ceil(needExtra/#fillStr)):sub(1,needExtra) or ''
    local frontExtra = extra:sub(1,math.floor(#extra / 2))
    local endExtra = extra:sub(math.floor(#extra / 2)+1)
    lines[k] = ('%s%s %s %s%s'):format(frontExtra, filler, line, filler, endExtra)
  end
  maxlength = maxlength + 2 -- +2 for spaces around line
  local filler = fillStr:rep(math.ceil((maxlength) / #fillStr)):sub(1,maxlength)
  table.insert(lines, 1, filler)
  lines[#lines+1] = filler
  return table.concat(lines,'\r\n')
end

FreeER.createBanner = createBanner

```

`disableMono.lua`:

```lua
--##### Disable Mono Lua Script for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a menu option to disable mono in the Mono menu
]]

-- START OF EXT TEMPLATE CONFIG --
local extItemCaption = 'Disable'
-- START OF EXT TEMPLATE CONFIG --

-- menu code --
local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption

local t = createTimer()
t.Interval = 1000
t.OnTimer = function(t)
  if not miMonoTopMenuItem then return end
  extMenu = miMonoTopMenuItem
  extMenu.add(extMenuItem)
  t.destroy()
end
-- menu code --

extMenuItem.OnClick = function()
  monopipe.destroy()
  monopipe = nil
end

```

`docs_gvim.lua`:

```lua
-- thanks to EXOR
-- https://discord.com/channels/350750090463281172/350754184267694081/798965420173557781
function file_exists(name)
  local f=io.open(name,"r")
  if f~=nil then io.close(f) return true else return false end
end
local gvim = "C:/Program Files (x86)/Vim/vim82/gvim.exe"
if file_exists(gvim) then
  getMainForm().Help1[1].setOnClick( 
    function () shellExecute(gvim,'celua.txt',getCheatEngineDir()) end) 
end

```

`duplicatePointer.lua`:

```lua
--##### Duplicate Pointer for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a context menu option to duplicate pointers
]]

local function findMenu(mi)
  while not mi.Menu do mi = mi.Parent end
  return mi.Menu
end
local del_mi = MainForm.Deletethisrecord1
local del_menu = findMenu(del_mi)

local mi = createMenuItem(del_menu)
mi.Caption = 'Duplicate Pointer'

local function duplicateMR(main)
  local properties = {'Description', 'Address', 'CustomTypeName', 'Script',
    'Active', 'Color', 'ShowAsHex', 'ShowAsSigned', 'AllowIncrease',
    'AllowDecrease', 'Collapsed', 'Async', 'AsyncProcessing',
    'AsyncProcessingTime', 'OnActivate', 'OnDeactivate', 'OnDestroy',
  'OnGetDisplayValue', 'DontSave', 'isGroupHeader', 'options'}
  -- options is list of header options

  local mr = (AddressList or getAddressList()).createMemoryRecord()
  for _,p in ipairs(properties) do
    mr[p] = main[p]
  end

  if main.Type == vtString then
    mr.String.Size = main.String.Size
    mr.String.Unicode = main.String.Unicode
    mr.String.Codepage = main.String.Codepage
  elseif main.Type == vtBinary then
    mr.Binary.Startbit = main.Binary.Startbit
    mr.Binary.Size = main.Binary.Size
  elseif main.Type == vtByteArray then
    mr.Aob.Size = main.Aob.Size
  end

  mr.OffsetCount = main.OffsetCount
  for i=0,main.OffsetCount-1 do
    mr.OffsetText[i] = main.OffsetText[i]
  end
  for i=0,main.HotkeyCount-1 do
    mr.Hotkey[i] = main.Hotkey[i]
  end

  for i=0,main.Count-1 do
    duplicateMR(main.Child[i]).appendToEntry(mr)
  end
  --if main.IsReadable then mr.Value = main.Value end
  return mr
end

mi.OnClick = function()
  local al = AddressList or getAddressList()
  -- only main selected, doesn't really make sense to copy multiple since offsets would likely be different
  local mr = al.getSelectedRecord()
  if not mr then return end -- not sure how that would happen but :)
  if mr.Type == vtAutoAssembler or mr.Type == vtGroupHeader then return end

  local numCopies = inputQuery('How many copies', 'Copies:', '1')
  numCopies = tonumber(numCopies)
  if not numCopies or numCopies == 0 then return end
  if mr.OffsetCount < 1 then -- plain address / not a pointer
    local offsetDiff     = inputQuery('How much to change by', 'How much to change by', '4')
    offsetDiff       = tonumber(offsetDiff,16)
    if not offsetDiff then
      showMessage('Invalid offset difference, was not a number')
      return
    end
    local newOffset = offsetDiff
    for i=1,numCopies do
      local copy = duplicateMR(mr)
      copy.Address = copy.Address .. (' %s %X'):format(newOffset>0 and'+'or'-',math.abs(newOffset))
      newOffset = newOffset + offsetDiff
    end
  else
    local offsetToChange = inputQuery('Offset Index to change', 'Offset Index to change', '0')
    local offsetDiff     = inputQuery('How much to change by', 'How much to change by', '4')
    offsetToChange = tonumber(offsetToChange)
    offsetDiff     = tonumber(offsetDiff,16)
    if not offsetDiff or not offsetToChange then
      showMessage('Invalid offset index or difference was not a number')
      return
    elseif offsetToChange >= mr.OffsetCount then
      showMessage('offset index was too large!')
      return
    end

    for i=1,numCopies do
      local copy = duplicateMR(mr)
      local newOffset = copy.Offset[offsetToChange] + offsetDiff
      if(tonumber(copy.OffsetText[offsetToChange],16)) then
        newOffset = ('%s%X'):format(newOffset>0 and'+'or'-',math.abs(newOffset))
      else
        newOffset = copy.OffsetText[offsetToChange] .. (' %s %X'):format(newOffset>0 and'+'or'-',math.abs(newOffset))
      end
      copy.OffsetText[offsetToChange] = newOffset
    end
  end
end
del_menu.Items.insert(del_mi.MenuIndex, mi)

```

`genFromStruct.lua`:

```lua
--##### Generate Memory Records from Structure Lua Script for Cheat Engine
--##### Author: FreeER (based on DB code snippet)
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  https://www.youtube.com/watch?v=V3SZWJQnGYs
  Adds a menu option which generates memory records in the address list based
  on a given base address and structure (id or name)
  It also makes generateFromStructure available for other code to use
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- TODO better differentiation between x and valid ModalResult on closing
-- IDEA rethink if pointers without childStructs should be ignored or autoGened (note no named elems) etc.

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'GenFromStruct'
local requiredVersion = 6.4 -- requirement for inputQuery
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

local uniquifier = 0xFFFF

local function getStructureIDByName(name)
  local lname = name:lower()
  local casematch = nil
  local count = getStructureCount()-1
  for i=0, count do
    local struct = getStructure(i)
    -- if there are two structs with the exact same name, not my problem if you get the wrong one!
    if struct.Name == name then return i
    elseif struct.Name:lower() == lname then
      if casematch == nil then casematch = i
        -- potentially misses case where exact match exists after two caseinsensitive matches
        -- ... can fix easily enough with two loops but... people probably should have that many
        -- structures with the same name right? right? I'll find out I guess lol
      else return nil, "more than one structure matches when ignoring case"
      end
    end
  end
  if casematch then return casematch else return nil, ("No structure with the name '%s' exists"):format(name) end
end

local function getStructureByName(name)
  local id, errmsg = getStructureIDByName(name)
  if not id then
    return nil, errmsg
  else
    return getStructure(id)
  end
end

local function getNamedElementsFromStructure(struct)
  if not struct then error("No struct given to getNamedElementsFromStructure!", 2) end
  local elements = {}
  for i=0, struct.Count-1 do
    if struct.Element[i].Name ~= "" then
      table.insert(elements, struct.Element[i])
    end
  end
  return elements
end

local function flash(control, color, time)
  if not inheritsFromControl(control) then
    local class = inheritsFromObject(control) and control.ClassName or tostring(control)
    local err = "non control component (%s) given to flash"
    return error(err:format(class))
  end
  if not color then color = 0xFF end
  if not time then time = 300 end

  local og = control.Color
  control.Color = color
  local t = createTimer()
  t.Interval = time
  t.OnTimer = function(t)
    control.Color = og
    t.destroy()
  end
end

local function createStructForm(editBoxOnEnter, comboBoxSetup, buttonOnClick)
  structForm = createForm(false)
  local f = structForm
  f.Caption = 'Pick the structure'
  f.centerScreen()
  f.DoNotSaveInTable = true
  f.OnClose = function(sender)
    if sender.ModalResult >= uniquifier then return sender.ModalResult end
    -- else user clicked the x and we should signal that it was canceled
    sender.ModalResult = -1
    return sender.ModalResult
  end

  local e = createEdit(f)
  e.Name = 'EditBox'
  e.onKeyUp = editBoxOnEnter

  local c = createComboBox(f)
  c.Name = 'ComboBox'
  c.ReadOnly = true

  local b = createButton(f)
  b.Name = 'Button'
  b.OnClick = buttonOnClick

  if comboBoxSetup and type(comboBoxSetup) == 'function' then
    local success, err = pcall(comboBoxSetup,c,f)
    -- rethrow, with message that makes it obvious who caused the error
    if not success then error(("\r\ncomboBoxSetup failed: %s"):format(err), 2) end
  end

  e.Text = c.Items[0]
  return f
end

local function commonComboBoxSetup(c,f,comboMaxWidth)
  local b = f.Button
  local e = f.EditBox
  local swidth = getWorkAreaWidth()
  comboMaxWidth = math.min(math.max(comboMaxWidth + c.getExtraWidth(), 100), swidth)
  c.Width = comboMaxWidth

  e.Width = c.Width
  local cWidth = c.Width
  c.Left = c.getExtraWidth()/1.3 -- try to center it...
  e.Left = c.Left
  c.Top = e.Height
  c.ItemIndex = 0

  f.ClientWidth = cWidth
  f.ClientHeight = e.Height + c.Height + b.Height

  b.Caption = 'Submit'
  b.Left = (f.ClientWidth - b.Width)/2
  b.Top = c.Top + c.Height
end

local function structurePrompt()
  if not structForm then
    local function editOnEnter(sender, key)
      if key == VK_ENTER or key == VK_RETURN then
        local structName =  sender.Text
        if tonumber(structName) then
          local index = tonumber(structName)
          if getStructureCount() > index and index >= 0 then
            sender.Owner.ModalResult = index+uniquifier
          else flash(sender) end
        else
          local id,errmsg = getStructureIDByName(sender.Text)
          if id then sender.Owner.ModalResult = id+uniquifier else flash(sender) end
        end
      end
      return true
    end

    local function comboSetup(c,f)
      local mwidth = -1e309 -- negative infinity
      -- same order so ItemIndex == structure index
      for i=0,getStructureCount()-1 do
        local name = getStructure(i).Name
        mwidth = math.max(mwidth, c.canvas.getTextWidth(name))
        c.Items.add(name)
      end
      commonComboBoxSetup(c,f,mwidth)
    end

    local function buttonClick(sender)
      local c = sender.Owner.ComboBox
      sender.Owner.ModalResult = c.ItemIndex+uniquifier -- 0 ignored so +uniquifier
    end
    local f = createStructForm(editOnEnter,comboSetup, buttonClick)
  end

  structForm.Visible = false
  local res = structForm.showModal()
  if res < 0 then return nil, 'cancelled' end -- -1 when closed
  res = res - uniquifier
  -- simple fix to Access Violation on second use... lol
  structForm.destroy()
  structForm = nil
  return getStructure(res)
end

local function structureElementPrompt(struct)
  if not struct then error("No struct given to structureElementPrompt!", 2) end
  local namedElems = getNamedElementsFromStructure(struct)
  if not structForm then
    local function editOnEnter(sender, key)
      if key == VK_ENTER or key == VK_RETURN then
        local structName =  sender.Text
        if tonumber(structName,16) then
          local offset = tonumber(structName,16)
          sender.Owner.ModalResult = offset+uniquifier
        else
          local found = false
          for k,v in pairs(namedElems) do
            local c = sender.Owner.ComboBox
            if v.Name == sender.Text then
              sender.Owner.ModalResult = v.Offset + uniquifier
              found = true
              break
            end
          end
          if not found then flash(sender) end
        end
      end
      return true
    end

    local function comboSetup(c,f)
      local mwidth = -1e309 -- negative infinity
      for k,v in pairs(namedElems) do
        local name = v.Name
        local width = c.canvas.getTextWidth(name)
        if width > mwidth then mwidth = width end
        c.Items.add(name)
      end
      commonComboBoxSetup(c,f,mwidth)
    end

    local function buttonClick(sender)
      local c = sender.Owner.ComboBox
      for k,v in pairs(namedElems) do
        if v.Name == c.Items[c.ItemIndex] then
          sender.Owner.ModalResult = v.Offset+uniquifier
          break
        end
      end
    end
    local f = createStructForm(editOnEnter,comboSetup, buttonClick)
  end

  structForm.Visible = false
  local res = structForm.showModal()
  if res < 0 then return nil, 'cancelled' end -- -1 when closed
  res = res - uniquifier

  -- simple fix to Access Violation on second use... lol
  structForm.destroy()
  structForm = nil
  return res
end

-- mostly debug
local function nameFromVartype(type)
      if (type == vtByte)          then return 'Byte'
  elseif (type == vtWord)          then return 'Word'
  elseif (type == vtDword)         then return 'Dword'
  elseif (type == vtQword)         then return 'Qword'
  elseif (type == vtSingle)        then return 'Float'
  elseif (type == vtDouble)        then return 'Double'
  elseif (type == vtString)        then return 'String'
  elseif (type == vtUnicodeString) then return 'UnicodeString'
  elseif (type == vtByteArray)     then return 'ByteArray'
  elseif (type == vtBinary)        then return 'Binary'
  elseif (type == vtAutoAssembler) then return 'Auto Assembler Script'
  elseif (type == vtPointer)       then return 'Pointer'
  elseif (type == vtCustom)        then return 'Custom'
  elseif (type == vtGrouped)       then return 'Grouped'
  else                                  return ("'%s' is an unknown type"):format(type)
  end
end

local al = getAddressList()

local function offsetToStr(initialOffset, prependHex, invert)
  local offset = ("%+d"):format(initialOffset * (invert and -1 or 1))
  offset = ("%s %s%s"):format(offset:sub(1,1), 
    prependHex and '0x' or '',
    ("%X"):format(math.abs(initialOffset)))
  return offset
end

local function isMemRec(mr)
  return mr and mr.ClassName and mr.ClassName == 'TMemoryRecord'
end

local AllMemoryRecordOptions = {'moHideChildren', 'moActivateChildrenAsWell',
  'moDeactivateChildrenAsWell', 'moRecursiveSetValue',
  'moAllowManualCollapseAndExpand', 'moManualExpandCollapse'}
for k,v in ipairs(AllMemoryRecordOptions) do AllMemoryRecordOptions[v] = true end

local function memrecOptionsList(mr)
  if not isMemRec(mr) then error(('%s is not a memory record!'):format(mr), 2) end
  local options,temp = {}, {}
  for i in mr.Options:gmatch('[^,%[%]]+') do temp[i] = true end
  for k,v in ipairs(AllMemoryRecordOptions) do options[v] = (temp[v] == true) end
  return options
end

local function memrecOptionsSet(mr,option,value,shutUpIKnowWhatImDoing)
  if not isMemRec(mr) then error(('%s is not a memory record!'):format(mr), 2) end
  if type(option) ~= 'string' and not shutUpIKnowWhatImDoing then
    error(('Memory options must be strings!'):format(mr), 2)
  end

  local newOptions = {}
  for i in option:gmatch('[^,]+') do
    if not shutUpIKnowWhatImDoing and not AllMemoryRecordOptions[i] then
      error(('%s is not a valid memory record option!'):format(i), 2)
    end
    table.insert(newOptions, i)
  end

  local options = memrecOptionsList(mr)
  for k,v in ipairs(newOptions) do options[v] = value end

  -- table.concat only works for numeric indexes
  for k,v in pairs(options) do if type(k) == 'string' and v then table.insert(options,k) end end
  local new = '[' .. table.concat(options, ',') .. ']'

  mr.Options = new
end

-- no, we won't just take an address and generate one in the main addresslist
-- if that's what you want then you create a memrec there and set the addr for us
function generateFromStructure(mmr, struct, offsetUsesName, offset)
  local isPointer = mmr and struct and offset == "pointer"
  if isPointer then offset = nil end
  if offset and type(offset) ~= "number" then error(("Given offset '%s' is not a number!"):format(offset),2)
  elseif offset == nil then offset = 0
  end
  if struct and (not struct.ClassName or struct.ClassName ~= 'TDissectedStruct') then
    error(("'%s' is not a valid struct!"):format(struct),2)
  end

  if not (mmr and struct) then -- onclick or "api" w/o info
    if mmr == nil then
      mmr = al.SelectedRecord
      -- ignore if it's an AA script or group header with no set address
      if mmr.Type == vtAutoAssembler or (mmr.IsGroupHeader and mmr.Address == '') then return end
    end -- default to SelectedRecord

    if not mmr or not mmr.ClassName or not mmr.ClassName == "TMemoryRecord" then
      error(('%s is not a memory record'):format(tostring(mmr)),2)
    elseif mmr.Type == vtAutoAssembler then
      error(('%s is an AA script without an address!'):format(tostring(mmr)),2)
    end

    local errmsg = nil
    struct, errmsg = structurePrompt()
    if not struct then showMessage(errmsg) return end

    offset, errmsg = structureElementPrompt(struct)
    if not offset then showMessage(errmsg) return end

    offsetUsesName = messageDialog('Use struct.name for offset?', mtConfirmation, mbYes, mbNo) == mrYes
  end
  if offset ~= nil and offset ~= 0 then
    offset = offsetToStr(offset, mmr.Address:sub(1,1) == '$', true)
    mmr.Address = ("%s %s"):format(mmr.Address,offset)
  end

  local elems = getNamedElementsFromStructure(struct)
  for i,v in ipairs(elems) do
    local mr = al.createMemoryRecord()
    mr.Description = v.Name
    mr.Type = v.Vartype
    if not isPointer then
      mr.Address = offsetUsesName and ('+%s.%s'):format(struct.name,v.Name) or offsetToStr(v.Offset)
      mr.ShowAsHex = v.DisplayMethod == 'dtHexadecimal'
      mr.ShowAsSigned = v.DisplayMethod == 'dtSignedInteger'
    else
      mr.Address = "+0"
      mr.OffsetCount = 1
      mr.OffsetText[0] = offsetUsesName and ('+%s.%s'):format(struct.name,v.Name) or offsetToStr(v.Offset)
    end

    local doAdd = true
    if mr.Type == vtUnicodeString then mr.Type = vtString mr.String.Unicode = true end
    if mr.Type == vtString then mr.String.Size = v.Bytesize end
    if mr.Type == vtCustom then mr.CustomTypeName = v.CustomType.Name end
    if mr.Type == vtByteArray then mr.Aob.Size = v.Bytesize end
    if mr.Type == vtPointer then
      mr.Type = vtDword -- vtPointer is just for struct, so use vtDword arbitrarily
      if v.childStruct then
        memrecOptionsSet(mr, 'moAllowManualCollapseAndExpand,moManualExpandCollapse', true)
        -- need delay before collapsed will work
        -- while it might work to simply move after gen, better safe
        local t = createTimer() t.Interval=50 t.OnTimer = function(t)
          mr.Collapsed = true t.destroy()
        end
        generateFromStructure(mr, v.childStruct, offsetUsesName, "pointer")
      else -- just some random pointer to who knows what... don't add it
        doAdd = false
      end
    end

    if doAdd then mr.appendToEntry(mmr) else mr.destroy() end
  end
end

extMenuItem.OnClick = function(sender) generateFromStructure() end


```

`get returnaddresses.lua`:

```lua
--##### Get Return Address POC Lua Function for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  creates printRetAddressesList which takes an address and the amount of time to check then prints the values that were on top of the stack (ie. the return address for ret instructions)
  FO: Find out what address this RETNs to when right clicking on a RETN operation code (extremely useful for microsecond calls  to determine the highest XREF count resources)(edited)
]]

-- global table to put function names so I don't have to remember exactlyw what I called them lol
FreeER = FreeER or {}

getRetAddressesList = {}
function getRetAddresses(addr, stopChecking)
  if not debug_isDebugging() then debugProcess(0) end
  if stopChecking then 
    debug_removeBreakpoint(addr)
    local addresses = getRetAddressesList[addr]
    if addresses then addresses.endUpdate() end
    return addresses
  end
  -- else
  local addresses = createStringlist()
  addresses.Duplicates = 'dupIgnore'
  addresses.Sorted = true
  addresses.beginUpdate()
  getRetAddressesList[addr] = addresses
  debug_setBreakpoint(addr, getInstructionSize(addr), bptExecute, function(...)
    addresses.add(("%X"):format(readPointer(ESP)))
    debug_continueFromBreakpoint(co_run)
    return 0
  end)
end

function printRetAddressesList(addr, time)
  addr = getAddressSafe(type(addr) == 'number' and ('%x'):format(addr) or addr)
  if not addr then error("Invalid address", 2) end
  getRetAddresses(addr)

  time = tonumber(time)
  time = time and math.ceil(time) or 10000 -- default to 10 seconds
  local t = createTimer()
  t.Interval = time
  t.OnTimer = function(t)
    t.destroy()
    local list = getRetAddresses(addr,true)
    if list then
      print(('found %i return addresses for %s'):format(list.Count, getNameFromAddress(addr)))
      for i=0,list.Count-1 do
        print(list[i])
      end
      list.destroy()
    else
      print('hm, getRetAddresses seems to have returned nil...sorry')
    end
  end
end
FreeER.getRetAddresses = getRetAddresses
FreeER.printRetAddressesList = printRetAddressesList

```

`git-simple.bat`:

```bat
setlocal
set msg=^"%*^"
set msg="%msg:"=%"

if not [%msg%] == [""] goto git
set /p msg="commit message: "
set msg=%msg:"=%
set msg=^"%msg%^"
:git
git add *
if [%errorlevel%] NEQ [0] goto nogit
git commit -m %msg%
if [%errorlevel%] == [0] git push origin
goto end
:nogit
echo You don't have git installed you git!
pause
:end
```

`github link.url`:

```url
[{000214A0-0000-0000-C000-000000000046}]
Prop3=19,11
[InternetShortcut]
IDList=
URL=https://github.com/FreeER/CE-Extensions
HotKey=0

```

`gotoOnBreak.lua`:

```lua
--##### gotoOnBreak Script
--##### Author: FreeER
--##### Website: 
--##### Github: https://github.com/FreeER
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  
  note: settings are global, they affect all disassemblers not just the one it was done from
]]

-- BGR
--local staticColor = 0xAE33AE
local menuCaption = 'gotoOnBreak'
if getCEVersion() < 6.4 then
  error(menuCaption .. " requires CE >= 6.4, update CE!")
end

local function setBreakpointFunction()
  local input = inputQuery(menuCaption, 'What address do you want to go to?', targetIs64Bit() and "RAX" or "EAX")
  -- if cancel then do nothing
  if not input then return end

  -- if 0 or empty string then disable
  if input == "0" or input:gsub("%s","") == "" then
    debugger_onBreakpoint = nil
    return
  end

  debugger_onBreakpoint = function()
    local straddr = input:upper() -- making uppercase shouldn't break anything since symbols are case insensitive
    -- apparently getAddress doesn't support registers...
    for _,reg in pairs({'%u?AX','%u?BX','%u?CX','%u?DX','%u?SI','%u?DI','%u?BP','%u?SP','%u?IP','R8%u?','R9%u?','R10%u?','R11%u?','R12%u?','R13%u?','R14%u?','R15%u?'}) do
      local match = straddr:match(reg)
      local val = _G[match] -- get register value
      if val then
        straddr = straddr:gsub(reg, ('%X'):format(val))
      end
    end
    local addr = getAddressSafe(straddr)
    if addr then getMemoryViewForm().HexadecimalView.Address = addr end
  end
end

local function createMenu(f)
  local items = f.menu.Items
  for j=0,items.Count-1 do
    if items[j].Caption == menuCaption then return end
  end
  local themenu = createMenuItem(f.Menu)
  themenu.Caption = menuCaption
  themenu.OnClick = setBreakpointFunction
  items.add(themenu)
end

-- add menu to main memory view form
createMenu(getMemoryViewForm())

-- remember when the user pastes a memory record to workaround a bug
local ctrlv_time = os.clock()

-- keyboard shortcut
local ctrlv = createHotkey(function(hk) ctrlv_time = os.clock() end, VK_CONTROL, VK_V)

-- menu
local pasteMenuItem = nil
-- find the menu item for paste
local it = MainForm.PopupMenu2.Items
for i=0,it.Count-1 do
  if it[i].Caption == 'Paste' then
    pasteMenuItem = it[i]
    break
  end
end
if not pasteMenuItem then error('failed to find paste menu item') end

-- add an onclick function
local pasteMenuItem_onclick = pasteMenuItem.OnClick
pasteMenuItem.OnClick = function(...)
  ctrlv_time = os.clock()
  if pasteMenuItem_onclick and type(pasteMenuItem_onclick) == 'function' then
    pasteMenuItem_onclick(...)
  end
end

-- setup event to add menu to new forms
-- seems to get an invalid form on paste that causes an error, no idea why
registerFormAddNotification(function(form)
  -- captions/names don't seem to be set yet so start a timer to check later
  local t = createTimer()
  t.OnTimer = function(t)
    -- stop checking (only checks once after a delay)
    t.destroy()
    -- if the user just copy/pasted a memory record then don't check (bug workaround)
    if os.clock() - ctrlv_time < 0.5 then return end
    -- check if it's a memory viwer form
    if form.Name:find("MemoryBrowser") then createMenu(form) end
  end
  t.Interval = 300
end)

```

`loader.lua`:

```lua
--##### Autorun Lua Script Loader for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  Tries to load all lua files in subdirectories of CE's autorun folder for easier extension management
  if autorun/package/init.lua exists only that file will be loaded instead of every file for custom management
]]
local ignoreDirs = {['ceshare']=1}

-- tweaked function from internet search
function scandir(path, files, ext)
    local t, popen = {}, io.popen
    local cmd = ('dir "%s\\%s" /b %s'):format(path, ext and ('*.%s'):format(ext) or "", files and "" or "/ad")
    --print(cmd)
    for filename in popen(cmd):lines() do
        t[filename] = filename
    end
    return t
end

local ap = getAutorunPath()
for _,dir in pairs(scandir(ap)) do
  if not ignoreDirs[dir] then
    --print('scanning', dir)
    local full = ('%s\\%s'):format(ap,dir)
    local files = scandir(full,true,'lua')
    if files['init.lua'] then
       dofile(full..'\\init.lua')
    else
      for _,file in pairs(files) do
        local f = ('%s\\%s'):format(full,file)
        --print('  ', 'requiring ', f)
        dofile(f)
      end
    end
  end
end



```

`lockMouse.lua`:

```lua
--##### Lock Mouse Script for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a menu option to lock the mouse where it's at until a hotkey is pressed
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- table of VK codes for keycombo to trigger hotkey
local hotkeyTrigger = {VK_CONTROL, VK_F12}
-- string of password required to disable mouse lock
local password = nil -- '5f4dcc3b5aa765d61d8327deb882cf99' -- md5 'password'
-- true if password is hash from stringToMD5String (not the plaintext password)
local passwordHashed     = false
local lockInterval       = 1     -- milliseconds between calling setMousePos
local specificXY         = nil   -- if table of x,y will set mouse there rather than current pos
local hotkeyStartsFreeze = false -- if false pressing the hotkey when not locked does nothing
local menuEndsFreeze     = false -- if false activating the menu with the keyboard does nothing
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Lock Mouse'
local requiredVersion = 6.4
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

FreeER = FreeER or {}
FreeER.mouseFreezeHotkey = createHotkey(function(hk)
  -- do nothing if mosue is not locked
  if not FreeER.mouseFreezeTimer then
    if hotkeyStartsFreeze then extMenuItem.doClick() end
    return
  end

  local user = nil
  if password then
    user = inputQuery('Password', 'Password', '')
    if not user then return end
    if passwordHashed then
      user = stringToMD5String(user)
    end
  end

  if user == password then
    FreeER.mouseFreezeTimer.destroy(); FreeER.mouseFreezeTimer = nil;
  end
end, hotkeyTrigger)

extMenuItem.OnClick = function()
  if FreeER.mouseFreezeTimer then
    FreeER.mouseFreezeTimer.destroy(); FreeER.mouseFreezeTimer = nil
    if menuEndsFreeze then return end
  end

  local pos                        = specificXY or {getMousePos()}
  FreeER.mouseFreezeTimer          = createTimer()
  FreeER.mouseFreezeTimer.Interval = lockInterval
  FreeER.mouseFreezeTimer.OnTimer  = function(t)
    setMousePos(unpack(pos))
  end
end

```

`lua engine output monospace.lua`:

```lua
--##### Lua Engine Output Monospace Setter for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  sets the lua engine output text to use the same font as the script input
  (which is monospace)
]]
getLuaEngine().mOutput.Font.Assign(getLuaEngine().mScript.Font)

```

`playRandomMovie.lua`:

```lua
--##### Remove Play Random Movie for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a menu option to play a random movie (based on registry settings - HKCU\Software\Cheat Engine\FreeER-RandomMoviePlayer)
]]

-- START OF USER CONFIG --
local useGroupMenu = true
local extItemShortcut = 'ctrl+]'
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Play Random Movie'
local requiredVersion = 6.4
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenuItem.Shortcut = extItemShortcut
extMenu.add(extMenuItem)
-- menu code --

math.randomseed(os.time())

local function findAllExtensions(path)
  local exts = {}
  for i,p in ipairs(getFileList(path, '', true)) do
    exts[p:match('.*%.(.*)')] = true
  end
  return exts
end
--[[
for k,v in pairs(findAllExtensions(path)) do
  print(k)
end
]]

local settings  = getSettings('FreeER-RandomMoviePlayer') --HKCU\Software\Cheat Engine\FreeER-RandomMoviePlayer
local movieMask = settings.Value['movieMask']
if not movieMask or movieMask == '' then
  movieMask = '*.m4v;*.mp4;*.m4a;*.avi;*.wmv;*.mkv;*.flv'
  settings.Value['movieMask'] = movieMask
end
local args      = settings.Value['args']
if not args or args == '' then
  args = '"%s"' -- simple quote of file name
  settings.Value['args'] = args
end
local command   = settings.Value['command'] --eg. 'vlc.exe' -- path to program to use for all files

local pathsep   = package.config:sub(1,1)

local function pickFile(path)
  path = path:gsub('[/\\]',pathsep)
  local list = getFileList(path, movieMask, true)
  --print(path, #list)
  if #list < 1 then error('No files to pick from!', 2) end
  local file = list[math.random(#list)]
  return file
end

extMenuItem.OnClick = function()
  local path = settings.Value['movieDirectory']
  if not path or path == '' then
    path = ('%s%s%s'):format(os.getenv('userprofile'),pathsep,'Videos')
  end
  path = inputQuery('Movie Path', 'Movie Path', path)
  if not path or path:gsub(' ','') == '' then return end

  if not command or command == '' then
    shellExecute(pickFile(path)) -- let windows use the default
  else
    shellExecute(command, args:format(pickFile(path)))
  end
  settings.Value['movieDirectory'] = path
end

```

`popout_addressList.lua`:

```lua
--##### Popout Address List
--##### Author: Dark Byte, menu added by FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  https://forum.cheatengine.org/viewtopic.php?p=5743590#5743590
]]

-- START OF USER CONFIG --
local useGroupMenu = true
local extItemShortcut = ''
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Popout Address List'
local requiredVersion = 6.4
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenuItem.Shortcut = extItemShortcut
extMenu.add(extMenuItem)
-- menu code --

local alw=createForm() 
alw.PopupMode='pmNone' --comment this if you want stay on top behaviour 
alw.Caption="Address List" 
alw.BorderStyle="bsSizeable" 
alw.ClientWidth=AddressList.Width 
alw.visible = false

local alwsettings=getSettings('alw') 
if alwsettings.Value['x']~='' then alw.left=tonumber(alwsettings.Value['x']) end 
if alwsettings.Value['y']~='' then alw.top=tonumber(alwsettings.Value['y']) end 
if alwsettings.Value['width']~='' then alw.width=tonumber(alwsettings.Value['width']) end 
if alwsettings.Value['height']~='' then alw.height=tonumber(alwsettings.Value['height']) end 

alw.OnCloseQuery=function(sender) 
  AddressList.Parent = MainForm.Panel1
  alw.visible=false
  return false 
end 

alw.OnDestroy=function(sender)  
  alwsettings.Value['x']=alw.left 
  alwsettings.Value['y']=alw.top 
  alwsettings.Value['width']=alw.width 
  alwsettings.Value['height']=alw.height 
end 

extMenuItem.OnClick = function()
  if AddressList.Parent==alw then
    AddressList.Parent = MainForm.Panel1
    alw.visible=false
  else
    AddressList.Parent = alw
    alw.visible=true
  end
end

```

`randomizeSelected.lua`:

```lua
--##### Randomize Selected Addresslist Values for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  Request from TwilightKillerX on Discord
  Randomizes the values of selected addresses
]]

local function findMenu(mi)
  while not mi.Menu do mi = mi.Parent end
  return mi.Menu
end
local del_mi = MainForm.Deletethisrecord1
local del_menu = findMenu(del_mi)

local mi = createMenuItem(del_menu)
mi.Caption = 'Randomize Values'

local miPrompt = createMenuItem(del_menu)
miPrompt.Caption = 'Randomize Values (range prompt)'

function randomize(mr)
  local types  = {
    [vtByte]   = function() return math.random(0, 0xFF) end,
    -- *smallInteger added in CE 6.7
    [vtWord]   = function() return math.random(0, 0xFFFF) end,
    [vtDword]  = function() return math.random(0, 0xFFFFFFFF) end,
    [vtQword]  = function() return math.random(0, 0x7FFFFFFFFFFFFFFF) * (math.random() > 0.5 and -1 or 1) end,
    --[vtSingle] set outside, refers to vtDword
    --[vtDouble] set outside, refers to vtQword
    --[vtByteArray] set outside, refers to vtByte

    -- unsupported
    --[[
    -- probably not the most _logical_ thing to do, but just as a demonstration of how it could be done
    [vtString] = function(len)
      local chars = {}
      for i=0,len do
        chars[#chars+1] = string.char(math.random(('a'):byte(1), ('z'):byte(1)))
      end
      return table.concat(chars,'')
    end,
    ]]
    --[vtGrouped],
    --[vtBinary], -- probably simple enough just not certain
    --[vtPointer], -- not a normal type, fix table to have 4/8?
    --[vtCustom] -- no way to get size, getCustomType(name).scriptUsesFloat
    --  exists for float/int but not size (other than parsing the script... not
    --  too hard but I don't feel like it right now)
  }
  types[vtSingle] = function() return string.unpack('f',string.pack('I4',types[vtDword]())) end
  types[vtDouble] = function() return string.unpack('d',string.pack('I8',types[vtQword]())) end
  types[vtByteArray] = function(len) 
    local bytes = {}
    for i=0, len do
      bytes[#bytes+1] = ('%X'):format(types[vtByte]())
    end
    return table.concat(bytes,' ')
  end

  if mr.Type == vtByteArray then
    return types[mr.Type](mr.Aob.Size)
  elseif types[mr.Type] then
    --print(mr.Description, types[mr.Type]())
    return types[mr.Type]()
  else
    --print('unknown type', mr.Type)
    return nil
  end
end

mi.OnClick = function()
  local al = getAddressList()
  local records = al.getSelectedRecords()
  if not records then return end
  for k,v in pairs(records) do
    if v.Type ~= vtAutoAssembler and not v.isGroupHeader then
      local val = randomize(v)
      if val then v.Value = val end
    end
  end
end

miPrompt.onClick = function()
  local valid = {vtByte, vtWord, vtDword, vtQword, vtSingle, vtDouble}
  local al = getAddressList()
  local records = al.getSelectedRecords()
  if not records then return end

  min = inputQuery('min value', 'Min value:', 0)
  max = inputQuery('max value', 'Max value:', 100)
  min = tonumber(min)
  max = tonumber(max)
  if not min or not max then -- probably hit cancel
    return
  end

  local success = pcall(math.random, min, max)
  if not success then
    showMessage('invalid range, math.random failed!')
    return
  end

  for k,v in pairs(records) do
    if valid[v.type] then
      local success, val = pcall(math.random, min, max)
      if success then
        v.Value = v.ShowAsHex and ('%X'):format(val) or val
      end
    end
  end
end

--[[
-- don't really want to prompt for every single record and
-- remembering values really only works for a single memory record huh...
local lastMinValues = {}
local lastMaxValues = {}
miPrompt.onClick = function()
  local valid = {vtByte, vtWord, vtDword, vtQword, vtSingle, vtDouble}
  local al = getAddressList()
  local records = al.getSelectedRecords()
  for k,v in pairs(records) do
    if valid[v.type] then
      local min = lastMinValues[mr.id] or 0
      local max = lastMaxValues[mr.id] or 100
      min = inputQuery('min value', 'Min value:', min)
      max = inputQuery('max value', 'Max value:', max)
      min = tonumber(min)
      max = tonumber(max)

      if min and max then
        lastMinValues[mr.id] = min
        lastMinValues[mr.id] = max
        local success, val = pcall(math.random, min, max)
        print('random:', val)
        if success then mr.Value = val end
      end
    end
  end
end
]]

del_menu.Items.insert(del_mi.MenuIndex, mi)
del_menu.Items.insert(del_mi.MenuIndex, miPrompt)

--[[
-- mr generation test
local address = 0x400290
local types = {
  vtByte, vtWord, vtDword, vtQword, vtSingle, vtDouble, vtString, vtUnicodeString,
  vtByteArray, vtBinary, vtAutoAssembler, vtPointer, vtCustom, vtGrouped
}
fullAccess(address, #types*0x10)

for _,t in ipairs(types) do
  local mr = AddressList.CreateMemoryRecord()
  mr.Address = ('%X'):format(address)
  address = address + 0x10
  mr.type = t
  mr.Description = _
end
]]

```

`remove hotkeys.lua`:

```lua
--##### Remove Hotkeys Lua Script for Cheat Engine
--##### Author: FreeER
--##### Github: https://github.com/FreeER
--##### Website: https://www.facebook.com/groups/CheatTheGame
--##### YouTube: https://www.youtube.com/channel/UCLy60mbqc3rSvh42jkpCDxw
--[[
  adds a menu option to remove all hotkeys from memory records
  note: this does not remove/destroy any hotkeys created by lua code only the gui
]]

-- START OF USER CONFIG --
local useGroupMenu = true
-- END OF CONFIG --

-- START OF EXT TEMPLATE CONFIG --
local extGroupMenuCaption = 'F&reeER\'s Extensions'
local extItemCaption = 'Remove Hotkeys'
local requiredVersion = 6.4 -- Not actually sure what the requirement is... possibly whenever CE added the new OOP syntax
-- START OF EXT TEMPLATE CONFIG --

if getCEVersion() < requiredVersion then
    error(("%s requires CE >= %d, update CE!"):format(extItemCaption, requiredVersion))
end

-- menu code --
local mf = getMainForm()
local mm = mf.Menu
local extMenu = nil

if useGroupMenu then
  -- look for existing group menu
  for i=0,mm.Items.Count-1 do
      if mm.Items.Item[i].Caption == extGroupMenuCaption then
          extMenu = mm.Items.Item[i]
          break
      end
  end
  if not extMenu then -- not found so create it
      extMenu = createMenuItem(mm)
      extMenu.Caption = extGroupMenuCaption
      mm.Items.add(extMenu)
  end
else
  extMenu = mm.Items
end

local extMenuItem = createMenuItem(extMenu)
extMenuItem.Caption = extItemCaption
extMenu.add(extMenuItem)
-- menu code --

extMenuItem.OnClick = function()
  -- http://lazarus-ccr.sourceforge.net/docs/lcl/dialogs/tmsgdlgbuttons.html
  if messageDialog('Remove hotkeys?', 3, 0,1) ~= mrYes then return end
  local al = getAddressList()
  local get_mr = al.getMemoryRecord
  for i=0, al.Count-1 do
    local mr = get_mr(i)
    for h=mr.HotkeyCount-1, 0, -1 do
      mr.Hotkey[h].destroy()
    end
  end
  showMessage('remember to save!') -- offering the prompt is probably more than it's really worth
end

```