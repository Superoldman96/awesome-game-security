Project Path: arc_gmh5225_GhidraBoy_fgi8ynul

Source Tree:

```txt
arc_gmh5225_GhidraBoy_fgi8ynul
├── CHANGELOG.markdown
├── LICENSE
├── Module.manifest
├── README.markdown
├── build.gradle.kts
├── data
│   ├── languages
│   │   ├── sm83.cspec
│   │   ├── sm83.ldefs
│   │   ├── sm83.pspec
│   │   ├── sm83.sinc
│   │   ├── sm83.slaspec
│   │   └── sm83_instructions.sinc
│   └── sleighArgs.txt
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── screenshot.png
├── settings.gradle.kts
└── src
    ├── main
    │   └── java
    │       └── fi
    │           └── gekkio
    │               └── ghidraboy
    │                   ├── BootRomUtils.java
    │                   ├── DataTypes.java
    │                   ├── GameBoyKind.java
    │                   ├── GameBoyKindOption.java
    │                   ├── GameBoyLoader.java
    │                   ├── GameBoyUtils.java
    │                   ├── RomUtils.java
    │                   └── Sha256.java
    └── test
        └── kotlin
            └── fi
                └── gekkio
                    └── ghidraboy
                        ├── DisassemblyTest.kt
                        ├── GhidraApplication.kt
                        ├── IntegrationTest.kt
                        ├── MemoryExt.kt
                        ├── ProgramExt.kt
                        ├── decompiler
                        │   └── DecompilerTest.kt
                        └── emu
                            ├── ControlFlowInstructionTest.kt
                            ├── EmuTest.kt
                            ├── EmulatorExt.kt
                            ├── FailOnMemoryFault.kt
                            ├── IgnorePCode.kt
                            └── MiscInstructionTest.kt

```

`CHANGELOG.markdown`:

```markdown
# Change Log

## [Unreleased]

### Fixed

- DAA pseudo op tracks data dependencies much better

## 20221116 - 2022-11-16

### Changed

- Build with Ghidra 10.2.2

### Fixed

- Revert unintended change in memory block order

## 20221115 - 2022-11-15

### Added

- Meaningful comments to all created memory blocks

### Changed

- Improve decompilation result when checking negative flags (NC, NZ)
- Build with Ghidra 10.2.1
- Build with Java 17

### Fixed

- Typo in ROM bank memory block comment
- Fix accidental generation of duplicate data types

## 20220521 - 2022-05-21

### Changed

- Build with Ghidra 10.1.4

## 20220510 - 2022-05-10

### Changed

- Build with Ghidra 10.1.3

## 20220316 - 2022-03-16

### Changed

- Build with Ghidra 10.1.2

## 20211211 - 2021-12-11

### Changed

- Build with Ghidra 10.1

## 20211028 - 2021-10-28

### Changed

- Build with Ghidra 10.0.4

## 20210817 - 2021-08-17

### Changed

- Build with Ghidra 10.0.2

## 20210728 - 2021-07-28

### Changed

- Build with Ghidra 10.0.1

## 20210630 - 2021-06-30

### Changed

- Build with Ghidra 10.0

## 20210529 - 2021-05-29

### Changed

- Build with Ghidra 9.2.4

## 20210418 - 2021-04-18

### Changed

- Build with Ghidra 9.2.3

## 20210120 - 2021-01-20

### Added

- Absolute offset as the comment in ROM memory banks. Note: this is done when importing a ROM, so existing projects won't automatically get the comments just by upgrading GhidraBoy

### Changed

- Build with Ghidra 9.2.2

## 20201223 - 2020-12-23

### Changed

- Build with Ghidra 9.2.1

## 20201113 - 2020-11-13

### Changed

- Build with Ghidra 9.2

## 20200219 - 2020-02-19

### Changed

- Build with Ghidra 9.1.2

## 20200122 - 2020-01-22

### Changed

- Build with Ghidra 9.1.1

### Fixed

- Fix INC (HL) and DEC (HL) behaviour. These were considered no-ops

## 20191104 - 2019-11-04

### Changed

- Build with Ghidra 9.1 final release

## 20190924 - 2019-09-24

### Fixed

- Fix compatibility with Ghidra 9.1 development version changes

## 20190803 - 2019-08-03

### Added

- Initial release for Ghidra 9.1 development version

```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.markdown`:

```markdown
# GhidraBoy: Sharp SM83 / Game Boy extension for Ghidra

**Very experimental! No compatibility guarantees!**

Ghidra version: Ghidra 10.2.2_PUBLIC_20221115

![Tetris disassembly](screenshot.png)

## Features

* Sharp SM83 (CPU core used in Game Boy) support for Sleigh
* Game Boy ROM loader:
  - Can load unbanked ROMs (&lt;= 32kB, e.g. Tetris)
  - Can load banked ROMs (&gt; 32kB, e.g. Pokemon)
  - Can load greyscale boot ROMs (DMG/DMG0/MGB/SGB/SGB2)
  - Can load color boot ROMs (CGB/CGB0)
* Memory blocks based on the hardware memory map
  - Banked regions use overlays (TODO: figure out if there's a better way to
    support them)
  - GB vs GBC differences are handled (e.g. banked WRAM)
- Symbols for hardware registers (0xFFxx range)
  - GB vs GBC differences are handled (e.g. existence of KEY1 register)
* Game Boy cartridge header data types
  - Enumerated types for some things

## How to install

1. Download a [prebuilt GhidraBoy release](https://github.com/Gekkio/GhidraBoy/releases), or build it yourself.
2. Start Ghidra
3. File -> Install Extensions
4. Press the plus icon ("Add extension")
5. Choose the built or downloaded GhidraBoy zip file
6. Restart Ghidra when prompted to load the extension properly

## How to build

As a prerequisite, you need to have a Ghidra installation somewhere (an actual
installation, not a copy of Ghidra source code!).

```
export GHIDRA_INSTALL_DIR=/path/to/ghidra
./gradlew
```

or

```
./gradlew -Pghidra.dir=/path/to/ghidra
```

You can then find a built extension .zip in the `build/distributions` directory.

## Open questions / problems

- Decompiler output is difficult to read if certain instructions are used (e.g.
  rotates, JP HL for jumptables)
- Default "ASM calling convention" assumes all registers can be inputs and/or
  outputs. Inputs/outputs are often guessed incorrectly, so manual tuning is
  required for almost every function
- Are overlays the only / the best solution for handling banked memory areas?
  Right now in banked ROMs every function call to 0x4000-0x7fff needs to be
  manually resolved to the correct bank(s)

## License

Licensed under the Apache License, Version 2.0.

```

`build.gradle.kts`:

```kts
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import java.time.LocalDate
import java.time.format.DateTimeFormatter.BASIC_ISO_DATE
import java.util.Properties

plugins {
    java
    kotlin("jvm") version "1.7.21"
    id("org.jlleitschuh.gradle.ktlint") version "11.0.0"
}

repositories {
    mavenCentral()
}

val ghidraDir = System.getenv("GHIDRA_INSTALL_DIR")
    ?: (project.findProperty("ghidra.dir") as? String)
    ?: throw IllegalStateException("Can't find Ghidra installation")

val ghidraProps = Properties().apply { file("$ghidraDir/Ghidra/application.properties").inputStream().use { load(it) } }
val ghidraVersion = ghidraProps.getProperty("application.version")!!
val ghidraRelease = ghidraProps.getProperty("application.release.name")!!

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    withSourcesJar()
}

tasks.withType<KotlinCompile> {
    kotlinOptions {
        jvmTarget = "17"
        freeCompilerArgs += "-opt-in=kotlin.ExperimentalUnsignedTypes"
    }
}

val ghidra: Configuration by configurations.creating

dependencies {
    ghidra(fileTree("$ghidraDir/Ghidra/Framework") { include("**/*.jar") })
    ghidra(fileTree("$ghidraDir/Ghidra/Features") { include("**/*.jar") })

    compileOnly(ghidra)

    testImplementation(ghidra)
    testImplementation(kotlin("stdlib-jdk8"))
    testImplementation(platform("org.junit:junit-bom:5.9.0"))
    testImplementation("org.junit.jupiter:junit-jupiter-api")
    testImplementation("org.junit.jupiter:junit-jupiter-params")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
}

val generateExtensionProps by tasks.registering() {
    val output = file("$buildDir/generated/extension.properties")
    outputs.file(output)
    doLast {
        output.outputStream().use {
            val props = Properties()
            props += mapOf(
                ("name" to "GhidraBoy"),
                ("description" to "Support for Sharp SM83 / Game Boy"),
                ("author" to "Gekkio"),
                ("createdOn" to LocalDate.now().toString()),
                ("version" to ghidraVersion)
            )
            props.store(it, null)
        }
    }
}

val compileSleigh by tasks.registering(JavaExec::class) {
    val slaspecFile = file("data/languages/sm83.slaspec")
    val slaFile = file("data/languages/sm83.sla")

    inputs.files(fileTree("data/languages").include("*.slaspec", "*.sinc"))
        .withPropertyName("sourceFiles")
        .withPathSensitivity(PathSensitivity.RELATIVE)
    outputs.files(slaFile)
        .withPropertyName("outputFile")

    classpath = configurations["ghidra"]
    mainClass.set("ghidra.pcodeCPort.slgh_compile.SleighCompile")
    args = listOf("-u", "-l", "-n", "-t", "-e", "-c", "-f", slaspecFile.absolutePath)
}

val zip by tasks.registering(Zip::class) {
    archiveFileName.set("ghidra_${ghidraVersion}_${ghidraRelease}_${LocalDate.now().format(BASIC_ISO_DATE)}_${project.name}.zip")

    into("${project.name}/")
    from(tasks.named("jar")) {
        into("lib/")
    }
    from(tasks.named("sourcesJar")) {
        into("lib/")
        rename { "${project.name}-src.zip" }
    }
    from(configurations.runtimeClasspath.get()) {
        into("lib/")
    }

    from(generateExtensionProps)
    from("data") {
        into("data/")
        include("**/*.cspec", "**/*.ldefs", "**/*.pspec", "**/*.sinc", "**/*.slaspec", "**/sleighArgs.txt")
    }
    from("README.markdown", "LICENSE", "Module.manifest")
}

tasks.named("assemble") {
    dependsOn("zip")
}

tasks.named<Test>("test") {
    dependsOn("compileSleigh")
    useJUnitPlatform()

    systemProperty("ghidra.dir", ghidraDir)
    systemProperty("SystemUtilities.isTesting", true)
}

defaultTasks("clean", "assemble")

```

`data/languages/sm83.cspec`:

```cspec
<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<compiler_spec>
  <data_organization>
    <machine_alignment value="1"/>
    <default_alignment value="1"/>
    <default_pointer_alignment value="1"/>
    <pointer_size value="2"/>
    <integer_size value="2"/>
  </data_organization>
  <global>
    <range space="ram"/>
  </global>
  <stackpointer register="SP" space="ram" growth="negative"/>
  <returnaddress>
    <varnode space="stack" offset="0" size="2"/>
  </returnaddress>
  <default_proto>
    <prototype name="__asm" extrapop="2" stackshift="2" strategy="register">
      <input>
        <pentry minsize="1" maxsize="1">
          <register name="A"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="HL"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="BC"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="DE"/>
        </pentry>
        <pentry minsize="1" maxsize="500" align="1">
          <addr offset="2" space="stack"/>
        </pentry>
      </input>
      <output>
        <pentry minsize="1" maxsize="1">
          <register name="A"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="HL"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="BC"/>
        </pentry>
        <pentry minsize="1" maxsize="2">
          <register name="DE"/>
        </pentry>
      </output>
      <unaffected>
        <register name="SP"/>
      </unaffected>
    </prototype>
  </default_proto>
</compiler_spec>

```

`data/languages/sm83.ldefs`:

```ldefs
<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<language_definitions>
  <language processor="SM83"
            endian="little"
            size="16"
            variant="default"
            version="1.0"
            slafile="sm83.sla"
            processorspec="sm83.pspec"
            id="SM83:LE:16:default">
    <description>Sharp SM83</description>
    <compiler name="default" spec="sm83.cspec" id="default"/>
  </language>
</language_definitions>

```

`data/languages/sm83.pspec`:

```pspec
<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<processor_spec>
  <programcounter register="PC"/>
</processor_spec>

```

`data/languages/sm83.sinc`:

```sinc
# Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

define endian = little;
define alignment = 1;
define space ram type=ram_space size=2 default;
define space register type=register_space size=1;

define register offset=0x00 size=1 [ F A C B E D L H ];
define register offset=0x00 size=2 [ AF  BC  DE  HL ];
define register offset=0x08 size=2 [ PC  SP  ];

@define C_flag "F[4,1]"
@define H_flag "F[5,1]"
@define N_flag "F[6,1]"
@define Z_flag "F[7,1]"

define token opcode (8)
  op0_8       = (0,7)
  op0_4       = (0,3)
  op0_3       = (0,2)
  reg0_3      = (0,2)
  op3_2       = (3,4)
  op3_3       = (3,5)
  reg3_3      = (3,5)
  bit3_3      = (3,5)
  qregpair4_2 = (4,5)
  dregpair4_2 = (4,5)
  sregpair4_2 = (4,5)
  op5_3       = (5,7)
  op6_2       = (6,7)
;

define token data8 (8)
  imm8  = (0,7)
  sign8 = (7,7)
  simm8 = (0,7) signed
;

define token data16 (16)
  imm16 = (0,15)
;

attach variables [ reg0_3 reg3_3 ] [ B C D E H L _ A ];
attach variables [ sregpair4_2 dregpair4_2 ] [ BC DE HL SP ];
attach variables [ qregpair4_2 ] [ BC DE HL AF ];

cc: "NZ" is op3_2=0b00 {
  local c:1 = !$(Z_flag);
  export c;
}
cc: "Z"  is op3_2=0b01 {
  local c:1 = $(Z_flag);
  export c;
}
cc: "NC" is op3_2=0b10 {
  local c:1 = !$(C_flag);
  export c;
}
cc: "C"  is op3_2=0b11 {
  local c:1 = $(C_flag);
  export c;
}

Addr16: imm16 is imm16 {
  export *:1 imm16;
}

Mem8: (imm16) is imm16 {
  export *:1 imm16;
}

Mem16: (imm16) is imm16 {
  export *:2 imm16;
}

RelAddr8: loc is simm8 [
  loc = inst_next + simm8;
] {
  export *:1 loc;
}

RstAddr: loc is op3_3 [
  loc = op3_3 << 3;
] {
  export *:1 loc;
}

HLInc: (HL+) is HL {
  local tmp = HL;
  HL = HL + 1;
  export *:1 tmp;
}

HLDec: (HL-) is HL {
  local tmp = HL;
  HL = HL - 1;
  export *:1 tmp;
}

CMem8: (C) is C {
  local ptr:2 = 0xff00 | zext(C);
  export *:1 ptr;
}

HiMem8: (imm8) is imm8 {
  local off:1 = imm8;
  local ptr:2 = 0xff00 | zext(off);
  export *:1 ptr;
}

define pcodeop IME;
define pcodeop daaOperand;
define pcodeop halt;
define pcodeop stop;

macro push16(val16) {
  SP = SP - 2;
  *:2 SP = val16;
}

macro pop16(ret16) {
  ret16 = *:2 SP;
  SP = SP + 2;
}

macro aluAdd(op8) {
  local x:1 = op8;
  local tmp:1 = A + x;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = (((A & 0xf) + (x & 0xf)) & 0x10) != 0;
  $(C_flag) = carry(A, x);
  A = tmp;
}

macro aluAdc(op8) {
  local x:1 = op8;
  local cy:1 = $(C_flag);
  local tmp:1 = A + x + cy;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = (((A & 0xf) + (x & 0xf) + cy) & 0x10) != 0;
  $(C_flag) = carry(carry(A, x), cy);
  A = tmp;
}

macro aluSub(op8) {
  local x:1 = op8;
  local tmp:1 = A - x;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 1;
  $(H_flag) = (((A & 0xf) - (x & 0xf)) & 0x10) != 0;
  $(C_flag) = A < x;
  A = tmp;
}

macro aluSbc(op8) {
  local x:1 = op8;
  local cy = $(C_flag);
  local tmp:1 = A - x - cy;
  $(Z_flag) = (A == 0);
  $(N_flag) = 1;
  $(H_flag) = (((A & 0xf) - (x & 0xf) - cy) & 0x10) != 0;
  $(C_flag) = A < (x + cy);
  A = tmp;
}

macro aluAnd(op8) {
  local x:1 = op8;
  A = A & x;
  $(Z_flag) = (A == 0);
  $(N_flag) = 0;
  $(H_flag) = 1;
  $(C_flag) = 0;
}

macro aluXor(op8) {
  local x:1 = op8;
  A = A ^ x;
  $(Z_flag) = (A == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = 0;
}

macro aluOr(op8) {
  local x:1 = op8;
  A = A | x;
  $(Z_flag) = (A == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = 0;
}

macro aluCp(op8) {
  local x:1 = op8;
  local tmp:1 = A - x;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 1;
  $(H_flag) = (((A & 0xf) - (x & 0xf)) & 0x10) != 0;
  $(C_flag) = A < x;
}

macro aluInc(op8) {
  local x:1 = op8;
  local tmp:1 = x + 1;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  # TODO: check which one is better for decompilation: (x & 0xf) == 0xf  vs  (((x & 0xf) + 1) & 0x10) != 0
  $(H_flag) = ((x & 0xf) == 0xf);
  op8 = tmp;
}

macro aluDec(op8) {
  local x:1 = op8;
  local tmp:1 = x - 1;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 1;
  # TODO: check which one is better for decompilation: (x & 0xf) == 0  vs  (((x & 0xf) - 1) & 0x10) != 0
  $(H_flag) = ((x & 0xf) == 0);
  op8 = tmp;
}

macro aluRlc(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[7,1];
  local tmp:1 = (x << 1) | co;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluRrc(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[0,1];
  local tmp:1 = (co << 7) | (x >> 1);
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluRl(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[7,1];
  local tmp:1 = (x << 1) | $(C_flag);
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluRr(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[0,1];
  local tmp:1 = ($(C_flag) << 7) | (x >> 1);
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluSla(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[7,1];
  local tmp:1 = x << 1;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluSra(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[0,1];
  local tmp:1 = x s>> 1;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluSwap(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local tmp:1 = (x[0,4] << 4) | x[4,4];
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = 0;
  op8 = tmp;
}

macro aluSrl(op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local co:1 = x[0,1];
  local tmp:1 = x >> 1;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
  op8 = tmp;
}

macro aluBit(bit, op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local mask:1 = (1 << bit);
  local tmp:1 = x & mask;
  $(Z_flag) = (tmp == 0);
  $(N_flag) = 0;
  $(H_flag) = 1;
}

macro aluRes(bit, op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local mask:1 = ~(1 << bit);
  local tmp:1 = x & mask;
  op8 = tmp;
}

macro aluSet(bit, op8) {
  # TODO: double-check flags
  local x:1 = op8;
  local mask:1 = (1 << bit);
  local tmp:1 = x | mask;
  op8 = tmp;
}

```

`data/languages/sm83.slaspec`:

```slaspec
# Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

@include "sm83.sinc"

@include "sm83_instructions.sinc"

```

`data/languages/sm83_instructions.sinc`:

```sinc
# Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# 8-bit loads

:LD reg3_3, reg0_3 is op6_2=0b01 & reg3_3 & reg0_3 {
  reg3_3 = reg0_3;
}

:LD reg3_3, imm8 is op6_2=0b00 & reg3_3 & op0_3=0b110; imm8 {
  reg3_3 = imm8;
}

:LD reg3_3, (HL) is op6_2=0b01 & reg3_3 & op0_3=0b110 & HL {
  reg3_3 = *:1 HL;
}

:LD (HL), reg0_3 is op6_2=0b01 & op3_3=0b110 & reg0_3 & HL {
  *:1 HL = reg0_3;
}

:LD (HL), imm8 is op0_8=0x36 & HL; imm8 {
  *:1 HL = imm8;
}

:LD A, (BC) is op0_8=0x0a & A & BC {
  A = *:1 BC;
}

:LD A, (DE) is op0_8=0x1a & A & DE {
  A = *:1 DE;
}

:LDH A, CMem8 is op0_8=0xf2 & A & CMem8 {
  A = CMem8;
}

:LDH CMem8, A is op0_8=0xe2 & A & CMem8 {
  CMem8 = A;
}

:LDH A, HiMem8 is op0_8=0xf0 & A; HiMem8 {
  A = HiMem8;
}

:LDH HiMem8, A is op0_8=0xe0 & A; HiMem8 {
  HiMem8 = A;
}

:LD A, Mem8 is op0_8=0xfa & A; Mem8 {
  A = Mem8;
}

:LD Mem8, A is op0_8=0xea & A; Mem8 {
  Mem8 = A;
}

:LD A, HLInc is op0_8=0x2a & A & HLInc {
  A = HLInc;
}

:LD A, HLDec is op0_8=0x3a & A & HLDec {
  A = HLDec;
}

:LD (BC), A is op0_8=0x02 & A & BC {
  *:1 BC = A;
}

:LD (DE), A is op0_8=0x12 & A & DE {
  *:1 DE = A;
}

:LD HLInc, A is op0_8=0x22 & A & HLInc {
  HLInc = A;
}

:LD HLDec, A is op0_8=0x32 & A & HLDec {
  HLDec = A;
}

# 8-bit arithmetic

:ADD reg0_3 is op6_2=0b10 & op3_3=0b000 & reg0_3 {
  aluAdd(reg0_3);
}

:ADD imm8 is op0_8=0xc6; imm8 {
  aluAdd(imm8);
}

:ADD (HL) is op0_8=0x86 & HL {
  local val:1 = *:1 HL;
  aluAdd(val);
}

:ADC reg0_3 is op6_2=0b10 & op3_3=0b001 & reg0_3 {
  aluAdc(reg0_3);
}

:ADC imm8 is op0_8=0xce; imm8 {
  aluAdc(imm8);
}

:ADC (HL) is op0_8=0x8e & HL {
  local val:1 = *:1 HL;
  aluAdc(val);
}

:SUB reg0_3 is op6_2=0b10 & op3_3=0b010 & reg0_3 {
  aluSub(reg0_3);
}

:SUB imm8 is op0_8=0xd6; imm8 {
  aluSub(imm8);
}

:SUB (HL) is op0_8=0x96 & HL {
  local val:1 = *:1 HL;
  aluSub(val);
}

:SBC reg0_3 is op6_2=0b10 & op3_3=0b011 & reg0_3 {
  aluSbc(reg0_3);
}

:SBC imm8 is op0_8=0xde; imm8 {
  aluSbc(imm8);
}

:SBC (HL) is op0_8=0x9e & HL {
  local val:1 = *:1 HL;
  aluSbc(val);
}

:AND reg0_3 is op6_2=0b10 & op3_3=0b100 & reg0_3 {
  aluAnd(reg0_3);
}

:AND imm8 is op0_8=0xe6; imm8 {
  aluAnd(imm8);
}

:AND (HL) is op0_8=0xa6 & HL {
  local val:1 = *:1 HL;
  aluAnd(val);
}

:XOR reg0_3 is op6_2=0b10 & op3_3=0b101 & reg0_3 {
  aluXor(reg0_3);
}

:XOR imm8 is op0_8=0xee; imm8 {
  aluXor(imm8);
}

:XOR (HL) is op0_8=0xae & HL {
  local val:1 = *:1 HL;
  aluXor(val);
}

:OR reg0_3 is op6_2=0b10 & op3_3=0b110 & reg0_3 {
  aluOr(reg0_3);
}

:OR imm8 is op0_8=0xf6; imm8 {
  aluOr(imm8);
}

:OR (HL) is op0_8=0xb6 & HL {
  local val:1 = *:1 HL;
  aluOr(val);
}

:CP reg0_3 is op6_2=0b10 & op3_3=0b111 & reg0_3 {
  aluCp(reg0_3);
}

:CP imm8 is op0_8=0xfe; imm8 {
  aluCp(imm8);
}

:CP (HL) is op0_8=0xbe & HL {
  local val:1 = *:1 HL;
  aluCp(val);
}

:INC reg3_3 is op6_2=0b00 & reg3_3 & op0_3=0b100 {
  aluInc(reg3_3);
}

:INC (HL) is op0_8=0x34 & HL {
  local val:1 = *:1 HL;
  aluInc(val);
  *:1 HL = val;
}

:DEC reg3_3 is op6_2=0b00 & reg3_3 & op0_3=0b101 {
  aluDec(reg3_3);
}

:DEC (HL) is op0_8=0x35 & HL {
  local val:1 = *:1 HL;
  aluDec(val);
  *:1 HL = val;
}

:RLCA is op0_8=0x07 {
  # TODO: double-check flags
  local co:1 = A[7,1];
  A = (A << 1) | co;
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
}

:RLA is op0_8=0x17 {
  # TODO: double-check flags
  local co:1 = A[7,1];
  A = (A << 1) | $(C_flag);
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
}

:RRCA is op0_8=0x0f {
  # TODO: double-check flags
  local co:1 = A[0,1];
  A = (co << 7) | (A >> 1);
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
}

:RRA is op0_8=0x1f {
  # TODO: double-check flags
  local co:1 = A[0,1];
  A = ($(C_flag) << 7) | (A >> 1);
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = co;
}

:RLC reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b000 & reg0_3 {
  aluRlc(reg0_3);
}

:RLC (HL) is op0_8=0xcb & HL; op0_8=0x06 {
  local val:1 = *:1 HL;
  aluRlc(val);
  *:1 HL = val;
}

:RRC reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b001 & reg0_3 {
  aluRrc(reg0_3);
}

:RRC (HL) is op0_8=0xcb & HL; op0_8=0x0e {
  local val:1 = *:1 HL;
  aluRrc(val);
  *:1 HL = val;
}

:RL reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b010 & reg0_3 {
  aluRl(reg0_3);
}

:RL (HL) is op0_8=0xcb & HL; op0_8=0x16 {
  local val:1 = *:1 HL;
  aluRl(val);
  *:1 HL = val;
}

:RR reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b011 & reg0_3 {
  aluRr(reg0_3);
}

:RR (HL) is op0_8=0xcb & HL; op0_8=0x1e {
  local val:1 = *:1 HL;
  aluRr(val);
  *:1 HL = val;
}

:SLA reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b100 & reg0_3 {
  aluSla(reg0_3);
}

:SLA (HL) is op0_8=0xcb & HL; op0_8=0x26 {
  local val:1 = *:1 HL;
  aluSla(val);
  *:1 HL = val;
}

:SRA reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b101 & reg0_3 {
  aluSra(reg0_3);
}

:SRA (HL) is op0_8=0xcb & HL; op0_8=0x2e {
  local val:1 = *:1 HL;
  aluSra(val);
  *:1 HL = val;
}

:SWAP reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b110 & reg0_3 {
  aluSwap(reg0_3);
}

:SWAP (HL) is op0_8=0xcb & HL; op0_8=0x36 {
  local val:1 = *:1 HL;
  aluSwap(val);
  *:1 HL = val;
}

:SRL reg0_3 is op0_8=0xcb; op6_2=0b00 & op3_3=0b111 & reg0_3 {
  aluSrl(reg0_3);
}

:SRL (HL) is op0_8=0xcb & HL; op0_8=0x3e {
  local val:1 = *:1 HL;
  aluSrl(val);
  *:1 HL = val;
}

:BIT bit3_3, reg0_3 is op0_8=0xcb; op6_2=0b01 & bit3_3 & reg0_3 {
  aluBit(bit3_3, reg0_3);
}

:BIT bit3_3, (HL) is op0_8=0xcb & HL; op6_2=0b01 & bit3_3 & op0_3=0b110 {
  local val:1 = *:1 HL;
  aluBit(bit3_3, val);
}

:RES bit3_3, reg0_3 is op0_8=0xcb; op6_2=0b10 & bit3_3 & reg0_3 {
  aluRes(bit3_3, reg0_3);
}

:RES bit3_3, (HL) is op0_8=0xcb & HL; op6_2=0b10 & bit3_3 & op0_3=0b110 {
  local val:1 = *:1 HL;
  aluRes(bit3_3, val);
  *:1 HL = val;
}

:SET bit3_3, reg0_3 is op0_8=0xcb; op6_2=0b11 & bit3_3 & reg0_3 {
  aluSet(bit3_3, reg0_3);
}

:SET bit3_3, (HL) is op0_8=0xcb & HL; op6_2=0b11 & bit3_3 & op0_3=0b110 {
  local val:1 = *:1 HL;
  aluSet(bit3_3, val);
  *:1 HL = val;
}

# Control

:JP Addr16 is op0_8=0xc3; Addr16 {
  goto Addr16;
}

:JP HL is op0_8=0xe9 & HL {
  goto [HL];
}

:JR RelAddr8 is op0_8=0x18; RelAddr8 {
  goto RelAddr8;
}

:CALL Addr16 is op0_8=0xcd; Addr16 {
  push16(&:2 inst_next);
  call Addr16;
}

:RET is op0_8=0xc9 {
  pop16(PC);
  return [PC];
}

:RETI is op0_8=0xd9 {
  pop16(PC);
  local ime:1 = 1;
  IME(ime);
  return [PC];
}

:JP cc, Addr16 is op5_3=0b110 & cc & op0_3=0b010; Addr16 {
  if (cc) goto Addr16;
}

:JR cc, RelAddr8 is op5_3=0b001 & cc & op0_3=0b000; RelAddr8 {
  if (cc) goto RelAddr8;
}

:CALL cc, Addr16 is op5_3=0b110 & cc & op0_3=0b100; Addr16 {
  if (!cc) goto inst_next;
  push16(&:2 inst_next);
  call Addr16;
}

:RET cc is op5_3=0b110 & cc & op0_3=0b000 {
  if (!cc) goto inst_next;
  pop16(PC);
  return [PC];
}

:RST RstAddr is op6_2=0b11 & RstAddr & op0_3=0b111 {
  push16(&:2 inst_next);
  call RstAddr;
}

# Miscellaneous

:HALT is op0_8=0x76 {
  halt();
}

:STOP is op0_8=0x10 {
  stop();
}

:DI is op0_8=0xf3 {
  local ime:1 = 0;
  IME(ime);
}

:EI is op0_8=0xfb {
  local ime:1 = 1;
  IME(ime);
}

:CCF is op0_8=0x3f {
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = !$(C_flag);
}

:SCF is op0_8=0x37 {
  $(N_flag) = 0;
  $(H_flag) = 0;
  $(C_flag) = 1;
}

:NOP is op0_8=0x00 {
}

:DAA is op0_8=0x27 {
  local op8:1 = 0;
  op8 = daaOperand(A, $(C_flag), $(H_flag), $(N_flag));
  local tmp:1 = A + op8;
  local co:1 = carry(A, op8);
  $(Z_flag) = (tmp == 0);
  $(H_flag) = 0;
  $(C_flag) = $(C_flag) || ((!$(N_flag)) && co);
  A = tmp;
}

:CPL is op0_8=0x2f {
  A = ~A;
  $(N_flag) = 1;
  $(H_flag) = 1;
}

# 16-bit loads

:LD dregpair4_2, imm16 is op6_2=0b00 & dregpair4_2 & op0_4=0b0001; imm16 {
  dregpair4_2 = imm16;
}

:LD Mem16, SP is op0_8=0x08 & SP; Mem16 {
  Mem16 = SP;
}

:LD SP, HL is op0_8=0xf9 & SP & HL {
  SP = HL;
}

:LD HL, SP+simm8 is op0_8=0xf8 & HL & SP; simm8 {
  # TODO: double-check flags
  local tmp:2 = SP + simm8;
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = (((SP:1 & 0xf) + (simm8 & 0xf)) & 0x10) != 0;
  $(C_flag) = carry(SP:1, simm8);
  HL = tmp;
}

:LD HL, SP-val is op0_8=0xf8 & HL & SP; simm8 & sign8=1 [
  val = -simm8;
] {
  # TODO: double-check flags
  local tmp:2 = SP + simm8;
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = (((SP:1 & 0xf) + (simm8 & 0xf)) & 0x10) != 0;
  $(C_flag) = carry(SP:1, simm8);
  HL = tmp;
}

:PUSH qregpair4_2 is op6_2=0b11 & qregpair4_2 & op0_4=0b0101 {
  push16(qregpair4_2);
}

:POP qregpair4_2 is op6_2=0b11 & qregpair4_2 & op0_4=0b0001 {
  pop16(qregpair4_2);
}

# 16-bit arithmetic

:ADD HL, sregpair4_2 is op6_2=0b00 & sregpair4_2 & op0_4=0b1001 & HL {
  # TODO: double-check flags
  local tmp:2 = HL + sregpair4_2;
  $(N_flag) = 0;
  $(H_flag) = (((HL & 0xfff) + (sregpair4_2 & 0xfff)) & 0x1000) != 0;
  $(C_flag) = carry(HL, sregpair4_2);
  HL = tmp;
}

:ADD SP, simm8 is op0_8=0xe8 & SP; simm8 {
  # TODO: double-check flags
  local tmp:2 = SP + simm8;
  $(Z_flag) = 0;
  $(N_flag) = 0;
  $(H_flag) = (((SP:1 & 0xf) + (simm8 & 0xf)) & 0x10) != 0;
  $(C_flag) = carry(SP:1, simm8);
  SP = tmp;
}

:INC sregpair4_2 is op6_2=0b00 & sregpair4_2 & op0_4=0b0011 {
  sregpair4_2 = sregpair4_2 + 1;
}

:DEC sregpair4_2 is op6_2=0b00 & sregpair4_2 & op0_4=0b1011 {
  sregpair4_2 = sregpair4_2 - 1;
}

```

`data/sleighArgs.txt`:

```txt
# Add sleigh compiler options to this file (one per line) which will
# be used when compiling each language within this module.
# All options should start with a '-' character.
#
# IMPORTANT: The -a option should NOT be specified
#
```

`gradle.properties`:

```properties
kotlin.stdlib.default.dependency=false

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${0##*/}

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle.kts`:

```kts
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
rootProject.name = "GhidraBoy"

```

`src/main/java/fi/gekkio/ghidraboy/BootRomUtils.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.app.util.bin.ByteProvider;

import java.io.IOException;
import java.util.Arrays;
import java.util.Optional;

public final class BootRomUtils {
    private BootRomUtils() {
    }

    private static final Sha256[] GB_ROMS = {
            Sha256.parse("26e71cf01e301e5dc40e987cd2ecbf6d0276245890ac829db2a25323da86818e"), // DMG0
            Sha256.parse("cf053eccb4ccafff9e67339d4e78e98dce7d1ed59be819d2a1ba2232c6fce1c7"), // DMG
            Sha256.parse("0e4ddff32fc9d1eeaae812a157dd246459b00c9e14f2f61751f661f32361e360"), // SGB
            Sha256.parse("a8cb5f4f1f16f2573ed2ecd8daedb9c5d1dd2c30a481f9b179b5d725d95eafe2"), // MGB
            Sha256.parse("fd243c4fb27008986316ce3df29e9cfbcdc0cd52704970555a8bb76edbec3988"), // SGB2
    };
    private static final Sha256[] CGB_ROMS = {
            Sha256.parse("3a307a41689bee99a9a32ea021bf45136906c86b2e4f06c806738398e4f92e45"), // CGB0
            Sha256.parse("b4f2e416a35eef52cba161b159c7c8523a92594facb924b3ede0d722867c50c7"), // CGB
    };

    public static Optional<GameBoyKind> detectBootRom(ByteProvider provider) throws IOException {
        if (provider.length() == 0x100) {
            var hash = Sha256.of(provider);
            if (Arrays.asList(GB_ROMS).contains(hash)) {
                return Optional.of(GameBoyKind.GB);
            }
        } else if (provider.length() == 0x900) {
            var hash = Sha256.of(provider);
            if (Arrays.asList(CGB_ROMS).contains(hash)) {
                return Optional.of(GameBoyKind.CGB);
            }
        }
        return Optional.empty();
    }
}

```

`src/main/java/fi/gekkio/ghidraboy/DataTypes.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.program.model.data.*;
import ghidra.program.model.data.Enum;

import java.util.Arrays;

public final class DataTypes {
    private DataTypes() {
    }

    private static final CategoryPath PATH = new CategoryPath(CategoryPath.ROOT, "Game Boy");

    public static final ByteDataType u8 = ByteDataType.dataType;
    public static final WordDataType u16 = WordDataType.dataType;
    public static final CharDataType ch = CharDataType.dataType;

    public static final TypeDef LOGO;
    public static final Enum CGB_FLAG;
    public static final Structure TITLE_BLOCK_OLD;
    public static final Structure TITLE_BLOCK_NEW;
    public static final Union TITLE_BLOCK;
    public static final Enum SGB_FLAG;
    public static final Enum CART_TYPE;
    public static final Enum ROM_SIZE;
    public static final Enum RAM_SIZE;
    public static final Enum REGION;
    public static final Structure HEADER;

    static {
        LOGO = new TypedefDataType(PATH, "logo", array(u8, 0x30));

        CGB_FLAG = new EnumDataType(PATH, "cgb_flag", 1);
        CGB_FLAG.add("NONE", 0x00);
        CGB_FLAG.add("SUPPORT", 0x80);
        CGB_FLAG.add("ONLY", 0xc0);

        TITLE_BLOCK_OLD = new StructureDataType(PATH, "title_block_old", 0);
        TITLE_BLOCK_OLD.add(array(ch, 15), "title", null);
        TITLE_BLOCK_OLD.add(CGB_FLAG, "cgb_flag", null);

        TITLE_BLOCK_NEW = new StructureDataType(PATH, "title_block_new", 0);
        TITLE_BLOCK_NEW.add(array(ch, 11), "title", null);
        TITLE_BLOCK_NEW.add(array(ch, 4), "manufacturer_code", null);
        TITLE_BLOCK_NEW.add(CGB_FLAG, "cgb_flag", null);

        TITLE_BLOCK = new UnionDataType(PATH, "title_block");
        TITLE_BLOCK.add(array(ch, 16), "title_only", null);
        TITLE_BLOCK.add(TITLE_BLOCK_OLD, "old_format", null);
        TITLE_BLOCK.add(TITLE_BLOCK_NEW, "new_format", null);

        SGB_FLAG = new EnumDataType(PATH, "sgb_flag", 1);
        SGB_FLAG.add("NONE", 0x00);
        SGB_FLAG.add("SUPPORT", 0x03);

        CART_TYPE = new EnumDataType(PATH, "cart_type", 1);
        CART_TYPE.add("ROM_ONLY", 0x00);
        CART_TYPE.add("MBC1", 0x01);
        CART_TYPE.add("MBC1_RAM", 0x02);
        CART_TYPE.add("MBC1_RAM_BATT", 0x03);
        CART_TYPE.add("MBC2", 0x05);
        CART_TYPE.add("MBC2_BATT", 0x06);
        CART_TYPE.add("RAM", 0x08);
        CART_TYPE.add("RAM_BATT", 0x09);
        CART_TYPE.add("MMM01", 0x0b);
        CART_TYPE.add("MMM01_RAM", 0x0c);
        CART_TYPE.add("MMM01_RAM_BATT", 0x0d);
        CART_TYPE.add("MBC3_RTC_BATT", 0x0f);
        CART_TYPE.add("MBC3_RAM_RTC_BATT", 0x10);
        CART_TYPE.add("MBC3", 0x11);
        CART_TYPE.add("MBC3_RAM", 0x12);
        CART_TYPE.add("MBC3_RAM_BATT", 0x13);
        CART_TYPE.add("MBC5", 0x19);
        CART_TYPE.add("MBC5_RAM", 0x1a);
        CART_TYPE.add("MBC5_RAM_BATT", 0x1b);
        CART_TYPE.add("MBC5_RUMBLE", 0x1c);
        CART_TYPE.add("MBC5_RAM_RUMBLE", 0x1d);
        CART_TYPE.add("MBC5_RAM_BATT_RUMBLE", 0x1e);
        CART_TYPE.add("MBC6", 0x20);
        CART_TYPE.add("MBC7", 0x22);
        CART_TYPE.add("POCKET_CAMERA", 0xfc);
        CART_TYPE.add("TAMA5", 0xfd);
        CART_TYPE.add("HUC3", 0xfe);
        CART_TYPE.add("HUC1", 0xff);

        ROM_SIZE = new EnumDataType(PATH, "rom_size", 1);
        ROM_SIZE.add("32K", 0x00);
        ROM_SIZE.add("64K", 0x01);
        ROM_SIZE.add("128K", 0x02);
        ROM_SIZE.add("256K", 0x03);
        ROM_SIZE.add("512K", 0x04);
        ROM_SIZE.add("1MB", 0x05);
        ROM_SIZE.add("2MB", 0x06);
        ROM_SIZE.add("4MB", 0x07);
        ROM_SIZE.add("8MB", 0x08);

        RAM_SIZE = new EnumDataType(PATH, "ram_size", 1);
        RAM_SIZE.add("NONE", 0x00);
        RAM_SIZE.add("2KB", 0x01);
        RAM_SIZE.add("8KB", 0x02);
        RAM_SIZE.add("32KB", 0x03);
        RAM_SIZE.add("128KB", 0x04);
        RAM_SIZE.add("64KB", 0x05);

        REGION = new EnumDataType(PATH, "region", 1);
        REGION.add("JAPAN", 0x00);
        REGION.add("WORLD", 0x01);

        HEADER = new StructureDataType(PATH, "header", 0);
        HEADER.add(TITLE_BLOCK, "title_block", null);
        HEADER.add(array(ch, 2), "new_licensee_code", null);
        HEADER.add(SGB_FLAG, "sgb_flag", null);
        HEADER.add(CART_TYPE, "cartridge_type", null);
        HEADER.add(ROM_SIZE, "rom_size", null);
        HEADER.add(RAM_SIZE, "ram_size", null);
        HEADER.add(REGION, "region", null);
        HEADER.add(u8, "old_licensee_code", null);
        HEADER.add(u8, "mask_rom_version", null);
        HEADER.add(u8, "header_checksum", null);
        HEADER.add(u16, "global_checksum", null);
    }

    public static void addAll(DataTypeManager m) {
        var types = new DataType[]{LOGO, CGB_FLAG, TITLE_BLOCK_OLD, TITLE_BLOCK_NEW, TITLE_BLOCK, SGB_FLAG, CART_TYPE, ROM_SIZE, RAM_SIZE, REGION, HEADER};
        var c = m.createCategory(PATH);
        Arrays.stream(types).forEach(d -> c.addDataType(d, DataTypeConflictHandler.DEFAULT_HANDLER));
    }

    static Array array(DataType d, int size) {
        return new ArrayDataType(d, size, -1);
    }
}

```

`src/main/java/fi/gekkio/ghidraboy/GameBoyKind.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

public enum GameBoyKind {
    GB, CGB
}

```

`src/main/java/fi/gekkio/ghidraboy/GameBoyKindOption.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.app.util.Option;

import javax.swing.*;
import java.awt.*;

public class GameBoyKindOption extends Option {
    private final Component customEditor = createCustomEditor(this);

    public GameBoyKindOption(String name, GameBoyKind value) {
        super(name, GameBoyKind.class, value, null, null);
    }

    public GameBoyKindOption(String group, String name, GameBoyKind value) {
        super(name, GameBoyKind.class, value, null, group);
    }

    public GameBoyKindOption(String name) {
        super(name, GameBoyKind.class, null, null, null);
    }

    public GameBoyKindOption(String name, GameBoyKind value, String arg) {
        super(name, GameBoyKind.class, value, arg, null);
    }

    public GameBoyKindOption(String name, GameBoyKind value, String arg, String group) {
        super(name, GameBoyKind.class, value, arg, group);
    }

    @Override
    public Component getCustomEditorComponent() {
        return this.customEditor;
    }

    @Override
    public Option copy() {
        return new GameBoyKindOption(this.getName(), (GameBoyKind) this.getValue(), this.getArg(), this.getGroup());
    }

    private static Component createCustomEditor(Option option) {
        var panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));

        var gb = new JRadioButton("Game Boy");
        gb.addActionListener(e -> option.setValue(GameBoyKind.GB));
        gb.setSelected(GameBoyKind.GB.equals(option.getValue()));

        var cgb = new JRadioButton("Game Boy Color");
        cgb.addActionListener(e -> option.setValue(GameBoyKind.CGB));
        cgb.setSelected(GameBoyKind.CGB.equals(option.getValue()));

        var group = new ButtonGroup();
        group.add(gb);
        group.add(cgb);
        panel.add(gb);
        panel.add(cgb);
        return panel;
    }
}

```

`src/main/java/fi/gekkio/ghidraboy/GameBoyLoader.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.app.util.MemoryBlockUtils;
import ghidra.app.util.Option;
import ghidra.app.util.OptionUtils;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.importer.MessageLog;
import ghidra.app.util.opinion.AbstractProgramLoader;
import ghidra.app.util.opinion.LoadSpec;
import ghidra.app.util.opinion.LoaderTier;
import ghidra.framework.model.DomainFolder;
import ghidra.framework.model.DomainObject;
import ghidra.program.database.function.OverlappingFunctionException;
import ghidra.program.model.address.AddressOverflowException;
import ghidra.program.model.address.AddressSet;
import ghidra.program.model.data.DataUtilities.ClearDataMode;
import ghidra.program.model.lang.LanguageCompilerSpecPair;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static fi.gekkio.ghidraboy.BootRomUtils.detectBootRom;
import static fi.gekkio.ghidraboy.GameBoyUtils.addHardwareBlocks;
import static fi.gekkio.ghidraboy.GameBoyUtils.populateHardwareBlocks;
import static fi.gekkio.ghidraboy.RomUtils.detectRom;
import static ghidra.app.util.MemoryBlockUtils.createInitializedBlock;
import static ghidra.app.util.MemoryBlockUtils.createUninitializedBlock;
import static ghidra.program.model.data.DataUtilities.createData;

public class GameBoyLoader extends AbstractProgramLoader {
    private static final String OPT_HW_BLOCKS = "Create GB hardware memory blocks";
    private static final String OPT_DATA_TYPES = "Create GB data types";
    private static final String OPT_KIND = "Hardware type";

    @Override
    public String getName() {
        return "Game Boy";
    }

    @Override
    public LoaderTier getTier() {
        return LoaderTier.SPECIALIZED_TARGET_LOADER;
    }

    @Override
    public int getTierPriority() {
        return 0;
    }

    @Override
    public boolean supportsLoadIntoProgram() {
        return true;
    }

    @Override
    public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
        var result = new ArrayList<LoadSpec>();
        if (detectBootRom(provider).isPresent() || detectRom(provider).isPresent()) {
            result.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair("SM83:LE:16:default", "default"), true));
        }
        return result;
    }

    @Override
    public List<Option> getDefaultOptions(ByteProvider provider, LoadSpec loadSpec, DomainObject domainObject, boolean isLoadIntoProgram) {
        var result = super.getDefaultOptions(provider, loadSpec, domainObject, isLoadIntoProgram);
        result.add(new Option(OPT_HW_BLOCKS, true));
        result.add(new Option(OPT_DATA_TYPES, true));
        try {
            var bootRom = detectBootRom(provider);
            if (bootRom.isPresent()) {
                result.add(new GameBoyKindOption(OPT_KIND, bootRom.get()));
                return result;
            }
            var rom = detectRom(provider);
            if (rom.isPresent()) {
                result.add(new GameBoyKindOption(OPT_KIND, rom.get()));
                return result;
            }
        } catch (IOException ignored) {
        }
        result.add(new GameBoyKindOption(OPT_KIND, GameBoyKind.GB));
        return result;
    }

    @Override
    protected List<LoadedProgram> loadProgram(ByteProvider provider, String programName, DomainFolder programFolder, LoadSpec loadSpec, List<Option> options, MessageLog log, Object consumer, TaskMonitor monitor) throws IOException, CancelledException {
        var result = new ArrayList<LoadedProgram>();
        var pair = loadSpec.getLanguageCompilerSpec();
        var language = getLanguageService().getLanguage(pair.languageID);
        var compiler = language.getCompilerSpecByID(pair.compilerSpecID);

        var baseAddress = language.getAddressFactory().getDefaultAddressSpace().getAddress(0);
        var program = createProgram(provider, programName, baseAddress, getName(), language, compiler, consumer);
        var success = false;
        try {
            var kind = OptionUtils.getOption(OPT_KIND, options, GameBoyKind.GB);
            if (OptionUtils.getBooleanOptionValue(OPT_DATA_TYPES, options, true)) {
                int id = program.startTransaction("Create GB data types");
                try {
                    DataTypes.addAll(program.getDataTypeManager());
                } finally {
                    program.endTransaction(id, true);
                }
            }
            if (loadInto(provider, loadSpec, options, log, program, monitor)) {
                createDefaultMemoryBlocks(program, language, log);

                if (OptionUtils.getBooleanOptionValue(OPT_HW_BLOCKS, options, true)) {
                    int id = program.startTransaction("Create GB hardware memory blocks");
                    try {
                        addHardwareBlocks(program, kind, log);
                        populateHardwareBlocks(program, kind);
                    } catch (InvalidInputException | CodeUnitInsertionException e) {
                        log.appendException(e);
                    } finally {
                        program.endTransaction(id, true);
                    }
                }
                success = result.add(new LoadedProgram(program, programFolder));
            }
        } finally {
            if (!success) {
                program.release(consumer);
            }
        }
        return result;
    }

    @Override
    protected boolean loadProgramInto(ByteProvider provider, LoadSpec loadSpec, List<Option> options, MessageLog log, Program program, TaskMonitor monitor) throws IOException, CancelledException {
        var as = program.getAddressFactory().getDefaultAddressSpace();

        var bootRom = detectBootRom(provider);
        var rom = MemoryBlockUtils.createFileBytes(program, provider, monitor);

        if (bootRom.isPresent()) {
            var cgb = GameBoyKind.CGB.equals(bootRom.get());
            try {
                createInitializedBlock(program, false, cgb ? "boot0" : "boot", as.getAddress(0x0000), rom, 0, 0x100, "", getName(), false, false, true, log);
                createUninitializedBlock(program, false, "rom", as.getAddress(0x0100), 0x50, "", getName(), true, false, false, log);
                if (cgb) {
                    createInitializedBlock(program, false, "boot1", as.getAddress(0x0200), rom, 0x200, 0x700, "", getName(), false, false, true, log);
                }
                var st = program.getSymbolTable();
                st.addExternalEntryPoint(as.getAddress(0x0000));
                st.createLabel(as.getAddress(0x0000), "boot_entry", SourceType.IMPORTED);
            } catch (AddressOverflowException | InvalidInputException e) {
                log.appendException(e);
                throw new CancelledException("Loading failed: " + e.getMessage());
            }
        } else {
            var banked = provider.length() > 0x8000;
            try {
                createInitializedBlock(program, false, banked ? "rom0" : "rom", as.getAddress(0x0000), rom, 0, banked ? 0x4000 : 0x8000, "Cartridge ROM (offset 0)", getName(), true, false, true, log);
                if (banked) {
                    var romX = as.getAddress(0x4000);
                    var offset = 0x4000;
                    var bank = 1;
                    while (offset < rom.getSize()) {
                        createInitializedBlock(program, true, "rom" + bank, romX, rom, offset, 0x4000, "Cartridge ROM (offset %d)".formatted(offset), getName(), true, false, true, log);
                        offset += 0x4000;
                        bank += 1;
                    }
                }
                createUninitializedBlock(program, false, "xram", as.getAddress(0xa000), 0x2000, "Cartridge RAM", getName(), true, true, true, log);

                var st = program.getSymbolTable();
                st.createLabel(as.getAddress(0x0000), "rst00", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0008), "rst08", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0010), "rst10", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0018), "rst18", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0020), "rst20", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0028), "rst28", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0030), "rst30", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0038), "rst38", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0040), "intr_vblank", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0048), "intr_stat", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0050), "intr_timer", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0058), "intr_serial", SourceType.IMPORTED);
                st.createLabel(as.getAddress(0x0060), "intr_joypad", SourceType.IMPORTED);
                st.addExternalEntryPoint(as.getAddress(0x0100));
                try {
                    var entry = program.getFunctionManager().createFunction("entry", as.getAddress(0x0100), new AddressSet(as.getAddress(0x0100), as.getAddress(0x103)), SourceType.IMPORTED);
                    entry.setNoReturn(true);
                } catch (OverlappingFunctionException e) {
                    log.appendException(e);
                }
            } catch (AddressOverflowException | InvalidInputException e) {
                log.appendException(e);
                throw new CancelledException("Loading failed: " + e.getMessage());
            }
        }
        var createDataTypes = OptionUtils.getBooleanOptionValue(OPT_DATA_TYPES, options, true);

        if (createDataTypes || program.getDataTypeManager().contains(DataTypes.LOGO)) {
            try {
                createData(program, as.getAddress(0x0104), DataTypes.LOGO, -1, false, ClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);
            } catch (CodeUnitInsertionException e) {
                log.appendException(e);
            }
        }
        if (createDataTypes || program.getDataTypeManager().contains(DataTypes.HEADER)) {
            try {
                createData(program, as.getAddress(0x0134), DataTypes.HEADER, -1, false, ClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);
            } catch (CodeUnitInsertionException e) {
                log.appendException(e);
            }
        }
        return true;
    }
}

```

`src/main/java/fi/gekkio/ghidraboy/GameBoyUtils.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataUtilities;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.InvalidInputException;

import static fi.gekkio.ghidraboy.DataTypes.array;
import static fi.gekkio.ghidraboy.DataTypes.u8;
import static ghidra.app.util.MemoryBlockUtils.createUninitializedBlock;
import static ghidra.program.model.data.DataUtilities.createData;

public final class GameBoyUtils {
    private GameBoyUtils() {
    }

    public static void addHardwareBlocks(Program program, GameBoyKind kind, MessageLog log) {
        var source = kind == GameBoyKind.CGB ? "Game Boy Color hardware" : "Game Boy hardware";
        var as = program.getAddressFactory().getDefaultAddressSpace();
        if (kind == GameBoyKind.CGB) {
            createUninitializedBlock(program, true, "vram0", as.getAddress(0x8000), 0x2000, "Video RAM (bank 0)", source, true, true, false, log);
            createUninitializedBlock(program, true, "vram1", as.getAddress(0x8000), 0x2000, "Video RAM (bank 1)", source, true, true, false, log);
        } else {
            createUninitializedBlock(program, false, "vram", as.getAddress(0x8000), 0x2000, "Video RAM", source, true, true, false, log);
        }
        if (kind == GameBoyKind.CGB) {
            createUninitializedBlock(program, false, "wram0", as.getAddress(0xc000), 0x1000, "Work RAM (bank 0)", source, true, true, true, log);
            for (int i = 1; i <= 7; i++) {
                createUninitializedBlock(program, true, "wram" + i, as.getAddress(0xd000), 0x1000, "Work RAM (bank %d)".formatted(i), source, true, true, true, log);
            }
        } else {
            createUninitializedBlock(program, false, "wram", as.getAddress(0xc000), 0x2000, "Work RAM", source, true, true, true, log);
        }
        createUninitializedBlock(program, false, "oam", as.getAddress(0xfe00), 0xa0, "Object Attribute Memory RAM", source, true, true, false, log);
        var io = createUninitializedBlock(program, false, "io", as.getAddress(0xff00), 0x80, "I/O registers", source, true, true, false, log);
        if (io != null) {
            io.setVolatile(true);
        }
        createUninitializedBlock(program, false, "hram", as.getAddress(0xff80), 0x7f, "High RAM", source, true, true, true, log);
        var ie = createUninitializedBlock(program, false, "ie", as.getAddress(0xffff), 0x1, "Interrupt Enable register", source, true, true, false, log);
        if (ie != null) {
            ie.setVolatile(true);
        }
    }

    public static void populateHardwareBlocks(Program program, GameBoyKind kind) throws CodeUnitInsertionException, InvalidInputException {
        var as = program.getAddressFactory().getDefaultAddressSpace();
        addHwData(program, "P1", as.getAddress(0xff00), u8);
        addHwData(program, "SB", as.getAddress(0xff01), u8);
        addHwData(program, "SC", as.getAddress(0xff02), u8);
        addHwData(program, "DIV", as.getAddress(0xff04), u8);
        addHwData(program, "TIMA", as.getAddress(0xff05), u8);
        addHwData(program, "TMA", as.getAddress(0xff06), u8);
        addHwData(program, "TAC", as.getAddress(0xff07), u8);
        addHwData(program, "IF", as.getAddress(0xff0f), u8);
        addHwData(program, "NR10", as.getAddress(0xff10), u8);
        addHwData(program, "NR11", as.getAddress(0xff11), u8);
        addHwData(program, "NR12", as.getAddress(0xff12), u8);
        addHwData(program, "NR13", as.getAddress(0xff13), u8);
        addHwData(program, "NR14", as.getAddress(0xff14), u8);
        addHwData(program, "NR21", as.getAddress(0xff16), u8);
        addHwData(program, "NR22", as.getAddress(0xff17), u8);
        addHwData(program, "NR23", as.getAddress(0xff18), u8);
        addHwData(program, "NR24", as.getAddress(0xff19), u8);
        addHwData(program, "NR30", as.getAddress(0xff1a), u8);
        addHwData(program, "NR31", as.getAddress(0xff1b), u8);
        addHwData(program, "NR32", as.getAddress(0xff1c), u8);
        addHwData(program, "NR33", as.getAddress(0xff1d), u8);
        addHwData(program, "NR34", as.getAddress(0xff1e), u8);
        addHwData(program, "NR41", as.getAddress(0xff20), u8);
        addHwData(program, "NR42", as.getAddress(0xff21), u8);
        addHwData(program, "NR43", as.getAddress(0xff22), u8);
        addHwData(program, "NR44", as.getAddress(0xff23), u8);
        addHwData(program, "NR50", as.getAddress(0xff24), u8);
        addHwData(program, "NR51", as.getAddress(0xff25), u8);
        addHwData(program, "NR52", as.getAddress(0xff26), u8);
        addHwData(program, "WAVE", as.getAddress(0xff30), array(u8, 16));
        addHwData(program, "LCDC", as.getAddress(0xff40), u8);
        addHwData(program, "STAT", as.getAddress(0xff41), u8);
        addHwData(program, "SCY", as.getAddress(0xff42), u8);
        addHwData(program, "SCX", as.getAddress(0xff43), u8);
        addHwData(program, "LY", as.getAddress(0xff44), u8);
        addHwData(program, "LYC", as.getAddress(0xff45), u8);
        addHwData(program, "DMA", as.getAddress(0xff46), u8);
        addHwData(program, "BGP", as.getAddress(0xff47), u8);
        addHwData(program, "OBP0", as.getAddress(0xff48), u8);
        addHwData(program, "OBP1", as.getAddress(0xff49), u8);
        addHwData(program, "WY", as.getAddress(0xff4a), u8);
        addHwData(program, "WX", as.getAddress(0xff4b), u8);
        if (kind == GameBoyKind.CGB) {
            addHwData(program, "KEY1", as.getAddress(0xff4d), u8);
            addHwData(program, "VBK", as.getAddress(0xff4f), u8);
        }
        addHwData(program, "BOOT", as.getAddress(0xff50), u8);
        if (kind == GameBoyKind.CGB) {
            addHwData(program, "HDMA1", as.getAddress(0xff51), u8);
            addHwData(program, "HDMA2", as.getAddress(0xff52), u8);
            addHwData(program, "HDMA3", as.getAddress(0xff53), u8);
            addHwData(program, "HDMA4", as.getAddress(0xff54), u8);
            addHwData(program, "HDMA5", as.getAddress(0xff55), u8);
            addHwData(program, "RP", as.getAddress(0xff56), u8);
            addHwData(program, "BCPS", as.getAddress(0xff68), u8);
            addHwData(program, "BCPD", as.getAddress(0xff69), u8);
            addHwData(program, "OCPS", as.getAddress(0xff6a), u8);
            addHwData(program, "OCPD", as.getAddress(0xff6b), u8);
            addHwData(program, "SVBK", as.getAddress(0xff70), u8);
            addHwData(program, "PCM12", as.getAddress(0xff76), u8);
            addHwData(program, "PCM34", as.getAddress(0xff77), u8);
        }
        addHwData(program, "IE", as.getAddress(0xffff), u8);
    }

    private static void addHwData(Program program, String name, Address address, DataType dataType) throws CodeUnitInsertionException, InvalidInputException {
        createData(program, address, dataType, -1, false, DataUtilities.ClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);
        program.getSymbolTable().createLabel(address, name, SourceType.IMPORTED).setPinned(true);
    }

}

```

`src/main/java/fi/gekkio/ghidraboy/RomUtils.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.app.util.bin.ByteProvider;

import java.io.IOException;
import java.util.Optional;

public final class RomUtils {
    private RomUtils() {
    }

    private static final Sha256 LOGO_HASH = Sha256.parse("daf4cabdc852baa0291849203f0b41fd0b4ecd58e0d7aff4a509f5de4d7f9a2e");

    public static Optional<GameBoyKind> detectRom(ByteProvider provider) throws IOException {
        if (provider.length() >= 0x150) {
            var logo = provider.readBytes(0x0104, 0x30);
            if (LOGO_HASH.equals(Sha256.of(logo))) {
                var cgbFlag = (short) provider.readByte(0x0143);
                return Optional.of((cgbFlag & 0x80) == 0 ? GameBoyKind.GB : GameBoyKind.CGB);
            }
        }
        return Optional.empty();
    }
}

```

`src/main/java/fi/gekkio/ghidraboy/Sha256.java`:

```java
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy;

import ghidra.app.util.bin.ByteProvider;
import ghidra.util.HashUtilities;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.regex.Pattern;

public record Sha256(String value) {
    @Override
    public String toString() {
        return this.value;
    }

    private static final Pattern SHA256_HEX = Pattern.compile("^[0-9a-z]{64}$");

    public static Sha256 parse(String sha256Hex) {
        if (!SHA256_HEX.matcher(sha256Hex).matches()) {
            throw new IllegalArgumentException("Invalid SHA256 " + sha256Hex);
        }
        return new Sha256(sha256Hex);
    }

    public static Sha256 of(ByteProvider provider) throws IOException {
        try (var stream = provider.getInputStream(0)) {
            return new Sha256(HashUtilities.getHash(HashUtilities.SHA256_ALGORITHM, stream));
        }
    }

    public static Sha256 of(byte[] bytes) throws IOException {
        try (var stream = new ByteArrayInputStream(bytes)) {
            return new Sha256(HashUtilities.getHash(HashUtilities.SHA256_ALGORITHM, stream));
        }
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/DisassemblyTest.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy

import ghidra.app.emulator.EmulatorHelper
import ghidra.program.database.ProgramDB
import ghidra.program.disassemble.Disassembler
import ghidra.program.model.listing.CodeUnit
import ghidra.util.task.TaskMonitor
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class DisassemblyTest : IntegrationTest() {
    @Test
    fun `can disassemble NOP`() = test(0x00, "NOP")

    @Test
    fun `can disassemble LD BC, nn`() = test(0x01, "LD BC,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble LD (BC), A`() = test(0x02, "LD (BC),A")

    @Test
    fun `can disassemble INC BC`() = test(0x03, "INC BC")

    @Test
    fun `can disassemble INC B`() = test(0x04, "INC B")

    @Test
    fun `can disassemble DEC B`() = test(0x05, "DEC B")

    @Test
    fun `can disassemble LD B, n`() = test(0x06, "LD B,0x55", 0x55)

    @Test
    fun `can disassemble RLCA`() = test(0x07, "RLCA")

    @Test
    fun `can disassemble LD (nn), SP`() = test(0x08, "LD (0x1234),SP", 0x34, 0x12)

    @Test
    fun `can disassemble ADD HL, BC`() = test(0x09, "ADD HL,BC")

    @Test
    fun `can disassemble LD A, (BC)`() = test(0x0a, "LD A,(BC)")

    @Test
    fun `can disassemble DEC BC`() = test(0x0b, "DEC BC")

    @Test
    fun `can disassemble INC C`() = test(0x0c, "INC C")

    @Test
    fun `can disassemble DEC C`() = test(0x0d, "DEC C")

    @Test
    fun `can disassemble LD C, n`() = test(0x0e, "LD C,0x55", 0x55)

    @Test
    fun `can disassemble RRCA`() = test(0x0f, "RRCA")

    @Test
    fun `can disassemble STOP`() = test(0x10, "STOP")

    @Test
    fun `can disassemble LD DE, nn`() = test(0x11, "LD DE,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble LD (DE), A`() = test(0x12, "LD (DE),A")

    @Test
    fun `can disassemble INC DE`() = test(0x13, "INC DE")

    @Test
    fun `can disassemble INC D`() = test(0x14, "INC D")

    @Test
    fun `can disassemble DEC D`() = test(0x15, "DEC D")

    @Test
    fun `can disassemble LD D, n`() = test(0x16, "LD D,0x55", 0x55)

    @Test
    fun `can disassemble RLA`() = test(0x17, "RLA")

    @Test
    fun `can disassemble JR e (positive operand)`() = test(0x18, "JR 0x0057", 0x55)

    @Test
    fun `can disassemble JR e (negative operand)`() = test(0x18, "JR 0xffd7", 0xd5)

    @Test
    fun `can disassemble ADD HL, DE`() = test(0x19, "ADD HL,DE")

    @Test
    fun `can disassemble LD A, (DE)`() = test(0x1a, "LD A,(DE)")

    @Test
    fun `can disassemble DEC DE`() = test(0x1b, "DEC DE")

    @Test
    fun `can disassemble INC E`() = test(0x1c, "INC E")

    @Test
    fun `can disassemble DEC E`() = test(0x1d, "DEC E")

    @Test
    fun `can disassemble LD E, n`() = test(0x1e, "LD E,0x55", 0x55)

    @Test
    fun `can disassemble RRA`() = test(0x1f, "RRA")

    @Test
    fun `can disassemble JR NZ, e (positive operand)`() = test(0x20, "JR NZ,0x0057", 0x55)

    @Test
    fun `can disassemble JR NZ, e (negative operand)`() = test(0x20, "JR NZ,0xffd7", 0xd5)

    @Test
    fun `can disassemble LD HL, nn`() = test(0x21, "LD HL,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble LD (HL+), A`() = test(0x22, "LD (HL+),A")

    @Test
    fun `can disassemble INC HL`() = test(0x23, "INC HL")

    @Test
    fun `can disassemble INC H`() = test(0x24, "INC H")

    @Test
    fun `can disassemble DEC H`() = test(0x25, "DEC H")

    @Test
    fun `can disassemble LD H, n`() = test(0x26, "LD H,0x55", 0x55)

    @Test
    fun `can disassemble DAA`() = test(0x27, "DAA")

    @Test
    fun `can disassemble JR Z, e (positive operand)`() = test(0x28, "JR Z,0x0057", 0x55)

    @Test
    fun `can disassemble JR Z, e (negative operand)`() = test(0x28, "JR Z,0xffd7", 0xd5)

    @Test
    fun `can disassemble ADD HL, HL`() = test(0x29, "ADD HL,HL")

    @Test
    fun `can disassemble LD A, (HL+)`() = test(0x2a, "LD A,(HL+)")

    @Test
    fun `can disassemble DEC HL`() = test(0x2b, "DEC HL")

    @Test
    fun `can disassemble INC L`() = test(0x2c, "INC L")

    @Test
    fun `can disassemble DEC L`() = test(0x2d, "DEC L")

    @Test
    fun `can disassemble LD L, n`() = test(0x2e, "LD L,0x55", 0x55)

    @Test
    fun `can disassemble CPL`() = test(0x2f, "CPL")

    @Test
    fun `can disassemble JR NC, e (positive operand)`() = test(0x30, "JR NC,0x0057", 0x55)

    @Test
    fun `can disassemble JR NC, e (negative operand)`() = test(0x30, "JR NC,0xffd7", 0xd5)

    @Test
    fun `can disassemble LD SP, nn`() = test(0x31, "LD SP,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble LD (HL-), A`() = test(0x32, "LD (HL-),A")

    @Test
    fun `can disassemble INC SP`() = test(0x33, "INC SP")

    @Test
    fun `can disassemble INC (HL)`() = test(0x34, "INC (HL)")

    @Test
    fun `can disassemble DEC (HL)`() = test(0x35, "DEC (HL)")

    @Test
    fun `can disassemble LD (HL), n`() = test(0x36, "LD (HL),0x55", 0x55)

    @Test
    fun `can disassemble SCF`() = test(0x37, "SCF")

    @Test
    fun `can disassemble JR C, e (positive operand)`() = test(0x38, "JR C,0x0057", 0x55)

    @Test
    fun `can disassemble JR C, e (negative operand)`() = test(0x38, "JR C,0xffd7", 0xd5)

    @Test
    fun `can disassemble ADD HL, SP`() = test(0x39, "ADD HL,SP")

    @Test
    fun `can disassemble LD A, (HL-)`() = test(0x3a, "LD A,(HL-)")

    @Test
    fun `can disassemble DEC SP`() = test(0x3b, "DEC SP")

    @Test
    fun `can disassemble INC A`() = test(0x3c, "INC A")

    @Test
    fun `can disassemble DEC A`() = test(0x3d, "DEC A")

    @Test
    fun `can disassemble LD A, n`() = test(0x3e, "LD A,0x55", 0x55)

    @Test
    fun `can disassemble CCF`() = test(0x3f, "CCF")

    @Test
    fun `can disassemble LD B, B`() = test(0x40, "LD B,B")

    @Test
    fun `can disassemble LD B, C`() = test(0x41, "LD B,C")

    @Test
    fun `can disassemble LD B, D`() = test(0x42, "LD B,D")

    @Test
    fun `can disassemble LD B, E`() = test(0x43, "LD B,E")

    @Test
    fun `can disassemble LD B, H`() = test(0x44, "LD B,H")

    @Test
    fun `can disassemble LD B, L`() = test(0x45, "LD B,L")

    @Test
    fun `can disassemble LD B, (HL)`() = test(0x46, "LD B,(HL)")

    @Test
    fun `can disassemble LD B, A`() = test(0x47, "LD B,A")

    @Test
    fun `can disassemble LD C, B`() = test(0x48, "LD C,B")

    @Test
    fun `can disassemble LD C, C`() = test(0x49, "LD C,C")

    @Test
    fun `can disassemble LD C, D`() = test(0x4a, "LD C,D")

    @Test
    fun `can disassemble LD C, E`() = test(0x4b, "LD C,E")

    @Test
    fun `can disassemble LD C, H`() = test(0x4c, "LD C,H")

    @Test
    fun `can disassemble LD C, L`() = test(0x4d, "LD C,L")

    @Test
    fun `can disassemble LD C, (HL)`() = test(0x4e, "LD C,(HL)")

    @Test
    fun `can disassemble LD C, A`() = test(0x4f, "LD C,A")

    @Test
    fun `can disassemble LD D, B`() = test(0x50, "LD D,B")

    @Test
    fun `can disassemble LD D, C`() = test(0x51, "LD D,C")

    @Test
    fun `can disassemble LD D, D`() = test(0x52, "LD D,D")

    @Test
    fun `can disassemble LD D, E`() = test(0x53, "LD D,E")

    @Test
    fun `can disassemble LD D, H`() = test(0x54, "LD D,H")

    @Test
    fun `can disassemble LD D, L`() = test(0x55, "LD D,L")

    @Test
    fun `can disassemble LD D, (HL)`() = test(0x56, "LD D,(HL)")

    @Test
    fun `can disassemble LD D, A`() = test(0x57, "LD D,A")

    @Test
    fun `can disassemble LD E, B`() = test(0x58, "LD E,B")

    @Test
    fun `can disassemble LD E, C`() = test(0x59, "LD E,C")

    @Test
    fun `can disassemble LD E, D`() = test(0x5a, "LD E,D")

    @Test
    fun `can disassemble LD E, E`() = test(0x5b, "LD E,E")

    @Test
    fun `can disassemble LD E, H`() = test(0x5c, "LD E,H")

    @Test
    fun `can disassemble LD E, L`() = test(0x5d, "LD E,L")

    @Test
    fun `can disassemble LD E, (HL)`() = test(0x5e, "LD E,(HL)")

    @Test
    fun `can disassemble LD E, A`() = test(0x5f, "LD E,A")

    @Test
    fun `can disassemble LD H, B`() = test(0x60, "LD H,B")

    @Test
    fun `can disassemble LD H, C`() = test(0x61, "LD H,C")

    @Test
    fun `can disassemble LD H, D`() = test(0x62, "LD H,D")

    @Test
    fun `can disassemble LD H, E`() = test(0x63, "LD H,E")

    @Test
    fun `can disassemble LD H, H`() = test(0x64, "LD H,H")

    @Test
    fun `can disassemble LD H, L`() = test(0x65, "LD H,L")

    @Test
    fun `can disassemble LD H, (HL)`() = test(0x66, "LD H,(HL)")

    @Test
    fun `can disassemble LD H, A`() = test(0x67, "LD H,A")

    @Test
    fun `can disassemble LD L, B`() = test(0x68, "LD L,B")

    @Test
    fun `can disassemble LD L, C`() = test(0x69, "LD L,C")

    @Test
    fun `can disassemble LD L, D`() = test(0x6a, "LD L,D")

    @Test
    fun `can disassemble LD L, E`() = test(0x6b, "LD L,E")

    @Test
    fun `can disassemble LD L, H`() = test(0x6c, "LD L,H")

    @Test
    fun `can disassemble LD L, L`() = test(0x6d, "LD L,L")

    @Test
    fun `can disassemble LD L, (HL)`() = test(0x6e, "LD L,(HL)")

    @Test
    fun `can disassemble LD L, A`() = test(0x6f, "LD L,A")

    @Test
    fun `can disassemble LD (HL), B`() = test(0x70, "LD (HL),B")

    @Test
    fun `can disassemble LD (HL), C`() = test(0x71, "LD (HL),C")

    @Test
    fun `can disassemble LD (HL), D`() = test(0x72, "LD (HL),D")

    @Test
    fun `can disassemble LD (HL), E`() = test(0x73, "LD (HL),E")

    @Test
    fun `can disassemble LD (HL), H`() = test(0x74, "LD (HL),H")

    @Test
    fun `can disassemble LD (HL), L`() = test(0x75, "LD (HL),L")

    @Test
    fun `can disassemble HALT`() = test(0x76, "HALT")

    @Test
    fun `can disassemble LD (HL), A`() = test(0x77, "LD (HL),A")

    @Test
    fun `can disassemble LD A, B`() = test(0x78, "LD A,B")

    @Test
    fun `can disassemble LD A, C`() = test(0x79, "LD A,C")

    @Test
    fun `can disassemble LD A, D`() = test(0x7a, "LD A,D")

    @Test
    fun `can disassemble LD A, E`() = test(0x7b, "LD A,E")

    @Test
    fun `can disassemble LD A, H`() = test(0x7c, "LD A,H")

    @Test
    fun `can disassemble LD A, L`() = test(0x7d, "LD A,L")

    @Test
    fun `can disassemble LD A, (HL)`() = test(0x7e, "LD A,(HL)")

    @Test
    fun `can disassemble LD A, A`() = test(0x7f, "LD A,A")

    @Test
    fun `can disassemble ADD B`() = test(0x80, "ADD B")

    @Test
    fun `can disassemble ADD C`() = test(0x81, "ADD C")

    @Test
    fun `can disassemble ADD D`() = test(0x82, "ADD D")

    @Test
    fun `can disassemble ADD E`() = test(0x83, "ADD E")

    @Test
    fun `can disassemble ADD H`() = test(0x84, "ADD H")

    @Test
    fun `can disassemble ADD L`() = test(0x85, "ADD L")

    @Test
    fun `can disassemble ADD (HL)`() = test(0x86, "ADD (HL)")

    @Test
    fun `can disassemble ADD A`() = test(0x87, "ADD A")

    @Test
    fun `can disassemble ADC B`() = test(0x88, "ADC B")

    @Test
    fun `can disassemble ADC C`() = test(0x89, "ADC C")

    @Test
    fun `can disassemble ADC D`() = test(0x8a, "ADC D")

    @Test
    fun `can disassemble ADC E`() = test(0x8b, "ADC E")

    @Test
    fun `can disassemble ADC H`() = test(0x8c, "ADC H")

    @Test
    fun `can disassemble ADC L`() = test(0x8d, "ADC L")

    @Test
    fun `can disassemble ADC (HL)`() = test(0x8e, "ADC (HL)")

    @Test
    fun `can disassemble ADC A`() = test(0x8f, "ADC A")

    @Test
    fun `can disassemble SUB B`() = test(0x90, "SUB B")

    @Test
    fun `can disassemble SUB C`() = test(0x91, "SUB C")

    @Test
    fun `can disassemble SUB D`() = test(0x92, "SUB D")

    @Test
    fun `can disassemble SUB E`() = test(0x93, "SUB E")

    @Test
    fun `can disassemble SUB H`() = test(0x94, "SUB H")

    @Test
    fun `can disassemble SUB L`() = test(0x95, "SUB L")

    @Test
    fun `can disassemble SUB (HL)`() = test(0x96, "SUB (HL)")

    @Test
    fun `can disassemble SUB A`() = test(0x97, "SUB A")

    @Test
    fun `can disassemble SBC B`() = test(0x98, "SBC B")

    @Test
    fun `can disassemble SBC C`() = test(0x99, "SBC C")

    @Test
    fun `can disassemble SBC D`() = test(0x9a, "SBC D")

    @Test
    fun `can disassemble SBC E`() = test(0x9b, "SBC E")

    @Test
    fun `can disassemble SBC H`() = test(0x9c, "SBC H")

    @Test
    fun `can disassemble SBC L`() = test(0x9d, "SBC L")

    @Test
    fun `can disassemble SBC (HL)`() = test(0x9e, "SBC (HL)")

    @Test
    fun `can disassemble SBC A`() = test(0x9f, "SBC A")

    @Test
    fun `can disassemble AND B`() = test(0xa0, "AND B")

    @Test
    fun `can disassemble AND C`() = test(0xa1, "AND C")

    @Test
    fun `can disassemble AND D`() = test(0xa2, "AND D")

    @Test
    fun `can disassemble AND E`() = test(0xa3, "AND E")

    @Test
    fun `can disassemble AND H`() = test(0xa4, "AND H")

    @Test
    fun `can disassemble AND L`() = test(0xa5, "AND L")

    @Test
    fun `can disassemble AND (HL)`() = test(0xa6, "AND (HL)")

    @Test
    fun `can disassemble AND A`() = test(0xa7, "AND A")

    @Test
    fun `can disassemble XOR B`() = test(0xa8, "XOR B")

    @Test
    fun `can disassemble XOR C`() = test(0xa9, "XOR C")

    @Test
    fun `can disassemble XOR D`() = test(0xaa, "XOR D")

    @Test
    fun `can disassemble XOR E`() = test(0xab, "XOR E")

    @Test
    fun `can disassemble XOR H`() = test(0xac, "XOR H")

    @Test
    fun `can disassemble XOR L`() = test(0xad, "XOR L")

    @Test
    fun `can disassemble XOR (HL)`() = test(0xae, "XOR (HL)")

    @Test
    fun `can disassemble XOR A`() = test(0xaf, "XOR A")

    @Test
    fun `can disassemble OR B`() = test(0xb0, "OR B")

    @Test
    fun `can disassemble OR C`() = test(0xb1, "OR C")

    @Test
    fun `can disassemble OR D`() = test(0xb2, "OR D")

    @Test
    fun `can disassemble OR E`() = test(0xb3, "OR E")

    @Test
    fun `can disassemble OR H`() = test(0xb4, "OR H")

    @Test
    fun `can disassemble OR L`() = test(0xb5, "OR L")

    @Test
    fun `can disassemble OR (HL)`() = test(0xb6, "OR (HL)")

    @Test
    fun `can disassemble OR A`() = test(0xb7, "OR A")

    @Test
    fun `can disassemble CP B`() = test(0xb8, "CP B")

    @Test
    fun `can disassemble CP C`() = test(0xb9, "CP C")

    @Test
    fun `can disassemble CP D`() = test(0xba, "CP D")

    @Test
    fun `can disassemble CP E`() = test(0xbb, "CP E")

    @Test
    fun `can disassemble CP H`() = test(0xbc, "CP H")

    @Test
    fun `can disassemble CP L`() = test(0xbd, "CP L")

    @Test
    fun `can disassemble CP (HL)`() = test(0xbe, "CP (HL)")

    @Test
    fun `can disassemble CP A`() = test(0xbf, "CP A")

    @Test
    fun `can disassemble RET NZ`() = test(0xc0, "RET NZ")

    @Test
    fun `can disassemble POP BC`() = test(0xc1, "POP BC")

    @Test
    fun `can disassemble JP NZ, nn`() = test(0xc2, "JP NZ,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble JP nn`() = test(0xc3, "JP 0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble CALL NZ, nn`() = test(0xc4, "CALL NZ,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble PUSH BC`() = test(0xc5, "PUSH BC")

    @Test
    fun `can disassemble ADD n`() = test(0xc6, "ADD 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x00`() = test(0xc7, "RST 0x0000")

    @Test
    fun `can disassemble RET Z`() = test(0xc8, "RET Z")

    @Test
    fun `can disassemble RET`() = test(0xc9, "RET")

    @Test
    fun `can disassemble JP Z, nn`() = test(0xca, "JP Z,0x1234", 0x34, 0x12)

//    fun `can disassemble 0xcb`() = test(0xcb, "")

    @Test
    fun `can disassemble CALL Z, nn`() = test(0xcc, "CALL Z,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble CALL nn`() = test(0xcd, "CALL 0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble ADC n`() = test(0xce, "ADC 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x08`() = test(0xcf, "RST 0x0008")

    @Test
    fun `can disassemble RET NC`() = test(0xd0, "RET NC")

    @Test
    fun `can disassemble POP DE`() = test(0xd1, "POP DE")

    @Test
    fun `can disassemble JP NC, nn`() = test(0xd2, "JP NC,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble 0xd3`() = test(0xd3, "?? D3h")

    @Test
    fun `can disassemble CALL NC, nn`() = test(0xd4, "CALL NC,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble PUSH DE`() = test(0xd5, "PUSH DE")

    @Test
    fun `can disassemble SUB n`() = test(0xd6, "SUB 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x10`() = test(0xd7, "RST 0x0010")

    @Test
    fun `can disassemble RET C`() = test(0xd8, "RET C")

    @Test
    fun `can disassemble RETI`() = test(0xd9, "RETI")

    @Test
    fun `can disassemble JP C, nn`() = test(0xda, "JP C,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble 0xdb`() = test(0xdb, "?? DBh")

    @Test
    fun `can disassemble CALL C, nn`() = test(0xdc, "CALL C,0x1234", 0x34, 0x12)

    @Test
    fun `can disassemble 0xdd`() = test(0xdd, "?? DDh")

    @Test
    fun `can disassemble SBC n`() = test(0xde, "SBC 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x18`() = test(0xdf, "RST 0x0018")

    @Test
    fun `can disassemble LDH (n), A`() = test(0xe0, "LDH (0x55),A", 0x55)

    @Test
    fun `can disassemble POP HL`() = test(0xe1, "POP HL")

    @Test
    fun `can disassemble LDH (C), A`() = test(0xe2, "LDH (C),A")

    @Test
    fun `can disassemble 0xe3`() = test(0xe3, "?? E3h")

    @Test
    fun `can disassemble 0xe4`() = test(0xe4, "?? E4h")

    @Test
    fun `can disassemble PUSH HL`() = test(0xe5, "PUSH HL")

    @Test
    fun `can disassemble AND n`() = test(0xe6, "AND 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x20`() = test(0xe7, "RST 0x0020")

    @Test
    fun `can disassemble ADD SP, e (positive operand)`() = test(0xe8, "ADD SP,0x55", 0x55)

    @Test
    fun `can disassemble ADD SP, e (negative operand)`() = test(0xe8, "ADD SP,-0x2b", 0xd5)

    @Test
    fun `can disassemble JP HL`() = test(0xe9, "JP HL")

    @Test
    fun `can disassemble LD (nn), A`() = test(0xea, "LD (0x1234),A", 0x34, 0x12)

    @Test
    fun `can disassemble 0xeb`() = test(0xeb, "?? EBh")

    @Test
    fun `can disassemble 0xec`() = test(0xec, "?? ECh")

    @Test
    fun `can disassemble 0xed`() = test(0xed, "?? EDh")

    @Test
    fun `can disassemble XOR n`() = test(0xee, "XOR 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x28`() = test(0xef, "RST 0x0028") {
        val helper = EmulatorHelper(it.program)
        helper.writeRegister("SP", 0xffff)
        helper.step(TaskMonitor.DUMMY)
        println(helper.readRegister("SP"))
        println(helper.readRegister("PC"))
    }

    @Test
    fun `can disassemble LDH A, (n)`() = test(0xf0, "LDH A,(0x55)", 0x55)

    @Test
    fun `can disassemble POP AF`() = test(0xf1, "POP AF")

    @Test
    fun `can disassemble LDH A, (C)`() = test(0xf2, "LDH A,(C)")

    @Test
    fun `can disassemble DI`() = test(0xf3, "DI")

    @Test
    fun `can disassemble 0xf4`() = test(0xf4, "?? F4h")

    @Test
    fun `can disassemble PUSH AF`() = test(0xf5, "PUSH AF")

    @Test
    fun `can disassemble OR n`() = test(0xf6, "OR 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x30`() = test(0xf7, "RST 0x0030")

    @Test
    fun `can disassemble LD HL, SP+e (positive operand)`() = test(0xf8, "LD HL,SP+0x55", 0x55)

    @Test
    fun `can disassemble LD HL, SP+e (negative operand)`() = test(0xf8, "LD HL,SP-0x2b", 0xd5)

    @Test
    fun `can disassemble LD SP, HL`() = test(0xf9, "LD SP,HL")

    @Test
    fun `can disassemble LD A, (nn)`() = test(0xfa, "LD A,(0x1234)", 0x34, 0x12)

    @Test
    fun `can disassemble EI`() = test(0xfb, "EI")

    @Test
    fun `can disassemble 0xfc`() = test(0xfc, "?? FCh")

    @Test
    fun `can disassemble 0xfd`() = test(0xfd, "?? FDh")

    @Test
    fun `can disassemble CP n`() = test(0xfe, "CP 0x55", 0x55)

    @Test
    fun `can disassemble RST 0x38`() = test(0xff, "RST 0x0038")

    private fun test(opcode: Int, expected: String, vararg args: Int, assertions: (codeUnit: CodeUnit) -> Unit = {}) {
        val codeUnit = disassemble(byteArrayOf(opcode.toByte(), *(args.map { it.toByte() }).toByteArray()))
        assertEquals(expected, codeUnit.toString())
        assertions(codeUnit)
    }

    private fun disassemble(bytes: ByteArray): CodeUnit {
        val consumer = object {}
        val program = ProgramDB("test", language, language.defaultCompilerSpec, consumer)

        val block = program.withTransaction { program.memory.loadBytes("rom", address(0x0000), bytes) }

        val disassembler = Disassembler.getDisassembler(program, TaskMonitor.DUMMY, null)
        return program.withTransaction {
            disassembler.disassemble(block.start, program.memory.loadedAndInitializedAddressSet)
            program.codeManager.getCodeUnitAt(block.start)
        }
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/GhidraApplication.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy

import ghidra.GhidraApplicationLayout
import ghidra.framework.Application
import ghidra.framework.HeadlessGhidraApplicationConfiguration
import org.junit.jupiter.api.extension.Extension

class GhidraApplication : Extension {
    init {
        initialize()
    }

    companion object {
        private var initialized = false

        fun initialize() = synchronized(this) {
            if (initialized) return
            val layout = GhidraApplicationLayout()
            val configuration = HeadlessGhidraApplicationConfiguration()
            Application.initializeApplication(layout, configuration)
            initialized = true
        }
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/IntegrationTest.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy

import generic.jar.ResourceFile
import ghidra.app.plugin.processors.sleigh.SleighLanguageProvider
import ghidra.program.model.address.Address
import ghidra.program.model.lang.Language
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.extension.ExtendWith
import java.io.File

@ExtendWith(GhidraApplication::class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
open class IntegrationTest {
    protected lateinit var language: Language

    @BeforeAll
    open fun beforeAll() {
        val defs = ResourceFile(File("data/languages/sm83.ldefs"))
        val provider = SleighLanguageProvider(defs)
        Assertions.assertFalse(provider.hadLoadFailure())
        val languageDescription = provider.languageDescriptions.single()

        Assertions.assertEquals("Sharp SM83", languageDescription.description)
        Assertions.assertEquals("SM83", languageDescription.processor.toString())

        language = provider.getLanguage(languageDescription.languageID)
    }

    protected fun address(offset: Long): Address = language.addressFactory.defaultAddressSpace.getAddress(offset)
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/MemoryExt.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy

import ghidra.program.model.address.Address
import ghidra.program.model.mem.Memory
import ghidra.program.model.mem.MemoryBlock
import ghidra.util.task.TaskMonitor

fun Memory.loadBytes(name: String, start: Address, bytes: ByteArray, overlay: Boolean = false): MemoryBlock =
    createInitializedBlock(name, start, bytes.inputStream(), bytes.size.toLong(), TaskMonitor.DUMMY, overlay)

```

`src/test/kotlin/fi/gekkio/ghidraboy/ProgramExt.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy

import ghidra.program.model.listing.Program

inline fun <T> Program.withTransaction(description: String = "", crossinline f: () -> T): T {
    var success = false
    val id = startTransaction(description)
    try {
        val result = f()
        success = true
        return result
    } finally {
        endTransaction(id, success)
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/decompiler/DecompilerTest.kt`:

```kt
package fi.gekkio.ghidraboy.decompiler

import fi.gekkio.ghidraboy.DataTypes.u16
import fi.gekkio.ghidraboy.DataTypes.u8
import fi.gekkio.ghidraboy.GameBoyKind
import fi.gekkio.ghidraboy.GameBoyUtils
import fi.gekkio.ghidraboy.IntegrationTest
import fi.gekkio.ghidraboy.withTransaction
import ghidra.app.decompiler.DecompInterface
import ghidra.app.plugin.assembler.Assemblers
import ghidra.app.util.importer.MessageLog
import ghidra.program.database.ProgramDB
import ghidra.program.model.address.Address
import ghidra.program.model.address.AddressSet
import ghidra.program.model.data.DataType
import ghidra.program.model.data.PointerDataType
import ghidra.program.model.lang.Register
import ghidra.program.model.listing.Function
import ghidra.program.model.listing.Instruction
import ghidra.program.model.listing.Parameter
import ghidra.program.model.listing.ParameterImpl
import ghidra.program.model.listing.Program
import ghidra.program.model.listing.ReturnParameterImpl
import ghidra.program.model.symbol.SourceType
import ghidra.util.task.TaskMonitor
import org.intellij.lang.annotations.Language
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class DecompilerTest : IntegrationTest() {
    private lateinit var program: Program
    private lateinit var decompiler: DecompInterface

    @Test
    fun `simple decompilation works`() {
        val f = assembleFunction(
            address(0x0000),
            """
            LD A, 0x55
            INC A
            LD (0x1234), A
            RET
            """.trimIndent()
        )
        assertDecompiled(
            f,
            """
            void FUN_0000(void)
            {
                DAT_1234 = 0x56;
                return;
            }
            """.trimIndent()
        )
    }

    @Test
    fun `Github issue 10`() {
        val f = assembleFunction(
            address(0x0000),
            """
            LD A, (0x1234)
            AND A
            JR NZ, 0x0009
            LD C, 0x6A
            LDH (C), A
            RETI
            """.trimIndent()
        )
        assertDecompiled(
            f,
            """
            void FUN_0000(void)
            {
                if (DAT_1234 == '\0') {
                    OCPS = 0;
                }
                IME(1);
                return;
            }
            """.trimIndent()
        )
    }

    @Test
    fun memcpy() {
        val f = assembleFunction(
            address(0x0000),
            """
  LD A, B
  OR C
  RET Z
  LD A, (DE)
  LD (HL+), A
  INC DE
  DEC BC
  JR 0x0000
            """.trimIndent(),
            name = "memcpy",
            params = listOf(
                parameter("dst", pointer(u8), register("HL")),
                parameter("src", pointer(u8), register("DE")),
                parameter("len", u16, register("BC")),
            )
        )
        assertDecompiled(
            f,
            """
            void memcpy(byte *dst,byte *src,word len)
            {
                for (; (byte)((byte)(len >> 8) | (byte)len) != 0; len = len - 1) {
                    *dst = *src;
                    src = src + 1;
                    dst = dst + 1;
                }
                return;
            }
            """.trimIndent()
        )
    }

    @Test
    fun memset() {
        val f = assembleFunction(
            address(0x0000),
            """
  LD D, A
  LD A, B
  OR C
  RET Z
  LD A, D
  LD (HL+), A
  DEC BC
  JR 0x0001
            """.trimIndent(),
            name = "memset",
            params = listOf(
                parameter("dst", pointer(u8), register("HL")),
                parameter("val", u8, register("A")),
                parameter("len", u16, register("BC")),
            )
        )
        assertDecompiled(
            f,
            """
            void memset(byte *dst,byte val,word len)
            {
                for (; (byte)((byte)(len >> 8) | (byte)len) != 0; len = len - 1) {
                    *dst = val;
                    dst = dst + 1;
                }
                return;
            }
            """.trimIndent()
        )
    }

    @Test
    fun `upper nibble popcount`() {
        val f = assembleFunction(
            address(0x0000),
            """
  LD D, A
  XOR A
  LD E, A
  SLA D
  ADC E
  SLA D
  ADC E
  SLA D
  ADC E
  SLA D
  ADC E
  RET
            """.trimIndent(),
            name = "popcnt4_upper",
            params = listOf(
                parameter("value", u8, register("A")),
            ),
            returnParam = returnParameter(u8, register("A"))
        )
        assertDecompiled(
            f,
            """
            byte popcnt4_upper(byte value)
            {
                return ((-((char)(value << 1) >> 7) - ((char)value >> 7)) - ((char)(value << 2) >> 7)) -
                    ((char)(value << 3) >> 7); 
            }
            """.trimIndent()
        )
    }

    @Test
    fun `read_joypad_state`() {
        val f = assembleFunction(
            address(0x0000),
            """
  LD A, 0x20
  LDH (0x00), A
  LDH A, (0x00)
  LDH A, (0x00)
  CPL
  AND 0x0F
  SWAP A
  LD B, A
  LD A, 0x10
  LDH (0x00), A
  LDH A, (0x00)
  LDH A, (0x00)
  LDH A, (0x00)
  LDH A, (0x00)
  LDH A, (0x00)
  LDH A, (0x00)
  CPL
  AND 0x0F
  OR B
  LD B, A
  LD A, 0x30
  LDH (0x00), A
  LD A, B
  RET
            """.trimIndent(),
            name = "read_joypad_state",
            returnParam = returnParameter(u8, register("A"))
        )
        assertDecompiled(
            f,
            """
            byte read_joypad_state(void)
            {
                byte bVar1;
                byte bVar2;
                P1 = 0x20;
                bVar1 = P1;
                P1 = 0x10;
                bVar2 = P1;
                P1 = 0x30;
                return ~bVar2 & 0xf | ~bVar1 << 4;
            }
            """.trimIndent()
        )
    }

    @Test
    fun `sla8_to_16`() {
        val f = assembleFunction(
            address(0x0000),
            """
  LD C, A
  XOR A
  SLA C
  RLA
  SLA C
  RLA
  SLA C
  RLA
  SLA C
  RLA
  LD B, A
  RET
            """.trimIndent(),
            name = "sla8_to_16",
            params = listOf(
                parameter("value", u8, register("A"))
            ),
            returnParam = returnParameter(u16, register("BC"))
        )
        assertDecompiled(
            f,
            """
            word sla8_to_16(byte value)
            {
                return CONCAT11((((value >> 7) << 1 | (byte)(value << 1) >> 7) << 1 | (byte)(value << 2) >> 7) <<
                    1 | (byte)(value << 3) >> 7,value << 4);
            }
            """.trimIndent()
        )
    }

    @Test
    fun `DAA decompilation`() {
        val f = assembleFunction(
            address(0x0000),
            """
  LD A, 0x01
  ADD C
  DAA
  LD C, A
  RET Z
  INC C
  RET
            """.trimIndent(),
            name = "daa",
            params = listOf(
                parameter("value", u8, register("C"))
            ),
            returnParam = returnParameter(u8, register("C"))
        )
        assertDecompiled(
            f,
            """
            byte daa(byte value)
            {
                char cVar1;
                byte bVar2;
                cVar1 = daaOperand(value + 1,0xfe < value,((value & 0xf) + 1 & 0x10) != 0,0);
                bVar2 = value + 1 + cVar1;
                if (bVar2 == 0) {
                    return bVar2;
                }
                return bVar2 + 1;
            }
            """.trimIndent()
        )
    }

    @BeforeAll
    override fun beforeAll() {
        super.beforeAll()
        decompiler = DecompInterface()
    }

    @BeforeEach
    fun beforeEach() {
        val consumer = object {}
        program = ProgramDB("test", language, language.defaultCompilerSpec, consumer)
        program.withTransaction {
            program.memory.createInitializedBlock("rom", address(0x0000), 0x8000, 0, TaskMonitor.DUMMY, false)
            GameBoyUtils.addHardwareBlocks(program, GameBoyKind.CGB, MessageLog())
            GameBoyUtils.populateHardwareBlocks(program, GameBoyKind.CGB)
        }
        assertTrue(decompiler.openProgram(program)) { "Failed to initialize decompiler" }
    }

    @AfterEach
    fun afterEach() {
        decompiler.closeProgram()
    }

    @AfterAll
    fun afterAll() {
        decompiler.dispose()
    }

    private fun assembleFunction(
        address: Address,
        code: String,
        name: String? = null,
        params: List<Parameter>? = null,
        returnParam: Parameter? = null
    ): Function = program.withTransaction {
        val instructions: Iterable<Instruction> = Assemblers.getAssembler(program).assemble(address, *code.lines().toTypedArray())
        val addressSet = AddressSet()
        for (instruction in instructions) {
            addressSet.add(instruction.minAddress, instruction.maxAddress)
        }
        program.functionManager.createFunction(name, address, addressSet, SourceType.USER_DEFINED).apply {
            setCustomVariableStorage(true)
            val callingConvention = "default"
            val force = true
            if (params != null) {
                updateFunction(
                    callingConvention,
                    returnParam,
                    params,
                    Function.FunctionUpdateType.CUSTOM_STORAGE,
                    force,
                    SourceType.USER_DEFINED
                )
            } else {
                updateFunction(
                    callingConvention,
                    returnParam,
                    Function.FunctionUpdateType.CUSTOM_STORAGE,
                    force,
                    SourceType.USER_DEFINED
                )
            }
        }
    }

    private fun decompile(function: Function) =
        decompiler.decompileFunction(function, 10, TaskMonitor.DUMMY).also {
            assertTrue(it.decompileCompleted()) { "Decompilation did not complete" }
        }.decompiledFunction.c

    private fun formatCode(code: String) = code.lineSequence()
        .map { it.trim() }
        .filter { it.isNotEmpty() }
        .joinToString(separator = "\n")
    private fun assertDecompiled(function: Function, @Language("C") code: String) =
        assertEquals(formatCode(code), formatCode(decompile(function)))

    private fun parameter(name: String, type: DataType, register: Register) =
        ParameterImpl(name, type, register, program)
    private fun returnParameter(type: DataType, register: Register) =
        ReturnParameterImpl(type, register, program)
    private fun pointer(type: DataType) = PointerDataType(type)
    private fun register(name: String) = program.getRegister(name)
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/emu/ControlFlowInstructionTest.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy.emu

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtensionContext
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.Arguments
import org.junit.jupiter.params.provider.ArgumentsProvider
import org.junit.jupiter.params.provider.ArgumentsSource
import org.junit.jupiter.params.provider.EnumSource
import java.util.stream.Stream

class ControlFlowInstructionTest : EmuTest() {
    @Test
    fun `JP nn`() {
        emulator.write(0x0000u, 0xc3u, 0x34u, 0x12u)
        emulator.step()
        emulator.assertPC(0x1234u)
    }

    @Test
    fun `JP HL`() {
        emulator.writeHL(0x1234u)
        emulator.write(0x0000u, 0xe9u)
        emulator.step()
        emulator.assertPC(0x1234u)
    }

    @ParameterizedTest
    @ArgumentsSource(Conditions::class)
    fun `JP cc, nn`(cc: Condition, taken: Boolean) {
        emulator.writeF((if (taken) cc else cc.flip()).testFlags)
        emulator.write(0x000u, cc.jpOpcode, 0x34u, 0x12u)
        emulator.step()
        if (taken) {
            emulator.assertPC(0x1234u)
        } else {
            emulator.assertPC(0x0003u)
        }
    }

    @Test
    fun `JR e (positive)`() {
        emulator.write(0x0000u, 0x18u, 0x7fu)
        emulator.step()
        emulator.assertPC(0x0081u)
    }

    @Test
    fun `JR e (negative)`() {
        emulator.write(0x0000u, 0x18u, 0x80u)
        emulator.step()
        emulator.assertPC(0xff82u)
    }

    @ParameterizedTest
    @ArgumentsSource(Conditions::class)
    fun `JR cc, e (positive)`(cc: Condition, taken: Boolean) {
        emulator.writeF((if (taken) cc else cc.flip()).testFlags)
        emulator.write(0x000u, cc.jrOpcode, 0x7fu)
        emulator.step()
        if (taken) {
            emulator.assertPC(0x0081u)
        } else {
            emulator.assertPC(0x0002u)
        }
    }

    @ParameterizedTest
    @ArgumentsSource(Conditions::class)
    fun `JR cc, e (negative)`(cc: Condition, taken: Boolean) {
        emulator.writeF((if (taken) cc else cc.flip()).testFlags)
        emulator.write(0x000u, cc.jrOpcode, 0x80u)
        emulator.step()
        if (taken) {
            emulator.assertPC(0xff82u)
        } else {
            emulator.assertPC(0x0002u)
        }
    }

    @Test
    fun `CALL nn`() {
        emulator.writePC(0xabcdu)
        emulator.writeSP(0xbfffu)
        emulator.write(emulator.readSP(), 0x00u, 0x00u)
        emulator.write(0xabcdu, 0xcdu, 0x34u, 0x12u)
        emulator.step()
        emulator.assertPC(0x1234u)
        emulator.assertSP(0xbffdu)
        assertEquals((0xd0u).toUByte(), emulator.read(0xbffdu))
        assertEquals((0xabu).toUByte(), emulator.read(0xbffeu))
    }

    @ParameterizedTest
    @ArgumentsSource(Conditions::class)
    fun `CALL cc, nn`(cc: Condition, taken: Boolean) {
        emulator.writePC(0xabcdu)
        emulator.writeSP(0xbfffu)
        emulator.writeF((if (taken) cc else cc.flip()).testFlags)
        emulator.write(emulator.readSP(), 0x00u, 0x00u)
        emulator.write(0xabcdu, cc.callOpcode, 0x34u, 0x12u)
        emulator.step()
        if (taken) {
            emulator.assertPC(0x1234u)
            emulator.assertSP(0xbffdu)
            assertEquals((0xd0u).toUByte(), emulator.read(0xbffdu))
            assertEquals((0xabu).toUByte(), emulator.read(0xbffeu))
        } else {
            emulator.assertPC(0xabd0u)
            emulator.assertSP(0xbfffu)
        }
    }

    @Test
    fun `RET`() {
        emulator.writePC(0x1234u)
        emulator.writeSP(0xbffdu)
        emulator.write(emulator.readSP(), 0xcdu, 0xabu)
        emulator.write(0x1234u, 0xc9u)
        emulator.step()
        emulator.assertPC(0xabcdu)
        emulator.assertSP(0xbfffu)
    }

    @ParameterizedTest
    @ArgumentsSource(Conditions::class)
    fun `RET cc, nn`(cc: Condition, taken: Boolean) {
        emulator.writePC(0x1234u)
        emulator.writeSP(0xbffdu)
        emulator.writeF((if (taken) cc else cc.flip()).testFlags)
        emulator.write(emulator.readSP(), 0xcdu, 0xabu)
        emulator.write(0x1234u, cc.retOpcode)
        emulator.step()
        if (taken) {
            emulator.assertPC(0xabcdu)
            emulator.assertSP(0xbfffu)
        } else {
            emulator.assertPC(0x1235u)
            emulator.assertSP(0xbffdu)
        }
    }

    @Test
    fun `RETI`() {
        val ignore = IgnorePCode()
        emulator.registerCallOtherCallback("IME", ignore)
        emulator.writePC(0x1234u)
        emulator.writeSP(0xbffdu)
        emulator.write(emulator.readSP(), 0xcdu, 0xabu)
        emulator.write(0x1234u, 0xd9u)
        emulator.step()
        assertTrue(ignore.triggered)
        emulator.assertPC(0xabcdu)
        emulator.assertSP(0xbfffu)
    }

    @ParameterizedTest
    @EnumSource
    fun `RST`(rst: Rst) {
        emulator.writePC(0xabcdu)
        emulator.writeSP(0xbfffu)
        emulator.write(emulator.readSP(), 0x00u, 0x00u)
        emulator.write(0xabcdu, rst.opcode)
        emulator.step()
        emulator.assertPC(rst.target)
        emulator.assertSP(0xbffdu)
        assertEquals((0xceu).toUByte(), emulator.read(0xbffdu))
        assertEquals((0xabu).toUByte(), emulator.read(0xbffeu))
    }
}

private class Conditions : ArgumentsProvider {
    override fun provideArguments(context: ExtensionContext): Stream<out Arguments> =
        Condition.values().flatMap { listOf(Arguments.of(it, false), Arguments.of(it, true)) }.stream()
}

enum class Rst(val opcode: UByte, val target: UShort) {
    Rst00(0xc7u, 0x0000u),
    Rst08(0xcfu, 0x0008u),
    Rst10(0xd7u, 0x0010u),
    Rst18(0xdfu, 0x0018u),
    Rst20(0xe7u, 0x0020u),
    Rst28(0xefu, 0x0028u),
    Rst30(0xf7u, 0x0030u),
    Rst38(0xffu, 0x0038u)
}

enum class Condition(
    val testFlags: UByte,
    val jrOpcode: UByte,
    val jpOpcode: UByte,
    val callOpcode: UByte,
    val retOpcode: UByte
) {
    NC(0b1110_0000u, 0x30u, 0xd2u, 0xd4u, 0xd0u),
    C(0b0001_0000u, 0x38u, 0xdau, 0xdcu, 0xd8u),
    NZ(0b0111_0000u, 0x20u, 0xc2u, 0xc4u, 0xc0u),
    Z(0b1000_0000u, 0x28u, 0xcau, 0xccu, 0xc8u);

    fun flip(): Condition = when (this) {
        NC -> C
        C -> NC
        NZ -> Z
        Z -> NZ
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/emu/EmuTest.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy.emu

import fi.gekkio.ghidraboy.IntegrationTest
import fi.gekkio.ghidraboy.withTransaction
import ghidra.app.emulator.EmulatorHelper
import ghidra.program.database.ProgramDB
import ghidra.program.model.listing.Program
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach

open class EmuTest : IntegrationTest() {
    protected lateinit var program: Program
    protected lateinit var emulator: EmulatorHelper

    @BeforeEach
    fun beforeEach() {
        val consumer = object {}
        program = ProgramDB("test", language, language.defaultCompilerSpec, consumer)
        program.withTransaction {
            program.memory.createUninitializedBlock("rom", address(0x0000), 0x10000, false)
        }
        emulator = EmulatorHelper(program)
        emulator.memoryFaultHandler = FailOnMemoryFault(emulator)
    }

    @AfterEach
    fun afterEach() {
        emulator.dispose()
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/emu/EmulatorExt.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy.emu

import ghidra.app.emulator.EmulatorHelper
import ghidra.util.task.TaskMonitor
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.fail

fun EmulatorHelper.step() {
    val success = step(TaskMonitor.DUMMY)
    if (!success) {
        fail<Unit>(lastError)
    }
}

fun EmulatorHelper.write(address: UShort, vararg bytes: UByte) = writeMemory(
    emulator.language.addressFactory.defaultAddressSpace.getAddress(address.toLong()),
    bytes.map { it.toByte() }.toByteArray()
)

fun EmulatorHelper.read(address: UShort): UByte = readMemoryByte(
    emulator.language.addressFactory.defaultAddressSpace.getAddress(address.toLong())
).toUByte()

fun EmulatorHelper.read(address: UShort, length: Int): UByteArray = readMemory(
    emulator.language.addressFactory.defaultAddressSpace.getAddress(address.toLong()),
    length
).map { it.toUByte() }.toUByteArray()

fun EmulatorHelper.assertA(a: UByte) = assertEquals(a, readA())
fun EmulatorHelper.assertF(f: UByte) = assertEquals(f, readF())
fun EmulatorHelper.assertB(b: UByte) = assertEquals(b, readB())
fun EmulatorHelper.assertC(c: UByte) = assertEquals(c, readC())
fun EmulatorHelper.assertD(d: UByte) = assertEquals(d, readD())
fun EmulatorHelper.assertE(e: UByte) = assertEquals(e, readE())
fun EmulatorHelper.assertH(h: UByte) = assertEquals(h, readH())
fun EmulatorHelper.assertL(l: UByte) = assertEquals(l, readL())
fun EmulatorHelper.assertAF(af: UShort) = assertEquals(af, readAF())
fun EmulatorHelper.assertBC(bc: UShort) = assertEquals(bc, readBC())
fun EmulatorHelper.assertDE(de: UShort) = assertEquals(de, readDE())
fun EmulatorHelper.assertHL(hl: UShort) = assertEquals(hl, readHL())
fun EmulatorHelper.assertPC(pc: UShort) = assertEquals(pc, readPC())
fun EmulatorHelper.assertSP(sp: UShort) = assertEquals(sp, readSP())

fun EmulatorHelper.readA(): UByte = this.readRegister("A").toInt().toUByte()
fun EmulatorHelper.readF(): UByte = this.readRegister("F").toInt().toUByte()
fun EmulatorHelper.readB(): UByte = this.readRegister("B").toInt().toUByte()
fun EmulatorHelper.readC(): UByte = this.readRegister("C").toInt().toUByte()
fun EmulatorHelper.readD(): UByte = this.readRegister("D").toInt().toUByte()
fun EmulatorHelper.readE(): UByte = this.readRegister("E").toInt().toUByte()
fun EmulatorHelper.readH(): UByte = this.readRegister("H").toInt().toUByte()
fun EmulatorHelper.readL(): UByte = this.readRegister("L").toInt().toUByte()
fun EmulatorHelper.readAF(): UShort = this.readRegister("AF").toInt().toUShort()
fun EmulatorHelper.readBC(): UShort = this.readRegister("BC").toInt().toUShort()
fun EmulatorHelper.readDE(): UShort = this.readRegister("DE").toInt().toUShort()
fun EmulatorHelper.readHL(): UShort = this.readRegister("HL").toInt().toUShort()
fun EmulatorHelper.readPC(): UShort = this.readRegister("PC").toInt().toUShort()
fun EmulatorHelper.readSP(): UShort = this.readRegister("SP").toInt().toUShort()

fun EmulatorHelper.writeA(a: UByte) = this.writeRegister("A", a.toLong())
fun EmulatorHelper.writeF(f: UByte) = this.writeRegister("F", f.toLong())
fun EmulatorHelper.writeB(b: UByte) = this.writeRegister("B", b.toLong())
fun EmulatorHelper.writeC(c: UByte) = this.writeRegister("C", c.toLong())
fun EmulatorHelper.writeD(d: UByte) = this.writeRegister("D", d.toLong())
fun EmulatorHelper.writeE(e: UByte) = this.writeRegister("E", e.toLong())
fun EmulatorHelper.writeH(h: UByte) = this.writeRegister("H", h.toLong())
fun EmulatorHelper.writeL(l: UByte) = this.writeRegister("L", l.toLong())
fun EmulatorHelper.writeAF(af: UShort) = this.writeRegister("AF", af.toLong())
fun EmulatorHelper.writeBC(bc: UShort) = this.writeRegister("BC", bc.toLong())
fun EmulatorHelper.writeDE(de: UShort) = this.writeRegister("DE", de.toLong())
fun EmulatorHelper.writeHL(hl: UShort) = this.writeRegister("HL", hl.toLong())
fun EmulatorHelper.writePC(pc: UShort) = this.writeRegister("PC", pc.toLong())
fun EmulatorHelper.writeSP(sp: UShort) = this.writeRegister("SP", sp.toLong())

```

`src/test/kotlin/fi/gekkio/ghidraboy/emu/FailOnMemoryFault.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy.emu

import ghidra.app.emulator.EmulatorHelper
import ghidra.pcode.emulate.EmulateExecutionState
import ghidra.pcode.memstate.MemoryFaultHandler
import ghidra.program.model.address.Address
import org.junit.jupiter.api.Assertions

class FailOnMemoryFault(private val emulator: EmulatorHelper) : MemoryFaultHandler {
    override fun uninitializedRead(address: Address, size: Int, buf: ByteArray, bufOffset: Int): Boolean {
        if (emulator.emulateExecutionState == EmulateExecutionState.INSTRUCTION_DECODE) {
            return false
        }
        val pc = emulator.executionAddress
        emulator.program.getRegister(address, size)?.let {
            Assertions.fail<Unit>("Uninitialized register read at $pc: $it")
        }
        Assertions.fail<Unit>("Uninitialized memory read at $pc: ${address.toString(true)}:$size")
        return true
    }

    override fun unknownAddress(address: Address, write: Boolean): Boolean {
        val pc = emulator.executionAddress
        if (write) {
            Assertions.fail<Unit>("Unknown address written at $pc: $address")
        } else {
            Assertions.fail<Unit>("Unknown address read at $pc: $address")
        }
        return false
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/emu/IgnorePCode.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy.emu

import ghidra.pcode.emulate.BreakCallBack
import ghidra.pcode.pcoderaw.PcodeOpRaw

class IgnorePCode : BreakCallBack() {
    var triggered: Boolean = false
        private set

    override fun pcodeCallback(op: PcodeOpRaw): Boolean {
        triggered = true
        return true
    }
}

```

`src/test/kotlin/fi/gekkio/ghidraboy/emu/MiscInstructionTest.kt`:

```kt
// Copyright 2019-2020 Joonas Javanainen <joonas.javanainen@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package fi.gekkio.ghidraboy.emu

import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

class MiscInstructionTest : EmuTest() {
    @Test
    fun `NOP`() {
        emulator.write(0x0000u, 0x00u)
        emulator.step()
        emulator.assertPC(0x0001u)
    }

    @Test
    fun `DI`() {
        val ignore = IgnorePCode()
        emulator.registerCallOtherCallback("IME", ignore)
        emulator.write(0x0000u, 0xf3u)
        emulator.step()
        assertTrue(ignore.triggered)
        emulator.assertPC(0x0001u)
    }

    @Test
    fun `EI`() {
        val ignore = IgnorePCode()
        emulator.registerCallOtherCallback("IME", ignore)
        emulator.write(0x0000u, 0xfbu)
        emulator.step()
        assertTrue(ignore.triggered)
        emulator.assertPC(0x0001u)
    }

    @Test
    fun `HALT`() {
        val ignore = IgnorePCode()
        emulator.registerCallOtherCallback("halt", ignore)
        emulator.write(0x0000u, 0x76u)
        emulator.step()
        assertTrue(ignore.triggered)
        emulator.assertPC(0x0001u)
    }

    @Test
    fun `STOP`() {
        val ignore = IgnorePCode()
        emulator.registerCallOtherCallback("stop", ignore)
        emulator.write(0x0000u, 0x10u)
        emulator.step()
        assertTrue(ignore.triggered)
        emulator.assertPC(0x0001u)
    }

    @Test
    fun `DAA`() {
        emulator.registerCallOtherCallback("daaOperand", IgnorePCode())
        emulator.writeF(0b0000_0000u)
        emulator.writeA(0x00u)
        emulator.write(0x0000u, 0x27u)
        emulator.step()
        emulator.assertPC(0x0001u)
    }

    @Test
    fun `CCF when C=1`() {
        emulator.writeF(0b1111_0000u)
        emulator.write(0x0000u, 0x3fu)
        emulator.step()
        emulator.assertPC(0x0001u)
        emulator.assertF(0b1000_0000u)
    }

    @Test
    fun `CCF when C=0`() {
        emulator.writeF(0b1110_0000u)
        emulator.write(0x0000u, 0x3fu)
        emulator.step()
        emulator.assertPC(0x0001u)
        emulator.assertF(0b1001_0000u)
    }

    @Test
    fun `SCF`() {
        emulator.writeF(0b1110_0000u)
        emulator.write(0x0000u, 0x37u)
        emulator.step()
        emulator.assertPC(0x0001u)
        emulator.assertF(0b1001_0000u)
    }

    @Test
    fun `CPL`() {
        emulator.writeF(0b1001_0000u)
        emulator.writeA(0x55u)
        emulator.write(0x0000u, 0x2fu)
        emulator.step()
        emulator.assertPC(0x0001u)
        emulator.assertF(0b1111_0000u)
        emulator.assertA(0xaau)
    }
}

```