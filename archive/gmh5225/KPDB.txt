Project Path: arc_gmh5225_KPDB_oyrwjsmv

Source Tree:

```txt
arc_gmh5225_KPDB_oyrwjsmv
├── DriverEntry.c
├── DriverEntry.h
├── KPDB.inf
├── KPDB.sln
├── KPDB.vcxproj
├── KPDB.vcxproj.filters
├── README.md
├── kpdb.c
├── kpdb.h
├── ntutils.c
└── ntutils.h

```

`DriverEntry.c`:

```c
#include "DriverEntry.h"

LPCSTR WantedSymbolList[] = { 
	"PspLoadImageNotifyRoutine", 
	"PspCreateProcessNotifyRoutine", 
	"PspCreateThreadNotifyRoutine", 
	"CallbackListHead",
	"EtwThreatIntProvRegHandle", 
	"KiServiceTable", 
	"KiTimerDispatch" };

SYMBOL_DATA SymbolsData[MAX_SYMBOL_DATA + 1];

void KpdbDemoRoutine() {
	for (int i = 0; i < (sizeof(WantedSymbolList) / sizeof(LPCSTR)); i++) {
		SymbolsData[i].SymbolName = WantedSymbolList[i];
	}

	SIZE_T FileSize = 0;
	PVOID pdbfile = NULL;
	LPCWSTR pdbfilepath = L"\\??\\C:\\Users\\ZEROBI~1\\AppData\\Local\\Temp\\ida\\ntkrnlmp.pdb\\87A327C6C356B7E2BAC1D75E779701651\\ntkrnlmp.pdb"; // replace this with the path of the PDB (keep the "\\??\\")
	// read PDB file and parse
	DbgPrintEx(0, 0, "[KPDB] KpdbDemoRoutine - Reading NT symbols...");
	{
		// get file size
		if (!NT_SUCCESS(UtilGetFileSize(pdbfilepath, NULL, &FileSize, NULL))) {
			DbgPrintEx(0, 0, "[KPDB] KpdbDemoRoutine - UtilGetFileSize failed!");
			return;
		}

		// allocate memory for file
		pdbfile = ExAllocatePool(PagedPool, FileSize);

		// read file
		if (!NT_SUCCESS(UtilReadFile(pdbfilepath, pdbfile)))
		{
			ExFreePool(pdbfile);
			DbgPrintEx(0, 0, "[KPDB] KpdbDemoRoutine - UtilReadFile failed!");
			return;
		}

		// run the parse
		if (!KpdbGetPDBSymbolOffset(pdbfile, SymbolsData)) {
			// free pool
			ExFreePool(pdbfile);
			DbgPrintEx(0, 0, "[KPDB] KpdbDemoRoutine - KpdbGetPDBSymbolOffset failed!");
			return;
		}

		// free pool
		ExFreePool(pdbfile);
	}

	KpdbConvertSecOffsetToRVA(UtilGetKernelBase(), SymbolsData); // kernel base = ntoskrnl module base

	DWORD Iterator = 0;
	while (SymbolsData[Iterator].SectionOffset) {
		DbgPrintEx(0, 0, "[KPDB] Symbol %s = 0x%p", SymbolsData[Iterator].SymbolName, SymbolsData[Iterator].SymbolRVA + UtilGetKernelBase());
		Iterator++;
	}
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) {
	KpdbDemoRoutine();

	return STATUS_UNSUCCESSFUL;
}
```

`DriverEntry.h`:

```h
#pragma once
#include "kpdb.h"
#include "ntutils.h"

#define MAX_SYMBOL_DATA 32

void KpdbDemoRoutine();
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath);

```

`KPDB.inf`:

```inf
;
; KPDB.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System ; TODO: specify appropriate Class
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318} ; TODO: specify appropriate ClassGuid
Provider=%ManufacturerName%
CatalogFile=KPDB.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 12
KPDB_Device_CoInstaller_CopyFiles = 11

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
KPDB.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%KPDB.DeviceDesc%=KPDB_Device, Root\KPDB ; TODO: edit hw-id

[KPDB_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
KPDB.sys

;-------------- Service installation
[KPDB_Device.NT.Services]
AddService = KPDB,%SPSVCINST_ASSOCSERVICE%, KPDB_Service_Inst

; -------------- KPDB driver install sections
[KPDB_Service_Inst]
DisplayName    = %KPDB.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\KPDB.sys

;
;--- KPDB_Device Coinstaller installation ------
;

[KPDB_Device.NT.CoInstallers]
AddReg=KPDB_Device_CoInstaller_AddReg
CopyFiles=KPDB_Device_CoInstaller_CopyFiles

[KPDB_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[KPDB_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[KPDB_Device.NT.Wdf]
KmdfService =  KPDB, KPDB_wdfsect
[KPDB_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName = "KPDB Installation Disk"
KPDB.DeviceDesc = "KPDB Device"
KPDB.SVCDESC = "KPDB Service"

```

`KPDB.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32929.385
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KPDB", "KPDB.vcxproj", "{74239EE4-EC4B-41FC-8978-09D8001CE985}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Debug|ARM64.Build.0 = Debug|ARM64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Debug|x64.ActiveCfg = Debug|x64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Debug|x64.Build.0 = Debug|x64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Debug|x64.Deploy.0 = Debug|x64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Release|ARM64.ActiveCfg = Release|ARM64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Release|ARM64.Build.0 = Release|ARM64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Release|ARM64.Deploy.0 = Release|ARM64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Release|x64.ActiveCfg = Release|x64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Release|x64.Build.0 = Release|x64
		{74239EE4-EC4B-41FC-8978-09D8001CE985}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {AC8B7868-0644-4C2B-A380-82768E40E3D0}
	EndGlobalSection
EndGlobal

```

`KPDB.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{74239EE4-EC4B-41FC-8978-09D8001CE985}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>KPDB</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <ClCompile>
      <SDLCheck>false</SDLCheck>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="KPDB.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DriverEntry.c" />
    <ClCompile Include="kpdb.c" />
    <ClCompile Include="ntutils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DriverEntry.h" />
    <ClInclude Include="kpdb.h" />
    <ClInclude Include="ntutils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KPDB.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="KPDB.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kpdb.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverEntry.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ntutils.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kpdb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverEntry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntutils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# KPDB - Windows kernel-mode PDB parser
KPDB is a Windows kernel-mode compatible PDB parser, it can help you parses PDB symbols in the kernel-mode environment. The purpose of this project is to put an end to version-specific hardcoded offsets and signature/instruction scanning so that it will bring more stability to the program. At the moment, KPDB only supports parsing symbols, but I will add type parsing capability on the next release. KPDB is a modified and ported-to-pure-c version of [namazso's lightweight PDB parser](https://gist.github.com/namazso/4bfafdb0233f72f5d13bfee825c203f7), so credit to him.

# Usage
If you want to see what KPDB can do, try cloning the repository, build the project as Release, load the driver, and see the result in DebugView.
![image](https://user-images.githubusercontent.com/41237415/209555217-0bcec534-8eb4-4aa7-960a-34cf30475f88.png)

```

`kpdb.c`:

```c
#include "kpdb.h"

const char kMagic[] = {
	0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x2F,
	0x43, 0x2B, 0x2B, 0x20, 0x4D, 0x53, 0x46, 0x20, 0x37, 0x2E, 0x30, 0x30,
	0x0D, 0x0A, 0x1A, 0x44, 0x53, 0x00, 0x00, 0x00
};

BOOL KpdbIsPDBMagicValid(SuperBlock* super) {
	return 0 == memcmp(super->FileMagic, kMagic, sizeof(kMagic));
}

PVOID KpdbGetPDBStreamDirectory(PVOID base) {
	SuperBlock* super = (SuperBlock*)base;
	DWORD size = super->NumDirectoryBytes;
	DWORD block_size = super->BlockSize;
	DWORD block_count = (size + block_size - 1) / block_size;
	PDWORD block_id_array = (PDWORD)((BYTE*)base + block_size * super->BlockMapAddr);

	PVOID stream_dir = ExAllocatePool(PagedPool, block_count * block_size);

	PCHAR end_of_stream = (PCHAR)stream_dir;
	for (int i = 0; i < block_count; ++i) {
		PCHAR block = (PCHAR)base + block_size * block_id_array[i];
		memcpy(end_of_stream, block, block_size);
		end_of_stream += block_size;
	}

	return stream_dir;
}

StreamData* KpdbGetPDBStreams(PVOID base, PDWORD streams_count) {
	SuperBlock* super = (SuperBlock*)base;
	if (!KpdbIsPDBMagicValid(super)) return NULL;
	DWORD block_size = super->BlockSize;

	PVOID stream_dir = KpdbGetPDBStreamDirectory(base);
	PDWORD ui32_iter = (PDWORD)stream_dir;
	DWORD stream_num = *ui32_iter++;
	PDWORD stream_array = ui32_iter;
	ui32_iter += stream_num;

	//printf("stream_num = %llu\n", stream_num);

	StreamData* streams = (StreamData*)ExAllocatePool(PagedPool, stream_num * sizeof(StreamData));
	*streams_count = 0;

	for (int i = 0; i < stream_num; ++i) {
		PCHAR current_stream = NULL;
		DWORD current_stream_size = stream_array[i];
		DWORD current_stream_block_count = (current_stream_size + block_size - 1) / block_size;

		current_stream = (PCHAR)ExAllocatePool(PagedPool, current_stream_block_count * block_size);

		PCHAR end_of_stream = current_stream;
		for (int j = 0; j < current_stream_block_count; ++j) {
			DWORD block_id = *ui32_iter++;
			PCHAR block = (PCHAR)base + (block_size * block_id);

			memcpy(end_of_stream, block, block_size);
			end_of_stream += block_size;
		}

		StreamData current_stream_data = { 0 };
		current_stream_data.StreamPointer = current_stream;
		current_stream_data.StreamSize = current_stream_size;
		streams[*streams_count] = current_stream_data;
		(*streams_count)++;
	}

	ExFreePool(stream_dir);

	return streams;
}

BOOL KpdbGetPDBSymbolOffset(PVOID pdbfile, PSYMBOL_DATA SymbolDataList) {
	PCHAR symbols = NULL;
	PCHAR types = NULL;
	StreamData* streams = NULL;
	DWORD streams_count = 0;
	SIZE_T symbolsstreamsize = 0;
	DWORD SymbolsCollected = 0;

	streams = KpdbGetPDBStreams(pdbfile, &streams_count);
	if (!streams) return FALSE;

	types = streams[2].StreamPointer;
	symbols = streams[(((DBIHeader*)streams[3].StreamPointer)->SymRecordStream)].StreamPointer;
	symbolsstreamsize = streams[(((DBIHeader*)streams[3].StreamPointer)->SymRecordStream)].StreamSize;

	{
		PCHAR it = symbols;
		const PCHAR end = (PCHAR)((SIZE_T)it + symbolsstreamsize);
		while (it != end)
		{
			const PUBSYM32* curr = (PUBSYM32*)it;
			if (curr->rectyp == S_PUB32)
			{
				DWORD iteration = 0;
				while (SymbolDataList[iteration].SymbolName) {
					if (strcmp(curr->name, SymbolDataList[iteration].SymbolName) == 0) {
						DbgPrintEx(0, 0, "S_PUB32: [%04X:%08X], Flags : %08X, %s\n", curr->seg, curr->off, curr->pubsymflags, curr->name);

						SymbolDataList[iteration].SectionNumber = curr->seg;
						SymbolDataList[iteration].SectionOffset = curr->off;
						//SymbolDataList[iteration].SymbolNameHash = KpdbCalcHashA(curr->name, KpdbStrlen(curr->name));
						SymbolsCollected++;
						break;
					}
					iteration++;
				}
			}
			it += curr->reclen + 2;
		}
	}

	// free all of the streams and free the stream data
	for (int i = 0; i < streams_count; i++) {
		ExFreePool(streams[i].StreamPointer);
	}

	ExFreePool(streams);

	return TRUE;
}

void KpdbConvertSecOffsetToRVA(DWORD64 ModuleBase, PSYMBOL_DATA SymbolDataList) {
	PIMAGE_NT_HEADERS NTHeader = (PIMAGE_NT_HEADERS)(ModuleBase + ((PIMAGE_DOS_HEADER)ModuleBase)->e_lfanew);
	PIMAGE_SECTION_HEADER SectionHeaderBaseAddr = (PIMAGE_SECTION_HEADER)((DWORD64)NTHeader + sizeof(IMAGE_NT_HEADERS));

	DWORD Iterator = 0;
	while (SymbolDataList[Iterator].SectionOffset) {
		if (SymbolDataList[Iterator].SectionNumber) SymbolDataList[Iterator].SymbolRVA = SymbolDataList[Iterator].SectionOffset + SectionHeaderBaseAddr[SymbolDataList[Iterator].SectionNumber - 1].VirtualAddress;
		Iterator++;
	}
}
```

`kpdb.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <minwindef.h>
#include <intrin.h>
#include <ntddndis.h>
#include <strsafe.h>
#include <fltkernel.h>

const char kMagic[32];

#pragma pack(push, 1)
typedef struct _SuperBlock
{
	CHAR  FileMagic[sizeof(kMagic)];
	DWORD BlockSize;
	DWORD FreeBlockMapBlock;
	DWORD NumBlocks;
	DWORD NumDirectoryBytes;
	DWORD Unknown;
	DWORD BlockMapAddr;
}SuperBlock;

typedef struct _StreamData {
	PCHAR StreamPointer;
	SIZE_T StreamSize;
}StreamData;

typedef struct _DBIHeader
{
	LONG	VersionSignature;
	DWORD	VersionHeader;
	DWORD	Age;
	WORD	GlobalStreamIndex;
	WORD	BuildNumber;
	WORD	PublicStreamIndex;
	WORD	PdbDllVersion;
	WORD	SymRecordStream;
	WORD	PdbDllRbld;
	LONG	ModInfoSize;
	LONG	SectionContributionSize;
	LONG	SectionMapSize;
	LONG	SourceInfoSize;
	LONG	TypeServerSize;
	DWORD	MFCTypeServerIndex;
	LONG	OptionalDbgHeaderSize;
	LONG	ECSubstreamSize;
	WORD	Flags;
	WORD	Machine;
	DWORD	Padding;
}DBIHeader;

typedef struct _PUBSYM32
{
	WORD reclen;     // Record length
	WORD rectyp;     // S_PUB32
	DWORD pubsymflags;
	DWORD off;
	WORD seg;
	char name[1];    // Length-prefixed name
}PUBSYM32;

typedef enum SYM_ENUM_e {
	// […]
	S_CONSTANT = 0x1107,  // constant symbol
	S_UDT = 0x1108,  // User defined type
	S_LDATA32 = 0x110c,  // Module-local symbol
	S_GDATA32 = 0x110d,  // Global data symbol
	S_PUB32 = 0x110e, // a public symbol (CV internal reserved)
	S_PROCREF = 0x1125, // Reference to a procedure
	S_LPROCREF = 0x1127, // Local Reference to a procedure
	// […]
};

typedef struct _SYMBOL_DATA {
	PCHAR SymbolName;
	//UINT SymbolNameHash;
	DWORD SectionOffset;
	DWORD SymbolRVA;
	WORD SectionNumber;
} SYMBOL_DATA, * PSYMBOL_DATA;
#pragma pack(pop)

BOOL KpdbIsPDBMagicValid(SuperBlock* super);
PVOID KpdbGetPDBStreamDirectory(PVOID base);
StreamData* KpdbGetPDBStreams(PVOID base, DWORD* streams_count);
BOOL KpdbGetPDBSymbolOffset(PVOID pdbfile, PSYMBOL_DATA SymbolDataList);
void KpdbConvertSecOffsetToRVA(DWORD64 ModuleBase, PSYMBOL_DATA SymbolDataList);
```

`ntutils.c`:

```c
#include "ntutils.h"

DWORD64 UtilGetKernelBase() {
	PRTL_PROCESS_MODULES ModuleInformation = NULL;
	NTSTATUS result;
	ULONG SizeNeeded;
	SIZE_T InfoRegionSize;
	DWORD64 output = 0;
	PROTOTYPE_ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;
	UNICODE_STRING ZWQSIName;

	RtlInitUnicodeString(&ZWQSIName, L"ZwQuerySystemInformation");
	ZwQuerySystemInformation = (PROTOTYPE_ZWQUERYSYSTEMINFORMATION)MmGetSystemRoutineAddress(&ZWQSIName);

	// get info size
	result = ZwQuerySystemInformation(0x0B, NULL, 0, &SizeNeeded);
	if (result != 0xC0000004) {
		return output;
	}
	InfoRegionSize = SizeNeeded;

	// get info
	while (result == 0xC0000004) {
		InfoRegionSize += 0x1000;
		ModuleInformation = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPoolNx, InfoRegionSize);
		if (ModuleInformation == NULL) {
			return output;
		}

		result = ZwQuerySystemInformation(0x0B, (PVOID)ModuleInformation, (ULONG)InfoRegionSize, &SizeNeeded);
		if (result == 0xC0000004) {
			ExFreePool((PVOID)ModuleInformation);
			ModuleInformation = NULL;
		}
	}

	if (!NT_SUCCESS(result)) {
		return output;
	}

	output = (DWORD64)ModuleInformation->Modules[0].ImageBase;

	// free pool
	ExFreePool((PVOID)ModuleInformation);

	return output;
}

NTSTATUS UtilGetFileSize(LPCWSTR FilePath, HANDLE FileHandle, PSIZE_T FileSize, PDWORD FileSizeHigh) {
	FILE_STANDARD_INFORMATION FileStandard;
	IO_STATUS_BLOCK IoStatusBlock;
	OBJECT_ATTRIBUTES ObjectAttributes;
	UNICODE_STRING FileNameUnicodeString;
	NTSTATUS result;
	BOOL CloseFileHandle = FALSE;

	if (FileHandle == NULL) {
		if (FilePath == NULL) {
			return (NTSTATUS)0xc0000030; //InvalidParameterMix
		}

		RtlInitUnicodeString(&FileNameUnicodeString, FilePath);

		ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
		ObjectAttributes.RootDirectory = NULL;
		ObjectAttributes.ObjectName = &FileNameUnicodeString;
		ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE | OBJ_INHERIT;
		ObjectAttributes.SecurityDescriptor = NULL;
		ObjectAttributes.SecurityQualityOfService = NULL;

		// open file
		result = ZwCreateFile(&FileHandle, GENERIC_READ | SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock, NULL, 0, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
		if (!NT_SUCCESS(result)) {
			return result;
		}

		CloseFileHandle = TRUE;
	}

	result = ZwQueryInformationFile(FileHandle, &IoStatusBlock, &FileStandard, sizeof(FILE_STANDARD_INFORMATION), (FILE_INFORMATION_CLASS)5);

	if (CloseFileHandle) ZwClose(FileHandle);

	if (!NT_SUCCESS(result)) {
		if (FileSizeHigh == NULL) {
			*FileSize = -1;
		}
		else {
			*FileSize = 0;
		}
		return result;
	}

	if (FileSizeHigh != NULL)
		*FileSizeHigh = FileStandard.EndOfFile.u.HighPart;

	*FileSize = FileStandard.EndOfFile.u.LowPart;
	return result;
}

NTSTATUS UtilReadFile(LPCWSTR FilePath, PVOID buffer) { // mostly copy-pasty from ReactOS source code
	NTSTATUS result;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	UNICODE_STRING FileNameUnicodeString;
	HANDLE FileHandle;
	SIZE_T FullFileSize;
	LARGE_INTEGER Offset;

	Offset.QuadPart = 0;

	RtlInitUnicodeString(&FileNameUnicodeString, FilePath);

	ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
	ObjectAttributes.RootDirectory = NULL;
	ObjectAttributes.ObjectName = &FileNameUnicodeString;
	ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE | OBJ_INHERIT;
	ObjectAttributes.SecurityDescriptor = NULL;
	ObjectAttributes.SecurityQualityOfService = NULL;

	// open file
	result = ZwCreateFile(&FileHandle, GENERIC_READ | SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock, NULL, 0, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if (!NT_SUCCESS(result)) {
		return result;
	}

	// get file size file
	result = UtilGetFileSize(NULL, FileHandle, &FullFileSize, NULL);
	if (!NT_SUCCESS(result)) {
		ZwClose(FileHandle);
		return result;
	}

	// read the file
	result = ZwReadFile(FileHandle, NULL, NULL, NULL, &IoStatusBlock, buffer, (ULONG)FullFileSize, &Offset, NULL);

	if (result == STATUS_PENDING)
	{
		result = ZwWaitForSingleObject(FileHandle, FALSE, NULL);
		if (NT_SUCCESS(result)) result = IoStatusBlock.Status;
		ZwClose(FileHandle);
		return result;
	}

	ZwClose(FileHandle);
	return result;
}
```

`ntutils.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <minwindef.h>
#include <intrin.h>
#include <ntddndis.h>
#include <strsafe.h>
#include <fltkernel.h>

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	ULONG Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	CHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef NTSTATUS(NTAPI* PROTOTYPE_ZWQUERYSYSTEMINFORMATION)(DWORD info, PVOID infoinout, ULONG len, PULONG retLen);

DWORD64 UtilGetKernelBase();
NTSTATUS UtilGetFileSize(LPCWSTR FilePath, HANDLE FileHandle, PSIZE_T FileSize, PDWORD FileSizeHigh);
NTSTATUS UtilReadFile(LPCWSTR FilePath, PVOID buffer);
```