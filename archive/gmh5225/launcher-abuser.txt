Project Path: arc_gmh5225_launcher-abuser_535uxtre

Source Tree:

```txt
arc_gmh5225_launcher-abuser_535uxtre
├── Launcher Abuser
│   ├── GameLauncherController.cpp
│   ├── GameLauncherController.h
│   ├── Launcher Abuser.cpp
│   ├── Launcher Abuser.vcxproj
│   ├── Launcher Abuser.vcxproj.filters
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── x86AddressesGrabber.cpp
│   └── x86AddressesGrabber.h
├── Launcher Abuser.sln
├── README.md
├── demo.gif
└── x86spy
    ├── x86spy.cpp
    ├── x86spy.vcxproj
    └── x86spy.vcxproj.filters

```

`Launcher Abuser.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Launcher Abuser", "Launcher Abuser\Launcher Abuser.vcxproj", "{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "x86spy", "x86spy\x86spy.vcxproj", "{410A0C19-EFA7-4A84-B6CC-27EF807220F8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Debug|x64.ActiveCfg = Debug|x64
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Debug|x64.Build.0 = Debug|x64
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Debug|x86.ActiveCfg = Debug|Win32
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Debug|x86.Build.0 = Debug|Win32
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Release|x64.ActiveCfg = Release|x64
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Release|x64.Build.0 = Release|x64
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Release|x86.ActiveCfg = Release|Win32
		{E1117EEA-88D4-4CA3-AC7B-AC29B1C716CD}.Release|x86.Build.0 = Release|Win32
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Debug|x64.ActiveCfg = Debug|x64
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Debug|x64.Build.0 = Debug|x64
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Debug|x86.ActiveCfg = Debug|Win32
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Debug|x86.Build.0 = Debug|Win32
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Release|x64.ActiveCfg = Release|Win32
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Release|x64.Build.0 = Release|Win32
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Release|x86.ActiveCfg = Release|Win32
		{410A0C19-EFA7-4A84-B6CC-27EF807220F8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6829C618-D541-4B8E-B4A6-4840D3F85ACB}
	EndGlobalSection
EndGlobal

```

`Launcher Abuser/GameLauncherController.cpp`:

```cpp

#include "GameLauncherController.h"


GameLauncherController::GameLauncherController(std::wstring launcherName, std::wstring gameProcessName) {
    this->launcherName = launcherName;
    this->gameProcessName = gameProcessName;
}


void GameLauncherController::getLauncherInfo() {
    this->getLauncherHandler();
    
    this->setModuleBaseAddress();
    
    this->findTheCodeCaveOnSectionNullBytes();
}

void GameLauncherController::setModuleBaseAddress() {
    uintptr_t modBaseAddr = 0;
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, this->launcherPid);

    if (hSnap != INVALID_HANDLE_VALUE)
    {
        MODULEENTRY32W modEntry;
        modEntry.dwSize = sizeof(modEntry);

        if (Module32FirstW(hSnap, &modEntry))
        {
            do
            {
                auto moduleName = std::wstring(modEntry.szModule);
                if (!_wcsnicmp(moduleName.c_str(), this->launcherName.c_str(), this->launcherName.length()))
                {
                    this->launcherMainModuleBaseAddress = (uintptr_t)modEntry.modBaseAddr;
                    break;
                }
            } while (Module32NextW(hSnap, &modEntry));
        }
    }
    CloseHandle(hSnap);
    if (this->launcherMainModuleBaseAddress == NULL)
    {
        notifyErrorAndExit("Something went wrong on the GameLauncherController::setModuleBaseAddress.");
    }
    return; 
}
void GameLauncherController::getLauncherHandler() {
    PROCESSENTRY32W PE32 {
        0
    };
    PE32.dwSize = sizeof(PE32);

    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hSnap == INVALID_HANDLE_VALUE) {
        LogThis(GetLastErrorAsString().c_str());
        notifyErrorAndExit("CreateToolhelp32Snapshot failed!");
        return;
    }

    DWORD PID = 0;
    BOOL bRet = Process32FirstW(hSnap, & PE32);
    while (bRet) {
        if (!wcscmp(PE32.szExeFile, this->launcherName.c_str())) {
          this->launcherPid = PE32.th32ProcessID;
          PID = PE32.th32ProcessID;
          break;
        }

        bRet = Process32NextW(hSnap, &PE32);
    }

    CloseHandle(hSnap);

    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, this->launcherPid);

    if (!processHandle) {
        notifyErrorAndExit("OpenProcess failed");
    }

    this->launcherHandle = processHandle;
    return;    
}

void GameLauncherController::findTheCodeCaveOnSectionNullBytes() {

  IMAGE_DOS_HEADER imageDosHeader = {'\0'};

  ReadProcessMemory(
    this->launcherHandle,
    LPCVOID(this->launcherMainModuleBaseAddress),
    LPVOID(&imageDosHeader),
    sizeof(imageDosHeader),
    NULL
  );

  if ((unsigned short)imageDosHeader.e_magic != 0x5a4d)
  {
    notifyErrorAndExit("Couldnt find the 'MZ' e_magic on IMAGE_DOS_HEADER.");
  }

  IMAGE_NT_HEADERS32 imageNtHeaders = {'\0'};
  
  ReadProcessMemory(
    this->launcherHandle,
    LPCVOID(this->launcherMainModuleBaseAddress + imageDosHeader.e_lfanew),
    LPVOID(&imageNtHeaders),
    sizeof(imageNtHeaders),
    NULL
  );

  // check if PE header is present
  if ((unsigned short)imageNtHeaders.Signature != 0x4550 )
  {
      LogThis((const char*)imageNtHeaders.Signature);
      notifyErrorAndExit("Couldnt find the PE chars on IMAGE_NT_HEADERS signature. Check above.");
  }

  
  if (imageNtHeaders.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC )
  {
    notifyErrorAndExit("This aint a 32 bit application. Weird. Check above the Magic.");
  }
  
  PIMAGE_SECTION_HEADER pSectionHeader = PIMAGE_SECTION_HEADER(this->launcherMainModuleBaseAddress + imageDosHeader.e_lfanew + sizeof(DWORD) + sizeof(imageNtHeaders.FileHeader) + imageNtHeaders.FileHeader.SizeOfOptionalHeader);

  for (UINT i = 0; i != imageNtHeaders.FileHeader.NumberOfSections; ++i, ++pSectionHeader) {
    printf("section address %X\n", pSectionHeader);

    IMAGE_SECTION_HEADER sectionHeaderCopy;

    ReadProcessMemory(
      this->launcherHandle,
      LPCVOID(pSectionHeader),
      LPVOID(&sectionHeaderCopy),
      sizeof(sectionHeaderCopy),
      NULL
    );

    // skip if aint an executable section
    if (!(sectionHeaderCopy.Characteristics & IMAGE_SCN_CNT_CODE))
    {
      continue;
    }

      unsigned long sectionTotalSize = NULL;
      // fix this shit
      for (unsigned int i = 1; i < 0x999999999; ++i)
      {
          sectionTotalSize = imageNtHeaders.OptionalHeader.SectionAlignment * i;
          unsigned long total = sectionHeaderCopy.SizeOfRawData/ (sectionTotalSize) ;
          if (total == 0)
          {
            break;
          }
      }      

    if (sectionTotalSize > 0x1000) {
      void * sectionCopyPtr = malloc(sectionTotalSize);
      ReadProcessMemory(
        this->launcherHandle,
        LPCVOID(imageNtHeaders.OptionalHeader.ImageBase + sectionHeaderCopy.VirtualAddress),
        LPVOID(sectionCopyPtr),
        sectionTotalSize,
        NULL
      );

      printf("addres da copia %X\n", sectionCopyPtr);


      BYTE * currentByte = ((BYTE*)sectionCopyPtr + sectionTotalSize);

      while(*currentByte == NULL) {
        currentByte = currentByte-1;
      }

      this->exploitableSectionInfo.numberOfNullBytes = (BYTE*)sectionCopyPtr + sectionTotalSize - currentByte -2;
      this->exploitableSectionInfo.startOfSectionAddr = imageNtHeaders.OptionalHeader.ImageBase + sectionHeaderCopy.VirtualAddress;
      this->exploitableSectionInfo.endOfSectionAddr = this->exploitableSectionInfo.startOfSectionAddr + sectionTotalSize;
      
      free(sectionCopyPtr);
      if (this->exploitableSectionInfo.numberOfNullBytes >= 0x1d0)
      {
        this->exploitableSectionInfo.sectionEndAddress = imageNtHeaders.OptionalHeader.ImageBase + sectionHeaderCopy.VirtualAddress + sectionTotalSize - 1;
        this->exploitableSectionInfo.nullBytesStartAddress = this->exploitableSectionInfo.sectionEndAddress - this->exploitableSectionInfo.numberOfNullBytes ;
        return;
      } else {
        return;  
      }
      
    }
  }

}

void GameLauncherController::overwriteCreateProcessToGetFullAccess(uintptr_t addrOpenProcess, uintptr_t addrOpenProcessJmpTo) {
  void* shellcodeBuffer = VirtualAlloc(NULL, 18, MEM_COMMIT, PAGE_READWRITE);
  
  if (shellcodeBuffer == nullptr) {
    notifyErrorAndExit("shellcodeBuffer == nullptr!");
  };

  SecureZeroMemory(shellcodeBuffer, 18);

  DWORD64 shellcodeBufferEndAddr = (DWORD64)shellcodeBuffer;

  BYTE openProcessWithAllAccessShellcode[] = {

    0xC7,0x44, 0x24, 0x04, 0xFF, 0xFF, 0x1F, 0x0,   // +0x00   | MOV     DWORD PTR SS:[ESP+0x4],0x1FFFFF                  
    0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,             // +0x8    | JMP     DWORD PTR DS:[<&OpenProcess>]   (TO BE REPLACED)
  };
   
  
  *reinterpret_cast<DWORD*>(openProcessWithAllAccessShellcode + 0xA) = addrOpenProcessJmpTo;

  if (!WriteProcessMemory(this->launcherHandle, (LPVOID)addrOpenProcess, openProcessWithAllAccessShellcode, sizeof(openProcessWithAllAccessShellcode), nullptr))
  {
      notifyErrorAndExit("WriteProcessMemory failed 1!");
  }
}


void GameLauncherController::setupSharedMemory(x86AddressesGrabber::X86FunctionsAddress* x86FunctionsAddress) {

  void* shellcodeBuffer = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_READWRITE);  

  if (shellcodeBuffer == nullptr) {
    notifyErrorAndExit("shellcodeBuffer == nullptr!");
  };

  SecureZeroMemory(shellcodeBuffer, 4096);

  DWORD64 shellcodeBufferEndAddr = (DWORD64)shellcodeBuffer;

  BYTE OpenFileMappingWShellcode[] = {

    // calling OpenFileMappingW 
    0x68, 0x00, 0x00, 0x00, 0x00,      // +0x00  | PUSH lpName address (REPLACE with lpName (c string adress of mappingName))
    0x6A, 0x00,                        // +0x05  | PUSH    0x0 (bInheritHandle)
    0x68, 0x1F, 0x00, 0x0F, 0x00,      // +0x07  | PUSH 0xF001F (dwDesiredAccess)

    0xB8, 0x00,0x00,0x00,0x00,         // +0x0C  | MOV EAX,0x0 (REPLACE OpenFileMappingW function address )
    0xFF, 0xD0,                        // +0x11  | CALL eax
  };
  
  
  DWORD64 lpNameReplaceAddress = (shellcodeBufferEndAddr + 0x01);
  *reinterpret_cast<DWORD*>(OpenFileMappingWShellcode + 0x0D) = x86FunctionsAddress->addrOpenFileMappingWPtr;

  CopyMemory((void*)shellcodeBufferEndAddr, OpenFileMappingWShellcode, sizeof(OpenFileMappingWShellcode));
  shellcodeBufferEndAddr += sizeof(OpenFileMappingWShellcode);

  BYTE MapViewOfFileShellcode[] = {
    // calling MapViewOfFile
    0x50,                                // +0x00 | PUSH    EAX (I'm pushing it here just to save the handle, will need it to call CloseHandle)
    0x68, 0x00, 0x10, 0x00, 0x00,        // +0x01 | PUSH    0x1000      
    0x6A, 0x00,                          // +0x06 | PUSH    0x0        
    0x6A, 0x00,                          // +0x08 | PUSH    0x0       
    0x68, 0x1F, 0x00, 0x0F, 0x00,        // +0x0A | PUSH    0xF001F   
    0x50,                                // +0x0F | PUSH    EAX (it will be the return of OpenFileMappingW)
    0xB8, 0x00,0x00,0x00,0x00,           // +0x10 | MOV EAX,0x0 (REPLACE MapViewOfFile function address )
    0xFF, 0xD0,                          // +0x15 | CALL eax
    0x8B, 0xF0,                          // +0x17 | MOV ESI,EAX (saving the return of MapViewOfFile, which is my filemapping Address)
  };

  *reinterpret_cast<DWORD*>(MapViewOfFileShellcode + 0x11) = x86FunctionsAddress->addrMapViewOfFilePtr;
  CopyMemory((void*)shellcodeBufferEndAddr, MapViewOfFileShellcode, sizeof(MapViewOfFileShellcode));
  shellcodeBufferEndAddr += sizeof(MapViewOfFileShellcode);


  BYTE CloseHandleShellcode[] = {

    //calling CloseHandle (the handle param is already on top of the stack, dont need to push it again)
    0xB8, 0x00,0x00,0x00,0x00,           // +0x00 | MOV EAX,0x0 (REPLACE CloseHandle function address )
    0xFF, 0xD0,                          // +0x05 | CALL eax

  };

  *reinterpret_cast<DWORD*>(CloseHandleShellcode + 0x01) = x86FunctionsAddress->addrCloseHandlePtr;
  CopyMemory((void*)shellcodeBufferEndAddr, CloseHandleShellcode, sizeof(CloseHandleShellcode));
  shellcodeBufferEndAddr += sizeof(CloseHandleShellcode);


  BYTE copySharedMemAddressAndInfiniteLoop[] = {
    0x89, 0x36,       // MOV     DWORD PTR DS:[ESI],ESI (esi has the shared mem address)
    0XEB, 0XFE, // loop infinito
  };

  CopyMemory((void*)shellcodeBufferEndAddr, copySharedMemAddressAndInfiniteLoop, sizeof(copySharedMemAddressAndInfiniteLoop));
  shellcodeBufferEndAddr += sizeof(copySharedMemAddressAndInfiniteLoop);

  DWORD shellcodeSize = (((unsigned int)shellcodeBufferEndAddr) - ((unsigned int)shellcodeBuffer));

  // finding the next aligned address
  DWORD lpNameAddressOnInjectedProcess = this->exploitableSectionInfo.nullBytesStartAddress + shellcodeSize;
  while (lpNameAddressOnInjectedProcess % 8 != 0) {
    lpNameAddressOnInjectedProcess++;
  }

  CopyMemory((void*)lpNameReplaceAddress, (void*)&lpNameAddressOnInjectedProcess, 4 );

  this->launcherHijackingThreadHandler = getThreadHandleBasedOnStartAddress(this->launcherHandle, this->exploitableSectionInfo.startOfSectionAddr, this->exploitableSectionInfo.endOfSectionAddr);

  if (!WriteProcessMemory(this->launcherHandle, (LPVOID)this->exploitableSectionInfo.nullBytesStartAddress, shellcodeBuffer, shellcodeSize, nullptr))
  {
      ResumeThread(this->launcherHijackingThreadHandler);
      notifyErrorAndExit("WriteProcessMemory failed 2");
  }

  std::wstring lpNameFilemappingInjected = L"sharedMe";

  unsigned int sizeOfWCstring = (lpNameFilemappingInjected.size()*2)+2;

  if (!WriteProcessMemory(this->launcherHandle, (LPVOID)lpNameAddressOnInjectedProcess, lpNameFilemappingInjected.c_str(), sizeOfWCstring, nullptr))
  {
      ResumeThread(this->launcherHijackingThreadHandler);
      notifyErrorAndExit("WriteProcessMemory failed 3!");
  }

  HANDLE hLocalSharedMem = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT | SEC_NOCACHE, 0, sharedMemoBufferSize, (LPCWSTR)lpNameFilemappingInjected.c_str() );
  if (!hLocalSharedMem) {
      notifyErrorAndExit("CreateFileMappingW failed!");
  }
  
  this->sharedMemoryLocalAddress = (DWORD64*)MapViewOfFile(hLocalSharedMem, FILE_MAP_ALL_ACCESS, 0, 0, sharedMemoBufferSize);
  
  if (!this->sharedMemoryLocalAddress) {
      notifyErrorAndExit("MapViewOfFile failed!");
  }  

  ExecWithThreadHiJacking(this->launcherHijackingThreadHandler, this->exploitableSectionInfo.nullBytesStartAddress, shellcodeSize , true);

  this->sharedMemoryInLauncherAddress = *this->sharedMemoryLocalAddress;
  
}



void GameLauncherController::deployControllerShellCode() {

    void* shellcodeBuffer = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_READWRITE);    

    if (shellcodeBuffer == nullptr) {
      notifyErrorAndExit("shellcodeBuffer == nullptr!");
    };

    SecureZeroMemory(shellcodeBuffer, 4096);

    DWORD64 shellcodeBufferEndAddr = (DWORD64)shellcodeBuffer;

    //0=do nothing, 1=read, 2=write
    BYTE spinlockController[] = {
      0xA0, 0x00, 0x00, 0x00, 0x00,     // +0x00         | MOV     AL,BYTE PTR DS:[sharedMemAddress]
      0x3C, 0x01,                       // +0x05         | CMP     AL,0x1                      
      0x74, 0x04,                       // +0x07         | JE      jumps to NtRVM
      0x72, 0xF5,                       // +0x09         | JB      keeps spinning
      0x7F, 0x00,                       // +0x0b         | JG      jumps to NtWVM
    };

    *reinterpret_cast<DWORD*>(spinlockController + 0x01) = this->sharedMemoryInLauncherAddress;

    CopyMemory((void*)shellcodeBufferEndAddr, spinlockController, sizeof(spinlockController));
    shellcodeBufferEndAddr += sizeof(spinlockController); 

    BYTE ntReadVirtualMemoryx64[] = {

      // heavens gate enter
      0x6A, 0x33,                                          // +0X00  | push 033h ; swap to long mode
      0xE8, 0x00, 0x00, 0x00, 0x00,                        // +0X02  | call $+5
      0x83, 0x04, 0x24, 0x05,                              // +0X07  | add dword ptr [esp], 5
      0xCB,                                                // +0X0B  | retf
      // /heavens gate enter
      // prelogue NtRVM
      0x48, 0x83, 0xEC, 0x28,                              // +0X0C    | sub rsp,28                                                       |
      0x48, 0xA1, 0,0,0,0,0,0,0,0,                         // +0x10    | mov rax,qword ptr ds:[ptr_to_hProcess]
      0x48, 0x8B, 0xC8,                                    // +0x1A    | mov rcx,rax
      0x48, 0xA1, 0,0,0,0,0,0,0,0,                         // +0x1D    | mov rax,qword ptr ds:[ptr_to_lpBaseAddress]
      0x48, 0x8B, 0xD0,                                    // +0x27    | mov rdx,rax
      0x48, 0xA1, 0,0,0,0,0,0,0,0,                         // +0x2A    | mov rax,qword ptr ds:[ptr_to_lpBuffer]
      0x4C, 0x8B, 0xC0,                                    // +0x34    | mov r8,rax
      0x48, 0xA1, 0,0,0,0,0,0,0,0,                         // +0x37    | mov rax,qword ptr ds:[ptr_to_nSize]
      0x4C, 0x8B, 0xC8,                                    // +0x41    | mov r9,rax
      0x48, 0xC7, 0x44, 0x24,  0x28, 0,0,0,0,              // +0x44    | mov qword ptr ss:[rsp+28],0
      // /prelogue NtXVM
      // NtRVM calling block
      0x4C, 0x8B, 0xD1,                                   //  +0X4D    | mov r10,rcx

      0x8A, 0x1C, 0x25, 0x0, 0x0, 0x0, 0x0,                // +0x50    | mov bl,byte ptr ds:[sharedMemAddress]
      0x80, 0xFB,  0x01,                                   // +0x57    | cmp bl,1
      0x7F, 0x07,                                          // +0x5A    | jg ntdll.7FFBD532F9C7
      0xB8, 0x3F, 0x00, 0x00, 0x00,                        // +0X5C    | mov eax,3F //ntReadVirtualMemory
      0xEB, 0x05,                                          // +0X61    | jmp ntdll.7FFBD532F9D3
      0xB8, 0x3A, 0x00, 0x00, 0x00,                        // +0X63    | mov eax,3A // ntWriteVirtualMemory
      0x0F, 0x05,                                          // +0X68    | syscall

      // /NtXVM calling block
      0x48, 0x83, 0xC4, 0x28,                              // +0X6A    | add rsp,28                                                       |
      
      // heavens gate exit
      0xE8, 0x00, 0x00, 0x00, 0x00,                        // +0X6E     | mov r10,rcx
      0xC7, 0x44, 0x24, 0x04, 0x23, 0x00, 0x00, 0x00,      // +0X73     | mov eax,3A
      0x83, 0x04, 0x24, 0x0D, 0xCB,                        // +0X7B     | syscall
      // /heavens gate exit
    };


    SpinLockControlStruct* controlStructInTargetProcess = reinterpret_cast<SpinLockControlStruct*>(this->sharedMemoryInLauncherAddress);
    *reinterpret_cast<HANDLE*>(ntReadVirtualMemoryx64 + 0x12) = &controlStructInTargetProcess->hProcess;
    *reinterpret_cast<DWORD64*>(ntReadVirtualMemoryx64 + 0x1F) = (DWORD64)&controlStructInTargetProcess->lpBaseAddress;
    *reinterpret_cast<DWORD*>(ntReadVirtualMemoryx64 + 0x2C) = (DWORD)&controlStructInTargetProcess->lpBuffer;
    *reinterpret_cast<SIZE_T*>(ntReadVirtualMemoryx64 + 0x39) = (SIZE_T)&controlStructInTargetProcess->nSize;

    *reinterpret_cast<DWORD*>(ntReadVirtualMemoryx64 + 0x53) = this->sharedMemoryInLauncherAddress;


    CopyMemory((void*)shellcodeBufferEndAddr, ntReadVirtualMemoryx64, sizeof(ntReadVirtualMemoryx64));
    shellcodeBufferEndAddr += sizeof(ntReadVirtualMemoryx64); 


    BYTE resetControllerAndJumpBack[] = {
      0xB8, 0,0,0,0,                               // +0x00       | mov eax,replace_with_operation_ptr
      0xC7, 0x00, 0,0,0,0,                         // +0x05       | MOV     DWORD PTR DS:[EAX],0x0
      0xE9, 0x63, 0xFF, 0xFF, 0xFF                 // +0xB        | JMP     spinlock start (unsigned int 4bytes) (TODO <- calculate this arbitrary number)
    };

    *reinterpret_cast<DWORD*>(resetControllerAndJumpBack + 0x01) = (DWORD)&controlStructInTargetProcess->operation;

    CopyMemory((void*)shellcodeBufferEndAddr, resetControllerAndJumpBack, sizeof(resetControllerAndJumpBack));
    shellcodeBufferEndAddr += sizeof(resetControllerAndJumpBack); 

    DWORD shellcodeSize = (((unsigned int)shellcodeBufferEndAddr) - ((unsigned int)shellcodeBuffer));
    if (!WriteProcessMemory(this->launcherHandle, (LPVOID)this->exploitableSectionInfo.nullBytesStartAddress, shellcodeBuffer, shellcodeSize, nullptr))
    {
        ResumeThread(this->launcherHijackingThreadHandler);
        notifyErrorAndExit("WriteProcessMemory failed 4!");
    }

    ExecWithThreadHiJacking(this->launcherHijackingThreadHandler, this->exploitableSectionInfo.nullBytesStartAddress, NULL , false);

};

// for getting an address of a procedure in memory.
PVOID GetLibraryProcAddress(const char LibraryName[], const char ProcName[])
{
  return GetProcAddress(GetModuleHandleA(LibraryName), ProcName);
}

// took it from the internet, the place where all good things come from.
// https://github.com/Zer0Mem0ry/WindowsNT-Handle-Scanner/blob/master/FindHandles/main.cpp
void GameLauncherController::getExistingHandlerToTheGame() {
    _NtQuerySystemInformation NtQuerySystemInformation =
      (_NtQuerySystemInformation)GetLibraryProcAddress("ntdll.dll", "NtQuerySystemInformation");
    _NtDuplicateObject NtDuplicateObject =
      (_NtDuplicateObject)GetLibraryProcAddress("ntdll.dll", "NtDuplicateObject");
    _NtQueryObject NtQueryObject =
      (_NtQueryObject)GetLibraryProcAddress("ntdll.dll", "NtQueryObject");

    NTSTATUS status;
    PSYSTEM_HANDLE_INFORMATION handleInfo;
    ULONG handleInfoSize = 0x10000;
    ULONG i;

    handleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);

    while ((status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, handleInfoSize, NULL)) == STATUS_INFO_LENGTH_MISMATCH)
      handleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(handleInfo, handleInfoSize *= 2);

    for (i = 0; i < handleInfo->HandleCount; i++)
    {
      SYSTEM_HANDLE handle = handleInfo->Handles[i];
      HANDLE dupHandle = NULL;
      POBJECT_TYPE_INFORMATION objectTypeInfo;
      PVOID objectNameInfo;
      UNICODE_ANOTHER_STRING objectName;
      ULONG returnLength;

      if (handle.ProcessId != this->launcherPid)
        continue;

      NT_SUCCESS(NtDuplicateObject(this->launcherHandle, (HANDLE)handle.Handle, GetCurrentProcess(), &dupHandle, 0, 0, 0));

      objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
      NT_SUCCESS(NtQueryObject(dupHandle, ObjectTypeInformation, objectTypeInfo, 0x1000, NULL));

      if (handle.GrantedAccess == 0x0012019f)
      {
        std::free(objectTypeInfo);
        CloseHandle(dupHandle);
        continue;
      }

      objectNameInfo = malloc(0x1000);
      if (!NT_SUCCESS(NtQueryObject(dupHandle, ObjectNameInformation, objectNameInfo, 0x1000, &returnLength)))
      {
        objectNameInfo = realloc(objectNameInfo, returnLength);
        if (!NT_SUCCESS(NtQueryObject(
          dupHandle,
          ObjectNameInformation,
          objectNameInfo,
          returnLength,
          NULL
        )))
        {
          std::free(objectTypeInfo);
          std::free(objectNameInfo);
          CloseHandle(dupHandle);
          continue;
        }
      }
      // reinterpret_cast<DWORD*>(OpenFileMappingWShellcode + 0x0D) = addrOpenFileMappingWPtr;
      // objectName = reinterpret_cast<UNICODE_ANOTHER_STRING>(*(PUNICODE_ANOTHER_STRING)objectNameInfo);
      std::wstring ObjectBuffer = objectTypeInfo->Name.Buffer;

      // We are only interested about handles to processes
      if (ObjectBuffer.find(L"Process") != std::wstring::npos)
      {

        HANDLE CurrentProcess = GetCurrentProcess();
        // HANDLE procHandle = OpenProcess(PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, handle.ProcessId);

        HANDLE DuplicatedHandle = 0;

        // Duplicating the handle, now we can do basically anything with it.
        if (DuplicateHandle(this->launcherHandle, (HANDLE)handle.Handle, CurrentProcess, &DuplicatedHandle, 0, false, DUPLICATE_SAME_ACCESS))
        {

          PVOID buffer2 = NULL;
          ULONG buffersize2 = 0;

          NTSTATUS status = NtQueryObject(this->launcherHandle, ObjectTypeInformation, buffer2, buffersize2, &buffersize2); // Return objecttypeinfo into buffer

          wchar_t process[MAX_PATH];
          if (GetModuleFileNameExW(DuplicatedHandle, NULL, process, MAX_PATH)) {
            std::wstring processname = process;
            int pos = processname.find_last_of(L"\\");
            processname = processname.substr(pos + 1, processname.length());
            if (processname == this->gameProcessName.c_str())
             {
              std::free(objectTypeInfo);
              std::free(objectNameInfo);
              CloseHandle(dupHandle);
              CloseHandle(DuplicatedHandle);
              //CloseHandle((HANDLE)handle.Handle);
              this->existingHandlerToTheGame = (HANDLE)handle.Handle;
              return;
            }
          }
        CloseHandle(DuplicatedHandle);
        }
      }
      std::free(objectTypeInfo);
      std::free(objectNameInfo);
      CloseHandle(dupHandle);
      //CloseHandle((HANDLE)handle.Handle);

    }

}


void GameLauncherController::cleanItUp() {
  CloseHandle(this->launcherHandle);
  CloseHandle(this->launcherHijackingThreadHandler);
}


uintptr_t* GameLauncherController::readGameMemory(DWORD64 readAddress, unsigned int lengthToRead) {
  if (lengthToRead > sharedMemoBufferWritableSize) {
    std::cout << "You are trying to read more than " << sharedMemoBufferWritableSize << " bytes. That's a no-no." << std::endl; 
    return nullptr;
  }

  SpinLockControlStruct* controlStructLocal = reinterpret_cast<SpinLockControlStruct*>(this->sharedMemoryLocalAddress);

  uintptr_t* localWriteBufferAddress = (uintptr_t*)(((BYTE*)(this->sharedMemoryLocalAddress))+ sharedMemoBufferOffset);
  uintptr_t* remoteWriteBufferAddress = (uintptr_t*)(this->sharedMemoryInLauncherAddress + sharedMemoBufferOffset);

  controlStructLocal->hProcess = (HANDLE)this->existingHandlerToTheGame;
  controlStructLocal->lpBaseAddress = readAddress;
  controlStructLocal->lpBuffer = (DWORD64)remoteWriteBufferAddress ;
  controlStructLocal->nSize = lengthToRead;
  controlStructLocal->operation = 1;
  while (controlStructLocal->operation != 0) {
    std::cout << "Reading! \n"; 
  }

  return localWriteBufferAddress;
}

void GameLauncherController::writeGameMemory(DWORD64 writeAddress, void* data, unsigned int lengthToWrite) {

  if (lengthToWrite > sharedMemoBufferWritableSize) {
    std::cout << "You are trying to write more than " << sharedMemoBufferWritableSize << " bytes. That's a no-no." << std::endl; 
    return;
  }

  SpinLockControlStruct* controlStructLocal = reinterpret_cast<SpinLockControlStruct*>(this->sharedMemoryLocalAddress);

  uintptr_t* localWriteBufferAddress = (uintptr_t*)(((BYTE*)(this->sharedMemoryLocalAddress))+ 0x50);
  uintptr_t* remoteWriteBufferAddress = (uintptr_t*)(this->sharedMemoryInLauncherAddress + 0x50);
  
  CopyMemory(localWriteBufferAddress, data, lengthToWrite);
  controlStructLocal->hProcess = (HANDLE)this->existingHandlerToTheGame;
  controlStructLocal->lpBaseAddress = writeAddress;
  controlStructLocal->lpBuffer = (DWORD64)remoteWriteBufferAddress ;
  controlStructLocal->nSize = lengthToWrite;
  controlStructLocal->operation = 2;
  while (controlStructLocal->operation != 0) {
    std::cout << "Writing! \n"; 
  }

}

```

`Launcher Abuser/GameLauncherController.h`:

```h
#pragma once

#include "x86AddressesGrabber.h"
#include "utils.h"

struct SpinLockControlStruct {
    DWORD64 operation = 0; //0=do nothing, 1=read, 2=write
    HANDLE hProcess = NULL;
    DWORD64 lpBaseAddress = NULL;
    DWORD64 lpBuffer = 0;
    SIZE_T nSize = 0;
};

struct ExploitableSectionInfo
{

  uintptr_t startOfSectionAddr;
  uintptr_t endOfSectionAddr;
  uintptr_t nullBytesStartAddress;
  uintptr_t sectionEndAddress;
  int numberOfNullBytes;
};

class GameLauncherController
{
  public:

    GameLauncherController(std::wstring launcherName, std::wstring gameProcessName);
    std::wstring launcherName;
    std::wstring gameProcessName;
    

    void getLauncherInfo();
    void overwriteCreateProcessToGetFullAccess(uintptr_t addrOpenProcess, uintptr_t addrOpenProcessJmpTo);
    void setupSharedMemory(x86AddressesGrabber::X86FunctionsAddress* x86FunctionsAddressPtr);
    void deployControllerShellCode();
    void getExistingHandlerToTheGame();
    void cleanItUp();
    uintptr_t* readGameMemory(DWORD64 readAddress, unsigned int lengthToRead);
    void writeGameMemory(DWORD64 writeAddress, void* data, unsigned int lengthToRead);

  protected:
    HANDLE existingHandlerToTheGame;
    void getLauncherHandler();
    void setModuleBaseAddress();
    void findTheCodeCaveOnSectionNullBytes();
    HANDLE launcherHandle;
    uintptr_t launcherMainModuleBaseAddress;
    uintptr_t launcherPid;    
    HANDLE launcherHijackingThreadHandler;

    ExploitableSectionInfo exploitableSectionInfo;
    DWORD64* sharedMemoryLocalAddress;
    DWORD sharedMemoryInLauncherAddress;
    static const int sharedMemoBufferSize = 4096;
    // the first 0x40 is reserved for the spinlock control structure.
    static const int sharedMemoBufferOffset = 0x30;
    static const int sharedMemoBufferWritableSize = sharedMemoBufferSize - sharedMemoBufferOffset;
};

```

`Launcher Abuser/Launcher Abuser.cpp`:

```cpp
// Launcher Abuser.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <string>
#include "x86AddressesGrabber.h"
#include "GameLauncherController.h"

int main()
{
    std::cout << "Welcome to Launcher Abuser! Let's borrow some handlers :D\n";
    x86AddressesGrabber::X86FunctionsAddress x86FunctionsAddress = {};
    x86AddressesGrabber::getFunctionAddresses(&x86FunctionsAddress);

    unsigned int option = 0;
    while (option <1 || option > 3) {
        std::cout << "What game launcher do you want to borrow the handler from?" << std::endl;
        std::cout << "1- Steam" << std::endl;
        std::cout << "2- Battle.net" << std::endl;
        std::cout << "3- Other" << std::endl;
        std::cin >> option;
    }

    std::wstring launcherName;
    std::wstring gameProcessName;


    switch(option) {
    case 1:
      launcherName = L"steam.exe";
      break; 
    case 2:
      launcherName = L"Battle.net.exe";
      break;   
    case 3:
      std::wcin >> launcherName;
      break;
    }

    std::wcout << "Ok, " << launcherName << " will be." << std::endl;

    std::cout << "What is the game process name (don't launch it yet)?" << std::endl;
    std::wcin >> gameProcessName;

    GameLauncherController gameLauncherCtl = {launcherName, gameProcessName};

    std::wcout << gameLauncherCtl.launcherName.c_str();
    gameLauncherCtl.getLauncherInfo();

    if (gameLauncherCtl.launcherName == L"steam.exe")
    {
        gameLauncherCtl.overwriteCreateProcessToGetFullAccess(x86FunctionsAddress.addrOpenProcess, x86FunctionsAddress.addrOpenProcessJmpTo);
    }

    std::cout << "Ok, now press enter when the game has loaded." << std::endl;
    std::cin >> option;


    gameLauncherCtl.setupSharedMemory(&x86FunctionsAddress);    
    gameLauncherCtl.deployControllerShellCode();    
    gameLauncherCtl.getExistingHandlerToTheGame();
    gameLauncherCtl.cleanItUp();


    while(true) {
        DWORD64 lpBaseAddress;
        unsigned int lengthToRead = 4;

        std::cout << "Address to read in the game: 0x";        
        std::cin >> std::hex >> lpBaseAddress;
        std::cout << "\n Length to read in hex:";
        std::cin >> std::hex >> lengthToRead;
        std::cout << std::endl;

        // gameLauncherCtl.writeGameMemory(lpBaseAddress, (void*)bufferToWritePtr, 4);

        uintptr_t *readDataPtr = gameLauncherCtl.readGameMemory(lpBaseAddress, lengthToRead);
        if (readDataPtr != nullptr)
        {
            printInHex((BYTE*)readDataPtr, lengthToRead);
        }

  }

}

```

`Launcher Abuser/Launcher Abuser.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e1117eea-88d4-4ca3-ac7b-ac29b1c716cd}</ProjectGuid>
    <RootNamespace>LauncherAbuser</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="GameLauncherController.cpp" />
    <ClCompile Include="Launcher Abuser.cpp" />
    <ClCompile Include="Utils.cpp" />
    <ClCompile Include="x86AddressesGrabber.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="GameLauncherController.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="x86AddressesGrabber.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`Launcher Abuser/Launcher Abuser.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Launcher Abuser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="x86AddressesGrabber.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GameLauncherController.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="x86AddressesGrabber.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GameLauncherController.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Launcher Abuser/Utils.cpp`:

```cpp
#include "Utils.h"

std::string GetLastErrorAsString() {
  //Get the error message, if any.
  DWORD errorMessageID = ::GetLastError();
  if (errorMessageID == 0)
    return std::string(); //No error message has been recorded

  LPSTR messageBuffer = nullptr;
  size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
    NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) & messageBuffer, 0, NULL);

  std::string message(messageBuffer, size);

  //Free the buffer.
  LocalFree(messageBuffer);

  return message;
}

void notifyErrorAndExit(const char * text) {
  std::cout << "---!!! Error ---!!!" << std::endl;
  std::cout << "---!!! " << text <<" ---!!!" << std::endl;

  std::cout << GetLastErrorAsString() << std::endl;
  std::cout << "Process will exit after any key press. Fix your shit." << std::endl;
  std::cin.get();
  ExitProcess(1);
}

void LogThis(const char * text) {
  std::cout << "--==-- " << text << " --==--\n";
}

char * TO_CHAR(wchar_t * string) {
  size_t len = wcslen(string) + 1;
  char * c_string = new char[len];
  size_t numCharsRead;
  wcstombs_s( & numCharsRead, c_string, len, string, _TRUNCATE);
  return c_string;
}

PEB * GetPEB() {
  #ifdef _WIN64
  PEB * peb = (PEB * ) __readgsword(0x60);

  #else
  PEB * peb = (PEB * ) __readfsdword(0x30);
  #endif

  return peb;
}

LDR_DATA_TABLE_ENTRY * GetLDREntry(std::string name) {
  LDR_DATA_TABLE_ENTRY * ldr = nullptr;

  PEB * peb = GetPEB();

  LIST_ENTRY head = peb -> Ldr -> InMemoryOrderModuleList;

  LIST_ENTRY curr = head;

  while (curr.Flink != head.Blink) {
    LDR_DATA_TABLE_ENTRY * mod = (LDR_DATA_TABLE_ENTRY * ) CONTAINING_RECORD(curr.Flink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

    if (mod -> FullDllName.Buffer) {
      char * cName = TO_CHAR(mod -> BaseDllName.Buffer);

      if (_stricmp(cName, name.c_str()) == 0) {
        ldr = mod;
        break;
      }
      delete[] cName;
    }
    curr = * curr.Flink;
  }
  return ldr;
}

void ExecWithThreadHiJacking(HANDLE hThread, DWORD shellcodePtr, SIZE_T shellcodeSize, bool thenRestore) {
  WOW64_CONTEXT tcInitial;
  WOW64_CONTEXT tcHijack;
  WOW64_CONTEXT tcCurrent;
  SecureZeroMemory(&tcInitial, sizeof(WOW64_CONTEXT));
  tcInitial.ContextFlags = WOW64_CONTEXT_ALL;
 
  // Suspend the thread and make it execute our shellcode

  DWORD suspendCount = SuspendThread(hThread);
  if (suspendCount > 0) // The thread was already suspended
    for (int i(0); i < suspendCount; ++i)
      ResumeThread(hThread);
  Wow64GetThreadContext(hThread, &tcInitial);
  CopyMemory(&tcHijack, &tcInitial, sizeof(WOW64_CONTEXT));
  CopyMemory(&tcCurrent, &tcInitial, sizeof(WOW64_CONTEXT));
  
  tcHijack.Eip = (DWORD)shellcodePtr;

  Wow64SetThreadContext(hThread, &tcHijack);
  ResumeThread(hThread);
 
  if (shellcodeSize == NULL)
    return; // Permanent thread hijack, do not wait for any execution completion
 
  // Check the thread context to know when done executing (Eip should be at memory address + size of shellcode - 2 in the infinite loop jmp rel8 -2)
  DWORD addrEndOfExec = (DWORD)shellcodePtr + shellcodeSize - 2;
  do {
    Wow64GetThreadContext(hThread, &tcCurrent);
    Sleep(1000);
  } while (tcCurrent.Eip != addrEndOfExec);

  if (thenRestore) {
    // Execution finished, resuming previous operations
    SuspendThread(hThread);
    Wow64SetThreadContext(hThread, &tcInitial);
    ResumeThread(hThread);
  }
 
  return;
}


HANDLE getThreadHandleBasedOnStartAddress(HANDLE processHandle, uintptr_t startOfSectionAddr, uintptr_t endOfSectionAddr) 
{
  tNtQueryInformationThread NtQueryInformationThread = (tNtQueryInformationThread)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryInformationThread");

  THREADENTRY32 TE32{ 0 };
  TE32.dwSize = sizeof(TE32);
  
  HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetProcessId(processHandle));
  if (hSnap == INVALID_HANDLE_VALUE)
  {
    notifyErrorAndExit("CreateToolhelp32Snapshot on hijackMainThread failed!");
  }

  DWORD dwTargetPID = GetProcessId(processHandle);
  DWORD ThreadID = 0;

  BOOL bRet = Thread32First(hSnap, &TE32);
  if (!bRet)
  {
    notifyErrorAndExit("Getting the handle failed!");
  }

  do
  {

    if (TE32.th32OwnerProcessID == dwTargetPID)
    {
      ThreadID = TE32.th32ThreadID;
      HANDLE hThread = OpenThread( THREAD_QUERY_INFORMATION |THREAD_SET_CONTEXT | THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME, FALSE, TE32.th32ThreadID);
      if (!hThread)
      {
        notifyErrorAndExit("Getting the handle failed!");
      }

      unsigned  long  long dwStartAddress;
      NTSTATUS ntStatus = NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, &dwStartAddress, sizeof(unsigned  long  long), NULL);
      if(ntStatus != 0x0) {
        notifyErrorAndExit("NtQueryInformationThread failed!");
      } 

      if (dwStartAddress >= startOfSectionAddr && dwStartAddress < endOfSectionAddr )
      {      
        CloseHandle(hSnap);
        return hThread;
      }
      CloseHandle(hThread);

      // break;
    }

    
    bRet = Thread32Next(hSnap, &TE32);
  } while (bRet);
  CloseHandle(hSnap);
  if (!ThreadID)
  {
    return NULL;
  }

}

void printInHex(BYTE* address, unsigned int length) {
    for (size_t i = 0; i < length; i++)
    {
        printf("%02hhx ", (unsigned char)(*(address + i)));
    }
    std::cout << "\n";

}

```

`Launcher Abuser/Utils.h`:

```h
#pragma once

#include <iostream>

#include <string>

#include <windows.h>
#include <Psapi.h>
#define WIN32_LEAN_AND_MEAN

#include <tlhelp32.h>

#define ThreadQuerySetWin32StartAddress 9

typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR Buffer;
}
UNICODE_STRING, * PUNICODE_STRING;

typedef struct _PEB_LDR_DATA {
  BYTE Reserved1[8];
  PVOID Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
}
PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  BYTE Reserved1[16];
  PVOID Reserved2[10];
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
}
RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
  BYTE Reserved1[2];
  BYTE BeingDebugged;
  BYTE Reserved2[1];
  PVOID Reserved3[2];
  PPEB_LDR_DATA Ldr;
  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  PVOID Reserved4[3];
  PVOID AtlThunkSListPtr;
  PVOID Reserved5;
  ULONG Reserved6;
  PVOID Reserved7;
  ULONG Reserved8;
  ULONG AtlThunkSListPtr32;
  PVOID Reserved9[45];
  BYTE Reserved10[96];
  PVOID PostProcessInitRoutine;
  BYTE Reserved11[128];
  PVOID Reserved12[1];
  ULONG SessionId;
}
PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
  LIST_ENTRY InLoadOrderLinks; /* 0x00 */
  LIST_ENTRY InMemoryOrderLinks; /* 0x08 */
  LIST_ENTRY InInitializationOrderLinks; /* 0x10 */
  PVOID DllBase; /* 0x18 */
  PVOID EntryPoint;
  ULONG SizeOfImage;
  UNICODE_STRING FullDllName; /* 0x24 */
  UNICODE_STRING BaseDllName; /* 0x28 */
  ULONG Flags;
  WORD LoadCount;
  WORD TlsIndex;
  union {
    LIST_ENTRY HashLinks;
    struct {
      PVOID SectionPointer;
      ULONG CheckSum;
    };
  };
  union {
    ULONG TimeDateStamp;
    PVOID LoadedImports;
  };
  _ACTIVATION_CONTEXT * EntryPointActivationContext;
  PVOID PatchInformation;
  LIST_ENTRY ForwarderLinks;
  LIST_ENTRY ServiceTagLinks;
  LIST_ENTRY StaticLinks;
}
LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef BOOL(WINAPI * tNtQueryInformationThread)(
  HANDLE ThreadHandle,
  ULONG ThreadInformationClass,
  PVOID ThreadInformation,
  ULONG ThreadInformationLength,
  PULONG ReturnLength
);



#define NT_SUCCESS(x) ((x) >= 0)
#define STATUS_INFO_LENGTH_MISMATCH 0xc0000004

#define SystemHandleInformation 16
#define ObjectBasicInformation 0
#define ObjectNameInformation 1
#define ObjectTypeInformation 2

typedef struct _UNICODE_ANOTHER_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR Buffer;
}
UNICODE_ANOTHER_STRING, * PUNICODE_ANOTHER_STRING;

typedef NTSTATUS(NTAPI *_NtQuerySystemInformation)(
  ULONG SystemInformationClass,
  PVOID SystemInformation,
  ULONG SystemInformationLength,
  PULONG ReturnLength
  );
typedef NTSTATUS(NTAPI *_NtDuplicateObject)(
  HANDLE SourceProcessHandle,
  HANDLE SourceHandle,
  HANDLE TargetProcessHandle,
  PHANDLE TargetHandle,
  ACCESS_MASK DesiredAccess,
  ULONG Attributes,
  ULONG Options
  );
typedef NTSTATUS(NTAPI *_NtQueryObject)(
  HANDLE ObjectHandle,
  ULONG ObjectInformationClass,
  PVOID ObjectInformation,
  ULONG ObjectInformationLength,
  PULONG ReturnLength
  );

typedef struct _SYSTEM_HANDLE
{
  ULONG ProcessId;
  BYTE ObjectTypeNumber;
  BYTE Flags;
  USHORT Handle;
  PVOID Object;
  ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
  ULONG HandleCount;
  SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef enum _POOL_TYPE
{
  NonPagedPool,
  PagedPool,
  NonPagedPoolMustSucceed,
  DontUseThisType,
  NonPagedPoolCacheAligned,
  PagedPoolCacheAligned,
  NonPagedPoolCacheAlignedMustS
} POOL_TYPE, *PPOOL_TYPE;

typedef struct _OBJECT_TYPE_INFORMATION
{
  UNICODE_ANOTHER_STRING Name;
  ULONG TotalNumberOfObjects;
  ULONG TotalNumberOfHandles;
  ULONG TotalPagedPoolUsage;
  ULONG TotalNonPagedPoolUsage;
  ULONG TotalNamePoolUsage;
  ULONG TotalHandleTableUsage;
  ULONG HighWaterNumberOfObjects;
  ULONG HighWaterNumberOfHandles;
  ULONG HighWaterPagedPoolUsage;
  ULONG HighWaterNonPagedPoolUsage;
  ULONG HighWaterNamePoolUsage;
  ULONG HighWaterHandleTableUsage;
  ULONG InvalidAttributes;
  GENERIC_MAPPING GenericMapping;
  ULONG ValidAccess;
  BOOLEAN SecurityRequired;
  BOOLEAN MaintainHandleCount;
  USHORT MaintainTypeList;
  POOL_TYPE PoolType;
  ULONG PagedPoolUsage;
  ULONG NonPagedPoolUsage;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;


std::string GetLastErrorAsString();
void LogThis(const char * text);
char * TO_CHAR(wchar_t * string);
PEB * GetPEB();
LDR_DATA_TABLE_ENTRY * GetLDREntry(std::string name);
void notifyErrorAndExit(const char * text);
HANDLE getThreadHandleBasedOnStartAddress(HANDLE processHandle, uintptr_t startOfSectionAddr, uintptr_t endOfSectionAddr);
void ExecWithThreadHiJacking(HANDLE hThread, DWORD shellcodePtr, SIZE_T shellcodeSize, bool thenRestore);
void printInHex(BYTE* address, unsigned int length);
```

`Launcher Abuser/x86AddressesGrabber.cpp`:

```cpp
#include "x86AddressesGrabber.h"

bool x86AddressesGrabber::getFunctionAddresses(X86FunctionsAddress * x86FunctionsAddress) {

  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  ZeroMemory( &si, sizeof(si) );
  si.cb = sizeof(si);
  ZeroMemory( &pi, sizeof(pi) );
  
  const wchar_t* app_const = spyProcessName.c_str();


  if( !CreateProcessW( NULL,
      (LPWSTR)app_const,
      NULL,
      NULL,
      FALSE,
      0,
      NULL,
      NULL,
      &si,
      &pi )
  ) 
  {
      notifyErrorAndExit("Error creating the x86spy process!");
  }

  HANDLE hLocalSharedMem = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT | SEC_NOCACHE, 0, sharedMemSize, (LPCWSTR)lpNameFilemappingx86Spy.c_str() );
  if (!hLocalSharedMem)
    return false;
  VOID * ptrLocalSharedMem = MapViewOfFile(hLocalSharedMem, FILE_MAP_ALL_ACCESS, 0, 0, sharedMemSize);
  if (!ptrLocalSharedMem)
    return false;
  
  while(*(DWORD*)ptrLocalSharedMem == 0x0) {
    std::cout << "Waiting for x86 spy process to update the addresses..." << std::endl;
    Sleep(2000);
  }

  x86FunctionsAddress->addrOpenFileMappingWPtr = *(DWORD*)ptrLocalSharedMem;
  x86FunctionsAddress->addrMapViewOfFilePtr = *((DWORD*)ptrLocalSharedMem+1);
  x86FunctionsAddress->addrCloseHandlePtr = *((DWORD*)ptrLocalSharedMem+2);
  x86FunctionsAddress->addrOpenProcess = *((DWORD*)ptrLocalSharedMem+3);
  x86FunctionsAddress->addrOpenProcessJmpTo = *((DWORD*)ptrLocalSharedMem+4);

  std::cout << "Addresses updated! Closing x86 spy process "<< std::hex << x86FunctionsAddress->addrOpenProcessJmpTo << std::endl;  

  TerminateProcess(
    pi.hProcess,
    0x0
  );
  CloseHandle( hLocalSharedMem );
  CloseHandle( pi.hProcess );
  CloseHandle( pi.hThread );

}

```

`Launcher Abuser/x86AddressesGrabber.h`:

```h
#pragma once

#include <windows.h>
#include <string>
#include "Utils.h"
#include <iostream>


namespace x86AddressesGrabber
{

    struct X86FunctionsAddress
    {
        DWORD addrOpenFileMappingWPtr = NULL;
        DWORD addrMapViewOfFilePtr = NULL;
        DWORD addrCloseHandlePtr = NULL;
        DWORD addrOpenProcess = NULL;
        DWORD addrOpenProcessJmpTo = NULL;
    };

    bool getFunctionAddresses(X86FunctionsAddress * x86FunctionsAddress);
    
    const std::wstring lpNameFilemappingx86Spy = L"x86Spy";
    const std::wstring spyProcessName = L"x86spy.exe";
    const DWORD sharedMemSize = 4096;
};


```

`README.md`:

```md
# Launcher Abuser

Stealthy way to hijack the existing game process handle within the game launcher (currently supports Steam and Battle.net). Achieve external game process read/write with minimum footprint. 
<p align="center">
  <img src="/demo.gif?raw=true" width="600px">
</p>

## Core Concepts:
- **No new handles**: The LA (Launcher Abuser/cheat) process communicates with the game launcher using [Named Shared Memory](https://docs.microsoft.com/en-us/windows/win32/memory/using-file-mapping?redirectedfrom=MSDN), but the LA->game launcher handle is destroyed before the game is loaded (and the communication still works without it).
- **No new modules**: A 154 bytes shellcode is injected into the game launcher to handle read and write requests using a spinlock and the shared memory.
- **No new threads**: An existing game launcher thread is hijacked so there's less footprint.
- **No new executable memory pages**: Since it's a 154 bytes shellcode, an existing executable page memory is used as a codecave for the spinlock (and the following read/write operations).

## How It Works
It abuses the existing game process handle that the launchers keep (usually with full permissions). The LA process controls the game launcher process using it to send read and write commands to the game process. The thing that allows us to have an inter-process communication without a handle between the LA process and the game launcher is the fact that you can destroy the handle after setting up the named shared memory (before the game gets loaded). A thread is hijacked from the game launcher process, and the execution redirected to an an eternal loop shellcode. This shellcode keeps checking if the operation byte is set. When the LA process wants to read or write to the game process, it writes the shared memory on his own process the arguments for NtReadVirtualMemory/NtWriteVirtualMemory and sets the operation byte. That memory is reflected on the game launcher process, and the spinlock gets to execute the operation and stores the result on an offset of the same shared memory. 

## How It Actually Works
Considering game launchers that are x86, here's what it does step by step:
1. Spawns a x86 process to get the addresses of the functions [OpenFileMappingW](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-openfilemappingw), [MapViewOfFile](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile) and [CloseHandle](https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle). Those addresses are the same across all Windows processes, so they are used in the shellcode.
2. Searches for a codecave in the game launcher, and injects a shellcode that will establish the IPC using the named shared memory and close the handle right after.
3. Hijacks the game launcher main thread and makes it execute the IPC setup shellcode. The LA process waits for the first bytes of the shared memory to be updated with the address of the shared memory in the game launcher process.
4. The spinlock shellcode is deployed in the shared memory and the game launcher's thread is redirected to it.
5. From now on, the LA process has control of the operations thru the shared memory. If the control byte is 0, it will keep looping. If it's 1, it'll perform a read operation and 2 a write operation. It uses a few instructions to transict to x64 mode so we don't have to worry about [WoW64's Heaven's Gate](https://medium.com/@fsx30/hooking-heavens-gate-a-wow64-hooking-technique-5235e1aeed73) and we can simply use syscall opcodes to perform `NtReadVirtualMemory/NtWriteVirtualMemory`. The parameters for the functions are passed in the following struct:
 
```cpp
        struct SpinLockControlStruct {
            DWORD64 operation = 0; //0=do nothing, 1=read, 2=write
            HANDLE hProcess = NULL;
            DWORD64 lpBaseAddress = NULL;
            DWORD64 lpBuffer = 0;
            SIZE_T nSize = 0;
        };
 ```
6. After the operation, the result (if it's a read) comes in a specific offset of the shared memory.

## How to Use It
The example on `Launcher Abuser.cpp`'s main function is pretty self explanatory. Just call the functions below after the setup and do whatever you want:
```cpp
//this function reads from the game memory
uintptr_t *dataPtr = gameLauncherCtl.readGameMemory(lpBaseAddress, lengthToRead);

//this function writes on the game memory
gameLauncherCtl.writeGameMemory(lpBaseAddress, (void*)bufferToWritePtr,  size);

```

## More info
I wrote a [tutorial on Guided Hacking](https://guidedhacking.com/threads/launcher-abuser-hijack-handles-from-steam-battle-net-launchers.17139). Check it out!

## Disclaimer
The project was developed for education purposes only. Nothing here is new and it was somewhat based on [this great project by harakirinox](https://www.unknowncheats.me/forum/anti-cheat-bypass/261176-silentjack-ultimate-handle-hijacking-user-mode-multi-ac-bypass-eac-tested.html). It should not be used to cheat in online games. It ain't cool kids. Also, as always, big shout-out to [Guided Hacking](https://guidedhacking.com). Best game hacking learning resources on the internet. You should check them out if you haven't yet.

```

`x86spy/x86spy.cpp`:

```cpp
// x86spy.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include <iostream>

#include <windows.h>

#include <tchar.h>

#include <stdio.h>

#include <string>

int main()
{
    std::cout << "<--- x86Spy.exe ---> Getting function addresses.\n";
    
    DWORD addrOpenFileMappingW = (DWORD)GetProcAddress(GetModuleHandle(TEXT("kernelbase.dll")), "OpenFileMappingW");
    DWORD addrMapViewOfFile = (DWORD)GetProcAddress(GetModuleHandle(TEXT("kernelbase.dll")), "MapViewOfFile");
    DWORD addrCloseHandle = (DWORD)GetProcAddress(GetModuleHandle(TEXT("kernelbase.dll")), "CloseHandle");
    DWORD addrOpenProcess = (DWORD)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "OpenProcess");
    DWORD addrOpenProcessJmpTo = (DWORD)(*(DWORD*)(addrOpenProcess + 0x8));


    DWORD sharedMemSize = 4096;

    std::wstring sharedMemName = L"x86Spy";

    HANDLE hLocalSharedMem = NULL;

    while (hLocalSharedMem == NULL) {
        hLocalSharedMem = OpenFileMappingW(FILE_MAP_ALL_ACCESS, FALSE, sharedMemName.c_str());
        Sleep(1000);
    }

    void* ptrLocalSharedMem = MapViewOfFile(hLocalSharedMem, FILE_MAP_ALL_ACCESS, 0, 0, sharedMemSize);
    if (!ptrLocalSharedMem) {
        return 0;
    }

    CloseHandle(hLocalSharedMem);
    while (true) {
        *(DWORD*)ptrLocalSharedMem = addrOpenFileMappingW;
        *((DWORD*)ptrLocalSharedMem + 1) = addrMapViewOfFile;
        *((DWORD*)ptrLocalSharedMem + 2) = addrCloseHandle;
        *((DWORD*)ptrLocalSharedMem + 3) = addrOpenProcess;
        *((DWORD*)ptrLocalSharedMem + 4) = addrOpenProcessJmpTo;

        std::cout << "<--- x86Spy.exe ---> I'm done, feel free to kill me.\n";

        Sleep(2000);
    }

}

```

`x86spy/x86spy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{410a0c19-efa7-4a84-b6cc-27ef807220f8}</ProjectGuid>
    <RootNamespace>x86spy</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="x86spy.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`x86spy/x86spy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="x86spy.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```