Project Path: arc_gmh5225_apex-legends-cheat_m9a_s5qk

Source Tree:

```txt
arc_gmh5225_apex-legends-cheat_m9a_s5qk
├── README.md
├── apex.sln
├── apex_client
│   ├── apex_client.vcxproj
│   ├── apex_client.vcxproj.filters
│   └── core
│       ├── dllmain.cpp
│       ├── driver
│       │   └── driver.h
│       └── sdk
│           ├── sdk.cpp
│           └── sdk.h
├── apex_driver
│   ├── apex_driver.vcxproj
│   ├── apex_driver.vcxproj.filters
│   └── core
│       ├── features
│       │   ├── esp.cpp
│       │   ├── features.h
│       │   └── misc.cpp
│       ├── hook
│       │   ├── hook.cpp
│       │   └── hook.h
│       ├── main.cpp
│       ├── renderer
│       │   ├── renderer.cpp
│       │   └── renderer.h
│       ├── sdk
│       │   ├── sdk.cpp
│       │   └── sdk.h
│       └── utils
│           ├── color.h
│           ├── hotkeys
│           │   ├── hotkeys.cpp
│           │   └── hotkeys.h
│           ├── imports.h
│           ├── math
│           │   ├── vectors.cpp
│           │   └── vectors.h
│           ├── memory
│           │   ├── memory.cpp
│           │   └── memory.h
│           ├── physical
│           │   ├── physical.cpp
│           │   └── physical.h
│           ├── utils.cpp
│           └── utils.h
└── apex_loader
    ├── apex_loader.vcxproj
    ├── apex_loader.vcxproj.filters
    └── core
        ├── loader
        │   ├── loader.cpp
        │   └── loader.h
        └── main.cpp

```

`README.md`:

```md
# apex legends external cheat

external cheat utilizing kernel gdi rendering & kernel key input

esp, chams, broken rcs

## bypass

syscall is hooked then called, once called hook is restored and enters a while loop. Usermode thread is trapped in kernel loop where cheat runs.

thread is attempted to be hidden by removing it from eprocess ThreadListHead, as well as the thread being hijacked from a legit process to have a start address backed by a signed process (probaly doesnt matter but cant hurt). where u get fucked is the anticheats stack walk, travesing the stack for address reissindg outside of a legit module. perhaps this isnt a big deal because the thread was created in usermode land so they may not stackwalk it but I have read they do. The threads irp also is in the kernel with its cpl being 0 as well which is supsiocous (u can check threads privledge level by checking SegCs register, SegCs & 3 i suppose u could maybe spoof this too? idk maybe use PspGetContextThreadInternal).

Anyways ive been using it for a week and a half on apex and havent been banned yet (its orobaly coming soon[!!!](https://cdn.discordapp.com/attachments/784596712060092427/800163253161820181/491.gif)). There is a lot of things that can be detcteded here and a lot of things u can do to hide the thread better

## usage
1. load the apex_driver.sys with kdmapper or whatever u want to use
2. run apex_loader.exe
    - this exeucatble loads the apex_client.dll into the speicified process (default EpicGamesLauncher.exe) [change your path and hijackled process here](https://github.com/NMan1/apex-legends-cheat/blob/6332e968db690c5285683bbc49815f880ba83827/apex_loader/core/main.cpp#L5)
3. Use dbgview to verifiy succsefull loading of driver. 
    - if driver failed to intitalize itself (couldnt get rendering functions, failed to unlink thread) it should return STATUS_UNSCUCUSEFL and a messagebox will popup from hijacked process indicating somethign failed

notes:
- change screen rsolusiton for proper w2s, [replace all 1920 x 1080](https://github.com/NMan1/apex-legends-cheat/blob/6332e968db690c5285683bbc49815f880ba83827/apex_driver/core/sdk/sdk.cpp#L76)
- END key unloads driver
- F1 toggles esp
- F2 toggles rcs, if i rmeebr coreeclrt this was broken so i wouldnt use it

<img src="https://i.imgur.com/6QZ4fBS.png"/>

https://user-images.githubusercontent.com/44145464/126057251-4de04761-00d1-4718-b074-6f2bc634f97c.mp4


credits:

quick dll thread hijack paste
https://github.com/hrt/ThreadJect-x64

unkown apex thread for offsets

```

`apex.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30709.64
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "apex_driver", "apex_driver\apex_driver.vcxproj", "{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "apex_loader", "apex_loader\apex_loader.vcxproj", "{26F87A2B-653A-450E-B988-E2CA6794E91A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "apex_client", "apex_client\apex_client.vcxproj", "{905F1DBC-F173-4612-891A-514AC3584823}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|ARM.ActiveCfg = Debug|ARM
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|ARM.Build.0 = Debug|ARM
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|ARM.Deploy.0 = Debug|ARM
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|ARM64.Build.0 = Debug|ARM64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|x64.ActiveCfg = Debug|x64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|x64.Build.0 = Debug|x64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|x64.Deploy.0 = Debug|x64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|x86.ActiveCfg = Debug|Win32
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|x86.Build.0 = Debug|Win32
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Debug|x86.Deploy.0 = Debug|Win32
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|ARM.ActiveCfg = Release|ARM
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|ARM.Build.0 = Release|ARM
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|ARM.Deploy.0 = Release|ARM
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|ARM64.ActiveCfg = Release|ARM64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|ARM64.Build.0 = Release|ARM64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|ARM64.Deploy.0 = Release|ARM64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|x64.ActiveCfg = Release|x64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|x64.Build.0 = Release|x64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|x64.Deploy.0 = Release|x64
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|x86.ActiveCfg = Release|Win32
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|x86.Build.0 = Release|Win32
		{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}.Release|x86.Deploy.0 = Release|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Debug|ARM.ActiveCfg = Debug|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Debug|ARM64.ActiveCfg = Debug|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Debug|x64.ActiveCfg = Debug|x64
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Debug|x64.Build.0 = Debug|x64
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Debug|x86.ActiveCfg = Debug|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Debug|x86.Build.0 = Debug|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Release|ARM.ActiveCfg = Release|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Release|ARM64.ActiveCfg = Release|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Release|x64.ActiveCfg = Release|x64
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Release|x64.Build.0 = Release|x64
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Release|x86.ActiveCfg = Release|Win32
		{26F87A2B-653A-450E-B988-E2CA6794E91A}.Release|x86.Build.0 = Release|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Debug|ARM.ActiveCfg = Debug|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Debug|ARM64.ActiveCfg = Debug|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Debug|x64.ActiveCfg = Debug|x64
		{905F1DBC-F173-4612-891A-514AC3584823}.Debug|x64.Build.0 = Debug|x64
		{905F1DBC-F173-4612-891A-514AC3584823}.Debug|x86.ActiveCfg = Debug|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Debug|x86.Build.0 = Debug|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Release|ARM.ActiveCfg = Release|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Release|ARM64.ActiveCfg = Release|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Release|x64.ActiveCfg = Release|x64
		{905F1DBC-F173-4612-891A-514AC3584823}.Release|x64.Build.0 = Release|x64
		{905F1DBC-F173-4612-891A-514AC3584823}.Release|x86.ActiveCfg = Release|Win32
		{905F1DBC-F173-4612-891A-514AC3584823}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7E263E77-DFA4-4CBC-AE4C-A41056AC9110}
	EndGlobalSection
EndGlobal

```

`apex_client/apex_client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{905f1dbc-f173-4612-891a-514ac3584823}</ProjectGuid>
    <RootNamespace>apexclient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;apexCLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;apexCLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;apexCLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <Optimization>Disabled</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;apexCLIENT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <Optimization>Disabled</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="core\sdk\sdk.cpp" />
    <ClCompile Include="core\dllmain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\driver\driver.h" />
    <ClInclude Include="core\sdk\sdk.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`apex_client/apex_client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\sdk\sdk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\driver\driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\sdk\sdk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`apex_client/core/dllmain.cpp`:

```cpp
#include <Windows.h>
#include "driver/driver.h"

init_t init{};

BOOL APIENTRY DllMain(HMODULE module, DWORD reason_for_call, LPVOID reserved) {
	if (reason_for_call == DLL_PROCESS_ATTACH) {
		init.usermode_process_id = GetCurrentProcessId();
		init.usermode_thread_id = GetThreadId(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)driver::call_hook, &init, 0, 0));
	}
}
```

`apex_client/core/driver/driver.h`:

```h
#pragma once
#include <Windows.h>
#include <mutex>
#include <iostream>
#include "../sdk/sdk.h"

typedef struct init_t {
	DWORD		usermode_process_id;
	DWORD		usermode_thread_id;
};

namespace driver {
	static void call_hook(init_t* argument) {
		while (!argument->usermode_thread_id) {};

		//wchar_t buffer[64]{};
		//wsprintf(buffer, L"id: %d", argument->usermode_thread_id);

		//MessageBox(NULL, buffer, L"Notify", MB_OK);

		void* control_function = GetProcAddress(LoadLibrary(L"win32u.dll"), "NtOpenCompositionSurfaceSectionInfo");
		if (!control_function) {
			MessageBox(NULL, L"failed to get control_function address", L"error", MB_OK);
			return;
		}

		auto possible_return = static_cast<uint64_t(__stdcall*)(init_t*)>(control_function)(argument);
		if (possible_return == 0xC0000001L) { // STATUS_UNSUCCESSFUL
			MessageBox(NULL, L"driver failed", L"error", MB_OK);
			return;
		}
	}
}
```

`apex_client/core/sdk/sdk.cpp`:

```cpp
#include "sdk.h"

namespace sdk {
	HANDLE process_id;

	uint64_t module_base;
}
```

`apex_client/core/sdk/sdk.h`:

```h
#pragma once
#include <windows.h>
#include <cstdint>

namespace sdk {
	extern HANDLE process_id;

	extern uint64_t module_base;
}
```

`apex_driver/apex_driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\features\esp.cpp" />
    <ClCompile Include="core\features\misc.cpp" />
    <ClCompile Include="core\hook\hook.cpp" />
    <ClCompile Include="core\main.cpp" />
    <ClCompile Include="core\renderer\renderer.cpp" />
    <ClCompile Include="core\sdk\sdk.cpp" />
    <ClCompile Include="core\utils\hotkeys\hotkeys.cpp" />
    <ClCompile Include="core\utils\math\vectors.cpp" />
    <ClCompile Include="core\utils\memory\memory.cpp" />
    <ClCompile Include="core\utils\physical\physical.cpp" />
    <ClCompile Include="core\utils\utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\features\features.h" />
    <ClInclude Include="core\hook\hook.h" />
    <ClInclude Include="core\renderer\renderer.h" />
    <ClInclude Include="core\sdk\sdk.h" />
    <ClInclude Include="core\utils\color.h" />
    <ClInclude Include="core\utils\hotkeys\hotkeys.h" />
    <ClInclude Include="core\utils\imports.h" />
    <ClInclude Include="core\utils\math\vectors.h" />
    <ClInclude Include="core\utils\memory\memory.h" />
    <ClInclude Include="core\utils\physical\physical.h" />
    <ClInclude Include="core\utils\utils.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C54DD342-E818-4F2A-A8CC-757A2D56AF4A}</ProjectGuid>
    <TemplateGuid>{0a049372-4c4d-4ea0-a64e-dc6ad88ceca1}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>apex_driver</RootNamespace>
    <DriverType>KMDF</DriverType>
    <WindowsTargetPlatformVersion>10.0.20348.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>MultiByte</CharacterSet>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>MultiByte</CharacterSet>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AdditionalIncludeDirectories>C:\Program Files (x86)\Windows Kits\10\Include\10.0.20348.0\km;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>real_entry</EntryPointSymbol>
    </Link>
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`apex_driver/apex_driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\hook\hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\utils\utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\renderer\renderer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\utils\hotkeys\hotkeys.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\utils\memory\memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\features\esp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\sdk\sdk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\utils\math\vectors.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\utils\physical\physical.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\features\misc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\utils\imports.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\hook\hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\features\features.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\renderer\renderer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\color.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\hotkeys\hotkeys.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\memory\memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\sdk\sdk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\math\vectors.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="core\utils\physical\physical.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`apex_driver/core/features/esp.cpp`:

```cpp
#include "features.h"
#include "..\renderer\renderer.h"

void features::esp(uintptr_t local_player) {
	auto view_renderer = memory::read<uintptr_t>(sdk::process, sdk::module_base + 0x41e3588);
	if (!view_renderer)
		return;

	auto view_matrix_ = memory::read<uintptr_t>(sdk::process, view_renderer + 0x1b3bd0);
	if (!view_matrix_)
		return;

	auto view_matrix = memory::read<sdk::view_matrix_t>(sdk::process, view_matrix_);

	for (int i = 0; i <= 100; i++) {
		auto entity = memory::read<uintptr_t>(sdk::process, (sdk::module_base + 0x1911448) + ((uintptr_t)i << 5));
		if (!entity || entity == local_player)
			continue;

		if (!sdk::is_player(entity))
			continue;

		if (!sdk::is_alive(entity))
			continue;

		if (sdk::get_team(entity) == sdk::get_team(local_player))
			continue;

		sdk::enable_glow(entity, { 124, 223, 100 });

		if (sdk::get_origin(local_player).distance_to(sdk::get_origin(entity)) * 0.01905f > 200) // 200m
			continue;

		auto head_pos = sdk::get_bone_pos(entity, 8);
		vec2_t head_pos_2d{};
		if (!sdk::world_to_screen(view_matrix.matrix, head_pos, head_pos_2d))
			continue;
		
		auto origin_pos = memory::read<vec3_t>(sdk::process, entity + 0x014c);
		vec2_t origin_pos_2d{};
		if (!sdk::world_to_screen(view_matrix.matrix, origin_pos, origin_pos_2d))
			continue;

		const float height = origin_pos_2d.y - head_pos_2d.y;
		const float width = height / 2.f;
		const float y = head_pos_2d.y;
		const float x = origin_pos_2d.x - (width / 2.f);

		render::draw_box(x, y, width, height, 1, { 0, 0, 0 });

		const auto health_height = (height - 2) * ((float)sdk::get_health(entity) / (float)sdk::get_max_health(entity));
		render::draw_filled_box(x - 6, (y + height) - health_height, 3, health_height, { 222, 49, 99 });
		render::draw_box(x - 6 - 1, y, 4, height, 1, { 0, 0, 0 });
	}
}
```

`apex_driver/core/features/features.h`:

```h
#pragma once
#include "..\sdk\sdk.h"

namespace features {
	void esp(uintptr_t local_player);

    void rcs(uintptr_t local_player);
}
```

`apex_driver/core/features/misc.cpp`:

```cpp
#include "features.h"

void features::rcs(uintptr_t local_player) {
	auto view_angles = sdk::get_view_angles(local_player);
	auto punch = sdk::get_aim_punch(local_player) * 2;

	punch.x *= 0.5;
	punch.y *= 0.5;
	punch.z = 0;

	auto rcs_angle = view_angles - punch;
	rcs_angle.normalize();
	sdk::set_view_angles(local_player, rcs_angle);
}
```

`apex_driver/core/hook/hook.cpp`:

```cpp
#include "hook.h"
#include "..\utils\memory\memory.h"

// credits to the dude for this nice hook wrapper, forgot his name 

namespace hook {
	uintptr_t address_original = NULL;

	uintptr_t address_handler = NULL;

	unsigned char original[12] = {};

	unsigned char jmp[12] = { 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0 };

	void init(uintptr_t to_hook, uintptr_t handler) {
		address_original = to_hook;
		address_handler = handler;
		memcpy((void*)original, (void*)to_hook, sizeof(original));
		*(uintptr_t*)(&jmp[2]) = address_handler;
	}	
	
	void set_hook() {
		memory::write_to_read_only_memory((PVOID*)address_original, &jmp, sizeof(jmp));
	}	

	void undo_hook() {
		memory::write_to_read_only_memory((PVOID*)address_original, &original, sizeof(original));
	}
}
```

`apex_driver/core/hook/hook.h`:

```h
#pragma once
#include <ntdef.h>

namespace hook {
	extern uintptr_t address_original;

	extern uintptr_t address_handler;

	extern unsigned char original[12];

	extern unsigned char jmp[12];

	void init(uintptr_t to_hook, uintptr_t handler);

	void set_hook();

	void undo_hook();
}
```

`apex_driver/core/main.cpp`:

```cpp
#include "utils\memory\memory.h"
#include "utils\imports.h"
#include "hook\hook.h"
#include "renderer\renderer.h"
#include "utils\color.h"
#include "utils\hotkeys\hotkeys.h"
#include "sdk\sdk.h"
#include "features\features.h"

typedef struct init_t {
	DWORD		usermode_process_id;
	DWORD		usermode_thread_id;
};

LARGE_INTEGER Timeout;

NTSTATUS hook_handler(PVOID called_param) {
	hook::undo_hook();

	print("hook init called\n");
	
	init_t* init = (init_t*)called_param;
	if (!init)
		return STATUS_UNSUCCESSFUL;

	if (!utils::unlink_thread((HANDLE)init->usermode_process_id, (HANDLE)init->usermode_thread_id)) {
		print("failed to unlink thread");
		return STATUS_UNSUCCESSFUL;
	}

	if (!render::init()) {
		print("failed to initalize render functions\n");
		return STATUS_UNSUCCESSFUL;
	}

	if (!hotkey::init()) {
		print("failed to initalize hotkey functions\n");
		return STATUS_UNSUCCESSFUL;
	}

	bool esp = true, rcs = false;
	while (true) {
		hotkey::update_key_state_bitmap();
		if (hotkey::is_key_down(VK_END)) {
			break;
		}

		// search for game
		if (!sdk::pid) {
			sdk::pid = memory::get_process_id("r5apex.exe");
			if (sdk::pid) {
				if (NT_SUCCESS(PsLookupProcessByProcessId(sdk::pid, &sdk::process))) {
					sdk::module_base = memory::get_module_base_x64(sdk::process);
					print("base : %p\n", sdk::module_base);
					print("pid : %d\n", sdk::pid);
				}
			}

			Timeout.QuadPart = RELATIVE(SECONDS(20));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
		}

		// when game is found
		if (sdk::pid) {
			auto local_player = sdk::get_local_player();
			if (local_player && sdk::is_player(local_player)) {
				if (esp)
					features::esp(local_player);

				if (rcs && hotkey::is_key_down(VK_LBUTTON))
					features::rcs(local_player);
			}
		}

		// settings
		if (hotkey::is_key_down(VK_F1))
			esp = !esp;
		else if (hotkey::is_key_down(VK_F2))
			rcs = !rcs;
	}

	hotkey::clean_up();

	if (sdk::process)
		ObDereferenceObject(sdk::process);

	print("leaving hook\n\n");
	return STATUS_SUCCESS;
}

void real_entry() {
	print("\nreal entry called.\n");

	auto exported_func = memory::get_system_module_export("\\SystemRoot\\System32\\drivers\\dxgkrnl.sys", "NtOpenCompositionSurfaceSectionInfo");
	hook::init((uintptr_t)exported_func, (uintptr_t)hook_handler);
	hook::set_hook();
}

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT  driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);
	return STATUS_SUCCESS;
}
```

`apex_driver/core/renderer/renderer.cpp`:

```cpp
#include "renderer.h"
#include "..\utils\memory\memory.h"
#include "..\utils\color.h"

#define PATCOPY (DWORD)0x00F00021
#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))

namespace render {
	gdi_select_brush_t gdi_select_brush = NULL;

	pal_blt_t nt_gdi_pal_blt = NULL;

	nt_user_get_dc_t nt_user_get_dc = NULL;

	nt_gdi_create_solid_brush_t nt_gdi_create_solid_brush = NULL;

	release_dc_t release_dc = NULL;

	delete_object_app_t delete_object_app = NULL;

	gre_ext_text_out_w_internal_t gre_ext_text_out_w_internal = NULL;

	bool init() {
		gdi_select_brush = (gdi_select_brush_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kfull.sys", "NtGdiSelectBrush");
		if (!gdi_select_brush) {
			print("failed to get gdi_select_brush\n");
			return false;
		}

		nt_gdi_pal_blt = (pal_blt_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kfull.sys", "NtGdiPatBlt");
		if (!nt_gdi_pal_blt) {
			print("failed to get nt_gdi_pal_blt\n");
			return false;
		}

		nt_user_get_dc = (nt_user_get_dc_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kbase.sys", "NtUserGetDC");
		if (!nt_user_get_dc) {
			print("failed to get nt_user_get_dc\n");
			return false;
		}

		nt_gdi_create_solid_brush = (nt_gdi_create_solid_brush_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kfull.sys", "NtGdiCreateSolidBrush");
		if (!nt_gdi_create_solid_brush) {
			print("failed to get nt_gdi_create_solid_brush\n");
			return false;
		}

		release_dc = (release_dc_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kbase.sys", "NtUserReleaseDC");
		if (!release_dc) {
			print("failed to get release_dc\n");
			return false;
		}

		delete_object_app = (delete_object_app_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kbase.sys", "NtGdiDeleteObjectApp");
		if (!delete_object_app) {
			print("failed to get delete_object_app\n");
			return false;
		}
		
		// text rendering stuff, never finished it coulkdnt be fucked, look up gre_ext_text_out_w_internal if u want to finish it 
		//{
		//	uintptr_t address = (uintptr_t)memory::get_system_module_export("\\SystemRoot\\System32\\win32kfull.sys", "NtGdiExtTextOutW");
		//	if (!address) {
		//		print("failed to get gre_ext_text_out_w_internal address\n");
		//		return false;
		//	}

		//	//address = (uintptr_t)memory::pattern_scan((PVOID)address, "\x8B\x54\x24\x78\xE8\xFF\xFF\xFF\xFF\x8B\xF0", "xxxxx????xx");
		//	//if (!address) {
		//	//	print("failed to get scan gre_ext_text_out_w_internal address\n");
		//	//	return false;
		//	//}

		//	//address += 5;
		//	//gre_ext_text_out_w_internal = (gre_ext_text_out_w_internal_t)(address + *reinterpret_cast<INT32*>(address) + sizeof(INT32));

		//	print("address %p\n", address);
		//}

		return true;
	}

	bool frame_rect(HDC hdc, const RECT* lprc, HBRUSH hbr, int thickness) {
		RECT r = *lprc;

		HBRUSH old_brush = gdi_select_brush(hdc, hbr);
		if (!old_brush)
			return false;

		nt_gdi_pal_blt(hdc, r.left, r.top, thickness, r.bottom - r.top, PATCOPY);
		nt_gdi_pal_blt(hdc, r.right - thickness, r.top, thickness, r.bottom - r.top, PATCOPY);
		nt_gdi_pal_blt(hdc, r.left, r.top, r.right - r.left, thickness, PATCOPY);
		nt_gdi_pal_blt(hdc, r.left, r.bottom - thickness, r.right - r.left, thickness, PATCOPY);

		gdi_select_brush(hdc, old_brush);
		return true;
	}
	
	bool filled_rect(HDC hdc, const RECT* lprc, HBRUSH hbr) {
		RECT r = *lprc;

		HBRUSH old_brush = gdi_select_brush(hdc, hbr);
		if (!old_brush)
			return false;

		nt_gdi_pal_blt(hdc, r.left, r.top, r.right - r.left, r.bottom - r.top, PATCOPY);

		gdi_select_brush(hdc, old_brush);
		return true;
	}

	void draw_box(int x, int y, int w, int h, int thickness, color clr) {
		HDC hdc = nt_user_get_dc(NULL);
		if (!hdc)
			return;

		HBRUSH brush = nt_gdi_create_solid_brush(RGB(clr.r, clr.g, clr.b), NULL);
		if (!brush)
			return;

		RECT rect{ x, y, x + w, y + h };
		frame_rect(hdc, &rect, brush, thickness);
		release_dc(hdc);
		delete_object_app(brush);
	}
	
	void draw_filled_box(int x, int y, int w, int h, color clr) {
		HDC hdc = nt_user_get_dc(NULL);
		if (!hdc)
			return;

		HBRUSH brush = nt_gdi_create_solid_brush(RGB(clr.r, clr.g, clr.b), NULL);
		if (!brush)
			return;

		RECT rect{ x, y, x + w, y + h };
		filled_rect(hdc, &rect, brush);
		release_dc(hdc);
		delete_object_app(brush);
	}
}
```

`apex_driver/core/renderer/renderer.h`:

```h
#pragma once
#include "..\utils\imports.h"
#include "..\utils\color.h"

namespace render {
	extern gdi_select_brush_t gdi_select_brush;

	extern pal_blt_t nt_gdi_pal_blt;

	extern nt_user_get_dc_t nt_user_get_dc;

	extern nt_gdi_create_solid_brush_t nt_gdi_create_solid_brush;

	extern release_dc_t release_dc;

	extern delete_object_app_t delete_object_app;

	bool init();

	void draw_box(int x, int y, int w, int h, int thickness, color clr);

	void draw_filled_box(int x, int y, int w, int h, color clr);
}
```

`apex_driver/core/sdk/sdk.cpp`:

```cpp
#include "sdk.h"

namespace sdk {
	HANDLE pid{};

	PEPROCESS process{};

	uintptr_t module_base{};

	uintptr_t get_local_player() {
		return memory::read<uintptr_t>(process, module_base + 0x1cc0ce8);
	}

	bool is_player(uintptr_t player) {
		return (memory::read<uintptr_t>(process, player + 0x0589) == 125780153691248);
	}

	bool is_alive(uintptr_t player) {
		return memory::read<int>(process, player + 0x26c8) == 0 && memory::read<int>(process, player + 0x0798) == 0;
	}

	int get_health(uintptr_t player) {
		return memory::read<int>(process, player + 0x0438);
	}

	int get_max_health(uintptr_t player) {
		return memory::read<int>(process, player + 0x0578);
	}

	int get_team(uintptr_t player) {
		return memory::read<int>(process, player + 0x0448);
	}

	vec3_t get_view_angles(uintptr_t player) {
		return memory::read<vec3_t>(process, player + 0x2518);
	}

	void set_view_angles(uintptr_t player, vec3_t angle) {
		memory::write<vec3_t>(process, player + 0x2518, angle);
	}

	vec3_t get_aim_punch(uintptr_t player) {
		return memory::read<vec3_t>(process, player + 0x2430);
	}

	vec3_t get_origin(uintptr_t player) {
		return memory::read<vec3_t>(process, player + 0x14C);
	}

	vec3_t get_bone_pos(uintptr_t player, int id) {
		vec3_t origin_pos = get_origin(player);
		uintptr_t bones_array = memory::read<uintptr_t>(process, player + 0xf38);
		vec3_t bone_pos{};

		bone_pos.x = memory::read<float>(process, bones_array + 0xCC + (id * 0x30)) + origin_pos.x;
		bone_pos.y = memory::read<float>(process, bones_array + 0xDC + (id * 0x30)) + origin_pos.y;
		bone_pos.z = memory::read<float>(process, bones_array + 0xEC + (id * 0x30)) + origin_pos.z;

		return bone_pos;
	}

	bool world_to_screen(float* view_matrix, vec3_t world, vec2_t& screen) {
		float* m_vMatrix = view_matrix;
		float w = m_vMatrix[12] * world.x + m_vMatrix[13] * world.y + m_vMatrix[14] * world.z + m_vMatrix[15];

		if (w < 0.01f)
			return false;

		screen.x = m_vMatrix[0] * world.x + m_vMatrix[1] * world.y + m_vMatrix[2] * world.z + m_vMatrix[3];
		screen.y = m_vMatrix[4] * world.x + m_vMatrix[5] * world.y + m_vMatrix[6] * world.z + m_vMatrix[7];

		float invw = 1.0f / w;
		screen.x *= invw;
		screen.y *= invw;

		float x = 1920 / 2;
		float y = 1080 / 2;

		x += 0.5 * screen.x * 1920 + 0.5;
		y -= 0.5 * screen.y * 1080 + 0.5;

		screen.x = x;
		screen.y = y;

		if (screen.x > 1920 || screen.x < 0 || screen.y > 1080 || screen.y < 0)
			return false;

		return true;
	}

	void enable_glow(uintptr_t player, color clr) {
		if (memory::read<int>(process, player + 0x1D8) == 2) {
			return;
		}
			
		struct glow_settings { BYTE glow_mode, border_mode, border_size, transparent_level; };
		memory::write<int>(process, player + 0x3c8, 1);
		memory::write<int>(process, player + 0x3d0, 2); 
		memory::write<glow_settings>(process, player + 0x2C4, { 101, 101, 46, 90 });
		memory::write<float>(process, player + 0x1D0, 61.f);  // r
		memory::write<float>(process, player + 0x1D4, 2.f);  // g
		memory::write<float>(process, player + 0x1D8, 2.f);  // b
	}
}
```

`apex_driver/core/sdk/sdk.h`:

```h
#pragma once
#include <ntifs.h>
#include "..\utils\memory\memory.h"
#include "..\utils\math\vectors.h"
#include "..\utils\color.h"

namespace sdk {
	extern HANDLE pid;

	extern PEPROCESS process;

	extern uintptr_t module_base;

	struct view_matrix_t {
		float matrix[16];
	};

	struct bone_t {
		BYTE pad[0xCC];
		float x;
		BYTE pad2[0xC];
		float y;
		BYTE pad3[0xC];
		float z;
	};

	uintptr_t get_local_player();

	bool is_player(uintptr_t player);

	bool is_alive(uintptr_t player);

	int get_health(uintptr_t player);

	int get_max_health(uintptr_t player);

	int get_team(uintptr_t player);

	vec3_t get_view_angles(uintptr_t player);

	void set_view_angles(uintptr_t player, vec3_t angle);

	vec3_t get_aim_punch(uintptr_t player);

	vec3_t get_origin(uintptr_t player);

	vec3_t get_bone_pos(uintptr_t ent, int id);

	bool world_to_screen(float* view_matrix, vec3_t world, vec2_t& screen);

	void enable_glow(uintptr_t ent, color clr);
}
```

`apex_driver/core/utils/color.h`:

```h
#pragma once
#include <ntifs.h>

struct color {
	int a, r, g, b;
	color() = default;

	color(int r, int g, int b, int a = 255) {
		this->r = r;
		this->g = g;
		this->b = b;
		this->a = a;
	}

	color(ULONG color) {
		this->a = (color >> 24) & 0xff;
		this->r = (color >> 16) & 0xff;
		this->g = (color >> 8) & 0xff;
		this->b = (color & 0xff);
	}

	color from_uint(ULONG uint) {
		return color(uint);
	}

	static color black(int a = 255) { return { 0, 0, 0, a }; }
	static color white(int a = 255) { return { 255, 255, 255, a }; }
	static color red(int   a = 255) { return { 255, 0, 0, a }; }
	static color green(int a = 255) { return { 0, 255, 0, a }; }
	static color blue(int  a = 255) { return { 0, 0, 255, a }; }
};
```

`apex_driver/core/utils/hotkeys/hotkeys.cpp`:

```cpp
#include "hotkeys.h"

namespace hotkey {
	PEPROCESS process;

	HANDLE pid;

	PVOID gaf_async_key_state;

	UINT8 key_state_bitmap[256 * 2 / 8]{};

	UINT8 key_state_recent_bitmap[256 / 8]{};

	bool init() {
		pid = memory::get_process_id("csrss.exe", false, 1);
		if (!pid) {
			print("failed to get winlogon pid\n");
			return false;
		}

		if (!NT_SUCCESS(PsLookupProcessByProcessId(pid, &process))) {
			print("failed to get winlogon process\n");
			return false;
		}

		gaf_async_key_state = memory::get_system_module_export("\\SystemRoot\\System32\\win32kbase.sys", "gafAsyncKeyState");
		if (!gaf_async_key_state) {
			print("failed to get gaf_async_key_state\n");
			return false;
		}
	}

	void clean_up() {
		ObDereferenceObject(process);
	}

	bool is_key_down(UINT8 const vk) {
		key_state_recent_bitmap[vk / 8] &= ~(1 << vk % 8); // works when placing this line here
		return key_state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2;
	}

	bool was_key_pressed(UINT8 const vk) { // doesnt work idk
		bool const result = key_state_recent_bitmap[vk / 8] & 1 << vk % 8;
		key_state_recent_bitmap[vk / 8] &= ~(1 << vk % 8);
		return result;
	}

	void update_key_state_bitmap() {
		auto prev_key_state_bitmap = key_state_bitmap;
		SIZE_T size = 0;

		MmCopyVirtualMemory(process,
			gaf_async_key_state,
			PsGetCurrentProcess(), &key_state_bitmap,
			256 * 2 / 8, KernelMode,
			&size);

		for (auto vk = 0u; vk < 256; ++vk) {
			if ((key_state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2) &&
				!(prev_key_state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2))
				key_state_recent_bitmap[vk / 8] |= 1 << vk % 8;
		}
	}
}
```

`apex_driver/core/utils/hotkeys/hotkeys.h`:

```h
#pragma once
#include "..\memory\memory.h"

namespace hotkey {
	bool init();

	void clean_up();

	bool is_key_down(UINT8 const vk);

	bool was_key_pressed(UINT8 const vk);

	void update_key_state_bitmap();
}

/*
 * 0x07 : reserved
 */


#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02

#define VK_BACK           0x08
#define VK_TAB            0x09

 /*
  * 0x0A - 0x0B : reserved
  */

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

  /*
   * 0x0E - 0x0F : unassigned
   */

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14

#define VK_KANA           0x15
#define VK_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VK_HANGUL         0x15
#define VK_IME_ON         0x16
#define VK_JUNJA          0x17
#define VK_FINAL          0x18
#define VK_HANJA          0x19
#define VK_KANJI          0x19
#define VK_IME_OFF        0x1A

#define VK_ESCAPE         0x1B

#define VK_CONVERT        0x1C
#define VK_NONCONVERT     0x1D
#define VK_ACCEPT         0x1E
#define VK_MODECHANGE     0x1F

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

   /*
	* VK_0 - VK_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
	* 0x3A - 0x40 : unassigned
	* VK_A - VK_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
	*/

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

	/*
	 * 0x5E : reserved
	 */

#define VK_SLEEP          0x5F

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#if(_WIN32_WINNT >= 0x0604)

	 /*
	  * 0x88 - 0x8F : UI navigation
	  */

#define VK_NAVIGATION_VIEW     0x88 // reserved
#define VK_NAVIGATION_MENU     0x89 // reserved
#define VK_NAVIGATION_UP       0x8A // reserved
#define VK_NAVIGATION_DOWN     0x8B // reserved
#define VK_NAVIGATION_LEFT     0x8C // reserved
#define VK_NAVIGATION_RIGHT    0x8D // reserved
#define VK_NAVIGATION_ACCEPT   0x8E // reserved
#define VK_NAVIGATION_CANCEL   0x8F // reserved

#endif /* _WIN32_WINNT >= 0x0604 */

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

	  /*
	   * NEC PC-9800 kbd definitions
	   */
#define VK_OEM_NEC_EQUAL  0x92   // '=' key on numpad

	   /*
		* Fujitsu/OASYS kbd definitions
		*/
#define VK_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VK_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VK_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VK_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VK_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

		/*
		 * 0x97 - 0x9F : unassigned
		 */

		 /*
		  * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
		  * Used only as parameters to GetAsyncKeyState() and GetKeyState().
		  * No other API or message will distinguish left and right keys in this way.
		  */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

```

`apex_driver/core/utils/imports.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntimage.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntstrsafe.h>

typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING     Name;
	PVOID             ModuleStart;
	PVOID             ModuleEnd;
	ULONG64         UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;
typedef struct _PIDDBCACHE_ENTRY
{
	LIST_ENTRY        List;
	UNICODE_STRING    DriverName;
	ULONG            TimeDateStamp;
	NTSTATUS        LoadStatus;
	char            _0x0028[16];
} PIDDBCACHE_ENTRY, * PPIDDBCACHE_ENTRY;

typedef struct _SYSTEM_MODULEE
{
	ULONG_PTR Reserved[2];
	PVOID     Base;
	ULONG     Size;
	ULONG     Flags;
	USHORT    Index;
	USHORT    Unknown;
	USHORT    LoadCount;
	USHORT    ModuleNameOffset;
	CHAR      ImageName[256];
} SYSTEM_MODULEE, * PSYSTEM_MODULEE;
typedef struct _SYSTEM_MODULE_INFORMATIONN
{
	ULONG_PTR     ModuleCount;
	SYSTEM_MODULEE Modules[1];
} SYSTEM_MODULE_INFORMATIONN, * PSYSTEM_MODULE_INFORMATIONN;

typedef struct _ETHREAD_META_2004
{
	char pad_0x0008[0x448]; //0x0008
	PVOID StartAddress; //0x0450 
	char pad_0x0458[0x20]; //0x0458
	_CLIENT_ID Cid; //0x0478 
	char pad_0x0480[0x50]; //0x0480
	PVOID Win32StartAddress; //0x04D0 
	char pad_0x04D8[0x10]; //0x04D8
	struct _LIST_ENTRY ThreadListEntry; //0x04E8 
} ETHREAD_META_2004, * PETHREAD_META_2004; /* size: 0x0898 */

typedef struct PiDDBCacheEntry {
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16];
}PIDCacheobj;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESS_INFO {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder;
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void); // not exported

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
	//    PVOID			LoadedImports;
	//    // seems they are exist only on XP !!! PVOID
	//    EntryPointActivationContext;	// -same-
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _STOR_SCSI_IDENTITY {
	char Space[0x8]; // +0x008 SerialNumber     : _STRING
	STRING SerialNumber;
} STOR_SCSI_IDENTITY, * PSTOR_SCSI_IDENTITY;

typedef struct _TELEMETRY_UNIT_EXTENSION {
	/*
		+0x000 Flags            : <anonymous-tag>
		+0x000 DeviceHealthEventsLogged : Pos 0, 1 Bit
		+0x000 FailedFirstSMARTCommand : Pos 1, 1 Bit
		+0x000 FailedFirstDeviceStatisticsLogCommand : Pos 2, 1 Bit
		+0x000 FailedFirstNvmeCloudSSDCommand : Pos 3, 1 Bit
		+0x000 SmartPredictFailure : Pos 4, 1 Bit
		+0x000 Reserved         : Pos 5, 27 Bits
	 */
	int SmartMask;
} TELEMETRY_UNIT_EXTENSION, * PTELEMETRY_UNIT_EXTENSION;

// lkd> dt storport!_RAID_UNIT_EXTENSION -b
typedef struct _RAID_UNIT_EXTENSION {
	union
	{
		struct
		{
			char Space[0x68]; // +0x068 Identity         : _STOR_SCSI_IDENTITY
			STOR_SCSI_IDENTITY Identity;
		} _Identity;

		struct
		{
			char Space[0x7c8]; // +0x7c8 TelemetryExtension : _TELEMETRY_UNIT_EXTENSION
			TELEMETRY_UNIT_EXTENSION Telemetry;
		} _Smart;
	};
} RAID_UNIT_EXTENSION, * PRAID_UNIT_EXTENSION;


extern "C" NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);

typedef __int64(__fastcall* RaidUnitRegisterInterfaces)(PRAID_UNIT_EXTENSION a1);

typedef NTSTATUS(__fastcall* DiskEnableDisableFailurePrediction)(void* a1, bool a2);

extern "C" __declspec(dllimport) NTSTATUS NTAPI ZwProtectVirtualMemory
(
	HANDLE ProcessHandle,
	PVOID * BaseAddress,
	PSIZE_T ProtectSize,
	ULONG NewProtect,
	PULONG OldProtect
);

extern "C" NTKERNELAPI PVOID NTAPI RtlFindExportedRoutineByName(_In_ PVOID ImageBase, _In_ PCCH RoutineName);

extern "C" NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

extern "C" NTKERNELAPI PPEB PsGetProcessPeb(IN PEPROCESS Process);

extern "C" NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(PVOID Base);

extern "C" NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(__in PEPROCESS Process);

extern "C" NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

extern "C" NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName(
	PUNICODE_STRING ObjectName,
	ULONG Attributes,
	PACCESS_STATE AccessState,
	ACCESS_MASK DesiredAccess,
	POBJECT_TYPE ObjectType,
	KPROCESSOR_MODE AccessMode,
	PVOID ParseContext OPTIONAL,
	PVOID* Object
);

extern "C" NTKERNELAPI
NTSTATUS
NTAPI
PsGetContextThread(
	__in PETHREAD Thread,
	__inout PCONTEXT ThreadContext,
	__in KPROCESSOR_MODE Mode
);

extern "C" NTKERNELAPI
NTSTATUS
NTAPI
PsSetContextThread(
	__in PETHREAD Thread,
	 __in PCONTEXT ThreadContext,
	 __in KPROCESSOR_MODE PreviousMode
	);

typedef HBRUSH(*gdi_select_brush_t)(_In_ HDC hdc, _In_ HBRUSH hbr);

typedef BOOL(*pal_blt_t)(_In_ HDC, _In_ int x, _In_ int y, _In_ int w, _In_ int h, _In_ DWORD);

typedef HDC(*nt_user_get_dc_t)(HWND hwnd);

typedef HBRUSH(*nt_gdi_create_solid_brush_t)(_In_ COLORREF color, _In_opt_ HBRUSH hbr);

typedef int (*release_dc_t)(HDC hdc);

typedef BOOL(*delete_object_app_t)(HANDLE handle);

typedef void(*gre_ext_text_out_w_internal_t)(_In_ HDC dc, int left, int top, UINT64, UINT64, LPCWSTR text, UINT32 textSize, UINT64, UINT64, UINT64);
```

`apex_driver/core/utils/math/vectors.cpp`:

```cpp
#include "vectors.h"

extern "C" unsigned int _fltused = 0; 

vec3_t::vec3_t(void) {
	x = y = z = 0.0f;
}

vec3_t::vec3_t(float fx, float fy, float fz) {
	x = fx;
	y = fy;
	z = fz;
}

vec3_t::~vec3_t(void) {
};

void vec3_t::init(float ix, float iy, float iz) {
	x = ix; y = iy; z = iz;
}

float vec3_t::normalize_float() {
	vec3_t res = *this;
	float l = res.length();
	if (l != 0.0f) {
		res /= l;
	}
	else {
		res.x = res.y = res.z = 0.0f;
	}
	return l;
}

float vec3_t::distance_to(const vec3_t& other) {
	vec3_t delta;
	delta.x = x - other.x;
	delta.y = y - other.y;
	delta.z = z - other.z;

	return delta.length();
}

void vec3_t::normalize(void) {
	auto vec_normalize = [&](vec3_t& v) {
		auto l = v.length();

		if (l != 0.0f) {
			v.x /= l;
			v.y /= l;
			v.z /= l;
		}
		else {
			v.x = v.y = 0.0f; v.z = 1.0f;
		}

		return l;
	};

	vec_normalize(*this);
}

vec3_t vec3_t::normalized(void) {
	vec3_t vec(*this);
	vec.normalize();

	return vec;
}

float vec3_t::length(void) {
	auto sqr = [](float n) {
		return static_cast<float>(n * n);
	};

	return sqrt(sqr(x) + sqr(y) + sqr(z));
}

float vec3_t::length_2d_sqr(void) const {
	return (x * x + y * y);
}

float vec3_t::dot(const vec3_t other) {
	return (x * other.x + y * other.y + z * other.z);
}

float vec3_t::dot(const float* other) {
	const vec3_t& a = *this;

	return(a.x * other[0] + a.y * other[1] + a.z * other[2]);
}

```

`apex_driver/core/utils/math/vectors.h`:

```h
#pragma once
#include <math.h>


#define M_PI 3.14159265358979323846
#define M_RADPI		57.295779513082f
#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.
#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )
#define DEG2RAD( x  )  ( (float)(x) * (float)(M_PI_F / 180.f) )

#define ASSERT( _exp ) ( (void ) 0 )

template <typename T>
T clip_number(const T& n, const T& lower, const T& upper) {
	if (n < lower) return lower;
	if (n > upper) return upper;
	return n;s
}

class vec3_t {
public:
	vec3_t();
	vec3_t(float, float, float);
	~vec3_t();

	float x, y, z;

	vec3_t& operator+=(const vec3_t& v) {
		x += v.x; y += v.y; z += v.z; return *this;
	}
	vec3_t& operator-=(const vec3_t& v) {
		x -= v.x; y -= v.y; z -= v.z; return *this;
	}
	vec3_t& operator*=(float v) {
		x *= v; y *= v; z *= v; return *this;
	}
	bool operator==(const vec3_t& v) {
		return (x == v.x) && (y == v.y);
	}
	vec3_t operator+(const vec3_t& v) {
		return vec3_t{ x + v.x, y + v.y, z + v.z };
	}
	vec3_t operator-(const vec3_t& v) {
		return vec3_t{ x - v.x, y - v.y, z - v.z };
	}
	vec3_t operator*(float fl) const {
		return vec3_t(x * fl, y * fl, z * fl);
	}
	vec3_t operator*(const vec3_t& v) const {
		return vec3_t(x * v.x, y * v.y, z * v.z);
	}
	vec3_t& operator/=(float fl) {
		x /= fl;
		y /= fl;
		z /= fl;
		return *this;
	}
	auto operator-(const vec3_t& other) const -> vec3_t {
		auto buf = *this;

		buf.x -= other.x;
		buf.y -= other.y;
		buf.z -= other.z;

		return buf;
	}

	auto operator/(float other) const {
		vec3_t vec;
		vec.x = x / other;
		vec.y = y / other;
		vec.z = z / other;
		return vec;
	}

	float& operator[](int i) {
		return ((float*)this)[i];
	}
	float operator[](int i) const {
		return ((float*)this)[i];
	}

	inline float Length2D() const
	{
		return sqrt((x * x) + (y * y));
	}

	void crossproduct(vec3_t v1, vec3_t v2, vec3_t cross_p) const //ijk = xyz
	{
		cross_p.x = (v1.y * v2.z) - (v1.z * v2.y); //i
		cross_p.y = -((v1.x * v2.z) - (v1.z * v2.x)); //j
		cross_p.z = (v1.x * v2.y) - (v1.y * v2.x); //k
	}
	vec3_t Cross(const vec3_t& vOther) const
	{
		vec3_t res;
		crossproduct(*this, vOther, res);
		return res;
	}

	void init(float ix, float iy, float iz);
	vec3_t normalized();
	float normalize_float();
	float distance_to(const vec3_t& other);
	void normalize();
	float length();
	float length_2d_sqr(void) const;
	float dot(const vec3_t other);
	float dot(const float* other);
};

// has to be hear
inline vec3_t operator*(float lhs, const vec3_t& rhs) {
	return vec3_t(rhs.x * lhs, rhs.x * lhs, rhs.x * lhs);
}

struct matrix_t
{
	matrix_t() { }
	matrix_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23)
	{
		mat_val[0][0] = m00;	mat_val[0][1] = m01; mat_val[0][2] = m02; mat_val[0][3] = m03;
		mat_val[1][0] = m10;	mat_val[1][1] = m11; mat_val[1][2] = m12; mat_val[1][3] = m13;
		mat_val[2][0] = m20;	mat_val[2][1] = m21; mat_val[2][2] = m22; mat_val[2][3] = m23;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	void init(const vec3_t& xAxis, const vec3_t& yAxis, const vec3_t& zAxis, const vec3_t& vecOrigin)
	{
		mat_val[0][0] = xAxis.x; mat_val[0][1] = yAxis.x; mat_val[0][2] = zAxis.x; mat_val[0][3] = vecOrigin.x;
		mat_val[1][0] = xAxis.y; mat_val[1][1] = yAxis.y; mat_val[1][2] = zAxis.y; mat_val[1][3] = vecOrigin.y;
		mat_val[2][0] = xAxis.z; mat_val[2][1] = yAxis.z; mat_val[2][2] = zAxis.z; mat_val[2][3] = vecOrigin.z;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	matrix_t(const vec3_t& xAxis, const vec3_t& yAxis, const vec3_t& zAxis, const vec3_t& vecOrigin)
	{
		init(xAxis, yAxis, zAxis, vecOrigin);
	}

	inline void set_origin(vec3_t const& p)
	{
		mat_val[0][3] = p.x;
		mat_val[1][3] = p.y;
		mat_val[2][3] = p.z;
	}

	float* operator[](int i) { ASSERT((i >= 0) && (i < 3)); return mat_val[i]; }
	const float* operator[](int i) const { ASSERT((i >= 0) && (i < 3)); return mat_val[i]; }
	float* base() { return &mat_val[0][0]; }
	const float* base() const { return &mat_val[0][0]; }

	float mat_val[3][4];
};

class vec2_t {
public:
	float x, y;

	vec2_t() {
		x = 0; y = 0;
	};
	vec2_t(float X, float Y) {
		x = X; y = Y;
	};
	vec2_t(vec3_t vec) {
		x = vec.x; y = vec.y;
	}

	inline vec2_t operator*(const float n) const {
		return vec2_t(x * n, y * n);
	}
	inline vec2_t operator+(const vec2_t& v) const {
		return vec2_t(x + v.x, y + v.y);
	}
	inline vec2_t operator-(const vec2_t& v) const {
		return vec2_t(x - v.x, y - v.y);
	}
	inline void operator+=(const vec2_t& v) {
		x += v.x;
		y += v.y;
	}
	inline void operator-=(const vec2_t& v) {
		x -= v.x;
		y -= v.y;
	}

	bool operator==(const vec2_t& v) const {
		return (v.x == x && v.y == y);
	}
	bool operator!=(const vec2_t& v) const {
		return (v.x != x || v.y != y);
	}

	inline float length() {
		return sqrt((x * x) + (y * y));
	}
};
```

`apex_driver/core/utils/memory/memory.cpp`:

```cpp
#pragma once
#include "memory.h"

namespace memory {
	PVOID pattern_scan(PVOID base, const char* pattern, const char* mask) {
		auto check_mask = [](const char* base, const char* pattern, const char* mask) -> bool {
			for (; *mask; ++base, ++pattern, ++mask) {
				if ('x' == *mask && *base != *pattern) {
					return false;
				}
			}

			return true;
		};

		auto find_pattern = [&check_mask](PVOID base, int length, const char* pattern, const char* mask) -> PVOID {
			length -= static_cast<int>(strlen(mask));
			for (auto i = 0; i <= length; ++i)
			{
				const auto* data = static_cast<char*>(base);
				const auto* address = &data[i];
				if (check_mask(address, pattern, mask))
					return PVOID(address);
			}

			return nullptr;
		};

		PVOID match = nullptr;

		auto* headers = reinterpret_cast<PIMAGE_NT_HEADERS>(static_cast<char*>(base) + static_cast<PIMAGE_DOS_HEADER>(base)->e_lfanew);
		auto* sections = IMAGE_FIRST_SECTION(headers);

		for (auto i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
			auto* section = &sections[i];
			if ('EGAP' == *reinterpret_cast<PINT>(section->Name) || memcmp(section->Name, ".text", 5) == 0) {
				match = find_pattern(static_cast<char*>(base) + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
				if (match)
					break;
			}
		}

		return match;
	}

	PVOID get_system_module_base(const char* module_name) {
		ULONG bytes = 0;
		NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
		if (!bytes)
			return 0;

		PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 0x454E4F45); // 'ENON'
		status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes);
		if (!NT_SUCCESS(status))
			return 0;

		PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
		PVOID module_base = 0, module_size = 0;

		for (ULONG i = 0; i < modules->NumberOfModules; i++) {
			if (strcmp((char*)module[i].FullPathName, module_name) == 0) {
				module_base = module[i].ImageBase;
				module_size = (PVOID)module[i].ImageSize;
				break;
			}
		}

		if (modules)
			ExFreePoolWithTag(modules, 0);

		if (module_base <= 0)
			return 0;

		return module_base;
	}

	ULONG64 get_module_base_x64(PEPROCESS proc) {
		return (ULONG64)PsGetProcessSectionBaseAddress(proc);
	}

	PVOID get_import_module_base(PEPROCESS target_proc, const char* module_name) {
		auto module_name_unicode = utils::char_to_unicode(module_name);

		PVOID base = 0;
		KeAttachProcess((PKPROCESS)target_proc);

		PPEB peb = PsGetProcessPeb(target_proc);
		if (!peb)
			goto end;

		if (!peb->Ldr || !peb->Ldr->Initialized)
			goto end;

		for (PLIST_ENTRY list = peb->Ldr->ModuleListLoadOrder.Flink;
			list != &peb->Ldr->ModuleListLoadOrder;
			list = list->Flink) {
			PLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
			if (RtlCompareUnicodeString(&entry->BaseDllName, &module_name_unicode, TRUE) == 0) {
				base = entry->DllBase;
				goto end;
			}
		}

	end:
		KeDetachProcess();
		return base;
	}

	HANDLE get_process_id(const char* process_name, bool print, int index) {
		ULONG buffer_size = 0;
		ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &buffer_size);

		auto buffer = ExAllocatePoolWithTag(NonPagedPool, buffer_size, 'mder');
		if (!buffer) {
			print("failed to allocate pool (get_process_id)");
			return 0;
		}

		HANDLE pid = 0;
		auto search_index = 0;
		auto process_name_unicode = utils::char_to_unicode(process_name);
		auto process_info = (PSYSTEM_PROCESS_INFO)buffer;
		if (NT_SUCCESS(ZwQuerySystemInformation(SystemProcessInformation, process_info, buffer_size, NULL))) {
			while (process_info->NextEntryOffset) {
				if (!RtlCompareUnicodeString(&process_name_unicode, &process_info->ImageName, true)) {
					if (search_index == index) {
						if (print)
							print("process name: %wZ | process ID: %d\n", process_info->ImageName, process_info->UniqueProcessId);
						pid = process_info->UniqueProcessId;
						break;
					}
					search_index++;
				}
				process_info = (PSYSTEM_PROCESS_INFO)((BYTE*)process_info + process_info->NextEntryOffset);
			}
		}

		RtlFreeUnicodeString(&process_name_unicode);
		ExFreePoolWithTag(buffer, 'mder');
		return pid;
	}

	PVOID get_system_module_export(const char* module_name, LPCSTR routine_name) {
		PVOID lpModule = memory::get_system_module_base(module_name);

		if (!lpModule)
			return NULL;

		return RtlFindExportedRoutineByName(lpModule, routine_name);
	}

	bool write_to_read_only_memory(void* address, void* buffer, size_t size) {

		PMDL Mdl = IoAllocateMdl(address, size, FALSE, FALSE, NULL);

		if (!Mdl)
			return false;

		// Locking and mapping memory with RW-rights:
		MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
		PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
		MmProtectMdlSystemAddress(Mdl, PAGE_READWRITE);

		// Write your buffer to mapping:
		RtlCopyMemory(Mapping, buffer, size);

		// Resources freeing:
		MmUnmapLockedPages(Mapping, Mdl);
		MmUnlockPages(Mdl);
		IoFreeMdl(Mdl);

		return true;
	}

	ULONG virtual_protect(HANDLE pid, PVOID address, ULONG size, ULONG protection) {
		if (!pid || !address || !size || !protection)
			return STATUS_INVALID_PARAMETER;

		NTSTATUS status = STATUS_SUCCESS;
		PEPROCESS target_process = nullptr;

		if (!NT_SUCCESS(PsLookupProcessByProcessId(reinterpret_cast<HANDLE>(pid), &target_process)))
			return STATUS_NOT_FOUND;

		ULONG protection_old = 0;
		SIZE_T size_t = size;

		KAPC_STATE state;
		KeStackAttachProcess(target_process, &state);

		status = ZwProtectVirtualMemory(NtCurrentProcess(), &address, &size_t, protection, &protection_old);
		print("virtual protect %X", status);

		KeUnstackDetachProcess(&state);

		ObDereferenceObject(target_process);
		return protection_old;
	}

	PVOID virtual_allocate(HANDLE pid, ULONG allocation_type, ULONG protection, ULONG size) {
		PEPROCESS process;
		if (!NT_SUCCESS(PsLookupProcessByProcessId(pid, &process))) {
			print("process lookup failed (virtual_allocate)");
			return false;
		}

		SIZE_T bytes = size;
		PVOID allocation_address = NULL;
		KAPC_STATE apc;
		KeStackAttachProcess(process, &apc);
		auto status = ZwAllocateVirtualMemory(ZwCurrentProcess(), &allocation_address, 0, &bytes, allocation_type, protection);
		KeUnstackDetachProcess(&apc);
		ObfDereferenceObject(process);
		return allocation_address;
	}
}
```

`apex_driver/core/utils/memory/memory.h`:

```h
#pragma once
#include "..\imports.h"
#include "..\utils.h"
#include "..\physical\physical.h"

namespace memory {
	PVOID pattern_scan(PVOID base, const char* pattern, const char* mask);

	PVOID get_system_module_base(const char* module_name);

	ULONG64 get_module_base_x64(PEPROCESS proc);

	PVOID get_import_module_base(PEPROCESS target_proc, const char* module_name);

	HANDLE get_process_id(const char* process_name, bool print = false, int index = 0);

	PVOID get_system_module_export(const char* module_name, LPCSTR routine_name);

	bool write_to_read_only_memory(void* address, void* buffer, size_t size);

	template <typename type>
	type read(PEPROCESS proccess, uintptr_t address, bool phsical_memeory=true) {
		type buffer{};
		if (!proccess || !address || (ULONGLONG)address > 0x7fffffffffff)
			return buffer;

		if (!phsical_memeory) {
			SIZE_T bytes = 0;
			MmCopyVirtualMemory(proccess, (PVOID)address, PsGetCurrentProcess(), &buffer, sizeof(type), KernelMode, &bytes);
			return buffer;
		}
		else {
			SIZE_T out_size{};
			if (NT_SUCCESS(physical::read(proccess, (PVOID)address, &buffer, sizeof(type), &out_size)))
				return buffer;
			else 
				return {};
		}
	}

	template <typename type>
	bool write(PEPROCESS proccess, uintptr_t address, type value, bool phsical_memeory = true) {
		if (!proccess || !address || (ULONGLONG)address > 0x7fffffffffff)
			return false;

		if (!phsical_memeory) {
			SIZE_T bytes = 0;
			return MmCopyVirtualMemory(PsGetCurrentProcess(), &value, proccess, (PVOID)address, sizeof(value), KernelMode, &bytes) == STATUS_SUCCESS;
		}
		else {
			SIZE_T out_size{};
			return physical::write(proccess, (PVOID)address, &value, sizeof(value), &out_size) == STATUS_SUCCESS;
		}
	}

	ULONG virtual_protect(HANDLE pid, PVOID address, ULONG size, ULONG protection);

	PVOID virtual_allocate(HANDLE pid, ULONG allocation_type, ULONG protection, ULONG size);
}
```

`apex_driver/core/utils/physical/physical.cpp`:

```cpp
#include "physical.h"

NTKERNELAPI
PVOID
PsGetProcessSectionBaseAddress(
	__in PEPROCESS Process
);

//https://ntdiff.github.io/
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H1 20180

DWORD GetUserDirectoryTableBaseOffset()
{
	RTL_OSVERSIONINFOW ver = { 0 };
	RtlGetVersion(&ver);

	switch (ver.dwBuildNumber)
	{
	case WINDOWS_1803:
		return 0x0278;
		break;
	case WINDOWS_1809:
		return 0x0278;
		break;
	case WINDOWS_1903:
		return 0x0280;
		break;
	case WINDOWS_1909:
		return 0x0280;
		break;
	case WINDOWS_2004:
		return 0x0388;
		break;
	case WINDOWS_20H2:
		return 0x0388;
		break;
	case WINDOWS_21H1:
		return 0x0388;
		break;
	default:
		return 0x0388;
	}
}

//check normal dirbase if 0 then get from UserDirectoryTableBas
ULONG_PTR GetProcessCr3(PEPROCESS pProcess)
{
	PUCHAR process = (PUCHAR)pProcess;
	ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	if (process_dirbase == 0)
	{
		DWORD UserDirOffset = GetUserDirectoryTableBaseOffset();
		ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + UserDirOffset);
		return process_userdirbase;
	}
	return process_dirbase;
}
ULONG_PTR GetKernelDirBase()
{
	PUCHAR process = (PUCHAR)PsGetCurrentProcess();
	ULONG_PTR cr3 = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
	return cr3;
}


#define PAGE_OFFSET_SIZE 12
static const ULONG64 PMASK = (~0xfull << 8) & 0xfffffffffull;

NTSTATUS ReadPhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead)
{
	MM_COPY_ADDRESS AddrToRead = { 0 };
	AddrToRead.PhysicalAddress.QuadPart = (LONGLONG)TargetAddress;
	return MmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, BytesRead);
}


ULONG64 TranslateLinearAddress(ULONG64 directoryTableBase, ULONG64 virtualAddress) {
	directoryTableBase &= ~0xf;

	ULONG64 pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
	ULONG64 pte = ((virtualAddress >> 12) & (0x1ffll));
	ULONG64 pt = ((virtualAddress >> 21) & (0x1ffll));
	ULONG64 pd = ((virtualAddress >> 30) & (0x1ffll));
	ULONG64 pdp = ((virtualAddress >> 39) & (0x1ffll));

	SIZE_T readsize = 0;
	ULONG64 pdpe = 0;
	ReadPhysicalAddress((PVOID)(directoryTableBase + 8 * pdp), &pdpe, sizeof(pdpe), &readsize);
	if (~pdpe & 1)
		return 0;

	ULONG64 pde = 0;
	ReadPhysicalAddress((PVOID)((pdpe & PMASK) + 8 * pd), &pde, sizeof(pde), &readsize);
	if (~pde & 1)
		return 0;

	/* 1GB large page, use pde's 12-34 bits */
	if (pde & 0x80)
		return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

	ULONG64 pteAddr = 0;
	ReadPhysicalAddress((PVOID)((pde & PMASK) + 8 * pt), &pteAddr, sizeof(pteAddr), &readsize);
	if (~pteAddr & 1)
		return 0;

	/* 2MB large page */
	if (pteAddr & 0x80)
		return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

	virtualAddress = 0;
	ReadPhysicalAddress((PVOID)((pteAddr & PMASK) + 8 * pte), &virtualAddress, sizeof(virtualAddress), &readsize);
	virtualAddress &= PMASK;

	if (!virtualAddress)
		return 0;

	return virtualAddress + pageOffset;
}

NTSTATUS ReadVirtual(ULONG64 dirbase, ULONG64 address, BYTE* buffer, SIZE_T size, SIZE_T* read)
{
	ULONG64 paddress = TranslateLinearAddress(dirbase, address);
	return ReadPhysicalAddress((PVOID)paddress, buffer, size, read);
}

NTSTATUS WritePhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten)
{
	if (!TargetAddress)
		return STATUS_UNSUCCESSFUL;

	PHYSICAL_ADDRESS AddrToWrite = { 0 };
	AddrToWrite.QuadPart = (LONGLONG)TargetAddress;

	PVOID pmapped_mem = MmMapIoSpaceEx(AddrToWrite, Size, PAGE_READWRITE);

	if (!pmapped_mem)
		return STATUS_UNSUCCESSFUL;

	memcpy(pmapped_mem, lpBuffer, Size);

	*BytesWritten = Size;
	MmUnmapIoSpace(pmapped_mem, Size);
	return STATUS_SUCCESS;
}

NTSTATUS WriteVirtual(ULONG64 dirbase, ULONG64 address, BYTE* buffer, SIZE_T size, SIZE_T* written)
{
	ULONG64 paddress = TranslateLinearAddress(dirbase, address);
	return WritePhysicalAddress((PVOID)paddress, buffer, size, written);
}

//MmMapIoSpaceEx limit is page 4096 byte



namespace physical {
	NTSTATUS read(PEPROCESS pProcess, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* read) {
		NTSTATUS NtRet{};

		ULONG_PTR process_dirbase = GetProcessCr3(pProcess);

		SIZE_T CurOffset = 0;
		SIZE_T TotalSize = size;
		while (TotalSize)
		{

			ULONG64 CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
			if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

			ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
			SIZE_T BytesRead = 0;
			NtRet = ReadPhysicalAddress((PVOID)CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), ReadSize, &BytesRead);
			TotalSize -= BytesRead;
			CurOffset += BytesRead;
			if (NtRet != STATUS_SUCCESS) break;
			if (BytesRead == 0) break;
		}

		*read = CurOffset;
		return NtRet;
	}

	NTSTATUS write(PEPROCESS pProcess, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* written) {
		ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
		NTSTATUS NtRet{};
		SIZE_T CurOffset = 0;
		SIZE_T TotalSize = size;
		while (TotalSize)
		{
			ULONG64 CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
			if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

			ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
			SIZE_T BytesWritten = 0;
			NtRet = WritePhysicalAddress((PVOID)CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), WriteSize, &BytesWritten);
			TotalSize -= BytesWritten;
			CurOffset += BytesWritten;
			if (NtRet != STATUS_SUCCESS) break;
			if (BytesWritten == 0) break;
		}

		*written = CurOffset;
		return NtRet;
	}
}

```

`apex_driver/core/utils/physical/physical.h`:

```h
#pragma once
#include "..\imports.h"

namespace physical {
	NTSTATUS read(PEPROCESS pProcess, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* read);

	NTSTATUS write(PEPROCESS pProcess, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* written);
}
```

`apex_driver/core/utils/utils.cpp`:

```cpp
#include "utils.h"
#include "imports.h"

namespace utils {
	UNICODE_STRING char_to_unicode(const char* convert) {
		ANSI_STRING ansi = {};
		UNICODE_STRING uni = {};
		RtlInitAnsiString(&ansi, convert);
		if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&uni, &ansi, TRUE))) {
			RtlFreeAnsiString(&ansi);
		}
		return uni;
	}

	LIST_ENTRY old{};

	// pair this with function relink_threads when leaving hook or else bsod. This is an alternatvie to the funciton below, but I diiodnt do this one becaue its suspisocus with a process wiht no
	// theeads (not possible) and this was just a lazy implemneation
    bool unlink_threadlist_head(HANDLE process_id) {
		if (!process_id) {
			print("invalid process id\n");
			return false;
		}

		PEPROCESS process = nullptr;
		if (NT_SUCCESS(PsLookupProcessByProcessId(process_id, &process))) {
			LIST_ENTRY* thread_list_head = (LIST_ENTRY*)make_ptr(process, 0x5e0);
			if (!thread_list_head) {
				print("failed to get thread list head");
				ObDereferenceObject(process);
				return false;
			}

			old.Blink = thread_list_head->Blink;
			old.Flink = thread_list_head->Flink;
			thread_list_head->Blink = thread_list_head;
			thread_list_head->Flink = thread_list_head;

			print("removed all threads from linked list\n");
			ObDereferenceObject(process);
			return true;
		}
		
		return false;
    }

	bool unlink_thread(HANDLE process_id, HANDLE thread_id) {
		PEPROCESS process = nullptr;
		if (NT_SUCCESS(PsLookupProcessByProcessId(process_id, &process))) {
			PETHREAD thread = nullptr;
			if (NT_SUCCESS(PsLookupThreadByThreadId(thread_id, &thread))) {
				LIST_ENTRY* thread_list_head = (LIST_ENTRY*)make_ptr(process, 0x5e0);
				if (!thread_list_head) {
					print("failed to get thread list head");
					ObDereferenceObject(process);
					return false;
				}

				PLIST_ENTRY list = thread_list_head;
				while ((list = list->Flink) != thread_list_head) { // thxs russian man on unkwn
					PETHREAD_META_2004 p_entry = CONTAINING_RECORD(list, ETHREAD_META_2004, ThreadListEntry);
					UINT64 current_tid = (UINT64)PsGetThreadId((PETHREAD)p_entry);
					if (current_tid == (UINT64)thread_id) {
						PETHREAD_META_2004 p_previous_entry = CONTAINING_RECORD(list->Blink, ETHREAD_META_2004, ThreadListEntry);
						PETHREAD_META_2004 p_next_entry = CONTAINING_RECORD(list->Flink, ETHREAD_META_2004, ThreadListEntry);

						p_previous_entry->ThreadListEntry.Flink = list->Flink;
						p_next_entry->ThreadListEntry.Blink = list->Blink;

						list->Blink = list;
						list->Flink = list;

						print("removed thread[%d] from linked list\n", thread_id);
						ObDereferenceObject(process);
						ObDereferenceObject(thread);
						return true;
					}

				}

				ObDereferenceObject(process);
				ObDereferenceObject(thread);
				return false;
			}
		}
	}

	bool relink_threads(HANDLE process_id) {
		if (!process_id) {
			print("invalid process id\n");
			return false;
		}

		PEPROCESS process = nullptr;
		if (NT_SUCCESS(PsLookupProcessByProcessId(process_id, &process))) {
			LIST_ENTRY* thread_list_head = (LIST_ENTRY*)make_ptr(process, 0x5e0);
			if (!thread_list_head) {
				print("failed to get thread list head");
				ObDereferenceObject(process);
				return false;
			}

			thread_list_head->Blink = old.Blink;
			thread_list_head->Flink = old.Flink;

			print("restored threads to linked list\n");
			ObDereferenceObject(process);

			return true;
		}
		
		return false;
	}
}

```

`apex_driver/core/utils/utils.h`:

```h
#pragma once
#include <ntifs.h>

#define print(f_, ...) DbgPrintEx(0, 0, (f_), ##__VA_ARGS__)

#define make_ptr( ptr, val ) ( (uintptr_t)ptr + (uintptr_t)val )

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) \
(((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) \
(((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) \
(((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) \
(((signed __int64)(seconds)) * MILLISECONDS(1000L))

namespace utils {
	UNICODE_STRING char_to_unicode(const char* convert);

	void random_text(char* text, const int length);

	bool unlink_threadlist_head(HANDLE process_id);

	bool unlink_thread(HANDLE process_id, HANDLE thread_id);

	bool relink_threads(HANDLE process_id);
}
```

`apex_loader/apex_loader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{26f87a2b-653a-450e-b988-e2ca6794e91a}</ProjectGuid>
    <RootNamespace>apexloader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="core\loader\loader.cpp" />
    <ClCompile Include="core\main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\loader\loader.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`apex_loader/apex_loader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core\loader\loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="core\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core\loader\loader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`apex_loader/core/loader/loader.cpp`:

```cpp
#include "loader.h"
#include <iostream>
#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>

// todo:replace this with your dll
#define TARGET_DLL_ADDRESS L"C:\\Users\\nickm\\source\\repos\\r6\\x64\\Release\\r6_client.dll"
//#define TARGET_DLL_ADDRESS L"C:\\Users\\nickm\\Desktop\\r6_client.dll"

typedef HMODULE(WINAPI* pLoadLibraryA)(LPCSTR);
typedef FARPROC(WINAPI* pGetProcAddress)(HMODULE, LPCSTR);

typedef BOOL(WINAPI* PDLL_MAIN)(HMODULE, DWORD, PVOID);

typedef struct _MANUAL_INJECT
{
	PVOID ImageBase;
	PIMAGE_NT_HEADERS NtHeaders;
	PIMAGE_BASE_RELOCATION BaseRelocation;
	PIMAGE_IMPORT_DESCRIPTOR ImportDirectory;
	pLoadLibraryA fnLoadLibraryA;
	pGetProcAddress fnGetProcAddress;
}MANUAL_INJECT, * PMANUAL_INJECT;

DWORD WINAPI LoadDll(PVOID p)
{
	PMANUAL_INJECT ManualInject;

	HMODULE hModule;
	DWORD64 i, Function, count, delta;

	DWORD64* ptr;
	PWORD list;

	PIMAGE_BASE_RELOCATION pIBR;
	PIMAGE_IMPORT_DESCRIPTOR pIID;
	PIMAGE_IMPORT_BY_NAME pIBN;
	PIMAGE_THUNK_DATA FirstThunk, OrigFirstThunk;

	PDLL_MAIN EntryPoint;

	ManualInject = (PMANUAL_INJECT)p;

	pIBR = ManualInject->BaseRelocation;
	delta = (DWORD64)((LPBYTE)ManualInject->ImageBase - ManualInject->NtHeaders->OptionalHeader.ImageBase); // Calculate the delta

																										  // Relocate the image

	while (pIBR->VirtualAddress)
	{
		if (pIBR->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION))
		{
			count = (pIBR->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			list = (PWORD)(pIBR + 1);

			for (i = 0; i < count; i++)
			{
				if (list[i])
				{
					ptr = (DWORD64*)((LPBYTE)ManualInject->ImageBase + (pIBR->VirtualAddress + (list[i] & 0xFFF)));
					*ptr += delta;
				}
			}
		}

		pIBR = (PIMAGE_BASE_RELOCATION)((LPBYTE)pIBR + pIBR->SizeOfBlock);
	}

	pIID = ManualInject->ImportDirectory;

	// Resolve DLL imports

	while (pIID->Characteristics)
	{
		OrigFirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)ManualInject->ImageBase + pIID->OriginalFirstThunk);
		FirstThunk = (PIMAGE_THUNK_DATA)((LPBYTE)ManualInject->ImageBase + pIID->FirstThunk);

		hModule = ManualInject->fnLoadLibraryA((LPCSTR)ManualInject->ImageBase + pIID->Name);

		if (!hModule)
		{
			return FALSE;
		}

		while (OrigFirstThunk->u1.AddressOfData)
		{
			if (OrigFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				// Import by ordinal

				Function = (DWORD64)ManualInject->fnGetProcAddress(hModule, (LPCSTR)(OrigFirstThunk->u1.Ordinal & 0xFFFF));

				if (!Function)
				{
					return FALSE;
				}

				FirstThunk->u1.Function = Function;
			}

			else
			{
				// Import by name

				pIBN = (PIMAGE_IMPORT_BY_NAME)((LPBYTE)ManualInject->ImageBase + OrigFirstThunk->u1.AddressOfData);
				Function = (DWORD64)ManualInject->fnGetProcAddress(hModule, (LPCSTR)pIBN->Name);

				if (!Function)
				{
					return FALSE;
				}

				FirstThunk->u1.Function = Function;
			}

			OrigFirstThunk++;
			FirstThunk++;
		}

		pIID++;
	}

	if (ManualInject->NtHeaders->OptionalHeader.AddressOfEntryPoint)
	{
		EntryPoint = (PDLL_MAIN)((LPBYTE)ManualInject->ImageBase + ManualInject->NtHeaders->OptionalHeader.AddressOfEntryPoint);
		return EntryPoint((HMODULE)ManualInject->ImageBase, DLL_PROCESS_ATTACH, NULL); // Call the entry point
	}

	return TRUE;
}

DWORD WINAPI LoadDllEnd()
{
	return 0;
}


#pragma comment(lib,"ntdll.lib")

extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);

UCHAR code[] = {
  0x48, 0xB8, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // mov -16 to rax
  0x48, 0x21, 0xC4,                                             // and rsp, rax
  0x48, 0x83, 0xEC, 0x20,                                       // subtract 32 from rsp
  0x48, 0x8b, 0xEC,                                             // mov rbp, rsp
  0x90, 0x90,                                                   // nop nop
  0x48, 0xB9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,   // mov rcx,CCCCCCCCCCCCCCCC
  0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,   // mov rax,AAAAAAAAAAAAAAAA
  0xFF, 0xD0,                                                   // call rax
  0x90,                                                         // nop
  0x90,                                                         // nop
  0xEB, 0xFC                                                    // JMP to nop
};

DWORD FindProcessId(const std::wstring& processName)
{
	PROCESSENTRY32 processInfo;
	processInfo.dwSize = sizeof(processInfo);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	Process32First(processesSnapshot, &processInfo);
	if (!processName.compare(processInfo.szExeFile))
	{
		CloseHandle(processesSnapshot);
		return processInfo.th32ProcessID;
	}

	while (Process32Next(processesSnapshot, &processInfo))
	{
		if (!processName.compare(processInfo.szExeFile))
		{
			CloseHandle(processesSnapshot);
			return processInfo.th32ProcessID;
		}
	}

	CloseHandle(processesSnapshot);
	return 0;
}

namespace loader {
	bool load_dll(const wchar_t* process_name, const wchar_t* dll_path) {
		LPBYTE ptr;
		HANDLE hProcess, hThread, hSnap, hFile;
		PVOID mem, mem1;
		DWORD ProcessId, FileSize, read, i;
		PVOID buffer, image;
		BOOLEAN bl;
		PIMAGE_DOS_HEADER pIDH;
		PIMAGE_NT_HEADERS pINH;
		PIMAGE_SECTION_HEADER pISH;
		THREADENTRY32 te32;
		CONTEXT ctx;
		MANUAL_INJECT ManualInject;

		te32.dwSize = sizeof(te32);
		ctx.ContextFlags = CONTEXT_FULL;
		hFile = CreateFile(dll_path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); // Open the DLL

		if (hFile == INVALID_HANDLE_VALUE) {
			printf("\nError: Unable to open the DLL (%d)\n", GetLastError());
			return false;
		}

		FileSize = GetFileSize(hFile, NULL);
		buffer = VirtualAlloc(NULL, FileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (!buffer) {
			printf("\nError: Unable to allocate memory for DLL data (%d)\n", GetLastError());

			CloseHandle(hFile);
			return false;
		}

		if (!ReadFile(hFile, buffer, FileSize, &read, NULL)) {
			printf("\nError: Unable to read the DLL (%d)\n", GetLastError());

			VirtualFree(buffer, 0, MEM_RELEASE);
			CloseHandle(hFile);

			return false;
		}

		CloseHandle(hFile);

		pIDH = (PIMAGE_DOS_HEADER)buffer;
		if (pIDH->e_magic != IMAGE_DOS_SIGNATURE) {
			printf("\nError: Invalid executable image.\n");

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		pINH = (PIMAGE_NT_HEADERS)((LPBYTE)buffer + pIDH->e_lfanew);
		if (pINH->Signature != IMAGE_NT_SIGNATURE) {
			printf("\nError: Invalid PE header.\n");

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		if (!(pINH->FileHeader.Characteristics & IMAGE_FILE_DLL)) {
			printf("\nError: The image is not DLL.\n");

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		RtlAdjustPrivilege(20, TRUE, FALSE, &bl);

		ProcessId = FindProcessId(process_name);
		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);
		if (!hProcess) {
			printf("\nError: Unable to open target process handle (%d)\n", GetLastError());
			return false;
		}

		image = VirtualAllocEx(hProcess, NULL, pINH->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Allocate memory for the DLL
		if (!image) {
			printf("\nError: Unable to allocate memory for the DLL (%d)\n", GetLastError());

			VirtualFree(buffer, 0, MEM_RELEASE);
			CloseHandle(hProcess);

			return false;
		}

		if (!WriteProcessMemory(hProcess, image, buffer, pINH->OptionalHeader.SizeOfHeaders, NULL)) {
			printf("\nError: Unable to copy headers to target process (%d)\n", GetLastError());

			VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);
			CloseHandle(hProcess);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		pISH = (PIMAGE_SECTION_HEADER)(pINH + 1);
		for (i = 0; i < pINH->FileHeader.NumberOfSections; i++) {
			WriteProcessMemory(hProcess, (PVOID)((LPBYTE)image + pISH[i].VirtualAddress), (PVOID)((LPBYTE)buffer + pISH[i].PointerToRawData), pISH[i].SizeOfRawData, NULL);
		}
		mem1 = VirtualAllocEx(hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Allocate memory for the loader code

		if (!mem1) {
			printf("\nError: Unable to allocate memory for the loader code (%d)\n", GetLastError());

			VirtualFreeEx(hProcess, image, 0, MEM_RELEASE);
			CloseHandle(hProcess);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		memset(&ManualInject, 0, sizeof(MANUAL_INJECT));

		ManualInject.ImageBase = image;
		ManualInject.NtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)image + pIDH->e_lfanew);
		ManualInject.BaseRelocation = (PIMAGE_BASE_RELOCATION)((LPBYTE)image + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		ManualInject.ImportDirectory = (PIMAGE_IMPORT_DESCRIPTOR)((LPBYTE)image + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
		ManualInject.fnLoadLibraryA = LoadLibraryA;
		ManualInject.fnGetProcAddress = GetProcAddress;

		if (!WriteProcessMemory(hProcess, mem1, &ManualInject, sizeof(MANUAL_INJECT), NULL))
			std::cout << "Error " << std::hex << GetLastError() << std::endl;

		if (!WriteProcessMemory(hProcess, (PVOID)((PMANUAL_INJECT)mem1 + 1), LoadDll, 4096 - sizeof(MANUAL_INJECT), NULL))
			std::cout << "Error " << std::hex << GetLastError() << std::endl;
		hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

		Thread32First(hSnap, &te32);
		while (Thread32Next(hSnap, &te32)) {
			if (te32.th32OwnerProcessID == ProcessId) {
				break;
			}
		}

		CloseHandle(hSnap);

		mem = VirtualAllocEx(hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!mem) {
			printf("\nError: Unable to allocate memory in target process (%d)", GetLastError());

			CloseHandle(hProcess);
			return false;
		}

		hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
		if (!hThread) {
			printf("\nError: Unable to open target thread handle (%d)\n", GetLastError());

			VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
			CloseHandle(hProcess);
			return false;
		}

		SuspendThread(hThread);
		GetThreadContext(hThread, &ctx);

		buffer = VirtualAlloc(NULL, 65536, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		ptr = (LPBYTE)buffer;
		ZeroMemory(buffer, 65536);
		memcpy(buffer, code, sizeof(code));

		for (BYTE* ptr = (LPBYTE)buffer; ptr < ((LPBYTE)buffer + 300); ptr++) {
			DWORD64 address = *(DWORD64*)ptr;
			if (address == 0xCCCCCCCCCCCCCCCC) {
				*(DWORD64*)ptr = (DWORD64)mem1;
			}

			if (address == 0xAAAAAAAAAAAAAAAA) {
				*(DWORD64*)ptr = (DWORD64)((PMANUAL_INJECT)mem1 + 1);
			}
		}

		if (!WriteProcessMemory(hProcess, mem, buffer, sizeof(code), NULL)) {
			printf("\nError: Unable to write shellcode into target process (%d)\n", GetLastError());

			VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
			ResumeThread(hThread);

			CloseHandle(hThread);
			CloseHandle(hProcess);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		ctx.Rip = (DWORD64)mem;
		if (!SetThreadContext(hThread, &ctx)) {
			printf("\nError: Unable to hijack target thread (%d)\n", GetLastError());

			VirtualFreeEx(hProcess, mem, 0, MEM_RELEASE);
			ResumeThread(hThread);

			CloseHandle(hThread);
			CloseHandle(hProcess);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return false;
		}

		ResumeThread(hThread);
		CloseHandle(hThread);
		CloseHandle(hProcess);
		VirtualFree(buffer, 0, MEM_RELEASE);
	}
}

```

`apex_loader/core/loader/loader.h`:

```h
#pragma once

namespace loader {
	bool load_dll(const wchar_t* process_name, const wchar_t* dll_path);
}
```

`apex_loader/core/main.cpp`:

```cpp
#include "loader/loader.h"
#include <iostream>

int main() {
	loader::load_dll(L"PUT YOUR PROCESS HERE OR KEEP SAME EpicGamesLauncher.exe",
		L"YOUR PATH!!!!\\apex_client.dll");	

	return 0;
}
```