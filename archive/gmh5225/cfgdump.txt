Project Path: arc_gmh5225_cfgdump_rmy4v6g7

Source Tree:

```txt
arc_gmh5225_cfgdump_rmy4v6g7
├── README.md
├── cfg.sln
└── cfgdump
    ├── Helper.cpp
    ├── Helper.h
    ├── cfg.def
    ├── cfgdump.cpp
    ├── cfgdump.vcxproj
    └── cfgdump.vcxproj.filters

```

`README.md`:

```md
# cfgdump
Windbg extension that allows you analyze Control Flow Guard map

# commands

!cfgcover - prints memory map that is covered by CFG map and shows which region are protected by CFG bits

!cfgrange \<address\> \<size\> - prints CFG bits for specified address range

!cfgdump - prints all CFG bits for whole address space

!cfgmap - prints available CFG maps

```

`cfg.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.21005.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "cfg", "cfgdump\cfgdump.vcxproj", "{76645DE8-8AE1-40F8-8796-AA45C2B063EB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Debug|Win32.ActiveCfg = Debug|Win32
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Debug|Win32.Build.0 = Debug|Win32
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Debug|x64.ActiveCfg = Debug|x64
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Debug|x64.Build.0 = Debug|x64
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Release|Win32.ActiveCfg = Release|Win32
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Release|Win32.Build.0 = Release|Win32
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Release|x64.ActiveCfg = Release|x64
		{76645DE8-8AE1-40F8-8796-AA45C2B063EB}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`cfgdump/Helper.cpp`:

```cpp
#include "Helper.h"
#include <stdarg.h>
#include <Windows.h>
#include <wdbgexts.h>

using namespace std;

// =================

Exception::Exception(const char* Format, ...)
{
	char buffer[256];

	va_list args;
	va_start(args, Format);
	_vsnprintf_s(buffer, _countof(buffer), _TRUNCATE, Format, args);
	va_end(args);

	m_errorMessage = buffer;
}

const char* Exception::What()
{
	return m_errorMessage.c_str();
}

// =================


Arguments::Arguments(const char* commandLine) : m_argPointer(0)
{
	if (!commandLine)
		return;

	char* context;
	auto tokens = _strdup(commandLine);
	auto token = strtok_s(tokens, " ", &context);
	
	if (!token)
		return;

	do { 
		m_arguments.push_back(token);
	} while (token = strtok_s(nullptr, " ", &context));

	free(tokens);
}

size_t Arguments::ArgsCount()
{
	return m_arguments.size();
}

bool Arguments::Probe(std::string& arg)
{
	if (m_argPointer >= m_arguments.size())
		return false;

	arg = m_arguments[m_argPointer];
	return true;
}

bool Arguments::SwitchToNext()
{
	if (m_argPointer >= m_arguments.size())
		return false;

	m_argPointer++;
	return true;
}

bool Arguments::GetNext(string& arg)
{
	if (m_argPointer >= m_arguments.size())
		return false;

	arg = m_arguments[m_argPointer++];
	return true;
}

```

`cfgdump/Helper.h`:

```h
#pragma once

#include <vector>
#include <string>

class Exception
{
	std::string m_errorMessage;

public:

	Exception(const char* Format, ...);

	const char* What();
};

class Arguments
{
	std::vector<std::string> m_arguments;
	unsigned int m_argPointer;

public:

	Arguments(const char* commandLine);

	size_t ArgsCount();

	bool Probe(std::string& arg);
	bool SwitchToNext();
	bool GetNext(std::string& arg);
};

```

`cfgdump/cfg.def`:

```def
LIBRARY   Cfg  
EXPORTS  
  ExtensionApiVersion    @1  
  WinDbgExtensionDllInit @2  
  cfgdump                @3  
  cfgrange               @4
  cfgcover               @5
  cfgmap                 @6
```

`cfgdump/cfgdump.cpp`:

```cpp
#include <Windows.h>
#include <imagehlp.h>
#include <wdbgexts.h>
#include <dbgeng.h>
#include "Helper.h"
#include <string>
#include <sstream>

//TODO:
// - Add support of legacy CFG 2-bit
// - Is it possible to use output prefix?

#pragma comment(lib, "dbgeng.lib")

struct MapChunk {
	ULONGLONG address;
	union {
		unsigned long cfg32;
		unsigned long long cfg64;
	};
};

EXT_API_VERSION ExtApiVersion = { 1, 1, EXT_API_VERSION_NUMBER, 0 };

WINDBG_EXTENSION_APIS ExtensionApis = { 0 };

IDebugClient*         g_DebugClient = NULL;
IDebugSymbols3*       g_DebugSymbols = NULL;
IDebugDataSpaces2*    g_DebugDataSpaces = NULL;
IDebugControl3*       g_DebugControl = NULL;

const auto VIRTUAL32_SIZE = 0x80000000ull;
const auto VIRTUAL64_SIZE = 0x800000000000ull;
const ULONGLONG MAX_CFGMAP32_SIZE = (VIRTUAL32_SIZE >> 8) * sizeof(ULONG);
const ULONGLONG MAX_CFGMAP64_SIZE = (VIRTUAL64_SIZE >> 9) * sizeof(ULONGLONG);

enum Platform {
	x86,
	x64
};

enum MapType
{
	Auto,
	Cfg32,
	Cfg64
};

Platform g_currentPlatform = Platform::x86;
bool g_isWow64Process = false;

// --------------------------- 

VOID WDBGAPI WinDbgExtensionDllInit(PWINDBG_EXTENSION_APIS lpExtensionApis, USHORT usMajorVersion, USHORT usMinorVersion)
{
	ExtensionApis = *lpExtensionApis;

	if (::DebugCreate(__uuidof(IDebugClient), (void**)&g_DebugClient) != S_OK)
	{
		dprintf("Error, acuqiring IDebugClient failed\n\n");
		return;
	}

	if (g_DebugClient->QueryInterface(__uuidof(IDebugSymbols3), (void**)&g_DebugSymbols) != S_OK)
	{
		dprintf("Error, acuqiring IDebugSymbols failed\n\n");
		return;
	}

	if (g_DebugClient->QueryInterface(__uuidof(IDebugDataSpaces2), (void**)&g_DebugDataSpaces) != S_OK)
	{
		dprintf("Error, acuqiring IDebugDataSpaces2 failed\n\n");
		return;
	}

	if (g_DebugClient->QueryInterface(__uuidof(IDebugControl3), (void**)&g_DebugControl) != S_OK)
	{
		dprintf("Error, acuqiring IDebugControl3 failed\n\n");
		return;
	}
}

LPEXT_API_VERSION WDBGAPI ExtensionApiVersion(void)
{
	return &ExtApiVersion;
}

// --------------------------- 

bool IsX64Platform()
{
	return (g_currentPlatform == Platform::x64);
}

const char* GetSpaces(unsigned int level)
{
	switch (level)
	{
	case 0:
		return "";
	case 1:
		return " ";
	case 2:
		return "  ";
	case 3:
		return "   ";
	case 4:
		return "    ";
	case 5:
		return "     ";
	case 6:
		return "      ";
	case 7:
		return "       ";
	default:
		break;
	}
	return     "        ";
}

void PrintCFGMapInfo(ULONGLONG cfgmap)
{
	if (IsX64Platform())
		dprintf("CFG Map64: %llx - %llx (%llx)\n\n", cfgmap, cfgmap + MAX_CFGMAP64_SIZE, MAX_CFGMAP64_SIZE);
	else
		dprintf("CFG Map32: %llx - %llx (%llx)\n\n", cfgmap, cfgmap + MAX_CFGMAP32_SIZE, MAX_CFGMAP32_SIZE);
}

void PrintCFGChunkHeader(unsigned int level)
{
	if (IsX64Platform())
		dprintf("\n%s  Address          0123456789abcdef   0123456789abcdef   0123456789abcdef   0123456789abcdef\n", GetSpaces(level));
	else
		dprintf("\n%s  Address  0123456789abcdef   0123456789abcdef   0123456789abcdef   0123456789abcdef\n", GetSpaces(level));
}

void PrintCFGChunk(const MapChunk& chunk, unsigned int level, bool clipped, bool& skipped, bool& empty)
{
	auto bits = chunk.cfg64;

	for (auto i = 0; i < 8; i++)
	{
		if (clipped && (bits & 0xFF) == 0)
		{
			skipped = true;
			bits >>= 8;
			continue;
		}

		if (empty)
		{
			PrintCFGChunkHeader(level);
			empty = false;
		}

		if (skipped)
		{
			dprintf("%s ...\n", GetSpaces(level));
			skipped = false;
		}

		if (IsX64Platform())
			dprintf("%s%016llx", GetSpaces(level), chunk.address + (i * 0x40));
		else
			dprintf("%s%08llx", GetSpaces(level), chunk.address + (i * 0x40));

		for (auto a = 0; a < 4; a++)
		{
			if ((bits & 2) != 0)
				dprintf(" | ++++++++++++++++");
			else if ((bits & 1) != 0)
				dprintf(" | +...............");
			else
				dprintf(" | ................");

			bits >>= 2;
		}

		dprintf("\n");
	}
}

const char* MemoryTypeToString(DWORD type)
{
	switch (type)
	{
	case MEM_IMAGE:
		return "Image";
	case MEM_MAPPED:
		return "Mapped";
	case MEM_PRIVATE:
		return "Private";
	case 0:
		return "None";
	default:
		break;
	}

	return "Unknown";
}

const char* MemoryStateToString(DWORD state)
{
	switch (state)
	{
	case MEM_COMMIT:
		return "Commited";
	case MEM_FREE:
		return "Free";
	case MEM_RESERVE:
		return "Reserved";
	default:
		break;
	}

	return "Unknown";
}

std::string ConvertProtectionToString(DWORD protection)
{
	std::stringstream out;

	if (protection & PAGE_NOACCESS)
		out << "NoAccess";
	else if (protection & PAGE_READONLY)
		out << "ReadOnly";
	else if (protection & PAGE_READWRITE)
		out << "ReadWrite";
	else if (protection & PAGE_WRITECOPY)
		out << "WriteCopy";
	else if (protection & PAGE_EXECUTE)
		out << "Execute";
	else if (protection & PAGE_EXECUTE_READ)
		out << "ExecuteRead";
	else if (protection & PAGE_EXECUTE_READWRITE)
		out << "ExecuteReadWrite";
	else if (protection & PAGE_EXECUTE_WRITECOPY)
		out << "ExecuteWriteCopy";

	if (protection & PAGE_GUARD)
		out << "|Guard";
	if (protection & PAGE_NOCACHE)
		out << "|NoCache";
	if (protection & PAGE_WRITECOMBINE)
		out << "|WriteCombine";

	return out.str();
}

void GetMemoryInfoString(const MEMORY_BASIC_INFORMATION64& info, char* buffer, size_t size)
{
	if (size >= 1)
		buffer[0] = '\0';

	if (info.Type != MEM_IMAGE)
		return;

	ULONGLONG base;
	HRESULT result = g_DebugSymbols->GetModuleByOffset(info.AllocationBase, 0, NULL, &base);
	if (result != S_OK)
		return;

	result = g_DebugSymbols->GetModuleNameString(DEBUG_MODNAME_IMAGE, DEBUG_ANY_ID, base, buffer, size, NULL);
	if (result != S_OK)
		return;
}

void PrintCFGRegionHeader()
{
	if (IsX64Platform())
		dprintf("   Start              End                Size           CFGbits Type       State      Protection\n");
	else
		dprintf("   Start      End        Size   CFGbits Type       State      Protection\n");//TODO:
}

const char* GetCFGRangeState(ULONGLONG cfgmap, ULONGLONG address, ULONGLONG size);

void PrintCFGRegion(ULONGLONG cfgmap, ULONGLONG ptr, ULONGLONG range, const MEMORY_BASIC_INFORMATION64& info)
{
	//TODO: add support of Wow64 map
	char memory[MAX_PATH];
	GetMemoryInfoString(info, memory, sizeof(memory));

	if (IsX64Platform())
		dprintf("  %016llx | %016llx | %016llx | %s | %-8s | %-8s | %-25s %s\n",
				ptr,
				ptr + range,
				range,
				GetCFGRangeState(cfgmap, ptr, range),
				MemoryTypeToString(info.Type),
				MemoryStateToString(info.State),
				ConvertProtectionToString(info.Protect).c_str(),
				memory
		);
	else
		dprintf("  %08llx | %08llx | %08llx | %s | %-8s | %-8s | %-25s %s\n",
				ptr,
				ptr + range,
				range,
				GetCFGRangeState(cfgmap, ptr, range),
				MemoryTypeToString(info.Type),
				MemoryStateToString(info.State),
				ConvertProtectionToString(info.Protect).c_str(),
				memory
		);
}

// --------------------------- 

ULONGLONG ConvertAddressToCfgMapAddress(ULONGLONG cfgmap, ULONGLONG address)
{
	return cfgmap + ((address >> 9) * 8);
}

bool LoadMapChunk(ULONGLONG cfgmap, ULONGLONG address, ULONGLONG size, MapChunk& chunk)
{
	ULONG readed;
	HRESULT result = g_DebugDataSpaces->ReadVirtual(
		ConvertAddressToCfgMapAddress(cfgmap, address),
		&chunk.cfg64,
		sizeof(chunk.cfg64),
		&readed
	);
	if (result != S_OK)
		return false;

	if (readed != sizeof(chunk.cfg64))
		return false;

	chunk.address = address;
	return true;
}

void FindCFGMap(ULONGLONG& cfgmap, MapType type)
{

	ULONGLONG top, cfgsize, ptr = 0;

	if (type == MapType::Cfg32)
	{
		cfgsize = MAX_CFGMAP32_SIZE;
		top     = VIRTUAL32_SIZE;
	}
	else if (type == MapType::Cfg64)
	{
		cfgsize = MAX_CFGMAP64_SIZE;
		top     = VIRTUAL64_SIZE;
	}
	else
	{
		cfgsize = (IsX64Platform() ? MAX_CFGMAP64_SIZE : MAX_CFGMAP32_SIZE);
		top     = (IsX64Platform() ? VIRTUAL64_SIZE    : VIRTUAL32_SIZE);
	}

	ULONGLONG start = 0;
	bool calculation = false;

	while (ptr < top)
	{
		MEMORY_BASIC_INFORMATION64 info;
		HRESULT result = g_DebugDataSpaces->QueryVirtual(ptr, &info);
		if (result != S_OK)
		{
			ptr += 0x1000;
			continue;
		}

		// Fix for NULL allocation base on modern OS
		if (!info.AllocationBase)
			info.AllocationBase = ptr;

		ptr += info.RegionSize;

		if (calculation)
		{
			if (start == info.AllocationBase)
				continue;

			calculation = false;
			if (info.AllocationBase - start == cfgsize)
			{
				cfgmap = start;
				return;
			}
		}

		if (!calculation)
		{
			if (info.Type != MEM_MAPPED)
				continue;
			
			if (info.BaseAddress != info.AllocationBase)
				continue;

			calculation = true;
			start = info.AllocationBase;
		}
	}

	throw Exception("can't find CFG map");
}

void SelectArchitecture()
{
	ULONG qualifier, dbgclass;

	HRESULT result = g_DebugControl->GetDebuggeeType(&dbgclass, &qualifier);
	if (result != S_OK)
		throw Exception("can't retreive debuggee type, code: %x\n", result);

	if (dbgclass != DEBUG_CLASS_USER_WINDOWS)
		throw Exception("supported only usermode process debugging\n");

	g_currentPlatform = (g_DebugControl->IsPointer64Bit() == S_OK ? Platform::x64 : Platform::x86);
}

// --------------------------- 

bool DumpCFGMapRange(ULONGLONG cfgmap, ULONGLONG address, ULONGLONG size, unsigned int level, bool clipped)
{
	//   Address          0123456789abcdef   0123456789abcdef   0123456789abcdef   0123456789abcdef
	// 0000000003fce800 | ................ | ++++++++++++++++ | ................ | ................
	// 0000000003fce840 | ................ | +............... | ................ | ................
	// 0000000003fce880 | ................ | ++++++++++++++++ | ................ | ................
	// 0000000003fce8c0 | ................ | +............... | ................ | ................
	// 0000000003fce900 | ................ | ++++++++++++++++ | ................ | ................
	// 0000000003fce940 | ................ | +............... | ................ | ................
	// 0000000003fce980 | ................ | ++++++++++++++++ | ................ | ................
	// 0000000003fce9c0 | ................ | +............... | ................ | ................
	// ...
	// 0000000003fce080 | ................ | ++++++++++++++++ | ................ | ................
	// ...

	const auto chunkBlockSize = 0x200ul;

	auto start = address - (address % chunkBlockSize);
	auto delta = (address + size) - start;
	auto chunks = (delta / chunkBlockSize) + (delta % chunkBlockSize ? 1 : 0);

	bool skipped = false;
	bool empty = true;
	for (auto i = 0ull; i < chunks; i++)
	{
		MapChunk chunk;
		auto address = start + (i * chunkBlockSize);

		if (!LoadMapChunk(cfgmap, address, chunkBlockSize, chunk))
		{
			//TODO: improve it, not need to print error message for each chunk
			//dprintf(" %016llx | failed, can't load map bits\n", address);
			continue;
		}

		PrintCFGChunk(chunk, level, clipped, skipped, empty);
	}

	return !empty;
}

DECLARE_API(cfgrange)
{
	try
	{
		Arguments arguments(args);
		ULONGLONG cfgmap = 0, start = 0, size = 0;

		SelectArchitecture();
		FindCFGMap(cfgmap, MapType::Auto);
		
		std::string arg;
		if (!arguments.GetNext(arg))
			throw Exception("no address argument\n");

		start = std::stoll(arg, 0, 16);

		if (!arguments.GetNext(arg))
			size = 1;
		else
			size = std::stoll(arg, 0, 16);

		DumpCFGMapRange(cfgmap, start, size, 1, true);
	}
	catch (Exception& e)
	{
		dprintf("Error: %s\n", e.What());
	}
	catch (std::exception& e)
	{
		dprintf("STDError: %s\n", e.what());
	}
}

// --------------------------- 

void DumpMemoryInCFGRegion(ULONGLONG cfgmap, ULONGLONG address, ULONGLONG size, bool clipped)
{
	auto ptr = address;
	auto top = address + size;

	while (ptr < top)
	{
		MEMORY_BASIC_INFORMATION64 info;
		HRESULT result = g_DebugDataSpaces->QueryVirtual(ptr, &info);
		if (result != S_OK)
		{
			dprintf("Warning: query virtual address %llx failed, code: %x\n", ptr, result);
			ptr += 0x1000;
			continue;
		}

		auto range = info.BaseAddress + info.RegionSize - ptr;

		if (ptr + range > top)
			range = top - ptr;

		dprintf("  Region: %llx - %llx (%llx), %s, %s\n", 
			ptr,
			ptr + range,
			range,
			MemoryStateToString(info.State),
			MemoryTypeToString(info.Type)
		);
		
		if (!DumpCFGMapRange(cfgmap, ptr, range, 3, clipped))
			dprintf("      without cfg bits\n");

		dprintf("\n");
		ptr += range;
	}
}

void DumpFullCFGMap(ULONGLONG cfgmap)
{
	auto cfgptr = cfgmap;
	auto cfgtop = cfgmap + (IsX64Platform() ? MAX_CFGMAP64_SIZE : MAX_CFGMAP32_SIZE);

	dprintf("\n");

	PrintCFGMapInfo(cfgmap);

	while (cfgptr < cfgtop)
	{
		MEMORY_BASIC_INFORMATION64 info;
		HRESULT result = g_DebugDataSpaces->QueryVirtual(cfgptr, &info);
		if (result != S_OK)
		{
			dprintf("Warning: query virtual address %llx failed, code: %x\n", cfgptr, result);
			cfgptr += 0x1000;
			continue;
		}

		if (info.AllocationBase != cfgmap)
		{
			dprintf("Warning: allocation base missmatched %016llx != %016llx\n", info.AllocationBase, cfgmap);
			break;
		}

		if (info.State != MEM_COMMIT || (info.Protect & PAGE_NOACCESS) != 0)
		{
			//dprintf("Skip no access: %016llx, %016llx\n", cfgptr, info.RegionSize);
			cfgptr += info.RegionSize;
			continue;
		}

		auto address = ((cfgptr - cfgmap) << 9ull) / 8;
		auto size = (info.RegionSize / 8ull) * 0x200ull;

		dprintf(" CFG Region: %llx - %llx (%llx)\n\n", address, address + size, size);

		DumpMemoryInCFGRegion(cfgmap, address, size, true);

		cfgptr += info.RegionSize;
		dprintf("\n");
	}
}

DECLARE_API(cfgdump)
{
	try
	{
		ULONGLONG cfgmap;
		SelectArchitecture();
		FindCFGMap(cfgmap, MapType::Auto);
		DumpFullCFGMap(cfgmap);
	}
	catch (Exception& e)
	{
		dprintf("Error: %s\n", e.What());
	}
	catch (std::exception& e)
	{
		dprintf("STDError: %s\n", e.what());
	}
}

// --------------------------- 

const char* GetCFGRangeState(ULONGLONG cfgmap, ULONGLONG address, ULONGLONG size)
{
	const auto chunkBlockSize = 0x200ul;

	auto start = address - (address % chunkBlockSize);
	auto delta = (address + size) - start;
	auto chunks = (delta / chunkBlockSize) + (delta % chunkBlockSize ? 1 : 0);
	bool failed = false;

	for (auto i = 0ull; i < chunks; i++)
	{
		MapChunk chunk;
		auto address = start + (i * chunkBlockSize);

		if (!LoadMapChunk(cfgmap, address, chunkBlockSize, chunk))
		{
			failed = true;
			continue;
		}
		
		if (chunk.cfg64)
			return "+";
	}

	return (failed ? "?" : " ");
}

void DumpMemoryMapInCFGRegion(ULONGLONG cfgmap, ULONGLONG address, ULONGLONG size)
{
	auto ptr = address;
	auto top = address + size;

	PrintCFGRegionHeader();

	while (ptr < top)
	{
		MEMORY_BASIC_INFORMATION64 info;
		HRESULT result = g_DebugDataSpaces->QueryVirtual(ptr, &info);
		if (result != S_OK)
		{
			dprintf("Warning: query virtual address %llx failed, code: %x\n", ptr, result);
			ptr += 0x1000;
			continue;
		}

		auto range = info.BaseAddress + info.RegionSize - ptr;

		if (ptr + range > top)
			range = top - ptr;

		PrintCFGRegion(cfgmap, ptr, range, info);

		ptr += range;
	}
}

void DumpCFGCoveredMemory(ULONGLONG cfgmap)
{
	auto cfgptr = cfgmap;
	auto cfgtop = cfgmap + (IsX64Platform() ? MAX_CFGMAP64_SIZE : MAX_CFGMAP32_SIZE);

	dprintf("\n");

	PrintCFGMapInfo(cfgmap);

	while (cfgptr < cfgtop)
	{
		MEMORY_BASIC_INFORMATION64 info;
		HRESULT result = g_DebugDataSpaces->QueryVirtual(cfgptr, &info);
		if (result != S_OK)
		{
			dprintf("Warning: query virtual address %llx failed, code: %x\n", cfgptr, result);
			cfgptr += 0x1000;
			continue;
		}

		if (info.AllocationBase != cfgmap)
		{
			dprintf("Warning: allocation base missmatched %llx != %llx\n", info.AllocationBase, cfgmap);
			break;
		}

		if (info.State != MEM_COMMIT || (info.Protect & PAGE_NOACCESS) != 0)
		{
			//dprintf("Skip no access: %016llx, %016llx\n", cfgptr, info.RegionSize);
			cfgptr += info.RegionSize;
			continue;
		}

		auto address = ((cfgptr - cfgmap) << 9ull) / 8;
		auto size = (info.RegionSize / 8ull) * 0x200ull;

		dprintf(" CFG Region: %llx - %llx (%llx)\n\n", address, address + size, size);

		DumpMemoryMapInCFGRegion(cfgmap, address, size);

		cfgptr += info.RegionSize;
		dprintf("\n");
	}
}

DECLARE_API(cfgcover)
{
	try
	{
		ULONGLONG cfgmap;
		SelectArchitecture();
		FindCFGMap(cfgmap, MapType::Auto);
		DumpCFGCoveredMemory(cfgmap);
	}
	catch (Exception& e)
	{
		dprintf("Error: %s\n", e.What());
	}
	catch (std::exception& e)
	{
		dprintf("STDError: %s\n", e.what());
	}
}

// --------------------------- 

void DumpProcessCFGMap(MapType type)
{
	ULONGLONG cfgmap;

	if (type == MapType::Auto)
		return;

	try
	{
		FindCFGMap(cfgmap, type);
	}
	catch (...)
	{
		return;
	}

	dprintf(
		"CFG Map%s: %llx - %llx (%llx)\n",
		(type == MapType::Cfg32 ? "32" : "64"),
		cfgmap,
		cfgmap + (type == MapType::Cfg32 ? MAX_CFGMAP32_SIZE : MAX_CFGMAP64_SIZE),
		(type == MapType::Cfg32 ? MAX_CFGMAP32_SIZE : MAX_CFGMAP64_SIZE)
	);
}

DECLARE_API(cfgmap)
{
	try
	{
		DumpProcessCFGMap(MapType::Cfg32);
		DumpProcessCFGMap(MapType::Cfg64);
	}
	catch (Exception& e)
	{
		dprintf("Error: %s\n", e.What());
	}
	catch (std::exception& e)
	{
		dprintf("STDError: %s\n", e.what());
	}
}
```

`cfgdump/cfgdump.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{76645DE8-8AE1-40F8-8796-AA45C2B063EB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>cfgdump</RootNamespace>
    <ProjectName>cfg</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CFGDUMP_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>cfg.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CFGDUMP_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;CFGDUMP_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>cfg.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;CFGDUMP_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>cfg.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="cfgdump.cpp" />
    <ClCompile Include="Helper.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cfg.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`cfgdump/cfgdump.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="cfgdump.cpp" />
    <ClCompile Include="Helper.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helper.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cfg.def" />
  </ItemGroup>
</Project>
```